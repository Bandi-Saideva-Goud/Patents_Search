{"patent_number": "US-6463517-B1", "publication_id": 73185734, "family_id": 24383804, "publication_date": "2002-10-08", "titles": [{"lang": "EN", "text": "Apparatus and method for generating virtual addresses for different memory models"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50392069\"><p>An apparatus and method for generating virtual addresses for different types of memory models using an existing address generation unit. A processor can be configured to operate using either a segmented memory model or a flat memory model according to an operating mode. When the processor is operating using a segmented memory model, it can use the base address of a segment register to calculate a virtual address. When the processor is operating using a flat memory model, it can use the base address of a pseudo segment register to calculate a virtual address. In this manner, the processor can use existing address generation techniques to generate a virtual address for either a segmented memory model or a flat memory model.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00001\" num=\"1\"><claim-text>1. A processor comprising:</claim-text><claim-text>a first register configured to store a segment selector identifying a segment descriptor including a first base address; </claim-text><claim-text>a second register including a second base address; </claim-text><claim-text>an address generation unit; </claim-text><claim-text>wherein said processor is configured to establish an operating mode responsive to an enable indication, a first operating mode indication, and a second operating mode indication, wherein said address generation unit is configured to generate a virtual address, wherein said virtual address is generated using said first base address in response to said operating mode corresponding to a first mode, and wherein said virtual address is generated using said second base address in response to said operating mode corresponding to a second mode. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00002\" num=\"2\"><claim-text>2. The processor of <claim-ref idref=\"US-6463517-B1-CLM-00001\">claim 1</claim-ref>, wherein said second base address comprises all zeros.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00003\" num=\"3\"><claim-text>3. The processor of <claim-ref idref=\"US-6463517-B1-CLM-00001\">claim 1</claim-ref>, wherein a first address size in said first mode is 32 or fewer bits, and wherein a second address size in said second mode is greater than 32 bits.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00004\" num=\"4\"><claim-text>4. The processor of <claim-ref idref=\"US-6463517-B1-CLM-00001\">claim 1</claim-ref>, wherein said address generation unit comprises:</claim-text><claim-text>a first adder; and </claim-text><claim-text>a second adder coupled to said first adder; </claim-text><claim-text>wherein in response to said operating mode corresponding to said first mode: </claim-text><claim-text>said first adder is configured to add said first base address to a displacement value to generate a first intermediate result and said second adder is configured to add said first intermediate result to a first base value and a first index value to generate said virtual address; </claim-text><claim-text>wherein in response to said operating mode corresponding to said second mode: </claim-text><claim-text>said first adder is configured to add a first portion of said second base address to said displacement value to generate a second intermediate result and said second adder is configured to add a concatenation of said second intermediate result and a second portion of said second base address to a second base value and a second index value to generate said virtual address. </claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00005\" num=\"5\"><claim-text>5. The processor of <claim-ref idref=\"US-6463517-B1-CLM-00004\">claim 4</claim-ref>,</claim-text><claim-text>wherein in response to said operating mode corresponding to said first mode: </claim-text><claim-text>said first adder is configured to generate said first intermediate result in a first clock cycle and said second adder is configured to generate said virtual address in a second clock cycle immediately following said first clock cycle; </claim-text><claim-text>wherein in response to said operating mode corresponding to said second mode: </claim-text><claim-text>said first adder is configured to generate said second intermediate result in said first clock cycle and said second adder is configured to generate said virtual address in said second clock cycle. </claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00006\" num=\"6\"><claim-text>6. The processor of <claim-ref idref=\"US-6463517-B1-CLM-00005\">claim 5</claim-ref>, wherein said first base value and said first index value each comprise 32 or fewer bits, and wherein said second base value and said second index value each comprise greater than 32 bits.</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00007\" num=\"7\"><claim-text>7. The processor of <claim-ref idref=\"US-6463517-B1-CLM-00006\">claim 6</claim-ref>,</claim-text><claim-text>wherein in response to said operating mode corresponding to said first mode: </claim-text><claim-text>said virtual address comprises 32 or fewer bits; </claim-text><claim-text>wherein in response to said operating mode corresponding to said second mode: </claim-text><claim-text>said virtual address comprises greater than 32 bits. </claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00008\" num=\"8\"><claim-text>8. The processor of <claim-ref idref=\"US-6463517-B1-CLM-00001\">claim 1</claim-ref>, wherein a prefix of said instruction can change said operating mode from said first mode to said second mode or from said second mode to said first mode.</claim-text></claim>"}, {"num": 9, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00009\" num=\"9\"><claim-text>9. The processor of <claim-ref idref=\"US-6463517-B1-CLM-00001\">claim 1</claim-ref>, wherein said second register comprises a non-architected register.</claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00010\" num=\"10\"><claim-text>10. A method comprising:</claim-text><claim-text>determining whether a processor is operating in a first mode according to a first mode indication, a second mode indication, and an enable indication; </claim-text><claim-text>generating a virtual address corresponding to an instruction using a first base address from a first register in response to said processor not operating in said first mode; and </claim-text><claim-text>generating said virtual address using a second base address from a second register in response to said processor operating in said first mode. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00011\" num=\"11\"><claim-text>11. The method of <claim-ref idref=\"US-6463517-B1-CLM-00010\">claim 10</claim-ref>, wherein said second base address comprises all zeros.</claim-text></claim>"}, {"num": 12, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00012\" num=\"12\"><claim-text>12. The method of <claim-ref idref=\"US-6463517-B1-CLM-00010\">claim 10</claim-ref>, wherein a first address size in said first mode is 32 or fewer bits, and wherein a second address size in said second mode is greater than 32 bits.</claim-text></claim>"}, {"num": 13, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00013\" num=\"13\"><claim-text>13. The method of <claim-ref idref=\"US-6463517-B1-CLM-00010\">claim 10</claim-ref>,</claim-text><claim-text>wherein said generating said virtual address using said first base address comprises: </claim-text><claim-text>adding said first base address to a displacement value to generate a first intermediate result; and </claim-text><claim-text>adding said first intermediate result to a first base value and a first index value to generate said virtual address; </claim-text><claim-text>wherein said generating said virtual address using said second base address comprises: </claim-text><claim-text>adding a first portion of said second base address to said displacement value to generate a second intermediate result; and </claim-text><claim-text>adding a concatenation of said second intermediate result and a second portion of said second base address to a second base value and a second index value to generate said virtual address. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00014\" num=\"14\"><claim-text>14. The method of <claim-ref idref=\"US-6463517-B1-CLM-00013\">claim 13</claim-ref>, wherein said</claim-text><claim-text>wherein said generating said virtual address using said first base address further comprises: </claim-text><claim-text>generating said first intermediate result in a first clock cycle; and </claim-text><claim-text>generating said virtual address in a second clock cycle immediately following said first clock cycle; </claim-text><claim-text>wherein said generating said virtual address using said second base address further comprises: </claim-text><claim-text>generating said second intermediate result in said first clock cycle; and </claim-text><claim-text>generating said virtual address in said second clock cycle. </claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00015\" num=\"15\"><claim-text>15. The method of <claim-ref idref=\"US-6463517-B1-CLM-00014\">claim 14</claim-ref>, wherein said first base value and said first index value each comprise 32 or fewer bits, and wherein said second base value and said second index value each comprise greater than 32 bits.</claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00016\" num=\"16\"><claim-text>16. The method of <claim-ref idref=\"US-6463517-B1-CLM-00015\">claim 15</claim-ref>,</claim-text><claim-text>wherein in response to said processor not operating in said first mode: </claim-text><claim-text>said virtual address comprises 32 or fewer bits; </claim-text><claim-text>wherein in response to said processor operating in said first mode: </claim-text><claim-text>said virtual address comprises greater than 32 bits. </claim-text></claim>"}, {"num": 17, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00017\" num=\"17\"><claim-text>17. The method of <claim-ref idref=\"US-6463517-B1-CLM-00010\">claim 10</claim-ref>, further comprising:</claim-text><claim-text>changing said operating mode from said first mode to said second mode or from said second mode to said first mode in response to a prefix of said instruction. </claim-text></claim>"}, {"num": 18, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00018\" num=\"18\"><claim-text>18. The method of <claim-ref idref=\"US-6463517-B1-CLM-00010\">claim 10</claim-ref>, wherein said second register comprises a non-architected register.</claim-text></claim>"}, {"num": 19, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00019\" num=\"19\"><claim-text>19. A computer system comprising:</claim-text><claim-text>a microprocessor including: </claim-text><claim-text>a first register configured to store a segment selector identifying a segment descriptor including a first base address; </claim-text><claim-text>a second register including a second base address; </claim-text><claim-text>an address generation unit; </claim-text><claim-text>wherein said processor is configured to establish an operating mode responsive to an enable indication, a first operating mode indication, and a second operating mode indication, wherein said address generation unit is configured to generate a virtual address, wherein said virtual address is generated using said first base address in response to said operating mode corresponding to a first mode, and wherein said virtual address is generated using said second base address in response to said operating mode corresponding to a second mode; and </claim-text><claim-text>an input/output (I/O) device coupled to said microprocessor and to another computer system, wherein said I/O device is configured to communicate between said microprocessor and said another computer system. </claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6463517-B1-CLM-00020\" num=\"20\"><claim-text>20. The computer system of <claim-ref idref=\"US-6463517-B1-CLM-00019\">claim 19</claim-ref>, wherein said I/O device comprises a modem.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53648387\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention is related to the field of processors and, more particularly, to generating addresses in processors.</p><p>2. Description of the Related Art</p><p>The x86 architecture (also known as the IA-32 architecture) has enjoyed widespread acceptance and success in the marketplace. Accordingly, it is advantageous to design processors according to the x86 architecture. Such processors may benefit from the large body of software written to the x86 architecture (since such processors may execute the software and thus computer systems employing the processors may enjoy increased acceptance in the market due to the large amount of available software).</p><p>As computer systems have continued to evolve, 64 bit address size (and sometimes operand size) has become desirable. A larger address size allows for programs having a larger memory footprint (the amount of memory occupied by the instructions in the program and the data operated upon by the program) to operate within the memory space. A larger operand size allows for operating upon larger operands, or for more precision in operands. More powerful applications and/or operating systems may be possible using 64 bit address and/or operand sizes.</p><p>Unfortunately, the x86 architecture is limited to a maximum 32 bit operand size and 32 bit address size. The operand size refers to the number of bits operated upon by the processor (e.g. the number of bits in a source or destination operand). The address size refers to the number of bits in an address generated by the processor. Thus, processors employing the x86 architecture may not serve the needs of applications which may benefit from 64 bit address or operand sizes.</p><p>The x86 architecture can operate using a segmented memory model. When using address sizes of 64 bits, however, a flat memory model may be desirable. The process of generating virtual addresses in a flat memory model can differ from the process of generating virtual addresses in a segmented memory model. Accordingly, for a processor to be able to operate using a flat memory model and a segmented memory model, it must be able to generate virtual addresses for either type of model. It would be desirable for a processor to be able to generate virtual addresses for either a flat memory model or a segmented memory model using existing address generation techniques.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by an apparatus and method for generating virtual addresses for different types of memory models using an existing address generation unit. A processor can be configured to operate using either a segmented memory model or a flat memory model according to an operating mode. When the processor is operating using a segmented memory model, it can use the base address of a segment register to calculate a virtual address. When the processor is operating using a flat memory model, it can use the base address of a pseudo segment register to calculate a virtual address. In one embodiment, this base address can be zero. In this manner, the processor can use existing address generation techniques to generate a virtual address for either a segmented memory model or a flat memory model. More particularly, a segment register and a pseudo segment register can be located in a register file such that a processor can read a value from the register file to perform address generation regardless of the operating mode.</p><p>In one embodiment, a processor can include a segment register that stores a segment descriptor and a pseudo segment register that stores a base address. The segment descriptor includes a base address, a first operating mode indication, and a second operating mode indication. The first and second operating mode indications can be used by the processor along with an enable indication in a control register to establish an operating mode. The operating mode can indicate whether the processor is currently using a segmented memory model or a flat memory model. If the processor is using a segmented memory model, it can convey the base address from the segment register to an address generation unit to generate a virtual address. If the processor is using a flat memory model, it can convey the base address from the pseudo segment register to the address generation unit to generate a virtual address.</p><p>The use of the apparatus and method described herein may advantageously allow a processor to generate virtual addresses for either a segmented memory model or a flat memory model using existing address generation techniques.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of one embodiment of a processor.</p><p>FIG. 2 is a block diagram of one embodiment of a segment descriptor for 32/64 mode.</p><p>FIG. 3 is a block diagram of one embodiment of a segment descriptor for compatibility mode.</p><p>FIG. 4 is a block diagram of operation in compatibility mode and in legacy mode according to one embodiment of the processor shown in FIG. <b>1</b>.</p><p>FIG. 5 is a table illustrating one embodiment of operating modes as a function of segment descriptor and control register values.</p><p>FIG. 6 is a block diagram of one embodiment of a register.</p><p>FIG. 7 is a block diagram of one embodiment of a processor including an address generation unit.</p><p>FIG. 8<i>a </i>is a block diagram of one embodiment of a portion of a segment descriptor table address.</p><p>FIG. 8<i>b </i>is a block diagram of one embodiment of a displacement value.</p><p>FIG. 8<i>c </i>is a block diagram of one embodiment of descriptor tables in a memory.</p><p>FIG. 9 is a flow chart illustrating a method of generating 64 bit addresses.</p><p>FIG. 10 is a flow chart illustrating a method of generating addresses in a 32/64 mode.</p><p>FIG. 11 is a block diagram of one embodiment of a computer system including the processor shown in FIG. <b>1</b>.</p><p>FIG. 12 is a block diagram of another embodiment of a computer system including the processor shown in FIG. <b>1</b>.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</h4><p>Turning now to FIG. 1, a block diagram illustrating one embodiment of a processor <b>10</b> is shown. Other embodiments are possible and contemplated. In the embodiment of FIG. 1, processor <b>10</b> includes an instruction cache <b>12</b>, an execution core <b>14</b>, a data cache <b>16</b>, an external interface unit <b>18</b>, a memory management unit (MMU) <b>20</b>, and a register file <b>22</b>. In the illustrated embodiment, MMU <b>20</b> includes a set of segment registers <b>24</b>, a first control register <b>26</b>, a second control register <b>28</b>, a local descriptor table register (LDTR) <b>30</b>, and a global descriptor table register (GDTR) <b>32</b>. Instruction cache <b>12</b> is coupled to external interface unit <b>18</b>, execution core <b>14</b>, and MMU <b>20</b>. Execution core <b>14</b> is further coupled to MMU <b>20</b>, register file <b>22</b>, and data cache <b>16</b>. Data cache <b>16</b> is further coupled to MMU <b>20</b> and external interface unit <b>18</b>. External interface unit <b>18</b> is further coupled to MMU <b>20</b> and to an external interface.</p><p>Generally speaking, processor <b>10</b> employs a processor architecture compatible with the x86 architecture and including additional architectural features to support 64 bit processing. Processor <b>10</b> is configured to establish an operating mode in response to information stored in a code segment descriptor corresponding to the currently executing code and further in response to one or more enable indications stored in one or more control registers. As used herein, an \u201coperating mode\u201d specifies default values for various programmably selectable processor attributes. For example, the operating mode may specify a default operand size and a default address size. The default operand size specifies the number of bits in an operand of an instruction, unless an instruction's encoding overrides the default. The default address size specifies the number of bits in an address of a memory operand of an instruction, unless an instruction's encoding overrides the default. The default address size specifies the size of at least the virtual address of memory operands, and may also specify the size of the physical address. Alternatively, the size of the physical address may be independent of the default address size and may instead be dependent on the LME bit described below (e.g. the physical address may be 32 bits if the LME bit is clear and an implementation-dependent size greater than 32 bits and less than 64 bits if the LME bit is set) or on another control bit (e.g. the physical address extension bit, or PAE bit, in another control register). As used herein, a \u201cvirtual address\u201d is an address generated prior to translation through an address translation mechanism (e.g. a paging mechanism) to a \u201cphysical address\u201d, which is the address actually used to access a memory. Additionally, as used herein, a \u201csegment descriptor\u201d is a data structure created by software and used by the processor to define access control and status for a segment of memory. A \u201csegment descriptor table\u201d is a table in memory having multiple entries, each entry capable of storing a segment descriptor.</p><p>In the illustrated embodiment, MMU <b>20</b> generates an operating mode and conveys the operating mode to execution core <b>14</b>. Execution core <b>14</b> executes instructions using the operating mode. More particularly, execution core <b>14</b> fetches operands having the default operand size from register file <b>22</b> or memory (through data cache <b>16</b>, if the memory operands are cacheable and hit therein, or through external interface unit <b>18</b> if the memory operands are noncacheable or miss data cache <b>16</b>) unless a particular instruction's encoding overrides the default operand size, in which case the overriding operand size is used. Similarly, execution core <b>14</b> generates addresses of memory operands, wherein the addresses have the default address size unless a particular instruction's encoding overrides the default address size, in which case the overriding address size is used. In other embodiments, the information used to generate the operating mode may be shadowed locally in the portions of processor <b>10</b> which use the operating mode (e.g. execution core <b>14</b>), and the operating mode may be determined from the local shadow copies.</p><p>As mentioned above, MMU <b>20</b> generates the operating mode responsive to a code segment descriptor corresponding to the code being executed and further responsive to one or more values in control registers. Information from the code segment descriptor is stored in one of the segment registers <b>24</b> (a register referred to as CS, or code segment). Additionally, control register <b>26</b> stores an enable indication (LME) which is used to enable an operating mode in which the default address size is greater than 32 bits (\u201c32/64 mode\u201d) as well as certain compatibility modes for the 32 bit and 16 bit operating modes. The default operand size may be 32 bits in 32/64 mode, but instructions may override the default 32 bit operand size with a 64 bit operand size when desired. If the LME indication is in an enabled state, then 32/64 mode may be used in addition to 32 bit and 16 bit modes. If the LME indication is in a disabled state, then 32/64 mode is disabled. In one embodiment, the default address size in 32/64 mode may be implementation-dependent but may be any value up to and including 64 bits. Furthermore, the size of the virtual address may differ in a given implementation from the size of the physical address in that implementation.</p><p>It is noted that enable indications may be described herein as bits with the enabled state being the set state of the bit and the disabled state being the cleared state of the bit. However, other encodings are possible, including encodings in which multiple bits are used and encodings in which the enabled state is the clear state and the disabled state is the set state. Accordingly, the remainder of this description may refer to the LME indication in control register <b>26</b> as the LME bit, with the enabled state being set and the disabled state being clear. However, other encodings of the LME indication are contemplated, as set forth above.</p><p>Segment registers <b>24</b> store information from the segment descriptors currently being used by the code being executed by processor <b>10</b>. As mentioned above, CS is one of segment registers <b>24</b> and specifies the code segment of memory. The code segment stores the code being executed. Other segment registers may define various data segments (e.g. a stack data segment defined by the SS segment register, and up to four data segments defined by the DS, ES, FS, and GS segment registers). FIG. 1 illustrates the contents of an exemplary segment register <b>24</b>A, including a selector field <b>24</b>AA and a descriptor field <b>24</b>AB. Selector field <b>24</b>AA is loaded with a segment selector to activate a particular segment in response to certain segment load instructions executed by execution core <b>14</b>. The segment selector identifies the segment descriptor in a segment descriptor table in memory. More particularly, processor <b>10</b> may employ two segment descriptor tables: a local descriptor table and a global descriptor table. The base address of the local descriptor table is stored in the LDTR <b>30</b>. Similarly, the base address of the global descriptor table is stored in GDTR <b>32</b>. A bit within the segment selector (the table indicator bit) selects the descriptor table, and the remainder of the segment selector is used as an index into the selected table. When an instruction loads a segment selector into one of segment registers <b>24</b>, MMU <b>20</b> reads the corresponding segment descriptor from the selected segment descriptor table and stores information from the segment descriptor into the segment descriptor field (e.g. segment descriptor field <b>24</b>AB for segment register <b>24</b>A). The information stored in the segment descriptor field may comprise any suitable subset of the segment descriptor, including all of the segment descriptor, if desired. Additionally, other information derived from the segment descriptor or other sources may be stored in the segment descriptor field, if desired. For example, an embodiment may decode the operating mode indications from the code segment descriptor and store the decoded value rather than the original values of the operating mode indications. If an instruction causes CS to be loaded with a segment selector, the code segment may change and thus the operating mode of processor <b>10</b> may change.</p><p>In one embodiment, the CS segment register is used in 32/64 mode. The data segment registers are ignored. In 16 and 32 bit modes, the code segment and data segments may be active. Furthermore, a second enable indication (PE) in control register <b>28</b> may affect the operation of MMU <b>20</b>. The PE enable indication may be used to enable protected mode, in which segmentation and/or paging address translation mechanisms may be used. If the PE enable indication is in the disabled state, segmentation and paging mechanisms are disabled and processor <b>10</b> is in \u201creal mode\u201d (in which addresses generated by execution core <b>14</b> are physical addresses). Similar to the LME indication, the PE indication may be a bit in which the enabled state is the bit being set and the disabled state is the bit being clear. However, other embodiments are contemplated as described above.</p><p>It is noted that MMU <b>20</b> may employ additional hardware mechanisms, as desired. For example, MMU <b>20</b> may include paging hardware to implement paging address translation from virtual addresses to physical addresses. The paging hardware may include a translation lookaside buffer (TLB) to store page translations.</p><p>It is noted that control registers <b>26</b> and <b>28</b> may be implemented as architected control registers (e.g. control register <b>26</b> may be CR<b>4</b> and control register <b>28</b> may be CR<b>0</b>). Alternatively, one or both of the control registers may be implemented as model specific registers to allow for other uses of the architected control registers without interfering with 32/64 mode.</p><p>Generally, instruction cache <b>12</b> is a high speed cache memory for storing instruction bytes. Execution core <b>14</b> fetches instructions from instruction cache <b>12</b> for execution. Instruction cache <b>12</b> may employ any suitable cache organization, including direct-mapped, set associative, and fully associative configurations. If an instruction fetch misses in instruction cache <b>12</b>, instruction cache <b>12</b> may communicate with external interface unit <b>18</b> to fill the missing cache line into instruction cache <b>12</b>. Additionally, instruction cache <b>12</b> may communicate with MMU <b>20</b> to receive physical address translations for virtual addresses fetched from instruction cache <b>12</b>.</p><p>Execution core <b>14</b> executes the instructions fetched from instruction cache <b>12</b>. Execution core <b>14</b> fetches register operands from register file <b>22</b> and updates destination registers in register file <b>22</b>. The size of the register operands is controlled by the operating mode and any overrides of the operating mode for a particular instruction. Similarly, execution core <b>14</b> fetches memory operands from data cache <b>16</b> and updates destination memory locations in data cache <b>16</b>, subject to the cacheability of the memory operands and hitting in data cache <b>16</b>. The size of the memory operands is similarly controlled by the operating mode and any overrides of the operating mode for a particular instruction. Furthermore, the size of the addresses of the memory operands generated by execution core <b>14</b> is controlled by the operating mode and any overrides of the operating mode for a particular instruction.</p><p>Execution core <b>14</b> may employ any suitable construction. For example, execution core <b>14</b> may be a superpipelined core, a superscalar core, or a combination thereof Execution core <b>14</b> may employ out of order speculative execution or in order execution, according to design choice.</p><p>Register file <b>22</b> may include 64 bit registers which may be accessed as 64 bit, 32 bit, 16 bit, or 8 bit registers as indicated by the operating mode of processor <b>10</b> and any overrides for a particular instruction. The register format for one embodiment is described below with respect to FIG. <b>7</b>. The registers included in register file <b>22</b> may include the LEAX, LEBX, LECX, LEDX, LEDI, LESI, LESP, and LEBP registers. Register file <b>22</b> may further include the LEIP register. Alternatively, execution core <b>14</b> may employ a form of register renaming in which any register within register file <b>22</b> may be mapped to an architected register. The number of registers in register file <b>22</b> may be implementation dependent for such an embodiment.</p><p>Data cache <b>16</b> is a high speed cache memory configured to store data. Data cache <b>16</b> may employ any suitable cache organization, including direct-mapped, set associative, and fully associative configurations. If a data fetch or update misses in data cache <b>16</b>, data cache <b>16</b> may communicate with external interface unit <b>18</b> to fill the missing cache line into data cache <b>16</b>. Additionally, if data cache <b>16</b> employs a writeback caching policy, updated cache lines which are being cast out of data cache <b>16</b> may be communicated to external interface unit <b>18</b> to be written back to memory. Data cache <b>16</b> may communicate with MMU <b>20</b> to receive physical address translations for virtual addresses presented to data cache <b>16</b>.</p><p>External interface unit <b>18</b> communicates with portions of the system external to processor <b>10</b>. External interface unit <b>18</b> may communicate cache lines for instruction cache <b>12</b> and data cache <b>16</b> as described above, and may communicate with MMU <b>20</b> as well. For example, external interface unit <b>18</b> may access the segment descriptor tables and/or paging tables on behalf of MMU <b>20</b>.</p><p>It is noted that processor <b>10</b> may include an integrated level <b>2</b> (L<b>2</b>) cache, if desired. Furthermore, external interface unit <b>18</b> may be configured to communicate with a backside cache in addition to communicating with the system.</p><p>Turning now to FIG. 2, a block diagram of one embodiment of a code segment descriptor <b>40</b> for 32/64 mode is shown. Other embodiments are possible and contemplated. In the embodiment of FIG. 2, code segment descriptor <b>40</b> comprises 8 bytes with the most significant 4 bytes illustrated above the least significant 4 bytes. The most significant four bytes are stored at a numerically larger address than the least significant four bytes. The most significant bit of each group of four bytes is illustrated as bit <b>31</b> in FIG. 2 (and FIG. 3 below), and the least significant bit is illustrated as bit <b>0</b>. Short vertical lines within the four bytes delimit each bit, and the long vertical lines delimit a bit but also delimit a field (both in FIG. <b>2</b> and in FIG. <b>3</b>).</p><p>Unlike the 32 bit and 16 bit code segment descriptors illustrated in FIG. 3 below, code segment descriptor <b>40</b> does not include a base address or limit. Processor <b>10</b> employs a flat virtual address space for 32/64 mode (rather than the segmented linear address space employed in 32 bit and 16 bit modes). Accordingly, the portions of code segment descriptor <b>40</b> which would otherwise store the base address and limit are reserved in segment descriptor <b>40</b>. It is noted that a virtual address provided through segmentation may also be referred to herein as a \u201clinear address\u201d. The term \u201cvirtual address\u201d encompasses any address which is translated through a translation mechanism to a physical address actually used to address memory, including linear addresses and other virtual addresses generated in non-segmented architectures.</p><p>Segment descriptor <b>40</b> includes a D bit <b>42</b>, an L bit <b>44</b> (set to one for a 32/64 mode code segment), an available bit (AVL) <b>46</b>, a present (P) bit <b>48</b>, a descriptor privilege level (DPL) <b>50</b>, and a type field <b>52</b>. D bit <b>42</b> and L bit <b>44</b> are used to determine the operating mode of processor <b>10</b>, as illustrated in FIG. 5 below. AVL bit <b>46</b> is available for use by system software (e.g. the operating system). P bit <b>48</b> is used to indicate whether or not the segment is present in memory. If P bit <b>48</b> is set, the segment is present and code may be fetched from the segment. If P bit <b>48</b> is clear, the segment is not present and an exception is generated to load the segment into memory (e.g. from disk storage or through a network connection). The DPL indicates the privilege level of the segment. Processor <b>10</b> employs four privilege levels (encoded as <b>0</b> through <b>3</b> in the DPL field, with level <b>0</b> being the most privileged level). Certain instructions and processor resources (e.g. configuration and control registers) are only executable or accessible at the more privileged levels, and attempts to execute these instructions or access these resources at the lower privilege levels result in an exception. When information from code segment <b>40</b> is loaded into the CS segment register, the DPL becomes the current privilege level (CPL) of processor <b>10</b>. Type field <b>52</b> encodes the type of segment. For code segments, the most significant bit two bits of type field <b>52</b> may be set (the most significant bit distinguishing a code or data segment from a system segment, and the second most significant bit distinguishing a code segment from a data segment), and the remaining bits may encode additional segment type information (e.g. execute only, execute and read, or execute and read only, conforming, and whether or not the code segment has been accessed).</p><p>It is noted that, while several indications in the code segment descriptor are described as bits, with set and clear values having defined meanings, other embodiments may employ the opposite encodings and may use multiple bits, as desired. Thus, for example, the D bit <b>42</b> and the L bit <b>44</b> may each be an example of an operating mode indication which may be one or more bits as desired, similar to the discussion of enable indications above.</p><p>Turning now to FIG. 3, a block diagram of one embodiment of a code segment descriptor <b>54</b> for 32 and 16 bit compatibility mode is shown. Other embodiments are possible and contemplated. As with the embodiment of FIG. 2, code segment descriptor <b>54</b> comprises 8 bytes with the most significant 4 bytes illustrated above the least significant 4 bytes.</p><p>Code segment descriptor <b>54</b> includes D bit <b>42</b>, L bit <b>44</b>, AVL bit <b>46</b>, P bit <b>48</b>, DPL <b>50</b>, and type field <b>52</b> similar to the above description of code segment descriptor <b>40</b>. Additionally, code segment descriptor <b>54</b> includes a base address field (reference numerals <b>56</b>A, <b>56</b>B, and <b>56</b>C), a limit field (reference numerals <b>57</b>A and <b>57</b>B) and a G bit <b>58</b>. The base address field stores a base address which is added to the logical fetch address (stored in the LEIP register) to form the linear address of an instruction, which may then optionally be translated to a physical address through a paging translation mechanism. The limit field stores a segment limit which defines the size of the segment. Attempts to access a byte at a logical address greater than the segment limit are disallowed and cause an exception. G bit <b>58</b> determines the scaling of the segment limit field. If G bit <b>58</b> is set the limit is scaled to 4K byte pages (e.g. 12 least significant zeros are appended to the limit in the limit field). If G bit <b>58</b> is clear, the limit is used as is.</p><p>It is noted that code segment descriptors for 32 and 16 bit modes when 32/64 mode is not enabled via the LME bit in control register <b>26</b> may be similar to code segment descriptor <b>54</b>, except the L bit is reserved and defined to be zero. It is further noted that, in 32 and 16 bit modes (both compatibility mode with the LME bit set and modes with the LME bit clear) according to one embodiment, data segments are used as well. Data segment descriptors may be similar to code segment descriptor <b>54</b>, except that the D bit <b>42</b> is defined to indicate the upper bound of the segment or to define the default stack size (for stack segments).</p><p>Turning next to FIG. 4, a diagram illustrating exemplary uses of the LME bit in control register <b>26</b> and the compatibility modes to allow for a high degree of flexibility in implementing the 32/64 mode and the 32 and 16 bit modes is shown. A box <b>60</b> illustrates exemplary operation when the LME bit is set, and a box <b>62</b> illustrates exemplary operation when the LME bit is clear.</p><p>As illustrated in box <b>60</b>, the compatibility modes supported when the LME bit is set may allow for a 64 bit operating system (i.e. an operating system designed to take advantage of the virtual and physical address spaces in excess of 32 bits and/or data operands of 64 bits) to operate with a 32 bit application program (i.e. an application program written using 32 bit operand and address sizes). The code segment for the operating system may be defined by the 32/64 mode code segment descriptor <b>40</b> illustrated in FIG. 2, and thus the L bit may be set. Accordingly, the operating system may take advantage of the expanded virtual address space and physical address space for the operating system code and the data structures maintained by the operating system (including, e.g. the segment descriptor tables and the paging translation tables). The operating system may also use the 64 bit data type defined in 32/64 mode using instruction encodings which override the default 32 bit operand size. Furthermore, the operating system may launch a 32 bit application program by establishing one or more 32 bit compatibility mode segment descriptors (L bit cleared, D bit set, e.g. segment descriptor <b>54</b> shown in FIG. 2) in the segment descriptor table and branching into one of the compatibility mode segments. Similarly, the operating system may launch a 16 bit application program by establishing one or more 16 bit compatibility mode segment descriptors (L bit cleared, D bit cleared, e.g. segment descriptor <b>54</b> shown in FIG. 2) in the segment descriptor table and branching into one of the compatibility mode segments. Accordingly, a 64 bit operating system may retain the ability to execute existing 32 bit and 16 bit application programs in the compatibility mode. A particular application program may be ported to 32/64 mode if the expanded capabilities are desired for that program, or may remain 32 bit or 16 bit.</p><p>While processor <b>10</b> is executing the 32 bit application program, the operating mode of processor <b>10</b> is 32 bit. Thus, the application program may generally execute in the same fashion as it does in 32 bit mode with the LME bit clear (e.g. when the operating system is a 32 bit operating system as well). However, the application program may call an operating system service, experience an exception, or terminate. In each of these cases, processor <b>10</b> may return to executing operating system code (as illustrated by arrow <b>64</b> in FIG. <b>4</b>). Since the operating system code operates in 32/64 mode, the address of the operating system service routine, exception handler, etc. may exceed 32 bits. Thus, processor <b>10</b> may need to generate an address greater than 32 bits prior to returning to the operating system code. The LME bit provides processor <b>10</b> with an indication that the operating system may be operating in 32/64 mode even though the current operating mode is 32 bit, and thus processor <b>10</b> may provide the larger address space for operating system calls and exceptions.</p><p>In one embodiment, exceptions are handled using interrupt segment descriptors stored in an interrupt segment descriptor table. If the LME bit is set, the interrupt segment descriptors may be 16 byte entries which include a 64 bit address of the operating system routine which handles the exception. If the LME bit is clear, the interrupt segment descriptors may be eight byte entries which include a 32 bit address. Accordingly, processor <b>10</b> accesses the interrupt descriptor table responsive to the LME indication (i.e. reading a 16 byte entry if the LME bit is set and reading an eight byte entry if the LME bit is clear). Therefore, exceptions may be handled by the 64 bit operating system even though the application program is executing in 32 bit compatibility mode. Furthermore, processor <b>10</b> supports a 32 bit (or 16 bit) operating system if the LME bit is clear.</p><p>Similarly, the call mechanisms within processor <b>10</b> may operate in different fashions based on the state of the LME bit. Since the operating system typically executes at a higher privilege level than the application program, transfers from the application program to the operating system are carefully controlled to ensure that the application program is only able to execute permitted operating system routines. More generally, changes in privilege level are carefully controlled. In one embodiment, processor <b>10</b> may support at least two mechanisms for performing operating system calls. One method may be through a call gate in the segment descriptor tables (described in more detail below). Another method may be the SYSCALL instruction supported by processor <b>10</b>, which uses a model specific register as the source of the address of the operating system routine. Updating the model specific registers is a privileged operation, and thus only code executing at a higher privilege level (e.g. operating system code) may establish the address in the model specific register used by the SYSCALL instruction. For the SYSCALL method, a second model specific register may be defined to store the most significant 32 bits of the address of the operating system routine. Thus, if the LME bit is set, the address may be read from the two model specific registers. If the LME bit is clear, the address may be read from the model specific register storing the least significant 32 bits. Alternatively, the model specific register used by the SYSCALL instruction may be expanded to 64 bits and the address may be 32 bits (the least significant 32 bits of the model specific register) or 64 bits based on the state of the LME bit.</p><p>As illustrated above, having the LME bit set may allow for processor <b>10</b> to operate in a system in which the operating system is 64 bit and one or more application programs are not 64 bit (e.g. 32 bit as shown or 16 bit, which operates in a similar fashion to the above description). Additionally, as illustrated by box <b>62</b>, having the LME bit clear may allow for processor <b>10</b> to operate in 32 bit or 16 bit modes compatible with the x86 architecture. As described above, the mechanisms for handling exceptions and operating system calls are designed to handle the LME bit being set or clear, and thus the 32 bit and 16 bit modes may operate unmodified, even though processor <b>10</b> is capable of operating in 32/64 mode. Furthermore, by providing the x86 compatible 16 and 32 bit modes when the LME bit is clear, (and ignoring the L bit, which is reserved in these modes) processor <b>10</b> may operate in a system in which the L bit is defined for some other purpose than for 32/64 mode and may still support 32/64 mode if the LME bit is set. Accordingly, a system employing a 32 bit operating system and 32 bit or 16 bit application programs may employ processor <b>10</b>. Subsequently, the system could be upgraded to a 64 bit operating system without having to change processor <b>10</b>.</p><p>Not illustrated in FIG. 4 is a 64 bit operating system and a 64 bit application program operating with the LME bit set. The mechanisms for calling operating system routines described above for the 64 bit operating system and 32 bit application program may apply equally to the 64 bit application program as well. Additionally, call gates which support 64 bits of offset are supported (as will be described in more detail below).</p><p>Turning next to FIG. 5, a table <b>70</b> is shown illustrating the states of the LME bit, the L bit in the code segment descriptor, and the D bit in the code segment descriptor and the corresponding operating mode of processor <b>10</b> according to one embodiment of processor <b>10</b>. Other embodiments are possible and contemplated. As table <b>70</b> illustrates, if the LME bit is clear, then the L bit is reserved (and defined to be zero). However, processor <b>10</b> may treat the L bit as a don't care if the LME bit is clear. Thus, the x86 compatible 16 bit and 32 bit modes may be provided by processor <b>10</b> if the LME bit is clear. If the LME bit is set and the L bit in the code segment is clear, then a compatibility operating mode is established by processor <b>10</b> and the D bit selects 16 bit or 32 bit mode. If the LME bit and the L bit are set and the D bit is clear, 32/64 mode is selected for processor <b>10</b>. Finally, the mode which would be selected if the LME, L and D bits are all set is reserved.</p><p>As mentioned above, the 32/64 operating mode includes a default address size in excess of 32 bits (implementation dependent but up to 64 bits) and a default operand size of 32 bits. The default operand size of 32 bits may be overridden to 64 bits via a particular instruction's encoding. The default operand size of 32 bits is selected to minimize average instruction length (since overriding to 64 bits involves including an instruction prefix in the instruction encoding which may increase the instruction length) for programs in which 32 bits are sufficient for many of the data manipulations performed by the program. For such programs (which may be a substantial number of the programs currently in existence), moving to a 64 bit operand size may actually reduce the execution performance achieved by the program (i.e. increased execution time). In part, this reduction may be attributable to the doubling in size in memory of the data structures used by the program when 64 bit values are stored. If 32 bits is sufficient, these data structures would store 32 bit values, Thus, the number of bytes accessed when the data structure is accessed increases if 64 bit values are used where 32 bit values would be sufficient, and the increased memory bandwidth (and increased cache space occupied by each value) may cause increased execution time. Accordingly, 32 bits is selected as the default operand size and the default may be overridden via the encoding of a particular instruction.</p><p>Turning now to FIG. 6, a diagram illustrating one embodiment of the LEAX register <b>74</b> is shown. Other registers within register file <b>22</b> may be similar. Other embodiments are possible and contemplated. In the embodiment of FIG. 6, register <b>74</b> includes 64 bits, with the most significant bit labeled as bit <b>63</b> and the least significant bit labeled as bit <b>0</b>. FIG. 6 illustrates the portions of the LEAX register accessed based upon the operand size of an instruction (if the A register is selected as an operand). More particularly, the entirety of register <b>74</b> is accessed if the operand size is 64 bits (as illustrated by the brace labeled \u201cLEAX\u201d in FIG. <b>6</b>). If the operand size is 32 bits, bits <b>31</b>:<b>0</b> of register <b>74</b> are accessed (as illustrated by the brace labeled \u201cEAX\u201d in FIG. <b>6</b>). If the operand size is 16 bits, bits <b>16</b>:<b>0</b> of the register are accessed (as illustrated by the brace labeled \u201cAX\u201d in FIG. <b>6</b>). The above operand sizes may be selected based on the operating mode and the inclusion of any override prefixes. However, certain instruction opcodes are defined which access an eight bit register (AH or AL in FIG. <b>6</b>).</p><p>Turning next to FIG. 7, a block diagram of one embodiment of a processor including an address generation unit is shown. Other embodiments are possible and contemplated. FIG. 7 depicts decode unit <b>100</b>, register file <b>22</b>, segment registers <b>24</b>, pseudo-segment register <b>102</b>, LDTR <b>30</b>, GDTR <b>32</b>, and address generation unit (AGU) <b>110</b>. AGU <b>110</b> includes 32 bit adder <b>112</b> and 64 bit adder <b>114</b>. Interconnections among the elements of FIG. 7 are shown, although other interconnections are possible and contemplated.</p><p>AGU <b>110</b> can be configured to generate 64 bit addresses using adder <b>112</b> and adder <b>114</b>. In one embodiment, AGU <b>110</b> can generate 64 bit addresses when operating in 32/64 mode as described above and can generate other address sizes when operating in other modes. An instruction received by decode unit <b>100</b> can indicate the values to be used by AGU <b>110</b> to generate an address. These values can include an index value and a base value that can be specified by the instructions using register operands. The register operand or operands can be conveyed to register file <b>22</b>, and register file <b>22</b> can convey values corresponding to the operands to AGU <b>110</b>. The instruction can also specify a displacement value. The displacement value can be conveyed to AGU <b>110</b> as shown. In generating an address, an address value from segment registers <b>24</b>, pseudo-segment register <b>102</b>, LDTR <b>30</b> or GDTR <b>32</b> may be used. Segment registers <b>24</b>, pseudo-segment register <b>102</b>, LDTR <b>30</b> or GDTR <b>32</b> can provide the address value to AGU <b>110</b> as indicated.</p><p>In one embodiment, segmentation is disabled in 32/64 mode. Thus, in 32/64 mode, a flat address space model is used and the base address of a segment register <b>24</b> is not used to generate a virtual address. When the processor is operating in 32/64 mode, the base address of pseudo-segment register <b>102</b> can be used to generate the virtual address. In one embodiment, pseudo-segment register <b>102</b> is a non-architected register such that the register is not selectable via an instruction encoding. In addition, the base address of pseudo-segment register <b>102</b> can be set to zero such that this zero value can be used by AGU <b>110</b> to generate the virtual address. In this manner, additional hardware may not be needed in AGU <b>110</b> to generate virtual addresses in 32/64 mode even though segment base addresses from the architected segment registers are not used.</p><p>In 32/64 mode, AGU <b>110</b> can generate 64 bit virtual addresses. In one embodiment, adder <b>112</b> can add the least significant 32 bits of the base address from pseudo-segment register <b>102</b> to a displacement value to generate an intermediate result. Adder <b>114</b> can then add a concatenation of the intermediate result and the most significant 32 bits of the base address from pseudo-segment register <b>102</b> to a base value and an index value to generate a 64 bit virtual address. In one embodiment, the base value and the index value can be up to 64 bits in 32/64 mode. The base value or index value may also be 32, 16 or 8 bits. Adder <b>114</b> may generate the virtual address in a clock cycle immediately following the clock cycle that adder <b>112</b> generated the intermediate result.</p><p>When the processor is not operating in 32/64 mode, the processor can operate in a segmentation mode. Thus, the base address of a segment register <b>24</b> can be used for a virtual address generation. In one embodiment, this base address can be 32 or fewer bits. Adder <b>112</b> can add this base address to a displacement to generate an intermediate result. Adder <b>114</b> can then add the intermediate result to a base value and an index value. In one embodiment, the base value and the index value can be either 32, 16 or 8 bits when the processor is not operating in 32/64 mode. Adder <b>114</b> may generate the virtual address in a clock cycle immediately following the clock cycle that adder <b>112</b> generated the intermediate result.</p><p>As noted above, LDTR <b>30</b> and GDTR <b>32</b> can include addresses that indicate the base addresses of the local segment descriptor table and the global segment descriptor table, respectively. In one embodiment, these addresses can be 64 bit addresses if the LME bit is set so that the tables can be located anywhere in a memory space that is addressed using 64 bits. An address stored in either LDTR <b>30</b> or GDTR <b>32</b> can be referred to generally as a segment descriptor table address. In order to access a descriptor located in one of these tables, AGU <b>110</b> can generate a virtual address using the segment descriptor table address, a displacement value, an index value, and a base value.</p><p>AGU <b>110</b> can generate a virtual address using adder <b>112</b> and adder <b>114</b>. AGU <b>110</b> can receive a segment descriptor table address from LDTR <b>30</b> or GDTR <b>32</b> as well as a displacement value from decode <b>100</b>, an index value and a base value from register file <b>22</b>. Adder <b>112</b> can add the displacement value to a first portion of the segment descriptor table address to generate an intermediate result. In one embodiment, the first portion of the segment descriptor address can comprise the least significant 32 bits of the address. The intermediate result can then be concatenated with a second portion of the segment descriptor table address. In one embodiment, the second portion of the segment descriptor address can comprise the most significant 32 bits of the address. The concatenated result can be conveyed to adder <b>114</b>. Adder <b>114</b> can then add the concatenated result to the base value and the index value to generate a virtual address.</p><p>To insure that adder <b>112</b> does not generate a carry bit, the segment descriptor table address is required to be aligned on an address boundary and the displacement value is required not to exceed a maximum value. The address boundary can be an integer multiple of a fixed number of bytes.</p><p>In one embodiment, segment descriptor table addresses are required to be aligned on 16 byte boundaries, and the maximum value for displacement values is sixteen. This embodiment is illustrated in FIG. 8<i>a, </i>FIGS. 8<i>b, </i>and <b>8</b><i>c. </i></p><p>FIG. 8<i>a </i>depicts a portion of a segment descriptor table address <b>120</b>. By requiring segment descriptor table addresses to be aligned on 16 byte boundaries, the four least significant bits <b>124</b> of a segment descriptor table address will be zero. The remaining bits <b>122</b> of segment descriptor table address <b>120</b> can specify the base address of a corresponding descriptor table. It can be noted that another portion of segment descriptor table address <b>120</b>, not shown, can contain the most significant bits of the base address, such as bits <b>32</b> through <b>63</b>.</p><p>FIG. 8<i>b </i>depicts displacement value <b>130</b>. By limiting the displacement value to a maximum value of sixteen, the displacement value can be represented by the four least significant bits <b>134</b> of displacement value <b>130</b>. Accordingly, the bits of the displacement value above the fourth bit, collectively bits <b>132</b>, will be zero.</p><p>When adder <b>112</b> adds a displacement value <b>120</b> and a portion of a segment descriptor table address <b>130</b>, the zeros in the four least significant bits <b>124</b> ensure that a carry will not be generated in bits <b>3</b> through <b>0</b> and the zeros in bits <b>132</b> of the displacement value ensure that a carry will not be generated in bits <b>31</b> through <b>4</b>. Accordingly, the intermediate result generated by adding a displacement value <b>120</b> and a portion of a segment descriptor table address <b>130</b> can be concatenated with the remaining portion of the segment descriptor table address to create a 64 bit value. This 64 bit value can be added to an index value and a base value in adder <b>114</b> as indicated above to generate a 64 bit virtual address.</p><p>FIG. 8<i>c </i>depicts LDT <b>142</b> and GDT <b>144</b> as aligned on 16 byte boundaries in a 64 bit address space <b>140</b> (indicated by addresses <b>0</b> through FFFF FFFF FFFF FFFFh). Accordingly, the segment descriptor table addresses of LDTR <b>30</b> and GDTR <b>32</b> point to the base of LDT <b>142</b> and GDT <b>144</b>, respectively. In this manner, LDT <b>142</b> and GDT <b>144</b> can be located anywhere in address space <b>140</b> as long as they begin on a 16 byte boundary.</p><p>In the embodiment of FIG. 7, a fault can be generated if the segment descriptor table address is not properly aligned on an address boundary. In one embodiment, the fault can be generated by the processor itself, either in hardware or in software such as microcode. In another embodiment, the fault can be generated by an operating system running on the processor.</p><p>In one embodiment, the process of generating an address into a segment descriptor table can be handled by microcode or hardware to ensure that the displacement value does not exceed a maximum value.</p><p>In one embodiment, adder <b>112</b> can be configured to generate the intermediate result in a first clock cycle and adder <b>114</b> may be configured to generate the virtual address in a second clock cycle that immediately follows the first clock cycle. In this manner, the apparatus and method described herein may advantageously permit 64 bit addresses to be generated while minimizing the hardware needed to do so and permitting increased clock speeds in a processor. More specifically, adder <b>112</b> can comprise a 32 bit adder as opposed to a 64 bit adder and the generation of virtual addresses can be spread over two clock cycles to allow clock speeds to be increased.</p><p>It can be noted that FIG. 7 depicts a simplified portion of processor <b>10</b>. The processor may also include other pipeline stages between decode unit <b>100</b> and AGU <b>110</b> such as a reservation station or a scheduler.</p><p>Turning next to FIG. 9, a flow chart illustrating a method of generating 64 bit addresses is shown. Variations on the method are possible and contemplated. In FIG. 9, a determination is made as to whether a segment descriptor table address is aligned on an address boundary as indicated in block <b>180</b>. In one embodiment, this determination can be made in response to a segment descriptor table address being changed. If the segment descriptor table address is not aligned on the address boundary, then a fault is generated as indicated by block <b>182</b>.</p><p>If the segment descriptor table address is aligned on the address boundary, then a first portion of the segment descriptor table address is added to a displacement value to generate an intermediate result as indicated in block <b>184</b>. The intermediate result is concatenated with a second portion of the segment descriptor table address as indicated in block <b>186</b>. An index value, a base value, and the concatenation of the intermediate result and the second portion of the segment descriptor table address are added to generate a virtual address as indicated in block <b>188</b>.</p><p>Turning next to FIG. 10, a flow chart illustrating a method of generating addresses in a 32/64 mode is shown. Variations on the method are possible and contemplated. In FIG. 10, a determination is made as to whether a processor is operating in a 32/64 mode as indicated in block <b>190</b>. If the processor is operating in a 32/64 mode, then a pseudo-segment register value can be used to generate a virtual address as indicated in block <b>192</b>. If the processor is not operating in a 32/64 mode, then a segment register value can be used to generate the virtual address as indicated in block <b>194</b>.</p><p>Computer Systems</p><p>Turning now to FIG. 11, a block diagram of one embodiment of a computer system <b>200</b> including processor <b>10</b> coupled to a variety of system components through a bus bridge <b>202</b> is shown. Other embodiments are possible and contemplated. In the depicted system, a main memory <b>204</b> is coupled to bus bridge <b>202</b> through a memory bus <b>206</b>, and a graphics controller <b>208</b> is coupled to bus bridge <b>202</b> through an AGP bus <b>210</b>. Finally, a plurality of PCI devices <b>212</b>A-<b>212</b>B are coupled to bus bridge <b>202</b> through a PCI bus <b>214</b>. A secondary bus bridge <b>216</b> may further be provided to accommodate an electrical interface to one or more EISA or ISA devices <b>218</b> through an EISA/ISA bus <b>220</b>. Processor <b>10</b> is coupled to bus bridge <b>202</b> through a CPU bus <b>224</b> and to an optional L<b>2</b> cache <b>228</b>. Together, CPU bus <b>224</b> and the interface to L<b>2</b> cache <b>228</b> may comprise an external interface to which external interface unit <b>18</b> may couple.</p><p>Bus bridge <b>202</b> provides an interface between processor <b>10</b>, main memory <b>204</b>, graphics controller <b>208</b>, and devices attached to PCI bus <b>214</b>. When an operation is received from one of the devices connected to bus bridge <b>202</b>, bus bridge <b>202</b> identifies the target of the operation (e.g. a particular device or, in the case of PCI bus <b>214</b>, that the target is on PCI bus <b>214</b>). Bus bridge <b>202</b> routes the operation to the targeted device. Bus bridge <b>202</b> generally translates an operation from the protocol used by the source device or bus to the protocol used by the target device or bus.</p><p>In addition to providing an interface to an ISA/EISA bus for PCI bus <b>214</b>, secondary bus bridge <b>216</b> may further incorporate additional functionality, as desired. An input/output controller (not shown), either external from or integrated with secondary bus bridge <b>216</b>, may also be included within computer system <b>200</b> to provide operational support for a keyboard and mouse <b>222</b> and for various serial and parallel ports, as desired. An external cache unit (not shown) may further be coupled to CPU bus <b>224</b> between processor <b>10</b> and bus bridge <b>202</b> in other embodiments. Alternatively, the external cache may be coupled to bus bridge <b>202</b> and cache control logic for the external cache may be integrated into bus bridge <b>202</b>. L<b>2</b> cache <b>228</b> is further shown in a backside configuration to processor <b>10</b>. It is noted that L<b>2</b> cache <b>228</b> may be separate from processor <b>10</b>, integrated into a cartridge (e.g. slot <b>1</b> or slot A) with processor <b>10</b>, or even integrated onto a semiconductor substrate with processor <b>10</b>.</p><p>Main memory <b>204</b> is a memory in which application programs are stored and from which processor <b>10</b> primarily executes. A suitable main memory <b>204</b> comprises DRAM (Dynamic Random Access Memory). For example, a plurality of banks of SDRAM (Synchronous DRAM) or Rambus DRAM (RDRAM) may be suitable.</p><p>PCI devices <b>212</b>A-<b>212</b>B are illustrative of a variety of peripheral devices such as, for example, network interface cards, video accelerators, audio cards, hard or floppy disk drives or drive controllers, SCSI (Small Computer Systems Interface) adapters and telephony cards. Similarly, ISA device <b>218</b> is illustrative of various types of peripheral devices, such as a modem, a sound card, and a variety of data acquisition cards such as GPIB or field bus interface cards.</p><p>Graphics controller <b>208</b> is provided to control the rendering of text and images on a display <b>226</b>. Graphics controller <b>208</b> may embody a typical graphics accelerator generally known in the art to render three-dimensional data structures which can be effectively shifted into and from main memory <b>204</b>. Graphics controller <b>208</b> may therefore be a master of AGP bus <b>210</b> in that it can request and receive access to a target interface within bus bridge <b>202</b> to thereby obtain access to main memory <b>204</b>. A dedicated graphics bus accommodates rapid retrieval of data from main memory <b>204</b>. For certain operations, graphics controller <b>208</b> may further be configured to generate PCI protocol transactions on AGP bus <b>210</b>. The AGP interface of bus bridge <b>202</b> may thus include functionality to support both AGP protocol transactions as well as PCI protocol target and initiator transactions. Display <b>226</b> is any electronic display upon which an image or text can be presented. A suitable display <b>226</b> includes a cathode ray tube (\u201cCRT\u201d), a liquid crystal display (\u201cLCD\u201d), etc.</p><p>It is noted that, while the AGP, PCI, and ISA or EISA buses have been used as examples in the above description, any bus architectures may be substituted as desired. It is further noted that computer system <b>200</b> may be a multiprocessing computer system including additional processors (e.g. processor <b>10</b><i>a </i>shown as an optional component of computer system <b>200</b>). Processor <b>10</b><i>a </i>may be similar to processor <b>10</b>. More particularly, processor <b>10</b><i>a </i>may be an identical copy of processor <b>10</b>. Processor <b>10</b><i>a </i>may be connected to bus bridge <b>202</b> via an independent bus (as shown in FIG. 11) or may share CPU bus <b>224</b> with processor <b>10</b>. Furthermore, processor <b>10</b><i>a </i>may be coupled to an optional L<b>2</b> cache <b>228</b><i>a </i>similar to L<b>2</b> cache <b>228</b>.</p><p>Turning now to FIG. 12, another embodiment of a computer system <b>300</b> is shown. Other embodiments are possible and contemplated. In the embodiment of FIG. 12, computer system <b>300</b> includes several processing nodes <b>312</b>A, <b>312</b>B, <b>312</b>C, and <b>312</b>D. Each processing node is coupled to a respective memory <b>314</b>A-<b>314</b>D via a memory controller <b>316</b>A-<b>316</b>D included within each respective processing node <b>312</b>A-<b>312</b>D. Additionally, processing nodes <b>312</b>A-<b>312</b>D include interface logic used to communicate between the processing nodes <b>312</b>A-<b>312</b>D. For example, processing node <b>312</b>A includes interface logic <b>318</b>A for communicating with processing node <b>312</b>B, interface logic <b>318</b>B for communicating with processing node <b>312</b>C, and a third interface logic <b>318</b>C for communicating with yet another processing node (not shown). Similarly, processing node <b>312</b>B includes interface logic <b>318</b>D, <b>318</b>E, and <b>318</b>F; processing node <b>312</b>C includes interface logic <b>318</b>G, <b>318</b>H, and <b>318</b>I; and processing node <b>312</b>D includes interface logic <b>318</b>J, <b>318</b>K, and <b>318</b>L. Processing node <b>312</b>D is coupled to communicate with a plurality of input/output devices (e.g. devices <b>320</b>A-<b>320</b>B in a daisy chain configuration) via interface logic <b>318</b>L. Other processing nodes may communicate with other I/O devices in a similar fashion.</p><p>Processing nodes <b>312</b>A-<b>312</b>D implement a packet-based link for inter-processing node communication. In the present embodiment, the link is implemented as sets of unidirectional lines (e.g. lines <b>324</b>A are used to transmit packets from processing node <b>312</b>A to processing node <b>312</b>B and lines <b>324</b>B are used to transmit packets from processing node <b>312</b>B to processing node <b>312</b>A). Other sets of lines <b>324</b>C-<b>324</b>H are used to transmit packets between other processing nodes as illustrated in FIG. <b>12</b>. Generally, each set of lines <b>324</b> may include one or more data lines, one or more clock lines corresponding to the data lines, and one or more control lines indicating the type of packet being conveyed. The link may be operated in a cache coherent fashion for communication between processing nodes or in a noncoherent fashion for communication between a processing node and an I/O device (or a bus bridge to an I/O bus of conventional construction such as the PCI bus or ISA bus). Furthermore, the link may be operated in a non-coherent fashion using a daisy-chain structure between I/O devices as shown. It is noted that a packet to be transmitted from one processing node to another may pass through one or more intermediate nodes. For example, a packet transmitted by processing node <b>312</b>A to processing node <b>312</b>D may pass through either processing node <b>312</b>B or processing node <b>312</b>C as shown in FIG. <b>12</b>. Any suitable routing algorithm may be used. Other embodiments of computer system <b>300</b> may include more or fewer processing nodes then the embodiment shown in FIG. <b>12</b>.</p><p>Generally, the packets may be transmitted as one or more bit times on the lines <b>324</b> between nodes. A bit time may be the rising or falling edge of the clock signal on the corresponding clock lines. The packets may include command packets for initiating transactions, probe packets for maintaining cache coherency, and response packets from responding to probes and commands.</p><p>Processing nodes <b>312</b>A-<b>312</b>D, in addition to a memory controller and interface logic, may include one or more processors. Broadly speaking, a processing node comprises at least one processor and may optionally include a memory controller for communicating with a memory and other logic as desired. More particularly, each processing node <b>312</b>A-<b>312</b>D may comprise one or more copies of processor <b>10</b>. External interface unit <b>18</b> may includes the interface logic <b>318</b> within the node, as well as the memory controller <b>316</b>.</p><p>Memories <b>314</b>A-<b>314</b>D may comprise any suitable memory devices. For example, a memory <b>314</b>A-<b>314</b>D may comprise one or more RAMBUS DRAMs (RDRAMs), synchronous DRAMs (SDRAMs), static RAM, etc. The address space of computer system <b>300</b> is divided among memories <b>314</b>A-<b>314</b>D. Each processing node <b>312</b>A-<b>312</b>D may include a memory map used to determine which addresses are mapped to which memories <b>314</b>A-<b>314</b>D, and hence to which processing node <b>312</b>A-<b>312</b>D a memory request for a particular address should be routed. In one embodiment, the coherency point for an address within computer system <b>300</b> is the memory controller <b>316</b>A-<b>316</b>D coupled to the memory storing bytes corresponding to the address. In other words, the memory controller <b>316</b>A-<b>316</b>D is responsible for ensuring that each memory access to the corresponding memory <b>314</b>A-<b>314</b>D occurs in a cache coherent fashion. Memory controllers <b>316</b>A-<b>316</b>D may comprise control circuitry for interfacing to memories <b>314</b>A-<b>314</b>D. Additionally, memory controllers <b>316</b>A-<b>316</b>D may include request queues for queuing memory requests.</p><p>Generally, interface logic <b>318</b>A-<b>318</b>L may comprise a variety of buffers for receiving packets from the link and for buffering packets to be transmitted upon the link. Computer system <b>300</b> may employ any suitable flow control mechanism for transmitting packets. For example, in one embodiment, each interface logic <b>318</b> stores a count of the number of each type of buffer within the receiver at the other end of the link to which that interface logic is connected. The interface logic does not transmit a packet unless the receiving interface logic has a free buffer to store the packet. As a receiving buffer is freed by routing a packet onward, the receiving interface logic transmits a message to the sending interface logic to indicate that the buffer has been freed. Such a mechanism may be referred to as a \u201ccoupon-based\u201d system.</p><p>I/O devices <b>320</b>A-<b>320</b>B may be any suitable I/O devices. For example, I/O devices <b>320</b>A-<b>320</b>B may include network interface cards, video accelerators, audio cards, hard or floppy disk drives or drive controllers, SCSI (Small Computer Systems Interface) adapters and telephony cards, modems, sound cards, and a variety of data acquisition cards such as GPIB or field bus interface cards.</p><p>Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Kevin J.", "last_name": "McGrath", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}, {"first_name": "", "last_name": "ADVANCED MICRO DEVICES, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/10"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/10        20060101A I20051008RMUS"}, {"label": "G06F   9/318       20060101A I20051008RMEP"}, {"label": "G06F   9/355       20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711208"}, {"primary": false, "label": "711209"}, {"primary": false, "label": "712E09041"}, {"primary": false, "label": "711E12068"}, {"primary": false, "label": "712E09035"}], "ecla_classes": [{"label": "G06F   9/34X"}, {"label": "G06F   9/30X4"}, {"label": "G06F  12/10S"}], "cpc_classes": [{"label": "G06F   9/342"}, {"label": "G06F  12/109"}, {"label": "G06F   9/30189"}, {"label": "G06F  12/1036"}, {"label": "G06F   9/30189"}, {"label": "G06F   9/342"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "2000-06-15", "application_date": "2000-06-15", "family_members": [{"ucid": "US-6463517-B1", "titles": [{"lang": "EN", "text": "Apparatus and method for generating virtual addresses for different memory models"}]}]}