{"patent_number": "US-6591414-B2", "publication_id": 73480168, "family_id": 17694540, "publication_date": "2003-07-08", "titles": [{"lang": "EN", "text": "Binary program conversion apparatus, binary program conversion method and program recording medium"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50520281\"><p>A binary program conversion apparatus capable of converting an original binary program into a new binary program which runs at higher speed in a target computer having a cache memory. The binary program conversion apparatus comprises an executing part, a generating part and a producing part. The executing part executes the original binary program. The generating part generates executed blocks information indicating first instruction blocks which are executed by the executing part. The producing part produces, based on the executed blocks information generated by the generating part, the new binary program which contains second instruction blocks corresponding to the plural of the first instruction blocks and which causes, when being executed in the computer, the computer to store second instruction blocks corresponding to the first instruction blocks executed by the executing part at different locations of the cache memory.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00001\" num=\"1\"><claim-text>1. A binary program conversion apparatus, used for converting a first binary program which consists of a plurality of first instruction blocks into a second binary program which is executed in a computer having a cache memory, comprising:</claim-text><claim-text>executing means for executing the first instruction blocks of the first binary program after an additional area has been added to the first binary program, the additional area having a size of up to and including a size of the cache memory; </claim-text><claim-text>generating means for generating executed blocks information from the executed first instruction blocks; and </claim-text><claim-text>producing means for producing the second binary program from the executed blocks information, the second binary program comprising second instruction blocks corresponding to the first instruction blocks, ones of the second instruction blocks having been copied into the addition area </claim-text><claim-text>wherein </claim-text><claim-text>when the second binary program is executed in the computer, the computer stores the second instruction blocks corresponding to the executed first instruction blocks at locations where any other second instruction blocks are not stored within the cache memory, and </claim-text><claim-text>object code of the first binary program is used during a process of converting the second binary program from the first binary program. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00002\" num=\"2\"><claim-text>2. A binary program conversion apparatus according to <claim-ref idref=\"US-6591414-B2-CLM-00001\">claim 1</claim-ref>, wherein said producing means produces the second binary program including a part in which the second instruction blocks corresponding to the executed first instruction blocks are arranged successively.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00003\" num=\"3\"><claim-text>3. A binary program conversion apparatus according to <claim-ref idref=\"US-6591414-B2-CLM-00001\">claim 1</claim-ref>, further comprising:</claim-text><claim-text>creating means for creating a line data indicating lines of the cache memory which are to be used when the produced second binary program is executed in the computer; and </claim-text><claim-text>controlling means for controlling </claim-text><claim-text>said executing means so as to execute third instruction blocks of a third binary program, </claim-text><claim-text>said generating means so as to generate second executed blocks information from the executed third instruction blocks, and </claim-text><claim-text>said producing means so as to produce a fourth binary program from the second executed blocks information and the line data, the fourth binary program comprising fourth instruction blocks corresponding to the executed third instruction blocks, </claim-text><claim-text>wherein </claim-text><claim-text>when the fourth binary program is executed in the computer, the computer stores the fourth instruction blocks corresponding to the executed third instruction blocks at locations in lines of the cache memory except the lines indicated by the line data. </claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00004\" num=\"4\"><claim-text>4. A binary program conversion apparatus according to <claim-ref idref=\"US-6591414-B2-CLM-00001\">claim 1</claim-ref>, further comprising:</claim-text><claim-text>recognizing means for recognizing a frequency of use for data access of every line of the cache memory by monitoring running states of the executed first instruction blocks of the first binary program; and </claim-text><claim-text>selecting means for selecting from a recognition result of said recognizing means lines having the lowest frequency of use from all lines of the cache memory to use for storing the second instruction blocks corresponding to the executed first instruction blocks, and </claim-text><claim-text>wherein said producing means produces the second binary program which causes, when being executed in the computer, the computer to store the second instruction blocks corresponding to the executed first instruction blocks at locations in the lines selected by said selecting means. </claim-text></claim>"}, {"num": 5, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00005\" num=\"5\"><claim-text>5. A binary program conversion apparatus according to <claim-ref idref=\"US-6591414-B2-CLM-00002\">claim 2</claim-ref>, further comprising:</claim-text><claim-text>searching means for searching from the second binary program a second instruction block containing on its end a conditional branch instruction whose branch destination is set for a next second instruction block; and </claim-text><claim-text>changing means for changing a branch condition and the branch destination of the conditional branch instruction so that a transition from the searched second instruction block to the next second instruction block takes place without branching. </claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00006\" num=\"6\"><claim-text>6. A binary program conversion apparatus according to <claim-ref idref=\"US-6591414-B2-CLM-00001\">claim 1</claim-ref>, wherein said producing means produces the second binary program which causes, when being executed in the computer, the computer to store the second instruction blocks in the cache memory when the total size stored is within cache memory size, and wherein the second instruction blocks are selected according to the executing frequency of each block.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00007\" num=\"7\"><claim-text>7. The binary program conversion apparatus according to <claim-ref idref=\"US-6591414-B2-CLM-00001\">claim 1</claim-ref>, wherein said producing means produces the second binary program without using a symbol table of the first binary program.</claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00008\" num=\"8\"><claim-text>8. The binary program conversion apparatus according to <claim-ref idref=\"US-6591414-B2-CLM-00001\">claim 1</claim-ref>, further comprising securing means for securing the additional area in the first binary program, wherein</claim-text><claim-text>said executing means executes the first binary program having the secured additional area, and </claim-text><claim-text>said producing means further comprises copying ones of the first instruction blocks into the secured additional area of the first binary program using the executed blocks information such that the copied ones of the first instruction blocks in the secured additional area are executed. </claim-text></claim>"}, {"num": 9, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00009\" num=\"9\"><claim-text>9. The binary program conversion apparatus according to <claim-ref idref=\"US-6591414-B2-CLM-00001\">claim 1</claim-ref>, wherein ones of the first instruction blocks correspond to a same line in the cache memory, and ones of the second instruction blocks corresponding to the ones of the first instruction blocks correspond to different respective lines in the cache memory.</claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00010\" num=\"10\"><claim-text>10. A binary program conversion method, used for converting a first binary program having first instruction blocks into a second binary program which is executed in a computer having a cache memory, comprising:</claim-text><claim-text>executing the first instruction blocks of the first binary program after an additional area has been added to the first binary program, the additional area having a size of up to and including a size of the cache memory; </claim-text><claim-text>generating executed blocks information from the executed first instruction blocks; and </claim-text><claim-text>producing the second binary program from the executed blocks information, the second binary program comprising second instruction blocks corresponding to the first instruction blocks of the first binary program, ones of the second instruction blocks having been copied into the additional area, </claim-text><claim-text>wherein </claim-text><claim-text>when the second binary program is executed in the computer, the computer stores the second instruction blocks corresponding to the executed first instruction blocks at locations where any other second instruction blocks are not stored within the cache memory, and </claim-text><claim-text>object code of the first binary program is used during the process of converting the second binary program from the first binary program. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00011\" num=\"11\"><claim-text>11. A binary program conversion method according to <claim-ref idref=\"US-6591414-B2-CLM-00010\">claim 10</claim-ref>, wherein said producing comprises producing the second binary program including a part in which the second instruction blocks corresponding to the executed first instruction blocks are arranged successively.</claim-text></claim>"}, {"num": 12, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00012\" num=\"12\"><claim-text>12. A binary program conversion method according to <claim-ref idref=\"US-6591414-B2-CLM-00010\">claim 10</claim-ref>, further comprising:</claim-text><claim-text>creating a line data indicating lines of the cache memory which are to be used when the produced second binary program is executed in the computer; and </claim-text><claim-text>controlling </claim-text><claim-text>said executing executes a third binary program comprising third instruction blocks, and </claim-text><claim-text>said generating generates second executed blocks information from the executed third instruction blocks, and </claim-text><claim-text>said producing produces a fourth binary program from the second executed blocks information and the line data, the fourth binary program comprising fourth instruction blocks corresponding to the executed third instruction blocks, </claim-text><claim-text>wherein </claim-text><claim-text>when the fourth binary program is executed in the computer, the computer stores the fourth instruction blocks corresponding to the executed third instruction blocks at locations on lines of the cache memory except the lines indicated by the line data. </claim-text></claim>"}, {"num": 13, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00013\" num=\"13\"><claim-text>13. A binary program conversion method according to <claim-ref idref=\"US-6591414-B2-CLM-00010\">claim 10</claim-ref>, further comprising:</claim-text><claim-text>recognizing a frequency of use for data access of every line of the cache memory by monitoring running states of the executed first instruction blocks of the first binary program; and </claim-text><claim-text>selecting lines having the lowest frequency of use from all lines of the cache memory to use for storing second instruction blocks based on a recognition result of said recognizing the frequency of use, and </claim-text><claim-text>wherein said producing comprises producing the second binary program which causes, when executed in the computer, the computer to store second instruction blocks corresponding to the executed first instruction blocks at locations in the selected lines. </claim-text></claim>"}, {"num": 14, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00014\" num=\"14\"><claim-text>14. A binary program conversion method according to <claim-ref idref=\"US-6591414-B2-CLM-00011\">claim 11</claim-ref>, further comprising:</claim-text><claim-text>searching a second instruction block containing on its end a conditional branch instruction whose branch destination is set for a next second instruction block; and </claim-text><claim-text>changing a branch condition and the branch destination of the conditional branch instruction so that a transition from the searched second instruction block to the next second instruction block takes place without branching. </claim-text></claim>"}, {"num": 15, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00015\" num=\"15\"><claim-text>15. A binary program conversion method according to <claim-ref idref=\"US-6591414-B2-CLM-00010\">claim 10</claim-ref>, wherein producing step involves producing the second binary program which causes, when being executed in the computer, the computer to store the second instruction blocks in the cache memory when the total size stored is within cache memory size, wherein the second instruction blocks are selected according to the executing frequency of each block.</claim-text></claim>"}, {"num": 16, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00016\" num=\"16\"><claim-text>16. A recording medium for recording programs for making a computer having a cache memory function as:</claim-text><claim-text>executing means for executing first instruction blocks of a first binary program after an additional area has been added to the first binary program, the additional area having a size of up to and including a size of the cache memory; </claim-text><claim-text>generating means for generating executed blocks information from the executed first instruction blocks; and </claim-text><claim-text>producing means for producing a second binary program from the executed blocks information, the second binary program comprising second instruction blocks corresponding to the executed first instruction blocks of the first binary program, ones of the second instruction blocks having been copied into the additional area, </claim-text><claim-text>wherein </claim-text><claim-text>when the second binary program is executed in the computer, the computer stores the second instruction blocks corresponding to the executed first instruction blocks at locations where any other second instructions blocks are not stored within the cache memory, and </claim-text><claim-text>object code of the first binary program is used during the process of converting the second binary program from the first binary program. </claim-text></claim>"}, {"num": 17, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00017\" num=\"17\"><claim-text>17. A binary program conversion apparatus, used for converting a first binary program including a plurality of object modules having a plurality of first instruction blocks into a second binary program which is executed in a computer having a cache memory without using a source code of the first binary program, comprising:</claim-text><claim-text>adding means for adding an additional area to the first binary program, the additional area having a size up to and including a size of the cache memory, and adding instructions of the additional area being jumped to from the first instruction blocks; </claim-text><claim-text>executing means for executing first instruction blocks of the first binary program with the additional area added; </claim-text><claim-text>generating means for generating executed blocks information from the executed first instruction blocks; and </claim-text><claim-text>producing means for producing the second binary program by copying the first instruction blocks of the plurality of object modules into different areas where any other second instruction blocks of the second binary program are not stored within the additional area based on the executed blocks information, the second binary program comprising the second instruction blocks corresponding to the first instruction blocks, </claim-text><claim-text>wherein </claim-text><claim-text>when the second binary program is executed in the computer, the computer stores the second instruction blocks corresponding to the executed first instruction blocks at locations where any other second instruction blocks are not stored within the cache memory, and </claim-text><claim-text>object code of the first binary program is used during a process of converting the second binary program from the first binary program. </claim-text></claim>"}, {"num": 18, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00018\" num=\"18\"><claim-text>18. A binary program conversion apparatus according to <claim-ref idref=\"US-6591414-B2-CLM-00017\">claim 17</claim-ref>, wherein the size of the additional area is the same as the cache memory.</claim-text></claim>"}, {"num": 19, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00019\" num=\"19\"><claim-text>19. A method of converting a first binary program comprising a plurality of object modules having first instruction blocks into a second binary program which is executed in a computer having a cache memory without using a source code of the first binary program, comprising:</claim-text><claim-text>adding an additional area to the first binary program, the additional area being an additional area having a size corresponding to and including a size of the cache memory, and adding instructions of the additional area being jumped to from the first instruction blocks; </claim-text><claim-text>executing the first instruction blocks of the first binary program; </claim-text><claim-text>generating executed blocks information from the executed first instruction blocks; and </claim-text><claim-text>producing the second binary program by copying the executed first instruction blocks of the plurality of the object modules into different areas within the additional area based on the executed blocks information, the second binary program comprising second instruction blocks corresponding to the executed first instruction blocks, </claim-text><claim-text>wherein </claim-text><claim-text>when the second binary program is executed in the computer, the computer stores the second instruction blocks corresponding to the executed first instruction blocks at locations where any other second instructions blocks are not stored within the cache memory, and </claim-text><claim-text>object code of the first binary program is used during a process of converting the second binary program from the first binary program. </claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00020\" num=\"20\"><claim-text>20. A method of converting a first binary program as recited in <claim-ref idref=\"US-6591414-B2-CLM-00019\">claim 19</claim-ref>, wherein the size of the additional area is the same as the cache memory.</claim-text></claim>"}, {"num": 21, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00021\" num=\"21\"><claim-text>21. A computer program embodied on a computer-readable medium for converting a first binary program comprising a plurality of object modules having first instruction blocks into a second binary program which is executed in a computer having a cache memory without using a source code of the first binary program, comprising:</claim-text><claim-text>an adding element to add an additional area to the first binary program, the additional area being an additional area having a size up to and including a size of the cache memory, and adding instructions of the additional area being jumped to from the first instruction blocks; </claim-text><claim-text>an executing element to execute the first instruction blocks of the first binary program; </claim-text><claim-text>an generating element to generate executed blocks information from the executed first instruction blocks; and </claim-text><claim-text>a producing element to produce the second binary program by copying the executed first instruction blocks of the plurality of the object modules into different areas within the additional area based on the executed blocks information, the second binary program comprising second instruction blocks corresponding to the executed first instruction blocks, </claim-text><claim-text>wherein </claim-text><claim-text>when the second binary program is executed in the computer, the computer stores second instruction blocks corresponding to the executed first instruction blocks at locations where any other second instruction blocks are not stored within the cache memory, and </claim-text><claim-text>object code of the first binary program is used during a process of converting the second binary program from the first binary program. </claim-text></claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00022\" num=\"22\"><claim-text>22. A computer program as recited in <claim-ref idref=\"US-6591414-B2-CLM-00021\">claim 21</claim-ref>, wherein the size of the additional area is the same as the cache memory.</claim-text></claim>"}, {"num": 23, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6591414-B2-CLM-00023\" num=\"23\"><claim-text>23. A binary program conversion apparatus, used for converting a first binary program comprising first instruction blocks into a second binary program which is executed in a computer having a cache memory without using a source code of the first binary program, comprising:</claim-text><claim-text>adding means for adding a cache blocking area of predetermined size comprising a plurality of lines to the first binary program; </claim-text><claim-text>executing means for executing the first binary program; </claim-text><claim-text>generating means for generating executed blocks of information indicating first instruction blocks in the first binary program executed by said executing means; and </claim-text><claim-text>producing means for producing, by copying the first instruction blocks into different areas within the cache blocking area based on the executed blocks of information generated by said generating means, the second binary program which contains second instruction blocks corresponding to the plurality of the first instruction blocks and which causes, when being executed in the computer, the computer to store second instruction blocks corresponding to the first instruction blocks executed by said executing means at different locations of the cache memory, wherein the source code of the first binary program is not used to create the second binary program, </claim-text><claim-text>wherein the producing means compares a total size of the executed first instruction blocks with the size of the cache blocking area, and if the total size of the first instruction blocks is not larger than the size of the cache blocking area, determines a number of the lines, L, necessary for holding all of the executed instruction blocks, selects L number of lines of the cache memory, of which a frequency in use is low, produces the second binary program by copying the first instruction blocks into the location in the cache blocking area, the location corresponding to the selected lines, if the total size of the first instruction blocks is larger than the size of the cache blocking area, selects the larger number of the first instruction blocks in the order of frequency of being executed so that the total size of the selected first instruction blocks does not exceed the size of the cache blocking area, and produces the second binary program by copying the selected first instruction blocks into the cache blocking area.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53953959\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates to a binary program conversion apparats and method for converting an original binary program into a new binary program that runs faster in a computer. Moreover, the present invention relates to a program recording medium with a program for making a computer to function as such a binary program conversion apparatus.</p><p>2. Description of the Related Art</p><p>To improve the performance of computer systems, many efforts have been made over the years to speed up the main memory. However, the development of cache memory has enabled an improvement in the performance of computer systems without speeding up the main memory.</p><p>The cache memory is a small, fast memory located between the main memory and the CPU. In the computer system having the cache memory, when a word (an instruction or data) is requested by the CPU, it is examined whether the requested word exists in the cache memory. If the requested word exists in the cache memory, the word in the cache memory is forwarded to the CPU. On the other hand, if the requested word does not exist in the cache memory, a fixed-size block of data, called a block or line, containing the requested word is retrieved from the main memory and placed into the cache memory. Then, the requested word contained in the data (line) in the cache memory is forwarded to the CPU.</p><p>That is, programs tend to reuse instructions and data which they have used recently and also tend to use words whose addresses are near one another in a short time. (Note that the former property and the latter property are called temporal locality of reference and spatial locality of reference, respectively.) In other words, the words in the main memory which the CPU will request in the near future in executing a program can be anticipated to some degree.</p><p>Since the cache memory stores such words, the CPU in the computer with the cache memory can obtain majority of words which are necessary to execute a program at the speed corresponding to not the access speed of the main memory but the access speed of the cache memory. As a result, a computer with a cache memory operates at the same speed with a system with a high-speed main memory and without a cache memory.</p><p>Moreover, since a computer with a cache memory needs a high-speed memory of small capacity, the use of the cache memory decreases the cost to construct a computer with a certain performance. Consequently, mostly of recent computers are provided with cache memories.</p><p>In addition, recent popularization of personal computers have decreased the price of the memory devices. As a result, modifying a program (software) so that the hit ratio of the main memory may increase in order to improve the performance of the computer becomes hardly significant. Because, in the computer to which many memory devices that became cheap are installed for actualizing a main memory of a large capacity, the hit ratio of the main memory is so high as not to influence the operation speed.</p><p>Therefore, for improving the performance of a computer by means of modifying a program, it is more effective to modify the program so that the hit ratio of the cache memory will be increased. That is, it becomes more important that improving the locality of reference of programs to draw out the performance of the cache memory to its maximum.</p><p>So far, to improve the hit ratio of the cache memory in a certain computer, a source program is compiled by a compiler developed for the computer. That is, to utilize this re-compile technology, each program user has to keep not only binary programs, which are programs used in practice, but also their source programs.</p><p>Moreover, since the advancement of the computer hardware is very fast and it takes time to develop a new compiler corresponding to a new computer architecture, more advanced hardware may be developed before the development of the compiler is completed. That is, there is a problem that correspondence by means of the conventional re-compile technology did not catch up with the advancement of hardware.</p><p>For these reasons, a program conversion technology which can convert a program into a new program suitable for a target computer without using its source program is wished for.</p><h4>SUMMARY OF THE INVENTION</h4><p>An object of the present invention is to provide a binary program conversion apparatus and a binary program conversion method which can convert an original binary program into another binary program that runs at high speed in a computer without using a source program of the original binary program.</p><p>It is another object of the present invention is to provide a program recording medium with a program for making a computer to function as such a binary program conversion apparatus.</p><p>A binary program conversion apparatus according to a first aspect of the invention is used for converting a first binary program which consists of a plural of first instruction blocks into a second binary program which is executed in a computer having a cache memory.</p><p>The binary program conversion apparatus comprises an executing part, a generating part and a producing part. The executing part executes the first binary program.</p><p>The generating part generates executed blocks information indicating first instruction blocks which are executed by the executing part.</p><p>The producing part produces, based on the executed blocks information generated by the generating part, the second binary program which contains second instruction blocks corresponding to the plural of the first instruction blocks and which causes, when being executed in the computer, the computer to store second instruction blocks corresponding to the first instruction blocks executed by the executing part at different locations of the cache memory.</p><p>Thus, the binary program conversion apparatus of the first aspect converts a binary program (first binary program) into a new binary program (second binary program) which runs fast in the computer with the cache memory by carrying out processes involves rearranging binary codes (executed blocks). Therefore, according to this binary program conversion apparatus, binary programs suitable for the computer having the cache memory can be obtained without using (managing) their source programs.</p><p>Actualization of the binary program conversion apparatus according to the first aspect involves the use of the producing part which produces the second binary program including a part in which the second instruction blocks corresponding to the first instruction blocks executed by the executing part arranged successively.</p><p>The binary program conversion apparatus according to the first aspect of the invention may further include a creating part and a controlling part. The creating part create a line data indicating lines of the cache memory which are to be used when the second binary program produced by the producing part is executed in the computer.</p><p>The controlling part controls the executing part so as to execute a third binary program which consists of a plural of third instruction blocks at first. Then, the controlling part controls the generating part so as to generate second executed blocks information indicating third instruction blocks executed by the executing part. Moreover, the controlling part controls the producing part so as to produce a fourth binary program which causes, when being executed in the computer, the computer to store fourth instruction blocks corresponding to the third instruction blocks executed by the executing part on different locations on lines of the cache memory excluding the lines indicated by the line data.</p><p>According to the thus constructed binary conversion apparatus, two binary programs (first, third binary programs), which are executed at the same time, can be converted into new two binary programs (second, fourth binary programs) which run at high speed in the computer.</p><p>The binary program conversion apparatus may further include a recognizing part which recognizes frequency of use for data access of every line of the cache memory by monitoring running states of the first binary program executed by the executing part, and the selecting part which selects, based on a recognition result of the recognizing part, lines from all lines of the cache memory to use for storing the second instruction blocks corresponding to the first instruction blocks executed by the executing part. In this case, adopted is the producing part which produces the second binary program which causes, when being executed in the computer, the computer to store the second instruction blocks corresponding to the first instruction blocks executed by the executing part on different locations on the lines selected by the selecting part.</p><p>According to the thus constructed binary conversion apparatus, a new binary program (second binary program) which causes no or little conflict miss between an instruction access and a data access can be obtained.</p><p>Furthermore, when employed is the producing part which produces the second binary program including a part in which the second instruction blocks corresponding to the first instruction blocks executed by the executing part arranged successively, the binary program conversion apparatus may be constructed by adding a searching part and a changing part.</p><p>The searching part searches from the binary program produced by the producing part a second instruction block containing on its end a conditional branch instruction whose branch destination is set for a next second instruction block. The changing part changes a branch condition and the branch destination of the conditional branch instruction so that a transition from the second instruction block searched by the searching part to the next second instruction block takes place without branching.</p><p>According to the thus constructed binary conversion apparatus, a new binary program (second binary program) which runs at higher speed can be obtained.</p><p>A binary program conversion apparatus according to a second aspect of the invention is used for converting a first binary program into a second binary program which is executed in a computer.</p><p>The binary program conversion apparatus according to the second aspect comprises a searching part and a producing part. The searching part for searching from the first binary program first instruction strings each of which consists of at least one predetermined instruction code. The producing part for producing the second binary program by replacing the respective instruction strings searched by the searching part with second instruction strings assigned to the first instruction strings.</p><p>Thus, the binary program conversion apparatus of the second aspect converts a original binary program (first binary program) into a new binary program (second binary program) which runs fast in the target computer by replacing instruction strings in the original binary program. Therefore, according to this binary program conversion apparatus, binary programs suitable for the target computer can be obtained without using (managing) their source programs.</p><p>Note that, the binary conversion apparatus of the present invention may be realized by running a corresponding program recorded in a program medium in a conventional computer.</p><p>A binary program conversion method according to a first aspect of the invention is used for converting a first binary program which consists of a plural of first instruction blocks into a second binary program which is executed in a computer having a cache memory.</p><p>The binary program conversion method according to the first aspect comprises an executing step, a generating step and a producing step. In the executing step, the first binary program is executed. In the generating step, executed blocks information indicating first instruction blocks executed in the executing step is generated. In the producing step, based on the executed blocks information generated in the generating step, the second binary program is generated which contains second instruction blocks corresponding to the plural of the first instruction blocks of the first binary program and which causes, when being executed in the computer, the computer to store the second instruction blocks corresponding to the first instruction blocks executed in the executing step on different locations of the cache memory.</p><p>The binary program conversion method according to the first aspect may adopt the producing step which involves producing the second binary program including a part in which the second instruction blocks corresponding to the first instruction blocks executed in the executing step arranged successively.</p><p>It is feasible to further add, to the program conversion method, a creating step and a controlling step. The creating step involves a process of creating a line data indicating lines of the cache memory which are to be used when the second binary program produced in the producing step is executed in the computer. The controlling step involves processes of controlling the executing step so as to execute a third binary program which consists of a plural of third instruction blocks, and of controlling the generating step so as to generate second executed blocks information indicating third instruction blocks executed in the executing step, and of controlling the producing step so as to produce, based on the second executed blocks information and the line data, a fourth binary program which contains fourth instruction blocks corresponding to the plural of the third instruction blocks and which causes, when being executed in the computer, the computer to store the fourth instruction blocks corresponding to the third instruction blocks executed by said executing means at different locations on lines of the cache memory excluding the lines indicated by the line data.</p><p>It is possible to further add, to the binary program conversion method according to the first aspect of the invention, a recognizing step and a selecting step.</p><p>The recognizing step involves a process of recognizing frequency of use for data access of every line of the cache memory by monitoring running states of the first binary program executed in the executing step. The selecting step involves a process of selecting lines from all lines of the cache memory to use for storing second instruction blocks based on a recognition result of the recognizing step. Incidentally, in this case, there is employed the producing step involves producing the second binary program which causes, when being executed in the computer, the computer to store second instruction blocks corresponding to the first instruction blocks executed in the executing step on different locations on the lines selected in the selecting step.</p><p>It is desirable to add a searching step and a changing step to the binary program conversion method in which adopted is the producing step involving a process of producing the second binary program including a part in which the second instruction blocks corresponding to the first instruction blocks executed in the executing step arranged successively.</p><p>The searching step involves a process of searching a second instruction block containing on its end a conditional branch instruction whose branch destination is set for a next second instruction block. The changing step involves a process of changing a branch condition and the branch destination of the conditional branch instruction so that a transition from the second instruction block searched in the searching step to the next second instruction block takes place without branching.</p><p>A binary program conversion method according to a second aspect of the invention is used for converting a first binary program into a second binary program which is executed in a computer. The binary program conversion method comprises a searching step and a producing step.</p><p>The searching step involves a process of searching from the first binary program first instruction strings each of which consists of at least one predetermined instruction code. The producing step of producing the second binary program by replacing the respective instruction strings searched in the searching step with second instruction strings assigned to the first instruction strings.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the present invention will become apparent during the following discussion in conjunction with the accompanying drawings, in which;</p><p>FIG. 1 is an explanatory diagram illustrating a construction of the binary program conversion apparatus in an embodiment of the present invention;</p><p>FIG. 2 is an explanatory diagram of a text table created by a trace analyzer in the binary program conversion apparatus of the embodiment;</p><p>FIG. 3 is an explanatory diagram of a data use line table created by the trace analyzer;</p><p>FIG. 4 is an explanatory diagram of a line table created by a cache allocator in the binary program conversion apparatus;</p><p>FIG. 5 is an explanatory diagram of a binary program to be converted by the binary program conversion apparatus;</p><p>FIG. 6 is an explanatory diagram showing the principle of operation procedure of the binary program conversion apparatus;</p><p>FIG. 7 is an explanatory diagram showing the first half of the operation procedure of the binary program conversion apparatus in converting two binary programs that are executed at the same time;</p><p>FIG. 8 is an explanatory diagram showing the latter half of the operation procedure of the binary program conversion apparatus in converting two binary programs that are executed at the same time;</p><p>FIG. 9 is a flowchart showing the operation procedure of the cache allocator;</p><p>FIG. 10 is a flowchart showing the overall operation procedure of an object code converter in the binary program conversion apparatus;</p><p>FIG. 11 is a flowchart of a block copy process carried out by the object code converter;</p><p>FIG. 12 is a flow chart of a copy process carried out by the object code converter;</p><p>FIG. 13 is a flowchart of a branch condition reversing process carried out by the object code converter;</p><p>FIG. 14 is a flowchart of a CTI relocation process carried out by the object code converter;</p><p>FIG. 15 is a flowchart of a branch prediction process carried out by the object code converter;</p><p>FIG. 16 is a flowchart of a relocation process carried out by the object code converter;</p><p>FIG. 17 is explanatory diagram showing the principle of the operation procedure of the binary program conversion apparatus in converting two binary programs that are executed at the same time;</p><p>FIG. 18 is explanatory diagram showing how the cache memory is used when two executable object programs generated by the binary program conversion apparatus;</p><p>FIGS. 19-26 are partial program lists for explaining the operation procedure of the binary program conversion apparatus;</p><p>FIGS. 27A, <b>27</b>B are explanatory diagrams showing how the cache memory is used when executing binary programs before conversion and after conversion.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</h4><p>The present invention will now be described with reference to the accompanying drawings.</p><p>The binary program conversion apparatus in an embodiment converts a binary program into another binary program which runs at a high speed in a target computer having a cache memory. The binary program conversion apparatus is functionally realized by installing a program, which is stored in a recording medium like a CD-ROM, to the target computer.</p><p>Therefore, before discussing the operation procedure of the binary program conversion apparatus, the construction and the architecture of the computer used in the embodiment will be described.</p><p>The computer has the cache memory of 1 Mbytes divided into lines each of which consists of successive 64 bytes. Namely, the cache memory consists of 16384 (=1 Mbytes/64 bytes) lines. The 16384 lines are managed with using line numbers from 0 to 16383, respectively.</p><p>Moreover, the computer used in the embodiment is supported with the virtual memory. That is, virtual addresses from the CPU are translated into physical addresses used for accessing the main memory or the cache memory.</p><p>In the computer, when an instruction/data of one byte is requested by the CPU, it is examined whether the instruction/data exists in the cache memory. If the instruction/data does not exist in the cache memory, a data of 64 bytes in the main memory which contains the instruction/data is retrieved from the main memory and placed in the cache memory. Then, the instruction/data contained in the retrieved data in the cache memory is forwarded to the CPU.</p><p>The line where the retrieved data containing the requested instruction/data is stored is uniquely decided from the virtual address of the requested instruction/data. Concretely, the remainder into which the virtual address is divided by the cache memory size is used as the index of the line for storing the retrieved data.</p><p>Hereinafter, assuming that the computer has the construction and the architecture as described above, the operation of the binary program conversion apparatus in the embodiment is explained. Note that, in the following discussions, a source program (or source code) compiled is denoted as an object program and a file which stores an object program is denoted as an object file. A program, which is executable on the computer, obtained by linking one or more object programs is denoted as an executable object program. Moreover, a binary program will be used generically of an object program and an executable object program.</p><p>First of all, the outline of operating procedure of the binary program conversion apparatus is explained by exemplifying a case where one executable object program is converted.</p><p>As explained above, the binary program conversion apparatus is functionally realized by installing the binary program conversion program developed for this apparatus into the computer. When running the installed binary program conversion program, the computer starts to function as the binary program conversion apparatus consists of a link editor <b>11</b>, a profiler <b>12</b>, a trace analyzer <b>13</b>, a cache allocator <b>14</b>, and an object code converter <b>15</b> as schematically shown in FIG. <b>1</b>.</p><p>The link editor <b>11</b> adds a cache blocking area (hereinafter referred to as CaB area) of the same size as the cache memory (1 MB in the embodiment) to an executable object program to be converted. Concretely, the link editor <b>11</b> links a pseudofunction to secure the CaB area (details are described later) with the executable object program to be converted, thereby creating another executable object program. The link editor also stored relocation information (address constants) in the executable object program to enable complete relocation by the object code converter <b>15</b>. Note that, in the following explanations, an area except the CaB area in the executable object program generated by the link editor <b>11</b> will be denoted as the MTXT area.</p><p>The profiler <b>12</b> traces (executes) the executable object program in which the CaB area is secured and creates an execution profile which contains information on the instruction codes that are executed.</p><p>The trace analyzer <b>13</b> analyzes the execution profile created by the profiler <b>12</b> and creates a text table and a data use line table. The text table is a table which holds information necessary for converting the executable object program. More concretely, it holds records each of which consists of 10 items as shown in FIG. <b>2</b>. The data use line table holds records each of which consists of cache line number (\u201cLINE\u201d) and number of times the line, identified by the cache line number, is used for storing data (\u201cUSE\u201d) as shown in FIG. <b>3</b>.</p><p>The cache allocator <b>14</b> recognizes a volume (size) necessary to store all instruction blocks in the MTXT area executed by the profiler <b>11</b> based on the information in the text table created by the trace analyzer <b>13</b>. Then, the cache allocator <b>14</b> determines L which is the minimum number of the cache lines necessary for holding the executed instruction blocks and selects the first L lines having the lowest frequencies of use by data access based on the information in the data use line table. Next, the cache allocator <b>14</b> classifies the selected lines into some groups each consist of consecutive lines, and create a line table containing information which indicates the classified groups. Concretely, the cache allocator <b>14</b> creates a line table containing records each of which includes starting line number (\u201cFROM\u201d), ending line number (\u201cTO\u201d), and number of lines (\u201cNUM\u201d) of an area consists of consecutive lines as shown in FIG. <b>4</b>.</p><p>Note that, when the size necessary to store all instruction blocks executed is larger than the size of the cache memory, the cache allocator <b>14</b> performs a processing different from the processing explained above. Details of the processing are described later.</p><p>After the line table is created, the object code converter <b>15</b> starts a processing for converting the executable object program.</p><p>In converting the executable object program, the object code converter <b>15</b> copies instruction blocks executed by the profiler <b>12</b> into areas within the CaB area which correspond to the cache lines selected by the cache allocator <b>14</b> based on the information in the text table and the line table. Then, the object code converter <b>15</b> writes on the starting location of each instruction block whose copy is made in the CaB area an unconditional branch instruction which cause a branch to the origin of the copy in the CaB area. Furthermore, the object code converter changes target offset/addresses of CTIs (Control Transfer Instruction; branch, call, jmpl, etc.) That is, the object code converter <b>14</b> modifies the object program so that the copies in the CaB area are executed.</p><p>The executable object program generated thus runs faster than the executable object program before conversion. The reason is described below.</p><p>For example, it is assumed that an executable object program containing three instruction blocks a, b, and c which are executed under an operational condition is given to the binary program conversion apparatus for conversion. It is also assumed that the instruction blocks a and b exists in the locations which corresponds to the same line in the cache memory as illustrated in FIG. <b>5</b>.</p><p>In this case, the binary program conversion apparatus, as schematically shown in FIG. 6, copies the instruction blocks a, b and c in the CaB area, thereby generating a new executable object program whose instruction blocks in the CaB area are executed. That is, the binary program conversion apparatus generates the executable object program whose instruction block a, b and c will be stored in the different lines of the cache memory.</p><p>Consequently, when running the executable object program generated by the binary program conversion apparatus, no hit-miss in the cache memory due to the conflict between the instruction accesses occurs. As a result, the converted executable object program runs faster than the original executable object program.</p><p>Next, the operating procedure of the binary program conversion apparatus is explained more in detail by exemplifying a case where two executable object programs A and B that are executed at the same time are converted.</p><p>In this case, as schematically shown in FIG. 7, the link editor links pseudofunctions to secure the CaB areas with the executable object programs A and B, thereby generating executable object program A\u2032 and B\u2032 each of which has a CaB area. At this time, to enable complete relocation by the object converter, the link editor stored relocation information (address constants) in each executable object program.</p><p>Then, the profiler traces the executable object program A\u2032 and B\u2032 individually or simultaneously and create an execution profile including information on the instruction codes executed.</p><p>After the creation of the execution profile, as shown in FIG. 8, the trace analyzer creates text tables A and B, and data use line tables A and B based on the information in the execution profile.</p><p>Thereafter, based on the information in the text tables A and B, the cache allocator determines total size of the executed instruction blocks in the executable object program A\u2032 and B\u2032. Then, if the total size is smaller than the size of the cache memory (CaB area; 1 MB in the embodiment), the cache allocator selects the cache lines to utilize for holding all executed instruction blocks based on the information in the data use line table A and B. Next, it classifies area which consists of the selected cache lines into consecutive line areas and creates a line table which contains one or more records each indicating one consecutive line area.</p><p>On the contrary, if the total size of the executed instruction blocks is larger than the size of the cache memory, the cash allocator creates the line table having one record which consists of the starting line number, the ending line number, and the number of lines of the cache memory without selecting the cache lines. Moreover, the cache allocator selects the instruction blocks to be copied into the CaB from all executed instruction blocks and changes the content of the text tables A and B to inform the object code converter of the selection result.</p><p>More concretely, as shown in FIG. 9, the cache allocator first determines SUMtot which is the sum of the sizes of the instruction blocks executed by the profiler based on the information in all text tables (step <b>100</b>). Then, the cache allocator judges whether SUMtot&gt;CZ is satisfied (step <b>101</b>). Here, CZ is the size of the cache memory.</p><p>When SUMtot&gt;CZ is satisfied (step <b>101</b>:T), the cache allocator determines a maximum X with which SUM(X)&gt;CZ is satisfied, and memorizes X as MAXRUN (step <b>102</b>). Here, SUM(X) is the sum of the size of the instruction blocks which were executed at least X times. Note that, the cache allocator determines MAXRUN as follows. The cache allocator first retrieves the records concerning the instruction blocks from all text tables. Next, it sorts the retrieved records in descending order using RUN as the key so that SUM(X) may be computed by summing up values of SZ of the first some records of the sorted records. Then, the cash allocator computes SUM(X) decreasing the value of X and memorizes the value of X which satisfies the inequality SUM(X)&gt;CZ for the first time as MAXRUN.</p><p>After determining MAXRUN, the cache allocator changes values of RUN, which are equal to or smaller than MAXRUN, in the records concerning the instruction block to \u201c0\u201d (step <b>103</b>). Then, the cache allocator creates a line table containing one record which consists of the starting line number, the ending line number, and the number of lines of the cache memory (step <b>104</b>). Namely, the cache allocator creates the line table containing one record in which values of FROM, TO, and LINE are set with 0, 16383, and 16384, respectively. After creating the line table, the cache allocator terminates the processing shown in the Figure.</p><p>On the other hand, when SUMtot&gt;CZ is not satisfied (step <b>101</b>:F), the cache allocator determines number of lines, L, necessary for holding all instruction blocks executed by the profiler based on the cache composition information (line size) and SUMtot (step <b>105</b>). Then, the cache allocator sorts the records in all data use line tables in the ascending order using USE as the key to select the first L records having the lowest USE (step <b>106</b>).</p><p>After the selection of L records, the cache allocator sorts the records in the ascending order using the line number (LINE) as the key and classifies the sorted records into some groups each of which consists of one or more records having consecutive line numbers. Then, it determines the starting line number, the ending line number, and the number of lines of the consecutive line area indicated by the records in each groups (step <b>107</b>).</p><p>Thereafter, the cache allocator creates a line table (see FIG. 4) in which records each of which consists of the starting line number, the ending line number, and the number of lines of a consecutive line area are placed in descending order of the number of the lines (step <b>108</b>) and terminates the processing.</p><p>After the line table is created, the object code converter starts a process for converting the executable object program A\u2032 and B\u2032.</p><p>As illustrated in FIG. 8, when converting the executable object program A\u2032 which is the first program to be converted, the object code converter uses the text table A\u2032 and the line table. On the other hand, when converting the executable object program B\u2032 which is the second program to be converted, the object code converter uses the text table B\u2032, the line table, and a line log A that has been created in the converting process for the executable object program A\u2032.</p><p>Hereafter, the details of the conversion process executed by the object code converter is explained with reference to FIGS. 10 through 16.</p><p>When starting the conversion process, the object converter, as shown in FIG. 10, first judges whether the executable object program to be processed is the first program to be converted (step <b>110</b>). When the object program is the first program (step <b>110</b>:T), the object code converter executes a block copy process (step <b>112</b>), a CTI relocation process (step <b>113</b>), and an address constant relocation process (step <b>114</b>) one by one.</p><p>FIG. 11 shows the operation procedure of the object code converter in the block copy process. When starting the block copy process, the object code converter selects one record for a instruction block in the text table and judges whether RUN(Si)\u22671 is satisfied (step <b>120</b>). Here, Si represents an instruction block to which the selected record relates, and RUN(Si) represents a value of RUN (number of times instruction block is executed) in the selected record.</p><p>When RUN(Si)\u22671 is not satisfied (step <b>120</b>:F), the object code converter judges whether or not processing for all instruction blocks is completed (step <b>127</b>). When processing for all instruction blocks is not completed (step <b>127</b>;F), the object code converter returns to step <b>120</b> and starts processing for the next instruction block.</p><p>When RUN(Si)\u22671 is satisfied (step <b>120</b>:T), the object code converter executes a copy process (step <b>121</b>) in order to copy the instruction block Si in the MTXT area into the CaB area.</p><p>FIG. 12 shows the operation procedure of the object code converter in the copy process. When starting the copy process, the object code converter first determines a copy target address, from which the instruction block Si is to be copied, based on the information in the line table and the cache composition information (step <b>130</b>). Then, the object code converter judges whether the instruction block Si can be arranged on a consecutive area within the CaB area which includes the copy target address and corresponds to the consecutive line area indicated by one record in the line table (step <b>131</b>). When the instruction block Si can be arranged in the consecutive area (step <b>131</b>:T), the object code converter copies the instruction block Si into the consecutive area (step <b>132</b>) and terminates the copy process.</p><p>When the instruction block Si cannot be arranged in the consecutive area (step <b>131</b>:F), the object code converter divides the instruction blocks Si into some blocks and copies the divided blocks into some consecutive areas (step <b>133</b>). In this step, when copying each divided block except the last divided block, the object code converter writes an unconditional branch which causes a branch to the next consecutive area to be used for holding the next divided block on an ending location of the consecutive area in which the divided block is copied. Then, it terminates the copy process.</p><p>After completing the copy process, the object code converter, as shown in FIG. 11, writes an unconditional branch instruction which causes a branch to the instruction block Si in the CaB area on the starting location of the instruction block Si in the MTXT area (step <b>122</b>).</p><p>Next, the object code converter determines the instruction block Sj which will be copied into the CaB area next, and computes MADDR(Sj) which is the starting address of the instruction block Sj (step <b>123</b>). Then, the object code converter judges whether a branch instruction Ci is included in the block Si (step <b>124</b>).</p><p>When no branch instruction is included in the instruction block Si (step <b>124</b>:F), the object code converter judged whether MADDR(Sj)!=MADDR(Si)+SZ(Si) is satisfied (step <b>128</b>). Here, SZ(Si) is the size of the instruction block Si. When MADDR(Sj)!=MADDR(Si)+SZ(Si) is satisfied (step <b>128</b>:T), the object code converter writes an unconditional branch instruction which cause a branch to the address \u201cMADDR(Si)+SZ(Si)\u201d at the location next to the copied instruction block Si in the CaB area (step <b>129</b>) and proceeds to step <b>127</b>. On the other hand, when MADDR(Sj)!=MADDR(Si)+SZ(Si) is not satisfied, that is, MADDR(Sj)=MADDR(Si)+SZ(Si) is satisfied (step <b>128</b>:F), the object code converter proceeds to step <b>127</b> without writing the unconditional branch instruction.</p><p>When a branch instruction Ci is included in the instruction block Si (step <b>124</b>:T), the object code converter judges whether MADDR(Sj)=TADDR(Ci) is satisfied (step <b>125</b>). Here, TADDR(Ci) is the target address (branch address) of the branch instruction Ci. When MADDR(Sj)=TADDR(Ci) is satisfied (step <b>125</b>;T), the object code converter executes a branch condition reversing process (step <b>126</b>).</p><p>Hereafter, the operation procedure of the object code converter in the branch condition reversing process is explain with reference to FIG. <b>13</b>. Note that, the reason why this process is carried out will be explained later.</p><p>When starting the branch condition reversing process, the object code converter first judges whether the branch instruction Ci is an annulled branch instruction (step <b>140</b>). The annulled branch instruction (delay nullification branch instruction) is a branch instruction which directs the CPU to execute its succeeding instruction (delay instruction) when the branch is taken and not to execute the succeeding instruction when the branch is not taken.</p><p>When the branch instruction Ci is not an annulled branch instruction (step <b>140</b>:F), the object code converter reverses the branch condition of the instruction Ci (step <b>143</b>). On the other hand, when the branch instruction Ci is an annulled branch instruction (step <b>140</b>:T), the object code converter reverses the branch condition of the branch Ci and removes the annulled constraint (step <b>141</b>). Then, the object code converter inserts an instruction \u201cnop\u201d (instruction which directs the CPU to carry out no effective operation) between the branch instruction and the delay instruction (step <b>142</b>).</p><p>That is, the annulled branch instruction in the original program is a instruction which causes the CPU to execute a delay instruction only when a certain condition is met. However, if only a branch condition of the annulled branch instruction is reversed, the reversed instruction causes the CPU to execute the delay instruction only when the certain condition is not met. Therefore, the object code converter removes the annulled constraint and adds the \u201cnop\u201d instruction, thereby generating combination of instruction codes which cause the CPU to execute the \u201cdelay\u201d instruction only when the certain condition is met.</p><p>After executing step <b>142</b> or step <b>143</b>, the object code converter judges whether the branch instruction whose branch condition is reversed is a \u201cbn\u201d (step <b>144</b>). Here, \u201cbn\u201d (branch never) is a branch instruction which never causes a branch, and deleting the \u201cbn\u201d results in any problems. Therefore, when the branch instruction is a \u201cbn\u201d (step <b>144</b>:T), the object code converter deletes the instruction (step <b>145</b>). Then, the object code converter judges whether the succeeding instruction to the branch instruction is a \u201cnop\u201d (step <b>146</b>). When the succeeding instruction is a \u201cnop\u201d (step <b>146</b>; T), the object code converter deletes the instruction (step <b>147</b>) and terminates the branch condition reversing process.</p><p>When the branch instruction changed is not a \u201cbn\u201d (step <b>144</b>; F) or the succeeding instruction is not a \u201cnop\u201d (step <b>146</b>:F), the object code converter terminates the branch condition reversing process without deleting any instructions.</p><p>After the branch condition reversing process is terminated, the object code converter, as shown in FIG. 11, proceed to step <b>127</b> and judges processing for all instruction blocks is completed. When processing for all instruction blocks is completed (step <b>127</b>:T), the object code converter terminates the block copy process and starts the CTI relocation process.</p><p>FIG. 14 shows the operation procedure of the object code converter in the CTI relocation process.</p><p>In the CTI relocation process, the object code converter first select one record related to CTI in the text table and judges whether a code at the address TADDR(Ci) has been copied into the CaB area (step <b>150</b>). Here, TADDR(Ci) is a target address of the instruction Ci to which the selected record relates.</p><p>When the code at TADDR(Ci) has been copied into the CaB area (step <b>150</b>:T), the object code converter relocates TADDR(Ci) (step <b>151</b>) and executes a branch prediction process (details will be described later) for the instruction Ci in the MTXT area (step <b>152</b>). Then, the object code converter judges whether the instruction block Si including the instruction Ci has been copied into the CaB area (step <b>153</b>). When the instruction block Si has been copied into the CaB area (step <b>153</b>;T), the object code converter relocates the target address of the copy of the instruction Ci in the CaB area (step <b>154</b>) and executes the branch prediction process for the instruction Ci in the CaB area (step <b>155</b>).</p><p>Then, when processing for all CTIs is not completed (step <b>156</b>:F), the object code converter returns to step <b>150</b> and starts processing for the next CTI. On the other hand, when processing for all CTIs is completed (step <b>156</b>:T), the object code converter creates a line log which holds the information indicating the cache lines in which the instruction blocks are stored when the converted executable object program is executed (step <b>157</b>) and terminates the CTI relocation process.</p><p>After terminating the CTI relocation process, the object code converter, as mentioned before (see FIG. <b>10</b>), executes the address constant relocation process.</p><p>Before explaining the address constant relocation process, the branch prediction process (steps <b>152</b>, <b>155</b>) will be explained with reference to FIG. <b>15</b>.</p><p>When starting the branch prediction process, the object code converter first judges whether the CPU in the target computer supports a predictional branch instruction (step <b>160</b>). Note that, the predictional branch instruction is a branch instruction which has a prediction bit showing the probability that the branch will be taken is higher than 0.5 or not. When the predictional branch instruction with a prediction bit showing the probability is higher than 0.5, \u201cBPcc, pt\u201d, is given, the CPU sporting the predictional branch instruction prefetches instructions which are to be executed when the branch is taken. When the predictional branch instruction with a prediction bit showing the probability is not higher than 0.5, \u201cBPcc, pn\u201d, is given, the CPU executes the branch instruction without prefetching instruction.</p><p>When the CPU supports the predictional branch instruction (step <b>160</b>;T), the object code converter judges whether BT(Ci)/RUN(Ci)&gt;0.5 (\u201cnumber of times branch instruction is taken\u201d/\u201cnumber of times branch instruction is executed\u201d&gt;0.5) is satisfied (step <b>161</b>). When BT(Ci)/RUN(Ci)&gt;0.5 is satisfied (step <b>161</b>;T), the object code converter rewrites the instruction Ci with \u201cBPcc, pt\u201d (step <b>162</b>) and terminates the predictional branch process. On the other hand, when BT(Ci)/RUN(Ci)&gt;0.5 is not satisfied (step <b>161</b>; F), the object code converter rewrites Ci with the predictional branch instruction \u201cBPcc, pn\u201d (step <b>163</b>) and terminates the predictional branch process.</p><p>Hereinafter, the operation procedure of the object code converter in the address constant relocation process is explained with reference to FIG. <b>16</b>. Note that, the address constant relocation process is carried out to prevent that control is transferred to an instruction in the MTXT area by a branch instruction conditional to a register.</p><p>When starting the address constant relocation process, the object code converter selects an address constant among the address constants which are stored in the executable object program by the link editor, and judges whether the selected address constant points to any locations on the instruction blocks whose copies are made on the CaB (step <b>170</b>). When the address constant points to any of such locations (step <b>170</b>:T), the object code converter rewrites the address constant with a corresponding address in the CaB area (step <b>171</b>) and proceeds to step <b>172</b>. On the contrary, when the address constant does not point to any of such locations (step <b>170</b>:F), the object code converter proceeds to step <b>172</b> without rewriting the address constant.</p><p>In step <b>172</b>, the object code converter judges whether or not processing for all address constants is completed (step <b>172</b>). When processing for all address constants is not completed (step <b>172</b>:F), the object code converter returns to step <b>170</b> and starts the processing for the next address constant.</p><p>When recognizing that processing for all address constants is completed (step <b>172</b>:T), the object code converter terminates the address constant relocation process.</p><p>When the address constant relocation process is terminated, the conversion process for the object program A\u2032 is completed. Namely, the object program A\u2033 which runs faster than the object program A is generated. Then, the conversion process for the next executable object program B\u2032 is started as schematically shown in FIGS. 8, <b>10</b>.</p><p>In this case, since the object program B\u2032 is not the first program, the object code converter proceeds to step <b>111</b> and deletes the records concerning cache lines which will be used for holding the instruction blocks in the object program A\u2033 from the line table based on the information in the line log A created in the CTI relocation process for the object program A\u2032. After updating the contents of the line table, the object code converter executes the block copy process (step <b>112</b>), the CTI relocation process (step <b>113</b>), and the address constant relocation process (step <b>114</b>) for the executable object program B\u2032 one by one.</p><p>Consequently, as schematically shown in FIG. 17, the executed instruction blocks in the object program B are copied into the CaB area in such a manner that the copied instruction blocks in the CaB area are, when being executed, stored in the cache lines that are not used for storing the copied instruction blocks in the object program A\u2033.</p><p>Hereafter, the operation procedure of the binary program conversion apparatus discussed above is explained more concretely using program lists shown in FIGS. 19-26. Note that, in the discussions below, it is assumed for convenience' sake that the binary program conversion apparatus (object code converter) copies all the executed instruction blocks into the CaB area before performing other processing. And notations in every program lists are based on an assembler language for a certain computer architecture.</p><p>To begin with, the basic operation procedure of the binary conversion apparatus will be discussed by exemplifying a case where one executable object program whose list is shown in FIG. 19 is converted. Note that, the instruction \u201cseticc\u201d in the list represents an instruction for setting a condition code to which conditional branch instruction refers. The instruction \u201cbe\u201d (branch equal) is an instruction which causes a branch when an equal condition is satisfied. The \u201cc-.\u201d following \u201cbe\u201d indicates that the offset value of the branch target is a value obtained by subtracting the present address (\u201c.\u201d) from the starting address of the block c. The instruction \u201cdelay\u201d is a delay instruction which is executed at the same time with the branch instruction. The \u201cdelay\u201d is executed even when the branch is taken. That is, after a branch instruction and corresponding \u201cdelay\u201d are executed, an instruction of the branch target is executed.</p><p>As explained before, when a program is converted, only the instruction blocks executed by the profiler are copied into the CaB area. Therefore, if the blocks a and b in the program shown in FIG. 19 are executed by the profiler, the program is modified to the program shown in FIG. <b>20</b>. That is, the program having the instruction blocks a\u2032 and b\u2032, which are the copies of instruction blocks a and b, in the CaB area is generated.</p><p>Then, relocations are carried out so that instruction block a\u2032 and b\u2032 are executed. As the result, the program shown in FIG. 20 is modified to the program shown in FIG. <b>21</b>.</p><p>That is, the unconditional branch instruction \u201cba, a a\u2032-.\u201d which causes a branch to the block a\u2032 in the CaB area is set at the starting address of the block a in the MTXT area (*1). Similarly, the unconditional branch instruction \u201cba, a b\u2032-.\u201d which causes a branch to the block b\u2032 is set at the starting address of the block b (*2). Note that, \u201c, a\u201d in the instruction \u201cba, a a\u2032-.\u201d or \u201cba, a b\u2032-.\u201d represents that the instruction is an annulled branch instruction which cause the CPU not to execute its succeeding instruction.</p><p>Moreover, the target offset value of the branch instruction in the block a\u2032 is rewritten so that the control will be transferred to the block c in the MTXT area (*3). With respect to the block b\u2032 in the CaB area, since the block c following the block b is not copied into the CaB area, the unconditional branch instruction \u201cba, a c-.\u201d is added to its end (*4).</p><p>Next, the operation procedure in the branch condition reversing process is explained by exemplifying a case where the blocks a and c in the program shown in FIG. 19 are executed by the profiler.</p><p>In this case, the program shown in FIG. 19 is converted into the program shown in FIG. <b>22</b>. That is, the unconditional branch instructions to the blocks a\u2032 and c\u2032 are set at the starting addresses in the blocks a and c in the MTXT area (*5,*7). Moreover, since the branch target of the branch instruction \u201cbe\u201d in the block a is the instruction block c whose copy is made on the CaB area, the target offset value of the branch instruction is rewritten so that the branch instruction causes a branch to the instruction block c\u2032 (*6).</p><p>Furthermore, since the target of the branch instruction \u201cbe\u201d in the block b\u2032 is the block c whose copy is made on the CaB area and at the location of the CaB area next to the block b\u2032, the instruction is substituted for the branch instruction \u201cbne\u201d (branch not equal) and its target offset value is rewritten so that a branch will be taken to the block b in the MTXT area (*8) in the branch condition reversing process.</p><p>Next, the operation procedure in the branch condition reversing process for a annulled branch instruction is explained by exemplifying a case where the program shown in FIG. 23 is given to the binary program conversion apparatus and the blocks a and c are executed by the profiler.</p><p>In this case, the program shown in FIG. 24 is generated by the binary program conversion apparatus. That is, with respect to the instruction blocks a and c in the MTXT area, adding the unconditional branch instructions and relocating the target offset value are carried out similarly to the case where the program does not include an annulled branch instruction (see FIG. <b>22</b>).</p><p>Then, with respect to the annulled branch instruction \u201cbe, a c-.\u201d in the block a\u2032 (not shown in the figure), since its branch target (i.d. the block c) is copied in the location next to the block b\u2032, its branch condition is reversed and the annulled constraint is removed. That is, the annulled branch instruction \u201cbe, a\u201d is substituted for the not annulled branch instruction \u201cbne\u201d. Furthermore, the target offset value of the \u201cbne\u201d is rewritten so that a branch to the block b in the MTXT area will be taken (*9). In addition, the instruction \u201cnop\u201d is inserted between the modified branch instruction and the instruction \u201cdelay\u201d (*10).</p><p>When the thus converted program is executed under the situation that the branch instruction \u201cbne b-\u201d in the block a\u2032 causes a branch, its succeeding instruction \u201cnop\u201d is executed, but the instruction \u201cdelay\u201d is not executed. On the other hand, when the program is used under the situation that the branch instruction \u201cbne b-\u201d does not cause a branch, the instruction \u201cdelay\u201d is executed. Thus, the program generated by the binary program conversion apparatus controls the CPU in the same manner that the original program does.</p><p>Hereinafter, the operation procedure in the branch prediction process will be explained by exemplifying a case where the program shown in FIG. 25 is given to the binary program conversion apparatus and the instruction blocks a and c in the program are executed by the profiler. Note that, in the following explanations, it is assumed that the value of BT/RUN for branch instructions (*11,*12) in the executed instruction blocks is larger than 0.5.</p><p>In this case, the program shown in FIG. 25 is converted into the program shown in FIG. <b>26</b>. Namely, to begin with, copying the executed instruction blocks into CaB area, relocations, reversing branch condition of branch instructions is carried out to the program. Thereafter, the branch instructions \u201cbe\u201d and \u201cbg\u201d with high probability to branch in the MTXT area in the processed program are substituted for the corresponding predictional branch instructions \u201cbe,pt\u201d and \u201cbg,pt\u201d, respectively (*13,*14). The copied branch instruction \u201cbg\u201d in the block c\u2032 is also substituted for the corresponding predictional branch instructions \u201cbg,pt\u201d (*16). On the other hand, with respect to the copied branch instruction in the block a\u2032, since processing to reverse the branch condition has been carried out, substitution for the predictional branch instruction \u201cbne, pn\u201d is performed (*15).</p><p>As discussed in detail above, the binary program conversion apparatus, when being given one or more object programs for conversion, adds a CaB area words on which will be stored in different locations in the cache memory to each of the object programs, and checks instruction blocks which will be executed. Then, if the total size of the instruction blocks which will be executed is not larger than the cache memory size, it copies part of the instruction blocks which will be executed into the CaB area and modifies some instruction codes so that the copies of the instruction blocks on the CaB area will be used. If the total size of the instruction blocks which will be executed is smaller than the cache memory size, it copies all the instruction blocks which will be executed into the CaB area so that the copies are stored in the cache lines which are not frequently used for storing data, and modifies some instruction codes so that the copies of the instruction blocks on the CaB area will be used.</p><p>Therefore, according to this binary program conversion apparatus, one or more new object programs can be obtained which have lower miss rates due to conflicts between instruction accesses than their original object programs in case where the total size of the instruction blocks that will be executed is larger than the cache memory size in the original object programs. Moreover, new object programs which causes no miss due to conflicts between instruction accesses and which also causes fewer misses due to conflicts between a instruction access and a data access can be obtained in case where the total size of the instruction blocks that will be executed is smaller than the cache memory size in their original object programs.</p><p>Furthermore, since conversion is carried out by packing the instruction blocks into the CaB area, the object program generated by the binary program conversion apparatus consumes smaller volume of the cache memory for storing unnecessary instruction blocks than the original program does. In other word, the binary program conversion apparatus generates the object program which utilizes the lines of the cache memory efficiently.</p><p>For example, by this binary program conversion apparatus, an object program by which the cache memory is utilized in a condition as shown in FIG. 27A is converted into a new object program by which the cache memory is used in a condition as shown in FIG. <b>27</b>B.</p><p>Note that, in FIGS. 27A and 27B, a value in the column \u201cline\u201d represents a line number of cache memory and a value in the column \u201cwi\u201d (i=0-15) represents a number of times access to the i-th word (4 bytes) was made in the corresponding cache line. A value in the column \u201caccess\u201d represents a sum of the numbers of times access to the 0th through 15th words was made in the corresponding cache line. A value in the column \u201cwc\u201d represents a number of words accessed (used) in the corresponding cache line. A value in the in the column \u201cn\u201d represents number of program lines which are stored in the corresponding cache line. Namely, a cache line whose value of \u201cn\u201d is larger than 1 is a line which was replaced several times (once at least) with another program line.</p><p>As clearly shown in FIG. 27A, when running the object program before conversion, there are cases where a cache line is used for holding a program line containing many unnecessary words (see values of \u201cwc\u201d).</p><p>On the other hand, since the binary program conversion apparatus packs instruction blocks which will be executed within the CaB area, thereby generating a new object program, when running the generated new object program, each cache line is used for holding one program line containing no or few unnecessary words as shown in FIG. <b>27</b>B. In fact, the average value of word usage ratios for the cache lines shown in FIG. 27B is 94.4% (15.1 words/line), while that for the original object program is 59.4% (9.5 words/line). Thus, the object program with high word usage ratio can be obtained by the binary program conversion apparatus.</p><p>Note that, the new object program is so generated by the binary program conversion apparatus that instruction codes which are included in the program line of the original object program relating to the row having \u201cline\u201d of <b>3698</b> and \u201cwc\u201d of 15 (the second row) in FIG. 27A will be stored in the 10th through 15th words of the cache line whose line number is <b>9742</b> and the 0th through 9th words of the cache line whose line number is <b>9743</b>, and instruction codes which are included in the program line relating to the 3rd, 5th, 6th, 8th, 10th, 12th, and 15th rows and are accessed will be stored within the cache lines whose line number are <b>9743</b>-<b>9748</b>, and the remaining instruction codes will be stored in the remaining words (words to which instruction codes are not allocated) in the cache lines with line numbers of <b>9742</b>, <b>9728</b> and <b>9749</b>.</p><p>In addition, the binary program conversion apparatus modifies the object program so that frequency at which control is transferred due to taking branch is lowered, and replaces some instruction codes with new, more suitable instruction codes, these modifications also increases the speed of the object program.</p><p>That is, since, in general, a control transfer to a remote address due to taking a branch needs longer time to be carried out than a control transfer to a next address, the modification for the branch instructions increases the speed of the object program. Moreover, there is often the case where an instruction code (or a combination of instruction codes) cannot be executed speedy by a target CPU, while the code (or the combination) can be executed speedy by another CPU. It is also a fact that, in such case, the target CPU generally has an alternative instruction code with the code. Consequently, the replacements of instruction codes also increases the speed of the object program.</p><p>Thus, according to the binary program conversion apparatus in the embodiment, since various optimizations are made to original binary program(s), new binary program(s) which runs at extremely high speed in the target computer can be obtained easily.</p><p>It should be noted that the binary conversion technique discussed so far can be applied to various computers besides the computer in the embodiment.</p><p>For example, the computer in the embodiment is provided with the cache memory having 16384 lines of 64 bytes. The present technique can be applied, of course, to a computer provided with a cache memory having lines of arbitrary number and sizes. Moreover, there are computers which have plural (normally two) cache memories between the CPU and the main memory. This technique can be applied to such a computer.</p><p>Furthermore, while the cache memory in the embodiment is a integrated type cache memory which stores data and instructions, the present technique can be applied to a computer provided with a so-called separated type cache memory which consists of a data cache to hold data, and an instruction cache to hold instructions. When applying the present technique to such a computer, processing related to the data use line table can be omitted, because no miss due to conflicts between an instruction access and a data access occurs in the separated type cache memory.</p><p>This technique can be applied to a computer having a set associative cache or full associative cache, while the computer in the embodiment has the direct mapped cache (which is equivalent with one way set associative cache). In such cashes, a cache line where a line containing a requested word is placed cannot be determined from an address of the requested word. But, a set (group of cache lines) where the line containing the requested word is placed can be determined from the address and the line is placed on a cache line which is in the set and not used for storing a line. Consequently, with respect to these caches, a cache line which will be used for holding the line can be specified based on the address of the requested word. Therefore, this technique can be applied to computers having set or full associative caches.</p><p>As a matter of course, this technique can be applied to a computer provided with not a virtual cache, but a physical cache in which indexing is carried out with using a physical address.</p><p>In short, this binary conversion technique can be applied to every computer in which a storing position of a requested word in the cache memory can be guessed from its address.</p><p>It should be also noted that part of this technique can be applied to a computer without a cache memory. For example, the replacement technique taught in the branch prediction process is effective to a computer without a cache memory. Because, with utilizing this technique, a original object program which contains instruction codes that are unsuitable for a target computer can be converted into a new object program which contains instruction codes that are suitable for the computer.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Yoshinobu", "last_name": "Hibi", "name": ""}, {"first_name": "Hidefumi", "last_name": "Nishi", "name": ""}, {"first_name": "Toshiki", "last_name": "Izuchi", "name": ""}, {"first_name": "Masaharu", "last_name": "Kitaoka", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "FUJITSU LIMITED"}, {"first_name": "", "last_name": "FUJITSU LIMITED", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/45"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/45        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "717151"}], "ecla_classes": [{"label": "G06F   8/52"}, {"label": "G06F   8/4442"}], "cpc_classes": [{"label": "G06F   8/4442"}, {"label": "G06F   8/52"}, {"label": "G06F   8/40"}, {"label": "G06F   1/00"}, {"label": "G06F   8/52"}, {"label": "G06F   8/4442"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1996-10-28", "application_date": "1997-10-03", "family_members": [{"ucid": "DE-69735342-T2", "titles": [{"lang": "EN", "text": "Binary program converter and method"}, {"lang": "DE", "text": "Bin\u00e4rprogrammkonvertierger\u00e4t und -verfahren"}]}, {"ucid": "DE-69735342-D1", "titles": [{"lang": "EN", "text": "Binary program converter and method"}, {"lang": "DE", "text": "Bin\u00e4rprogrammkonvertierger\u00e4t und -verfahren"}]}, {"ucid": "CN-1152287-C", "titles": [{"lang": "EN", "text": "Binary program conversion apparatus, binary program conversion method and program recording medium"}, {"lang": "ZH", "text": "\u4e8c\u8fdb\u5236\u7a0b\u5e8f\u8f6c\u6362\u8bbe\u5907\u548c\u8f6c\u6362\u65b9\u6cd5"}]}, {"ucid": "US-6591414-B2", "titles": [{"lang": "EN", "text": "Binary program conversion apparatus, binary program conversion method and program recording medium"}]}, {"ucid": "CN-1181528-A", "titles": [{"lang": "EN", "text": "Binary program conversion apparatus, binary program conversion method and program recording medium"}, {"lang": "ZH", "text": "\u4e8c\u8fdb\u5236\u7a0b\u5e8f\u8f6c\u6362\u8bbe\u5907,\u8f6c\u6362\u65b9\u6cd5\u548c\u7a0b\u5e8f\u8bb0\u5f55\u5a92\u4f53"}]}, {"ucid": "EP-0838755-B1", "titles": [{"lang": "FR", "text": "Appareil et m\u00e9thode pour convertir des programmes binaires"}, {"lang": "EN", "text": "Binary program conversion apparatus and method"}, {"lang": "DE", "text": "Bin\u00e4rprogrammkonvertierger\u00e4t und -verfahren"}]}, {"ucid": "EP-0838755-A3", "titles": [{"lang": "FR", "text": "Appareil et m\u00e9thode pour convertir des programmes binaires"}, {"lang": "EN", "text": "Binary program conversion apparatus and method"}, {"lang": "DE", "text": "Bin\u00e4rprogrammkonvertierger\u00e4t und -verfahren"}]}, {"ucid": "EP-0838755-A2", "titles": [{"lang": "FR", "text": "Appareil et m\u00e9thode pour convertir des programmes binaires"}, {"lang": "EN", "text": "Binary program conversion apparatus and method"}, {"lang": "DE", "text": "Bin\u00e4rprogrammkonvertierger\u00e4t und -verfahren"}]}, {"ucid": "KR-100297172-B1", "titles": [{"lang": "KO", "text": "\uc774\uc9c4\ud504\ub85c\uadf8\ub7a8\ubcc0\ud658\uc7a5\uce58\ubc0f\uc774\uc9c4\ud504\ub85c\uadf8\ub7a8\ubcc0\ud658\ubc29\ubc95"}, {"lang": "EN", "text": "BINARY PROGRAM CONVERSION APPARATUS AND BINARY PROGRAM CONVERSION METHOD"}]}, {"ucid": "KR-19980033137-A", "titles": [{"lang": "KO", "text": "\uc774\uc9c4 \ud504\ub85c\uadf8\ub7a8 \ubcc0\ud658\uc7a5\uce58, \uc774\uc9c4 \ud504\ub85c\uadf8\ub7a8 \ubcc0\ud658\ubc29\ubc95 \ubc0f \ud504\ub85c\uadf8\ub7a8\uae30\ub85d\ub9e4\uccb4"}, {"lang": "EN", "text": "Binary program converter, binary program conversion method and program recording medium"}]}, {"ucid": "US-20010003822-A1", "titles": [{"lang": "EN", "text": "BINARY PROGRAM CONVERSION APPARATUS, BINARY PROGRAM CONVERSION METHOD AND PROGRAM RECORDING MEDIUM"}]}]}