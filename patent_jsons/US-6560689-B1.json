{"patent_number": "US-6560689-B1", "publication_id": 73405072, "family_id": 24159605, "publication_date": "2003-05-06", "titles": [{"lang": "EN", "text": "TLB using region ID prevalidation"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50488960\"><p>A prevalidation content addressable memory, CAM, is used to pre-decode a virtual address region extension and enable it for use by a translation look-aside buffer, TLB. The prevalidation CAM removes the region extensions stored in region registers from a serial TLB look-up path.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00001\" num=\"1\"><claim-text>1. An apparatus comprising:</claim-text><claim-text>a storage unit to store a plurality of region identification values associated with addressing corresponding regions in memory and a plurality of index values corresponding to registers used to hold region addresses to access the regions in memory; </claim-text><claim-text>a translation buffer to receive a virtual address and to generate a physical address, if the virtual address matches a corresponding tag address stored in said translation buffer; and </claim-text><claim-text>an enable logic circuit to generate a line enable signal to enable an entry in said translation buffer for the corresponding tag address, if a region address in a selected register matches one of the region identification values and an index coded in the virtual address indexing the register holding the matching region address matches the index value for the corresponding region identification value, the line enable signal to allow access to one of the regions in memory without reading from the register to generate a second virtual address. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00002\" num=\"2\"><claim-text>2. The apparatus of <claim-ref idref=\"US-6560689-B1-CLM-00001\">claim 1</claim-ref>, wherein said storage unit comprises a content addressable memory to store the region identification values and the index values.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00003\" num=\"3\"><claim-text>3. The apparatus of <claim-ref idref=\"US-6560689-B1-CLM-00001\">claim 1</claim-ref>, wherein said storage unit uses the region addresses to map to a region of the memory that is allocated for a particular process.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00004\" num=\"4\"><claim-text>4. The apparatus of <claim-ref idref=\"US-6560689-B1-CLM-00001\">claim 1</claim-ref> further comprising a purge enable unit to purge a corresponding region of memory, if a region address in a selected register matches one of the region identification values.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00005\" num=\"5\"><claim-text>5. The apparatus of <claim-ref idref=\"US-6560689-B1-CLM-00001\">claim 1</claim-ref> further comprising a purge enable circuit to purge a region of memory, if a region address in a selected register matches one of the region identification values and an index coded in the virtual address indexing the register holding the matching region address matches the index value for the corresponding region identification value.</claim-text></claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00006\" num=\"6\"><claim-text>6. An address translation apparatus comprising:</claim-text><claim-text>a prevalidation unit to store a plurality of region identification values associated with addressing corresponding regions in memory and a plurality of index values corresponding to registers used to hold region addresses to access the regions in memory; </claim-text><claim-text>a translation look-aside buffer to receive a virtual address and to generate a physical address, if the virtual address matches a corresponding tag address stored in said translation look-aside buffer; and </claim-text><claim-text>an enable logic circuit to generate a line enable signal to enable an entry in said translation look-aside buffer for the corresponding tag address, if a region address in a selected register matches one of the region identification values and an index coded in the virtual address indexing the register holding the matching region address matches the index value for the corresponding region identification value, the line enable signal to allow prevalidation of region addresses to access regions in memory and enable corresponding entries in said translation look-aside buffer. </claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00007\" num=\"7\"><claim-text>7. The address translation apparatus of <claim-ref idref=\"US-6560689-B1-CLM-00006\">claim 6</claim-ref>, wherein said prevalidation unit comprises a content addressable memory to store the region identification values and the index values.</claim-text></claim>"}, {"num": 8, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00008\" num=\"8\"><claim-text>8. The address translation apparatus of <claim-ref idref=\"US-6560689-B1-CLM-00006\">claim 6</claim-ref>, wherein said prevalidation unit uses the region addresses to map to a region of the memory that is allocated for a particular process.</claim-text></claim>"}, {"num": 9, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00009\" num=\"9\"><claim-text>9. The address translation apparatus of <claim-ref idref=\"US-6560689-B1-CLM-00006\">claim 6</claim-ref> further comprising a purge enable unit to purge a corresponding region of memory, if a region address in a selected register matches one of the region identification values.</claim-text></claim>"}, {"num": 10, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00010\" num=\"10\"><claim-text>10. The address translation apparatus of <claim-ref idref=\"US-6560689-B1-CLM-00006\">claim 6</claim-ref> further comprising a purge enable circuit to purge a region of memory, if a region address in a selected register matches one of the region identification values and an index coded in the virtual address indexing the register holding the matching region address matches the index value for the corresponding region identification value.</claim-text></claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00011\" num=\"11\"><claim-text>11. A processor comprising:</claim-text><claim-text>a processing core to generate a virtual address to access a given region in memory; </claim-text><claim-text>a plurality of region identification registers to store region addresses; </claim-text><claim-text>a prevalidation unit to store a plurality of region identification values associated with addressing corresponding regions in memory and a plurality of index values corresponding to region identification registers used to hold region addresses to access the regions in memory; </claim-text><claim-text>a translation look-aside buffer to receive the virtual address and to generate a physical address, if the virtual address matches a corresponding tag address stored in said translation look-aside buffer; and </claim-text><claim-text>an enable logic circuit to generate a line enable signal to enable an entry in said translation look-aside buffer for the corresponding tag address, if a region address in a selected region identification register matches one of the region identification values and an index coded in the virtual address indexing the region identification register holding the matching region address matches the index value for the corresponding region identification value, the line enable signal to allow prevalidation of region addresses to access regions in memory and enable corresponding entries in said translation look-aside buffer. </claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00012\" num=\"12\"><claim-text>12. The processor of <claim-ref idref=\"US-6560689-B1-CLM-00011\">claim 11</claim-ref>, wherein said prevalidation unit comprises a content addressable memory to store the region identification values and the index values.</claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00013\" num=\"13\"><claim-text>13. The processor of <claim-ref idref=\"US-6560689-B1-CLM-00012\">claim 12</claim-ref>, wherein said prevalidation unit uses the region addresses to map to a region of the memory that is allocated for a particular process.</claim-text></claim>"}, {"num": 14, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00014\" num=\"14\"><claim-text>14. The processor of <claim-ref idref=\"US-6560689-B1-CLM-00012\">claim 12</claim-ref> further comprising a purge enable unit to purge a corresponding region of memory, if a region address in a selected register matches one of the region identification values.</claim-text></claim>"}, {"num": 15, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00015\" num=\"15\"><claim-text>15. The processor of <claim-ref idref=\"US-6560689-B1-CLM-00012\">claim 12</claim-ref> further comprising a purge enable circuit to purge a region of memory, if a region address in a selected register matches one of the region identification values and an index coded in the virtual address indexing the register holding the matching region address matches the index value for the corresponding region identification value.</claim-text></claim>"}, {"num": 16, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00016\" num=\"16\"><claim-text>16. A computer system comprising:</claim-text><claim-text>a memory; </claim-text><claim-text>a processor to generate a virtual address to access a given region in memory; </claim-text><claim-text>a plurality of region identification registers to store region addresses; </claim-text><claim-text>a prevalidation unit to store a plurality of region identification values associated with addressing corresponding regions in memory and a plurality of index values corresponding to region identification registers used to hold region addresses to access the regions in memory; </claim-text><claim-text>a translation look-aside buffer to receive the virtual address and to generate a physical address, if the virtual address matches a corresponding tag address stored in said translation look-aside buffer; and </claim-text><claim-text>an enable logic circuit to generate a line enable signal to enable an entry in said translation look-aside buffer for the corresponding tag address, if a region address in a selected region identification register matches one of the region identification values and an index coded in the virtual address indexing the region identification register holding the matching region address matches the index value for the corresponding region identification value, the line enable signal to allow prevalidation of region addresses to access regions in memory and enable corresponding entries in said translation look-aside buffer. </claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00017\" num=\"17\"><claim-text>17. The computer system of <claim-ref idref=\"US-6560689-B1-CLM-00016\">claim 16</claim-ref>, wherein said prevalidation unit comprises a content addressable memory to store the region identification values and the index values.</claim-text></claim>"}, {"num": 18, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00018\" num=\"18\"><claim-text>18. The computer system of <claim-ref idref=\"US-6560689-B1-CLM-00017\">claim 17</claim-ref>, wherein said prevalidation unit uses the region addresses to map to a region of the memory that is allocated for a particular process.</claim-text></claim>"}, {"num": 19, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00019\" num=\"19\"><claim-text>19. The computer system of <claim-ref idref=\"US-6560689-B1-CLM-00017\">claim 17</claim-ref> further comprising a purge enable unit to purge a corresponding region of memory, if a region address in a selected register matches one of the region identification values.</claim-text></claim>"}, {"num": 20, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00020\" num=\"20\"><claim-text>20. The computer system of <claim-ref idref=\"US-6560689-B1-CLM-00017\">claim 17</claim-ref> further comprising a purge enable circuit to purge a region of memory, if a region address in a selected register matches one of the region identification values and an index coded in the virtual address indexing the register holding the matching region address matches the index value for the corresponding region identification value.</claim-text></claim>"}, {"num": 21, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00021\" num=\"21\"><claim-text>21. A method comprising:</claim-text><claim-text>storing a plurality of region identification values associated with addressing corresponding regions in memory and a plurality of index values corresponding to region identification registers in a prevalidation unit to a translation look-aside buffer; </claim-text><claim-text>generating an enable signal to enable an entry in the translation look-aside buffer for a corresponding tag address of a virtual address, if a region address in a selected region identification register matches one of the region identification values and an index coded in the virtual address indexing one of the region identification registers holding the matching region address matches the index value for the corresponding region identification value, the enable signal to allow prevalidation of region addresses to access regions in memory and enable corresponding entries in the translation look-aside buffer. </claim-text></claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00022\" num=\"22\"><claim-text>22. The method of <claim-ref idref=\"US-6560689-B1-CLM-00021\">claim 21</claim-ref> further comprises changing the region address in one of the region identification registers which causes a respective entry for the tag in the translation look-aside buffer to be disabled by the enable signal, but returning the original region address in the one region identification register causes the respective entry for the tag in the translation look-aside buffer to be enabled.</claim-text></claim>"}, {"num": 23, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00023\" num=\"23\"><claim-text>23. The method of <claim-ref idref=\"US-6560689-B1-CLM-00021\">claim 21</claim-ref> further comprises purging a corresponding region of memory, if a region address in a selected region identification register matches one of the region identification values.</claim-text></claim>"}, {"num": 24, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560689-B1-CLM-00024\" num=\"24\"><claim-text>24. The method of <claim-ref idref=\"US-6560689-B1-CLM-00021\">claim 21</claim-ref> further comprises purging a corresponding region of memory, if a region address in a selected region identification register matches one of the region identification values and an index coded in the virtual address indexing the region identification register holding the matching region address matches the index value for the corresponding region identification value.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53919838\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates to the field of computer architecture and more specifically to a translation look-aside buffer for translating virtual addresses to physical addresses.</p><p>2. Description of the Related Art</p><p>In a computer, a typical practice is to use a translation look-aside buffer (TLB) to translate a virtual address to a physical address. The TLB generally operates to receive all or part of a virtual address and determines if an entry stored in the TLB matches the received virtual address. If there is a match, the TLB provides the physical address stored in the TLB which corresponds to the matched entry. This physical address from the TLB is typically combined with offset bits of the virtual address to generate a complete physical address. In TLB structures, the offset size is a function of the page size for the computer architecture being implemented.</p><p>The TLB essentially operates as a fast cache memory, which stores a subset of the total virtual to physical address translation mappings. When a virtual address matches one of the translations stored in the TLB, it is termed a TLB hit. When a TLB hit occurs, the physical address is quickly generated. If there is a miss, a delay is encountered in generating the physical address while the missing address translation is found, placed in the TLB, and a repetition of the original access is performed.</p><p>Processor architectures define the virtual addressing scheme to access the physical memory. Although various paging, segmentation, and other schemes can be employed, the addressing scheme is constrained by the number of bits available for processing the addresses. TLBs are designed within these constraints. TLBs using content addressable memory (CAM) can quickly match the virtual address to the entries stored in the TLB. However, as architectures expand from 32 to 64 bits, 128 bits and higher, the achitecture and the addressing scheme become more complex. The complexity often results in slower processor operation.</p><p>Accordingly, the present invention pertains to the operation of a TLB in a computer.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 is a schematic block diagram of an architectural model for translating a virtual address having a region extension to a physical address in a translation look-aside buffer.</p><p>FIG. 2 illustrates the translation of the virtual address to a physical address for the schematic diagram of FIG. <b>1</b>.</p><p>FIG. 3 is a schematic block diagram of the present invention in which a prevalidation CAM is used with the TLB to pre-decode the region extension portion of the virtual address.</p><p>FIG. 4 illustrates the translation of the virtual address to a physical address for the schematic diagram of FIG. <b>3</b>.</p><p>FIG. 5 illustrates the use of a line enable bit for enabling a valid selected entry in the prevalidation CAM.</p><p>FIG. 6 is a schematic block diagram of a line enable circuit of the preferred embodiment for generating the line enable bit.</p><p>FIG. 7 is a schematic block diagram of a purge enable circuit of the preferred embodiment for generating a purge enable bit for use in purging the TLB.</p><p>FIG. 8 is a schematic block diagram illustrating an arrangement of array cells which comprise the prevalidation circuit of the present invention.</p><p>FIG. 9 is a schematic block diagram of a single-ported CAM cell used in the prevalidation CAM.</p><p>FIG. 10 is a schematic block diagram exemplifying a computer system in which the present invention is implemented to translate a virtual address to a physical address.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>Referring to FIG. 1, an architectural address translation model <b>10</b> for a 64-bit addressing scheme is shown. FIG. 2 illustrates a bit flow diagram as the addresses transition through the components shown in FIG. <b>1</b>. Accordingly a 64-bit virtual address, VA[<b>63</b>:<b>0</b>] (the [<b>63</b>:<b>0</b>] denotes bits 0 through 63), enters FIGS. 1 and 2 for translation to a physical address PA[<b>63</b>:<b>0</b>]. Typically, the virtual address VA is generated by a processor core. The model <b>10</b> is strictly for illustration of the architecture of a 64-bit addressing scheme for generating physical addresses. The invention operates in concordance with the architecture of the model <b>10</b> (with some noted exceptions) in generating physical addresses, but the invention implementation will appear different.</p><p>In the architectural address translation model <b>10</b>, three of the bits VA[<b>63</b><b>61</b>] are used to select one of eight Region IDentification (RID) registers <b>11</b>. A three to eight decoder is used for selecting the register identified by VA[<b>63</b>:<b>61</b>]. It is appreciated that less/more RID registers <b>11</b> can be used and selected by decoding of less/more bits. The RID registers <b>11</b> each contain a value that is designated as a region identifier or RID. Each RID is used to identify a region in memory. This is in addition to any paging, segmentation, etc. In practicing the invention, an operating system executed by a processor selects and utilizes the different regions for different programs or functions.</p><p>For example, when a process is to be switched (such as when context switching is performed in a processor), the processor selects a set of region identifiers to identify the different regions of memory associated with the second process which is to be switched in. Accordingly, during the context switch, the RID registers <b>11</b> are loaded with values of the region identifiers which correspond to the regions of memory associated with the new process. It is to be noted, that regions of memory can be exclusive, shared or overlapped, so that the same RID value may be present in two or more RID registers <b>11</b> and/or may be allocated to multiple processes. In the example of FIG. 1, each RID register <b>11</b> holds a 24-bit RID value, noted as RID[<b>23</b>:<b>0</b>]. The RID[<b>23</b>:<b>0</b>] value identifies the location of a particular region in memory associated with a process using that RID register <b>11</b>. Thus, VA[<b>63</b>:<b>61</b>] selects one of the RID registers <b>11</b> whose output RID[<b>23</b>:<b>0</b>] is used for further translation of the virtual address signal.</p><p>In the operational model, the RID [<b>23</b>:<b>0</b>] bits are concatenated with the remaining VA[<b>60</b>:<b>0</b>] bits to form an 85-bit secondary virtual address VA\u2032[<b>84</b>:<b>0</b>]. The RID[<b>23</b>:<b>0</b>] becomes VA\u2032[<b>84</b>:<b>61</b>], and VA[<b>60</b>:<b>0</b>] is used for VA\u2032[<b>60</b>:<b>0</b>]. Thus, the secondary virtual address VA\u2032[<b>84</b>:<b>0</b>] is 85 bits in length and assuming a minimum page size of 4K, all but twelve of the bits are translated by a TLB <b>12</b>.</p><p>Bits VA\u2032[<b>84</b>:<b>12</b>] are coupled to a TLB content addressable memory (CAM) array <b>13</b> for translation. The TLB CAM <b>13</b> contains entries/logic such that when in operation, if the address input matches an entry in the CAM <b>13</b> (a TLB hit), a corresponding location in a TLB data array (shown in the Figures as a random-access-memory, RAM) <b>14</b> outputs a portion of a physical address noted as PA[<b>63</b>:<b>12</b>]. If a TLB miss occurs (the address input does not match an entry in the CAM <b>13</b>), then the system invokes one of a variety of routines to obtain the missing translation (virtual address to physical address mapping) to be placed within the TLB (CAM and RAM arrays), places the translation into the TLB and the translation is performed again.</p><p>In the example model <b>10</b>, the lower twelve bits of the virtual address VA\u2032[<b>11</b>:<b>0</b>] represent offset within a 4K memory page. VA\u2032[<b>11</b>:<b>0</b>] require no translation in the TLB <b>12</b> and form a portion PA[<b>11</b>:<b>0</b>] of the physical address. Once virtual to physical translation is completed, the 64-bit physical address, PA[<b>63</b>:<b>0</b>], is used to access a storage location, such as main memory of a computer. In the example, the page size implemented is 4 k (2<sup>12</sup>), i.e. VA\u2032[<b>11</b>:<b>0</b>] is used for addressing locations within the page. The offset/TLB data array/concatenation can be designed for other page sizes or designed to support variable page sizes as well.</p><p>The 64-bit virtual address VA[<b>63</b>:<b>0</b>] is converted to an 85-bit secondary virtual address by the utilization of the RID registers <b>11</b>. Subsequently, 73 bits of this secondary virtual address are input to the TLB <b>14</b> for translation to generate a physical address. The RID bits are utilized to identify regions of memory specifically by processes which access a particular RID register. Again, typical practice is to assign different region identifiers for different processes, so that separate regions in memory can be configured to accommodate these different processes.</p><p>The architectural model <b>10</b> allows for regional identification of memory, but if the architecture is implemented structurally pursuant to the signal flow shown in FIG. 2, some disadvantages could result. The model <b>10</b> actually has two translations which are performed serially. First; VA[<b>63</b>:<b>61</b>] is used to select RID[<b>23</b>:<b>0</b>] for the first translation. Subsequently, RID[<b>23</b>:<b>0</b>] is then used for the second translation performed in the TLB <b>12</b>. Thus, two serial translations are required.</p><p>Since the first translation is a register read, the output from the register can only occur after VA[<b>63</b>:<b>61</b>] has been decoded. The RID register <b>11</b> output is then sent to the TLB <b>12</b> for the TLB translation. The two serial translations may require more than one clock cycle to perform. Additionally, the TLB CAM <b>13</b> needs to process 73 bits of secondary virtual address, VA\u2032[<b>84</b>:<b>12</b>]. The additional 24 bits of RID[<b>23</b>:<b>0</b>] increases the size of the CAM entry by about a third. The additional CAM size results in a slower response in the translation of the virtual address, as the CAM entry hit detection time scales with the number of entries and the number of address bits being compared.</p><p>In order to provide an efficient implementation of the architectural model <b>10</b> of FIG. 1, the present invention utilizes a prevalidation CAM to remove the RID registers from the TLB look-up path and reduce the number of address bits compared in the TLB CAM during accesses. Accordingly, as shown in FIGS. 3 and 4, a prevalidation CAM <b>20</b> is utilized to pre-decode the RID portion of the secondary virtual address used by TLB CAM array <b>13</b>.</p><p>The prevalidation CAM <b>20</b> of the preferred embodiment is an array having one entry <b>21</b> per TLB entry where any/multiple prevalidation CAM entries can contain representations for the contents of an RID register and a typical implementation would have many more TLB/prevalidation CAM entries than RID registers.</p><p>When a new entry is placed in the TLB, its corresponding prevalidation CAM entry is loaded as well via replacement path <b>22</b>. The TLB CAM <b>13</b> is loaded with the virtual address, VA[<b>63</b>:<b>12</b>] (Note from FIG. 1 that VA[<b>63</b>:<b>61</b>] is used to select a RID register and thus generate the secondary virtual address bits VA\u2032[<b>84</b>:<b>61</b>], where VA\u2032[<b>60</b>:<b>12</b>]=VA[<b>60</b>:<b>12</b>]). The corresponding prevalidation CAM entry is loaded with the RID Register Index (number), RI[<b>2</b>:<b>0</b>] (which is the same as VA[<b>63</b>:<b>61</b>]), and VA\u2032[<b>84</b>:<b>61</b>] (RID[<b>23</b>:<b>0</b>]) of the corresponding TLB entry, of the RID register which was identified by VA[<b>63</b>:<b>61</b>] of the new TLB entry upon insertion. Additionally, since the prevalidation CAM entry VA\u2032[<b>84</b>:<b>61</b>] (RID[<b>23</b>:<b>0</b>]) of the corresponding TLB entry matches RID[<b>23</b>:<b>0</b>] of the RID register identified by the prevalidation CAM entry RI[<b>2</b>:<b>0</b>], Line Enable <b>26</b> of the TLB entry which corresponds to the prevalidation CAM entry will be set (enabled).</p><p>The RID[<b>23</b>:<b>0</b>] and RI[<b>2</b>:<b>0</b>] values are stored in the prevalidation CAM <b>20</b> array, are used to provide a predecode of the VA\u2032[<b>84</b>:<b>61</b>] portion of the address that would architecturally be sent to the TLB CAM <b>13</b> (as shown in FIG. <b>1</b>). Thus, when a virtual address VA[<b>63</b>:<b>0</b>] is received for translation, a secondary virtual address VA\u2032 does not need to be generated/compared. More specifically, if the Line Enable <b>26</b> of a TLB entry is set, it indicates that the architectural secondary virtual address VA\u2032[<b>84</b>:<b>61</b>] will match that of the TLB entry (stored as RID[<b>23</b>:<b>0</b>] in the corresponding prevalidation CAM entry), if VA[<b>63</b>:<b>61</b>] points to the RID register identified by RI[<b>2</b>:<b>0</b>] (in the corresponding prevalidation CAM entry) and the content of that RID register has not changed since the TLB entry was inserted. Since RI[<b>2</b>:<b>0</b>] is the same as VA[<b>63</b>:<b>61</b>] upon TLB entry insertion, it is implied that so long as the RID register content has not changed, a TLB entry with its Line Enable set, whose stored VA[<b>63</b>:<b>61</b>] matches the incoming VA[<b>63</b>:<b>61</b>], VA\u2032[<b>84</b>:<b>61</b>] of the incoming access would have matched VA\u2032[<b>84</b>:<b>61</b>] of the TLB entry if the RID registers had been read (using VA[<b>63</b>:<b>61</b>]). Therefore, instead of sending VA\u2032[<b>84</b>:<b>12</b>] to the TLB, VA[<b>63</b>:<b>12</b>] can be directly sent to the TLB (as shown in FIGS. <b>3</b> and <b>4</b>), where VA[<b>60</b>:<b>12</b>]=VA\u2032[<b>60</b>:<b>12</b>], and a match of VA[<b>63</b>:<b>61</b>] with the Line Enable set actually implies a match of VA\u2032[<b>84</b>:<b>61</b>].</p><p>The offset bits VA[<b>11</b>:<b>0</b>] are used in the same manner as previously described. That is, VA[<b>11</b>:<b>0</b>] bypasses the TLB <b>12</b> to generate PA[<b>11</b>:<b>0</b>] to address each 4 k page selected. Again, as previously described, the number of these offset bits need not be constrained to twelve bits as shown in the example illustrations of FIGS. 1-4.</p><p>It is to be noted that several other units are shown in FIGS. 3 and 4. For example, buffers <b>25</b> are used between the TLB CAM array <b>13</b> and the TLB data array <b>14</b> for buffering the match signal from the TLB CAM <b>13</b> and a purge enable (PE) circuit <b>27</b> is placed between the prevalidation CAM <b>20</b> and the TLB CAM <b>12</b>.</p><p>As previously described, the use of Line Enable <b>26</b>, with VA[<b>63</b>:<b>61</b>] allows the TLB to perform virtual address match calculations without first reading the RID registers and generating VA\u2032[<b>84</b>:<b>61</b>]. However, it also follows, that if the content of the RID register identified by a prevalidation CAM array entry RI[<b>2</b>:<b>0</b>], does not match its RID[<b>23</b>:<b>0</b>] (which represents VA\u2032[<b>86</b>:<b>61</b>] of the corresponding TLB entry), then it should not be possible to match the TLB entry. This case can be generated by changing the contents of a RID register (after TLB/prevalidation CAM array entries have been loaded based upon its previous value). It is enforced by clearing of the Line Enables of affected TLB/prevalidation CAM array entries (if a TLB entry Line Enable <b>26</b> is not set, then the entry cannot be matched) as described below.</p><p>In FIG. 5, an example is shown using arbitrary values for the RI and RID values. On the first line, RID register number five is shown with an initial RID value (RID register RID[<b>23</b>:<b>0</b>]) of \u201cA\u201d. A prevalidation CAM entry <b>20</b> corresponding to a TLB entry for which VA[<b>63</b>:<b>61</b>]=5, was loaded based upon this RID register value, and therefore contains a prevalidation CAM RID [<b>23</b>:<b>0</b>]=\u201cA\u201d and an RI[<b>2</b>:<b>0</b>]=5. The Line Enable bit <b>26</b> of this entry is set to \u201c1\u201d because the same RID [<b>23</b>:<b>0</b>] values are loaded into RID register number five and the prevalidation CAM <b>20</b> which points to a RID register number five (RI[<b>2</b>:<b>0</b>]=5).</p><p>The second line in FIG. 5 exemplifies a situation where the Operating System (OS) changes the content of RID register number five, as in a context switch, to \u201cB\u201d (RID register RID[<b>23</b>:<b>0</b>]=\u201cB\u201d). However, the prevalidation CAM entry RID[<b>23</b>:<b>0</b>], still contains the old value \u201cA\u201d (i.e. if a program tried to access a region via VA[<b>63</b>:<b>61</b>]=5, it would get \u201cB\u201d for VA\u2032[<b>84</b>:<b>61</b>], not \u201cA\u201d). Therefore, all prevalidation CAM entries (and their corresponding TLB entries) which point to RID register number five (via their RI[<b>2</b>:<b>0</b>] and their corresponding TLB CAM entry's VA[<b>63</b>:<b>61</b>] bits), but do not contain RID[<b>23</b>:<b>0</b>]=\u201cB\u201d must be disabled. This is done by clearing their Line Enable 26 bits to \u201c<b>0</b>\u201d, as shown in FIG. <b>5</b>.</p><p>On the last line in FIG. 5, the OS changes the content of RID register number five back to \u201cA\u201d (RID register RID[<b>23</b>:<b>0</b>]=\u201cA\u201d) and the prevalidation CAM entry RID[<b>23</b>:<b>0</b>], still contains the old value \u201cA\u201d (i.e. if a program tried to access a region via VA[<b>63</b>:<b>61</b>]=5, it would again get \u201cA\u201d for VA\u2032[<b>86</b>:<b>61</b>]). Therefore, all prevalidation CAM entries (and their corresponding TLB entries) which point to RID register number five (via their RI[<b>2</b>:<b>0</b>] and their corresponding TLB CAM entry's VA[<b>63</b>:<b>61</b>] bits), which contain RID[<b>23</b>:<b>0</b>]=\u201cA\u201d should be re-enabled. This is done by setting their Line Enable 26 bits to \u201c1\u201d, as shown in FIG. <b>5</b>. It is to be noted that the previously described process for setting/clearing of the Line Enable bits <b>26</b> and use of the Line Enable bits as a substitute for the architectural process of generating VA\u2032[<b>84</b>:<b>61</b>] and comparing VA\u2032[<b>86</b>:<b>61</b>] with TLB CAM contents to determine entry matches differs from the strict architectural model <b>10</b>. In the case that two RID registers, for example RID registers <b>3</b> and <b>5</b>, contain the same RID[<b>23</b>:<b>0</b>] value, for example \u201cX\u201d, a TLB entry which matched VA\u2032[<b>84</b>:<b>61</b>]=\u201cX\u201d would match if VA[<b>63</b>:<b>61</b>] was <b>3</b> or <b>5</b>, a TLB entry created according to the invention implementation could only match one or the other (two entries would be required to match both).</p><p>FIG. 6 shows an example of the logic used to set and clear the Line Enable 26 bits. Each prevalidation CAM entry would contain such logic. The Line Enable 26 bit cell shown in FIG. 6 may be read and written explicitly via the complementary bit lines BL and BL# using the Prevalidation and TLB CAM word line (used to set the Line Enable when new TLB entries are inserted). Alternatively, the Line Enable (LE) bit will be set to \u201c1\u201d, if the Set/Clear enable is active (\u201c1\u201d), the Prevalidation RI match <b>32</b> is active (\u201c1\u201d), and the Prevalidation RID Value Match <b>33</b> is active (\u201c1\u201d). The Line Enable bit will be cleared or reset to \u201c0\u201d, if the Set/Clear enable is active (\u201c1\u201d), and the Prevalidation RI match <b>32</b> is active (\u201c1\u201d), and the Prevalidation RID Value Match <b>33</b> is inactive (\u201c0\u201d). Otherwise, the Line Enable bit <b>26</b> will retain its previous state. For purposes of TLB purging, the Line Enable <b>26</b> can be temporarily asserted without changing its permanent state when the TLB Purge Enable is asserted (\u201c1\u201d).</p><p>As previously explained in the description of FIG. 5, when a RID register is written with a new RID value (RID[<b>23</b>:<b>0</b>]), those Prevalidation CAM array entries which point to the RID register being written (according to their RI[<b>2</b>:<b>0</b>] bits), that have the same RID value as the new value of the RID register, must have their corresponding Line Enables set, and those Prevalidation CAM array entries which point to the RID register being written (according to their RI[<b>2</b>:<b>0</b>] bits), that do not have the same RID value as the new value of the RID register, must have their corresponding Line Enables cleared. To accomplish this using the structures shown in FIG. 6, when a RID register is written, the RID register number is compared with the RI[<b>2</b>:<b>0</b>] bits of each Prevalidation CAM array entry via comparator <b>30</b> to generate the Prevalidation RI Match <b>32</b> signal. Additionally, the new RID register value is compared with the RID[<b>23</b>:<b>0</b>] bits of each Prevalidation CAM array entry via comparator <b>31</b> to generate the Prevalidation RID Value Match <b>33</b> signal. Simultaneously, the Set/Clear Enable signal is temporarily asserted to \u201c1\u201d to allow the results of the match signals <b>32</b> and <b>33</b> to update the Line Enables.</p><p>In the described embodiment, it is to be noted that the RID value match alone will not generate a line enable of \u201c1\u201d. There must also be an index match as well. It is also to be noted that line enable clearing is not a purging function, since the prevalidation CAM entries <b>21</b> are not affected by the Line Enable cleaning operation. The LE bit is one of the control signals which gates the generation of a TLB hit. By using the LE bit, the TLB/prevalidation CAM entry can be re-enabled if the RID register it points to is reloaded with the original RID value. Furthermore, it is to be noted that the LE bit is in addition to any other valid bit(s) used for gating whether or not a TLB entry can be matched.</p><p>TLB purges (the removal/invalidation of TLB entries described by ranges of virtual addresses) are performed with the aid of the Purge Enable circuit <b>27</b>. An architectural purge, according to architectural model <b>10</b> would input a VA\u2032[<b>84</b>:<b>12</b>] and a range (for example 4M bytes), and all TLB entries whose CAM entry virtual address fell within a 4M bytes range starting at VA\u2032[<b>84</b>:<b>12</b>] (aligned to the nearest, lower, 4M byte boundary) would be invalidated/eliminated. Architectural purges are generally purges initiated according to software and thus have expected/guaranteed results. Hardware purges are initiated by hardware for the purpose of TLB clean up and thus may have inconsistent results from implementation to implementation. For example, in the event a TLB miss occurs and a hardware engine is used to find/insert the missing translation, it would be desirable to purge the TLB of any entries which overlapped the new entry before the new entry was inserted (to avoid any possibility of electrical contention). This type of purge is not designed to eliminate a TLB translation, but is only designed to clean up the TLB. Thus, for the example, TLB translations which overlap the new translation from an architectural perspective, like model <b>10</b>, would be optionally purged, and TLB translations which overlapped the new translation from an implementation perspective would be required to be purged.</p><p>One example of a Purge Enable (PE) circuit <b>27</b> is shown in FIG. <b>7</b>. The purge enable is used to facilitate architectural purges. An architectural purge, as previously described, as intended to invalidate/eliminate all TLB entries whose CAM entries fall within a given secondary virtual address range. The purged range is expected to function independently of the RID register used to obtain the purging secondary address range, and in fact, could be supplied from an external source such that the TLB purging VA\u2032[<b>84</b>:<b>61</b>] input does not correspond to any of the local processor's current RID register values. For the invention to perform an architectural purge, the input VA\u2032[<b>84</b>:<b>61</b>] is compared against all prevalidation CAM entries RID[<b>23</b>:<b>0</b>] values to generate Prevalidation RID Value Match <b>33</b> signals. At the same time, the Set Enable of the Prevalidation CAM Purge Enable Cell in FIG. 7 is temporarily asserted to \u201c1\u201d allowing the Purge Enable bits of the TLB entries whose prevalidation RID Value Match <b>33</b> signals are asserted to be set to \u201c1\u201d. The setting of the Purge Enables will cause the Line Enables to be asserted (as shown in FIG. 6) for those TLB entries whose prevalidation CAM entries contain RID values (RID[<b>23</b>:<b>0</b>] which maps to VA\u2032[<b>84</b>:<b>61</b>] of the TLB entry) that match the VA;[<b>84</b>:<b>61</b>] input. The remainder of the supplied purge address, VA\u2032[<b>60</b>:<b>12</b>] is then compared against the TLB CAM entries. TLB entries whose CAM contents match the VA\u2032[<b>60</b>:<b>12</b>] supplied, and whose Line Enable bits are set are invalidated. Note, because architectural purges are independent of the RID register used to generate VA\u2032[<b>84</b>:<b>12</b>], the prevalidation CAM array RI bits and the TLB CAM VA[<b>63</b>:<b>61</b>] bits are not a part of the purging function. During architectural purges, comparisons against the TLB CAM entry's VA[<b>63</b>:<b>61</b>] bits are don't cared/forced to match. The use of the Purge Enable to force Line Enables active (Purge Enable generation is based solely upon RID Value Matching) eliminates the RI bits from affecting the purging process. Once the TLB entry invalidations have been completed, the Reset of the Prevalidation CAM Purge Enable Cell in FIG. 7 is temporarily asserted to \u201c1\u201d, thus clearing the Purge Enable bits of the TLB entries to \u201c0\u201d.</p><p>It is to be noted that the PE signal applies to the RID value only. The TLB <b>12</b> will also CAM appropriate bits of the VA[<b>60</b>:<b>12</b>] for a match to complete the address matching of the purge. Some or all of the bits of the VA[<b>60</b>:<b>12</b>] may be don't cared where the purge being effected is for a larger size page. For example, to purge a 64K page, bits VA[<b>15</b>:<b>12</b>] are don't cared/forced to match.</p><p>Hardware purges, as previously described, are used to clean up a TLB. For example, a hardware purge used to remove TLB existing which overlap a new entry to be inserted (as a result of a hardware engine search for a missing translation) before the insertion takes place in order to avoid any possibility of electrical contention. Since this purge is only intended to eliminate electrical contention (multiple TLB matches for a single input address), it is only necessary to compare the VA[<b>63</b>:<b>12</b>] and page size/range of the new translation against the TLB CAM array. If the TLB entry Line Enable is set, and the TLB CAM array matches the address/page size input, then the entry will be invalidated. It is not necessary to invalidate any TLB entries whose Line Enables are not set as they cannot be matched (and therefore cannot cause contention with the new entry).</p><p>It is to be further noted that the present invention can be implemented in a variety of ways to practice the invention. One embodiment is shown in FIG. 8, wherein the prevalidation CAM <b>20</b> is structured as multiple arrays, having the wordlines (WL) coupled together. A RID index (RI) CAM array <b>40</b> cams the RI[<b>2</b>:<b>0</b>] against the stored index pointer and a RID CAM <b>41</b> cams the RID[<b>23</b>:<b>0</b>] against the stored RID value. A purge cell array <b>42</b> and line enable cell array <b>43</b> are employed for generating the purge enable and line enable signals, respectively. The four array units <b>40</b>-<b>43</b> form the prevalidation array <b>20</b>, which is then placed physically proximal to the TLB <b>12</b>.</p><p>FIG. 9 shows an exemplary circuit of a single-ported CAM cell for the prevalidation CAM <b>20</b>. The cell is written via the complementary bit lines BL and BL# when the Word Line is active (\u201c1\u201d). The cell performs comparisons using the complementary CAM input lines CA and CA#. While the CA and CA# lines are both \u201c1\u201d, the Match line is precharged to a \u201c1\u201d. Then, the value to be compared is placed on the complementary CAM input lines (if the value is \u201c1\u201d, CA is \u201c1\u201d and CA# is \u201c0\u201d, if the value is \u201c0\u201d, CA is \u201c0\u201d and CA# is \u201c1\u201d, if the value is to be a don't care, CA is \u201c1\u201d and CA# is \u201c1\u201d). If the CAM input value matches that of the CAM cell contents or is a \u201cdon't care\u201d, then the Match line will remain active (\u201c1\u201d), else it will be discharged to \u201c0\u201d indicating a mismatch. Multiple cells can share a single match line in order to provide comparisons of larger pieces of data. As shown, the CAM cell is single-ported. It can be made multi-ported, but for the specific embodiment, it was only possible to write on RID register per clock. Therefore, only one port was needed to update the prevalidation CAM <b>20</b> array. In contrast, the embodiment had a multi-ported TLB. When performing a TLB look-up, multiple virtual addresses, VA[<b>63</b>:<b>12</b>], would be presented to the TLB to generate physical addresses. This yielded another advantage to this invention in that, for those virtual address bits (VA\u2032[<b>84</b>:<b>61</b>] in this case) which are moved to the prevalidation CAM <b>20</b> instead of being placed in the TLB CAM, only a single-ported CAM cell is needed (assuming only 1 RID register update per clock) even if the TLB is multi-ported (which saves array area). However, the porting techniques are a design choice and various configurations can be adapted to practice the invention.</p><p>FIG. 10 illustrates one typical system implementation for the invention. A computer <b>50</b> is shown in which a processor <b>51</b> functions as a sole or one of a plurality of processors comprising the central processing unit (CPU) or units of the computer <b>50</b>. Typically, the processor <b>51</b> is embodied in a single integrated circuit chip. The processor <b>51</b> includes an execution (processing) core <b>52</b>, which has one or more execution units. A section of the processor is dedicated to memory management and is typically referred to as a memory management unit (MMU), among other names. A MMU <b>53</b> is shown coupled to the core <b>52</b>. In this embodiment, the region registers <b>11</b>, prevalidation CAM <b>20</b>, TLB components <b>13</b> and <b>14</b> are shown as part of the MMU <b>53</b>. It is appreciated that the registers <b>11</b> could be located elsewhere in the processor <b>51</b>. Generally, the prevalidation CAM <b>20</b> and the TLB <b>12</b> are located together and generally in the MMU.</p><p>The invention is practiced according to the description above to receive a virtual address from the core <b>52</b> and generate a physical address for accessing a memory location. The memory can be located on-chip (as shown by on-chip memory <b>54</b>) or off-chip (as shown by off-chip memory <b>55</b>). Typically, the on chip memory can be a cache memory or part of the main memory (RAM). The off-chip memory is typically comprised of main memory (but may include a cache), which also is coupled to other memory devices, such as to a disk storage medium. However, it is to be noted, that the invention can be configured in other ways to perform the address translation described above.</p><p>Thus, a prevalidation CAM for use with a TLB to translate virtual address to a physical address is described. The pre-decoding of the RID portion of the TLB translation removes the register-based virtual address extension from the TLB lookup timing path, therein reducing the time required for the virtual address translation. Enable bits are used to indicate lines which are mapped to RID values currently in the RID register file. The TLB CAM array will use the pre-validated line enable bits as a substitute for the look-up of the regional portion of the virtual address when performing TLB look-ups.</p><p>The invention allows for the architectural virtual address extension without causing impact to the TLB look-up. It also reduces the area consumed by multi-ported TLBs to support these extensions. That is, if the address extension is made part of the TLB CAM, the extension portion would be required for each port of a multi-ported TLB. Additionally, the prevalidation CAM is positioned on the side of the TLB to keep the prevalidation CAM <b>20</b> out of the path between the TLB CAM <b>13</b> and the RAM array <b>14</b>. Furthermore, the invention allows for two types of purging to be performed.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Gregory S.", "last_name": "Mathews", "name": ""}, {"first_name": "Gary", "last_name": "Hammond", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTEL CORPORATION"}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/14"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/10        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711204"}, {"primary": false, "label": "711108"}, {"primary": false, "label": "711220"}, {"primary": false, "label": "711152"}, {"primary": false, "label": "711E12065"}], "ecla_classes": [{"label": "G06F  12/10L2"}], "cpc_classes": [{"label": "G06F  12/1036"}, {"label": "G06F  12/1036"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "2000-03-31", "application_date": "2000-03-31", "family_members": [{"ucid": "US-6560689-B1", "titles": [{"lang": "EN", "text": "TLB using region ID prevalidation"}]}]}