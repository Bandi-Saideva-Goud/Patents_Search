{"patent_number": "US-4398243-A", "publication_id": 69112554, "family_id": 22504989, "publication_date": "1983-08-09", "titles": [{"lang": "EN", "text": "Data processing system having a unique instruction processor system"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA9445871\" source=\"translation\"><p>A data processing system which handles thirty-two bit logical addresses which can be derived from either sixteen bit logical addresses or thirty-two bit logical addresses, the latter being translated into physical addresses by unique translation means. The system includes means for decoding macro-instructions of both a basic and an extended instruction set, each macro-instruction containing in itself selected bit patterns which uniquely identify which type of instruction is to be decoded. The decoded macro-instructions provide the starting address of one or more micro-instructions, which address is supplied to a unique micro-instruction sequencing unit which appropriately decodes a selected field of each micro-instruction to obtain each successive micro-instruction. The system uses hierarchical memory storage using eight storage segments (rings), access to the rings being controlled in a privileged manner according to different level of privilege. The memory system uses a bank of main memory modules which interface with the central processor system via a dual port cache memory, block data transfers between the main memory and the cache memory being controlled by a bank controller unit.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA36404140\"><p>A data processing system which handles thirty-two bit logical addresses which can be derived from either sixteen bit logical addresses or thirty-two bit logical addresses, the latter being translated into physical addresses by unique translation means. The system includes means for decoding macro-instructions of both a basic and an extended instruction set, each macro-instruction containing in itself selected bit patterns which uniquely identify which type of instruction is to be decoded. The decoded macro-instructions provide the starting address of one or more micro-instructions, which address is supplied to a unique micro-instruction sequencing unit which appropriately decodes a selected field of each micro-instruction to obtain each successive micro-instruction. The system uses hierarchical memory storage using eight storage segments (rings), access to the rings being controlled in a privileged manner according to different level of privilege. The memory system uses a bank of main memory modules which interface with the central processor system via a dual port cache memory, block data transfers between the main memory and the cache memory being controlled by a bank controller unit.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. In a data processing system, an instruction processor means for decoding a plurality of first instructions forming a first designated basic instruction set the addresses of which have a first selected number of bits and a plurality of second instructions forming a second designated extended instruction set the addresses of which have a second selected number of bits different from said first selected number, each of said first or second instructions including at least an operating code portion which includes a selected bit code combination which identifies whether said instruction is from said basic instruction set or from said extended instruction set and some of said first and second instructions further including at least one displacement portion, said instruction processor means comprising<claim-text>instruction decode register means having at least two register regions, a first of said regions designated to temporarily store said operating code portion of an instruction and said at least one other region designated to temporarily store a displacement portion;</claim-text><claim-text>means for supplying an incoming instruction of said basic instruction set or said extended instruction set;</claim-text><claim-text>instruction decode shifter means connected to said instruction supplying means and responsive to said incoming instruction for entering said incoming instruction into said instruction decode register means so that said first designated region temporarily stores the operating code portion thereof and said at least one other designated region, if required, temporarily stores a displacement portion thereof;</claim-text><claim-text>means responsive to the selected bit code combination of each incoming instruction for identifying whether said instruction is from basic instruction set or from said extended instruction set; and</claim-text><claim-text>means for decoding the operating code portion of said identified instruction supplied thereto from said instruction decode register means to produce a plurality of operating code descriptors associated with said decoded instruction and for producing a starting address of one or more microinstructions associated with said decoded instruction.</claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. In a data processing system in accordance with claim 1 wherein said instruction processor means further includes<claim-text>displacement handling means connected to said instruction decode register means and to said decoding means and responsive to a displacement portion of an instruction, if included therein, from said instruction decode register means and to selected ones of said operating code descriptors from said decoding means for providing a displacement word having a predetermied number of bits, the displacement portions of which are arranged in a selected format for use by said data processing system.</claim-text></claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. In a data processing system in accordance with claim 2 wherein said displacement handling means includes sign extend logic means responsive to selected ones of said operating code descriptors and to a displacement portion of an instruction, if included therein, for extending the displacement portion by sign extended data, if necessary, to produce said displacement word.</claim-text></claim>"}, {"num": 4, "parent": 2, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. In a data processing system in accordance with claim 2 wherein said displacement handling means includes zero extend logic means responsive to selected ones of said operating code descriptors and to a displacement portion of an instruction, if included therein, for extending the displacement portion by a selected number of zero bits, if necessary, to produce said displacement word.</claim-text></claim>"}, {"num": 5, "parent": 2, "type": "dependent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. In a data processing system in accordance with claim 2 wherein said displacement handling means further includes means responsive to said displacement word for supplying said displacement word to said system for use in an arithmetic or logical operation.</claim-text></claim>"}, {"num": 6, "parent": 2, "type": "dependent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. In a data processing system in accordance with claim 2 wherein said displacement handling means further includes means responsive to said displacement word for supplying a logical address word to provide a memory reference address to said system.</claim-text></claim>"}, {"num": 7, "parent": 2, "type": "dependent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. In a data processing system in accordance with claim 2 wherein said instruction processor means decodes said incoming instruction to provide said starting address and said displacement word, if required, while the one or more microinstructions associated with the starting address of the preceding decoded instruction are being executed.</claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. In a data processing system in accordance with claim 1 said instruction processor means further including<claim-text>instruction cache storage means for storing a plurality of instructions only;</claim-text><claim-text>means for identifying whether a requested instruction is stored in said instruction cache storage means;</claim-text><claim-text>said instruction cache storage means being responsive to the address of said requested instruction stored therein when said identifying means indicates that said requested instruction is stored in said instruction cache storage means for supplying said requested instruction to said instruction decode shifter means.</claim-text></claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. In a data processing system in accordance with claim 8 wherein said data processing system includes a main memory means, said instruction processor means further including<claim-text>means for accessing said requested instruction from said main memory storage means when said identifying means indicates that said requested instruction is not stored in said instruction cache storage means.</claim-text></claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. In a data processing system in accordance with claim 9, said instruction processor means further including means for providing a direct transmission path to said instruction decode shifter means for a requested instruction which has been accessed from said main memory storage means.</claim-text></claim>"}, {"num": 11, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. In a data processing system in accordance with claim 1 wherein said instruction decoding means is an array of programmable read-only-memories connected to said instruction decode register means and responsive to the operating code portions of an instruction supplied from said first region thereof for decoding said operating code portion to produce the starting microaddress of one or more microinstructions associated with said decoded instruction.</claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim num=\"12\"><claim-text>12. A data processing system in accordance with claim 11 wherein said array of programmable read-only-memories includes first programmable read-only-memory means for decoding instructions of said basic instruction set and second programmable read-only-memory means for decoding instructions of said extended instruction set.</claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim num=\"13\"><claim-text>13. A data processing system in accordance with claim 12 said instruction processor means further including<claim-text>means responsive to said selected bit code combination for enabling a selected one of said first or second programmable read-only-memory means to decode said instruction depending on whether the instruction to be decoded is from said basic instruction set or from said extended instruction set.</claim-text></claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"14\"><claim-text>14. A data processing system in accordance with claim 13 wherein<claim-text>said selected bit code combination comprises a 1 in bit .0. and 1001 in bits 12-15 of said instruction for identifying a first group of instructions from said extended instruction set.</claim-text></claim-text></claim>"}, {"num": 15, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"15\"><claim-text>15. A data processing system in accordance with claim 13 wherein<claim-text>said selected bit code combination comprises a 1 in bit .0. and 011000 in bits 10-15 of said instruction for identifying a first group of instructions from said extended instruction set.</claim-text></claim-text></claim>"}, {"num": 16, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"16\"><claim-text>16. A data processing system in accordance with claim 13 wherein<claim-text>said selected bit code combination comprises a 1 in bit .0., a 0 in bit 5 and 111000 in bits 10-15 of said instruction for identifying a third group of instructions from said extended instruction set.</claim-text></claim-text></claim>"}, {"num": 17, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"17\"><claim-text>17. A data processing system in accordance with claim 13 wherein<claim-text>said selected bit code combination comprises a 0 in bit .0. and 1000 in bits 12-15 of said instruction for identifying instructions from said basic instruction set.</claim-text></claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES317378400\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>TABLE OF CONTENTS</h4><p>Introduction</p><p>Related Applications</p><p>Background of the Invention</p><p>Brief Summary of the Invention</p><p>Description of the Invention</p><p>General Description</p><p>Fixed Point Registers</p><p>Floating Point Registers</p><p>Stack Management Registers</p><p>Memory Management Registers</p><p>Overall Systems</p><p>Memory System</p><p>System Cache Unit</p><p>Bank Controller</p><p>Main Memory Modules</p><p>Address Translation Unit</p><p>Protection Check System</p><p>Instruction Processor</p><p>Instruction Cache</p><p>Decode/Displacement Logic</p><p>Micro-Sequencer</p><p>Arithmetic Logic Unit</p><p>Micro-Instruction Format</p><p>Unique Macro-Instructions</p><h4>INTRODUCTION</h4><p>This invention relates generally to data processing systems and, more particularly, to such systems which can handle 32 bit logical addresses at a size and cost which is not significantly greater than that of systems which presently handle only 16 bit logical addresses.</p><h4>RELATED APPLICATIONS</h4><p>This application is one of the following groups of applications, all of which include the same text and drawings which describe an overall data processing system and each of which includes claims directed to a selected aspect of the overall data processing system, as indicated generally by the titles thereof as set forth below. All of such applications are being filed concurrently and, hence, all have the same filing date of Apr. 25, 1980.</p><p>(1) Data Processing System, Ser. No. 143,561, filed by E. Rasala, S. Wallach, C. Alsing, K. Holberger, C. Holland, T. West, J. Guyer, R. Coyle, M. Ziegler and M. Druke;</p><p>(2) Data Processing System Having A Unique Address Translation Unit, Ser. No. 143,681, filed by S. Wallach, K. Holberger, S. Staudener and C. Henry;</p><p>(3) Data Processing System Utilizing A Hierarchical Memory Storage System, Ser. No. 143,981, filed by S. Wallach, K. Holberger, D. Keating and S. Staudener;</p><p>(4) Data Processing System Having a Unique Memory System, Ser. No. 143,974, filed by M. Ziegler and M. Druke;</p><p>(5) Data Processing System Having A Unique Instruction Processor System, Ser. No. 143,651, filed by K. Holberger, J. Veres, M. Ziegler and C. Henry;</p><p>(6) Data Processing System Having A Unique Microsequencing System, Ser. No. 143,710, filed by C. Holland, K. Holberger, D. Epstein, P. Reilly and J. Rosen;</p><p>(7) Data Processing System Having Unique Instruction Responsive Means, Ser. No. 143,982, filed by C. Holland, S. Wallach and C. Alsing.</p><h4>BACKGROUND OF THE INVENTION</h4><p>Presently available data processing systems which are often referred to as belonging to the \"mini-computer\" class normally handle logical addresses and data words which are 16 bits in length. As used herein, the term \"logical\" address, sometimes referred to by those in the art as a \"virtual\" address, is used to denote an address that is programmer visible, an address which the programmer can manipulate. In contrast, a \"physical\" address is the address of a datum location in the main memory of a data processing system. Operating data processing systems utilize appropriate translation tables for converting logical addresses to physical addresses.</p><p>Such mini-computers have been successfully used in many applications and provide a high degree of data processing capability at reasonable cost. Examples of such systems which have found favor in the marketplace are those known as the \"Nova\" and the \"Eclipse\" systems designed and developed by Data General Corporation of Westboro, Massachusetts. The Nova and Eclipse family of mini-computers are described in the publications available from Data General Corporation which are listed in Appendix A incorporated as part of this specification.</p><p>The Nova system provides a logical address space of 64 kilobytes (the prefix \"kilo\" more accurately represents 1024, or 2<sup>10</sup>) and the Eclipse system also provides a logical address space of 64 kilobytes, both being proven systems for handling many applications at reasonable cost. It is desirable in the development of improved systems to provide for an orderly growth to an even larger logical address space than presently available in Nova and Eclipse systems. Such an extended logical address base permits a larger set of instructions to be utilized by the system, the enlarged instruction set being capable of including substantially all of the basic instructions now presently available in the prior Nova and Eclipse systems as well as a large number of additional, or extended, instructions which take advantage of the increased or expanded logical address space.</p><p>Accordingly, such an improved system should be designed to be responsive to software which has been previously designed for use in Nova and Eclipse systems so that those presently having a library of Nova and Eclipse software, representing a substantial investment, can still use such software in the improved, expanded address system. The improved system also would provide for a greater flexibility in performance at a reasonable cost to as to permit more on-line users at a larger number of on-line terminals to utilize the system. The expanded address space would further permit the system to support more extensive and sophisticated programs devised specifically therefor, as well as to support all of the previous programs supported by the unextended Nova or Eclipse systems.</p><h4>BRIEF SUMMARY OF THE INVENTION</h4><p>The system of the invention utilizes a unique combination of central processor and memory units, the processor comprising an address translation unit, an instruction processor unit, an arithmetic logic unit and a microsequencing unit, while the memory unit includes a system cache unit, a main memory unit and a bank controller unit for controlling data transfers therebetween. The system handles thirty-two bit logical addresses which can be derived from either sixteen bit or thirty-two bit addresses. Unique means are provided for translating the thirty-two bit logical addresses. The system uses hierarchical memory storage, wherein information is stored in different segment storage regions (rings), access to the rings being controlled in a privileged manner so that access to different rings are governed by different levels of privilege.</p><p>The memory system uses a main memory comprising a plurality of memory modules each having a plurality of memory planes. The main memory normally interfaces with the remainder of the system via a dual port system cache memory unit, block data transfers between the main memory and the system cache are controlled by a bank controller unit.</p><p>The invention of this particular application involves an instruction processor in which macro-instructions are decoded using a unique programmable read-only-memory means which is capable of decoding instructions of two types, i.e., instructions from a first basic instruction set or instructions from a second extended instruction set, the instruction which is being decoded containing in itself selected bit patterns which uniquely identify which type of instruction is to be decoded. The instruction processor includes means for decoding the operating code portion of an identified instruction for producing operating code designators associated with the decoded instruction and for producing a starting address of one or more microinstructions associated with the decoded instruction.</p><p>The decoded instructions provide the starting address of one or more incroinstructions, which starting address is supplied to a unique microinstruction sequencing unit which appropriately decodes a selected field of each microinstruction for determining the address of the next successive microinstruction, such address being suitably selected from a plurality of microaddress sources.</p><p>The overall system includes means responding to certain macro-instructions which perform unique operations indigenous to the overall system.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>DESCRIPTION OF THE INVENTION</h4><p>The invention can be described in more detail with the help of the drawings wherein:</p><p>FIG. 1 shows a block diagram of the overall data processing system of the invention as described therein;</p><p>FIG. 2 shows a block diagram of the system cache unit of the system of FIG. 1;</p><p>FIG. 3 shows a block diagram of the bank controller unit of the system of FIG. 1;</p><p>FIG. 4 shows a block diagram of a module of the main memory unit of the system of FIG. 1;</p><p>FIGS. 5-5G show more specific logic for the system cache data store of FIG. 2;</p><p>FIGS. 6-6E show more specific logic for the tag store of FIG. 2;</p><p>FIGS. 7 and 7A show more specific logic for the ICACHE tag store copy unit of FIG. 2;</p><p>FIG. 8 shows more specific logic for the tag store comparator of FIG. 2;</p><p>FIG. 9 shows more specific logic for the ICACHE tag store comparator of FIG. 2;</p><p>FIGS. 10-10B show more specific logic for the CPORT and IPORT address registers and write back tag unit of FIG. 2;</p><p>FIG. 11 shows more specific logic for the index SV and index SV2 units of FIG. 2;</p><p>FIG. 12 shows more specific logic for the WPSV unit of FIG. 2;</p><p>FIGS. 13 and 13A show more specific logic for the index mux and WP mux of FIG. 2;</p><p>FIG. 14 shows more specific logic for the data write register of FIG. 2;</p><p>FIGS. 15-15B show more specific logic for the multiplexer and index driver units of FIG. 2;</p><p>FIGS. 16-16D show more specific logic for the write data register of FIG. 2;</p><p>FIGS. 17 and 17A show more specific logic for the multiplexer unit of FIG. 2;</p><p>FIGS. 18-18G show more specific logic for the driver units and driver logic of FIG. 2;</p><p>FIG. 19 shows more specific logic for the index/index SV comparator of FIG. 2;</p><p>FIGS. 20-20C show more specific logic for the CPU buffer data regiser, I/O buffer data register and CRD IN register of FIG. 2;</p><p>FIGS. 21, 22, 23, 24 and 24A show more specific logic for the system cache parity logic;</p><p>FIG. 26 shows more specific logic for the main memory interface control logic;</p><p>FIGS. 27, 27A, 28-28B show more specific logic for the CBUS interface;</p><p>FIGS. 29, 29A, 30, 30A, 31, 31A, 32, 32A, 33, 34, 34A, 35, 35A, 36, 37, 38, 38A, 39, 40, 41, 41A, 42, 43-43B show various aspects of the system cache control logic for the system cache of FIG. 2;</p><p>FIGS. 44-44B show more specific logic for the mux store unit of FIG. 3;</p><p>FIGS. 45-45C show more specific logic for the C-bit generator of FIG. 3;</p><p>FIGS. 46-46A show more specific logic for the (32-bit) and (8-bit) registers of FIG. 3;</p><p>FIGS. 47 and 47A show more specific logic for the write data bus driver of FIG. 3;</p><p>FIGS. 48-48C show more specific logic for the S-bit generator of FIG. 3;</p><p>FIG. 49 shows more specific logic for the RDSV register of FIG. 3;</p><p>FIG. 50 shows more specific logic for the S-bit SV register of FIG. 3;</p><p>FIGS. 51, 51A, 52-52B show more specific logic for the parity and correction logic of FIG. 3;</p><p>FIGS. 53-53A show more specific logic for direct read driver units of FIG. 3;</p><p>FIGS. 54, 54A show more specific logic for the R/W Mod SEL and RADDR and CADDR units of FIG. 3;</p><p>FIG. 55 shows more specific logic for the mod sel logic of FIG. 3;</p><p>FIGS. 56-56A show more specific logic for the address unit of FIG. 3;</p><p>FIGS. 57-57B show more specific logic for the bank controller and timing logic of FIG. 3;</p><p>FIGS. 58-58F show more specific logic for the bank controller timing, refresh and control logic for the bank controller of FIG. 3;</p><p>FIGS. 59-59A show more specific logic for the parity logic of FIG. 3;</p><p>FIG. 60 shows more specific logic for the control signal drivers of the bank controller of FIG. 3;</p><p>FIGS. 61-61B, 62, 63 and 63A show C Bus interface logic for the bank controller of FIG. 3;</p><p>FIGS. 64-64B, 65-65B show more specific logic for the data-in registers of FIG. 4;</p><p>FIGS. 66-66G and 67-67A show the plane .0. rams and control of FIG. 4;</p><p>FIGS. 68-68G and 69-69A show the plane 1 rams and control of FIG. 4;</p><p>FIGS. 70-70G and 71-71A show the plane 2 rams and control of FIG. 4;</p><p>FIGS. 72-72G and 73-73A show the plane 3 rams and control of FIG. 4;</p><p>FIGS. 74-74D show more specific logic for the data-out register and mux unit of FIG. 4;</p><p>FIG. 75 shows more specific logic for the memory array latches and drivers of FIG. 4;</p><p>FIG. 76 shows more specific logic for the Ram Sel logic of FIG. 4;</p><p>FIG. 77-77C show more specific logic for the Modsel comparator and memory module control logic of FIG. 4;</p><p>FIG. 78 shows more specific logic for the memory module timing logic of FIG.4;</p><p>FIGS. 79-81 show block diagrams which represent the address translation unit of the system of FIG. 1;</p><p>FIGS. 82-82G show more specific logic for various registers and a mux of FIG. 79;</p><p>FIGS. 83 and 83A show more specific logic for the tag store and protection store of FIG. 79;</p><p>FIG. 84 shows more specific logic for the tag comparator unit of FIG. 79;</p><p>FIGS. 85 and 85A show more specific logic for the logical address register of FIG. 79;</p><p>FIGS. 86 and 86A show more specific logic for the physical address offset mux of FIG. 79;</p><p>FIG. 87 shows more specific logic for the LAR CPD driver unit of FIG. 79;</p><p>FIGS. 88 and 88A show the physical address drivers of FIG. 79;</p><p>FIG. 89 shows the input priority encoder for use in the ATU of FIG. 79;</p><p>FIG. 90 shows the fault cache drivers of FIG. 79;</p><p>FIGS. 91-91B shows more specific logic for the ring protection logic of FIG. 80;</p><p>FIGS. 92-92D show more specific logic for fault detection and cache block crossing trap logic of FIG. 79;</p><p>FIGS. 93-93G show more specific logic for the fault detection trap logic of FIG. 79;</p><p>FIGS. 94 and 94A show more specific logic for the validity store and purge logic of FIG. 79;</p><p>FIG. 95 shows more specific logic for the translation register of FIG. 79;</p><p>FIGS. 96-96D show more specific logic for the reference/modify storage and control logic of FIG. 79;</p><p>FIG. 97 shows more specific logic for state save drivers of FIG. 79;</p><p>FIGS. 98-98G show more specific logic for the 16-bit M M P U emulation control logic of FIG. 79;</p><p>FIGS. 99-99A show more specific logic for ATU timing logic for use with the ATU of FIG. 79;</p><p>FIGS. 100-100C show more specific logic for permitting the ATU to interface with the system cache unit of the system;</p><p>FIGS. 101-106 show block diagrams which represent the instruction processor unit of the system of FIG. 1;</p><p>FIGS. 107-107C show more specific logic for the ICACHE data store of FIG. 102;</p><p>FIG. 108 shows more specific logic for the ICACHE data store address unit of FIG. 106;</p><p>FIGS. 109-109C show more specific logic for the CPM register of FIG. 102;</p><p>FIG. 110 shows more specific logic for the ICACHE validity store of FIG. 102;</p><p>FIG. 111 shows more specific logic for the validity store address input of FIG. 102;</p><p>FIG. 112 shows more specific logic for the comparator and Set IDR valid units of FIG. 102;</p><p>FIGS. 113-113C show more specific logic for the IDR shifter unit of FIG. 103;</p><p>FIGS. 114-114B show more specific logic for the IDR unit of FIG. 103;</p><p>FIG. 115 shows more specific logic for the IDR unit of FIG. 103;</p><p>FIGS. 116 and 116A show more specific logic for the ICACHE pointer logic of FIG. 106;</p><p>FIG. 117 shows more specific logic for the ICP LA drivers of FIG. 106;</p><p>FIG. 118 shows more specific logic for the request control logic of FIG. 106;</p><p>FIG. 119 shows more specific logic for the physical translation register of FIG. 106;</p><p>FIGS 120-120A show control logic for use with the ICACHE of FIG. 102;</p><p>FIG. 121 shows the CPD drivers of FIG. 103;</p><p>FIG. 122-122D show more specific logic for the instruction pre-decode logic of FIG. 103;</p><p>FIGS. 123-123E show more specific logic for the decode PROM'S of FIG. 103;</p><p>FIGS. 124-124E show more specific logic for the ST\u03bcAD load control logic of FIG. 103;</p><p>FIGS. 125-125A show more specific logic for the displacenent mux at the input to the displacement logic of FIG. 104;</p><p>FIGS. 126-126C show more specific logic for the displacement mux at the input to the displacement logic of FIG. 104;</p><p>FIG. 127 shows more specific logic for the SEX logic of FIG. 104;</p><p>FIG. 128 shows more specific logic for the zero/ones extend logic of FIG. 104;</p><p>FIGS. 129-129A show more specific logic for the displacement/increment buffer of FIG. 104;</p><p>FIGS. 130-130A show more specific logic for the displacement latch and drivers of FIG. 104;</p><p>FIGS. 131-131B show more specific logic for the PC register and CPD bus drivers of FIG. 104;</p><p>FIGS. 132-132C show more specific logic for the adder of FIG. 104;</p><p>FIGS. 133-133A show more specific logic for the PC and displacement latches and drivers of FIG. 104;</p><p>FIG. 134 shows more specific logic for the PC clock of FIG. 104;</p><p>FIGS. 135-135C show timing and control logic for use with the instruction processor of FIGS. 101-106;</p><p>FIGS. 136-136D show interface logic which permits the instruction processor to interface with the system cache unit of the system;</p><p>FIGS. 137 and 138 show block diagrams of the microsequencer unit of the system of FIG. 1;</p><p>FIGS. 139-139D show more specific logic for the stack mux, stack ram, stack pointer and TOS unit of FIG. 137;</p><p>FIG. 140 shows more specific logic for the STOS unit of FIG. 137;</p><p>FIGS. 141-141B show more specific logic for the address mux of FIG. 137;</p><p>FIG. 142 shows more specific logic for the address save register of FIG. 137;</p><p>FIGS. 143 and 143A show more specific logic for the address input to the microcontrol store unit of FIG. 137;</p><p>FIG. 144 shows more specific logic for the starting microaddress driver of FIG. 137;</p><p>FIG. 145 shows more specific logic for the (\u03bcPC+1) and increment unit of FIG. 137;</p><p>FIGS. 146-146F, 146.1-146.1F, 146.2-146.2F, 146.3-146.3F, 146.4-146.4E, 146.5-146.5E, 146.6-146.6F and 146.7-146.7F show more specific logic for the microcontrol store of FIG. 137;</p><p>FIGS. 147-147D show more specific logic for the NAC decode logic of FIG. 137;</p><p>FIGS. 148-148A show more specific logic for the parity logic of FIG. 137;</p><p>FIGS. 149-149B show more specific logic for the concatenation logic and the dispatch mux of FIG. 138;</p><p>FIGS. 150-150A show more specific logic for the dispatch mux of FIG. 138;</p><p>FIG. 151 shows more specific logic for the 6-Bit counter of FIG. 138;</p><p>FIGS. 152-152A show more specific logic for the 8 Flags unit of FIG. 138;</p><p>FIGS. 153-153A show more specific logic for the test 0 and test 1 muxes and the condition mux of FIG. 138;</p><p>FIG. 154 shows a block diagram of a representative arithmetic logic unit of the system of FIG. 1;</p><p>FIG. 155 shows a diagrammatic representation of certain memory locations used to explain the operation of a particular macro-instruction used in the system of FIG. 1; and</p><p>FIG. 156 shows a diagrammatic representation of certain operations performed in the macro-instruction discussed with reference to FIG. 155.</p><p>FIG. 157 depicts a diagram showing a one-level page table transversal in a long address translation; and</p><p>FIG. 158 shows a diagram of a two-level page table transversal in a long address translation.</p><p>In connection with the above figures, where a particular figure requires more than one sheet of drawings, each subsequent sheet is designated by the same figure number with sequential letters appended thereto (e.g., FIG. 5 (for sheet 1); FIG. 5A (for sheet 2); FIG. 5B (for sheet 3) . . . etc.). With respect to FIG. 146 in particular, which depicts the microcontrol store 170, fifty-six sheets of drawing are used. The sheets are numbered 146, 146A, 146B, 146C, 146D, 146E, 146F; 146.1, 146.1A, 146.1B, 146.1C, 146.1D. 146.1E, 146.1F; 146.2, 146.2A, 146.2B . . . etc. to 146.8, 146.8A, 146.8B . . . 146.8F.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>General Description</h4><p>Before describing a specific implementation of the system of the invention, it is helpful to discuss the overall concept thereof in more general terms so that the characteristics that are desired can be described and the description of a particular implementation can be better understood.</p><p>A significant aspect of the system of the invention, as discussed above, is the size of the logical address space which is available. For purposes of convenience in distinguishing between the previous NOVA and Eclipse systems, the extended system as discussed herein will sometimes be referred to as the \"Eagle\" system. In the Eagle system, for example, the logical address space can be as high as 4 gigabytes (more accurately the prefix \"giga\" is 1,073,741,824, or 2<sup>30</sup>, so that 4 gigabytes is, more accurately, 4,294,967,296) where a byte is defined as having 8 bits of precision. As used hereinafter, a \"word\" is defined as having 16 bits of precision (i.e., equivalent to 2 bytes) and a \"double-word\" as having 32 bits of precision (equal to two words, or four bytes). Because of the increased logical address space the overall system is able to support an instruction set which is larger than that supported by a Nova system or an Eclipse system having, for example, a much smaller logical address space. The overall capability of the system can be best understood by those in the art by examination of the set of the extended instructions which are capable of being performed by the system. Such an instruction set in accordance with the invention is set forth in Appendix B incorporated as a part of this specification. Such instruction set includes the extended instruction set (which can be referred to as the Eagle instruction set) and the Eclipse C-350 instruction set, as well as the Nova instruction set, all of which are capable of being handled by the system, the latter two instruction sets being already disclosed as part of the above publications. All Nova and Eclipse instructions are executed according to the principles and specifications presented in the above-referenced publications.</p><p>The binary encodings of the extended instructions which are supported by the system of the invention are shown in Appendix B. A significant difference exists between the systems having extended instructions in accordance with the invention and systems having extended instructions which have been suggested by others. In any system in which an extended instruction set effectively represents a \"super\" set of a previous, or original, set of instructions, all of the instructions must be suitably decoded for machine operations. Normally, such systems utilize a decoding sub-system for decoding both the original instruction set and for decoding the extended instruction set. The decoder operates so as to permit the decoding of only one of the instruction sets at a time, the original instruction set and the extended instruction set being in effect, mutually exclusive. In order to determine which instruction is to be decoded, a unique instruction must be used to set a \"mode bit\", i.e., a single bit which in one state indicates that the original instruction set is to be decoded and in the other state indicates that the extended instruction set is to be decoded. However, in neither case can the decoding subsystem be made available to decode either of the both sets simultaneously. Such approach inserts a limitation on the overall machine operation since it is never possible to simultaneously decode instructions from different instruction sets of an overall super set thereof.</p><p>The system of the invention, however, avoids such mutual exclusivity and is arranged to be capable of decoding instructions from either set or both sets at any one time. A decoder PROM (programmable read-only-memory) system is utilized for decoding both the extended Eagle instruction set and the original or basic instruction sets as, for example, the original Nova and Eclipse instruction set. Each instruction to be decoded includes the information which determines which decoder is to be utilized, such determination thereby being inherently carried in each instruction word which is to be decoded. As seen in Appendix B, for example, the information is contained in bits .0. and 12-15. Thus, in the extended Eagle instruction set, bit .0. is always a \"1\" while bits 12-15 are always \"1001\" for all instructions of the extended instructions set except for those extended instructions which use a \"1\" in bit .0. and the encoding \"011000\" in bits 10-15 and a \"1\" in bit \"0\", a \"0\" in bit 5, and the encoding \"111000\" in bits 10-15. On the other hand, the original Eclipse instructions are such that bit .0. is 0 and bits 12-15 are \"1000\". Further, in cases where the instruction does not carry either the Eagle coded bits or the Eclipse coded bits, such instruction is interpreted as a NOVA instruction.</p><p>Because each instruction carries with it an identification as to which instruction set the instruction belongs, the system operates to decode instructions on a non-mutually exclusive basis.</p><p>In order to support the extended operations of the system, the configuration thereof requires an augmentation of the registers which were previously available in the original system of which the new system is an extension. The following registers are utilized in the system and are discussed in more detail later with respect to the particular implementation described in connection with specific figures below.</p><p>The register set includes fixed point registers, floating point registers, stack management registers and memory management registers.</p><p>Fixed Point Registers</p><p>The system includes four fixed point accumulators (ACC .0.-3), one program counter (PC) and one processor status register (PSR). Each of the accumulators has 32 bit precision which can accommodate (1) a 16 bit operand which can be sign extended to 32 bits; (2) a 15 bit address which can be zero extended to 28 bits, the higher order 3 bits of the program counter being appended thereto together with a zero bit, all of which can be appended for storage in the accumulator; or (3) an 8 bit byte which can be zero extended to 32 bits before storage in the accumulator.</p><p>The program counter has 31 bits of precision, bits 1-3 identifying one of 8 current memory rings (discussed in more detail below) and bits 4-31 of which accomodate an address offset for instruction addresses. For Eclipse operation, for example, which normally requires only a 15 bit program counter, the bits 1-3 identify the current memory ring as in a 31 bit extended operation while the 15 least significant bits 17-31 represent the 15 bit Eclipse program counter and bits 4-16 are all zeros.</p><p>The processor status register is a 16 bit register which provides an overflow mask bit which if set will result in a fixed point overflow. Additionally the register includes a fixed point overflow indicator bit and a bit which indicates that a micro interrupt has occurred. Other bits in the register are reserved and are thus available for potential future use.</p><p>Floating Point Registers</p><p>The system includes four floating point accumulators (FPAC .0.-3) and one floating point status register (FPSR). Each of the floating point accumulators contains 64 bits of precision which is sufficient to wholly contain a double precision floating point value. The floating point registers of the extended system are identical to the Eclipse floating point accumulators (FPAC) which are discussed in the aforementioned publications.</p><p>The floating point status register also has 64 bits of precision, 32 bits of which act as the floating point program counter. In the event of a floating point fault the floating point program counter bits define the address of the floating point instruction that caused the fault. Four other bits are utilized, respectively, to indicate an exponent overflow condition, an exponent underflow condition, a divide-by-zero condition and a mantissa overflow condition. Another counter bit will result in a floating point fault if any of the above latter four bits are also set. The floating point counter also includes a zero bit and negative bit, as are generally used in status registers, as well as bits for indicating a floating point rounding mode of operation and an interrupt resume operations.</p><p>Stack Management Registers</p><p>The system of the invention utilizes four 32 bit registers to manage the memory stack, which registers include a stack pointer, a stack limit, a stack base, and a frame pointer. The stack pointer register references the double word entry at the top of the stack. When a \"push\" operation occurs, all the bits of the stack pointer are incremented by 2 and the \"pushed\" object is placed in the double word addressed by the new value of the stack pointer. In a \"pop\" operation the double word addressed by the current value of the stack pointer is placed in a designated register and all 32 bits of the stack pointer are then decremented by 2.</p><p>The frame pointer register references the first available double word minus two in the current frame. The stack limit contains an address that is used to determine stack overflow. After any stack operation pushes objects onto the stack, the stack pointer is compared to the stack limit. If the stack pointer is greater than the stack limit a stack fault is signaled. The stack base contains an address that is used to determine the stack underflow. After any stack operation that pops objects from the stack, the stack pointer is compared to the stack base. If the stack pointer is less than the stack base a stack fault is signaled.</p><p>Memory Management Registers</p><p>Eight registers are used to manage memory, such registers each being designated as a segment base register (SBR) having 32 bits of precision, the memory being divided into eight segments, or rings, thereof. The SBR's in the system described herein are formed as part of scratch pad registers on an address translation unit (ATU) of the system, as discussed in more detail below. One bit of such SBR indicates whether or not the segment associated therewith can be referenced (i.e. is there a valid or an invalid reference to such segment). Another bit indicates the maximum length of the segment offset field i.e. whether or not the reference is a one level page table or a two level page table, as explained in more detail below. A third bit of each segment base register indicates whether a Nova/Eclipse instruction for loading an effective address of a Nova/Eclipse I/O instruction is being executed. Another bit represents a \"protection\" bit which indicates whether or not an I/O instruction can be executed or whether the execution thereof would be a violation of the protection granted to such segment. Nineteen of the bits contain a physical address which identifies the physical address in the memory of the indicated page table. Discussions of the addressing of page tables in the memory are presented in more detail below including a discussion of the memory locations in each segment.</p><p>Overall System</p><p>A block diagram of a preferred embodiment of the invention is shown in FIG. 1. The central processor portion of the system comprises an arithmetic logic unit (ALU) 11, an instruction processor unit 12, a micro-sequencer unit 13 and an address translation unit (ATU) 14. The memory system includes a main memory unit 16, an auxiliary cache memory unit 17 and a memory control unit identified as bank controller unit 18. A central processor address bus 19 permits the transfer of addresses among the instruction processor unit 12, the address translation unit 14 and the memory system. A control processor, memory (CPM) bus 20 permits the transfer of instructions and operands among arithmetic logic unit 11, instruction processor unit 12, address translation unit 14 and the memory system 15.</p><p>I/O address bus 21 and I/O memory/data bus 22 permit the transfers of addresses and data respectively with respect to I/O devices via I/O channel unit 23, as well as the transfers thereof between the memory system and a console control processor unit 24. Suitable control buses for the transfer of control signals among the various units of the overall system are provided as buses 25-31 described in more detail below. Appropriate teletype and floppy disc systems 33 and 34, respectively, can be utilized with the system, particularly in the diagnostics mode of operation via console control processor unit 24 by way of a suitable micro processor computer 35.</p><p>The inventive aspects of the system to be described herein requires a more detailed discussion of the memory system, the address translation unit, the instruction processor unit and the micro sequencer unit. The arithmetic logic unit, the console control processor unit and the I/O channel unit with their associated controls need not be described in detail.</p><h4>Memory System</h4><p>In accordance with a preferred embodiment of the invention the memory system comprises up to two megabytes of main memory 16 and, if desired, the system can be expanded even further as, for example, to 4 megabytes. It should be noted that sufficient bits are reserved in the physical address fields so as to allow for system expansion to one billion bytes of memory. The interface between the main memory unit 16 and the remainder of the system is via the dual port cache memory unit 17, data being transferred between the main memory and the cache memory unit in blocks of 16 bytes. The cache memory unit herein will usually be referred to as the \"system cache\" (SYS CACHE) to distinguish it from a separate cache memory in the instruction processor unit which latter memory will normally be referred to as the \"instruction cache\" (I CACHE) unit. The system cache unit 17 services CPU requests for data transfers on port 17A of its two ports and services requests from the I/O system at port 17B thereof. CPU data transfers can include \"byte-aligned-byte\" transfers, \"word-aligned-word\" transfers, and double word transfers. I/O data transfers can include \"word-aligned-word\" transfers, \"double word-aligned-double word\" transfers and 16 byte block transfers.</p><p>The main memory unit 16 can include from one to eight 256-kilobyte memory modules, as shown in FIG. 4. Each memory module contains a memory array of 156 16 K dynamic random access memories (RAMs), organized at each module in the form of four planes .0.-3 of 16K 39-bit words each. Each word comprises 32 bits of data and 7 error correction bits, as discussed in more detail below. Memory timing and control for the RAMs of each memory module is accomplished on the memory bank controller board 18. The control signals from the memory bank controller are clocked into a register on each memory module, the outputs thereof driving the \"plane-.0.\" RAMs. The outputs from such reigister are clocked a fixed time later into another register which drives the \"plane-1\" RAMs. Such pipe line operation continues through \"plane-2\" RAMs and \"plane-3\" RAMs so that all four planes receive the same control signals at fixed intervals (e.g. 110 nanosecond intervals), resulting in the transfer of a block of four consecutive 39-bit words.</p><p>Memory bank controller 18 has three main functions. First of all, it provides an interface between the system cache 17 and the memory modules of the main memory unit 16. Secondly, it performs necessary error checking and correction operation and, thirdly, it controls the refresh operation of the dynamic RAMs on each of the memory modules. The details of the interface between the system cache and the bank controller are discussed in more detail below.</p><p>The error checking and correction logic on the bank controller performs single-bit error correction and double-bit error detection using a 7 bit error correction Hamming code as is well known in the art. The 7 check bits generated for each 32 bit data word are stored with such word in the main memory modules. When the word is subsequently read from memory, all 39 bits are decoded to produce a 7 bit pattern of syndrome bits which pattern identifies which, if any, single bit is in error and indicates when more than one bit is in error. When a correctable single-bit occurs, the console control processor 24 is provided with the address and the syndrome bit pattern of the failing bit. The data is thereupon corrected and sent to the system cache after a fixed time delay equal to a system clock period, e.g. 110 nanoseconds in a particular embodiment, in accordance with well-known error correcting operation, the remaining words in the pipe line operation being prevented from transfer until the corrected signal is made available by the use of a suitable inhibit signal identified as the BC ERROR signal.</p><p>Substantially immediate correction of single bit errors is desirable so that such errors do not grow into multiple bit errors. A conventional technique can be used in which the corrected data is written back into memory only when it has been read and found to be in error. Two problems arise with such a technique. First of all, the memory locations which are not often read are not often corrected and, secondly, significant time can be wasted in trying to correct a failure if it occurs in a frequently accessed memory location. The system of the invention can avoid such problems by utilizing a separate process for monitoring all of the main memory locations so that each location therein is checked and corrected, if necessary, once every two seconds. Such checking is performed during the memory refresh cycle and does not reduce the availability of the memory to the system. A detailed description of such a technique is disclosed in U.S. Patent Application, Ser. No. 143,675, filed concurrently by M. Ziegler, M. Druke, W. Baxter and J. VanRoeckle, which application is incorporated by reference herein.</p><p>System Cache Unit</p><p>The system cache unit 17 represents the sole connection between the main memory unit 16 and the remainder of the system and consists of a memory system port 38 for connection to the main memory and two requestor ports, 17A and 17B, as discussed above, one intended primarily for handling CPU requests and one intended primarily for handling I/O requests. The system cache board also provides a direct access path 39 between the I/O port and the memory system port providing for direct block transfers therebetween. Cache board 17 also includes a 16-kilobyte, direct mapped high speed cache data store 40 having a block size of 16 bytes which can be accessed from either the I/O or the CPU requestor port. Block diagrams of the logic utilized in the system cache unit 17, the bank controller unit 18 and a typical memory module of the main memory unit 16 are shown in FIGS. 2,3, and 4.</p><p>As can be seen in FIG. 2, the system cache data store 40 receives all requests for data from the memory other than block transfer requests from the I/O port which are serviced by the main memory directly. In the particular embodiment described, the cache data store receives the data address at the address input of either CPORT 17A or IPORT 17B which address is placed in either CPORT address register 41 or IPORT address register 42. The incoming address includes a Tag portion, an Index portion and a word pointer portion as follows: ##STR1## The three least significant bits 29-31 of the cache data store address specify the word pointer, which identifies the desired word within a block of the 16 byte 8 word block of the data store. The remaining bits 9-28 identify the block address which corresponds exactly to the address which would be used to fetch the desired block from the main memory. The latter bits are divided into Tag bits 9-18 and Index bits 19-28 as shown.</p><p>The system cache as depicted in FIG. 2 includes a \"Tag\" Store Unit 43. Data store 40 is a high speed memory array of 4K\u00d732 bit words (i.e. 1K 16-byte blocks) and holds a copy of a block of words from main memory. The data store is addressed by the index and word pointer bits of the cache data store address word, the index being a 10-bit address of a block within the data store 40 and the three word pointer bits pointing to the desired word within the selected block, as mentioned above. A data store block may be used to buffer any data block of main memory which shares the same index.</p><p>The function of the Tag store 43 is to identify which of the many possible blocks from the main memory is buffered in each 16 byte block of the data store 40. Tag store 43 is a high speed array of 1K 12-bit words and is addressed by the 10-bit index portion of the memory address. Each 12-bit word contains ten bits which identify the block from the main memory which is buffered in data store 40. When the main memory is 4 megabytes or less, the first two bits of this tag are needed only for future expansion of the main memory capacity and can be zero. Bits 10 and 11 are flags to indicate the status of the data. Thus a \"valid\" flag V indicates that the indentifiable data store block contains valid data. For example, if an I/O port operation were to request a block \"write\" to main memory which modifies the contents of a block which has already been buffered in the data store 40, the valid flag of that block would be reset to indicate that its data is no longer valid.</p><p>A \"modify\" flag M indicates that the contents of the data store block have been modified. Thus, if a data block is removed from the data store 40 to make room for a new data block from main memory, the removed data block is written back to main memory if the modified data flag is set.</p><p>A second tag store unit 44 is shown on the system cache board, which latter tag store is a replica of the instruction cache (ICACHE) tag store which is described later. The ICACHE tag store is used on the system cache board to determine when a write to memory would affect the contents of the instruction cache at the instruction processor. When such an effect would occur, as indicated by a comparison at comparator 45 of the incoming address and the ICACHE addresses, the system cache alerts the instruction processor by asserting an \"instruction cache write\" signal, as indicated in FIG. 2, to inform the instruction cache (ICACHE) at the instruction processor board of the location of the block which has been so modified.</p><p>In the operation of the system cache all requests are initially assumed to be \"read\" requests, since even when a \"write\" request occurs it is possible that the data to be written will need to be read and modified (a \"read-modify-write\" operation) before the write operation is to be performed. If the system cache is not busy when a request is received at an input port, the data store 40 and the tag store 43 are accessed simultaneously, using the appropriate portions of the received input address as discussed above. The data from the location in the data store 40 which has been addressed is loaded into the cache write data register 46 via multiplexer 48 if the data transfer is a write into memory operation so that in the next cycle the contents of the write data register 46 can be enabled onto the bus via multiplexer 47 and bus driver unit 49. If the data is a read operation the data output from data store 40 is supplied at the CPORT or IPORT, as required, via multiplexer 48 and driver units 50 and 51, respectively.</p><p>The data from the tag store 43 is first examined to determine if the requested data, is, in fact, in the data store 40. The tag portion of the word which is read from the tag store is compared at comparator 52 with the tag portion of the address which has been submitted by the requestor and the valid flag checked to see that it is set. If such comparison is successful (a system cache \"hit\") the data from data store 40 is the desired data and the requestor is permitted to receive it or to write it into memory. If the comparison fails (a system cache \"miss\") the data block which has been requested is not in the cache data store 40 and must be brought in from the main memory. Such an occurrence is termed a \"cache fault\" condition and, when such fault occurs, the requestor is prevented from loading in data until after the fault is resolved.</p><p>Once the data is available for the requestor the requestor must signal that it wishes to accept the data and, if the requestor does not do so when the data first becomes available, the read operation will be repeated until the requestor indicates its willingness to accept the data.</p><p>Because access to the data in data store 40 requires two system clock cycles to complete, the cache addresses as received from requestors can be \"pipe-lined\" in a manner such that two accesses can be in progress at any one time. Advantage is taken of this ability to pipe-line access requests by intertwining the accessors of one of the input ports with those of the other input ports. An appropriate clocking signal, which has a frequency one-half that of the basic system clock, is used to indicate which requestor port is allowed to access the cache data store at any given time. As a result there is no interference between CPU and I/O port accesses except during a cache fault. The only exception is that both I/O and CPU ports are not allowed to be in the process of accessing the same data store block at the same time. An example of the intertwining operation between the ports for a read operation is discussed below. In the particular example described the CPU port requestor does not choose to take the data at the first opportunity so that a read repeat occurs.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->__________________________________________________________________________\n   t0                                                                     \n          t1                                                              \n                 t2                                                       \n                       t3                                                 \n                             t4                                           \n                                   t5                                     \n__________________________________________________________________________\nCPU  Address and                                                          \n            Tag and                                                       \n                   Data ready.                                            \n                         Data Store                                       \n                               Data Ready.                                \nPORT START  Data Stores                                                   \n                   Requestor                                              \n                         read  Requestor                                  \nREAD Signal on                                                            \n            read.  does not                                               \n                         again.                                           \n                               asserts RT                                 \n     bus.          assert RT   Signal and                                 \n                   Signal.     loads data.                                \nIO   Idle cycle                                                           \n            Address and                                                   \n                   Tag and                                                \n                         Data ready.                                      \n                               Idle cycle                                 \nPORT or end of                                                            \n            START  Data Stores                                            \n                         Requestor                                        \n                               or start of                                \nREAD last   Signal on                                                     \n                   read. asserts RT                                       \n                               next                                       \n     access.                                                              \n            bus.         Signal and                                       \n                               access.                                    \n                         loads data.                                      \n__________________________________________________________________________\n</pre><p>For a cache write operation, the cache, at the time the memory write access is initiated, assumes that a read-modify-write operation will be performed and accordingly does a read as described above. However, even if the transfer is to be a simple write operation, the tag store information must be read to determine the location at which the incoming data will be written so that in actuality no time is lost in performing a superfluous data store read operation. For a simple write operation, or for the write portion of a read-modify-write operation, the requestor asserts a write transfer (WT) signal to indicate completion of the transfer. Instead of driving the data from the output register onto the memory port 38 the system cache loads an input register 53 with the data which is to be written from the data bus at the end of the cycle and writes it into the data store 40 during the next cycle. If a cache fault results from such a write request, the system cache accepts the data to be written into the input register but does not write it into the data store 40 until after the fault is resolved. An example of a CPU port write request in a manner similar to that discussed above for a read request is shown below.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->__________________________________________________________________________\n   t0                                                                     \n          t1                                                              \n                 t2                                                       \n                       t3                                                 \n                             t4                                           \n                                   t5                                     \n__________________________________________________________________________\nCPU  Address and                                                          \n            Tag and                                                       \n                   Data ready.                                            \n                         Data Store                                       \n                               Idle cycle.                                \nPORT START and                                                            \n            Data Stores                                                   \n                   Requestor                                              \n                         written.                                         \nWRITE                                                                     \n     WRITE  read.  asserts WT                                             \n     Signals on    Signal and                                             \n     bus.          sends data.                                            \nIO   Idle cycle                                                           \n            Address and                                                   \n                   Tag and                                                \n                         Data ready.                                      \n                               Idle cycle                                 \nPORT or end of                                                            \n            START  Data Stores                                            \n                         Requestor                                        \n                               or start of                                \nREAD last   Signal on                                                     \n                   read. asserts RT                                       \n                               next                                       \n     access.                                                              \n            bus.         Signal and                                       \n                               access.                                    \n                         loads data.                                      \n__________________________________________________________________________\n</pre><p>The examples discussed above show single read or single write operations. It is also possible for a requestor to submit a new address and a START signal along with the read transfer (RT) and/or write transfer (WT) signal, so that consecutive read operations or consecutive write operations from a single port can be performed every two cache cycles (a CPU cycle, for example, is equivalent to two cache cycles) unless a cache fault occurs. However, if a read access is initiated at the same time that a write transfer is performed, the data store 40 cannot be read on the next cycle because it is being written into at that time. When this condition happens, the read operation requires an additional two cache cycles for completion. If the requestor is aware that a read operation is following a write transfer and wishes to avoid a wasted cycle, the requestor can either delay starting the read request until the next cycle or it may start the read request to wait an extra cycle before requesting the data transfer. In either case useful work could be done in the otherwise wasted cycle, although initiation of a read followed by a wait for an extra cycle is usually more desirable because it allows a cache fault to be detected at an earlier point in time.</p><p>A read-modify-write operation can be accomplished by asserting a START signal and WRITE signal along with the address, followed by a read transfer at a later cycle and a write transfer at a still later cycle. When a WRITE signal is signaled at the start of an access, the system cache will not consider that the access has been completed until a write transfer is performed. During such operation all other requestors are prohibited from accessing the same data. Thus, requestors utilizing the same input port are prevented from access by the fact that the first requestor controls the bus during the entire read-modify-write operation. Requestors on the other port are prevented from access by the fact that both ports are prohibited from accessing the same data store block at the same time. Such prohibition also prevents requestors at another port from removing a block of data from the cache data store when the system cache is in the middle of an operation.</p><p>If the system cache board receives a write transfer request when a write operation has not been previously indicated or, if it receives a read transfer and a write transfer request simultaneously, access to the system cache data store is aborted without the transfer of any data. If such simultaneous read and write transfer requests are asserted at the beginning of the next cycle after the START request, the access may be avoided without even initiating an unnecessary cache fault indication.</p><p>In addition to the above transfers, the system cache board has the capability of performing direct write transfers between the input ports and the main memory, the bulk of such data traffic being capable of being handled without affecting the contents of the cache data store 40. If the requested transfer is a block write transfer, the data is written directly into the main memory via data write register 40A, MUX 48 and write data register 46. Data transfers at the I/O port are not allowed when the CPU port is in the process of accessing data which has the same Index as the I/O block which is to be transferred. Data read-modify-write transfers are also not permitted by the system.</p><p>In the overall system cache block diagram shown in FIG. 2, the input registers for the CPU request port and the I/O request port are shown as data registers 54 and 55. Addresses associated with the data at such registers are supplied to the CPU address register 41 and the I/O address register 42, each address comprising the Index, Tag and Word Pointer as discussed above.</p><p>Specific logic diagrams of the system cache board 17 depicted in FIG. 2 are shown in FIGS. 5-44, which latter figures are appropriately labeled as follows to show more specifically a particular embodiment of the various portions of the system cache 17 depicted therein.</p><p>FIG. 5 shows the cache data store 40; FIG. 6 the Tag store 43; FIG. 7 the ICACHE tag store copy unit 44; FIG. 8 the tag store comparator 52; FIG. 9 the ICACHE tag store comparator 45; FIG. 10 the CPORT and IPORT registers 41 and 42 and the write back tag unit; FIGS. 11 and 12 the INDEX SV WP SV unit of FIG. 2; FIG. 13 the INDEX and WP multiplexer units; FIG. 14 data write register 40A; FIG. 15 the multiplexer unit 48 and the index driver unit 48' which supplies an input to multiplexer 48; FIG. 16 the write data register 46; FIG. 17 the multiplexer unit 47; FIG. 18 the driver units 50 and 51 and driver logic associated therewith; FIG. 19 the INDEX/INDEX SV comparator unit; FIG. 20 the CPU buffer data register 54, the I/O buffer data register 55, and the CRD IN register 53. The specific system cache parity logic is shown in FIGS. 21-25. The main memory and other interface control logic is shown in FIGS. 26-28. As in any data processing system board, adequate control signals for the various units thereon must be provided and control logic for the particular embodiments of the system cache board depicted in FIGS. 5-27 are shown in FIGS. 29-43.</p><p>Bank Controller</p><p>FIG. 3 depicts an overall block diagram of the bank controller 18 which interfaces between the system cache at the left hand side of the drawing and the memory modules at the right hand side thereof. Words which are read from the memory modules, identified as RD .0.-38, including 7 parity bits, are supplied to the bank controller for transfer to the system cache, such words being identified as CRD .0.-31 in FIG. 3, via the error correction logic 70 which also supplies four parity bits, identified as CRD PAR .0.-3. Address and data words which are to be written into the main memory modules are supplied from the system cache such words being identified as CA/WD .0.-31, together with the parity bits therefor, identified as CA/WD PAR .0.-3, the data being supplied to the write data bus for the memory modules as WD .0.-31 and parity bits WD 32-38 via error correction logic 70. The addresses therefor are supplied in the form of information which is required to select the desired memory module (MODSEL .0.-3) (to identify up to 16 modules) and to select the desired RAM within the selected module (ADDR.0.-7)</p><p>Further, the bank controller supplies the following control signals to the main memory which responds thereto as required. The RAS and CAS signals represent the row address and column address strobe signals for the RAM's of the main memory. The LDOUT signal causes the selected module to load its output register at the end of the current cycle and to enable the register to place the contents of the output register on the read data bus during the next cycle. The LDIN signal causes the selected module to accept data from the write bus during the next cycle and to write such data into the RAMs during the following cycle. The REFRESH signal overrides the module selection for the row address strobe (RAS) signal only. During a refresh operation one module is read normally and all others perform an RAS refresh only.</p><p>The bank controller also interfaces the system cache to supply 32-bit words (CRD .0.-31) to the cache along with 4 parity bits (CRD PAR .0.-3) for byte parity and to receive 32 bit address and data words (CA/WD .0.-31) from the cache along with byte parity bits (CA/WD PAR .0.-3). The bank controller also supplies the following control signals to the cache. The BC BUSY signal indicates that the bank controller is not able to accept a BC START (see below) request. The BC ERROR signal indicates that the data word placed on the read data bus during the last cycle contained a correctable error and must be replaced with the corrected word for the data which is on the bus during the current cycle. Once a BC ERROR signal has been asserted all subsequent words of the same block transfer are also passed through the error correction logic. Accordingly, BC ERROR need be asserted only once for each block transfer.</p><p>The BC DATABACK signal indicates that the first word of the four word block to be transferred will be at the read data bus in the next cycle. The BC REJECT signal indicates that the bank controller cannot accept the contents of the write data bus at the end of the current cycle. The BC START indicates that a bank controller transfer operation is to commence.</p><p>Specific logic diagrams for the particular units of the bank controller board 18 of FIG. 3 are shown in FIGS. 44-63, which latter figures are appropriately labelled as follows to show more specifically a particular embodiment of the various portions of the bank controller 18 depicted therein.</p><p>The error correction logic 70 is shown in FIGS. 44-63 and includes the multiplexer store unit shown in FIG. 44; the C-bit generator unit 45; the (32 bits) register and (8 bits) register shown in FIG. 46; the drivers for the write data bus shown in FIG. 47; the S-bit generator shown in FIG. 48. The read save register shown in FIG. 49; the S save register shown in FIG. 50; the read parity save register and parity logic shown in FIG. 51 and the correction logic shown in FIG. 52. The direct read driver unit is shown in FIG. 53.</p><p>With reference to the control units at the lower part of FIG. 3, the R/W module selection unit and the RADDR and CADDR units are shown in FIG. 54; the MODSEL unit and drivers therefor are shown in FIG. 55; and the ADDRESS unit and driver therefor are shown in FIG. 56.</p><p>Appropriate timing and control logic both for address and data transfer and for memory refresh operation is shown in FIGS. 57-59, the drivers for the principal control signals supplied to the memory module being shown in FIG. 60; and various bus interface logic as shown in FIGS. 61-63.</p><p>Main Memory Modules</p><p>FIG. 4 depicts the overall block diagram for a typical memory module of the main memory system of the invention and shows the memory array 60 of dynamic NMOS random access memories (RAM's) organized as four planes of 16K 39-bit words each and identifiable as planes .0.-3. A word which is to be written into the memory array is received from the bank controller as WD.0.-38 via buffer 62. Words being stored in even planes .0. and 2 are stored in even plane data register 63 while words to be stored in odd planes 1 and 3 are stored in odd plane data register 64. The control signals are supplied from the bank controller to control logic 65. The module selects code bits MOD SEL.0.-3 are supplied to a comparator 66 to provide a MODSEL signal if the particular module has been selected. Control signals from control logic 65 are supplied to appropriate latching circuitry 67 to provide appropriate signals for controlling the operation of the memory array via drivers 61. The control signals from the memory bank controllers are first clocked into the plane .0.  latching registers 67A and the outputs thereof drive the plane .0. RAMs via drivers 61A. The outputs of the first latch register are those clocked at a fixed time period later into the next latch register set 67B which drives the plane 1 RAMs. Such pipeline operation continues in order to drive the plane 2 and plane 3 RAMs such that all four RAM planes receive the same control signals at fixed intervals, resulting in the transfer of a block of four consecutive 39-bit words. While the RAM address from the bank controller includes eight bits, only seven bits of address are used for the 16K RAMs discussed above, the extra bit allowing for possible future expansion. Thus, addressed bits ADR .0.-5 are clocked at fixed intervals to each of the latches 67A-67D of the planes .0.-3 at fixed intervals. ADR 6 is supplied to RAM selection logic 68 together with the plane .0. latch signal RPL .0. RAS to provide the JADR 6 signal for the plane .0. latch register 67A. The RAS and CAS signals provide the necessary control signals via the control logic 65 and latch registers 67 for driving the row address strobe (RAS) and the column address strobe (CAS) signals for the RAMs.</p><p>The LDOUT signal to the input of control logic 65 causes the module to load its output register at the end of the current cycle and enable it onto the read data bus during the next cycle via the data out register and multiplexer logic 69 and read bus driver 69A. The LDIN signal at the input to control logic 65 causes the module to accept data from the write data bus via registers 63 and 64 for writing into the RAM during the following cycle. The following timing diagrams show the status of the various signals for block read and block write operations at each fixed time interval (in the particular embodiment described, for example, each cycle can be 110 ns). As can be seen, the plane .0.-3 data is provided in the read operation in sequence and the input data is written into such planes in sequence.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->__________________________________________________________________________\nBlock Read                                                                \n    t0                                                                    \n          t1                                                              \n                 t2                                                       \n                        t3                                                \n                               t4                                         \n                                    t5                                    \n                                         t6                               \n                                              t7                          \n__________________________________________________________________________\nControl                                                                   \n     RAS    RAS,CAS                                                       \n                   RAS,CAS                                                \n                          LDOUT  &lt;pre-                                    \n                                      &lt;next                               \nSignals                                                                   \n     MODSELS                                                              \n            MODSELS                                                       \n                   MODSELS                                                \n                          MODSELS                                         \n                                 charge&gt;                                  \n                                      access&gt;                             \nAddress                                                                   \n     ROW    COLUMN COLUMN                                                 \nLines                                                                     \n     ADDRESS                                                              \n            ADDRESS                                                       \n                   ADDRESS                                                \nRead                             PLANE                                    \n                                      PLANE                               \n                                           &lt;etc.&gt;                         \nData bus                         DATA DATA.                               \n                                           &lt;etc.&gt;                         \nWrite                                                                     \nData Bus                                                                  \n__________________________________________________________________________\n</pre><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->__________________________________________________________________________\nBlock Write                                                               \n    t0                                                                    \n          t1                                                              \n                 t2                                                       \n                        t3                                                \n                              t4                                          \n                                    t5                                    \n                                         t6                               \n                                            t7                            \n__________________________________________________________________________\nControl                                                                   \n     RAS,LDN                                                              \n            RAS,CAS                                                       \n                   RAS,CAS            &lt;next                               \nSignals                                                                   \n     MODSELS                                                              \n            MODSELS                                                       \n                   MODSELS            access&gt;                             \nAddress                                                                   \n     ROW    COLUMN COLUMN                                                 \nLines                                                                     \n     ADDRESS                                                              \n            ADDRESS                                                       \n                   ADDRESS                                                \nRead                                                                      \nData Bus                                                                  \nWrite       PLANE 0                                                       \n                   PLANE 1                                                \n                          PLANE 2                                         \n                                PLANE 3                                   \nData Bus    DATA   DATA   DATA  DATA                                      \n__________________________________________________________________________\n</pre><p>More specific detailed logic circuitry for implementing the units shown in the block diagram of FIG. 4 to achieve the desired operation as described above are shown in FIGS. 64-78. Data in registers 63 and 64 are shown in FIGS. 64 and 65, respectively. The memory array 60 is shown in FIGS. 66-73 wherein plane .0. RAMs and the control input circuitry therefor are shown in FIGS. 66 and 67; plane 1 RAMs and the control input circuitry therefor are shown in FIGS. 68 and 69, plane 2 RAMs and the control input circuitry therefor are shown in FIGS. 70 and 71, and plane 3 RAMs and the control input circuitry therefor are shown in FIGS. 72 and 73. The data out register and multiplexer unit 69 are shown in FIG. 74. Latching and driver logic is shown in 75. The RAM select logic unit (RAMSEL LOGIC) is shown in FIG. 76, while the MODSEL comparator unit 66 and the various control logic units and latching circuitry associated therewith and with the input control signals from bank controller unit 18 are shown in FIG. 77. Memory module timing logic is shown in FIG. 78.</p><h4>Address Translation Unit</h4><p>The address translation unit (ATU) 14 is shown broadly in FIGS. 79-81, the primary function of such unit being to translate a user's logical address (LA) into a corresponding physical address (PA) in the physical address space of the processor's memory modules discussed above. Such translation is effectively performed in two ways, one, by accessing a page from the system cache or from main memory at the particular page table entry specified in a field of the logical address and placing the accessed page in a translation store unit for use in performing the address translation, a sequence of operations normally designated as a Long Address Translation (LAT) and, the other, by accessing additional references to a page that has already been selected for access after an LAT has been performed and the page selected by the LAT is already present in the translation store. The latter translation provides an accelerated address reference and can be accomplished by saving, at the end of every Long Address Translation, the address of the physical page which has been accessed. As mentioned, the physical page involved is stored in a high speed random access memory (RAM) file designated in FIG. 79 at ATU translation store 100.</p><p>Translations of addresses on the physical page which is stored in the ATU translation store 100 are available to the processor within one operating time cycle of the CPU, while normally the Long Address Translation will take a plurality of such cycles for a reference which requires a single level page table reference (e.g. 3 cycles) or a two-level page table reference (e.g. 5 cycles), where the page in question is available in the system cache memory. Even longer times may be required if the page involved can not be found in the system cache memory and must be accessed from main memory.</p><p>A secondary function of the ATU is to emulate all operations of the previous system of which the present system is an extension, e.g., in the system described, to perform all Eclipse memory management processor unit (MMPU1) address translation operations, as described in the above referenced publication for such systems, in an efficient and compatible way, such emulated operations being described in more detail later.</p><p>In order to understand more clearly the translation of a logical word address (a byte address when shifted right by one position produces a word address), the logical word address can be defined as shown below: ##STR2##</p><p>As seen therein, the segment and logical page address is 21 bits long, the segment and logical page address being divided into two fields, the Tag field and the Index field. The Tag field is defined as bits LA 2-14 while the Index field is defined as bit LA 1 plus bits LA 15-21.</p><p>As seen in FIG. 79, when a logical word address LA.0.-31 is received from the arithmetic logic unit (ALU) on the logical address bus 26 it is latched into a logical address register (LAR) 101. The Index bits LA 15-21 are taken directly from the logical address bus to address four RAM stores, the first being a Tag store 102, which retains the tag portions of the logical addresses corresponding to the physical addresses saved in the ATU physical address (PA) translation store 100. The Index bits LA 15-21 are also supplied to a validity store RAM unit 103 and to a protection store RAM unit 104, as discussed below.</p><p>If the physical address translation store 100 contains valid address translations, when a memory access is started the logical address is loaded into the logical address register 101 and the Index (bits LA 15-21) is used to select a location in the store.</p><p>In the particular system described, even though there is a valid address translation at such location in translation store 100, it may not be the correct one. Corresponding with each index of the logical addresses (and each address location in the translation store) there are a selected number of possible \"tags\", each tag corresponding to a unique physical page address. Only one of such tags and its corresponding physical page address can be saved in the translation store 100 at the location selected by the Index. Therefore the \"tag\" (TAG 2-14) that corresponds to the Index in question and is currently stored in the tag store 102 is compared at comparator 105 to the \"tag\" in the logical address register (LA 2-14). If the \"tags\" correspond, the address translation contained in the translation store 100 is the correct one and can be used to supply the desired physical address (signified by an ATU HIT signal at the output of comparator 105). If they do not match, a Long Address Translation operation must be performed to obtain the desired physical page address from the system cache or main memory. The physical page address which is thereby accessed by such LAT procedure to replace the physical page address previously contained in the ATU translation store 100 is placed on the appropriate transfer bus (CPM bus 20). At the completion of the long address translation, the \"tag\" taken from the logical address register (LAR 2-14) is written into the tag store 102 at the location selected by the index and the physical page address from the memory data register 106 (MD 18-31) is written into the translation store 100 at the location specified by the index.</p><p>The ATU configuration shown in FIG. 79 also contains further components which are used to place the translated physical address of a desired physical page table on the physical page address (PA) bus 27. There are three other possible sources of physical page table addresses, the first of which is bits SBR 18-31 of a segment base register which segment base register can also be located in scratch pad units of the address translation unit. This address is used to reference either a high order page table (HOPT) of a two-level page table or the low order page table (LOPT) of a one-level page table. Since the segment base registers are located at the ATU, such address can be obtained from the logical address bus 26 as LA 18-31.</p><p>The following diagrams depict the results of the control actions initiated by the arithmetic translation unit (ATU) to perform a long address translation in which a physical address is derived from a logical address by traversing the one-and two-level page tables in the main memory. Diagram A depicts a one-level page table traversal, while Diagram B depicts a two-level page table traversal, the physical address bits 3-21 of the final physical address (i.e., the desired memory allocation data) being placed in the translation store 100 so that when the corresponding logical address is subsequently requires a translation, the physical address is available (an ATU HIT occurs) and there is no need for subsequent long address translation.</p><p>The logical word address to be translated for a one-level page table translation has the format shown in FIG. 157 A. Bits 1-3 of the word address specify one of the eight segment base registers (SBRs). The ATU uses the contents of this valid SBR to form the physical address of a page table entry (PTE), as shown at point  1  of the diagram.</p><p>The selected SBR contains a bit (bit 1) which specifies whether the page table traversal is a one-level (bit 1 is zero) or a two-level (bit 1 is a one) page table. In Diagram A a page table entry address comprising the starting address of a selected page table and page table entry offset specifying a page address therein.</p><p>To form this physical page address, the ATU begins with the physical address as shown at  2  of the diagram. This address becomes bits 3-21 of the PTE address. Bits 13-21 of the logical word address become bits 22-30 of the PTE address. The ATU appends a zero to the right of the PTE address, making a 29-bit word address.</p><p>Bits 3-21 of the PTE address (unchanged in the step above) specify the starting address of a page table. Bits 22-31 of the PTE address specify an offset from the start of the stable to some PTE (labelled PTEn in Diagram A). This PTE specifies the starting address of a page of memory, as shown at  3  of the diagram.</p><p>PTEn bits 13-31, the page address, become bits 3-21 of the physical address, as shown at  4  of FIG. 157. The page offset field specified in bits 22-31 of the logical word address becomes bits 22-31 of the physical address. This is the physical word address translated from the original word address. The physical address bits 3-21 are placed in the translation store as the memory allocation data for subsequent use if the same logical word address requires subsequent translation. It should be noted that when using a one-level page table, bits 4-12 of the logical word address must be zero. If they are not zero and bit 1 of the SBR indicates a one-level page table is required, a page fault occurs.</p><p>Just as in the one-level page table translation process, in the two-level page table translation depicted in FIG. 158, the processor produces a physical address. The logical word address to be translated has the format shown in the diagram, the steps (1) through (4) being substantially the same as in Diagram A except that bits 4-12 of the logical word address become bits 22-30 of the PTE address. The ATU appends a zero to the right of the PTE address, making a 29-bit word address. Bits 1-3 of the word address specify one of the eight segment base registers (SBRs).</p><p>Bits 3-21 of the PTE address specify the starting address of a page table. Bits 22-31 of the PTE address specify an offset from the start of the table to some PTE (labelled PTEn). The PTE specifies the starting address of a page table. Thus, the ATU now constructs the address of a second PTE from the address at  4 . The physical address specified in bits 13-31 of the first (PTEn) becomes bits 3-21 of the address of the second PTEm. Bits 13-21 of the logical word address become bits 22-30 of the second PTE's address. The ATU appends a zero to the right of the second PTE address to make a 29-bit word address.</p><p>Bits 3-21 of the second PTE address specify the starting address of a second page table. Bits 22-31 of the second PTE address specify an offset from the start of the second table to some PTE (labelled PTEm in Diagram B). The second PTE specifies the starting address of a page, as shown at 5  in Diagram B.</p><p>The second PTEm's bits 13-31, the page address, become bits 3-21 of the physical address and the page offset specified in bits 22-31 of the logical word address becomes bits 22-31 of the physical address, as shown at  6  in FIG. 158. This last value is the final physical word address.</p><p>The physical page table address for the low order page table of a two-level page table is in bits 18-31 of the high order page table entry (HOPTE) which must be fetched from the main memory. Thus, the second possible source of the physical page table address is the memory data register (MD) 105 which holds the data that arrives on the physical memory data (CPM) bus 20 as MD 18-31. A suitable page table multiplexer 107 is used to select which of the two sources will drive the physical address bus when its outputs are enabled.</p><p>The third and final source is to drive the physical page address bus 27 directly through a physical mode buffer 108, such buffer being used to address physical memory directly (PHY 8-21) from buts LA 8-21 of the logical address bus. Such buffer is enabled while the ATU unit is turned off (i.e., no address translation is required) since the physical address in that mode is the same as the logical address and no translation is necessary.</p><p>Bits PHY 22-31 of the physical address are offset by displacement bits, there being three possible origins for the offset. The first source of such offset is from bits LA 22-31 of the logical address bus which bits are used while in physical mode (not address translation is necessary) as well as the offset in the object page. The second source of the offset is bits LAR 4-12 (referred to as two-level page table bits in Diagram B above) of the logical address register which is used as an offset within the high order page table during a long address translation. Since this source is only nine bits long and page table entries are double words aligned on even word boundaries, a ten bit offset (to form PHY 22-31) is constructed by appending a zero bit to the least significant bit. The final source for the offset is bits LAR 13-21 (referred to as one-level page table bits in Diagram B above) of the logical address register which is used as an offset within the low order page table during a long address translation. A zero bit is appended to the least significant bit of this source also. Offset multiplexer 109 is used to select the desired one of such three offset sources.</p><p>The following discussion summarizes the address bit sources for forming a low order or high order page table entry address in main memory in making a long address translation. The address of the page table entry is formed from address fields in a segment base register (SBR) and from address fields in the logical address register. The address fields of a segment base register can be depicted as follows: ##STR3##</p><p>Depending on whether a one-level (low order) or a two-level (high order) page table entry is called for, the SBR address field comprising bits 4-12 or the SBR address field comprising bits 13-21 is transferred to the memory data register 105 to form the higher order bits of the page table entry. As mentioned above, the eight SBR registers are located in 8 of the 256  locations of scratch pad registers on the ATU. This use of such scratch pad locations for the segment base registers can be contrasted with prior known systems wherein the segment base register (or registers comparable thereto) in a segment, or ring, protection memory system are all located at specific locations in the main memory. By placing them in a scratch-pad memory located in a processing unit of the system, as in the ATU unit here, the higher order page table entry bits are acquired more rapidly than they would be if it were necessary to fetch them from main memory and, hence, the speed at which page table entries can be made is improved considerably.</p><p>One of the bits of an SBR (identified above as \"V\" bit) is examined to determine whether the SBR contents are valid. Another bit (identified above as \"L\" bit) is examined to determine whether a 1-level or a 2-level page table entry is required so that the correct field is supplied to the memory data register.</p><p>Other bit fields of the SBR are used to determine whether a Load Effective Address (LEF) instruction (such LEF instruction is part of the Eclipse instruction set as explained more fully in the above cited publications therein) or I/O instruction is required. Thus in a selected state the LEF Enable bit will enable an LEF instruction while a selected state of the I/O Protect bit will determine whether an I/O instruction can be permitted. The remaining field of the SBR contains the address offset bits.</p><p>Protection Check System</p><p>As is also seen in FIG. 79 a variety of protection checks are made for each reference to memory, which protection checks are made by the use of protection store unit 104, protection logic unit 110 and ring protection logic unit 111 for providing appropriate fault code bits (FLTCD 0-3) which are supplied to the micro-sequencer (described below) via driver 112 on to the CPD bus 25 for initiating appropriate fault micro-code routines depending on which fault has occured.</p><p>The following six protection checks can be made:</p><p>1. Validity storage protection</p><p>2. Read protection</p><p>3. Write protection</p><p>4. Execute protection</p><p>5. Defer protection</p><p>6. Ring maximization protection</p><p>A validity storage protection check determines whether the corresponding block of memory to which a memory reference is made has been allocated and is accessible to the current user of the system. The validity storage field is a one-bit field which is located, for example, at bit zero of each of the segment base registers (located on an ATU board as discussed above) or at bit zero in each of the high order page table entry addresses and low order page table entry addresses. In a particular embodiment, for example, a \"1\" indicates that the corresponding block has been so allocated and is accessible whereas a \"0\" indicates that the user cannot use such a memory block.</p><p>Generally when a new user enters the system all pages and segments in the logical address space which are allocated to that user, except those containing the operating system, are marked invalid. Validity bits are then set valid as the system begins allocating logical memory to such new user. If a user makes a memory reference to an invalid page, an invalid page table, or an invalid segment, the memory reference is aborted and a validity storage protection error is then signaled by the fault code bits on the CPD bus.</p><p>The read protection field is a one-bit field normally located at a selected bit (bit 2, for example) in each of the low order page table entry addresses and a check thereof determines whether the corresponding object page can or cannot be read by the current user. If the page cannot be read, a read error is signaled by the fault code bits on the CPD bus. In a similar manner a check of the write protection error field determines whether the corresponding object page can be written into by the current user, an appropriate write error being signaled by the fault code bits if the user attempts to write into a page to which he is not allowed.</p><p>The execute protection field is a one-bit field which is located at a selected bit (e.g. bit 4) in each of the low order page table entry addresses and a check thereof determines whether instructions from a corresponding object page can or cannot be executed by the current user. If such an instruction fetch is not allowed, an execute error is signaled by the fault code bits on the CPD bus. Execute protection is normally checked only during the first fetch within a page and any additional instruction fetches are performed using the physical page address from the first fetch, which for such purpose is retained by the instruction processor.</p><p>When a user is attempting to reference a location in memory and is utilizing a chain of indirect addresses to do so, the system will abort the operation if a chain of more than a selected number of said indirect addresses is encountered. For example, in the system under discussion if a chain of more than sixteen indirect addresses is encountered the operation is appropriately aborted and a defer error is signaled by the fault code bits on the CPD bus. Such protection is utilized, for example, normally when the system has performed a loop operation and the system, because of a fault in the operation thereof, continues to repeat the indirect loop addressing process without being able to break free from the loop operation.</p><p>Ring maximization protection is utilized when the user is attempting to reference a logical location in memory in a lower ring (segment) than the current ring of execution (CRE 1-3). Since such operation is not permitted by the system, the operation must be aborted if the user attempts to reference a lower ring than currently being used and a ring maximization error is signaled on the CPD bus. Since the logical address space is divided into eight rings, or segments, a ring which the user desires to reference can be indicated by bits 1-3, for example, of the logical address.</p><p>The specific logic circuitry utilized for such protection checks (i.e., the protection store 104 and the protection logic 110 and the protection logic 111 associated therewith) is shown in FIGS. 80 and 81. Thus, logic for the generation of the read error, write error, execution error and validity error signals is shown in FIG. 80 and logic for generating the defer error and ring maximization error signals being shown in FIG. 81.</p><p>With respect to the protection system, since logical address space is partitioned into eight hierarchical regions (i.e. the \"rings\" or \"segments\") the partitioning can be delineated by the segment field of the logical address. Thus, segment number 0 is always assigned to ring 0 (ring 0 being the ring in which only priviledged instructions can be executed), segment 1 is always assigned to ring 1, and so forth. Such approach differs from previous systems using a segmented hierarchical address space in that the ring number is not independent of the logical address space. In contrast, in the system discussed here, each ring is directly bound in the space so that segment 0 is always allocated to ring 0, segment 1 to ring 1, and so forth.</p><p>The access field in a page table entry comprises three bits (MD 2-4) is shown in FIG. 79 and indicates the capabilities of the referenced data item in the logical address space, i.e. as to whether the reference data item is to be a read access, a write access, or an execute access, the protection store 104 responding to such bits to produce either a read enable signal (RD ENB), or a write enable (WR ENB) or an execute enable (EX ENB). The ring protection governs the proper interpretation of the access privileges of the user to a particular ring, a user being permitted access only to selected, consecutively numbered rings. Thus, access can only be made to a bracket of rings (an access bracket) if the effective source for such reference is within the appropriate access bracket. For example, the read bracket of a data reference in any ring is the ring number. That is, a data address reference to segment 5 (ring 5), for example, can never legitimately originate from an effective source which is greater than 5. In other words an effective source in segment 5 can never reference a ring lower than ring 5 and, therefore, if a reference from an effective source greater than 5 attempts to access ring 5 a ring maximum error (MAX ERR) will be signaled as shown by the logic in FIG. 13. A table showing such ring protection operation is shown below:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nEffective                                                                 \nSource  Target Space                                                      \nSpace   RING 0   RING 1    Ring 2 . . .                                   \n                                       RING 7                             \n______________________________________                                    \nRING 0  Val-R0   Val-R1    Val-R2 . . .                                   \n                                       Val-R7                             \nRING 1  Fault    Val-R1    Val-R2 . . .                                   \n                                       Val-R7                             \nRING 2  Fault    Fault     Val-R2 . . .                                   \n                                       Val-R7                             \n.       .        .         .           .                                  \n.       .        .         .           .                                  \n.       .        .         .           .                                  \nRING 7  Fault    Fault     Fault  . . .                                   \n                                       Val-R7                             \n______________________________________                                    \n</pre><p>In summary, in order to make a ring access, the ring maximization function is used to determine whether or not the reference is a valid ring reference and, if it is, the page table entry that references the address datum is examined to see if the page is a valid one. Then, if the read protection bit indicates that such valid page can be read, the read can be performed. If any one of the examinations shows a protection error (i.e., ring maximization error, validity error, or read error) the read is aborted and an appropriate fault code routine is called. Similarly, appropriate examination for protection errors for write access and execute access situations can also be performed.</p><p>In an hierachical address space such as discussed above, it is desirable to mediate and authenticate any attempt to switch rings, i.e., to obtain access to a ring (segment) other than the ring which is currently being used (a \"ring crossing\" operation). The performing of a ring crossing operation is authenticated as follows.</p><p>Any ring crossing attempts occur only as a result of an explicit attempt to do so by a program control instruction, and such explicit attempt can occur only if the following conditions are satisfied.</p><p>(1) The program control instruction is of the form of a subroutine \"call\", i.e., where access is desired to a subroutine in another ring (LCALL--see Appendix B), or a subroutine \"return\", i.e., where a subroutine in another ring has been accessed and it is desired to return to the original ring (WRTN and WPOPB--see Appendix B). All other program control instructions (e.g., JUMP) ignore the ring field of the effective address required for the instruction and such instructions can only transfer to locations within the correct segment.</p><p>(2) The direction of a subroutine call crossing must be to a lower ring number (i.e., inwardly toward ring 0) wherein the lower ring has a higher order of protection and the current ring of execution and the direction of a subroutine return crossing must be to a higher ring number (i.e., outwardly away from ring 0) wherein the higher ring has a lower order of protection than the called ring containing the subroutine. Outward calls and inward returns are trapped as protection faults.</p><p>(3) The target segment of the effective branch address is not in the segment identified by bits 1-3 of the program counter.</p><p>In the above conditions are met the return address for outward returns is merely interpreted as a normal word address. However, if the above conditions are met for an inward call, the branch address is interpreted as follows: ##STR4## Bits 16-31 are interpreted as a \"gate\" into the specified segment (SBR of bits 1-3) in the target space. The gate number is used to verify that the specified gate is in the called segment and, upon verification, to associate on instruction address with the specified gate via a \"gate array\" in the called segment, as discussed below.</p><p>The location of the gate array in any called segment is indicated by a pointer contained in particular locations of the called segment (e.g., in a particular embodiment the pointer locations may be specified as locations 34 and 35 in each segment. The structure of the gate array is as follows: ##STR5##</p><p>The gate number of the pointer which referenced the target segment is compared with bits 16-31 of the first 32 bits of the gate array. If the gate number is greater than or equal to the maximum number of gates in the gate array, the ring crossing call is not permitted and a protection fault occurs (if the maximum number of gares is 0, the segment involved cannot be a valid target of an inward ring crossing call operation).</p><p>If the gate number is less than the maximum number of gates, the gate number is then used to index into one of the gates of the gate array which follows the first 32 bits thereof. The contents of the indexed gate are read and are used to control two actions. First, the effective source is compared to the gate bracket bits 1-3 of the indexed gate. The effective source must be less than or equal to the referenced gate bits and, if so, the PC offset bits 4-31 become the least significant 28 bits of the program counter and bits 1-3 of the program counter are set to the segment containing the gate array.</p><p>If the gate in a ring cross operation, as described above, is a permitted entry point to the ring to which the crossing is made, a new stack is constructed. In order to do so a stack switching operation must occur since there is only one stack per ring. Thus, before the new stack can be created, the contents of the current stack management registers must be saved at specified memory locations of the caller's ring. The callee's stack can then be created, the arguments from the caller's stack being copied onto the newly created callee's stack, the number of such arguments being specified by the X or the LCALL instruction (see Appendix B). An appropriate check is first made to determine whether copying of all of the arguments would created a stack overflow condition. If so, a stack fault is signalled, the ring crossing being permitted and the fault being processed in the called ring.</p><p>In order to emulate operation of ECLIPSE address translation operations appropriate emulation control signals for placing the ATU in the ECLIPSE operating mode are required as shown by emulation control logic unit 115 which, in response to coded instructions generated by the microsequencer board 13 produces such signals to permit operation for 16-bit addresses equivalent to the memory management protection unit (MMPU) of ECLIPSE comparators as described in the aforesaid publications thereon.</p><p>Specific logic circuitry for implementing the various blocks of the address translation unit shown in FIGS. 79-81 are shown in FIGS. 82-100. FIG. 82 depicts the translation store unit 100 supplied with bits MD 18-31 from the memory data register 105 and in turn supplying the translated physical address bits 8-21 which have resulted from a translation of the logical address bits LA 15-21. FIG. 82 also shows the page table address multiplexer unit 107 and physical mode buffer unit 108. In addition, such figure includes the \"last block\" register unit 116 which during an ECLIPSE MMPU emulation operation provides the physical address bits PHY 8-21. FIG. 82 also shows the LMP Data Register. FIG. 83 shows Tag Store 102 and Protection Store 104. Tag comparator unit 105 is depicted in FIG. 84. FIG. 85 shows the logical address register 101, which physical address offset multiplexer 109 and the logical address register CPD bus driver unit are shown in FIGS. 86 and 87, respectively. The physical address bus driver units for filing the appropriate physical address bit PHY 8-21 are shown in FIG. 88.</p><p>Protection logic including fault detection and cache block crossing trap logic is depicted in FIGS. 89-92, protection logic identification encoder unit 110 being shown in FIG. 89, the fault code bit drive unit 112 being shown in FIG. 90, ring protection logic circuit 111 being shown in FIG. 91 and the fault detection and cache block crossing logic being shown in FIGS. 92 and 93.</p><p>Validity store unit 103 is shown in FIG. 94 together with translation purge logic and the multiplexer associated therewith. The translation register of FIG. 79 is depicted in detail in FIG. 95. The reference/modify storage and control logic unit is shown in FIG. 96, the state save drive unit associated therewith being depicted in FIG. 97. The 16 bit MMPU emulation control logic is shown in FIG. 98.</p><p>ATU timing logic is shown in FIG. 99 and suitable system code interface logic is shown in FIG. 100.</p><h4>Instruction Processor</h4><p>The instruction processor (IP) 12 is utilized to handle the fetching and decoding of macro-instructions for the data processing system of the invention. The instruction processor operates both at and ahead of the program counter and its primary function is to provide a starting microaddress (ST\u03bcAD) for each micro-instruction, which starting microaddress is supplied to the microsequencer unit 13. Subsidiary functions of the instruction processer are (1) to provide the source and destination accumulator designations, (2) to provide the effective address calculation parameters for the arithmetic logic unit and (3) to provide sign or zero extended displacements for making memory references or for in-line literals (immediates) to the arithmetic logic unit (ALU).</p><p>Instruction Cache</p><p>As seen in FIG. 101, the instruction processor includes instruction cache logic 120 (ICACHE), macro-instruction decoding logic 121 (which includes an instruction decode register as shown in FIG. 103) and program counter/displacement logic 122 as described below. The ICACHE logic functions as a pre-fetcher unit, i.e., the instruction cache (ICACHE) thereof obtains a block od subsequent macro-instructions for decoding, which block has been accessed from memory while the previous macro-instructions are being executed. The ICACHE stores the subsequent block of macro-instructions even if such macro-instructions are not immediately going to be used by the microsequencer. The decoding logic 121 of the instruction processor responds to a macro-instruction from ICACHE, decodes the operational code thereof (opcode) to provide the opcode description information for control and status logic 123 and to supply the information needed therefrom to the starting micro-address (ST\u03bcAD) register 124 (and thence to the micro-sequencer) to identify the starting micro-address of the required micro-instructions.</p><p>The displacement logic 122 supplies the displacement data to the ALU if the index for such displacement is on the ALU board. If the index for the displacement is the IP program counter, the displacement logic combines the displacement information with the program counter information available at the instruction processor to form the logical address for supply to the LA bus.</p><p>Thus, in an overall IP operating sequence, a macro-instruction is read from an ICACHE storage unit of the ICACHE logic 120 into the decode logic 121 which thereupon decodes the instruction opcode and generates the starting micro-address for the micro-sequencer. During the decoding and starting micro-address generation process, the instruction processor simultaneously reads the next macro-instruction from the ICACHE into the decode logic. While the micro-sequencer is reading the first micro-instruction, the decode logic is decoding the next macro-instruction for generating the next starting micro-address. When the micro-instruction at the starting micro-address is being executed, the micro-sequencer reads the next micro-instruction from the next starting micro-address. Accordingly, a pipeline decoding and execution process occurs.</p><p>As seen in the more detailed FIG. 102, the ICACHE logic 120 includes an ICACHE data store unit 130, a tag store unit 131 and a validity store unit 132. As discussed with reference to the system cache 17 of the memory system, the operation of the ICACHE is substantially similar in that the tag portion (PHY ICP 8-21) of the address of each desired word of the macro-instruction is compared at comparator 133 with the tag portions of the addresses stored in the TAG store 131 of those words which are stored in the ICACHE data store 130. In addition, the validity store unit demonstrates whether the desired address is a valid one. If the address is valid and if a tag \"match\" occurs, the 32-bit double word at such address is then supplied from the ICACHE data store 130 to the decode logic 121.</p><p>If the required macro-instructions in the appropriate ICACHE block are not present on the current physical page (i.e., the physical page corresponding to the logic page value of the current value of the program counter) which is stored in the ICACHE data store 130 (i.e., a Tag match does not occur) or if the validity bit is not set, an ICACHE \"miss\" occurs and the cache block containing the macro-instructions must be referenced from memory. Such ICACHE block memory reference may be to the system cache (SYS CACHE) or to the main memory, if the system cache access also misses. When the accessed ICACHE block is fetched, the desired macro instructions thereof are written into the ICACHE data store 130 from CPM register 134 and the block is simultaneously routed directly into the decoding logic through bypass path 135. The ICACHE logic can then continue to prefetch the rest of the macro-instructions from the fetched page as an instruction block thereof, placing each one into the ICACHE data store 130 as they are accessed. The control logic for the ICACHE logic 120 is ICACHE/ICP control logic unit 136.</p><p>Decode/Displacement Logic</p><p>The decode logic, shown in more detail in FIG. 103, includes instruction decode units 140 and 141 for decoding the opcode portion of the macro-instructions. Decode unit 140 is used for decoding the opcodes of the original basic instructions for the system of which the present system is an extension. Thus, in a specific embodiment as discussed above, such basic instructions may be the NOVA and ECLIPSE instructions for Data General Corporation's previous NOVA and ECLIPSE system. Decode unit 141 is used for decoding the opcodes of the extended instruction set, e.g. the \"Eagle\" macro-instructions mentioned above.</p><p>The opcodes are supplied from an instruction decode register (IDR) 142 having three storage register sections, each capable of storing a word and identified as IDR A, IDR B and IDR C. The opcode of each macro-instruction is stored in the IDR A section while displacements are stored in the IDR B and C sections. An IDR shifter unit 143 is used to shift the desired opcode portion of the instruction accessed from the ICACHE data store 130 into the IDR A section of IDR 142 and to shift the appropriate displacement words of the instruction, if any, to the IDR B and IDR C sections thereof. The control logic for the IDR and the IDR shifter units is IDR/shifter control unit 137, shown in FIG. 102.</p><p>When the macro-instruction has been routed to the decode logic, the decode units 140 or 141, as required, decode the opcode portion thereof to provide opcode description (OPCD DSCR) information, including the length of the instruction (i.e., whether the instruction comprises a single, or double or triple word). When the entire instruction has been supplied to the decode logic (from ICACHE data store 130) a SET IDR VLD signal is generated to produce an IDR VLD signal at IDR/shifter control 137 (FIG. 102). Following the decoding process, the starting micro-address is loaded into the ST\u03bcAD register 144 from either decode PROM 140 or 141 depending on whether the macro-instruction is a basic or an extended instruction. Control of the loading of ST\u03bcAD register 64 resides in ST\u03bcAD load control unit 145.</p><p>The displacement word or words, if any, are generally present in IDR B or C (for certain NOVA instructions a byte displacement may be extracted from IDRA, although generally for almost all other instructions displacements are extracted from IDRB and IDR), being extracted from the displacement logic 146, as shown in FIG. 104. The displacements are sign or zero extended, as necessary, and are clocked into a displacement register thereof so as to be made available either directly to the logical address (LA) bus or to the CPD bus for use at the ALU unit, as discussed below.</p><p>When the starting micro-address has been clocked into ST\u03bcAD register 144, an UPDATE signal is issued by the IP status logic unit 138 (FIG. 102) to inform the IDR/shifter control 143 that the decoded information has been used and can be shifted out of IDR 140/141. The decoding of subsequent macro-instructions continues until a discontinuity in the straight-line decoding operation occurs. When a jump in the straight-line operation occurs the micro-sequencer issues an IPSTRT signal to the program counter register 147 of the instruction processor (FIG. 20) so that a new program counter address (LA 4-31) can be placed in the program counter register from the logical address bus. The starting micro-address register 144 is reset and the starting micro-address of an appropriate wait routine, for example, is placed therein until the decoding process for the instruction associated with the new program counter can begin.</p><p>In some situations the sequence of macro-instructions which are being decoded are present on more than one physical page. Under such conditions when the ICACHE control detects the end of the page which is stored in the ICACHE data store 130, a special routine must be invoked in order to fetch the next page into the ICACHE store 130 so as to continue the prefetching operation on the new page. Thus, when the last instruction of a particular page has been decoded and the decode pipeline is effectively empty, the starting micro-address register is loaded with the starting micro-address of a suitable page control routine which accesses the required new page and permits the next page to be loaded into ICACHE store 130 via physical page register 134 so that the instruction processor can continue with the decoding of the macro-instructions thereon.</p><p>If a macro-instruction is not on the page contained in the ICACHE store 130, the correct page must be accessed from either the system cache or main memory because of an ICACHE \"miss\" in the instruction processor. Access to the system cache is provided at the same system cache input port as that used by the address translation unit (ATU). In the system of the invention, however, the ICACHE is given a lower priority than the ATU so that if the ATU wishes to access the system cache the instruction processor must hold its access request until the ATU has completed its access.</p><p>The use of ICACHE logic as described herein becomes extremely advantageous in programs which utilize a short branch backwards. If a macro-instruction branch displacement is less than the number of words in the ICACHE data store there is a good chance that the required macro-instructions will still be stored locally in the ICACHE data store and no additional system cache or main memory references are required.</p><p>In a particular embodiment, for example, the overall ICACHE logic 120 may comprise a single set, direct mapped array of 256 double words in data store 130 plus Tag and Validity bits in Tag Store 131 and Validity store 132. Data is entered into the data store as aligned double words and the ICACHE data store is addressed with the eight bits which include bits ICP 23-27 from the instruction cache pointer (ICP) unit 150 shown in FIG. 105 and bits ADR 28,29,30 from unit 139.</p><p>A copy of the Tag store 131 of the instructor processor's ICACHE unit is also kept in the system cache, the latter cache needing such information so that it can inform the instruction processor when data has been written into the ICACHE.</p><p>The validity store 132 is arranged, for example, in a particular embodiment, as 64 double words by four validity bits in order to indicate the validity of each double word in the ICACHE data store. Each initial fetch into a new block of instruction words will set the corresponding validity bit for the double words and reset the remaining three validity bits. During a prefetch operation into the same block, the corresponding validity bit for the prefetch double word is set while the remaining three validity bits remain the same. The prefetching operation stops when the last double word in the block has been prefetched in order to avoid unnecessary system cache faults.</p><p>If the ICACHE operation is such that the end of a physical page is reached and it is necessary to obtain the next physical page address for the next logical page of the program counter (PC bits 4-21), the ICACHE control logic unit 136 (FIG. 102) asserts a signal (identified as the ICAT signal) which is supplied to the ST\u03bcAD load control logic 145 (FIG. 103). When the last macro-instruction at the end of the current page has been decoded, the ST\u03bcAD control logic 145 supplies the starting micro-address for the ICAT micro-code routine which thereupon performs the necessary address translation operation for a transfer of the next physical page address for the ICACHE data store 130.</p><p>The instruction processor utilizes two pointers to the instruction stream. The first pointer is the program counter register 147 (FIG. 104) which holds the logical address of the instruction which is being executed, and the second pointer is the instruction cache pointer (ICP) 150 (FIG. 106) which holds the logical address of the next macro-instruction which is needed for the decode logic. A separate register PICP 152 (physical instruction cache pointer) holds the physical page address of the logical page referred to by bits 4-21 of the instruction cache pointer (ICP). Thus the ICP 150 functions as the prefetch logical address pointer and the PICP functions as the prefetch physical address pointer. The program counter 147 and the ICP 150 are loaded from the logical address bus at the start of an instruction processor operation. The ICP is incremented ahead of the program counter as the decoding pipeline operation is filled. On an ICACHE fault, or miss, the PICP physical address is used to reference the memory and the ICP address is used as a pointer to the next logical page address for address translations when the end of the correct page has been reached.</p><p>In accordance with the instruction processor operation the optimum performance is achieved when the instructions are locally available in the ICACHE, such instructions thereby becoming substantially immediately available when the micro-sequencer requests them. Instructions which are not locally available in the ICACHE take an amount of time which is dependent on system cache address operation and page fault routine operations.</p><p>The macro-instruction decoding logic utilizes three 16-bit fields identified as the IDR A, IDR B, and IDR C fields, as mentioned above. The \"A\" field contains the opcode while the \"B\" and \"C\" contain either the displacement(s) for the instruction in the \"A\" field or one or more fields of the macro-instruction which follows in the instruction stream. The instruction decode register, IDR 142, is arranged to keep all three fields full, if possible, by sending word requests tothe ICACHE (ICP control unit 136) when any of the three IDR fields is empty. As mentioned above, if the ICACHE word request results in an ICACHE \"miss\" a system cache fetch is initiated.</p><p>The \"A\" field of the instruction decode register 142 is used by the decode logic PROMs 140 or 141 to decode the opcode of the macro-instruction and, also to provide the starting address of the macro-instruction which is required. The \"B\" and \"C\" fields determine the displacements, if any, that are required. Each field is one word in length and therefore the longest instruction that the instruction processor can decode and canonicalize the displacement for has a maximum length of three words.</p><p>When the A field of the instruction decode register is full, the decode PROMs 140 or 141 decode the opcode of the instruction. If the entire instruction, including opcode plus displacement, is in the instruction decode register, a signal IDR VLD is asserted by the IDR shifter control logic 137 to inform the IP status logic 138 that an entire instruction is ready to be decoded so as to provide a starting micro-address for ST\u03bcAD register 144. The displacement logic 146 which extracts the displacement, either sign or zero extends it, as necessary, and then loads it into a displacement register. If the displacement index is on the ALU board the displacement is latched onto the CPD bus via latch unit 153 for supply thereto. If the displacement index is the PC register 147, the displacement is added to the PC bits at adder 148 and supplied to the logical address bus via latches 149, as shown in FIG. 104.</p><p>During the above loading processes the instruction decode register 142 is shifted by the length of the instruction that has been decoded so as to be ready to receive the next instruction, i.e., a shift of one, two or three words. The IDR shifter unit 143 serves to provide such shift of the contents of the instruction decode register 142. A shift of three words, for example, completely empties the instruction decode register which is then ready to receive the next instruction from the ICACHE (or directly from memory on an ICACHE \"miss\"). The shifter, for example, allows either word in a double-word instruction which has been accessed from the ICACHE to be directly loaded anywhere into the instruction decode register. The placement in IDR 142 is determined by examination of the validity bits in the IDR. Thus if the \"A\" field is invalid, the incoming instruction data would be loaded into the \"A\" field. Whenever any of the three fields in the instruction decode register 142 are empty, a word request is made of the ICACHE via ICACHE control logic 136 for accessing the next instruction as determined by the ICACHE pointer (ICP) 150, bits 23-27 of which uniquely determine which double-word in the ICACHE is to be accessed. If the instruction is a single word instruction, the ICP bits 28-30 and the ICPX bits 28-30 obtained from the fetch request control logic 151 (FIG. 105) uniquely determine which word of the double word is to be used as the instruction as shown at word pointer logic 139 (FIG. 102).</p><p>If the instruction decode register 142 has at least two fields empty and a word pointer points to an even double word, then the double word would be loaded into two empty fields of the IDR. After loading, the ICACHE pointer 150 would be incremented so that it points to the next double word. If the IDR has only one empty field and a word pointer points to an even double word, then the first word would be loaded into the IDR and the word pointer would be sent to point to the second word of the double word and the ICACHE pointer remains the same. When the word pointer points to the second word, only one word can be accessed from the ICACHE and loaded into the instruction decode register.</p><p>The decode logic utilizes predecode logic 154 (FIG. 103) which is used to select the location in one of the two sets of decode PROMs 140 and 141. As mentioned above, one set of PROMs 140 holds a basic set of instructions (e.g., NOVA/ECLIPSE instructions) while the second set of PROMs 141 holds the extended instructions (e.g., EAGLE instructions). The decoding process for the basic set of decode PROMs 140 is performed in two stages, the first level being performed in the predecode logic 154 at the output of the shifter which is used to place the basic macro-instructions into the correct form so that the decode logic 140 can decode the opcode and be ready with the displacement information in the correct form and sequence. Such logic is shown in more detailed in FIG. 122. The instructions for the extended set are already in the desired form and need not be predecoded before being supplied to the decode PROMs 141. In either case each incoming macro-instruction maps into at least one location of a selected one of the decode PROMs 140 or 141 to produce the required opcode descriptors and the required starting micro-address for supply to the micro-sequencer.</p><p>The decision to select the output of decode PROM 140 (e.g., NOVA/ECLIPSE) or decode PROM 141 (e.g. EAGLE) is determined by examining selected bits (e.g., bits .0., 12-15 as discussed above) of IDR A. As described above, the selection of the decode PROM is not determined by a separately designated \"mode\" bit as in previous systems, which prior process causes the decode operation to be mutually exclusive. In contrast, the present system in selecting the appropriate decode operation performs such operation on an instruction by instruction basis since each instruction inherently carries with it the information required to determine such decode selection.</p><p>Specific logic circuitry for implementing the block diagram of the instruction processor to provide the operation discussed above with reference to FIGS. 101-106 is shown in FIGS. 107-136. ICACHE data store 130 and the ICACHE data store address input logic are shown in FIGS. 107 and 108, respectively, while CPM register 134 supplying cache block words from memory being shown in FIG. 109 and 109A. ICACHE tag store 131 is also depicted in FIG. 109B and 109C and ICACHE validity store 132, together with the validity store address input is shown in FIGS. 110 and 111, respectively. Comparator 133 and logic for providing the SET IDR VLD signal are shown in FIG. 112.</p><p>FIG. 113 shows IDR shifter 143, the IDR shifter control logic 137 being shown in FIG. 114. The instruction decode register (IDR) unit 142 is depicted in FIG. 115 and include IDR sections A, B and C as shown.</p><p>With reference to the ICACHE logic circuitry the ICACHE pointer (ICP) logic 150 and the ICP logical address driver logic of FIG. 106 is shown in more detail in FIGS. 116 and 117, respectively. The ICACHE pointer pre-fetch request control logic 151 and the physical ICP translation register 152 of FIG. 105 is depicted in more detail in FIGS. 118 and 119, respectively. Other general ICACHE control logic is further depicted in FIG. 120.</p><p>The driver logic which provides inputs FASA.0.-15 from the CPD but to IDR A as shown in FIG. 103 is depicted in FIG. 121, while the instruction pre-decode logic and control therefor is shown in FIG. 122. Decode PROMS 140 and 141 which effectively include the ST\u03bcAD register 144, together with the IP status logic 138 are shown in FIG. 123. The starting microaddress control logic 145 is depicted in detail in FIG. 124.</p><p>With reference to the displacement and program counter portion of the instruction processor, the displacement logic 146 is shown in FIG. 125, the displacement multiplexer associated therewith being depicted in FIG. 126. The sign extend (SEX) logic is shown in FIG. 127, while the zero/ones extend logic is shown in FIG. 128. FIG. 129 shows the displacement increment buffer of FIG. 104 while the displacement latch and drivers 153 are depicted in FIG. 130. FIG. 131 shows program counter register 147 and the CPD bus driver of FIG. 104, while adder 148 and the PC+DISP latch and driver units 149 are shown in FIGS. 132 and 133, respectively. Program counter clock logic is depicted in FIG. 134.</p><p>General instruction processor timing and control logic circuitry is shown in FIG. 135, while the system cache interface logic required for the instruction processor 12 to interface the system cache 17 is shown in FIG. 136.</p><h4>Micro-sequencer</h4><p>The primary function of the micro-sequencer unit is to generate micro-instructions from the starting micro-address which is supplied to a random-access-memory (RAM) storage unit on the micro-sequencer board. An overall block diagram of the micro-sequencer board for the particular embodiment of the system of the invention described herein is shown in FIGS. 137-138. As can be seen, the RAM storage unit is identified as the micro-control store unit 170 and is capable of storing up to 4-K 80 bit (79 bits plus 1 parity bit) micro instructions and is sufficient to store all of the micro-instructions required for the system being described. The micro-instructions can be appropriately loaded into store unit 170 initially (i.e., prior to the use of the system) through a suitable console via appropriate console interface logic unit 171. Once the entire micro-instruction set has been loaded into the micro-control store unit 170, the console interface logic need no longer be used, unless a micro-instruction is changed or additional micro-instructions are to be stored. Addresses for the micro-instructions are supplied at the RA input to the micro-sequencer board.</p><p>Once the entire micro-instruction set has been loaded into the micro-control store 170, the system is ready for performing the micro-instructions, as determined by the instruction processor unit 12 which, as discussed above, supplies the starting micro-address (ST\u03bcAD) for a micro-instruction routine. As can be seen in FIG. 137, the starting micro-address (ST\u03bcAD) is supplied via buffer 172 and AND circuitry 173 to the address input of the micro-control store 170. The starting micro-address selects the starting micro-instruction at the appropriate location in the micro-control store and supplies the control signals associated with said instruction via buffer 174 to the appropriate locations within the overall data processing system which are involved in the operations required for such instruction in a manner similar to that which would occur in supplying instructions to any data processing system.</p><p>The micro-sequencer must then determine the next address required for the next sequential micro-instruction (if any) via appropriate decoding of the \"next address control\" field (NAC.0.-19) of the current micro-instruction. This field in the particular embodiment described is a 20-bit field of the 80-bit micro-instruction obtained from the micro-control store. The NAC field is suitably decoded by the NAC decode logic 175 to provide the necessary control signals (some of which are identified) required to obtain the next micro-address. The decoding process can in one mode be a conditional one, i.e., wherein the NAC field decoding is conditioned upon one of a plurality of possible conditions which must be appropriately tested to determine which, if any, condition is TRUE. In the particular embodiment described, for example, there are eight test signals (TEST .0.-7) each test representing 8 conditions, for a total of 64 conditions which can be tested. Alternatively, in another mode the selection of the next micro-address may not be conditioned on any of the 64 conditions involved. After appropriate testing the address is selected from one of four sources, as determined by the decoding and condition test logic 182, for supply to the micro-control store 170 via ADDR multiplexer unit 176. Decoding and condition test logic 182 is shown in further detail in FIG. 138.</p><p>Thus, the address multiplexer output can be selected from the next sequential program counter address (\u03bcPC 4-15) which represents the previous micro-address incremented by one as obtained from the (\u03bcPC +1) unit 177 and increment logic 178 which accepts the previous micro-instruction (RA 4-15), increments it by one and supplies it to an input of the address multiplexer unit 176.</p><p>Alternatively, the next micro-address may be obtained from a temporary storage of a plurality of micro-addresses for a particular micro-code routine which addresses have been stored in a stack RAM storage unit 179, the next address being supplied directly as the address at the top of the stack (TOS 4-15) via a top of the stack (TOS) register 180. Alternatively, the address at the top of the stack may already have been accessed (popped) from the stack and saved in a previous operation in the Save TOS register 181 (particularly used in restoring the overall context after an interrupt process) so that the next micro-instruction address may alternatively be obtained from the top of the stack data (STOS 4-15) which has previously been saved in the STOS register.</p><p>A further source of the next micro-address for the address multiplexer may be an absolute address from decode and condition test logic 182, shown more specifically in FIG. 138, which address is specified by the micro-instruction word itself or an absolute address which may be identified by bits from another source external to the micro-sequencer board which other sources dispatch such address to the micro-sequencer, i.e., from the address translation unit (ATU) or from the arithmetic logic unit (ALU) selected bits of which can be suitably concatenated with absolute address bits from the current micro-instruction to form the next micro-address. As see in FIG. 138, the latter bits may be received via suitable registers 183 and 184 (see FIG. 138) from the ATU at the ATU dispatch (ATUD) register 183 or from the ALU on the CPD bus at the CPD register 184. Thus, as seen best in FIG. 138, such bits (ATUD 13-14 and CPD 20-31) can be concatenated with bits from the micro-instruction itself, identified by NAC bits .0.-2, 8-19, to form five possible micro-addresses by concatenation logic unit 185. One of five concatenated addresses is capable of being selected at Dispatch Multiplexer unit 186 and thereupon supplied to Address Multiplexer 176.</p><p>In order to obtain the desired stack data for the next possible micro-address (TOS 4-15 or STOS 4-15) suitable stack pointer logic 187 and stack control logic 188 are used with the stack RAM unit 179. The stack addresses which are supplied via stack pointer logic 187 determine the locations of the sequence of micro-instruction addresses which are required for micro-routines, which sequence has been previously supplied to the stack via stack multiplexer unit 189, the inputs of which are obtained either as absolute addresses (AA 4-15) from the micro-instruction which is currently being processed or as addressed obtained from the micro-program counter 177 (\u03bcPC+1), from a dispatched ALU source (CPD 20-31) via the CPD bus, or from an address which has been previously saved (AD 4-15) in save register 190.</p><p>When a micro-code routine which has been stored in the stack RAM is completed, the stack is then empty and a STKMT signal from the stack pointer logic 187 produces an appropriate IPOP OUT signal at the output of IPOP detection and latch logic 191 for supply to the instruction processor to indicate that a new starting micro-address (ST\u03bcAD) is required to provide the next micro-instruction or sequence thereof.</p><p>As a simple example of the operation of the micro-sequencer to illustrate the same, in a conditional jump instruction (CJMP), let it be assumed that the address of the next micro-instruction is to be supplied either as an absolute address from the dispatch multiplexer to which the micro-program must jump if the condition is TRUE or as the next sequential program address from the micro-program counter (PC+1) if the condition is not TRUE. For example, if the present micro-address is at a selected location of the \u03bc-control store 170 (e.g. location \"100\" ) the next micro-address is to be either the location signified by the next sequential program counter address (e.g., location \"101\" ) if the condition is not TRUE, or a jump to specified absolute address (e.g., at location \"500\" ) if the condition is TRUE. In order for the micro-sequencer to determine which of the two locations is be be selected, i.e., the absolute address (AAD 4-15) or the micro-program counter address (\u03bcPC 4-15), the condition must be tested to determine if it is \"TRUE\".</p><p>If testing of the condition provides a TRUE at the condition out logic 192, the absolute address (AAD 4-15) will be selected as the correct address from address multiplexer 176, while if the condition is not TRUE, the next micro-program counter address (\u03bcPC 4-15) will be selected. The testing logic 198 is shown in FIG. 138.</p><p>Specific logic circuitry for implementing the micro-sequencer unit 13 as discussed above and shown in the block diagrams of FIGS. 137 and 138 are shown in FIGS. 139-153. Stack logic circuits, including the stack ram 179, the stack multiplexer 189, the stack pointer unit 187 and the top-of-stack unit 180, are specifically shown in FIG. 139. The save-top-of-stack unit 181 is shown in FIG. 140. Address multiplexer 176 is depicted in FIG. 141, while the address save register is shown in FIG. 142 and the address logic 173 for supplying addresses to the microcontrol store 170 is shown in FIG. 143. FIG. 144 depicts the starting microaddress (ST\u03bcAD) driver unit 172. The imcremented microprogram counter (\u03bcPC+1) unit 177 and increment unit 178 are shown in FIG. 145.</p><p>Microcontrol store 170 is specifically depicted in FIG. 146* and the next address control (NAC) decode logic circuitry 175 is specifically shown in FIG. 147. Parity logic is shown in FIG. 148.</p><!--Greenbook footnotes--><p>With reference to the decoding and condition test logic circuitry 182, shown particularly in FIG. 138, specific logic circuitry for implementing such circuitry is shown in FIGS. 149-153. Thus, concatenation logic 185 and dispatch multiplexer 186 are depicted in FIG. 149, CPD multiplexer 197 is shown in FIG. 150, 6-bit counter 196 is shown in FIG. 151, 8 flags unit 193 is shown in FIG. 152, and test .0. and test 1 multiplexers 194 together with condition multiplexer 195 and the condition output unit 192 are all shown in FIG. 153.</p><h4>Arithmetic Logic Unit</h4><p>Before discussing in more detail the format of the microinstruction word, it is helpful to discuss FIG. 153 which shows a block diagram of a typical arithmetic logic unit generally having a configuration known to those in the art. As can be seen therein, the ALU unit 200, which performs the arithmetic and logical operations, has two inputs, identified as inputs R and S, which are supplied from a pair of multiplexers 201 and 202, respectively. The inputs to multiplexer 202 are obtained from the A and B outputs of a register file 203. A third input may be obtained from a source which supplies zeros to the multiplexer at all 31 bit positions (identified as the \".0.\" input) and a fourth input may be obtained from Q register 204.</p><p>Register file 203 contains 16 and 32 bit registers and includes four fixed point registers (ACC.0.-3), four floating point registers (FPAC.0.-3), and eight general registers (GR.0.-7). The selection of the appropriate registers for supplying the A and B inputs to ALU 200 is determined by the AREG.0.-3 and BREG.0.-3 bits of the micro-instruction field, as discussed in more detail below. The inputs to multiplexer 201 are obtained from the A output of the register file, from the D-bus 205 or from an all zeros input, as discussed with reference to multiplexer 202. The output of ALU 200 is supplied to a multiplexer 206 which selects either the output from ALU 200 or an output directly supplied from the A terminal of register file 203. The output of multiplexer 206 can be supplied to the logical address bus if the calculation is an address calculation, to the register file 203 for writing back into a selected register therein, to Q register 204 or to a plurality of other units on the arithmetic logic board, significant exemplary ones of which are identified as shifter units 207, a data store register 208 or directly to the D-bus 205 or to the memory data bus. The shifter outputs are supplied to the D-bus, while the data store register 208 supplies data to the CPD bus or to the D-bus via CPD register 209. Data supplied to the D-bus can then be used in subsequent arithmetic or logic operations via multiplexer 201. Other sources of the system may also supply data to D-bus 205, if desired. The general configuration of the arithmetic logic unit board 11, as shown in FIG. 154, is helpful in understanding the micro-instructions which are discussed below.</p><h4>Micro-instruction Format</h4><p>As discussed above with reference to the micro-sequencer unit 13, the micro-control store 170 thereof supplies a micro-instruction of 80 bits, the format thereof being depicted below. ##STR6##</p><p>The overall format comprises eighteen fields, one field of which has five bits available as reserve bits for future use. The seventeen fields which are utilized are described below.</p><p>The Next Address Control Field (NAC.0.-19)</p><p>As discussed above with reference to the micro-sequencer structure and operation, the first 20 bits of the micro-instruction format comprise the field for controlling the selection of the address for the next micro-instruction which address is either a \"conditional\" address, i.e. an address the selection of which is dependent on whether a specified condition which is tested is either true or false, or an \"unconditional\" address, i.e., an address which is selected independently of any conditions.</p><p>The NAC field of the micro-instruction for selecting a conditional address carries with it a 6 bit test field which identifies which of up to 64 conditions must be tested to determine whether a specified condition is true or false. The basic format of the NAC field for selecting a conditional address is shown below: ##STR7##</p><p>The conditions which can be tested may relate to conditions with respect to operations of the arithmetic logic unit, the address translation unit, the instruction processor, the micro-sequencer unit itself or input/output (I/O) conditions. As an example of typical conditions, Appendix C lists 53 conditions which can be tested in the particular system design described herein, involving tests relevant to the ALU, ATU, IP and micro-sequencer units, as well as certain I/O tests.</p><p>Various types of conditional addresses may be selected as discussed below, it being helpful to consider the following discussion in conjunction with FIGS. 33 and 34 showing broad block designs of the micro-sequencer logic.</p><p>A first conditional address may be a conditional absolute address, i.e. an address which uses absolute address bits AA 4-15 appropriately selected and supplied by dispatch multiplexer 186 to the address multiplexer 176, as seen in FIG. 4.</p><p>The format for such conditional absolute address utilizes the same format shown above for the mode bits, polarity bit and test bits, with the 10 absolute address bits being extended to a full 12 bits by concatenating the most significant bits of the current micro-program counter as the first two bits thereof (sometimes termed the \"page bits\"). The conditional absolute address may be utilized in 5 different modes as set forth in Appendix D (see \"Absolute Address Conditional\" therein). An example of one mode such as a \"Conditional Jump Code\" (CJMP) can be illustratively summarized below.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nMode  MneM.   Explanation                                                 \n                         True Action                                      \n                                   False Action                           \n______________________________________                                    \n000   CJMP    Conditional                                                 \n                         PC \u2190 AA(10)                                 \n                                   PC \u2190 PC + 1                       \n              Jump                                                        \n______________________________________                                    \n</pre><p>For such conditional jump mode, if the specified test condition is true the 10 absolute address bits concatenated with the 2 page bits forms the absolute address bits AA 4-15, which address is then selected at the address multiplexer 176 (FIGS. 33 and 34). If such specified condition is false, the address which is selected is the current program counter address incremented by 1 (i.e. \u03bcPC+1). Other modes for an \"absolute address conditional\" format are shown in Appendix D.</p><p>Another conditional address is a conditional dispatch address, wherein a portion of the address bits are obtained (or dispatched) from sources external to the micro-sequencer unit (such as the arithmetic logic unit or the address translation unit, for example) which dispatch bits can be concatenated with some or all first eight absolute address bits (AA.0.-7) as shown in FIG. 34. For such conditional dispatched addresses the following format is used: ##STR8##</p><p>The source from which the dispatch bits are obtained are identified by the two DSRC bits for 4 different source identifications.</p><p>Thus, the address may be formed by direct replacement of the lower 8 bits of the formed absolute address with the lower 8  bits of the CPD bus as shown below. ##STR9##</p><p>Alternatively, the address may be formed by direct replacement of the lower 4 bits of the formed absolute address with the lower 4 bits of the CPD bus, as shown below: ##STR10##</p><p>As further alternative, the address may be formed by direct replacement of the lower 4 bits of the formed absolute address with a different 4 bits of the CPD bus as shown below: ##STR11##</p><p>And as a final alternative, the address can be formed by direct replacement of the lower 3 bits of the formed absolute address with 2 bits from the address translation unit validity dispatch, with a zero in the least significant bit position, as shown below: ##STR12##</p><p>Certain addresses may require the use either of the incremented program counter address or the top of the stack address (with the top of the stack being appropriately popped, or removed, when the address is used) and for such purposes the lower 12 bits (NAC-19) need not be involved in the address generation process. Accordingly, such 8 bits are available for other purposes as desired. The format therefor is shown below: ##STR13## An explanation of such three special condition address selections are shown in more detail in Appendix D, identified as LCNT, CPOP and LOOP.</p><p>Certain addresses may be selected in conjunction with the setting of the 8 flags that are involved and such flag control commands can be identified by the NAC field in accordance with the following format: ##STR14## As seen in Appendix D (see Flag Controls set forth therein) such instructions can be divided into two sets each set being identified by the POP bit and each set having four different instructions identified by the two SET bits. Each instruction involves the setting of two flags, each flag being set in accordance with the CNTL1 or CNTL2 fields as follows:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nCNTL1 or                                                                  \nCNTL2               Action                                                \n______________________________________                                    \n00                  no change                                             \n01                  set it FALSE                                          \n10                  set it TRUE                                           \n11                  Toggle it                                             \n______________________________________                                    \n</pre><p>In each of the above flag control cases if the test condition which is specified is determined to be \"True\" the incremented micro-program counter address is used (\u03bcPC+1) while if the condition is \"false\" the top of the stack address is utilized and the stack is appropriately popped. As mentioned above, a summary of the flag controls is set forth in Appendix D.</p><p>Two of the instructions of the NAC field allow the conditional use of the stack without popping it (as opposed to the use and popping thereof discussed above) in accordance with the following format: ##STR15## Two instructions are involved, flag control being provided for either the set of flags .0. and 1 or the set of flags 2 and 3. A summary of such instructions, identified as the SPLIT instructions, is shown in Appendix D. As can be seen therein, if the condition is \"false\" the top of the stack address is utilized but the address remains at the top of the stack (i.e. the top of the stack is not popped). The final conditional instruction is a context restore instruction. Such instruction may be used, for example, after a fault routine has been implemented and it is desired to restore the machine to its previous state. In accordance therewith, not only is the machine state restored but a decision is made as to the next micro-address which should be utilized, depending on whether the condition which is tested is true or false. The context restore instruction format is shown below:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n ##STR16##                                                                \nA summary of the two instructions involved is shown in Appendix D         \n</pre><p>In addition to the conditional address instructions discussed above, in a particular embodiment of the system discussed, there are also unconditional address instructions (one particular embodiment utilizing eight unconditional instructions are set forth in Appendix D identified as Unconditional Instructions). In accordance with the format thereof there are no conditions to be tested so that for each mode of operation only a single action is specified and no selected choice need be made.</p><p>A summary of the unconditional address instructions, which can be divided into unconditional instructions utilizing the 12-bit absolute address or unconditional instructions utilizing the combinations of certain absolute address bits and dispatch source bits (Unconditional Dispatches) is shown in Appendix D.</p><p>AREG, BREG Fields</p><p>The 8 bits in these two fields identify which register of the register file in the arithmetic logic unit is to be used to provide the A and B inputs of the arithmetic logic unit 200. Thus the register file is capable of selecting one of sixteen registers, namely, the accumulators AC .0.-3, the floating point registers FPAC .0.-3 or other general registers GR .0.-7 in accordance with the following select codes.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n       Mnem   Value                                                       \n______________________________________                                    \n       AC0    0                                                           \n       AC1    1                                                           \n       AC2    2                                                           \n       AC3    3                                                           \n       FPAC0  4                                                           \n       FPAC1  5                                                           \n       FPAC2  6                                                           \n       FPAC3  7                                                           \n       GR0    8                                                           \n       GR1    9                                                           \n       GR2    A                                                           \n       GR3    B                                                           \n       GR4    C                                                           \n       GR5    D                                                           \n        ACSR  E                                                           \n        ACDR  F                                                           \n______________________________________                                    \n</pre><p>In the above table the coded value is in hexadecimal notation and in the specific case of coding ACSR or ACDR, the register file control comes from a register that specifies a source accumulator or from a register that specifies a destination accumulator. When the source accumulator ACSR .0.-3 or the destination accumulator ACDR .0.-3 equals hex E the general register GR6 will be selected. When ACSR .0.-3 or ACDR .0.-3 equal hex F then the general register GR7 will be selected.</p><p>The Control Store Mode</p><p>The control store mode 4-bit field defines the functionality of six of the other micro-instruction fields, namely, the ALUS, ALUOP, ALUD, DIST. CRYIN, and RAND fields. The following table summarizes the 16 control modes for the control store mode field.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->__________________________________________________________________________\n         Half-cycle 1 Half-cycle 2 DIST     RAND                          \nMnem Value                                                                \n         ALUS                                                             \n             ALUOP                                                        \n                  ALUD                                                    \n                      ALUS                                                \n                          ALUOP                                           \n                               ALUD                                       \n                                   Type                                   \n                                       CRYIN                              \n                                            Type                          \n__________________________________________________________________________\nSMATH                                                                     \n     0   uI  uI   #   DZ  OR   uI  Math                                   \n                                       Type0                              \n                                            Math                          \nSFIXP                                                                     \n     1   uI  uI   #   DZ  OR   uI  Gen Type1                              \n                                            Fixp                          \nSGEN 2   uI  uI   #   DZ  OR   uI  Gen Type0                              \n                                            Gen                           \nSATU 3   uI  uI   #   DZ  OR   uI  Gen Type0                              \n                                            Atu                           \nFMATH                                                                     \n     4   uI  uI   #   uI  uI   uI  Math                                   \n                                       Type0                              \n                                            Math                          \nFFIXP                                                                     \n     5   uI  uI   #   uI  uI   uI  Gen Type1                              \n                                            Fixp                          \nFGEN 6   uI  uI   #   uI  uI   uI  Gen Type0                              \n                                            Gen                           \nFATU 7   uI  uI   #   uI  uI   uI  Gen Type0                              \n                                            Atu                           \nMPY  8            #            #   Math                                   \n                                       Type2                              \n                                            Math                          \nDIV  9   uI       uI  uI       uI  Math                                   \n                                       Type3                              \n                                            Math                          \nBOUT A   uI  uI   #   ZB  OR   uI  Gen Type0                              \n                                            Gen                           \nNORM B   uI  uI   #   DZ  OR   uI  Math                                   \n                                       Type0                              \n                                            Math                          \nQDEC C   ZQ  SUB  GREG                                                    \n                      uI  uI   uI  Gen *Type0                             \n                                            Gen                           \nQINC D   ZQ  ADD  GREG                                                    \n                      uI  uI   uI  Gen *Type0                             \n                                            Gen                           \nQADD E   DQ  ADD  GREG                                                    \n                      uI  uI   uI  Gen *Type0                             \n                                            Gen                           \nPRESC                                                                     \n     F       uI   #   DZ  OR   uI  Math                                   \n                                       Type0                              \n                                            Math                          \n__________________________________________________________________________\n In the above table the following abbreviations are used:                 \n uI  Represents the uorder from the appropriate field of the specified    \n uinstruction.                                                            \n # - No clock takes place.                                                \n   - The uorder will deter to a predecoded or \"Forced\" value. See notes   \n below for further information.                                           \n *The CRYIN is forced to a zero the first half cycle in modes QDEC and    \n QADD, and to a one during the first half of mode QINC.                   \n</pre><p>As can be seen, operations can occur in either half of the operating time cycle of the system, for example, operations with respect to the CPU occurring in one-half of the cycle and operations with respect to I/O devices occurring in the other half of the cycle. The above table shows that the control modes for the control store mode field must be defined in accordance with the half-cycle which is occurring. Thus certain fields in the overall micro-instruction format will change depending on which half of the cycle is occurring and the CSM field defines how each of such fields is affected during each of the half-cycles involved.</p><p>The ALU source inputs (R and S), the ALU operation and the ALU destination as determined by their respective fields are discussed below, the above table providing a definition for the functionality thereof as explained by the above noted abbreviations. The source for the D-bus (see ALU in FIG. 53) for the first half cycle is discussed below under the D1ST field. The CRYIN definition determines the type of usage for the carry input select field as discussed below and the random field (RAND) type is also defined as discussed below with respect to such field. A more detailed description of the multiply (MPY), divide (DIV), prescaled mantissa (PRESC) and NORM modes is shown in Appendix E.</p><p>The D1ST Field</p><p>This 2-bit field defines the source for the 31 bits which are placed on the D-bus 205 of the arithmetic logic unit (see FIG. 53) during the first half cycle. The functionality of this field is dependent on what is coded in the CSM field as discussed above. For the two types (identified as MATH or GEN) the following sources are defined depending on the value of the D1ST field.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nType Math                                                                 \nMnem     Value     Description                                            \n______________________________________                                    \nMREG     0         D &lt;0-31&gt; = MREG &lt;0-31&gt;                                 \nMACC     1         D &lt;0-31&gt; = MACC &lt;0-31&gt;                                 \nCPDR     2         D &lt;0-31&gt; = CPDR &lt;0-31&gt;                                 \nAAR      3         D &lt;0-23&gt; = zero                                        \n                   D &lt;24-31&gt; = AAR &lt;24-31&gt;                                \n______________________________________                                    \n</pre><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nType Gen                                                                  \nMnem     Value     Description                                            \n______________________________________                                    \nMREG     0         D &lt;0-31&gt; = MREG &lt;0-31&gt;                                 \nCPDR     1         D &lt;0-31&gt; = CPD &lt;0-31&gt;                                  \nCPDR     2         D &lt;0-31&gt; = CPDR &lt;0-31&gt;                                 \nAAR      3         D &lt;0-23&gt; = zero                                        \n                   D &lt;24-31&gt; = AAR &lt;24-31&gt;                                \n______________________________________                                    \n</pre><p>D2ND Field</p><p>The four bits for this field define the source of the 31 bits to be placed on the D-bus during the second half cycle in accordance with the following definitions.</p><p>D&lt;0-31&gt; source during second half cycle.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nMnem   Value     Description                                              \n______________________________________                                    \n       0         Unassigned                                               \nCPDB   1         D &lt;0-31&gt; = CPDB &lt;0-31&gt;                                   \nCPDR   2         D &lt;0-31&gt; = CPDR &lt;0-31&gt;                                   \nAAR    3         D &lt;0-23&gt; = zero                                          \n                 D &lt;24-31&gt; = AAR &lt;24-31&gt;                                  \nCREG   4         D &lt;0-31&gt; = MREG &lt;0-31&gt;                                   \nMACC   5         D &lt;0-31&gt; = MACC &lt;0-31&gt;                                   \n       6         Unassigned                                               \n       7         Unassigned                                               \nNSHR   8         Right Nipple shifts. See SHFT field                      \nNSHL   9         Left Nipple shifts. See SHFT field                       \nPASS   A         D &lt;0-31&gt; = TLCH &lt;0-31&gt;                                   \n       B         Unassigned                                               \nPMD    C         Processor memory data. See not below.                    \n       D         Unassigned                                               \nASR    E         D &lt;0-15&gt; = ASR &lt;0-15&gt;                                    \n       F         Unassigned                                               \n______________________________________                                    \n</pre><p>The SHFT Field</p><p>The four bits of the SHFT field define two basic functions, namely, a control of the inputs for bit shifts into the Q-register or the B-register of the arithmetic logic unit (FIG. 53) and a control of a 4-bit shift (a \"nibble\" shift) at the Shifter 207 of the ALU. The latter shift is controlled by the D2ND field to occur only when such field is coded to product a right nibble shift (NSHR) or a left nibble shift (NSHL) as indicated above. The bit shift occurs with respect either to the data that is present in the Q-register or to the data which is being placed into the B-register, only if the D2ND field contains something other than a NSHR or NSHL code. The charts in Appendix F explain more completely how the nibble shift and bit shift hardware are controlled by the SHIFT field.</p><p>The ALUS Field, The ALUOP Field and The ALUD Field</p><p>The 3 bits of the ALUS field determines which bus is supplied to the R and S input of the arithmetic logic circuit 200 (FIG. 53) in accordance with the following chart.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nALUS FIELD      (R,S)                                                     \n______________________________________                                    \nAQ              0                                                         \nAB              1                                                         \nZQ              2                                                         \nZB              3                                                         \nZA              4                                                         \nDA              5                                                         \nDQ              6                                                         \nDZ              7                                                         \n______________________________________                                    \n</pre><p>In the above chart, A represents the A output of the register file, B represents the B output of the register file, Q represents the Q output from the Q register, Z is the all zeros input and D is the D-bus in FIG. 53. Thus, for an ALUS field of zero, for example, the R input is from the Q register, and so forth.</p><p>The three bits of the ALUOP field define the operation which is to be performed by the arithmetic logic circuit 200 in accordance with the following chart.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nALUOP FIELD                                                               \n______________________________________                                    \nADD           0           (R + S)                                         \nSUB           1           (S - R)                                         \nRSB           2           (R - S)                                         \nOR            3           (R or S)                                        \nAND           4           (R * S)                                         \nANC           5           (R' * S)                                        \nXOR           6           (R xor S)                                       \nSNR           7           (R xnr S)'                                      \n______________________________________                                    \n</pre><p>The 3 bits of the ALUD field defines the destination for the output of the arithmetic logic circuit 200 (i.e. where the result of the arithmetic or logical operation will be placed) in accordance with the following chart.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->__________________________________________________________________________\nALUD FIELD                                                                \nMnem Value                                                                \n         Description                                                      \n__________________________________________________________________________\nNLD  0   No load; Y &lt;0-31&gt; = ALU &lt;0-31&gt;                                   \nGREG 1   Load GREG only; Y &lt;0-31&gt; = ALU &lt;0-31&gt;                            \nBREG 2   Load BREG only; Y &lt;0-31&gt; = ALU &lt;0-31&gt;                            \nAOUT 3   Load BREG only; Y &lt;0-31&gt; = AREG &lt;0-31&gt;                           \n         If FLAG0 = 0, Y &lt;0-15&gt; = ALU &lt;0-31&gt;, Y &lt;16-31&gt; = AREG &lt;16-31&gt;    \nRSHB 4   Load BREG with ALU shifted right one bit;                        \n         LINK register: = ALU31; Y &lt;0-31&gt; = ALU &lt;0-31&gt;                    \nRSQB 5   Load BREG with ALU shifted right one bit;                        \n         Shift QREG right; Y &lt;0-31&gt; = ALU &lt;0-31&gt;                          \n         LINK register: = ALU31                                           \nLSHB 6   Load BREG with ALU shifted left one bit;                         \n         Y &lt;0-31&gt; = ALU &lt;0-31&gt;                                            \n         LINK gets ALU16, ALUO for FLAG0 = 0,1 respectively.              \nLSQR 7   Load BREG with ALU shifted left one bit;                         \n         Shift QREG left; Y &lt;0-31&gt; = ALU &lt;0-31&gt;                           \n         LINK gets ALU16, ALUO for FLAG0 = 0,1 repsectively.              \n__________________________________________________________________________\n</pre><p>The CRYINS Field</p><p>This field represents the arithmetic logic unit carry input select field and determines what kind of carry is used. There are 4 types of usage for this field (identified as Types .0.-3), the use thereof being governed by the CSM field discussed above and the RAND field discussed below. The charts in Appendix G for each type summarize the determinations to be made by the CRYINS field.</p><p>The Rand Field</p><p>The 10-bit random field is a multi-functional field and is controlled as discussed above by the CSM field. There are 4 types of usage thereof, identified as MATH, FIXP, GEN, and ATU.</p><p>The MATH type of usage has the following format: ##STR17## which includes 1 bit for controlling the rounding off of the floating point computation and the 4 FPOP bits for defining the floating point operation with regard to the exponent, multiplication and truncation utilized. The remaining 5 bits are available for other arithmetic logic unit operations, if desired. The MATH type usage for the random field is specified in the summary set forth in Appendix H.</p><p>The fixed point type usage (FIXP) has the following format: ##STR18##</p><p>As can be seen the first bit of the field in this type of usage combines with the CRYINS field Type 1 to form certain micro-orders as set forth below:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n                         CEST                                             \n                         (RAND                                            \nCRYINS CRYINS    CEXT    &lt;0&gt;)                                             \nMnem   Value     Mnem    Value   Description                              \n______________________________________                                    \nZ      0         N       0       CRYIN = 0                                \nH      1         N       0       CRYIN = 0                                \nZ,C    0         Carry   1       CRYIN = CARRY                            \nH,B    1         Carry   1       CRYIN = CARRY                            \n______________________________________                                    \n</pre><p>The remaining bits relate to miscellaneous operations, the first 4 miscellaneous bits (MISC 1) relating to ALU loading control and the second 5 miscellaneous bits (MISC 2) relating to various random operations with respect to carry, overflow and status operations, and set forth in Appendix I.</p><p>The general type of usage (GEN) utilizes the following format: ##STR19##</p><p>The first 4 bits (REGS) deal with general source and destination accumulator operations set forth in Appendix J. The 2 SPAR scratch pad bits deal with operations set forth in Appendix J. The 4 SPAD scratch pad bits deal with various scratch pad operations specified in Appendix J.</p><p>The final usage type for the random field is identified as ATU usage dealing with various address translation unit operations and has the following format. ##STR20## The first 5 bits (ATU 0) deal with the address translation unit operations, the next 2 ATU bits (ATU 1) define further ATU operations, and the final 3 ATU bits (ATU 2) define general operations, all as set forth in Appendix K.</p><p>The LAC Field</p><p>This 2 bit logical address control field controls the data that will be placed on the logical address bus, i.e. the field specifies the source for LA bits 1-31, in accordance with the following chart:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->__________________________________________________________________________\nSpecifies the source of LA &lt;1-31&gt;.                                        \nMnem                                                                      \n    Value                                                                 \n        Description                                                       \n__________________________________________________________________________\nDSN 0   LA &lt;0-31&gt;: = WDLCH &lt;0-31&gt; or BYLCH &lt;0-31&gt;                         \nDS  1   LA &lt;0-31&gt; &amp; LAR &lt;0-31&gt;: = WDLCH &lt;0-31&gt; or BYLCH &lt;0-31&gt;            \nSP  2   LA = Scratch Pad; LAR: = Scratch Pad                              \nIP  3   LA = PC + DISP; LAR = PC + DISP                                   \n        exception: when ICAT coded in ATUO,                               \n        LA = ICP; LAR = ICP                                               \n__________________________________________________________________________\n</pre><p>The CPDS Field</p><p>This 5-bit CPD source select field determines what is placed on the CPD bus, i.e. the source for the CPD 0-31 bits. This field also controls the loading of the CPDR register on the arithmetic logic unit.</p><p>An NCPDR random field (see GEN Type random field) overrides the loading of the CPDR register and prevents such loading. The source select and other control operations for the CPDR field are specified in accordance with the chart shown in Appendix L.</p><p>The MEMS Field</p><p>This 3-bit field defines the type of operating cycle which will be started for the memory (e.g. read cycle, a write cycle, a read-modify-write cycle) in accordance with the following chart:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n      Val-                                                                \nMnem  ue     Description                                                  \n______________________________________                                    \nNOP   0                                                                   \nRW    1      Start a read cycle for a word.                               \nRD    2      Start a read cycle for a double-word.                        \nRB    3      Start a read cycle for a byte.                               \nS     4      Start per MEMS field of previous non LAT start.              \n             During EFA routines, the IP supplies the control.            \nWW    5      Start a write or rmod cycle for a word.                      \nWD    6      Start a write or rmod cycle for a double word.               \n             See below.                                                   \nWB    7      Start a write or rmod cycle for a byte.                      \n______________________________________                                    \n</pre><p>The MEMC Field</p><p>This 2-bit field defines the completion of a memory operation in accordance with the following chart:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nMnem  Value   Description                                                 \n______________________________________                                    \nN     0                                                                   \nR     1       Read or Rmod operation.                                     \nW     2       Write operation. PMD &lt;0-31&gt; = DS &lt;0-31&gt;                     \nA     3       Abort operation                                             \n______________________________________                                    \n</pre><p>The UPAR Field</p><p>This single bit field contains the odd parity of the micro-word. If an even parity error is detected the overall operation will stop at the current micro-location incremented by +1.</p><p>The above discussion summarizes each of the fields of the micro-instruction format in accordance with the invention. It is helpful also to describe below the usage of the 8 flags which can be defined.</p><p>Flag 0 is the width flag and defines either a narrow (16 bit) arithmetic logic unit operation or a wide (32 bit) arithmetic logic unit operation. Flag 1 is an address flag and defines whether the logical address is to be driven as a basic instruction address (e.g. for NOVA/ECLIPSE operation) in which case only bits 17-31 of the logical address are driven by the logical address latch on the arithmetic logic unit, the address translation unit or the instruction processor unit. If the flag indicates an instruction expended address than all bits 0-31 of the extended logical address are so driven.</p><p>Flags 2-7 are general purpose flags and can be used as desired by the general micro-code in sequencing. For example, flag 4 has been used as a \"shift indirect\" flag and, when NSH is coded in the SHFT field of the micro-instruction format (see the discussion thereof above), a shift is made either to the left or to the right depending on the setting of flag 4. Further, flag 5 has been used to define whether or not a floating point operation requires a double precision operation.</p><p>Unique Macro-Instructions</p><p>In accordance with the unique extended processor system of the invention, as described above, certain operations are performed by the system which operations are in themselves uniquely indigenous to the overall operating capabilities of the system. Such operations are described in more detail below and can be best understood in conjunction with the system instruction set reproduced in Appendix B.</p><p>The first operation to be considered involves an interruption of a currently executing program by a peripheral device, for example, and the need to transfer control of the system to the appropriate interrupt operating sequence. One such unique interruption operation is related to the instruction designated as \"EAGLE Vector on Interrupting Device\" (having the abbreviated mnemonic description XVCT) in Appendix B (the instructions in the instruction set of Appendix B are listed in alphabetical order in accordance with their abbreviated mnemonic designations). An understanding of the XVCT interrupt operation can be obtained with the help of the diagrammatic representation of the memory locations shown in FIG. 155.</p><p>Interrupt requests are examined and identified in between the decoding of macroinstructions of a currently executing program and, if an interrupt request occurs, the contents of the stack registers for the current program are first saved in selected locations provided for such purpose in the current ring of execution (e.g. selected apparatus in Page 0 of the current ring).</p><p>Since ring O is the ring reserved for special operations, e.g., interrupt operations, the systems must then cross to ring 0 (change the CRE bits 1-3 of the SBA's to identify ring 0) and load the now empty stack registers with the contents, relating to interrupt procedures, of selected locations in ring 0. Further, a selected location of ring 0, e.g., location 0, for example, is examined to determine if the interrupt is a \"base level\" interrupt, i.e., an interrupt condition in which no other prior interrupts are being processed, or as a \"higher level\" interrupt in which one or more other interrupts are already pending. If pending location 0 indicates that the interrupt is a base level interrupt (e.g., location 0 is a \"zero\", as seen, for example, in FIG. 155, then the interrupt code examines a selected location (e.g., location 1) of ring 0 to determine if such location contains the XVCT code (the first 16 bits of such location 1 corresponds to the first 16 bits of the XVCT code specified in Appendix B). If the interrupt is an XVCT interrupt, the stack registers are then loaded with the XVCT information to set up a XVCT stack, i.e., an XVCT stack \"PUSH\" as seen in FIG. 156.</p><p>The displacement bits 17-31 of location 1 (corresponding to the displacement bits 17-31 of the XVCT instruction shown in Appendix B) then represent an address which points to a selected location in a preloaded XVCT table in the main memory (see FIG. 155). The \"device code\" information (a 16 bit offset code unique to each I/O device from which an interrupt request can be received) is received from the particular device which has requested the interrupt and offsets to a selected address which points to a particular device control table (DCT) in main memory associated with that particular device (e.g., DCT associated with device N identified in XVCT table). The device control table contains the address which points to macroinstructions in main memory which are required in order to perform the interrupt routine requested by the interrupting device.</p><p>The DCT also contains a coded word (\"MASK\") which identifies which other device can be \"masked out\" (i.e., prevented from performing an interrupt while the interrupt is pending for the particular device in question). Certain other devices which have higher interrupt priority than the device in question will not be so masked.</p><p>The DCT further defines the state of the system by a PSR (processor status register) word which is loaded into the PSR of the system and determines whether or not a fixed point overflow condition is to be enabled.</p><p>Once the macroinstructions for the particular interrupt routine requested by the particular device in question have been performed, the previously stored contents of the system stack registers relating to the program currently being executed by the system prior to the interrupt are restored to the system stack registers and such program continues its execution. The overall operation is shown diagrammatically in FIG. 156.</p><p>Another operation unique to the system described herein involves the loading of the segment base registers (SBR) of the system and related to the LSBRA instruction described in the instruction set of Appendix B. As explained above, the SBR's of the systems are not located in main memory but are more readily available on the ATU board of the system. The eight segment base registers of the system each contain a double word of a block of eight double words. The operation described here relates to the loading of such SBR's with an eight double-word block from memory, the starting address of which is contained in a selected accumulator of the system (e.g., AC.0.). The LSBRA operation then loads such block into the SBR's in the manner shown by the table designated in connection with the LSBRA instruction in Appendix B.</p><p>In another operation indigenous to the system described here the 31-bit value contained in the program counter (PC), as discussed with reference to the instruction processor unit (FIG. 20), is added to the value of the displacement contained in a particular instruction word and the result is placed in the program counter, as shown with reference to address 148 and PC register 147 of FIG. 20. The displacement is contained in the instruction designated as WBR (Wide Branch) in the instruction set in Appendix B. Such operation is in effect a program counter \"relative jump\" and involves a 16-bit EAGLE address (PC) and an 8-bit offset, the latter contained as bits 1-8 of the WBR instruction.</p><p>In connection with EAGLE operation in the extended system of the invention, operations are performed to extend (i.e., to validate) 16-bit data to 32 bits. Such operations will involve either zero-extending (ZEX) or sign-extending (SEX) the 16-bit data, as shown in the ZEX or SEX instruction in Appendix B. Thus, for a zero extended operation the 16-bit integer which is contained in the source accumulator (ACS) identified by bits 1, 2 of the instruction, is zero-extended to 32 bits and the result is loaded into the destination accumulator (ACD), identified by bits 3, 4 of the instruction, with the contents of ACS remaining unchanged, unless such accumulators are the same accumulator. For a sign extend operation the 16-bit integer in the ACS is sign extended and placed in the ACD as above.</p><p>A further operation unique to the extended system of the invention involves an operation in which the signed 16-bit integer in bits 16-31 of the ACD is multiplied by the signed 16-bit integer in bits 16-31 of the ACS. Such operation is associated with the Narrow Multiply (NMUL) instruction in Appendix B. Since the system utilizes 32-bit accumulators, when multiplication of 16-bit words (i.e. \"narrow\" words) is required it is necessary to use only 16 bits of the 32-bit accumulator contents. An overflow occurs if the answer is larger than 16 bits, so that if the overflow bit \"OVK\" is in a selected state (e.g. OVK is a 1) an overflow indication occurs and the machine operation is stopped (a \"trap\" occurs) and an overflow handling routine must be invoked.</p><p>The above discussed unique operations of the system of the invention are all indigenous to the design and operation thereof and represent operations not required or suggested by other previously known data processing systems. ##SPC1## ##SPC2## ##SPC3## ##SPC4## ##SPC5## ##SPC6## ##SPC7## ##SPC8## ##SPC9## ##SPC10## ##SPC11## ##SPC12## ##SPC13## ##SPC14## ##SPC15## ##SPC16## ##SPC17## ##SPC18## ##SPC19## ##SPC20## ##SPC21## ##SPC22## ##SPC23## ##SPC24## ##SPC25## ##SPC26## ##SPC27## ##SPC28## ##SPC29## ##SPC30## ##SPC31## ##SPC32##</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Kenneth D.", "last_name": "Holberger", "name": ""}, {"first_name": "James E.", "last_name": "Veres", "name": ""}, {"first_name": "Michael L.", "last_name": "Ziegler", "name": ""}, {"first_name": "Carl", "last_name": "Henry", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "DATA GENERAL CORPORATION"}, {"first_name": "", "last_name": "DATA GENERAL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/30"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  11/14        20060101A I20051008RMEP"}, {"label": "G06F  12/06        20060101A N20051008RMEP"}, {"label": "G06F  12/08        20060101A I20051008RMEP"}, {"label": "G06F  12/10        20060101A I20051008RMEP"}, {"label": "G06F  11/10        20060101A I20051008RMEP"}, {"label": "G06F  12/02        20060101A I20051008RMEP"}, {"label": "G06F   9/30        20060101A I20051008RMEP"}, {"label": "G06F   9/26        20060101A I20051008RMEP"}, {"label": "G06F  12/14        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712211"}, {"primary": false, "label": "711E12014"}, {"primary": false, "label": "712E09016"}, {"primary": false, "label": "712E09009"}, {"primary": false, "label": "714E11112"}, {"primary": false, "label": "714E11032"}, {"primary": false, "label": "711E12059"}, {"primary": false, "label": "711E12091"}, {"primary": false, "label": "711E12017"}], "ecla_classes": [{"label": "S06F11:10M4S"}, {"label": "G06F   9/34X"}, {"label": "T05K999:99"}, {"label": "G06F  12/10D"}, {"label": "G06F   9/26"}, {"label": "G06F   9/30"}, {"label": "G06F  11/10"}, {"label": "G06F  11/14"}, {"label": "S06F12:06C2"}, {"label": "G06F  12/08B"}, {"label": "G06F  12/14"}, {"label": "G06F  12/02D6"}], "cpc_classes": [{"label": "G06F  12/0623"}, {"label": "G06F  12/14"}, {"label": "G06F  12/0802"}, {"label": "G06F  12/1009"}, {"label": "G06F  11/14"}, {"label": "G06F   9/342"}, {"label": "G06F   9/26"}, {"label": "G06F  11/106"}, {"label": "G06F   9/30"}, {"label": "G06F  11/10"}, {"label": "G06F  12/0292"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1980-04-25", "application_date": "1980-04-25", "family_members": [{"ucid": "US-4398243-A", "titles": [{"lang": "EN", "text": "Data processing system having a unique instruction processor system"}]}]}