{"patent_number": "US-4794521-A", "publication_id": 69830143, "family_id": 25049523, "publication_date": "1988-12-27", "titles": [{"lang": "EN", "text": "Digital computer with cache capable of concurrently handling multiple accesses from parallel processors"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA9834730\" source=\"translation\"><p>A cache memory capable of concurrently accepting and working on completion of more than one cache access from a plurality of processors connected in parallel. Current accesses to the cache are handled by current-access-completion circuitry which determines whether the current access is capable of immediate completion and either completes the access immediately if so capable or transfers the access to pending-access-completion circuitry if not so capable. The latter circuitry works on completion of pending accesses; it determines and stores for each pending access status information prescribing the steps required to complete the access and redetermines that status information as conditions change. In working on completion of current and pending accesses, the addresses of the accesses are compared to those of memory accesses in progress on the system.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA36802042\"><p>A cache memory capable of concurrently accepting and working on completion of more than one cache access from a plurality of processors connected in parallel. Current accesses to the cache are handled by current-access-completion circuitry which determines whether the current access is capable of immediate completion and either completes the access immediately if so capable or transfers the access to pending-access-completion circuitry if not so capable. The latter circuitry works on completion of pending accesses; it determines and stores for each pending access status information prescribing the steps required to complete the access and redetermines that status information as conditions change. In working on completion of current and pending accesses, the addresses of the accesses are compared to those of memory accesses in progress on the system.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. A digital processing system comprising:<claim-text>a main memory for storing informatiom at memory locations identified by memory addresses,</claim-text><claim-text>a cache memory for temporarily storing copies of information from selected memory addresses,</claim-text><claim-text>first communication means for transferring information between said cache and main memories,</claim-text><claim-text>a plurality of processors for processing information stored in said cache memory,</claim-text><claim-text>second comuunication means for transferring stored information between said cache memory and said processors,</claim-text><claim-text>said processors each including means for making accesses to information stored in said cache memory by transferring the address of said information across said second communication means to said cache memory,</claim-text><claim-text>said cache memory comprising<claim-text>data storage means for storing said copies of information,</claim-text><claim-text>address storage means such as a tag store for storing the memory addresses associated with said copies,</claim-text><claim-text>memory interface means for accessing said main memory across said first communication means to transfer information between said data storage means and said main memory,</claim-text><claim-text>means for accepting and storing the address for a current access and at least one earlier accepted but not yet completed access (\"pending access\"),</claim-text><claim-text>means for concurrently working on completion of said current and pending accesses, said means comprising<claim-text>pending-access-completion means for working on completion of pending accesses, including means for determining and storing for each pending access status information prescribing the steps required to complete the access and for redetermining said status information as conditions change, and including pending-access-comparison means for comparing the address associated with said pending access to the addresses of main-memory accesses in progress on said system, and</claim-text><claim-text>current-access-completion means for determining whether said current access is capable of immediate completion and for completing said access immediately if so capable and transferring said current access to said pending-access-completion means if not so capable, including means for comparing the address associated with said current access to the addresses stored in said address storage means, and including current-access-comparison means for comparing the address associated with said current access to the addresses of main-memory accesses in progress on said system.</claim-text></claim-text></claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. The digital computer of claim 1 wherein said cache includes<claim-text>means for retrieving data from said memory in blocks, ach block having a block address, and</claim-text><claim-text>means for storing block addresses for said current and pending accesses.</claim-text></claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. The digital computer of claim 1 wherein said cache further includes<claim-text>means for concurrently taking steps to complete a plurality of pending accesses,</claim-text><claim-text>means for storing a block address including means for storing said block address for each said pending access and</claim-text><claim-text>means for storing a status code including means for storing a status code for each said pending access.</claim-text></claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. The digital computer of claim 3 wherein said cache includes means for delaying completion of a first said pending access in preference for a second pending access when said first and second pending accesses are from the same said processor and said second pending access was received by said cache before said first pending access, whereby the order of processor accesses to said cache is preserved.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. The digital computer of claim 4 wherein said cache further includes<claim-text>means for comparing the stored block address for each pending access to the address of each new block received by said cache from memory, and</claim-text><claim-text>means for redetermining the status code for each pending access based on the prior state of said status and the outcome of said comparison.</claim-text></claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. The digital computer of claim 5 wherein said means for redetermining the status code bases said redetermination on information on what steps have been or are being taken to complete the pending access corresponding to the new block received from memory.</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. The digital computer of claim 6 wherein said means for redetermining said status code bases said redetermination on what other activities are currently occurring in said cache.</claim-text></claim>"}, {"num": 8, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. The digital computer of claim 5 wherein said cache further includes<claim-text>means for comparing the block address of said current access to the block addresses of main memory accesses still in progress (not yet available in the cache memory) and</claim-text><claim-text>means for determining a said status code for said current access based on said comparison and said means for comparing.</claim-text></claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. The digital computer of claim 8 wherein<claim-text>said block address consists of a tag and an index,</claim-text><claim-text>said cache comprises</claim-text><claim-text>a tag store in which said tags are stored at addresses specified by said index and</claim-text><claim-text>a data store in which said data is stored at an address specified by said index, and</claim-text><claim-text>means are provided for comparing the index of said current access to the index portions of the block addresses for memory accesses still in progress so as to determine whether a block of data accessed from memory, though not the data sought by said current access, is data that will be written into the data store location addressed by said current access.</claim-text></claim-text></claim>"}, {"num": 10, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. The digital computer of claim 5 or 5 wherein<claim-text>said cache is divided into a plurality of sections and includes means for concurrently accepting a plurality of accesses to different said cache sections and</claim-text><claim-text>said cache sections include means for accessing blocks of data from said main memory and means for dividing each said block between cache sections.</claim-text></claim-text></claim>"}, {"num": 11, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. The digital computer of claim 1, 3, 5, or 8 wherein said cache is divided into a plurality of sections and includes means for concurrently accepting and working on completion of a plurality of accesses to different said cache sections.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES317472106\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><p>This patent includes a Microfiche Appendix (containing Appendices A-F) which comprises a total of 9 microfiche and 622 total frames.</p><h4>TABLE OF CONTENTS</h4><p>Background of the Invention</p><p>Summary of the Invention</p><p>Description of the Preferred Embodiment</p><p>I. Drawings</p><p>II. Summary</p><p>III. Computational Elements</p><p>A. Instructions</p><p>1. Vector Instructions</p><p>2. Processing States</p><p>3. Address Spaces</p><p>B. Data Types</p><p>1. Integer Data</p><p>2. Bit and Bit Field Data</p><p>3. Floating Point Data</p><p>4. Vector Data</p><p>C. General Registers</p><p>D. Control Registers</p><p>E. Memory Management</p><p>IV. Interactive Processors</p><p>V. Concurrent Processing and the CCUs</p><p>A. Concurrency Instructions</p><p>B. CCU Registers</p><p>C. CCU Status Register</p><p>D. Concurrency Control Bus</p><p>E. Communication Between the CEs and CCUs</p><p>F. Initiating Concurrent Processing</p><p>1. Waiting For Others CEs To Go Idle</p><p>2. Loading Registers</p><p>3. Clearing Synchronization and Iteration-Assignment Registers</p><p>4. Waking Up Other CEs</p><p>5. Assigning Iterations</p><p>6. Reading Registers</p><p>7. Timing</p><p>G. Relative Delay Between CE and CCU</p><p>H. Assigning New Iterations</p><p>I. Synchronizing Dependencies</p><p>1. The CAWAIT Instruction</p><p>2. The Four-Bit Size of the Synchronization Registers</p><p>3. The CADVANCE Instruction</p><p>J. Concluding Concurrent Processing</p><p>1. Executing CREPEAT in the Last Iteration</p><p>2. Executing CQUIT</p><p>K. Vector Concurrent Processing</p><p>L. Nested Concurrent Loops</p><p>M. Cactus Stack</p><p>VI. Examples of Concurrent Processing</p><p>VII. Backplane Switch</p><p>A. Circuitry</p><p>B. Operation</p><p>VII. Central Processing Cache</p><p>A. Summary</p><p>B. Data Paths</p><p>C. Address Paths</p><p>D. Handling Multiple acoesses</p><p>E. Cache Interleaving</p><p>Claims</p><h4>BACKGROUND OF THE INVENTION</h4><p>This invention relates to digital computers capable of parallel processing. There has been little progress in applying parallel processing to the computationally intensive applications typically found in engineering and scientific applications, particularly to parallel processing of the same job (i.e., the same instructions and data).</p><p>Caches have long been used in digital computers, and have been applied to parallel processing, with one cache assigned to each processor. A cache is a high-speed memory containing copies of selected data from the main memory. Memory accesses from a processor come to the cache, which determines whether it currently has a copy of the accessed memory location. If not, a cache \"miss\" has occurred, and the cache customarily stops accepting new accesses while it performs a main memory access for the data needed by the processor.</p><h4>SUMMARY OF THE INVENTION</h4><p>We have discovered that in a parallel processing environment, particularly one dedicated to concurrently processing portions of the same job (i.e., same instructions and data), a cache may be usefully given the capability of simultaneously accepting current accesses while working on completion of pending accesses that it was unable to complete earlier (e.g., because a main memory access was required). This makes possible far greater memory bandwidth for each processor.</p><p>In preferred embodiments, the block addresses for the pending accesses are stored along with a status code comprising a prescription of the steps necessary to complete the access; the stored block addresses for pending accesses are compared to the addresses of each new block of data received from main memory and the status code for each is redetermined based on the prior state of the code and the outcome of the address comparison; the block addresses of current accesses are compared to the addresses of main memory accesses still in progress (i.e., not yet available in the cache memory); the cache index of current accesses are compared to the cache indexes of main memory accesses in progress to determine whether a block of data accessed from memory, though not the data sought by the current access, is data that will be written into the cache memory location addressed by the current access; the cache is divided into a plurality of sections and is capable of concurrently accepting a plurality of accesses to different sections; the cache control logic is divided into quick-work logic for completing accesses capable of immediate completion, pending-status logic for initially determining the status code for a pending access and redetermining the status codes as conditions change, and access-completion logic for taking control of the data and address paths within the cache to complete a pending access when the status code indicates that it can be completed; logic is provided to assure that pending accesses from the same processor are completed in the order they are received, rather than the order in which they could best be completed; two cache sections split data blocks accessed from memory and share a main memory address bus, so as thereby to detect the addresses of blocks accessed by the other cache section.</p><p>Other features and advantages of the invention will be apparent from the description of a preferred embodiment and from the claims.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>DESCRIPTION OF THE PREFERRED EMBODIMENT</h4><h4>I. Drawings</h4><p>FIG. 1 is a system block diagram.</p><p>FIG. 2 is a block diagram of an interactive processor.</p><p>FIG. 3 is a block diagram of a high-speed processor or computational element (hereinafter a \"CE\").</p><p>FIG. 4 is a diagram showing the structure of the concurrency status register (CSTAT).</p><p>FIG. 5 is a block diagram showing the concurrency control bus that connetts concurrency control units (hereinafter \"CCUs\") and showing the connections between each CCU and its CE (only two CEs and CCUs are shown).</p><p>FIGS. 6-10 collectively are a block diagram of the CCU.</p><p>FIGS. 11A and 11B are two halves of a block diagram of the CCU status register (CSTAT).</p><p>FIG. 12 is a block diagram of one of the eight 4-bit synchronization registers.</p><p>FIG. 13 is a timing diagram for the CSTART instruction.</p><p>FIG. 14 is a diagram illustrating an example of concurrent processing.</p><p>FIG. 15 is a block diagram showing the CEs, backplane switch, and cache quadrants, and the connections therebetween.</p><p>FIG. 16 is a block diagram of the backplane-switch logic simplified to show the logic for one bit of the ninety-six bits switched between the CEs and cache quadrants.</p><p>FIG. 17 is a block diagram showing one of twenty-four four-bit gate arrays forming the backplane switch.</p><p>FIG. 18 is a perspective view, somewhat diagrammatic, of the circuit boards forming the CEs, cache quadrants, and backplane.</p><p>FIG. 19 is a block diagram showing the address and data paths in the cache quadrants.</p><p>FIG. 20 is an overall block diagram of the control logic for the cache quadrants.</p><p>FIG. 21 is a block diagram of the pending-status logic in a cache quadrant.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>II. Summary</h4><p>A system block diagram is shown in FIG. 1. Eight high-speed processors or computational elements (CEs) 10 are connected to two central processing cache boards 12 (each comprising two quadrants of a four-way interleaved central processing cache (CP cache)) by a switch 14 which resides on backplane 192 (FIG. 18) into which the CE and cache boards are plugged. The switch permits any four CEs to be concurrently accessing the four cache quadrants. The CEs each have a concurrency control unit (CCU) 24 for controlling concurrent processing. The CCUs communicate with other CCUs across a concurrency control bus 26. Memory bus 16 connects the cache quadrants to eight memory modules 17 (each 8 megabytes). Also connected to tee memory bus are two interactive processor caches 18, each of which is connected to three interactive processors (IPs) 20. Each IP serves a multibus 22, to which peripheral devices (not shown) are connnected.</p><p>The system is a shared-global-memory, symmetric (i.e., not master-slave) multiprocessing computer particularly useful for general scientific and engineering computation. The CEs can execute vector, floating-point, and concurrency instructions, as well as integer and logical instructions. The CEs concurrently process different iterations of the same iterative construct (but they may also operate independently to provide a high-performance multi-tasking system). The IPs are moderate-speed interactive processors that can execute integer and logical operations only, and are used for handling input/output traffic, text editing, and similar operations. Data types supported include 8, 16, and 32 bit integer/logical data as well as IEEE standard 32 and 64 bit floating-point data on the CEs only. Memory is virtually addressed. CEs access global memory through cache boards 12, which the CEs communicate with via switch 14. Each CE has its own 16K byte virtuallyaaddressed instruction cache. The IPs access global memory through interactive processor caches 18.</p><h4>III. Computational Elements</h4><p>The computational elements (CEs) are intended for high-speed computations. The CEs are identical, and as few as one may be installed in a system. Any number of CEs may participate in concurrent processing. Those that do are said to be in the concurrency complex (hereinafter \"the complex\"). Those that do not are said to be detached (CCU status bit DETACHED is 1 to indicate such detached operation). CEs can be detached in the event that a job mix being executed on the system includes jobs that cannot make use of concurrent processing (e.g., compilation and debugging) as well as jobs that can (e.g., production jobs). A detached CE acts as if it were a system with only one CE present; it executes concurrency instructions as if it were a one-processor system.</p><p>A block diagram of a CE is shown in FIG. 3. A processor internal bus PIBUS (32 bits wide) is used to transfer data and addresses between the CCU 24, an address translation unit, an instruction processor (containing both an address unit and an integer logic unit and comprising a Motorola 68020 instruction set), and a CE switch, which serves as a conduit between the PIBUS, the vector registers, and the floating point units (which include multipliers, divdders, and an adder). A control section (which includes an instruction parser, a microsequencer, and a RAM-based control store) provides instruction commands to the CCU, the instruction processor, the vector registers, an instruction cache, and the CE switch. The CE communicates with other CEs across the concurrency control bus 26, and with the CP caches 12 using the address and data ports connected to the memory switch 14.</p><h4>A. Instructions</h4><p>Each CE executes instructions stored in memory. Each is capable of interpreting and executing four categories of instructions: (1) base instructions, which implement data movement, logical, integer arithmetic, shift and rotate, bit manipulation, bit field, binary coded decimal, and program control operations; (2) floatinq point instructions, which implement arithmetic (including functions such as square root and sine), test, and move operations on floating point data; (3) vector instructions, which implement integer and floating point operations on up to 32 data elements at a time; and (4) concurrency instructions, which implement the parallel execution of instructions by multiple CEs. The processor contains several classes of registers (see below) for supporting instruction execution. An instruction consists of one or more whole words, where a word is 16 bits.</p><p>An instruction contains the information on the function and operands. Particular bits in the instruction define the function being requested of the processor; the number and location of the defining bits can vary depending on the instruction. The remaining bits of the instruction define the operand--the data to be acted upon. The data can be in memory, in registers within the processor, or in the instruction itself (immediate data); it can be specified as register numbers, values, and addresses.</p><p>Instruction execution normally occurs in the order in which the instructions appear in memory, from low addresses to high addresses. Instructions being executed in the normal sequence must immediately follow one another.</p><p>The processor controls the sequence of instruction execution by maintaining the memory address of the next instruction to be executed in a 32-bit register called the program counter (PC). During the execution of instrcctions that do not alter the normal sequence, the processor increments the PC so that it contains the address of the next sequential instruction in memory (that is, the address of the word immediately following the current instruction). For example, the PC would be incremented by 4 following execution of a 32 bit instruction. Instructions modify the contents of the PC to permit branching from the normal instruction sequence. Other instructions alter the normal sequence by loading a specified value into the PC.</p><p>Most of the base instructions and those vector instructions that produce scalar integer results alter special bits in the processor called integer condition codes. For example, subtracting two equal intege values sets the zero condition code, while subtracting a larger integer value from a smaller integer value sets the negative condition code. Some instructions contain a 4-bit condition code field whose value specifies a condition such as equal, less than, greater than, and so on. The condition is true if the condition codes are set in a certain way. For example, if the zero condition code is set, the equal condition is true; if the negative condition code is set and the overflow condition code is cleared, the less than condition is true; if the negative and overflow condition codes are set and the zero condition code is cleared, the greater than condition is true. The floating point instructions have separate floating point condition codes.</p><p>1. Vector Instructions</p><p>A vector instruction can operate on up to 32 elements of integer or floating point data at once. For example, a single vector add instruction can: add a scalar value to each element of a vector, add the corresponding elements of 2 vectors, or add the elements of vector together (reducing the vector to a scalar value). Vector instructions require set-up work to specify the characteristics of the vectors. Vectors of length greater than 32 elements are processed in a loop. On each iteration of the loop, the length is decremented by 32. The final iteration may (and usually does) contain fwwer than 32 elements. E.g., with a 72-element vector, the vector instructions would operate on 32-element vectors during the first 2 iterations and on an 8-element vector in the third and last iteration. The different iterations of such vector loops can be executed concurrently on a plurality of CEs.</p><p>2. Processing States</p><p>A CE operates in one of the three processing states: (1) normal, the state in which the processor executes instructions from memory as described in the preceding sections; (2) exception, the state initiated by external interrupts, bus exceptions, certain instructions, traps, and occurrences of certain conditions during instruction execution; (3) halted, the state caused by a serious failure requiring the processor to halt. The processor operates in one of two privilege states: user, in which execution of privileged instructions is inhibited, and supervisor, in which execution of nearly all instructions is permitted. The supervisor state can be either interrupt-supervisor state or master-supervisor state, to permit access to different system stacks. The processor enters interrupt-supervisor state when an exception occurs. Exception processing is the only method for entering supervisor state.</p><p>3. Address Spaces</p><p>Addresses specified in instructions are normally virtual (logical) and undergo a translation before being used. A virtual address can occur in one of several address spaces depending on the state of the machine and the nature of the data being accessed (for example, whether the processor is fetching an instruction or an operand): user data space (accesses of data in user privilege state); user program space (accesses of instructions in user privilege state); supervisor data space (accesses of data in supervisor privilege state); supervisor program space (accesses of instructions in supervisor privilege state); processor (CPU) space (accesses of instructions in any privilege state do not normally occur in processor space, which contains internal registers). The user and supervisor address spaces are references to external memory units. The processor address space is a read/access storage area internal to a CE.</p><h4>B. Data Types</h4><p>A CE supports integer, bit, bit field, binary coded decimal, and floating point data types. In addition, integer and floating point data can be accessed as vectors.</p><p>1. Integer Data</p><p>An integer data element can be a byte (8 bits), a word (16 bits, 2 bytes), or a longword (32 bits, 4 bytes). For signed arithmetic operations, the integer represents a positive or negative whole number. The most significant bit constitutes the sign of the number; it is cleared for a positive number, and set for a negative number. The remaining bits constitute the value of the number. Positive numbers are stored in binary notation. Negative numbers are stored in two's complement notation--the bits of the corresponding positive value are inverted and one is added to the result. For unsigned arithmetic operations, the integer represents an absolute whole number; all the bits constitute the value of the number; numbers are stored in binary notation. For logical operations, the integer is treated on a bit by bit basis.</p><p>2. Bit and Bit Field Data</p><p>Bit operations permit access of a bit by specifying its offset from the low order bit of a byte. Bit field operations permit access to a sequence of bits by specifying (a) the offset of the bit field from the low address bit of a byte and (b) the width of the bit field.</p><p>3. Floating Point Data</p><p>A floating point data element can be a longword (single precision) or a quadword (double precision). The least significant bit is always the high address bit of the data element and the bit numbers run from the high address bit to the low address bit within the data element. Representation of floating point data in memory follows the IEEE standards for single and double precision numbers, with some restrictions. The storage element consists of three parts: sign, exponent, and fractional part of mantissa.</p><p>4. Vector Data</p><p>A vector can be integer or floating point in type. The number of elements is called the vector length. The elements can be adjacent or can be separated by a constant stride. The stride is called the vector increment and is measured in multiples of the element size.</p><h4>C. General Registers</h4><p>Each CE contains data, address, floating point, and vector registers for general programming use. There are 8 data registers, named D0 through D7, which can be used for storing integer and bit field data; each register is 32 bits in size. There are 8 address registers, named A0 through A7, which can be used for storing word and longword integer data; each register is 32 bits in size. There are 8 floating point registers, named FP0 through FP7, which can be used for storing single and double precision floating point data; each register is 64 bits in size. There are 8 vector registers, named V0 through V7, which can be used for storing long integer and floating point data; each vector register is 64 bits by 32 elements (2048 bits total) in size; the data elements in one register must be of the same type and size.</p><h4>D. Control Registers</h4><p>In addition to the registers for general use, there are control registers. Most of these registers are modified implicitly during the execution of certain instructions, although some of the control registers can be manipulated directly.</p><p>The program counter (PC) is a 32-bit register that contains the address of the next instruction to be executed. The processor alters the contents of the PC as a part of normal instruction execution. Most instructions advance the PC to the memory address immediately following the instruction being executed, so that a sequential flow of instructions occurs. Some instructions permit jumping to a new instruction by loading a new address into the PC.</p><p>Address register 7 (A7) is treated as the user stack pointer (SP) if user mode is in effect, the master stack pointer if master supervisor mode is in effect, and the interrupt stack pointer if interrupt supervisor mode is in effect. The stacks are areas of memory that can be accessed on a last-in, first-out basis. Each stack is contiguous, running from high addresses to low addresses. The term system stack refers to any of the three stacks. The term supervisor stack refers to either the master stack or the interrupt stack. The stack pointer contains the address of the last word placed on the stack (the top of the stack). Storage is allocated on the stack by decrementing the stack pointer, and deallocated by incrementing the stack pointer. For example, to push the contents of A0 onto the system stack, the stack pointer (A7) is decremented by 4 (4 bytes), and A0 is stored at the address contained in the stack pointer.</p><p>A status register (16-bits) is provided. The low-order 8 bits contain the condition codes and the integer overflow bit. Instructions that operate on integer, bit, and bit field data (the base instructions) typically affect the condition codes. Vector instructions that produce scalar integer results also affect the condition codes. Condition codes include negative condition code (set if an instruction produces a negative result), zero condition code (set if an instruction produces a result of 0), overflow condition code (set if an instruction produces a result that overflows the size of the destination operand), carry condition code (set if an instruction generates a carry or a borrow), and extend condition code (set the same as the carry condition code).</p><p>Floating point operations (including vector operations on floating point operands) use a floating point status register, a 32-bit register that contains floating point condition codes and exception codes; and a floating point control register, a 32-bit register that contains exception trap enable codes and floating point mode codes.</p><p>Vector instructions reserve three data registers as control registers for specifying the length, increment, and offset of the vector instruction being processed. These registers are loaded prior to a vector instruction.</p><p>The control registers for concurrency operations are discussed in a subsequent section.</p><p>Each CE also has several internal processor registers.</p><h4>E. Memory Manaqement</h4><p>The memory management mechanism permits each program using the processor to address a very large amount of virtual memory (e.g., 2<sup>32</sup> bytes) starting at address 0. The processor (as a part of normal instruction execution) translates a program's virtual references to physical memory addresses using tables provided by software (for example, an operating system). If a virtual reference does not have a corresponding physical memory address, the processor can change to exception processing and transfer control to the memory management exception vector routine, permitting software to validate the virtual reference (for example, by reading the referenced instruction or data into memory from secondary storage). In this way, a program can use more space than a machine has physical memory, and many programs can work on one machine as if each program occupied memory alone. Virtual addresses for each program can be mapped to separate physical memory addresses for private, protected environments and to the same physical memory addresses as other programs to share code and data. In addition, the meoory management mechanism permits areas of memory to be flagged as read-only.</p><p>Memory management supports four virtual address spaces: user data (accesses of data in user privilege state), user program (accesses of instructions in user privilege state), supervisor data (accesses of data in supervisor privilege state), and supervisor program (accesses of instructions in supervisor privilege state). The initial memory addressed by each program can be divided into 1024 segments, each segment containing 1024 pages, and each page containing 4096 bytes. Virtual addresses can be flagged as read-only on a per space, per segment, and per page basis.</p><p>Physical memory consists of 2<sup>29</sup> addressable bytes numbered consecutively from address 0. Memory management divides physical memory into a series of pages each 4096 bytes in size.</p><p>A virtual address (32 bits in size) is divided into segment (10 bits), page (10 bits), and byte (12 bits) numbers. A physical address (28 bits in size) is divided into physical page (16 bits) and byte (12 bits) numbers. The low order 12 bits of a virtual address map directly to the low order 12 bits of a physical address; no translation takes place. The high order 20 bits of a virtual address (the segment and page numbers) point to a physical page through tables supplied by software, including segment and page tables. The processor constructs a physical address by determining the physical page number from the tables and the high order 20 bits of the virtual address. The 12 low order bits of the virtual address are then added to the physical page number yielding a complete physical memory address.</p><p>A CE caches the most recently used segment and page tables in an internal page translation buffer as translations are made. A CE first attempts to determine the physical page number associated with a virtual address from the page tables in the translation buffer. If the translation buffer does not contain the necessary page table, the CE attempts to locate the page table in memory from the segment tables in the translation buffer. If the translation buffer contains the necessary segment tables, the CE then examines the page table in memory to determine the physical page number. If the translation buffer does not contain the necessary segment table, the processor must examine the tables in memory to determine the physical page number.</p><h4>IV. Interactive Processors</h4><p>The interactive processors (IPs) are oriented toward input/output and operating systems duties. Each IP has the same base instructions and supporting registers as the CEs, but not its floating point, vector, or concurrency registers and instructions. An IP can access system registers, system devices, and input/output devices. Memory is accessed through an interactive processor cache (IPC), with up to three IPs being served by a single IPC. An IP is connected to peripheral devices through a multibus, and can transfer data between a peripheral device and system memory by way of the multibus and its IPC. An IP has asynchronous communications channels for console and diagnostic devices. A console IP is used to start the system, using the code read from its power-up EPROM. The operating system is also booted from EPROMs.</p><p>FIG. 2 is a block diagram of an IP. Processor 30 is connected by data bus 32 to multibus interface 34, IPC interface 36, and local memory 38. Virtual addresses supplied by processor 30 are translated by memory management 40. The local memory includes a power-up EPROM, boot EPROMs, registers, timers, a local 512K RAM, an EEPROM (providing additional registers), and registers for accessing DUART (dual universal asynchronous receiver/transmitter) channels.</p><p>Memory management is accomplished using two caches--a supervisor map and a user address translation unit (ATU)--and logic for translating virtual memory addresses (32 bits) to physical addresses (28 bits). The ATU is divided into a program section and a data section. Physical addresses are one of four types: global memory (28 bits defining an address in the main memory accessible by way of the IP cache), multibus (20 bits), local memory (28 bits), and IPC device (28 bits specifying a device, register, or storage area on the IPC).</p><h4>V. Concurrent Processing and the CCUs</h4><p>Referring to FIGS. 1 and 5, each CE 10 includes a CCU 24 that communicates with other CCUs across a concurrency control bus 26. The CCU provides hardware support for initiating concurrent. processing, assigning iterations, synchronizing dependencies, and terminating concurrent processing. The CCU and CCU bus are shown in FIGS. 5-12. Appendix B comprises the Boolean equations for five logic arrays of the CCU (CONTROL, DECODER, WAIT, PIDEC, RIDLE).</p><h4>A. Concurrency Instructions</h4><p>Concurrent processing is controlled using the following twenty concurrency instructions:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nLoop Control Instructions                                                 \nCADVANCE   Advance synchronization register.                              \nCAWAIT     Await synchronization register                                 \n           advance.                                                       \nCIDLE      Do nothing.                                                    \nCQUIT      Exit concurrent loop.                                          \nCSTART     Start concurrent loop.                                         \nCSTARTST   Start concurrent loop and serialize                            \n           traps.                                                         \nCVECTOR    Start vector concurrent loop.                                  \nCVECTORST  Start vector concurrent loop and                               \n           serialize traps.                                               \nCREPEAT    Branch to top of concurrent loop if                            \n           more iterations.                                               \nSave, Restore, and Move Instructions                                      \nCMOVE FROM Move CCU status register contents to                           \n           a specified address.                                           \nCMOVE TO   Load CCU status register from a                                \n           specified address.                                             \nCNEST      Save contents of CCURR, CMAX, CGSP,                            \n           and CSTAT registers.                                           \nCUNNEST    Restore contents of CCURR, CMAX, CGSP,                         \n           and CSTAT registers.                                           \nCRESTORE   Restore contents of all ten CCU                                \n           registers.                                                     \nCSAVE      Save contents of all ten CCU                                   \n           registers.                                                     \nVector Concurrency Instructions                                           \nVIH        Calculate the increment of a vector                            \n           for horizontal concurrent vector                               \n           operations.                                                    \nVLH        Calculate the length of a vector for                           \n           horizontal concurrent operations.                              \nVLV        Calculate the length of a vector for                           \n           vertical concurrent operations.                                \nVOH        Calculate the offset of a vector for                           \n           horizontal concurrent operations.                              \nVOV        Calculate the offset of a vector for                           \n           vertical concurrent operations.                                \n______________________________________                                    \n</pre><p>A detailed description of the functions performed by each of the first fifteen instructions is given in Appendix A, using a pseudocode that is explained in the appendix. The last five, the vector concurrency instructions, are described in the section on vector concurrent processing.</p><h4>B. CCU Registers</h4><p>There are ten 32-bit registers in each CCU:</p><p>CMAX (maximum iteration): The register contains the maximum iteration count for a concurrent loop in progress. This value is the same across all CEs in the concurrency complex.</p><p>CNEXT (next outer iteration): The register contains the low-order portion of the number of the next iteration for a concurrent loop in progress. The complete number is 33 bits with the high-order bit (CNEXT32) being stored in the CCU status register. The value is the same across all CEs in the complex.</p><p>CCURR (current iteration): The register contains the low-order portion of the number of the current iteration of a concurrent loop. The complete number is 33 bits with the high-order bit being stored in the CCU status register. This value is unique to each CE in the complex.</p><p>CCSP (unique (\"cactus\") stack pointer): The register holds the address of the base of a stack for storing local variables during concurrent loop execution. This value is unique to each CE in the complex.</p><p>CGSP (global stack pointer): The register is used to broadcast the stack pointer to other CEs prior to starting a concurrent loop.</p><p>CGPC (global program counter): The register is used to broadcast the program counter to other CEs prior to starting a concurrent loop.</p><p>CGFP (global frame pointer): The register is used to broadcast the frame pointer to other CEs prior to starting a concurrent loop.</p><p>CIPC (idle instruction address): The register is used to hold the address of the idle instruction, the instruction continuously executed by CEs in the complex when they are not needed.</p><p>CSYNC (synchronization regiseers): The register is the collective contents of the eight 4-bit synchronization registers, which are used to synchronize dependencies within a concurrent loop, and one of which may also be used to serialize traps.</p><p>CSTAT (the CCU status register): The register contains a variety of single-bit and multi-bit fields, as shown in FIG. 4.</p><h4>C. CCU Status Register</h4><p>The various fields of the CCU status register (CSTAT) are:</p><p>VPN (virtual processor number): VPN is the rank of a CE among N CEs in the complex, using a continguous numbering from 0 to N-1. There is not a one-to-one correspondence between the physical number of a CE and its VPN, as a CE may be absent, broken, or not taking part in concurrent processing. The VPN of each CE within the concurrency complex is computed during the CSTART sequence.</p><p>NUM (the nubber of CEs in the concurrency complex): NUM is a number from 0 to 7 expressing the total number of CEs in the complex (0 meaning one CE in the complex). NUM equals the highest VPN in the complex. NUM is computed during the CSTART sequence.</p><p>INLOOP: The INLOOP status bit indicates whether a CE is processing a concurrent loop. INLOOP is globally set to 1 (in all CCUs in the complex) during the CSTART sequence, and is used to wake up other CEs in the complex. It is cleared when a CE goes idle or resumes serial processing.</p><p>NESTED: The NESTED status bit indicates that its CE is executing a nested concurrent loop. NESTED is locally set to 1 when a CNEST instruction is encountered after concurrent processing is underway.</p><p>SERTRAP: The SERTRAP status bit is globally set to 1 when either a CSTARTST or CVECTORST is encountered, so that that traps become serialized.</p><p>ENABLE: The ENABLE bit can be used by the CE (with a CSAVE and CRESTORE operation) to leave a flag that a request to change the number of CEs in the complex has been made. Logic in the CE could inspect INLOOP and ENABLE, and if the bits were 0 and 1, respectively, inform the operating system so that a change in the complex size could be made while no concurrent processing was underway.</p><p>DETACHED: The DETACHED status bit specifies whether a CE is a member of the concurrency complex (a 1 indicates that it is not).</p><p>VECTOR: The VECTOR status bit is set to indicate that it is a vector-concurrent loop that is being executed.</p><p>PARITY: The PARITY status bit is set to force a CCU data bus parity error (by asserting PERR).</p><p>TEST: The TEST status bit can be used for diagnostic purposes.</p><p>CCURRO: These four bits are a zero followed by a duplicate of the low-order three bits of the current iteration number (CCURR).</p><p>CCURR32: This is the highest order bit of CCURR.</p><p>CNEXT32: This is the highest order bit of CNEXT.</p><h4>D. Concurrency Control Bus</h4><p>As shown in FIG. 5, the CCUs communicate with other CCUs across a concurrency control bus 26 consisting of 29 control lines and one 33-bit data bus (CCUBUS). The CCUBUS is bidirectional, and includes an additional parity bit CCUP. The control lines include three eight-bit groups of lines: advance lines ADV, ready lines RDY, and active lines ACT. Each advance line corresponds to one of eight synchronization registers. Each ready and active line corresponds to one of the eight CEs. The notation (FIG. 5) \"(7:0)\" following each of these groups of eight lines indicates that the lines are denoted \"0\" through \"7\". Every CCU receives as inputs all eight ready and active lines, and can place an output on its own line within each group. Outputs are denoted by the suffix \"O\"; inputs by the suffix \"I\" (e.g., there are eight ready input lines RDYI(7:0) and one ready output line RDYO at each CCU). The remaining five control lines comprise two select lines SEL(1:0), a CSTART line, a CQUIT line, and a write line CWR, all of which can be read and written by each CCU. The same \"O\" and \"I\" suffixes, meaning output and input, respectively, are used for signals on these lines.</p><p>The physical identity of each CE and its CCU is established where the CE is plugged into the backplane. A different board identity signal BDID (varying from 0 to 7) is supplied to each CE connector, from which it is routed to the CCU.</p><h4>E. Communication Between the CEs and CCUs</h4><p>Each CCU communicates with its CE across the CE's 32-bit data bus (PIBUS) and several control lines (FIG. 5). Control signals supplied to the CCU by the CE include a register select signal RSEL (4 bits), a write signal WR, a command signal DO, the iteration offset OFFS (3 bits; an argument of the AWAIT instruction), a read (or output enable) signal OE, a synchronizer select signal SSEL (3 bits; an argument of the AWAIT and ADVANCE instructions), and an instruction identifier signal CMND (4 bits). Control and status signals supplied to the CE from the CCU include six status bits from the CSTATUS register (ENABLE, DETACHED, SERTRAP, VECTOR, NESTED, INLOOP), the number of CEs in the complex NUM (3 bits), the CE's virtual number VPN (3 bits), and the signals TRAPOK, SERIAL, QUIT, WAIT, and PERR (each 1 bit). Several clocks C1, C3, P1, P3, E4 are passed to the CCU from the CE.</p><h4>F. Initiating Concurrent Processing</h4><p>Prior to concurrent processing only one of the CEs in the concurrency complex is active; the others are ordinarily idle. Concurrent processing is initiated when the active CE executes a CSTART (or CSTARTST, CVECTOR, CVECTORST) instruction. Microcode in the active CE supplies a multicycle sequence of instructions to the CE's CCU, instructions that (1) wake up the other CEs in the complex, (2) pass information (maximum iteration, global stack pointer, global frame pointer, and program counter) to its own CCU and, via the CCU bus, to other CCUs and CEs in the complex, (3) cause each CCU to arbitrate for an iteration to be executed by its CE, and (4) read from the CCU the assigned iteration number and a unique (\"cactus\") stack pointer for use during concurrent processing.</p><p>1. Waiting For Other CEs To Go Idle</p><p>Before the active CE begins this CSTART sequence, it checks to be sure that all other CEs in the complex are in the idle state. The CE establishes the idle status of the other CEs by inspecting the WAIT line, which emanates from multiplexer 100 (FIG. 6). The multiplexer is supplied with a four-bit instruction identifier CMND that indicates which of six instructions for which waiting may be required (CSTART, CWAIT, CADVANCE, CQUIT, CIDLE, CREPEAT) is currently being executed by the CE. The multiplexer uses the CMND signal to place the appropriate output of the WAIT logic array 102 on the WAIT line. The WAIT logic array has an output for each of the six instructions for which waiting may be required; each output is asserted whenever, based on several inputs, the WAIT logic array determines that the CE should delay further processing if it encounters the instruction. In the case of CSTART, a wait condition is imposed unless the ANYACT signal goes low, indicating that no other CEs in the complex are active. ANYACT is asserted by RIDLE logic array 90 if any active line ACT, other than the CCU's own ACT line, is asserted. An active line is asserted whenever a CE is not detached and not executing the CIDLE instruction. (The wait condition is also not imposed if the DETACHED or NESTED status bits are set, as in either case the loop following the CSTART instruction will not be executed concurrently.)</p><p>2. Loading Registers</p><p>After the wait condition imposed on executing CSTART is lifted, the CE's microcode begins a multicycle sequence of instructions to the CCU. Its first step is to write the global stack pointer (GSP, contained in a CE register) into the CGSP register (FIG. 9) of all CCUs in the complex (i.e., GSP is \"globally\" written into the CGSP registers). That is accomplished by the CE placing the contents of the A7 register on the PIBUS (FIG. 8), asserting the write line WR (FIG. 7), and placing the appropriate four-bit code on the RSEL lines. The RSEL and WR lines. are fed to DECODER logic array 124 (FIG. 7), causing two events to occur: (1) CWRO is asserted, connecting the PIBUS to the CCUBUS, so that GSP is available at all CCUs in the complex; and (2) the code for the CGSP register is asserted on the SEL lines, instructing all the CCUs to read the contents of the CCUBUS into their CGSP registers. The SEL code together with assertion of CWRO cause each CCU's CONTROL logic array to assert LDGSP, which, in turn, causes the CGSP register to read from the CCUBUS. The CCUBUS, rather than the PIBUS, is read into the CGSP register, because the RESTORE signal controlling multiplexer 120 (FIG. 9) is low (RESTORE is high during a state restore operation, when the saved state is read back into the local registers using the PIBUS).</p><p>A similar procedure is followed to store GPC, GFP, and MAX in the CGPC, CGFP, and CMAX registers, respectively, of all CCUs in the complex. (The last step, storing MAX, is not performed if it is a CVECTOR or CVECTORST that has been executed, because in those cases, only one iteration is performed by each processor in the complex.)</p><p>3. Clearing Synchronization and Iteration-Assignment Registers</p><p>A further action taken upon execution of a CSTART (or CSTARTST, CVECTOR, CVECTORST) instruction is clearing the synchronization registers CS0 to CS7, the current iteration register CCURR, and the next iteration register CNEXT, in all CCUs in the complex. The CE executing the CSTART asserts a DO CSTART instruction to its CCU, by asserting DO and placing the code for CSTART on the RSEL lines (FIG. 7). The DECODER logic array responds by asserting CSTARTO on the CSTART line of the CCU bus. The CONTROL logic arrays in each CCU in the complex respond by asserting CLRSYNC, CLRPAST, CLRCURR, and CLRNEXT, which, in turn, cause the corresponding registers to be cleared. CSTARTI, CSTARTI1, and CSTARTI3 (the latter two being delayed versions of CSTARTI) cause the CONTROL and DECODER logic arrays to assert the various signals required during the CSTART sequence.</p><p>4. Waking Up Other CEs</p><p>In the same cycle as these clearing operations are performed, SETINLOOP is asserted by the CONTROL logic array (FIG. 7) in each CC in the complex. SETINLOOP causes the INLOOP status bits of the CSTAT register in each CCU in the complex to be set. That, in turn, causes the other CEs in the complex, all of which are constantly inspecting the INLOOP bit, to wake up and to begin their portion of the CSTART sequence.</p><p>5. Assigning Iterations</p><p>In the machine cycle following the register clearing operations, the CCUs assign iterations for their CEs to execute following completion of the CSTART sequence. CSTARTO asserted on the CSTART line of the CCU bus causes CSTARTI1 to be asserted in each CCU in the complex in the following cycle (CSTARTI, the signal read from the CSTART line, is delayed one cycle by latches 134, 136, and emerges as CSTARTI1). The DECODER logic array 124 in each CCU in the complex responds to the assertion of CSTARTI1 by asserting RDYO, which is tied to that CCU's RDY line, one of the eight on the CCU bus. As there is a one-to-one correspondence between an asserted ready line and a CCU bidding for an iteration, the total number of CEs bidding for an iteration, or what is the same thing, the number of CEs in the complex, is simply the total number of asserted ready lines. That total is generated by incrementer 142; it totals the number of asserted lines, increments the 32-bit contents of line 144 by the total number of lines, and places the sum on line 146. The CNEXT register was cleared in the prior cycle so that the input line 144 to the incrementer is zero, meaning that its output on line 146 is simply the total number of CEs in the complex. Accordingly, the first three bits of the output are channeled off as NEWNPO (new NUM plus one) and loaded (after being decremented by 1) into the NUM field of the CSTAT register (ADDNUM having been asserted by the CONTROL logic array). The output of incrementer 142 also represents the number of the next iteration to be processed by the first CE to complete the first iteration assigned to it, and thus it is loaded into the CNEXT register via port 2 (ADDNEXT having been asserted by the CONTROL logic array).</p><p>Iteration assignment is also achieved using the ready lines. MASK logic array 140 screens the ready lines, using BDID, the CCU's physical address, and zeroes its own ready line and any lines corresponding to a physical address higher than its own (as RDY7, the highest ready line, would always be masked, it is not supplied to the MASK logic array). The total number of asserted ready lines emerging from MASK is the number of the iteration assigned to that CCU (iteration numbering begins with zero). For example, if three CCUs are in the complex, and one inspects the CCU with the highest physical address, one would find that the number of asserted ready lines emerging from MASK is two, which is the highest iteration to be initially assigned. The CCU with the next highest physical address will have one asserted ready line emerge from MASK, and be assigned iteration 1. The third, and final CCU will have zero asserted ready lines emerge from MASK, and be assigned iteration 0.</p><p>The manner in which this number of emerging asserted ready lines is translated into an iteration assignment is as follows. Incrementer 148 adds the number of asserted ready lines emerging from MASK to the previous contents of the CNEXT register (i.e., before it was incremented by the total number of asserted ready lines), and the sum is loaded into the CCURR register via port 2 (ADDCURR having been asserted by the CONTROL logic array). The CCURR register, therefore, receives the value of the current iteration to be processed by its CE.</p><p>6. Reading Registers</p><p>The final set of operations performed during the CSTART sequence is reading from the CCUs the contents of certain registers whose value was determined earlier in the CSTART sequence. The initiating CE reads the cactus stack pointer (CSP) from the CCSP register and the current iteration from the CCURR register. The other CEs in the complex read those two registers, and also the CGFP and CGPC registers. The contents of the CGFP and CCSP registers are required in order that every CE in the complex have the necessary state information to begin concurrent processing. The GFP is used to access global variables during loop execution. The contents of the CGPC register is read by the other CEs in order that they have the program counter value needed for resumption of serial processing. GPC is the address of the instruction at the top of the concurrent loop (i.e., immediately after the CSTART instruction). Reading registers from the CCU is accomplished by the CE asserting the output enable line OE and the RSEL code corresponding to the desired register.</p><p>Following those register read operations, the CEs in the complex begin execution of the instructions within the concurrent loop. As they are all executing the same instructions, the CEs execute the initial instructions of the loop roughly in phase with one another, although the initiating CE may get slightly ahead of the others because of the higher probability that the others will suffer cache misses (e.g., instruction cache misses arising because the other CEs' were in the idle state). The phase relationship of the CEs changes substantially, however, when the first CAWAIT instruction is encountered (see synchronzation discussion below).</p><p>7. Timing</p><p>The timing of the actions taking place following CSTART is shown graphically in FIG. 13. The notational scheme can be explained using examples. WRCGSP in the first machine cycle means that the initiating CE (the one executing the CSTART) has asserted the global write into the CGSP registers. The indication [GSP] in the third machine cycle indicates that the stack pointer has become valid for the first time in that cycle (they were loaded at the third quarter of the previous cycle, in which LDGSP was asserted). Similarly, the indication [INLOOP] in the fourth cycle indicates that the 1 loaded into the INLOOP bit of the status register in the third cycle upon assertion of SETINLOOP has become valid.</p><p>It can be seen that the DO CSTART instruction is asserted in the second machine cycle, after just one of the four write operations has begun. This timing permits the multi-cycle operations following DO CSTART to occur in parallel with the write operations.</p><h4>G. Relative Delay Between CE and CCU</h4><p>Delay latches 126, 127 delay execution of instructions given the CCU by the CE. The first half of the latch is clocked by the CE's P3 clock, high during the third quarter of the the CE's cycle. The second half of the latch is clocked by the CCU's C1 clock, hig during the first quarter of the CCU's cycle. The result is a variable delay of either one or one-half machine cycle, depending on the relative phase of the CE and CCU. The CCUs are always in phase with one another, as they are all driven by the same clock. The CEs, on the other hand, though driven by clocks synchronized with the CCU clock, can (as the result, for example, of cache misses) become one-half cycle out of phase with respect to the CCUs and other CEs. There is a full cycle of delay through latches 126, 127 when a CE and its CCU are in phase, and one-half cycle of delay when the devices are out of phase.</p><p>To make the difference in relative phase of the CCU and CE transparent to the CE, so that the delay between assertion of a signal by the CE and response by the CCU always appears the same, an additional variable delay of either zero or one-half cycle is added to some of the signals sent back to the CE. The 32-bit lines carrying the contents of four of the ten CCU registers to multiplexer 130 are delayed in this manner. These four (CCURR, CNEXT, CS0-CS7, and CSTAT) are edge triggered by CCU clock C1 and their outputs pass though a latch clocked by P1 before reaching the multiplexer, resulting in the multiplexer output on the PIBUS being delayed by an additional one-half cycle when the CE and CCU clocks are out of phase. The remaining six registers are loaded at CCU clock C3, and reach the multiplexer with a delay that is variable by one-half cycle. This variation is accomodated by the CE waiting the worst case delay at all times.</p><h4>H. Assigning New Iterations</h4><p>When a CE executing a concurrent loop reaches the CREPEAT instruction, which is placed after the last instruction within the loop, two actions are taken: (1) the displacement specified in the instruction is added to the program counter (this is done wholly within the CE) and (2) a new iteration is assigned using the ready lines RDY and CCURR and CNEXT registers.</p><p>The iteration assignment procedure is initiated by the CE asserting the DO CREPEAT instruction using its RSEL and DO lines (FIG. 7). That CE's own CCU responds by asserting its own ready line RDY. Other CEs simultaneously executing a CREPEAT instruction may also assert their own RDY line. The total number of asserted ready lines is used to update the CNEXT and CCURR registers in the same manner as described for the CSTART instruction. ADDNEXT is alwas asserted during concurrent execution to cause the contents of CNEXT to be incremented by the number of RDY lines asserted (even at times when a CCU is not asserting its own ready line). MASK zeroes all ready lines except those of CCUs of lower physical number than itself. CCURR is set equal to the prior contents of CNEXT plus the number of RDY lines emerging from MASK. In the case of a single RDY line being asserted, CNEXT is incremented by one, and CCURR is set equal to CNEXT.</p><p>To obtain the newly assigned iteration, the CE asserts a READ CCURR instruction by asserting the read line OE (FIG. 9) and placing the code for CCURR on its RSEL line.. That causes the contents of CCURR to pass through multiplexer 130, and be placed onto the PIBUS. The CE then begins execution of the new iteration of the concurrent loop.</p><p>Although the CE has begun execution of a new iteration, it will be brought to a halt if the CCU determines shortly thereafter that the new iteration exceeds the maximum iteration stored in the CMAX register. The contents of CCURR are compared to the contents of CMAX at comparator 110 (FIG. 9). If the maximum iteration has been exceeded, GTMAX is asserted, causing CONTROL logic array 118 (FIG. 7) to assert KWIT and, in turn, latch 112 (FIG. 11A) in the CSTAT register to assert QUIT. The CE, constantly checking for the occurence of QUIT, responds to its assertion by going idle (it reads the contents of the CIPC register from its CCU, and places the contents in its program counter).</p><p>The same comparison of CCURR to CMAX also establishes whether the new iteration is the last iteration; if it is, actions are taken to cause the CE assigned the new iteration to be the one to continue serial processing when it again reaches CREPEAT. Comparator 110 asserts EQMAX if CCURR equals CMAX. Assertion of EQMAX will cause CONTROL logic array 118 (FIG. 7) to assert CLRINLOOP the next time that a DO CREPEAT instruction is received from the CE. EQMAX asserts CEREAL, which causes SERIAL to be asserted, preventing the CE from branching back on the next CREPEAT.</p><p>The CURR32 input to the gates generating EQMAX and GTMAX is needed in the event that the number of iterations stored in CCURR exceeds its maximum capacity of 2<sup>32</sup> (approximately 4 billion) of the register. In that event, CURROVF (FIG. 8) is asserted by incrementer 148 and the CURR32 bit of the CSTAT register is set to 1 (FIG. 11A). When CURR32 is 1, GTMAX is set to 1 and EQMAX to 0. That immediately halts concurrent processing of the affected CE. To avoid this result, it may be preferable to adapt the software running on the system to assure that the number of iterations of a concurrently executed loop does not exceed the capacity of the 32-bit CCURR register.</p><h4>I. Synchronizing Dependencies</h4><p>The presence, within a concurrently executed loop, of an instruction that cannot properly be executed until another instruction (often the same instruction) is executed in a prior iteration creates what is called a dependency, and execution of the first instruction must be synchronized with execution of the second instruction in the prior iteration. Synchronization is accomplished using two instructions, CAWAIT and CADVANCE. A CAWAIT instruction is placed before the first instruction, and a CADVANCE after the second instruction. In the event that the same instruction is both the first and second instruction, the CAWAIT is placed before the instruction, and the CADVANCE is placed after it. Each pair of CAWAIT and CADVANCE instructions is ordinarily keyed to one of the eight synchronization registers CS0 to CS7. The fact that there are only eight synchronization registers does not, however, limit the number of dependencies that can be handled. If more than eight dependencies are present in the same iterative construct, groups of dependencies may be bracketed by pairs of CAWAIT and CADVANCE instructions, each group thereby being handled by a single synchronization register.</p><p>1. The CAWAIT Instruction</p><p>The CAWAIT instruction has two arguments: the number (SSEL) of the synchronization register (CS1-CS7) assigned to this dependency and the offset (OFFS) from the current iteration to the prior iteration (an offset of zero means the immediately prior iteration). Execution of a CAWAIT causes the CE to delay further processing until the WAIT output of the CCU's WAIT logic array goes low (FIG. 6). The CE places the number of the synchronization register specified in the AWAIT instruction on the SSEL lines. That selects the corresponding AWTOK line at multiplexer 114. When the AWTOK line is asserted during execution of the CAWAIT instruction, WAIT array 102 and multiplexer 100 (selecting the CAWAIT line in response to recognition of the code for CAWAIT on the CMND lines) cause the WAIT line to go low, allowing the CE to process the instruction following the CAWAIT instruction.</p><p>The AWTOK lines are controlled by synchronization registers CS0-CS7 (FIGS. 10, 12). An AWTOK line (the assertion of which acts as a go-ahead signal to a CE executing an AWAIT instruction) is asserted when its respective synchronization register is advanced to a number representing the prior iteration in which the second instruction (see above) is to have been executed. Specifically, the AWTOK is asserted when the first three bits of its synchronization register, the contents of 3-bit register SYNC in FIG. 12, is equal to (or greater than) the least significant three bits of the current iteration, the CURRO field of the status register, reduced by the offset OFFS plus 1. Set forth as an equation, AWTOK is asserted when</p><p></p><pre listing-type=\"equation\" xml:space=\"preserve\"><!--Greenbook equation-->SYNC\u2267CURRO-OFFS.</pre><p>This test is carried out by forming the difference CURRO-SYNC using circuit 106, and comparing the output of that circuit to the offset OFFS at comparator 108.</p><p>Circuit 106 actually forms the expression</p><p></p><pre listing-type=\"equation\" xml:space=\"preserve\"><!--Greenbook equation-->CURRO-SYNC+C-1</pre><p>The \"C-1\" term in the expression is there as the result of supplying an inverted copy of the ADVI signal to the comparator, in order to save a machine cycle of time in this synchronization procedure. The ADVI input, which is asserted as a consequence of execution of the CADVANCE instruction (see discussion below), increments the SYNC register, but the incremented value is not available until the machine cycle following assertion of ADVI. To make the effect of ADVI felt in the same cycle it is asserted, it is supplied through an inverter to circuit 106. In that cycle, C equals 0, and the output F of the circuit is thereby set to</p><p></p><pre listing-type=\"equation\" xml:space=\"preserve\"><!--Greenbook equation-->CURRO-(SYNC+1),</pre><p>which is the value it will have after SYNC is incremented. In the next cycle when ADVI will be low (making C equal to 1) and SYNC will have already een incremented by 1, the same output will be produced.</p><p>2. The Four-Bit Size of the Synchronization Registers</p><p>Even though iterations as high as 2<sup>32</sup> are permitted, it is possible to limit the size of each synchronization register to four bits, a three bit SYNC register and a single bit PAST register. The reason this is possible is that the CEs are never more than seven iterations away from one another. This is because of the ADVANCE instruction's built-in await, which causes a CE to wait until the immediately prior iteration has executed its CADVANCE (see discussion below). Accordingly, only three bits are needed to keep track of how far the current iteration is from the prior iteration responsible for the dependency. These three bits are stored in the SYNC register (FIG. 12). The three bits can be thought of as the least three significant bits of a virtual 32-bit synchronization register containing the number of the lowest iteration to have not executed its CADVANCE. Put another way, it is the least three significant bits of the iteration that has not yet cleared the dependent region (for once an iteration executes its CADVANCE no later iteration is dependent on it).</p><p>The single bit PAST register is provided to keep track of whether the SYNC register has been advanced past the current iteration CURRO. If that occurs, PAST is locally set to 1. PAST is actually set to 1 when the ADVANCE instruction is executed by its associated CE. PAST is cleared at the end of the iteration, when CREPEAT is executed. Unlike the 3-bit SYNC registers, which are simultaneously altered in all CCUs so as to be identical across the concurrency complex, the PAST bit is set locally.</p><p>3. The CADVANCE Instruction</p><p>The other synchronization instruction, CADVANCE, is responsible for incrementing the synchronization register. CADVANCE has one argument, the synchronization register to be advanced. When a CE executes a CADVANCE, it initially waits until its CCU determines that the immediately preceding iteration has executed its CADVANCE. Then it causes the specified synchronization register to be advanced by one.</p><p>The CADVANCE instruction has what amounts to a built-in CAWAIT with zero offset; it causes the CE to wait until the CADVANCE instruction has been executed in the immediately preceding iteration. This is accomplished using the ADVOK lines. The synchronization register specified in the CADVANCE instruction is placed on the SSEL lines, thereby selecting the corresponding ADVOK line at multiplexer 116 (ADVOK0 also bypassed the multiplexer because of its use in serializing traps; see discussion below). When the selected ADVOK line is asserted, the effect is to set the WAIT line to low, signalling the CE to resume processing. The ADVOK line is asserted when comparator 108 (FIG. 12) senses its B input is zero, an event that occurs when SYNC=CURRO (i.e., when the synchronization register has been incremented to this iteration).</p><p>After the WAIT line goes low, the CE asserts the DO CADVANCE instruction using the DO and RSEL lines. The DECODER logic array responds by asserting ADVO on the ADV line for the specified synchronization register (there are eight ADV lines, one for each register). The ADVO assertion has a local effect and a global effect. Locally, the assertion of ADVO sets PAST to 1 (because the fact that CADVANCE has been executed means that the synchronization register has been incremented past the current outermost iteration number). Globally, the asserted ADVO line is received as ADVI, and causes the respective SYNC register to be incremented by one in all CCUs in the complex. It is possible to provide just eight ADV lines because only one CE can possibly assert any one ADV line during the same cycle.</p><p>The fact that CADVANCE sets the PAST bit to 1 assures that further CAWAIT and CADVANCE instructions for the same dependency encountered in the same iteration will be ignored (branching within a concurrent loop may make such further occurrences possible). To accomplish this, all eight PAST bits are brought to the DECODER logic array where the DO CADVANCE instruction is decoded. If the PAST bit for the dependency specified in the CADVANCE instruction is set to 1, ADVO is not asserted. Also, the fact that PAST is set to 1 means the WAIT line is immediately set to low when either a CAWAIT or CADVANCE is encountered, because both the AWTOK and ADVOK lines are automatically asserted by OR gates 109, 111 (FIG. 12).</p><h4>J. Concluding Concurrent Processing</h4><p>Concurrent processing is concluded by execution of one of two instructions: CREPEAT or CQUIT.</p><p>1. Executing CREPEAT in the Last Iteration</p><p>As discussed previously, execution of CREPEAT will conclude concurrent processing if the iteration being processed is the maximum iteration (CURR equals MAX), as in that event EQMAX will have been asserted at the start of the iteration. Assertion of EQMAX has the immediate effect, even before the conclusion of that iteration, of asserting SERIAL (CEREAL is asserted by the CONTROL logic, causing latch 112 in the CSTAT register (FIG. 11A) to assert SERIAL). The assertion of SERIAL gives the CE advance warning that concurrent processing will end with the next CREPEAT. The CE executing CREPEAT is made to wait by the WAIT logic array until the rest of the CEs have put themselves into the idle state (by fetching iteration numbers that exceed the contents of CMAX). The WAIT logic array senses the idle state of the other CEs by looking at the ANYACT line. When the CREPEAT is actually executed, the assertion of the DO CREPEAT instruction by the CE concludes concurrent processing in this CE. The CONTROL logic array, sensing both EQMAX and DO CREPEAT, asserts CLRINLOOP, CLRVECTOR, and CLRSERTRAP, thereby clearing the INLOOP, VECTOR, and SERTRAP status bits.</p><p>2. Executing CQUIT</p><p>When a loop includes an instruction to branch out of the loop prior to completion of the prescribed number of iterations, a CQUIT instruction is inserted at the address to which the code may branch. A premature branch from a loop creates a potential problem for concurrently executed loops, because it is possible that the branch may be taken in an iteration preceding iterations for which instructions have already been executed by other CEs. As these further iterations would never have been processed if processing had been serial, there is the possibility that concurrent processing will change the result. There are at least three ways that such a change of result could occur: (1) data is stored into global memory in the subequent iterations changing the result of an operation outside the loop; (2) a subsequent iteration is first to execute a CQUIT; and (3) a trap is taken in the subsequent iterations (e.g., a divide by zero that would not have occurred had processing been serial).</p><p>Preventing the first potential difficulty--store operations that should not have occurred--must be handled by the software. One approach is to use the cactus stack for all store operations until there remains no possibility of a CQUIT being executed in a prior iteration, and to then transfer the private copies from the cactus stack to global memory.</p><p>The second difficulty--out of order CQUITS--is handled using the CAWAIT instruction. A zero offset CAWAIT on the CS0 synchronization register is inserted just before the CQUIT instruction (the branch from the loop is made to the CAWAIT). Also, the CSTARTST instruction (CSTART with serialized traps) is used instead of the CSTART instruction (and the CVECTORST instead of the CVECTOR), to cause automatic incrementing of the CS0 register by the CREPEAT instruction. These steps ensure that CQUITS are executed in order.</p><p>The third difficulty--unintended traps--is handled also by using the CSTARTST or CVECTORST instructions (instead of the CSTART or CEVECTOR) instructions. These instructions differ from the others only in that they cause the SERTRAP status bit to be set during the CSTART sequence. When the SERTRAP bit is set, a CE encountering a trap waits before Proceeding further until TRAPOK is asserted, telling it that the trap may be taken because no lower iteration capable of branching out of the loop is still executing.</p><p>TRAPOK is controlled by synchronization register CS0. If the iteration contained in CS0 equals the current iteration CURRO, a condition measured by comparators 106, 108 (FIG. 12), ADVOK0 is asserted. Register CS0 is advanced by CREPEAT (the very last instruction in a loop) if SERTRAP is 1, and thus the register contains the three least significant bits of the lowest iteration to have been completed. ADVOK0 is fed directly into WAIT logic array 102 (FIG. 6), which responds by asserting TRAPOK. TRAPOK is also asserted by WAIT if SERTRAP is zero, as that means trap serialization has not been specified. (TRAPOK is also asserted if DETACHED is set to 1, as that means there is no concurrent processing.)</p><h4>K. Vector Concurrent Processing</h4><p>The CEs in the concurrency complex can be used not only for concurrently processing iterative constructs such as DO loops but also for concurrently processing portions of a vector operation. For example, if a vector multiply operation is required, and the vector length is 100, a concurrency complex of three CEs (e.g., CE0, CE1, CE2) can divide the vector so that two CEs perform 34 of the vector operations and the third CE performs 32 of the operations. All of the operations performed by each CE are done in a single \"iteration\". The division of the vector between CEs can be done vertically or horizontally. In a vertical division, the first 34 vector elements of the example are processed by the first CE, the next 34 by the second CE, and the final 32 by the third CE. In a horizontal division, the first CE performs operations on vector elements 1, 4, 7, and so on; the second CE, on elements 2, 5, 8, and so on; the third CE, on elements 3, 6, 9, and so on. Which type of division is best is a software matter, and is typically determined by a compiler.</p><p>Five vector concurrency instructions are used by the CEs to calculate the parameters needed for the CEs to perform the concurrent processing of a vector operation. The Parameters are calculated by each CE using the NUM and VPN fields provided by its CCU, and then stored in a CE data register. In the calculations, the CE sets NUM and VPN to zero if either NESTED or DETACHED is asserted by the CCU.</p><p>In a horizontal division of the vector, three parameters are calculated: length, offset, and increment.</p><p>Length is the number of vector elements to be operated on by each CE. It is calculated using the VLH instruction, according to the formula:</p><p></p><pre listing-type=\"equation\" xml:space=\"preserve\"><!--Greenbook equation-->Length=CEIL[(N-VPN)/(NUM+1)]</pre><p>where N is the total number of vector elements and CEIL means that the result is rounded up to the next highest integer if not already an integer (VPN and NUM are set to zero in the calculation if NESTED or DETACHED are 1). In the example, CE0 is given a length of 34, and CE1 and CE2 are given lengths of 33. (In the actual implemenation, the calculation is done as follows: VPN is subtracted from N and one of two operations are performed. If NUM is 0, 1, 3, or 7 (meaning the number of CEs is a Power of two), NUM is added to (N-VPN) and the result is shifted right by 0, 1, 2, 3 bits (according to the power of two). If NUM is 2, 4, 5, or 6, the (N-VPN) term is multiplied by 2/3, 2/5, 2/6 or 2/7, respectively (where each fraction is rounded toward zero before use), the result is shifted right one bit, the fraction is truncated, and 1 is added to the result.)</p><p>Increment is the spacing or stride between the vector elements to be operated on by the CE. It is calculated using the VIH instruction, according to the formula:</p><p></p><pre listing-type=\"equation\" xml:space=\"preserve\"><!--Greenbook equation-->Increment=VINCR(NUM+1)</pre><p>where VINCR is the increment of the original vector. In the example, where VINCR is 1, all CEs are given an increment of 3. (In the actual implementation, the multiplication is done by shifting and adding.)</p><p>Offset is the location in the vector where the CE is to begin. It is calculated using the VOH instruction, according to the formula:</p><p></p><pre listing-type=\"equation\" xml:space=\"preserve\"><!--Greenbook equation-->Offset=VINCR(VPN)</pre><p>where VINCR is the increment of the original vector. In the example, CE0 is given an offset of 0, CE1 an offset of 1, and CE2 an offset of 2. (In the actual implementation, the multiplication is done by shifting and adding.)</p><p>When the vector division is vertical, only the first two of these three parameters need be calculated, as increment is one for all CEs.</p><p>Length is calculated using the VLV instruction, according to the formula:</p><p></p><pre listing-type=\"equation\" xml:space=\"preserve\"><!--Greenbook equation-->Length=MIN[CEIL[N/(NUM+1)], N-VPN(CEIL[N/(NUM+1)]]</pre><p>where CEIL is the same function described above and MIN is the minimum of the two parameters within the brackets. In the example, CE0 and CE1 are given lengths of 34, and CE2 a length of 32. (In the actual implementation, the CEIL[N/(NUM+1)] term is formed using the same methods used for the combined division-and-CEIL operation in the VLH instruction. The multiplication by VPN is done by shifting and adding. The minimum is found by comparing the two quantities, and choosing the smaller of the two.)</p><p>Offset is calculated using the VOV instruction, according to the formula:</p><p></p><pre listing-type=\"equation\" xml:space=\"preserve\"><!--Greenbook equation-->Offset=CEIL[N/(NUM+1)](VPN)</pre><p>In the example, CE0 is given an offset of 0, CE1 an offset of 34, and CE2 an offset of 68. (In the actual implementation, the calculation is performed using the same method as for the second term of the VLV equation.)</p><p>Actual concurrent processing is begun when a CVECTOR (or CVECTORST) instruction is executed at the start of the vector \"loop\", i.e., before the first of the vector operations to be processed concurrently. The parameter calculation instructions (e.g., VLH, VOH, VIH) follow the CVECTOR instruction.</p><p>The sequence of CCU instructions initiated by a CVECTOR instruction is largely identical to that initiated by a CSTART. The difference is that the VECTOR status bit is set to 1 in all CCUs in the complex during the third machine cycle, at the same time as INLOOP is set to 1. The fact that it is a CVECTOR instruction, rather than a CSTART, is communicated to the other CEs using two bits of the CCUBUS, referred to as CC(11:10). These two bits provide a code that the CCUs use to distinguish between the four types of instructions that initiate concurrent processing (CSTART, CSTARTST, CVECTOR, and CVECTORST). The two bits are only used during the DO CSTART instruction in the second machine cycle, a time when the CCUBUS is not being used.</p><p>Vector concurrent processing is concluded using a CREPEAT instruction following the last vector operation in the \"loop\". As there is only one \"iteration\" following a CVECTOR instruction, a mechanism is needed to force an end to concurrent processing upon execution of the first CREPEAT. This is provided by multiplexer 105 (FIG. 9), which supplies to the Y input of comparator 110 a 32-bit number containing all zeroes except for NUM in the least three significant bits (this instead of the contents of CMAX, as in the CSTART case). This causes the gate following comparator 110 to assert GTMAX at the start of the second \"iteration\", thereby setting INLOOP to 0 to prevent continued execution of that second \"iteration\". CCURR is set to a number in excess of NUM by assertion of the RDY lines following completion of the first \"iteration\".</p><h4>L. Nested Concurrent Loops</h4><p>The system accommodates subroutine calls within concurrently-executed loops, including subroutines that themselves call for concurrent execution of a loop. The latter occurs because subroutines can be compiled independently of the program calling them, making it impossible to know at compile time whether a particular subroutine will be called from within a concurrently-executed loop.</p><p>A concurrent loop within another concurrent loop is known as a nested concurrent loop, and is not executed concurrently. Provision is made for executing nested loops serially on the same processor that encounters them. It is possible to have a series of nested loops, each within the other. In all cases, however, only the outermost loop is executed concurrently. All inner loops, whether or not they contain instructions for concurrent execution, are executed serially on the same processor.</p><p>The NESTED and INLOOP status bits are used to keep track of whether it is the outermost or a nested concurrent loop that is being executed. INLOOP is set to \"1\" when the first CSTART is encountered during execution, signifying the start of an outermost concurrent loop. NESTED is set to \"1\" when a CNEST is encountered after INLOOP has already been set to \"1\".</p><p>At the beginning of a nested loop, the CCU clears the the current iteration register (CCURR). Subsequent iterations of the nested loop are assigned by adding 1 to the value of CCURR at the end of each iteration (assertion of the NESTED status bit alters the operation of the logic incrementing CCURR).</p><p>In order that trap serialization (see earlier discussion) may continue even during execution of a nested loop, the least three significant bits of the current iteration of the outermost loop are saved as CURRO in the CSTAT register (when NESTED is asserted, CURRO is frozen at the value it had during the last iteration of the outermost loop; ADDCURRO is not asserted by the CONTROL logic array upon execution of a CREPEAT in a nested loop). The three bits of CURRO are compared to the contents of synchronization register CS0, and TRAPOK is asserted, all in the same manner as if the processor were executing an outermost concurrent loop. Thus, if a trap is encountered during execution of a nest loop, and the SERTRAP bit is set, indicating serialization of traps, the CE waits until TRAPOK is asserted.</p><p>The values of four registers (CCURR, CMAX, CGSP, CSTAT) must be saved at the time a nested concurrent loop begins in order for the CE to properly continue processing at the conclusion of that nested loop. A CNEST instruction causes the four values to be saved (at a memory location specified by the operand), and must be placed before the CSTART of any concurrent loop that could possibly be executed as a nested loop (one CNEST placed before the first CSTART may suffice for a series of such concurrent loops). A CUNNEST instruction causes the four values to be written (from the memory location specified in the operand, ordinarily the same location as specified in the previous CNEST instruction) into the corresponding registers, and must follow the CQUIT or CREPEAT instruction of the nested loop (or the last of a series of nested loops). Ordinarily, different memory locations are specified by each pair of CNEST and CUNNEST instructions, so that loops may be nested within one another.</p><p>The values of CCURR and CMAX are saved because those registers will be used during execution of the nested loop, and the values will be needed when processing of the outermost loop resumes.</p><p>The value of CGSP is saved for a similar reason. The global stack pointer must be preserved so that it can be supplied to the CE that resumes serial processing. It is saved prior to execution of a nested loop because the CSTART sequence, which is the same for a nested loop as for an outermost loop, causes the current value of the CE's stack pointer to be written into the CGSP register. In the case of an outermost concurrent loop, that current value of the stack pointer is preserved in the CGSP register, and a private stack is assigned to the CE later in the CSTART sequence (see next section), by having the CE read the value of the CCSP register. But in the case of a nested loop, the current value of the CE's stack pointer does not need to be preserved, and must be given back to the CE, as the nested loop will be processed on the private stack assigned to that CE for the outermost loop. This is accomplished by causing the CE to read from CGSP when NESTED is set, and from CCSP when NESTED is not set (this in the function of the PIDEC logic array shown in FIG. 9).</p><p>The contents of the CSTAT register are saved in order to preserve the state of NESTED prior to execution of the nested loop. This is necessary for proper handling of a series of nested loops, each within another. Each time a CUNNEST instruction is executed, signifying the completion of one level of nesting, the prior value of NESTED is restored to the CCU, so that the CCU will be able to determine whether it has returned to the outermost loop (in which case NESTED will be restored to 0) or to a higher level nested loop (in which case NESTED will remain set to 1).</p><p>During execution of a nested loop, the value stored in the CNEXT register continues to be updated when other CEs assert their ready lines (which will only occur when a CE bids for a new iteration in an outermost concurrent loop). But the contents of CNEXT are not used during execution of the nested loop, as all iterations of a nested loop are executed by the same CE that initiated the loop. A new iteration assignment is made upon execution of a CREPEAT in the nested loop simply by incrementing the contents of CCURR by one. (This is accomplished as follows: The multiplexer at the input to incrementer 148 (FIG. 8) feeds the output of CCURR, rather than the output of CNEXT, to the incrementer when NESTED is asserted; MASK logic array 140 masks all of the ready lines when NESTED is asserted, so that only one line (the line driven by NESTED itself) is asserted at the input to incrementer 148.)</p><p>A further change brought about by setting the NESTED bit is that the VPN and NUM outputs from the CSTAT register are set to zero (FIG. 11B), so that the computations made upon execution of the five vector concurrency instructions (e.g., VLH, VOH, VIH) result in vector instructions being executed serially (all vector elements processed on the CE executing the instructions).</p><h4>M. Cactus Stack</h4><p>Each CE in the concurrency complex is assigned a private stack (collectively referred to as the cactus stack), for storing data unique to a single iteration of a concurrent loop. Such unique data is of two types: subroutine arguments (and return addresses) and temporary variables. The cactus stack is created during the CSTART sequence. The CE executing the CSTART instruction builds the cactus stack by causing its global stack pointer (GSP) to be written into the CGSP registers of all the CEs in the complex, and by causing all of the same CEs to read from their CCUs a virtual stack pointer (CVSP), which in the case of an outermost concurrent loop (NESTED not set) is the contents of the cactus stack register CCSP. The actual addresses assigned as cactus stack pointers are unique to each CE, and are established by the operating system, which writes the addresses into the CCSP register using a CSAVE and CRESTORE instruction prior to concurrent processing. The virtual stack pointer is read by asserting the appropriate RSEL code and the output enable bit OE (FIG. 9). If NESTED is not set, the PIDEC logic array selects the contents of CCSP. If NESTED is set, it selects the contents of CGSP (which, in a nested loop, contains the current value of the stack pointer on the CE's cactus stack).</p><h4>VI. Examples of Concurrent Processing</h4><p>FIG. 14 illustrates several characteristics of concurrent execution. Initially execution is serial; that is, only one CE is executing instructions, and the remaining CEs are idle. Here the active CE is CE5, but could be any CE. Concurrent execution begins when the active CE executes a CSTART instruction. Each of the CEs is given an iteration number, starting with iteration 0. The CSTART instruction specifies the maximum iteration, here 20.</p><p>When a CE finishes an iteration, it executes a CREPEAT instruction to begin the next iteration, if there is one. An iteration is assigned to a CE as soon as it asks for one. Note that iterations can be different lengths if they include conditional code.</p><p>If there are no more iterations to execute when the CREPEAT instruction is executed, one of two things happens. If the CE was executing an iteration other than the last one, it simply becomes idle. This is the case for CE0 after it finishes iteration 16. If, on the other hand, the CE was executing the last iteration, it waits for all the other CEs to become idle before continuing serial execution. This is the case for CE2 after it finishes iteration 20.</p><p>This code would take 50 time units to execute on a single CE. With concurrent execution it takes 8 time units. The speed up is 50/8=6.25. Typically N CEs will speed up code by a factor somewhat less than N when the number of iterations is not a multiple of N or when the iterations take different times to execute. The speed up approaches the number of CEs, however, as the number of iterations increases.</p><p>Giving a CE an iteration means that at the start of an iteration the iteration number CURR is placed in register D7 of the CE which is to execute the iteration. The first iteration for any CE is the virtual processor number VPN of the CE.</p><p>A CE learns what code it is to execute during the CSTART sequence following execution of a CSTART by one CE. Using the CCUs and the CCUBUS, all CEs are started with a program counter equal to the address of the instruction after the CSTART instruction. The CREPEAT instruction is a conditional branch instruction. If there is another iteration, the CE takes the branch and is given a new iteration. If there is not another iteration, the CE falls through or becomes idle, depending on whether it was executing the last iteration or not Table 1 shows a concurrent loop:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 1                                                     \n______________________________________                                    \n     \u2191                                                              \n     \u2191Serial code executed in a single                              \n     \u2193CE                                                           \n     \u2193                                                             \n     \u2193                                                             \n     cstart &lt;ea&gt;                                                          \n     \u2191              \u2191                                         \n     \u2191Loop prologue;                                                \n                          \u2191                                         \n     \u2193code executed once                                           \n                          \u2191                                         \n     \u2193per CE       \u2191Concurrent code                          \n     \u2193             \u2191executed in                              \nTop: \u2191              \u2193multiple CEs                            \n     \u2191Loop body;    \u2193                                        \n     \u2193code executed once                                           \n                          \u2193                                        \n     \u2193per iteration                                                \n                          \u2193                                        \n     \u2193             \u2193                                        \n     crepeat Top          \u2193                                        \n     \u2191                                                              \n     \u2191                                                              \n     \u2193Serial code executed in a single                             \n     \u2193CE                                                           \n     \u2193                                                             \n______________________________________                                    \n</pre><p>The loop prologue, code executed once per CE, can load registers and perform other operations which need not be executed on every iteration. Table 2 presents a simple Fortran loop:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 2                                                     \n______________________________________                                    \nFortran code:                                                             \n          DO 1 I=1,N                                                      \n         I A(I) = I+J                                                     \nCode:    Serial code                                                      \n         movl    N,d2        Start concurrent                             \n         subl    #1,d2        execution,                                  \n         cstart  d2           N iterations                                \n          movl    J,d6       Load J (Once per CE)                         \n  Top:    movl    d7,d1      iteration count                              \n          addq    #1,d1       +1 = I \u2192 d1                          \n          addl    d6,d1      I + J \u2192 d1                            \n          movl    d1,A:1[a7:1:4]                                          \n                             (d1) \u2192 A(I)                           \n         crepeat Top         Branch if more iterations                    \n         Serial code                                                      \n______________________________________                                    \n</pre><p>The loops of Tables 1 and 2 have independent iterations; that is, the iterations may be done in any order without changing the results. The more difficult case is a loop with iterations that depend on each other and that must, therefore, be synchronized to give correct results. Table 3 shows a dependency that requires synchronization.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 3                                                     \n______________________________________                                    \n ##STR1##                                                                 \n______________________________________                                    \n</pre><p>Here a value stored in one iteration is loaded by the next iteration. To get the right result the load must happen after the store. Before iteration I may load X, it must wait until iteration I-1 has stored X. To synchronize this dependency, two instructions need to be inserted in the code. A \"Can I go ahead?\" instruction called CAWAIT and a \"Go ahead!\" instruction called CADVANCE. An example is shown in Table 4:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 4                                                     \n______________________________________                                    \nFortran:          DO 1 I=1,N                                              \n                  . . .                                                   \n                  X = X + exp                                             \n       1          CONTINUE                                                \nCode:  movl        N,d2        Start concurrent                           \n       subl        #1,d2        execution,                                \n       cstart      d2           N iterations                              \n  Top:  . . .                                                             \n Code to put exp in fp1                                                   \n cawait         csl,#0    Can I go ahead?                                 \n fadds          X,fp1     X + exp                                         \n fmoves         fp1,X      \u2192 X                                     \n cadvance       csl       Go ahead!                                       \n crepeat        Top                                                       \n______________________________________                                    \n</pre><p>The CAWAIT instruction causes the CE that executes it to wait until the CE executing the previous iteration has performed a CADVANCE. Then X can safely be fetched from memory. After X is stored the CADVANCE instruction signals the CE excuting the next iteration that it can proceed. The CS1 in the CAWAIT and CADVANCE instructions is one of the eight synchronization registers CS0-CS7. Each can be used to synchronize a different dependency in a loop. In the unlikely event that a loop has more dependencies than there are synchronization registers, two dependencies can be combined with a CAWAIT before the first and a CADVANCE after the second. The 0 in the CAWAIT instruction is an offset in the range 0-7. Normally a dependency will be from one iteration to the next and an offset of zero will be used. Sometimes, however, the dependency will span two or more iterations, as in the example of Table 5:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 5                                                     \n______________________________________                                    \nFortran:                                                                  \n          DO 1 I=1,N                                                      \n          . . .                                                           \n          A(I) = A(I-3) + exp                                             \n        1  CONTINUE                                                       \nCode:   movl     N,d2           Start concurrent                          \n        subl     #1,d2           execution,                               \n        cstart   d2              N iterations                             \nTop:      . . .                                                           \n        Code to put exp in fp1                                            \n        cawait cs1,#2       Wait for iteration                            \n                            I-3                                           \n        fadds  A-12:1[d7:1:4],fp1                                         \n                            A(I-3) + exp                                  \n        fmoves fp1,A:1[d7:1:4]                                            \n                               \u2192 A(I)                              \n        cadvance                                                          \n               cs1          Go ahead!                                     \ncrepeat      Top                                                          \n______________________________________                                    \n</pre><p>Four of the concurrency instructions have been discussed so far. The fifth instruction, CQUIT, implements loop exit prior to the last iteration. An example is given in Table 6:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 6                                                     \n______________________________________                                    \nFortran:                                                                  \n           DO 1 I= 1,12                                                   \n          1 IF (A(I).EQ.X)GO TO 2                                         \n           . . .                                                          \n          2 J=I                                                           \n   . . .                                                                  \nCode:   cstartst #11        Start concurrent                              \n                            execution                                     \n         fmoves    X,fp1        Load register -                           \n                                once par CE                               \nTop:     fcmps     A:1[d7:1:4],fp1                                        \n                                  A(I) = X ?                              \n         fbeq      Two --A      If so, branch                             \ncrepeat      Top            Next iteration                                \n   . . .                                                                  \nTwo --A:                                                                  \n        cawait   cst,#0         Wait for lower                            \niterations                                                                \n        cquit                   Exit concurrency                          \n        addq1    #1,d7          Iteration count + 1                       \n        mov1     d7,I              = I                                    \nTwo:    mov1     I,J            J=I                                       \n______________________________________                                    \n</pre><p>Table 7 illustrates how the code of Table 6 is executed on a four CE concurrency complex when X=1 and A=[0, 2, 4, 6, 8, 7, 5, 3, 1, 2, 1, 9]. For simplicity, it is assumed that each instruction takes one unit of time.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 7                                                     \n______________________________________                                    \n     CE:                                                                  \nTime 0          1          2        3                                     \n______________________________________                                    \ncstarst          (idle)     (idle)   (idle)                               \n2    0fmoves    1fmoves     2fmovos  3fmoves                              \n3    0fcmps     1fcmps      2fcmps   3fcmps                               \n4    0fbeq (\u22601)                                                     \n                1fbeq (2\u22601)                                         \n                            2fbeq (4\u22601)                             \n                                     3fbeq (6\u22601)                    \n5    0crepeat   1crepeat    2crepeat                                      \n                                     3crepeat                             \n6    4fcmps     5fcmps      6fcmps   7fcmps                               \n7    4fbeq (8\u22601)                                                    \n                5fbeq (7\u22601)                                         \n                            6fbeq (5\u22601)                             \n                                     7fbeq (3\u22601)                    \n8    4crepeat   5crepeat    6crepeat                                      \n                                     7crepeat                             \n9    8fcmps     9fcmps     10fcmps  11tcmps                               \n10   8fbeq (1=1)                                                          \n                9fbeq (2\u22601)                                         \n                           10beq (1=1)                                    \n                                    12fbeq (9\u22601)                    \n11   8cawait    9crepeat   10cawait 11crepeat                             \n12   8cquit      (idle)     (idle)   (idle)                               \n13                                                                        \naddq1                                                                     \n      (idle)     (idle      (idle)                                        \n14                                                                        \nmov1  (idle)     (idle      (idle)                                        \n15                                                                        \nmov1  (idle)     (idle)     (idle)                                        \n______________________________________                                    \n</pre><p>The iteration number and the mnemonic executed by each CE is listed at each time step. The first thing to notice is that since each iteration is identical, the CREPEAT instructions occur on the same cycle and do not have to wait. The next thing to notice is that iterations are started even though it is not known if a previous iteration will be the last. Iterations 9, 10, and 11 were started even though 8 is the last actual iteration. Starting the later iterations is not harmful so long as they do nothing to change the result. In the example, all they do is fetch and test, and thus no problem can occur. A problem could result, however, if store operations are carried out in these surplus iterations.</p><p>It is necessary to make sure that the correct iteration performs the CQUIT. CE2 must not be allowed to think that iteration 10 is the last one just because A(11)=X. To assure that the correct iteration executes the CQUIT, the loop is started with a CSTARTST instruction, which causes the CREPEAT instruction to perform a CADVANCE on synchronization counter CS0, which is also called CST (see below). Also, prior to the CQUIT instruction a CAWAIT CS0 instruction is inserted. This guarantees that the earliest iteration will exit, even if a later iteration tries to exit earlier.</p><p>Software should be written so as not to store results if it is not certain whether an earlier iteration will execute a CQUIT. That is why, in the example, the storing of the loop index was done after the CQUIT instruction.</p><p>Another side effect of beginning iterations even though a CQUIT may be executed in an earlier iteration is that a trap, e.g., a divide by zero or a page fault, may be encountered in these iterations. An example is given in Table 8:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 8                                                     \n______________________________________                                    \n        cstartst N                                                        \n         . . .                                                            \nTop:     . . .                                                            \n         If . . . Then cquit                                              \n                        On iteration 10                                   \n         . . .                                                            \n         A = B/C        C = 0 on iteration 11                             \n         . . .                                                            \n        crepeat Top                                                       \n______________________________________                                    \n</pre><p>The divide by zero trap in iteration 11 should not be allowed to happen before the CQUIT in iteration 10. To accomplish this, the CSTARTST variant of CSTART is again used (the \"ST\" suffix standing for serialize traps). Trap serialization is only necessary in concurrent loops with a CQUIT instruction. CSTARTST loops implicitly use synchronization counter CS0 (which is also called CST as a reminder that it is used to serialize traps). The use of the CSTARTST instruction makes advance of CST implicit in the CREPEAT instruction and forces an implied AWAIT on CST when a trap is encountered (until TRAPOK is asserted).</p><p>A CQUIT may be used without a CAWAIT CS0, #0 preceding it. This is called a preemptive CQUIT. Any processor executing a preemptive CQUIT will stop the concurrent loop, even if it is not the one executing the lowest iteration. This is valuable in certain search programs to end searching when any CE has found the object of the search.</p><p>A concurrent loop may be used around a call to a subroutine whether or not the subroutine itself contains a concurrent loop. In other words, concurrent loops may be nested; however, the inner loop(s) each execute serially on a single CE. For this reason, a single subroutine would not normally contain nested concurrent loops within it. The code in Table 9 is used for a routine that contains a concurrent loop and may be called from either a concurrent loop or from serial code:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 9                                                     \n______________________________________                                    \nCalling routine: Called routine:                                          \n______________________________________                                    \n       . . .             S:     . . .                                     \n       cstart    N1             cnest  -(sp)                              \n        . . .                   . . .                                     \nT1:     . . .                   cstart N2                                 \n        jsr      S               . . .                                    \n        . . .            T2:     . . .                                    \n       crepeat   T1              . . .                                    \n       . . .                    crepeat                                   \n                                       T2                                 \n       jsr       S              . . .                                     \n. . .            more concurrent loops                                    \n                      . . .                                               \n                      cstart   Nn                                         \n                       . . .                                              \n               Tn:     . . .                                              \n                       . . .                                              \n                      crepeat  Tn                                         \n                      . . .                                               \n                      cunnest  (sp)+                                      \n                      . . .                                               \n                      rts                                                 \n______________________________________                                    \n</pre><p>Note that the instructions CNEST and CUNNEST are used at the beginning and end of a subroutine that has one or more concurrent loops. These are needed to save and restore the current and final iteration for the outer loop. In the example of Table 9, the first subroutine call (jsr) in the calling routine appears within a concurrent loop, meaning that each execution of a concurrent loop within the subroutine is performed serially by the CE that called the subroutine. The second (jsr) appears outside the concurrent loop, and thus the concurrent loops in the subroutine are executed concurrently on multiple CEs.</p><h4>VII. Backplane Switch</h4><p>The CEs are connected to the cache quadrants by backplane switch 14, as shown in FIG. 15.</p><h4>A. Circuitry</h4><p>Forty-eight control lines 200 extend across the backplane directly from the CEs to the cache quadrants, without passing through the backplane switch. Six control lines are connected to each CE, for a total of forty-eight control lines, all of which are are connected to each quadrant. The six control lines for each CE are: CSTRTL, CBUSYL, CWAITL, CADR5, CADR4X3, and CDTPAR. Collectively, the six control lines are denoted AC for CE0, BC for CE1, CC for CE2, and so on. CBUSYL, CWAITL, and CDTPAR are implemented as open-collector signals.</p><p>Ninety-six lines extend to the backplane switch from each CE and each cache quadrant: sixty-four bidirectional data lines CDT(63:0), twenty-six address lines CADR(27:6,4,2:0), an address parity line CADRPAR, three CE operation lines CEOP(2:0), and two data-length lines CDLN(1:0). Each CE and cache quadrant also provides the backplane switch with enable lines, e.g., AE and WE, for enabling data and addresses to be read from the ninety-six bidirectional lines connected to the switch. The cache quadrants provide the backplane switch with direction signals WD, XD, YD, ZD, which define the direction of data being transferred through the switch, and two sets of three-bit CE selection signals WS(2:0), XS(2:0), YS(2:0), ZS(2:0), which specify the CE to which, or from which, a transfer is being made. Only one set ofsselection signals is shown in the drawings, but separate 3-bit selection signals are provided for addresses and data.</p><p>The backplane switch consists of twenty-four identical four-line switches 190, which together provide the capability of switching ninety-six lines between the CEs and cache quadrants. The switches 190 physically reside on backplane 192 (FIG. 18), into which the CE boars and cache boards are plugged. Each four-line switch is implemented using a single CMOS gate array (e.g., Fujitsu 2600).</p><p>A block diagram of one four-line switch 190 is shown in FIG. 17. Four of the ninety-six lines passing through backplane 14 are connected to each four-line switch 190, for each cache quadrant and CE (e.g., W3, W2, W1, W0 for quadrant W, and A3, A2, A1, A0 for CE0). The enable lines (e.g., WE and AE), direction lines (e.g., WD), and CE selection lines (e.g., WS2, WS1, WS0) are also connected to the four-line switch.</p><p>Each four-line switch has three functional sections: a cache-ports section 202, selection section 204, and a CE-ports section 206.</p><p>The cache and CE-ports sections serve to divide the four bidirectional lines from each cache quadrant and CE into eight unidirectional lines, four going toward the CE (the \"IN\" lines) and four coming from the CE (the \"OUT\" lines). For example, the four bidirectional lines A(3:0) from CE0 are divided into four lines AIN(3:0) going to the CE and four lines AOUT(3:0) coming from the CE. The logic 208, 209 used for this function is shown in FIG. 16 for one of the four-lines from each cache quadrant and CE. Each line (e.g., W0) entering the switch (sixteen from the cache quadrants and thirty two from the CEs) passes through buffer gate 210 and inverter 212, and each line leaving the switch passes through three-state gate 214, enabled when the corresponding enable line is low (cache ports) or high (CE ports). For example, on the cache side, bidirectional line W0 passes through gates 210, 212 and emerges as WIN0; in the opposite direction, WOUT0 passes through three-state gate 214 when enable line WE is low. On the CE side, bidirectional line A0 passes through gates 210, 212 and emerges as AOUT0, and AIN0 passes through three-state gate 214 when enable line AE is high. Gates 210, 212, 214 are provided for each of the cache ports and CE ports connected to the backplane switch.</p><p>The selection section 204 of the switch serves to connect selected cache output lines (e.g., WIN0) to selected CE input lines (e.g., AIN0) when the transfer is to the CE, and to connect selected CE output lines (e.g., AOUT0) to selected cache input lines (e.g., WOUT0), when the transfer is from the CE. The selections are controlled by the cache, using the direction lines (e.g., WD) and the three-bit CE selection lines (e.g., WS(2:0)).</p><p>Data transferred from a cache port to a CE port is selected at the CE port by a four-bit-wide selector 216 consisting of four OR gates 218 driving a NAND gate 220 (FIG. 16). The OR gates select one of four cache output signals WIN0, XIN0, YIN0, ZIN0 under control of four selection signals WSELA, XSELA, YSELA, ZSELA, which are generated by decoding the CE selection signals WS, XS, YX, ZS at decoder 222. When a selection signal is low, its corresponding cache output signal is selected (e.g., WSELA set low, causes WIN0 to be connected to AIN0). Proper operation of the selector requires that no two cache ports access the same CE port at the same time; this is assured by the CE-cache protocol (see below). For clarity, only one selector 216 and decoder 222 are shown in FIG. 16. A total of thirty two, one for each of the four lines connected to each CE, are provided in each four-line switch.</p><p>Data transferred from a CE port to a cache port is selected at the cache port by an eight-to-one multiplexer 230 consisting of decoder 224, which converts a three-bit CE selection signal (e.g., ZS) to eight selections signals (e.g., ASELZ to HSELZ), and gates 226, 228, which use the eight selection signals to connect one of the eight CE output signals (AOUT0 to HOUT0) to a cache port (e.g., ZOUT0). The CE-cache protocol (see below) assures that only one cache quadrant (W, X, Y, or Z) ever accesses the same CE at any one time. Only one multiplexer 230 is shown in FIG. 4. A total of sixteen, one for each of the four lines connected to each cache quadrant, are provided in each four-line switch.</p><h4>B. Operation</h4><p>A CE initiates a cache operation by asserting its CSTRTL and supplying the two address bits CADR5 and CADR4X3 specifying which of the four interleaved quadrants of the cache are involved in the operation. CADR5 is the fifth least significant bit of the memory address involved in the operation being initiated by the CE. CADR4X3 is the exclusive-OR combination of the third and fourth bits of the memory address. The reason that these two bits are combined in addressing the cache quadrants has to do with the way in which the cache quadrants ae interleaved (see discussion of cache). If only two cache quadrants are in use (e.g., if only four CEs are in use), only address bit CADR4X3 is used to address a particular quadrant, and CADR5 is saved by the addressed cache quadrant for use with the remainder of the address transferred through the backplane switch.</p><p>As many as eight CEs may simultaneously bid for access to any of the four cache quadrants. Access conflicts are resolved by the cache quadrants. In the same 85 nanosecond cycle as the CSTRTL is asserted (the first cycle), the cache quadrant addressed resolves which of the contending CEs has priority (on the basis of the CE's physical location in the backplane, e.g., CE0 has priority over all other CEs), and in the second 85 nanosecond period, asserts CBUSYL to all but the highest-priority CE of those that are requesting access to that quadrant. CEs receiving the CBUSYL maintain their assertions of CSTRTL in subsequent cycles (only if they continue to desire access to that quadrant). The cache quadrant maintains assertion of CBUSYL in subsequent cycles until it is able to accept an address from the CE in question or until the CE removes CSTRTL. When CBUSYL is removed, the address transfer takes place in the same cycle. A CE must remove its CSTRTL in the cycle following transfer of an address, or the cache quadrant will interpret its presence as a new cache access request. A cache access may be aborted by a CE by its removing the CSTRTL assertion in the second cycle--the cycle in which the address transfer is to take place.</p><p>Also in the second cycle, the cache quadrant instructs the backplane switch to transfer the address CADR(27:6,4,2:0), operation code CEOP, and data length code CEDLN from the selected CE. The cache quadrant accomplishes this by asserting the code for the selected CE on its CE selection lines (e.g., WS). As the address lines through the backplane switch are unidirectional (CE to cache quadrant), the direction lines (e.g., WD) and enable lines (e.g., WE) for the eight address gates of the switch are hardwired in the appropriate state. The cache quadrant combines the twenty-six bits of address CEADR(27:0,4,2:0) transferred through the switch with the two bits CADR5 and CADR4X3 used in addressing the cache quadrant, to generate the full memory address.</p><p>In the third cycle, if the CEOP code shows that the CE is requesting a read operation, the cache quadrant inspects its tag store to determine whether the addressed quadword (data transfers are in 64 bit quadwords) is present in its data store while simultaneously reading from the data store the data at the location at which the data to be read would be found if present. During the same cycle, the cache quadrant prepares to set up the backplane switch to transfer data back to the selected CE (by asserting the CE selection lines for the CDT lines of the switch, and changing the state of the direction line, e.g., WD).</p><p>In the fourth cycle, if the tag-store lookup is successful, and there is no other condition that precludes it (e.g., a resource conflict), data are transferred through the backplane switch to the selected CE. If the look-up is unsuccessful (i.e., a \"cache miss\" has occurred), the cache quadrant asserts the CWAITL line for the selected CE, instructing the CE to wait until the removal of the CWAITL assertion before reading data from the backplane switch. CWAITL remains asserted until the cache quadrant is prepared to transfer the requested data. The transfer occurs during the first cycle in which CWAITL is not asserted.</p><p>If the CEOP code specifies a write operation, the tag-store lookup operation occurs in the third cycle (but a data store read is not performed), and the backplane switch is configured to transfer data from the CE to the cache on the CDT lines. If the lookup is successful, the data transfer occurs in the fourth cycle, and the write into the data store in the fifth cycle. If the lookup is unsuccessful, CWAITL is asserted, instructing the CE to hold the data on its CDT lines until the CWAITL assertion is removed.</p><p>The data transfer to or from a CE can be overlapped with a second CSTRTL assertion and address transfer from the same CE. Such overlapped accesses raise the possibility that a cache start will be accepted (CBUSYL not returned) by one cache quadrant before the data transfer for a previous operation has been completed by the same or another quadrant. In such a case the one or two quadrants involved must work together to assure that the data is transferred in the expected order and that the CWAITL signal is asserted unambiguously. This is accomplished by assuring that CWAITL is asserted only by the first quadrant to accept a cache start, until such time as the data transfer for that quadrant is complete. The data transfer for the later operation is delayed until at least two cycles after the earlier data transfer (rather than two cycles after the address transfer as in the ordinary case). If the quadrant controlling the later transfer wishes to delay the transfer further, it may then do so by asserting CWAITL. In this case, there will be exactly two cycles of delay from the end of one assertion of CWAITL to the start of the next assertion. Once CWAITL is under the control of the cache quadrant performing the later transfer, the timing of the data tranffer will be the same as for the ordinary case. The cache quadrants are able to detect for which CEs the CWAITL line has been asserted as the CWAITL lines for all CEs can be read by all cache quadrants.</p><p>Data parity bit CDTPAR, which is based on the entire 64 bits of data transferred across the CDT lines, is sent in the cycle following the data transfer. Address parity bit CADRPAR is transferred with the address during the second cycle.</p><p>There are three basic operations specified by the CEOP code: READ, WRITE, and TEST AND SET (TAS). The first two are straightforward, and have already been discussed. The TAS operation performs an atomic test and set of a bit in memory. The operation is performed by reading the addressed byte from the cache and transferring it back to the CE (as part of an eight-byte quadword transfer) while also writing the addressed byte back to memory with bit 7 set to one. It is guaranteed that no other processor, anywhere in the system, can access the data between the read and writeback portions of the operation.</p><p>The CEOP code may also be used to pass a cross-processor interrupt message to other processors via the backplane switch, cache, and memory bus. Additional interrupt control lines (not shown) may be provided for use by the cache to signal a CE of the occurrence and nature of such interrupts.</p><p>In addition to the read, write, and TAS operations specified by the CEOP code, a write-continuation operation may be specified (to perform the second half of a mis-aligned write that crosses a quadword boundary).</p><p>The data-length bits CDLN(1:0) are transferred with an address to instruct the cache quadrant as to the number of bytes following the address that are to be modified by a write operation.</p><h4>VIII. Central Processing Cache</h4><h4>A. Summary</h4><p>The system has a global central processing cache that serves up to eight CEs. The cache is divided into four interleaved quadrants (denoted W,X,Y,Z), two of which reside on each of two CP cache boards 12. Each cache quadrant can ordinarily complete one quadword (64-bit) read or write access in each 85 nanosecond cycle, resulting in a total peak throughput in the vicinity of 375 megabytes per second.</p><p>The block size of the cache (the smallest amount of data moved between the cache and memory) is 32 bytes. The data of each block is interleaved between two quadrants W,X on the same cache board so that for any 32-byte block quadwords 0 and 3 (quadwords are 8-byte words) are contained in quadrant W and quadwords 1 and 2 in quadrant X. Contiguous 32-byte blocks are interleaved between cache boards so that quadwords 4 and 7 are located in quadrant Y and quadwords 5 and 6 in quadrant Z. The interleaving is accomplished by the use of CADR5 to select the cache board and CADR4X3 to select the quadrant within the board.</p><p>The cache quadrants use a write-back cache protocol, meaning that both read and write operations are handled by the cache. Data which has been modified in the cache will not be written back into main memory until the data is required elsewhere in the system, or until the cache block in which it is contained is needed for other data, and blocks that have not been modified during their stay in the cache are not written back into memory when replaced.</p><p>Each cache quadrant contains 32 kilobytes of data storage, and the entire four-quadrant cache 128 kilobytes. The data stores of the quadrants are direct mapped, meaning that for any given location in main memory, there will be a single location in the cache which may contain a copy of the data from that main memory location.</p><h4>B. Data Paths</h4><p>The data paths for each cache quadrant are shown in FIG. 19 (which shows quadrant W and a portion of quadrant X). A 64-bit data bus CDIO(63:0) connects the I/O lines of data store 300 with ECC gate array 302 (implemented as two gate arrays), CE interface data input register CDIN, CE interface data output register CDOUT, and main memory bus input register DMBIN. Data store 300 is implemented using sixteen 4K\u00d74 MOS static RAMs plus eight 4K\u00d71 MOS RAMs for parity. The output enable signals of the parts driving the CDIO bus are gated with timing signals generated by a delay line to minimize the possibility of bus fighting during transitions from one bus source to another. The W suffixes in FIG. 19 indicate the Parts belonging to quadrant W; identical parts are present in quadrant X.</p><p>The DMBIN register receives data from one of the main memory data buses and supplies it simultaneously to the data store, ECC array, and CDOUT register.</p><p>The CDIN register receives data on the CDT bus from a CE via the backplane switch and supplies it simultaneously to the data store and ECC array (for parity checking and generation). The CWAITL signal is used to delay acceptance of the data from the CE until the data store is able to accept it.</p><p>The CDOUT register receives data from the data store, ECC array, and DMBIN register and supplies it to a CE via the backplane switch. The clock for this register can be stopped (by a HLDCDOUT signal) to hold the data for an extra cycle during the checking of the ECC check bits, or during the transition from write data to read data on the CDT bus.</p><p>The read or write to the parity portion of the data store 300 occurs one cycle after the corresponding read or write to the data portion. This is done to remove the time spent in generating parity bits from the critical timing path.</p><p>The ECC gate array in each quadrant performs error correction checking and generation functions for the main memory interface, and parity check and generation for the data store and the CE interface. The ECC array also provides the data path for data written from the cache back to main memory and assists in the execution of the TEST AND SET operation.</p><p>Each block of data to be written back to main memory from the cache is read from the data store into the ECC array one quadword (64 bits) at a time. In the cycle after receiving the data, the ECC array checks the byte parity of the data and generates check bits to be written along with the data into main memory. The combined 72 bits of data and check bits are then stored in a write-back file. The write-back file holds two quadwords for transfer to main memory. The other two words of a given cache block are handled by the ECC array for the other cache quadrant on the board. When the data from the write-back file is subsequently driven onto the main memory data bus, the ECC arrays for the two quadrants alternate in driving the data onto their respective data buses.</p><p>There are two 72-bit main memory buses, DMBTA and DMBTB. Cache quadrants on the same cache board are assigned to different buses. DMBTA is assigned to the W and Y quadrants; DMBTB is assigned to the X and Z quadrants. Thus, the DMBTA bus always transfers quadwords 0 and 3 of a given data block, and the DMBTB bus transfers quadwords 1 and 2. The use of two parallel buses increases the bandwidth of the memory bus by permitting two data block transfers to be in progress simultaneously. Dividing accessed data blocks between cache quadrants provides an advantageous prefetch of data. Each memory bus is driven by an ECC array no more frequently than every other 85 nanosecond cycle, and the ECC array begins to drive the data in the cycle prior to the one in which the data will be placed on the memory bus.</p><p>In addition to serving as the data path for write back to memory, the ECC array also reads in any other data placed on the CDIO bus and performs parity or ECC operations on that data. For example, when data is read from the data store to the CDOUT register, the ECC arrays check for correct data store parity and generate the appropriate bus parity for the transfer to the CE. Similarly, when data is transferred from the CE to the cache, the ECC array checks for correct bus parity and generates the appropriate data store parity.</p><p>When data is transferred from the DMBIN register to the data store, the ECC array generates the correct data store parity and checks for ECC error. If an ECC error is found, the ECC array supplies the corrected data to the data store (and to the CE data output register if appropriate) in the third cycle following the initial transfer of the erroneous data on the CDIO bus.</p><p>The ECC gate array also plays a role in the execution of the TEST AND SET (TAS) operation. When a TAS operation is specified by the CEOP code transferred from the CE, the ECC arrays read in the data supplied by the data store and check its parity as usual. Two cycles later, the ECC array returns the same data to the bus, but with the most significant bit of each byte set to 1. In the following cycle the ECC array supplies the parity bits for the new data so that the appropriate data store parity bit can be updated.</p><h4>C. Address Paths</h4><p>The address paths for each cache quadrant are shown in FIG. 19. The cache quadrants receive a 28-bit physical byte address from the CEs. The significance of the various parts of the address is shown in Table 10:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 10                                                    \n______________________________________                                    \n ##STR2##                                                                 \n______________________________________                                    \n</pre><p>The three least significant bits of the address (bits 0 through 2) indicate the desired byte within the specified quadword. These bits are treated by the cache as control information rather than as part of the address; they are used along with the data length code CDLN specified by the CE to determine which bytes should be modified by a write or TAS operation.</p><p>The next two bits (bits 3 and 4) of the address specify the desired quadword within the cache block. Because quadwords 0 and 3 are located in one quadrant and quadwords 1 and 2 are located in the other, the CE-supplied CADR4X3 signal, which is the Exclusive OR of bits 3 and 4, is used to determine which cache quadrant on a CP cache board contains the desired data. The CE also supplies a normal address bit 4 so that the selected cache quadrant can determine which of its two words is required.</p><p>Bit 5 of the address (supplied as CADR5 by the requesting CE) indicates which of the two CP cache boards in a four-way interleaved system contains the desired block of data.</p><p>The next 11 bits of the address (bits 6 through 16) form the cache index. These bits are used to address the tag store and (along with address bit 4) to address the data store of the selected cache quadrant. In effect, the index bits along with the bits which select the cache quadrant are used to specify the one location within the CP cache which could be occupied by the data from the addressed main memory location.</p><p>The remaining bits of the address (bits 17 through 27) form the cache tag. These bits indicate which one of the many possible blocks from main memory which could be contained in the addressed cache block is actually required by the CE. When the cache is accessed, these bits are compared with the contents of the tag store entry for the addressed block to determine if the desired data is in fact contained in the cache.</p><p>When a single CP cache board is used by itself as a two-way interleaved cache, the address is interpreted in accordance with Table 11:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 11                                                    \n______________________________________                                    \n ##STR3##                                                                 \n______________________________________                                    \n</pre><p>The function of bits 0 through 4 does not change. Bit 5, however, is no longer needed as a board-select bit and is shifted into the index. To make room for bit 5 in the index, bit 16 is shifted into the tag, which becomes one bit wider.</p><p>Each cache quadrant has three address input registers which are clocked in each (85 ns) cycle. The TAG register 310 is a simple 12 bit register which receives CADR(27:16) from the backplane switch and supplies those twelve bits to the address flow gate array 312 (the \"AF array\", implemented as two gate arrays) and to tag comparator 314. The SSIDX and TSIDX registers 316, 318 are used to hold two copies of the index portion of the address, one for the data store and the other for the tag store. The TSIDX register 318 accepts bits 5 through 16 of the address from either the CE via the backplane switch or from the AF array and feeds those bits to the AF array and the tag store 320. The DSIDX register 316 receives the same address bits, along with address bit 4, from the same two sources, and uses them to address the data store. Bits 4 and 6-16 of the address received from the CE are supplied from the backplane switch, while bit 5 is supplied by a flipflop in which it has been saved from its transfer as CADR5 in the previous cycle. The DSIDX register 316 also receives bit 4 of the address CADR(4) from the backplane switch.</p><p>Although the two index registers 316, 318 receive essentially the same data from the same two sources, their input select lines are independently controlled so that the TSIDX register can be accepting an address from the CE at the saee time that the DSIDX register is accepting a different address from the address flow gate array.</p><p>In order to be able to work correctly in either the single or the dual-board configuration, the two index registers always receive both bit 5 and bit 16 of the address, while the tag register always receives a full 12 bit tag, including bit 16. The inclusion of an extra bit in the tag comparison for a two board cache will not affect its operation, as a bit which is included in both the index and the tag will always compare successfully. For the two index registers, it is necessary to select either bit 5 or bit 16 of the address, depending upon the configuration.</p><p>Tag store 320 consists of two banks of four 1K\u00d74 fast static MOS RAMs which provide 2048 15-bit tag entries. Twelve bits of each tag store entry contain the tag itself. An additional bit is used for the VALID control flag, and the final two bits are used as tag parity bits. The VALID control flag is used to indicate whether or not the data store location associated with a given tag store entry contains any valid data. The flag is set at the completion of a cache miss resolution, and reset whenever the cache block will be in an indeterminate state (i.e., when one, but not both words of a new block have been written).</p><p>A separate pair of 4K\u00d71 fast static RAMs is used to keep two copies of the tag entry's MODIFIED control flag. The use of separate and independently controlled RAMs allows the modified bit to be set or cleared at the same time that the rest of the tag entry is being read. Two copies are kept to provide a separate parity check for this bit. The MODIFIED control flag is used to keep track of whether or not the data contained in the corresponding data store location has been modified. This flag is set when data contained in the cache, but currently unmodified, is written for the first time. The MODIFIED flag is reset when data which is currently in the cache and modified is being read into the write-back file in the ECC array. The MODIFIED flag is also reset whenever the VALID flag is reset.</p><p>Each cache quadrant checks each address submitted to it by a CE in order to determine if the requested data is already present in the cache. The check is performed by selecting the index portion of CADR as input to the TSIDX register 318 and applying the data read from the tag store 320 to one side of identity comparator 314 while applying the tag portion of CADR (contained in the tag register) to the other side of the comparator. The result of this comparison is gated with the VALID flag read from the tag store to generate a Cache Hit (or Cache Miss) indication.</p><p>When the address submitted for tag comparison is for a write or TAS operation, the tag comparison includes a check to verify that the MODIFIED flag is already set. If the MODIFIED flag is not yet set, the cache quadrant must set it to keep track of the fact that the data has been modified, so that the quadrant will know to write back to memory the block containing that data.</p><p>The MODIFIED flag will also be checked when the tag check indicates a cache miss. If the MODIFIED and VALID flags are both set when a miss is detected, the cache will cause the data contained in the data store to be written back to memory when it is replaced by the new data.</p><p>A significant portion of the address paths for a cache quadrant is contained in the AF array 312. The paths in the AF array can be divided into two halves. One half receives the addresses from the TAG register and the tag store index register TSIDX and is able to hold three of these addresses for operations which may be pending. The addresses from this half of the array can be driven onto the main memory address bus DMBADR to initiate reads for cache miss resolutions, and can be used to address the data store for the completion of an access that has been delayed for some reason. The paths in this half of the array are also used to delay the data store index used for write operations from the corresponding access of the tag store. The second half of the AF array reads addresses from the main memory address bus DMBADR, and holds other adrresses for memory-related activity in progress. Addresses are placed on the DMBADR bus by the array itself to initiate main memory reads, and the addresses are read by the AF arrays for both quadrants, and saved so that they may be used in the completion of the operation.</p><p>Addresses placed on the bus by the AF array for the other cache quadrant of the same board are similarly taken into a quadrant's own AF array and used to update the data and tag stores as appropriate to the action initiated by the other quadrant. The AF arrays are also responsible for generating the parity bits for a new tag entry, and for checking parity whenever a tag entry is read from the tag store.</p><p>When a write-back is required as part of a miss resolution, the miss address taken into the AF array from the main memory bus is used to read the old data from the appropriate data store block into the write-back file. The AF array for the quadrant which initiated the miss resolution also reads in the old tag from the tag store at this time. This old tag is concatenated with the index portion of the miss address to form the main memory address needed for initiating the write-back operation.</p><p>In addition to their several address registers and latches, the AF arrays also include a number of identity comparators for determining when two operations which are pending or in progress involve either the same data block (i.e., both tag and index are the same) or the same cache block (i.e., the index is the same).</p><p>Because of the need to work in both single and dual-board configurations, the AF array always includes bit 16 in the tag and includes both bits 5 and 16 in the index. Control inputs to the arrays will indicate in which of the two modes a given array is operating and for which half of the address the array has responsibility. The array which contains bit 16 of the address will enable or disable the inclusion of that bit in any index comparison, depending on the mode of operation, in order to be able to perform such comparisons correctly.</p><p>A single main memory address input register DMBADRIN and XCVR are shared by both quadrants on the same cache board. The sharing of the output drivers is facilitated by the fact that any given CP cache board will not drive a new main memory address onto the bus more often than every fourth cycle. The AF arrays for a quadrant which is about to place an address on the bus are enabled to drive the inputs of the bus drivers during the cycle before the bus itself is to be driven. The delay to the enabling of the data onto the main memory address bus will thus depend solely on the enabling of the output drivers at the start of the next cycle, and not on any delays introduced by the gate arrays themselves.</p><h4>D. Handling Multiple Accesses</h4><p>The cache quadrants have the ability to continue accepting CE accesses even after a cache miss or similar event has prevented them from immediately completing an access. Each quadrant has the capability of simultaneously working on three pending CE accesses.</p><p>There are a number of reasons besides a cache miss for a quadrant being unable to complete an access immediately: e.g., the data store may be temporarily inaccessible because it is being used for a higher priority activity; the CE may be unable to accept the data accessed as the result of an earlier access not having been completed (CEs may overlap cache accesses, but they must receive data transfers in order).</p><p>Each cache quadrant keeps track of pending CE accesses using one address register and two address latches, and corresponding status registers (see below). The address register and latches are located in the AF array. They are the CE address register CEREG and two miss latches MISSA, MISSB. The CEREG register receives the address for the most current CE access: the 12-bit tag store index (equivalent to CADR(16:5)) from the TSIDX register and the 12-bit tag (equivalent to CADR(27:16)) from the TAG register.</p><p>If a CE cache access is completed immediately by the quick-work logic (described below; the memory location is found in the cache and data is transferred in the fourth cycle flllowing the CSTRTL assertion), the contents of CEREG is simply replaced by the address of the next CE access. If, on tee other hand, the CE access cannot be handled immediately (and CWAITL is asserted to the CE), the contents of CEREG are held by the MISSA or MISSB latches, whichever is free. When both the MISSA and MISSB latches are full, and the access corresponding to the current contents of CEREG cannot be completed immediately, the clock to CEREG is halted to thereby temporarily store the address it contains, and the cache quadrant is alerted to refuse any further CE accesses (it asserts CBUSYL to all contenders). Thus, as many as three accesses may be simultaneously worked on by each cache quadrant. Normally, each cache quadrant accepts new accesses every 85 nanoseconds. After both miss registers are full, the speed is halved to provide enough time for the quadrant to determine, before accepting a new access, whether the current access (for which the address is stored in CEREG) will be completed immediately.</p><p>CE accesses are initially controlled by quick-work logic 322 (FIG. 20), which controls the tag store lookup, data store read and write, and so on (as well as the interface with the CE). When an access cannot be immediately handled, control of it shifts to pending-status logic 324. As many as three pending accesses in each quadrant can be under the control of the pending-status logic at any one time. The pending-status logic controls address register CEREG and address latches MISSA, MISSB in each quadrant, assigns to them addresses received from the quick-work logic, and maintains and updates a status code for each. Status codes are initially generated by the INITSTAT programmable logic array (PLA), and stored in initial-status register INIT (FIG. 21). From there they can be updated by three next-status PLAs (NEXTSTATC, NEXTSTATA, NEXTSTATB) and held in three next-status registers NEXTC, NEXTB, NEXTA.</p><p>When it is determined that an access cannot be handled immediately by the quick-work logic, the access becomes a \"pending\" access, and control of it is transferred to the pending-status logic. A four-bit state encoding and a three-bit substate encoding is generated by INITSTAT and assigned to the access. The state/substate combination identifies the reasons why the access could not be completed immediately and indicates the path that must be taken to resolve whatever conflicts are preventing completion of the access.</p><p>At the same time as the state and substate encodings are made, initial values of an S bit and a WB bit are set for that access. The S bit, when set, indicates that the completion of the access must be delayed until after a previous operation requested by the same CE has been completed, irrespective of whatever other constraints may or may not be placed on that access by its state or substate. The WB bit is used to track the state of the MODIFIED bit for the block which will be replaced if it should be necessary to bring a new data block in from memory in order to complete the access. The WB bit indicates whether or not a write-back operation is to be performed as part of the miss resolution.</p><p>The determination of the initial state and substate is based upon the type of access requested and upon the results of the tag comparison and the state of the MODIFIED bit, along with other information, such as the status of other CE accesses still pending and the results of address comparisons performed within the AF array.</p><p>The initial status (state, substate, S bit, and WB bit) is loaded, along with the CEOP specification for the access and the CEID of the requesting CE, from the INIT register into one of the next-status registers. If either NEXTA or NEXTB is empty, the status is loaded via the associated next-status PLA into the empty register. If both NEXTA and NEXTB are already full, the output of INIT is loaded only into NEXTC via the NEXTSTATC PLA. NEXTC is only used when CEREG is called upon to temporarily store the address of a third pending access. When the number of pending accesses is reduced to two or less, the contents of NEXTC (if its access has not already been completed) is transferred to either NEXTA or NEXTB. The choice of NEXTA or NEXTB as the destination for the output of INIT is governed by multiplexers 340, 342. During the transfer of INIT the output of NEXTC (which is coupled to the output of INIT via three-state logic not shown) is not enabled.</p><p>The status codes of pending accesses are redetermined each cycle by the next-status PLA to which the access is assigned. The PLAs determine a new status each cycle based on the old status (which is either fed back from the PLA's own next-status register or (as discussed above) transferred from the NEXTC register), inputs from the AF array indicating the results of address comparisons, and other inputs indicating the status of other activity occurring in the cache.</p><p>When the pending-status logic recognizes that address latches MISSA, MISSB in the AF array are full, it instructs the quick-work logic to accept CE accesses at a slower rate. When it recognizes that a third access has become pending (with its address stored in CEREG), it notifies the quick-work logic to stop accepting accesses, by asserting CBUSY to all contending CEs.</p><p>To complete pending accesses, the pending-status logic relies on either the memory-interface logic 326 or the unpended work logic 328. To complete an access by accessing the required data block from memory, the pending-status logic communicates with the memory-interface logic by asserting one of four memory-access signals ARBNXTI, ARBNXTC, ARBNXTA, ARBNXTB, to inform the memory-interface logic that it should access from memory the data block having the address stored in the corresponding register (CEREG ARBNXTC, MISSA for ARBNXTA, and MISSB for ARBNXTB; ARBNXTI is asserted before it is known in which register or latch the access address will be held). Also supplied to the memory-interface logic is the CE operation code CEOP and the CE identity CEID.</p><p>The memory-interface logic accomplishes two tasks. First, it completes the requested memory access, by instructing the AF array to assert the required block address on the DMBADR OUT bus and by instructing the DMBINA (or DMBINB, depending on the quadrant) register to accept data from the main memory bus. Second, it completes the cache access assigned to it by the pending-status logic. To complete the cache access, it must obtain the use of the data paths from the DMBINA register to the data store and ECC array and to the address paths from the AF array to the tag store, paths normally controlled by the quick-work logic. To do so, the memory-interface logic asserts DSRQ (data store request) and TSRQ (tag store request) to the quick-work logic. Assertion of these signals may prevent the quick-work logic from completing accesses, and may result in accesses being transferred to the pending-status logic, but the memory-interface logic is given priority so that data accessed from memory reaches the data store without delay. Once it has control of the paths, the memory-interface logic instructs the AF array to transfer the index portion from the RDADR latch (which contains the address of data accessed from main memory) to the paths to the tag and data stores, and it causes data to be moved across the CDIO bus to the ECC array and data store. When the memory-interface logic has completed an access assigned to it, it informs the quick-work logic to clear the CWAIT corresponding to the completed access.</p><p>Pending accesses not completed by the memory-interface logic are completed by the unpended-work logic 328. Only CE accesses that initiate a memory access are completed by the memory-interface logic. Those that can be completed without a memory access are handled by the unpended-work logic. Examples of accesses completed by the unpended-work logic include ones caused not by misses but by resource conflicts and ones for which the desired quadword is read from memory as the result of another pending access. The pending-status logic transfers accesses to the unpended-work logic by asserting one or more UNPEND signals (AUNPEND, BUNPEND, CUNPEND, one for each of the three possible pending accesses), as well as the CE operation code CEOP and the CE identity CEID. The UNPEND signals constitute one bit of the status code stored in the next-status registers, and are updated by the next-status PLAs with each change in the state/substate of an access; they represent a decoding of the specific state encoding (UNPEND) that indicates whether an access has a status appropriate for completion by the unpended-work logic. The unpended-work logic constantly checks to see if the resources are available to complete accesses assigned to it. When they are, it will control the AF array, ECC array, data store, and tag store as necessary to complete the access.</p><p>When the unpended-work logic completes an access, it informs the pending-status logic of that fact by asserting the appropriate EMPTY line (EMPTYA, EMPTYB, or EMPTYC), which causes the corresponding status and address registers and latches to be cleared, and it instructs the quick-work logic to clear the corresponding CWAIT signal.</p><p>In summary, there are three ways in which a cache access is completed: by the quick-work logic if completion can be done immediately, by the memory-interface logic if the cache access initiates a memory access, and by the unpended-work logic if the cache access can be completed without initiating a memory access.</p><p>Priority for access to the data store and related resources is always given to the memory-interface logic, as it cannot be required to hold up transfers from memory. Ordinarily the quick-work logic has the next highest priority, as it is ordinarily better to avoid creating new pending accesses than to complete those already pending. The unpended-logic may, however, take priority by asserting STOP to the quick-work logic, instructing it to assert CBUSY to all contending CEs. The quick-work logic, in turn, instructs the unpended-work logic whether it will be using the resources in the next cycle (e.g., if it will be accepting an address transfer for the last access it accepted) by asserting RlSTRT. If RlSTRT is asserted, the unpended-work logic waits until the following cycle, when it is assured of use of the resources.</p><p>The pending-status logic relies on the results of address comparisons made in the AF array to update the status of pending accesses. These comparisons are primarily of two types. First, addresses stored in CEREG, MISSA, and MISSB are compared to every address DMBIN received by the AF array from the main memory address bus DMBADR. Second, the address CEIN of the most current CE access (which may become a pending access) is compared to not only the current address DMBIN being received from memory but also to addresses received from memory in several prior cycles. The prior-received addresses are stored in a pipeline in the AF array and include register ADRIN and latches PDADR, RDADR.</p><p>A successful comparison between CEIN and the contents of addresses in the incoming address pipeline (e.g., PDADR, RDADR) may cause the pending-status logic (the INITSTAT PLA) to generate an initial status indicating that the current access is pending on another miss (POOM), i.e., that the data needed to complete the new access is on its way to the data store from the main memory bus. On the other hand, a successful comparison between only the index (and not the tag) of CEIN and an address of data being read in from main memory causes the pending-status logic to generate an initial status indicating that, even though the data required might presently be in the data store, it is about to be replaced by other data, and that, if the access cannot be immediately completed by the quick-work logic, the access must be given a status that requires it not initiate another memory access until after an interval long enough for completion of the access that caused the new data to be transferred from memory.</p><p>In summary, the address comparisons performed to determine how the status of a pending access should be updated (e.g., to a status indicating that the access can be completed by the memory-interface or unpended-work logic) comprise (1) comparisons of each new access address transferred by a CE to all addresses for main memory accesses still in progress (i.e., those for which the data has not already been stored in the data store) and (2) comparisons of each new memory access address to the addresses of each pending access.</p><p>The address comparisons made by the AF array include ones that assure that if both a read and a write to the same data are pending, the read is not completed if it came later until the earlier write has been completed.</p><p>The two cache quadrants on the same cache board share common main memory address buses (as shown in FIG. 19 for quadrants W, X). The DMBADR IN lines from the AF array of each quadrant are tied together, as are the DMBADR OUT lines. In this manner, the address of a data block being accessed by one quadrant is read by the other quadrant, which will be receiving half of the data block. Cache quadrants alternate in accessing main memory.</p><p>The CP cache may be provided with hardware for maintaining coherency between data in its own data stores and data stored in other subsystems (e.g., other caches) having access to memory. For example, the hardware monitors the main memory bus to detect whether other subsytems (e.g., other caches) are about to modify data of which the CP cache presently has a copy. The CP cache must immediately invalidate any such data (by setting the VALID bit low). Furthermore, if the CP cache has a modified copy of that data (which is necessarily the only such modified copy because other subsystems have invalidated any copies they have upon learning that the CP cache was modifiying its copy ), and another subsystem wants a copy of the data, the cache must transfer the data onto the main memory bus so that it is available to the other subsystem. Another example of a function performed by such data-coherency hardware is informing other subsystems when the CP cache is about to modify its copy of data. Such data coherency hardware increases the complexity of the state/substate status coding. Such data coherency hardware is discussed in Yen et al., \"Data Coherence Problem in a Multicache System\", IEEE Transactions on Computers, Vol. C34, No. 1 (January 1985), which is incorporated by reference.</p><h4>E. Cache Interleaving</h4><p>The preferred interleaving is shown in Table 12:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 12                                                    \n______________________________________                                    \n                        Cache    Cache                                    \nADR(5:3)  ADR4X3        Quadrant Board                                    \n______________________________________                                    \n0 0 0     0             W        0                                        \n0 0 1     1             X        0                                        \n0 1 0     1             X        0                                        \n0 1 1     0             W        0                                        \n1 0 0     0             Y        1                                        \n1 0 1     1             Z        1                                        \n1 1 0     1             Z        1                                        \n1 1 1     0             Y        1                                        \n______________________________________                                    \n</pre><p>The interleaving scheme provides excellent cache accessing efficiency (i.e., a minimum of wasted cache access cycles due to more than one CE attempting to access the same cache) when a plurality of CEs (each assigned a fixed priority ranking) are concurrently processing a program that accesses memory in strides of one and two quadwords (as well as larger strides that are divisible by two but not by four; e.g., strides of six and ten quadwords). A memory stride is the address spacing between successive memory accesses by software operating on the system. Scientific and engineering software, for which the present system is best suited, typically accesse memory with strides of both one and two (stride of ten is also relatively common).</p><p>To understand the advantages of the preferred interleaving it is helpful to examine other, less desirable schemes. Some schemes have poor performance for either a stride of one or a stride of two. For example, the interleaving scheme shown in Table 13 works well for strides of</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 13                                                    \n______________________________________                                    \n                Cache    Cache                                            \nADR(5:3)        Quadrant Board                                            \n______________________________________                                    \n0 0 0           W        0                                                \n0 0 1           X        0                                                \n0 1 0           Y        1                                                \n0 1 1           Z        1                                                \n1 0 0           W        0                                                \n1 0 1           X        0                                                \n1 1 0           Y        1                                                \n1 1 1           Z        1                                                \n______________________________________                                    \n</pre><p>one, but poorly for strides of two, wherein no cache accesses whatsoever would be made to half of the cache quadrants (becuuse they only contain memory locations skipped over in a stride of two). The interleaving scheme of Table 14 works well for a stride of two, but poorly for a stride of one.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 14                                                    \n______________________________________                                    \n                Cache    Cache                                            \nADR(5:3)        Quadrant Board                                            \n______________________________________                                    \n0 0 0           W        0                                                \n0 0 1           W        0                                                \n0 1 0           X        0                                                \n0 1 1           X        0                                                \n1 0 0           Y        1                                                \n1 0 1           Y        1                                                \n1 1 0           Z        1                                                \n1 1 1           Z        1                                                \n______________________________________                                    \n</pre><p>The reason for the difficulty with a stride of one can be seen by examining the cache access patterns for four CEs all concurrently processing a program with a memory-access stride of one. As shown in Table 15, a phase relationship between the access patterns can result in which the</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 15                                                    \n______________________________________                                    \nCE                                                                        \n______________________________________                                    \n1         W W X X Y Y Z Z W W X X Y Y Z Z                                 \n2         Y Z Z W W X X Y Y Z Z W W X X Y                                 \n3         X X Y Y Z Z W W X X Y Y Z Z W W                                 \n4         # # W # # W # X # # # # X # Y #                                 \n______________________________________                                    \n</pre><p>fourth CE (with the lowest priority) is locked out of accesses (indicated by a #) most of the time. In this phase relationship, each of the first three CEs is offset from the next higher priority CE by an odd number of cycles (specifically three in this instance).</p><p>There is another phase relationship, shown in Table 16, for the Table 14 interleaving scheme at a stride of one. In this phase relationship, in which each CE is offset from the next higher priority CE by an even number of cycles (specifically two in this instance), access lock-out of CE4 does not result. The difficulty, however, is that there is</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 16                                                    \n______________________________________                                    \nCE                                                                        \n______________________________________                                    \n1         W W X X Y Y Z Z W W X X Y Y Z Z                                 \n2         Z Z W W X X Y Y Z Z W W X X Y Y                                 \n3         Y Y Z Z W W X X Y Y Z Z W W X X                                 \n4         X X Y Y Z Z W W X X Y Y Z Z W W                                 \n______________________________________                                    \n nothing about the interleaving of Table 14 that will force the CEs to\n adopt the more efficient even-offset of Table 16 rather than the\n less-efficient odd-offset of Table 15, and thus performance will degrade\n on the average for a stride of one.\n</pre><p>What is advantageous about the interleaving scheme of Table 12 is that it produces a stride-of-one access pattern (WXXWYZZY) that forces the CEs into a phase relationship in which there are a minimum of (and ideally no) wasted cache accesses. Table 17 shows the initial cache accesses in</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 17                                                    \n______________________________________                                    \nCE                                                                        \n______________________________________                                    \n1         W X X W Y Z Z Y W X X W Y Z Z Y                                 \n2         # W # X X W Y Z Z Y W X X W Y Z                                 \n3         # # W # # X X W Y Z Z Y W X X W                                 \n4         # # # # W # # X X W Y Z Z Y W X                                 \n______________________________________                                    \n</pre><p>the four CEs for a stride of one. In the hypothetical shown, the four CEs initially attempt to access the same cache quadrant in the first cycle (something approximating what could occur at initiation of vector concurrent processing; see below). Access conflicts force CE2, CE3, and CE4 to delay some accesses until each reaches a phase relationship in which no further conflicts arise, wherein each CE's access pattern is offset by an even number of cycles from that of the CE with the next highest priority. This phase relationship will be reached by all the CEs no matter what the initial phase relationship.</p><p>The cache accessing sequence shown in Table 17 actually shows only half of the accesses that occur during a typical initiation of vector-concurrent processing on an eight-CE system (with all eight CEs participating in the concurrency complex). The sequence of Table 17 depicts the accessing occurring every other 85 nanosecond cache cycle for four of the eight CEs; the same accessing pattern occurs during the other cycles for the other four CEs. Assuming for simplicity that all eight CEs initially contend for the same cache quadrant, those that lose on the first cycle will contend on the very next cache cycle (no shown in the Table 17 sequence). One CE will win during that cycle, and the remaining ones will contend during the third cache cycle (the second cycle shown in Table 17). One by one the eight CEs will find a niche on one or the other of the alternating cache cycles, with the result that four will access the cache on odd cache cycles, and another four on even cycles (with the resulting assignment to odd or even cycles being random). The superior performance of the preferred interleaving is most pronounced when seven to eight CEs are part of the concurrency complex.</p><p>The general procedure for choosing an efficient interleaving is as follows. For each stride of interest, the desired offset between the access patterns of the contending CEs is determined. In general, the desired offset is equal to the quotient (or any multiple thereof) of the length of the pattern and the number N of available cache sections (the generality of this expression for offsets greater than four is believed to be accurate, but has not been investigated):</p><p></p><pre listing-type=\"equation\" xml:space=\"preserve\"><!--Greenbook equation-->OFFSET=LENGTH/N)</pre><p>The stride-of-one pattern for the preferred interleaving of Table 12 (WXXWYZZY) has a length of eight, and thus the desired offset (and multiples thereof) for four processors is 2, 4, 6, 8, and so on--i.e., any even number.</p><p>If an interleaving is efficient for a particular stride, it is also efficient for all odd multiples thereof. Thus, for example, the interleaving that produces the desirable eight-bit pattern WXXWYZZY for a stride of one also produces the same desirable pattern (except for irrelevant interchanges of cache section identities) for strides of three and five, and so for all odd strides. And the desirable pattern (WXYZ) for a stride of two also results for strides of 6, 10, and all other odd multiples of 2.</p><p>In general the length of a pattern equals the number of cache sections multiplied by the largest power of two stride that the pattern accommodates. For example, in the WXXWYZZY example, the length of 8 equals 4 cache quadrants multiplied by a largest power-of-two offset of 2.</p><p>Once the desired offset is known, the access pattern must be inspected to determine whether it will tolerate such an offset without conflicts arising. This inspection is easily carried out by determining whether the same cache section (e.g., W,X,Y,Z in the present case) appears in the pattern at any interval equal to the desired offset or a multiple thereof. If the same cache section does appear at such intervals, it means a conflict can result, making the Pattern undesirable. Inspection of the stride-of-one patterns (WXXWYZZY and WWXXYYZ) for the interleaving schemes of Tables 12 and 14 shows no conflicts at the desired offset of 2 nor at multiples of that offset. This accounts for the ability of the Table 14 interleaving to achieve the phase relationship shown in FIG. 16. Although these two access patterns will tolerate an offset of two, there are obviously patterns that will not (e.g., WXWXYZYZ).</p><p>After it has been determined that the pattern has no conflicts at the desired offset (or at multiples thereof), it is necessary to provide some means of forcing the contending processors to fall into the desired offset. With the contending CEs having a fixed priority ranking (e.g., based on their physical locations in the backplane), it is possible to force the desired offset simply by judicious selection of the interleaving itself. The interleaving is chosen so that the resulting access pattern generates at least one conflict at all of the undesired offsets. In the case of a desired offset of 2 (and also 4, 6, and 8), the access pattern must have at least one conflict at offsets of 1, 3, 5, and 7 (although the conflicts at 5 and 7 necessarily arise if conflicts are present at 1 and 3). As shown in Table 18 below, the stride-of-one access pattern for the Table 12 interleaving (repeated twice below) has the necessary odd-offset conflicts.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 18                                                    \n______________________________________                                    \n ##STR4##                                                                 \n______________________________________                                    \n</pre><p>By contrast, the stride-of-one pattern for the Table 14 interleaving does not have the necessary conflicts. As shown in Table 19, it lacks the conflicts for an offset of 3 (and 5), having only conflicts at offsets of 1 (and 7).</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 19                                                    \n______________________________________                                    \n ##STR5##                                                                 \n______________________________________                                    \n</pre><p>This procedure can be applied to any number of cache sections (and processors) and to any stride. (The number of cache sections must, for practical purposes, be a power of two because of the binary memory addressing. For example, if eight (instead of four) cache sections are provided, the offset for a sixteen cycle access pattern (which is needed to accommodate strides of 1 and 2) is</p><p></p><pre listing-type=\"equation\" xml:space=\"preserve\"><!--Greenbook equation-->OFFSET=L/N =16/8=2</pre><p>A desirable sixteen-cycle pattern is shown in Table 20  (in which the cache sections are denoted A through H ). As required, it has no conflicts at all even offsets, and at least one conflict at all odd offsets (exemplary odd-offset conflicts are shown for offsets of 1, 3, 5, and 7).</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 20                                                    \n______________________________________                                    \n ##STR6##                                                                 \n______________________________________                                    \n</pre><p>Other interleaving schemes than the one shown in Table 12 can be used. Schemes could be used that produce either of the eight-cycle access patterns shown in Table 21. Both patterns have the required absence of even-offset conflicts and presence of at least one conflict at all odd offsets (exemplary odd-offset conflicts are shown for offsets of 1 and 3).</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 21                                                    \n______________________________________                                    \n ##STR7##                                                                 \n ##STR8##                                                                 \n______________________________________                                    \n</pre><p>The interleaving schemes corresponding to these patterns (which are for a stride of one; stride of two produces the desirable pattern WXYZ) do not have the implementational simplicity of the interleaving scheme of Table 12, which permits the cache sections to be realized as two identical boards, each with identical quadrants.</p><p>Another interleaving scheme that could be used in place of Table 12 is one that provides the sixteen-cycle stride-of-one pattern shown in Table 22. It has the advantage</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 22                                                    \n______________________________________                                    \nW W X X X X W W Y Y Z Z Z Z Y Y                                           \n______________________________________                                    \n</pre><p>of performing well not only at a stride of one (the pattern above) but also at strides of two (WXXWYZZY pattern) and four (WXYZ pattern). It has the disadvantage, however, of requiring a longer concurrency startup, the interval shown in Table 17 during which numerous cache access cycles are wasted in forcing the necessary phase relationships between CEs. The interleaving required to produce the Table 22 pattern can be achieved by interleaving at the two-quadword level (using the exclusive-OR of ADR5 and ADR4 to choose the quadrant, ADR6 to choose the board, and ADR3 and ADR4 to choose the word within the quadrant) rather than, as preferred, at the one-quadword level. This interleaving might be advantageous in circumstances wherein the performance for a stride of four outweighed the loss of concurrency startup speed.</p><p>Appendix C includes a set of descriptions of the various states and substates stored in status registers INIT, NEXTC, NEXTA, NEXTB. The descriptions give the meaning of the state and substate, possible prior substates of the same state, possible prior states and substates, conditions for selection as the initial state (which is placed in the INIT register), and possible next state transitions.</p><p>Appendix D includes a detailed description of the contents and operation of the AF array. Page 8 gives the address comparisons made by the AF array, and used in updating the state and substates stored in the status registers (and latches).</p><p>Appendix E contains a full set of schematics for the cache board, memory interface board MIB (for reasons of space, the cache circuitry for each pair of quadrants is split between the cache board and MIB), ECC gate array, and AF gate array. The correspondence between the four basic blocks of control logic shown in FIG. 20 and the schematics of the appendix is essentially as follows: The quick-work logic includes schematics with titles referring to QUICK WORK, DATA SWITCH, CEINT, CBUSY, and CWAIT. The memory-interface logic includes schematics with titles referring to MISS START, MISS COMPLETE, and SCHEDULED WRITE BACK. The pending-status logic includes schematics with titles referring to INITIAL STATUS and NEXT STATUS. The unpended-work logic includes schematics of the same title. The schematics include logic related to data coherency (e.g., THIRD TAG STORE, FORCED WRITE BACK, nnd T3I). The cache board schematics are Dwg. No. 00007-00 (89 sheets). The memory-interface board schematics are Dwg. No. 00009-00 (60 sheets). The ECC gate array schematics are Dwg. No. 20004-00 (36 sheets). The AF gate array schematics are Dwg. No. 20006-00 (54 sheets).</p><p>Appendix F contains a full set of PAL equations (in some instances with explanatory comments, some of which may not have been amended to reflect revisions to the equations) for the PALs used on the cache and memory-interface boards. List of the PALs used in each board appear at the front of the appendix. The notation used in the PAL equations is the same as that for the PLA equations of Appendix B, and is explained at the front of that appendix.</p><p>Other embodiments of the invention are within the following claims.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Michael L.", "last_name": "Ziegler", "name": ""}, {"first_name": "Jonathan S.", "last_name": "Blau", "name": ""}, {"first_name": "Robert L.", "last_name": "Fredieu", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ALLIANT COMPUTER SYSTEMS CORPORATION"}, {"first_name": "", "last_name": "ALLIANT COMPUTER SYSTEMS CORPORATION, ACTON, MA., A CORP. OF MA.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  13/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711130"}, {"primary": false, "label": "711E12038"}], "ecla_classes": [{"label": "G06F  12/08B4S"}], "cpc_classes": [{"label": "G06F  12/0859"}, {"label": "G06F  12/084"}, {"label": "G06F  12/0859"}, {"label": "G06F  12/084"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1985-07-22", "application_date": "1985-07-22", "family_members": [{"ucid": "US-4794521-A", "titles": [{"lang": "EN", "text": "Digital computer with cache capable of concurrently handling multiple accesses from parallel processors"}]}]}