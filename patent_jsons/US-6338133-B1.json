{"patent_number": "US-6338133-B1", "publication_id": 72888425, "family_id": 23017750, "publication_date": "2002-01-08", "titles": [{"lang": "EN", "text": "Measured, allocation of speculative branch instructions to processor execution units"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50265281\"><p>A method and system for branch dispatching of instructions in a data processor. A processor having one or more buffers for storing instructions and one or more execution units for executing instructions is utilized. Each unit has a corresponding queue which holds instructions pending execution. First, a threshold level (selected maximum number of instructions in the instruction queue) is set. The current utilization measure for one or more execution units in the data processing system is determined. The current utilization measure is compared to the predetermined threshold value; and a speculative branch instruction is dispatched to a selected execution unit when the current utilization measure is less than the predetermined threshold value.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6338133-B1-CLM-00001\" num=\"1\"><claim-text>1. A method for dispatching of instructions in a data processing system comprising the steps of:</claim-text><claim-text>determining a current utilization measure for one or more execution units in said data processing system, wherein said current utilization measure is a number of instructions queued at said one or more execution units; </claim-text><claim-text>setting a threshold value for each execution unit, wherein an individual threshold is established for each execution unit, wherein said threshold value is selected based on characteristics of each of said plurality of execution units, and said threshold value is a number corresponding to the maximum desired number of instructions queued at said execution unit above which no speculative dispatch occurs; </claim-text><claim-text>comparing said number of instructions queued at each of said execution units with said threshold value of each of said execution units, respectively, to produce a series of results, and ORing said series of results, wherein said ORing yields a false output when no execution unit is at its threshold, and a true output when any one of said plurality of execution units is at its threshold; and </claim-text><claim-text>dispatching a speculative branch instruction to a selected execution unit only when said ORing step yields said false output indicating that said current utilization measure is less than said predetermined threshold value. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6338133-B1-CLM-00002\" num=\"2\"><claim-text>2. The method of <claim-ref idref=\"US-6338133-B1-CLM-00001\">claim 1</claim-ref>, wherein said determining step is implemented by tracking said number of instructions which have been dispatched, but not yet completed, as an indication of current execution utilization.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6338133-B1-CLM-00003\" num=\"3\"><claim-text>3. The method of <claim-ref idref=\"US-6338133-B1-CLM-00001\">claim 1</claim-ref>, wherein said determining step is implemented by tracking said number of instructions which have been dispatched, but not yet executed, as an indication of the amount of work that has already been assigned to said execution unit.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6338133-B1-CLM-00004\" num=\"4\"><claim-text>4. The method of <claim-ref idref=\"US-6338133-B1-CLM-00001\">claim 1</claim-ref>, wherein said dispatching step further includes:</claim-text><claim-text>first fetching an instruction; </claim-text><claim-text>examining said instruction in a predicted path to identify which execution unit is a target for execution of said instruction; </claim-text><claim-text>examining said instruction unit to determine the number of instructions queued up to said unit; </claim-text><claim-text>when said instruction unit has instructions queued up, disabling speculative instruction dispatching to said unit; and </claim-text><claim-text>when said instruction unit is idle, enabling the dispatch of speculative instructions to said unit. </claim-text></claim>"}, {"num": 5, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6338133-B1-CLM-00005\" num=\"5\"><claim-text>5. A data processing system for dispatching of instructions comprising:</claim-text><claim-text>means for determining a current utilization measure for one or more execution units in said data processing system determining a current utilization measure for one or more execution units in said data processing system, wherein said current utilization measure is a number of instructions queued at said one or more execution units; </claim-text><claim-text>means for setting a threshold value for each execution unit, wherein an individual threshold is established for each execution unit, wherein said threshold value is selected based on characteristics of each of said plurality of execution units, and said threshold value is a number corresponding to the maximum desired number of instructions queued at said execution unit above which no speculative dispatch occurs; </claim-text><claim-text>means for comparing said number of instructions queued at each of said execution units with said threshold value of each of said execution units, respectively, to produce a series of results, and ORing said series of results, wherein said ORing yields a false output when no execution unit is at its threshold, and a true output when any one of said plurality of execution units is at its threshold; and </claim-text><claim-text>means for dispatching a speculative branch instruction to a selected execution unit only when said ORing step yields said false output indicating that said current utilization measure is less than said predetermined threshold value. </claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6338133-B1-CLM-00006\" num=\"6\"><claim-text>6. The data processing system of <claim-ref idref=\"US-6338133-B1-CLM-00005\">claim 5</claim-ref>, wherein said determining means includes means for tracking said number of instructions which have been dispatched, but not yet completed, as an indication of current execution utilization.</claim-text></claim>"}, {"num": 7, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6338133-B1-CLM-00007\" num=\"7\"><claim-text>7. The data processing system of <claim-ref idref=\"US-6338133-B1-CLM-00005\">claim 5</claim-ref>, wherein said determining means includes means for tracking said number of instructions which have been dispatched, but not yet executed, as an indication of the amount of work that has already been assigned to said execution unit.</claim-text></claim>"}, {"num": 8, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6338133-B1-CLM-00008\" num=\"8\"><claim-text>8. The data processing system of <claim-ref idref=\"US-6338133-B1-CLM-00005\">claim 5</claim-ref>, wherein said dispatching means further includes:</claim-text><claim-text>means for first fetching an instruction; </claim-text><claim-text>means for examining said instruction in a predicted path to identify which execution unit is a target for execution of said instruction; </claim-text><claim-text>means for examining said instruction unit to determine the number of instructions queued up to said unit; </claim-text><claim-text>when said instruction unit has instructions queued up, means for disabling speculative instruction dispatching to said unit; and </claim-text><claim-text>when said instruction unit is idle, means for enabling the dispatch of speculative instructions to said unit. </claim-text></claim>"}, {"num": 9, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6338133-B1-CLM-00009\" num=\"9\"><claim-text>9. The data processing system of <claim-ref idref=\"US-6338133-B1-CLM-00005\">claim 5</claim-ref>, wherein:</claim-text><claim-text>said determining means includes a register coupled to an instruction queue of said execution unit, said instruction queue holding instructions awaiting execution by said execution unit, and said register storing said predetermined threshold value and tracking the number of instructions in said instruction queue; </claim-text><claim-text>said comparing means includes a comparator connected to said register via a counter, said counter for counting the number of instructions in said instruction queue, and comparator for comparing said number of instructions with said predetermined threshold value to yield a result, and further wherein when more than one execution unit is checked, said comparing means further includes a comparator for ORing said result of a first comparison with said result of a second comparison; and </claim-text><claim-text>said dispatching means includes a dispatch unit coupled to said comparator and said instruction queue, wherein said dispatch unit receives instructions form said instruction fetcher, and when said instruction is speculative, said dispatch unit dispatches said instruction to said instruction queue of said execution unit only when said comparator yields a \u201cfalse\u201d output to said dispatch unit. </claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6338133-B1-CLM-00010\" num=\"10\"><claim-text>10. A data processor comprising:</claim-text><claim-text>one or more execution units, wherein an execution unit has an instruction queue for holding instructions awaiting execution in said execution unit; </claim-text><claim-text>a register coupled to said instruction queue of said execution unit, wherein said register stores a predetermined threshold value for said instruction queue and further wherein said register tracks a number of instructions in said instruction queue; </claim-text><claim-text>a counter connected to said register, said counter for counting a number of instructions in said instruction queue; </claim-text><claim-text>a comparator connected to said counter for comparing said number of instructions in said instruction queue with said predetermined threshold value to yield a result, wherein said comparator performs a comparison on more than one execution unit to yield a plurality of results, wherein further said comparator is coupled to an OR circuit which performs an ORing function on said plurality of results to yield a second result; and </claim-text><claim-text>a dispatch unit coupled to an instruction fetcher, said comparator and said instruction queue, wherein said dispatch unit receives instructions from said instruction fetcher, and when said instruction is speculative, said dispatch unit dispatches said instruction to said instruction queue of said execution unit only when said comparator yields a particular result. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6338133-B1-CLM-00011\" num=\"11\"><claim-text>11. The data processor of <claim-ref idref=\"US-6338133-B1-CLM-00010\">claim 10</claim-ref>, wherein said second result is either said particular result or a different result, and wherein said second result is provided to said comparator.</claim-text></claim>"}, {"num": 12, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6338133-B1-CLM-00012\" num=\"12\"><claim-text>12. The data processor of <claim-ref idref=\"US-6338133-B1-CLM-00010\">claim 10</claim-ref>, wherein further said register stores said predetermined threshold value.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53507679\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Technical Field</p><p>The present invention relates in general to a method and system for data processing and in particular to a method and system for executing instructions within a data processor. Still more particularly, the present invention relates to a method and system for executing instructions within a data processor such that speculative branch instructions are controlled to provide more efficient execution.</p><p>2. Description of the Related Art</p><p>A conventional high performance superscalar processor typically includes an instruction cache for storing instructions, an instruction buffer for temporarily storing instructions fetched from the instruction cache for execution, a number of execution units for executing sequential instructions, a branch processing unit (BPU) for executing branch instructions, a dispatch unit for dispatching sequential instructions from the instruction buffer to particular execution units, and a completion buffer for temporarily storing instructions that have finished execution, but have not been completed.</p><p>As is well known in the art, sequential instructions fetched from the instruction queue are stored within the instruction buffer pending dispatch to the execution units. In contrast, branch instructions fetched from the instruction cache are typically forwarded directly to the branch processing unit for execution. In some cases, the condition register value upon which a conditional branch depends can be ascertained prior to executing the branch instruction, that is, the branch can be resolved prior to execution. If a branch is resolved prior to execution, instructions at the target address of the branch instruction are fetched and executed by the processor. In addition, any sequential instructions following the branch that have been pre-fetched are discarded. However, the outcome of a branch instruction often cannot be determined prior to executing the branch instruction due to a condition register dependency. When a branch instruction remains unresolved at execution, the branch processing unit utilizes a prediction mechanism, such as a branch history table, to predict which execution path should be taken. In conventional processors, the dispatch of sequential instructions following a branch predicted as taken is halted and instructions within the speculative target instruction stream are fetched during the next processor cycle. If the branch that was predicted as taken is resolved as mispredicted, a mispredict penalty is incurred by the processor due to the cycle time required to restore the sequential execution stream following the branch instructions.</p><p>A high performance processor achieves high instruction throughput by fetching and dispatching instructions under the assumption that branches are correctly predicted and allows instructions to execute without waiting for the completion of previous instructions. This is commonly known as speculative execution, i.e., executing instructions that may or may not have to be executed. The CPU guesses which path the branch was going to take. This guess may be a very intelligent guess (as in a branch history table) or very simple (as in always guess path not taken). Once the guess is made, the CPU starts executing that path. Typically, the processor executes instructions speculatively when it has resources that would otherwise be idle, so that the operation may be done at minimum or no cost. Therefore, in order to enhance performance, some processors speculatively execute unresolved branch instructions by predicting whether or not the indicated branch will be taken. Utilizing the result of the prediction, the fetcher is then able to fetch instructions within the speculative execution path prior to the resolution of the branch, thereby avoiding a stall in the execution pipeline if the branch is resolved as correctly predicted. If the guess is correct, and there are no holes or delays in the pipeline, execution continues at full speed. If, however, subsequent events indicate that the speculative instruction should not have been executed, the processor has to abandon any result that the speculative instruction produced and begin executing the path that should have been taken. The processor \u201cflushes\u201d or throws away the instruction results, backs itself up to get a new address and executes the correct instruction.</p><p>Most operations can be performed speculatively, as long as the processor appears to follow a simple sequential method such as those in a scalar processor. For some applications, however, speculative operations can be a severe detriment to the performance of the processor. For example, in the case of executing a load instruction after a branch instruction (known as speculative load because the load instruction is executed speculatively without knowing exactly which path of the branch would be taken), if the predicted execution path is incorrect, there is a high delay penalty is incurred when the pending speculative load in the instruction stream requests the required data from the system bus. In many applications, the rate of mis-predicted branches is high enough that the cost of speculatively accessing the system bus is prohibitively expensive. Furthermore, essential data stored in a data cache may be displaced by some irrelevant data obtained from the system bus because of a wrongful execution of a speculative load instruction caused by misprediction.</p><p>Prior art handling of this speculative execution of instructions includes U.S. Pat. No. 5,454,117 which discloses a branch prediction hardware mechanism. The mechanism performs speculative execution based on the branch history information in a table. However, it does not provide a means for prediction based on the current status of the branch execution unit. Similarly, U.S. Pat. No. 5,611,063 discloses a method for tracking allocation of resources within a processor utilizing a resource counter which has two bits set in two possible states corresponding to whether or not the instruction is speculative or when dispatched to an execution unit respectively.</p><p>U.S. Pat. No. 5,752,014 discloses a selection from among a plurality of branch prediction methodologies, namely dynamic prediction and static prediction, in speculative execution of conditional branch instructions. It discusses the execution of the instructions based on the prediction and subsequent conditional branch instruction.</p><p>No prior art discloses a method or system for determining whether to dispatch a speculative instruction based on current loading conditions. Consequently, a processor and method for speculatively executing conditional branch instructions are needed which intelligently determines when it is necessary to utilize speculative prediction.</p><p>In modern microprocessors, there are many mechanisms known to speculatively execute instructions. Speculative execution can improve performance significantly if the speculation is correct. In speculatively executing branch instructions, prediction means improve the likelihood of guessing the correct path. However, if the guess is wrong recovery means must be utilized to cancel the effect of instructions that should not be completed. In actual practice, it is sometimes difficult and expensive to selectively cancel instructions as a result of a bad branch speculation. This is especially true in superscalar systems where instructions are executed out-of-order. A new method is needed to better determine when speculative branch instructions are to be dispatched.</p><p>It would therefore be desirable to provide a method and system for selectively executing speculative branch instructions in a high performance processor by utilizing a better prediction scheme. It is further desirable to provide a method and system which dispatch speculative instructions only when the system is below a predefined load capacity to prevent unfettered dispatching of speculative instructions.</p><h4>SUMMARY OF THE INVENTION</h4><p>It is therefore one object of the present invention to provide an improved data processor.</p><p>It is another object of the present invention to provide a method and system for executing instructions within a data processor.</p><p>It is yet another object of the present invention to provide a method and system for executing instructions within a data processor such that speculative branch instructions are controlled to provide more efficient execution.</p><p>The foregoing objects are achieved as is now described. A method and system is disclosed for speculative branch dispatching of instructions in a data processor. A processor having one or more buffers for storing instructions and one or more execution units for executing instructions is utilized. Each execution unit has a corresponding queue which holds instructions pending execution. First, a threshold level (selected maximum number of instructions in the instruction queue) is set. The current utilization measure for one or more execution units in the data processing system is then determined. The current utilization measure is compared to the predetermined threshold value; and a speculative branch instruction is dispatched to a selected execution unit when the current utilization measure is less than the predetermined threshold value.</p><p>In one embodiment of the invention, the branch dispatching check occurs at each unit individually. A comparison is made of the number of instructions queued to the execution unit with its threshold value. The dispatching step dispatches the branch instructions to that execution unit only when the number of instructions queued at the execution unit is lower than the threshold value for that unit.</p><p>The above as well as additional objects, features, and advantages of the present invention will become apparent in the following detailed written description.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>DESCRIPTION OF THE DRAWINGS</h4><p>The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself however, as well as a preferred mode of use, further objects and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:</p><p>FIG. 1 is a block diagram of a data processing system utilized in one embodiment of the present invention;</p><p>FIG. 2 is a block diagram of a preferred embodiment of a processor which utilizes the method and system of the present invention;</p><p>FIG. 3 is a flow chart depicting the process of instruction execution according to one implementation of the present invention;</p><p>FIG. 4A is a block diagram of the circuit components utilized within one embodiment of the present invention; and</p><p>FIG. 4B is a block diagram depicting an instruction queue and register in accordance with one embodiment of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENT</h4><p>With reference now to the figures and in particular with reference to FIG. 1, there is illustrated a block diagram of the basic structure of a data processing system <b>100</b> utilized in the preferred embodiment of the invention. Data processing system <b>100</b> has at least one central processing unit (CPU) or processor <b>10</b> which is connected to several peripheral devices, including input/output devices <b>114</b> (such as a display monitor, keyboard, and graphical pointing device) for user interface, a permanent memory device <b>116</b> (such as a hard disk) for storing the data processing system's operating system and user programs/applications, and a temporary memory device <b>118</b> (such as random access memory or RAM) that is utilized by processor <b>10</b> to implement program instructions. Processor <b>10</b> communicates with the peripheral devices by various means, including a bus <b>120</b> or a direct channel <b>122</b> (more than one bus may be provided utilizing a bus bridge).</p><p>Those skilled in the art will further appreciate that there are other components that might be utilized in conjunction with those shown in the block diagram of FIG. 1; for example, a display adapter connected to processor <b>10</b> might be utilized to control a video display monitor, and a memory controller may be utilized as an interface between temporary memory device <b>118</b> and processor <b>10</b>. Data processing system <b>100</b> also includes firmware <b>124</b> whose primary purpose is to seek out and load an operating system from one of the peripherals (usually permanent memory device <b>116</b>) whenever the data processing system is first turned on. In the preferred embodiment, data processing system contains a relatively fast CPU or processor <b>10</b> along with sufficient temporary memory device <b>118</b> and space on permanent memory device <b>116</b>, and other required hardware components necessary for providing efficient execution of instructions.</p><p>FIG. 2 is a block diagram of processor <b>10</b>, for processing information according to a preferred embodiment of the present invention. Processor <b>10</b> may be located within data processing system <b>100</b> as depicted in FIG. <b>1</b>. In the depicted embodiment, processor <b>10</b> comprises a single integrated circuit superscalar microprocessor. Accordingly, as discussed further below, processor <b>10</b> includes various execution units, registers, buffers, memories, and other functional units, which are all formed by integrated circuitry. In a preferred embodiment of the present invention, processor <b>10</b> comprises one of the PowerPc\u2122 line of microprocessors, which operates according to reduced instruction set computing (RISC) techniques. As depicted in FIG. 1, processor <b>10</b> is coupled to system bus <b>11</b> via a bus interface unit BIU <b>12</b> within processor <b>10</b>. BIU <b>12</b> controls the transfer of information between processor <b>10</b> and other devices coupled to system bus <b>11</b> such as a main memory (not illustrated). Processor <b>10</b>, system bus <b>11</b>, and the other devices coupled to system bus <b>11</b> together form a data processing system.</p><p>BIU <b>12</b> is connected to instruction cache <b>14</b> and data cache <b>16</b> within processor <b>10</b>. High speech caches, such as instruction cache <b>14</b> and data cache <b>16</b>, enable processor <b>10</b> to achieve relatively fast access time to a subset of data or instructions previously transferred from main memory to instruction cache <b>14</b> and data cache <b>16</b>, thus improving the speech of operation of the data processing system. Instruction cache <b>14</b> is further coupled to sequential fetcher <b>17</b>, which fetches instructions from instruction cache <b>14</b> during each cycle for execution. Sequential fetcher <b>17</b> transmits branch instructions fetched from instruction cache <b>14</b> to branch processing unit BPU <b>18</b> for execution, but stores sequential instructions within instruction queue <b>19</b> for execution by other execution circuitry within processor <b>10</b>.</p><p>In the depicted embodiment, in addition to BPU <b>18</b>, the execution circuitry of processor <b>10</b> comprises multiple execution units, including fixed-point unit (FXU) <b>22</b>, load/store unit (LSU) <b>28</b>, and floating-point unit (FPU) <b>30</b>. As is well known by those skilled in the art, each of execution units FXU <b>22</b>, LSU <b>28</b>, and FPU <b>30</b> executes one or more instructions within a particular class of sequential instructions during each processor cycle. For example, FXU <b>22</b> performs fixed-point mathematical operations such as addition, subtraction, ANDing, ORing, and XORing utilizing source operands received from specified general purpose registers (GPRs) <b>32</b>. Following the execution of a fixed point instruction, FXU <b>22</b> outputs the data results of the instruction to GPR rename buffers <b>33</b>, which provide temporary storage for the result data until the instruction is completed by transferring the result data from GPR rename buffers <b>33</b> to one or more of GPRs <b>32</b>. Conversely, FPU <b>30</b> performs floating-point operations, such as floating-point multiplication and division, on source operands received from floating-point registers FPRs <b>36</b>. FPU <b>30</b> outputs data resulting from the execution of floating-point instructions to selected FPR rename buffers <b>37</b>, which temporarily store the result data until the instructions are completed by transferring the result data from FPR rename buffers <b>37</b> to selected FPRs <b>36</b>. As its name implies, LSU <b>28</b> executes floating-point and fixed-point instructions which either load data from memory (i.e., either data cache <b>16</b> or main memory) into selected GPRs <b>32</b> or FPRs <b>36</b> or which store data from a selected GPRs <b>32</b> or FPRs <b>36</b> to memory.</p><p>Processor <b>10</b> employs both pipelining and out-of-order execution of instructions to further improve the performance of its superscalar architecture. Accordingly, instructions can by executed by FXU <b>22</b>, LSU <b>28</b>, and FPU <b>30</b> in any order as long as data dependencies are observed. In addition, instructions are processed by each of FXU <b>22</b>, LSU <b>28</b> and FPU <b>30</b> at a sequence of pipeline stages. As is typical of high performance processors, each instruction is processed at five distinct pipeline stages, namely, fetch, decode/dispatch, execute, finish and completion.</p><p>During the fetch stage, sequential fetcher <b>17</b> retrieves one or more instructions associated with one or more memory addresses from instruction cache <b>14</b>. Sequential instructions fetched from instruction cache <b>14</b> are stored by sequential fetcher <b>17</b> within registers such as instruction queue <b>19</b>. In contrast, sequential fetcher <b>17</b> removes branch instructions from the instruction stream and forwards them to BPU <b>18</b> for execution. BPU <b>18</b> includes a branch prediction mechanism, which in one embodiment comprises a dynamic prediction mechanism such as a branch history table, that enables BPU <b>18</b> to speculatively execute unresolved conditional branch instructions by predicting whether the branch will be taken. Alternatively, in other embodiments of the present invention, a static, compiler-based prediction mechanism is implemented. As will be described in greater detail below, the present invention minimizes branch misprediction and subsequent penalties incurred by processor <b>10</b> when speculative instruction branch prediction is desired.</p><p>During the decode/dispatch stage, dispatch unit <b>20</b> decodes and dispatches one or more instructions from instruction queue <b>19</b> to the appropriate ones of execution units FXU <b>22</b>, LSU <b>28</b> and FPU <b>30</b>. Decoding involves determining the type of instruction including its characteristics and the execution unit to which it should be dispatched. In the preferred embodiment, it also involves determining whether or not the instruction is speculative. Also during the decode/dispatch stage, dispatch unit <b>20</b> allocates a rename buffer within GPR rename buffers <b>33</b> or FPR rename buffers <b>37</b> for each dispatched instructions' result data. According to a preferred embodiment of the present invention, dispatch unit <b>20</b> is connected to execution units FXU <b>22</b>, LSU <b>28</b> and FPU <b>30</b> by a set of registers described below with reference to FIGS. 4A and 4B.</p><p>FIG. 4A depicts the execution units FXU <b>22</b>, LSU <b>28</b> and FPU <b>30</b> and their corresponding register <b>401</b>A, <b>401</b>B, and <b>401</b>C and queue <b>407</b>A, <b>407</b>B, and <b>407</b>C. Typically, each register <b>401</b>A, <b>401</b>B, and <b>401</b>C allocates a valid bit <b>403</b> associated with each entry/instruction queued to the execution unit FXU <b>22</b>, LSU <b>28</b>, and FPU <b>30</b> in its respective queue <b>407</b>A, <b>407</b>B, and <b>407</b>C. This bit <b>403</b> when \u201con\u201d (set to \u201c1\u201d) indicates that an instruction is present and is traditionally utilized to give prominence to that instruction within queue <b>401</b>A, <b>401</b>B, and <b>401</b>C. Threshold value <b>405</b>A, <b>405</b>B, and <b>405</b>C for execution unit FXU <b>22</b>, LSU <b>28</b>, and FPU <b>30</b> is also illustrated in FIG. <b>4</b>A. As illustrated each unit may have a unique threshold value <b>405</b>A, <b>405</b>B, and <b>405</b>C. In the preferred embodiment, the tracking of the number of instructions in each queue is implemented by counting the number of bits <b>403</b> in register <b>401</b>A, <b>401</b>B, and <b>401</b>C. Bits <b>401</b> are counted by counter <b>411</b> which is connected to register <b>401</b>A, <b>401</b>B, and <b>401</b>C. After an instruction has been executed the corresponding bit is reset (set to \u20180\u2019) reducing the number count for that queue in the preferred embodiment. Thus registers <b>401</b>A, <b>401</b>B, and <b>401</b>C are utilized to keep track of the number of instructions in each queue <b>407</b>A, <b>407</b>B, and <b>407</b>C of each execution unit FXU <b>22</b>, LSU <b>28</b>, and FPU <b>30</b> respectively. For the purposes of this illustrative embodiment, it is assumed that instructions are loaded sequentially into the queue of the execution units. Those skilled in the art understand that this representation does not preclude other representations and further that the instructions are not limited to being executed in the sequential manner as illustrated. It is further understood by those skilled in the art that alternative ways of tracking the number of instructions in an execution unit's queue are contemplated as falling within the scope of the present invention. Utilization of the registers as presented here is solely for illustrative purposes, and is not exclusive.</p><p>Dispatch unit <b>20</b> is also programmed to dispatch speculative instructions based on given conditions supplied to it from OR circuit <b>415</b> which is connected to comparator <b>413</b>. Comparator <b>413</b> is provided with the threshold values for each execution unit FXU <b>22</b>, LSU <b>28</b> and FPU <b>30</b>. In the preferred embodiment, when dispatch unit <b>20</b> receives a speculative branch instruction (determined during the decoding stage), it first checks the system load to determine whether or not to send the branch instruction. In the preferred embodiment, comparator <b>413</b> compares each execution unit load level (number of instructions awaiting execution) to its threshold value. The results of these comparisons are then ORed together by OR circuit <b>415</b> to yield a \u201cfalse,\u201d output when all of the units are below their threshold. If any one or more unit is above its threshold, then a \u201ctrue\u201d output is yielded. In the preferred embodiment, dispatch unit <b>20</b> will only dispatch a speculative branch instruction when the results of the OR function is false. Comparisons are made at the beginning of each cycle, while a speculative branch instruction is present. When the result is true, the speculative branch instruction is held until a false result is obtained. A false result may thus be obtained in the next cycle or in subsequent cycles. Those skilled in the art are familiar with the functioning of an OR circuit.</p><p>FIG. 4A illustrates one embodiment of how the checking stage of the invention is implemented. Threshold value <b>405</b>A, <b>405</b>B, and <b>405</b>C for each unit FXU <b>22</b>, LSU <b>28</b> and FPU <b>30</b>, is represented on its corresponding queue <b>407</b>A, <b>407</b>B and <b>407</b>C. The number of instructions in a given queue is determined by checking bits <b>403</b> of register <b>401</b>A, <b>401</b>B, and <b>401</b>C. In the illustrative embodiment, FXU <b>22</b> has less instructions in its queue <b>407</b>A than its threshold value <b>405</b>A. Load/Store Unit <b>28</b> also has less instructions in its queue <b>407</b>B than its threshold value <b>405</b>B. A comparison by comparator <b>413</b> yields a false result for both units. FPU <b>30</b> has more instructions than its threshold value <b>405</b>C and yields a true result when a comparison is done by comparator <b>413</b>. ORing these results together thus yields a true result and the speculative branch instruction is not dispatched.</p><p>In another embodiment of the invention, only the number of speculative instructions found within any one queue is tracked. This yields a more realistic picture of how speculative the branch instruction may be. Further, the threshold value is set as a predetermined number of such speculative instructions found in the queue. When a speculative branch instruction is presented, the comparison is made based on these two values. Thus in FIG. 4B, although FPU <b>30</b> has more total instructions <b>409</b> than the threshold value, only the instructions which are themselves speculative are counted. Instruction <b>1</b><b>409</b>A and Instruction <b>3</b><b>409</b>B are speculative. Comparator <b>413</b> checks this number of speculative instructions (2) against threshold value <b>405</b>C. Identifying speculative instructions in this embodiment entails keeping track of the instruction when it is dispatched from dispatch unit. In this embodiment, register <b>401</b>C is provided with an additional bit <b>404</b> for tracking whether or not an instruction is speculative.</p><p>The preferred embodiment of the invention is implemented on a general system level and determines the dispatching of speculative branches. Another embodiment of the invention is implemented on an individual execution unit level and determines the dispatching of a speculative instruction which targets a specific execution unit. Dispatch unit <b>20</b> checks the target execution unit's register to determine the number of instructions present in the unit's queue. Comparator <b>413</b> then compares this value with the corresponding threshold value. As in the preferred embodiment of the invention, when the threshold value is equal to or below the number of instructions in the unit's queue, dispatch unit <b>20</b> holds the speculative instruction until the next cycle or subsequent cycles. If the number of instructions in the unit's queue falls below the threshold value, dispatch unit <b>20</b> dispatches the speculative instruction to the execution units to await execution.</p><p>Those skilled in the art understand that although specific methods have been disclosed of determining the threshold value of an execution unit, the threshold value is in fact an arbitrary value which may be selected in a variety of ways. The invention as described contemplates all such selection methods.</p><p>During the execution stage, execution units FXU <b>22</b>, LSU <b>28</b> and FPU <b>30</b> execute instructions received from dispatch unit <b>20</b> as soon as the source operands for the indicated operations are available. After execution has terminated, execution units FXU <b>22</b>, LSU <b>28</b>, and FPU <b>30</b> store data results within either GPR rename buffers <b>33</b> or FPR rename buffers <b>37</b>, depending upon the instruction type. Then, execution units FXU <b>22</b>, LSU <b>28</b>, and FPU <b>30</b> signal completion unit <b>40</b> that the execution unit has finished an instruction. Finally, instructions are completed in program order by transferring result data from GPR rename buffers <b>33</b> or FPR rename buffers <b>37</b> to GPRs <b>32</b> or FPRs <b>36</b>, respectively.</p><p>The execution of instructions prior to the final possible definition of all conditions effecting execution is called speculative execution. To wait for the outcome of conditional branches, or the arrival of all possible interrupts, would make full concurrent processing impossible.</p><p>The present invention provides a novel method to disable speculative execution when resources are busy. In the preferred embodiment, this is achieved by allowing branch guessing only when it is likely that processor units will benefit from the speculation. More specifically, in the preferred embodiment, the dispatch of a speculative branch path is dependant on a measure of current utilization of the execution units. In general, if there are instructions executing and instructions queued up to be executed, then the need for additional instructions to be dispatched is less than if the execution units were waiting for work (i.e., new instructions to execute). Therefore, in the preferred embodiment of this invention, a decision to dispatch speculative instructions is based on the current utilization of the execution units. In one illustrative embodiment of the invention, the logic tracks how many instructions are queued up for each of the execution units and, based on a threshold for each execution unit, decides whether or not to dispatch speculative paths.</p><p>In the preferred embodiment of the invention, different units are assigned different threshold settings. Threshold levels are based on the unit's individual characteristics, such as, the type of instructions executed on the unit. For the purposes of this invention, a unit's threshold refers specifically to a number of instructions which are located within the unit's instruction queue awaiting execution. This number is variable depending on the system loading and the developer's choice. In the preferred embodiment, the threshold is typically a number less than the maximum number of instructions which can be stored in the unit's instruction queue. For instance, in the case of instructions which could be executed in Memory Load/Store execution units, the latency of these instructions may be large due to the nature of memory and cache management, and therefore, the threshold level for the Load/Store units is lower than for a unit that didn't have a memory latency involved in its operation.</p><p>In another embodiment of the invention, the number of instructions which had been dispatched (but not yet completed) is tracked as an indication of current execution unit utilization or as an indication of the amount of work (i.e., instructions) that was already assigned to the execution unit.</p><p>In one embodiment, the invention is implemented without pre-set threshold levels. The instructions are fetched and examined in the predicted path to identify which execution unit(s) would be the target for execution of these instructions and then, based on how many instructions were queued up (to these units). When the target unit had instructions queued up, then speculative instructions wouldn't be dispatched to this unit. When the unit is idle, however, speculative instructions would be dispatched to it. Those skilled in the art understand that the setting of a threshold value, though disclosed as the preferred embodiment, is not essential to the working of the present invention when implemented as described above.</p><p>The invention is preferably implemented in hardware and may be illustrated in terms of internal circuitry of a processor for enabling speculative branch dispatching as in FIG. <b>4</b>A. In this embodiment, counter <b>411</b> tracks the number of instructions waiting to be executed in each execution unit. Comparator <b>413</b> indicates when the number of instructions waiting to be executed exceeds a predetermined threshold. Also, OR circuit <b>415</b> then compares a plurality of comparison results to determine system loading. These circuit components are additional components coupled to each other and the existing components of a processor, namely dispatch unit <b>20</b>, instruction queue <b>407</b>, and register <b>401</b> to enable speculative dispatching only when a number of instructions waiting for execution is less than a is predetermined threshold.</p><p>The above embodiment consists of new circuitry components. Another embodiment of the invention utilizes current hardware components. The dispatching circuitry for example, currently has a large list of conditions which are checked prior to dispatching of an instruction. Adding additional conditions to implement the invention requires very little effort and may be preferred in certain circumstances. Additionally, the physical components described above, namely a comparator, a counter and an OR circuit may be implemented as software blocks within the data processing system. The invention is capable of being implemented in any system/processor. In the preferred embodiment, a superscalar processor with multiple execution units capable of handling multiple numbers of instruction simultaneously, is desired.</p><p>It is understood by those skilled in the art that instructions may exist in more than one state. An instruction may be waiting to be executed or it may have already been executed and is in some stage of completeness. The present invention contemplates setting threshold values and counting the number of instructions in the queue based on predetermined factors which the developer may implement. For instance, if an instruction will take a large number of cycles before it is completed, then it would be preferred to count that instruction. If, however, that same instruction has been executed and will be completed in the current or next cycle, then it would be preferred to not count the instruction.</p><p>FIG. 3 depicts a flow chart of the process involved in the implementation of the preferred embodiment of the present invention. The process begins (step <b>201</b>) with the system developer setting threshold values for each execution unit (step <b>203</b>). During running of an application, an instruction is fetched (step <b>205</b>) by the sequential fetcher and placed into a register (step <b>207</b>). The system then checks to see if the instruction is speculative, i.e. if it is a branch instruction and if branch guessing is required (step <b>209</b>). When the instruction is speculative, a further check is made to determine if the execution unit queue is at its threshold level (step <b>210</b>). As discussed above, there are several ways to make this determination. For example, a register attached to each execution unit is utilized to track the number of instructions queued and this number is compared against the threshold value by a comparator. If the queue is at its threshold value, the instruction is held in abeyance until some of the prior instructions in the queues are executed (step <b>211</b>). This may take several cycles; however, the instruction is presented again to determine whether or not it is still speculative (step <b>209</b>). If, however, the instruction queue is not at its threshold level, or when the instruction is not speculative, then it is sent to the execution unit's instruction queue (step <b>213</b>) and ultimately executed (step <b>215</b>). The process then checks memory for additional instructions to execute (step <b>217</b>). If more instructions are available then the process returns to fetch the next instruction (step <b>205</b>). Otherwise, the process ends (step <b>219</b>). It is understood by those skilled in the art that although the above example has been shown with reference to single individual instructions, any number of instructions may be fetched from memory and processed simultaneously depending on hardware capabilities.</p><p>While the invention has been particularly shown and described with reference to a preferred embodiment, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "David Andrew", "last_name": "Schroter", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTERNATIONAL BUSINESS MACHINES CORPORATION"}, {"first_name": "", "last_name": "INTERNATIONAL BUSINESS MACHINES CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/38"}, {"primary": false, "label": "G06F   9/312"}, {"primary": false, "label": "G06F   9/445"}, {"primary": false, "label": "G06F   9/24"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712214"}, {"primary": false, "label": "712E09049"}, {"primary": false, "label": "710057"}, {"primary": false, "label": "710054"}, {"primary": false, "label": "710056"}, {"primary": false, "label": "711145"}, {"primary": false, "label": "712E0905"}, {"primary": false, "label": "712207"}, {"primary": false, "label": "712206"}, {"primary": false, "label": "711125"}, {"primary": false, "label": "711144"}, {"primary": false, "label": "712245"}, {"primary": false, "label": "711137"}, {"primary": false, "label": "711123"}, {"primary": false, "label": "712239"}, {"primary": false, "label": "712237"}], "ecla_classes": [{"label": "G06F   9/38B8"}, {"label": "G06F   9/38E2"}, {"label": "G06F   9/38E"}], "cpc_classes": [{"label": "G06F   9/384"}, {"label": "G06F   9/3842"}, {"label": "G06F   9/3836"}, {"label": "G06F   9/3814"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1999-03-12", "application_date": "1999-03-12", "family_members": [{"ucid": "US-6338133-B1", "titles": [{"lang": "EN", "text": "Measured, allocation of speculative branch instructions to processor execution units"}]}]}