{"patent_number": "US-6807620-B1", "publication_id": 73998833, "family_id": 32176867, "publication_date": "2004-10-19", "titles": [{"lang": "EN", "text": "Game system with graphics processor"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11751851\" source=\"national office\"><p>The present invention relates to the architecture and use of a computer system optimized for the efficient modeling of graphics. The computer system has a primary processor and a graphics processor. The primary processor has two vector processor units within it, one which is closely connected to central processor unit. Simultaneously performing complex modeling calculations on the first vector processor and CPU, and geometry transformation calculations on the second vector processor, allows for efficient modeling of graphics. Furthermore, the graphics processor is optimized to rapidly switch between data flow from the two vector processors. In addition, the graphics processor is able to render many pixels simultaneously, and has a local memory on the graphics processor chip that acts as a frame buffer, texture buffer, and z buffer. This allows a high fill rate to the frame buffer.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50736523\"><p>The present invention relates to the architecture and use of a computer system optimized for the efficient modeling of graphics. The computer system has a primary processor and a graphics processor. The primary processor has two vector processor units within it, one which is closely connected to central processor unit. Simultaneously performing complex modeling calculations on the first vector processor and CPU, and geometry transformation calculations on the second vector processor, allows for efficient modeling of graphics. Furthermore, the graphics processor is optimized to rapidly switch between data flow from the two vector processors. In addition, the graphics processor is able to render many pixels simultaneously, and has a local memory on the graphics processor chip that acts as a frame buffer, texture buffer, and z buffer. This allows a high fill rate to the frame buffer.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00001\" num=\"1\"><claim-text>1. A primary processor for a computer system, said primary processor comprising:</claim-text><claim-text>a) a main bus; </claim-text><claim-text>b) a first processor unit connected to said main bus, said first processor unit having </claim-text><claim-text>i) a central processor unit; </claim-text><claim-text>ii) a first vector processor unit for performing first matrix calculations, said first vector processor unit connected to said central processor unit to enable said first vector processor unit to operate as a coprocessor for said central processor unit; </claim-text><claim-text>c) a second vector processor unit for performing second matrix calculations, said second vector processor unit connected to said main bus; </claim-text><claim-text>d) a graphics processor interface for arbitrating whether to transmit from said primary processor calculation results from said first processor unit or from said second vector processor unit, said graphics processor interface connected to said main bus and directly to said second vector processor unit. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00002\" num=\"2\"><claim-text>2. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00001\">claim 1</claim-ref>, wherein said first matrix calculations comprise calculations for complex modeling of objects for graphical display.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00003\" num=\"3\"><claim-text>3. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00002\">claim 2</claim-ref>, wherein said second matrix calculations comprise calculations for simple geometrical transformations of objects for graphical display.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00004\" num=\"4\"><claim-text>4. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00001\">claim 1</claim-ref>, wherein said primary processor is implemented as an integrated circuit on a single substrate.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00005\" num=\"5\"><claim-text>5. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00001\">claim 1</claim-ref>, wherein said first vector processor unit has at least four floating point processor pipelines.</claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00006\" num=\"6\"><claim-text>6. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00005\">claim 5</claim-ref>, wherein said second vector processor unit has at least four floating point processor pipelines.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00007\" num=\"7\"><claim-text>7. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00001\">claim 1</claim-ref>, wherein said main bus is at least 128-bits wide.</claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00008\" num=\"8\"><claim-text>8. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00007\">claim 7</claim-ref>, wherein said central processor unit has an internal bus which is at least 128-bits wide.</claim-text></claim>"}, {"num": 9, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00009\" num=\"9\"><claim-text>9. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00001\">claim 1</claim-ref>, further comprising an image processing unit for decompressing high-resolution texture data from a compressed state.</claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00010\" num=\"10\"><claim-text>10. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00009\">claim 9</claim-ref>, wherein said high-resolution texture data is encoded in the MPEG2 format.</claim-text></claim>"}, {"num": 11, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00011\" num=\"11\"><claim-text>11. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00001\">claim 1</claim-ref>, wherein said first vector processor unit includes a first vector interface for decompressing packed data.</claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00012\" num=\"12\"><claim-text>12. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00011\">claim 11</claim-ref>, wherein said second vector processor unit includes a second vector interface for decompressing packed data.</claim-text></claim>"}, {"num": 13, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00013\" num=\"13\"><claim-text>13. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00001\">claim 1</claim-ref>, wherein said central processor unit includes a scratchpad memory, said scratchpad memory comprising SRAM and acting as a double buffer between said central processor unit and said main bus.</claim-text></claim>"}, {"num": 14, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00014\" num=\"14\"><claim-text>14. A computer system comprising:</claim-text><claim-text>a) a primary processor as in <claim-ref idref=\"US-6807620-B1-CLM-00001\">claim 1</claim-ref>; </claim-text><claim-text>b) a graphics processor, implemented as an integrated circuit on a single substrate, for rendering three dimensional objects, said graphics processor, comprising </claim-text><claim-text>i) a graphics rendering engine; </claim-text><claim-text>ii) a local memory; </claim-text><claim-text>iii) a mode register for storing first data indicating when said graphics rendering engine is in a first mode corresponding to the receipt by said graphics rendering engine of data calculated by said first vector processor unit and said central processor unit, and for storing second data indicating when said graphics rendering engine is in a second mode corresponding to the receipt by said graphics rendering engine of data calculated by said second vector processor unit; </claim-text><claim-text>iv) a plurality of pairs of environmental registers, each of said pairs of environmental registers comprising a first register and a second register, each of said first registers storing data for determining how said graphics rendering engine processes data when said mode register stores said first data indicating said first mode, and each of said second registers storing data for determining how said graphics rendering engine processes data when said mode register stores said second data indicating said second mode; and </claim-text><claim-text>c) a graphics transfer bus connecting said graphics processor and said primary processor. </claim-text></claim>"}, {"num": 15, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00015\" num=\"15\"><claim-text>15. A primary processor for a computer system, said primary processor comprising:</claim-text><claim-text>a) a main bus; </claim-text><claim-text>b) a coprocessor bus; </claim-text><claim-text>c) an interface bus; </claim-text><claim-text>d) a central processor unit connected to said main bus and to said coprocessor bus; </claim-text><claim-text>e) a first vector processor unit for performing first matrix calculations, said first vector processor being connected to said main bus and directly to said central processing unit through said coprocessor bus to enable said first vector processor unit to operate as a coprocessor for said central processor unit; </claim-text><claim-text>f) a second vector processor unit for performing second matrix calculations, said second vector processor unit connected to said main bus and said interface bus; </claim-text><claim-text>g) a graphics processor interface for arbitrating whether to transmit from said primary processor calculation results from said first vector processor unit and said central processor unit, or from said second vector processor unit, said graphics processor interface connected to said main bus and directly to said second vector processor unit through said interface bus. </claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00016\" num=\"16\"><claim-text>16. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00015\">claim 15</claim-ref>, wherein said first matrix calculations comprise calculations for complex modeling of objects for graphical display.</claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00017\" num=\"17\"><claim-text>17. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00016\">claim 16</claim-ref>, wherein said second matrix calculations comprise calculations for simple geometrical transformations of objects for graphical display.</claim-text></claim>"}, {"num": 18, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00018\" num=\"18\"><claim-text>18. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00015\">claim 15</claim-ref>, wherein said primary processor is implemented as an integrated circuit on a single substrate.</claim-text></claim>"}, {"num": 19, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00019\" num=\"19\"><claim-text>19. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00015\">claim 15</claim-ref>, wherein said first vector processor unit has at least four floating point processor pipelines.</claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00020\" num=\"20\"><claim-text>20. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00019\">claim 19</claim-ref>, wherein said second vector processor unit has at least four floating point processor pipelines.</claim-text></claim>"}, {"num": 21, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00021\" num=\"21\"><claim-text>21. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00015\">claim 15</claim-ref>, wherein said main bus is at least 128-bits wide.</claim-text></claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00022\" num=\"22\"><claim-text>22. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00021\">claim 21</claim-ref>, wherein said central processor unit has an internal bus which is at least 128-bits wide.</claim-text></claim>"}, {"num": 23, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00023\" num=\"23\"><claim-text>23. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00015\">claim 15</claim-ref>, further comprising an image processing unit for decompressing high-resolution texture data from a compressed state.</claim-text></claim>"}, {"num": 24, "parent": 23, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00024\" num=\"24\"><claim-text>24. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00023\">claim 23</claim-ref>, wherein said high-resolution texture data is encoded in the MPEG2 format.</claim-text></claim>"}, {"num": 25, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00025\" num=\"25\"><claim-text>25. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00015\">claim 15</claim-ref>, wherein said first vector processor unit includes a first vector interface for decompressing packed data.</claim-text></claim>"}, {"num": 26, "parent": 25, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00026\" num=\"26\"><claim-text>26. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00025\">claim 25</claim-ref>, wherein said second vector processor unit includes a second vector interface for decompressing packed data.</claim-text></claim>"}, {"num": 27, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00027\" num=\"27\"><claim-text>27. The primary processor of <claim-ref idref=\"US-6807620-B1-CLM-00015\">claim 15</claim-ref>, wherein said central processor unit includes a scratchpad memory, said scratchpad memory comprising SRAM and acting as a double buffer between said central processing unit and said main bus.</claim-text></claim>"}, {"num": 28, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00028\" num=\"28\"><claim-text>28. A computer system comprising:</claim-text><claim-text>a) a primary processor as in <claim-ref idref=\"US-6807620-B1-CLM-00015\">claim 15</claim-ref>; </claim-text><claim-text>b) a graphics processor for rendering three dimensional objects; and </claim-text><claim-text>c) a graphics transfer bus connecting said graphics processor and said primary processor. </claim-text></claim>"}, {"num": 29, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00029\" num=\"29\"><claim-text>29. The computer system of <claim-ref idref=\"US-6807620-B1-CLM-00028\">claim 28</claim-ref>, wherein said graphics processor is implemented as an integrated circuit on a single substrate, and includes:</claim-text><claim-text>a) a graphics rendering engine, comprising: </claim-text><claim-text>i) a mode register for storing first data indicating when said graphics rendering engine is in a first mode corresponding to the receipt by said graphics rendering engine of data calculated by said first vector processor unit and said central processor unit, and for storing second data indicating when said graphics rendering engine is in a second mode corresponding to the receipt by said graphics rendering engine of data calculated by said second vector processor unit; </claim-text><claim-text>ii) a plurality of pairs of environmental registers, each of said pairs of environmental registers comprising a first register and a second register, each of said first registers storing data for determining how said graphics rendering engine processes data when said mode register indicates said first mode, and each of said second registers storing data for determining how said graphics rendering engine processes data when said mode register indicates said second mode; and </claim-text><claim-text>b) a local memory. </claim-text></claim>"}, {"num": 30, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00030\" num=\"30\"><claim-text>30. A graphics processor implemented as an integrated circuit on a single substrate, said graphics processor comprising:</claim-text><claim-text>a) a graphics rendering engine, said graphics rendering engine comprising: </claim-text><claim-text>i) a mode register for storing first data indicating when said graphics rendering engine is in a first mode corresponding to the receipt by said graphics rendering engine of data calculated by a first vector processor unit and a central processor unit, and for storing second data indicating when said graphics rendering engine is in a second mode corresponding to the receipt by said graphics rendering engine of data calculated by a second vector processor unit; </claim-text><claim-text>ii) a plurality of pairs of environmental registers, each of said pairs of environmental registers comprising a first register and a second register, each of said first registers storing data for determining how said graphics rendering engine processes data when said mode register stores said first data indicating said first mode, and each of said second registers storing data for determining how said graphics rendering engine processes data when said mode register stores said second data indicating said second mode; and </claim-text><claim-text>b) a local memory. </claim-text></claim>"}, {"num": 31, "parent": 30, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00031\" num=\"31\"><claim-text>31. The graphics processor of <claim-ref idref=\"US-6807620-B1-CLM-00030\">claim 30</claim-ref>, wherein said graphics rendering engine includes logic circuitry for implementing alpha blending.</claim-text></claim>"}, {"num": 32, "parent": 30, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00032\" num=\"32\"><claim-text>32. The graphics processor of <claim-ref idref=\"US-6807620-B1-CLM-00030\">claim 30</claim-ref>, wherein said graphics rendering engine includes logic circuitry for implementing fogging.</claim-text></claim>"}, {"num": 33, "parent": 30, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00033\" num=\"33\"><claim-text>33. The graphics processor of <claim-ref idref=\"US-6807620-B1-CLM-00030\">claim 30</claim-ref>, wherein said graphics rendering engine includes logic circuitry for a depth test to implement Z-buffering.</claim-text></claim>"}, {"num": 34, "parent": 30, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00034\" num=\"34\"><claim-text>34. The graphics processor of <claim-ref idref=\"US-6807620-B1-CLM-00030\">claim 30</claim-ref>, wherein said graphics rendering engine includes logic circuitry for implementing a destination alpha test.</claim-text></claim>"}, {"num": 35, "parent": 30, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00035\" num=\"35\"><claim-text>35. The graphics processor of <claim-ref idref=\"US-6807620-B1-CLM-00030\">claim 30</claim-ref>, wherein said graphics rendering engine includes logic circuitry for implementing an alpha test.</claim-text></claim>"}, {"num": 36, "parent": 30, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00036\" num=\"36\"><claim-text>36. The graphics processor of <claim-ref idref=\"US-6807620-B1-CLM-00030\">claim 30</claim-ref>, wherein said local memory includes a frame buffer, a texture buffer, and a z-buffer.</claim-text></claim>"}, {"num": 37, "parent": 36, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00037\" num=\"37\"><claim-text>37. The graphics processor of <claim-ref idref=\"US-6807620-B1-CLM-00036\">claim 36</claim-ref>, wherein said graphics rendering engine includes logic circuitry for filling said frame buffer with a rectangle of at least 16 pixels per clock cycle, and wherein said rectangle can be initiated at a different column for each row of a single polygon being rendered.</claim-text></claim>"}, {"num": 38, "parent": 36, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00038\" num=\"38\"><claim-text>38. The graphics processor of <claim-ref idref=\"US-6807620-B1-CLM-00036\">claim 36</claim-ref>, wherein said graphics rendering engine includes logic circuitry for implementing a moving stamp in writing to said frame buffer.</claim-text></claim>"}, {"num": 39, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00039\" num=\"39\"><claim-text>39. A method of performing graphics calculations comprising the steps of:</claim-text><claim-text>a) performing first calculations in a first data stream using a first processor, wherein said first calculations comprise calculations for complex modeling of objects for graphical display; </claim-text><claim-text>b) simultaneously performing second calculations in a second data stream using a second processor, wherein said second data stream is parallel to said first data stream and said second calculations comprise calculations for simple geometrical transformations of objects for graphical display. </claim-text></claim>"}, {"num": 40, "parent": 39, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00040\" num=\"40\"><claim-text>40. The method of <claim-ref idref=\"US-6807620-B1-CLM-00039\">claim 39</claim-ref>, further comprising the step of arbitrating whether said first calculations or said second calculations are transmitted to a graphics processor at any given time.</claim-text></claim>"}, {"num": 41, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00041\" num=\"41\"><claim-text>41. A method of programming a graphics program comprising the steps of:</claim-text><claim-text>a) designating first calculations to be processed by a first processor, wherein said first calculations comprise calculations for complex modeling of objects for graphical display; </claim-text><claim-text>b) designating second calculations to be calculated by a second processor, wherein said second calculations comprise calculations for simple geometrical transformations of objects for graphical display; and </claim-text><claim-text>c) processing said first calculations and said second calculations simultaneously; and </claim-text><claim-text>d) arbitrating whether said first calculations or said second calculations are transmitted to a graphics processor at any given time. </claim-text></claim>"}, {"num": 42, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00042\" num=\"42\"><claim-text>42. A system for performing graphics calculations comprising:</claim-text><claim-text>a) a first processor for performing first calculations and transmitting said first calculations in a first data stream, said first calculations comprising calculations for complex modeling of objects for graphical display; </claim-text><claim-text>b) a second processor for performing second calculations and transmitting said second calculations in a second data stream, said second data stream being parallel to said first data stream and said second calculations comprising calculations for simple geometrical transformation of objects for graphical display. </claim-text></claim>"}, {"num": 43, "parent": 42, "type": "dependent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00043\" num=\"43\"><claim-text>43. A system as in <claim-ref idref=\"US-6807620-B1-CLM-00042\">claim 42</claim-ref>, further comprising an interface circuit for receiving said first data stream and said second data stream and for determining whether said first data stream or said second data stream is transmitted to a third processor for rendering.</claim-text></claim>"}, {"num": 44, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6807620-B1-CLM-00044\" num=\"44\"><claim-text>44. A system for performing graphics calculations comprising:</claim-text><claim-text>a) a first processor for performing first graphics calculations and transmitting said first graphics calculations in a first data stream; </claim-text><claim-text>b) a second processor for performing second graphics calculations and transmitting said second graphics calculations in a second data stream; </claim-text><claim-text>c) an interface circuit for receiving said first data stream and said second data stream and for determining whether said first data stream or said second data stream is transmitted to a third processor for rendering; </claim-text><claim-text>wherein said first graphics calculations comprise calculations for complex modeling of objects for graphical display and said second graphics calculations comprise calculations for sample geometrical transformations of objects for graphical display.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54319916\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>FIELD OF THE INVENTION</h4><p>The present invention relates to computer system architectures. More particularly, the present invention relates to the architecture and use of a computer system optimized for efficient modeling of graphics.</p><h4>BACKGROUND OF THE INVENTION</h4><p>High resolution, real time computer graphics are an important aspect of computer systems, particularly simulators (such as flight simulators) and game machines. Computer games, in particular, involve a great deal of computer graphics. Computer systems used as game machines, therefore, must handle far more computer graphics than a standard business computer used primarily for word processing or similar applications.</p><p>The game developer is faced with many limitations. He or she often wants realistic, highly detailed graphics. Prior art game machines, however, make the implementation of such graphics difficult. High resolution graphics are computationally expensive and difficult to render in the time required by a fast moving game. Current graphics co-processors, if implemented at all in game consoles, have difficulty supplying the bandwidth necessary to render high resolution, real time graphics.</p><p>Prior art game machines also do not permit easy behavioral and physical modeling of game objects. Many objects in a game would be more realistically rendered if their position and shape could be calculated, or modeled, under a set of rules or equations. However, such modeling is computationally expensive, requiring many floating point operations, and the standard CPU is not optimized for such calculations.</p><p>Prior art game machines also cannot easily deal with compressed video data. As game developers code larger and larger game worlds, they are in danger of running out of space in removable media. The use of compression techniques to store various kinds of data, such as graphics data, is limited by the need to decompress such data quickly for use in a real time, interactive game.</p><p>Prior art game machines also are generally restricted to gaming applications. Given the increasing computational power of gaming systems, developers are looking at other applications for game consoles besides gaming. However, limitations in input and output interfaces render such applications difficult.</p><h4>SUMMARY OF THE INVENTION</h4><p>The present invention provides an improved computer system particularly suited for simulators and game machines. The system includes a new computer architecture for such devices. This architecture comprises a main processor and a graphics processor. The main processor contains two co-processors for geometry modeling and a central processing unit(CPU).</p><p>In one aspect, the present invention provides a frame buffer and rendering system on the same integrated chip. This structure enables the computer system to draw many pixels in parallel to the frame buffer at a very high fill rate (high band width). As a result, the computer system can provide quick renderings of screen images at a high resolution.</p><p>In another aspect, the present invention provides a main processor with a 128-bit bus throughout this processor connecting all co-processors and a memory system. This structure enables the passing of data and instructions quickly from component to component, thereby improving bandwidth resolution and speed.</p><p>In another aspect, the present invention provides sub-processors with four floating-point, multiply-add arithmetic logic units (ALUs). These four ALUs enable the processing of four 32-bit operations simultaneously from the data of two 128-bit registers. This structure, therefore, enables parallel, 128-bit floating point calculations through parallel pipelining of similar calculations to, e.g., assist in modeling and geometry transformations.</p><p>The present invention, in a preferred embodiment, further provides a multimedia instruction set using 128 bit wide integer registers in parallel. This structure enables the handling of different size integers in parallel (64-bits\u00d72, or 32-bits\u00d74, or 16-bits\u00d78 or 8-bits\u00d716).</p><p>In yet another aspect, the present invention provides two geometry engines feeding in parallel into one rendering engine. One geometry engine preferably consists of the CPU, for flexible calculations, tightly coupled to a vector operation unit as a co-processor, for complex irregular geometry processing such as modeling of physics or behavior. The second geometry engine preferably is a programmable vector operation unit for simple, repetitive geometry processing such as background and distant views (simple geometrical transformations).</p><p>In accordance with this aspect of the invention, each geometry engine preferably provides data (termed display lists) that are passed to the rendering engine. Arbitrator logic between the geometry engines and the rendering engine determines the order in which these data are passed to the rendering engine. The second geometry engine preferably is given priority over the first, as the second geometry engine generally has more data to send, and the first geometry engine is buffered in case of interruption. With this structure, the application programmer can, e.g., specify which geometry engine should do particular graphics processing, thereby enabling sophisticated behavioral and physical modeling in real time.</p><p>Also, in accordance with this aspect of the invention, the rendering engine remembers the data from each geometry engine and stores these data until deliberately changed. These data, therefore, do not require resending when the rendering engine begins receiving data from a different geometry engine, thereby enhancing speed.</p><p>In yet another aspect, the present invention provides a specialized decompression processor for decompressing high-resolution texture data from a compressed state as stored in main memory. This processor allows for more efficient use of memory.</p><p>In a preferred embodiment, the present invention provides a system for packing modeling data into optimal bit widths in data units in main memory. Unpacking logic in the vector processors automatically unpacks these data without sacrificing performance.</p><p>In yet another aspect, the present invention provides all processors with a local cache memory. This architecture reduces the amount of data that is required to be transmitted on the relevant buses. In accordance with this aspect of the invention, the cache of the CPU is divided into an instruction cache and a data cache. The data cache first loads a necessary word from a cache line (sub-block ordering) and permits a hazard-free, cache-line hit while a previous load is still in process (hit-under-miss). The output from the cache is also buffered in a write back buffer. This structure allows write requests to be stored until the main bus is free.</p><p>A particularly preferred embodiment of the invention provides a scratchpad RAM that works as a double buffer for the CPU. In an application dealing primarily with computer graphics, most of the data written out of the primary processor will be in the form of display lists, which contain the results of geometry calculations in the form of vertex information of primitive objects. These display lists, once generated, will not be needed again by the primary processor because they are a final result to be passed on to the geometry processor. Therefore, there is no benefit derived from caching these data in a traditional data cache when writing out this data (a write access scheme). However, most data read by such a computer graphics application are three-dimensional object data. A whole object must be cached in order to effect the speed of the CPU access to the object. The scratchpad allows a fast way to simultaneously write the display lists and read the object data without going through the standard data cache. Direct memory access (\u201cDMA\u201d) transfers between the main memory and the scratchpad allows data transfer without CPU overhead. Treating the scratchpad as a double buffer hides main memory latency from the CPU.</p><p>Another aspect of the present invention is the provision of common protocol data jacks for enabling multiple types of inputs and outputs.</p><p>These and other aspects of the present invention will become apparent by reference to the following detailed description of the preferred embodiments and the appended claims.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 is a block diagram of the key components of the computer system.</p><p>FIG. 2 is a block diagram of the primary processor.</p><p>FIG. 3 is a block diagram of the primary processor core.</p><p>FIG. 4 is a block diagram showing the relationship of the primary processor core to vector processing unit zero and vector processing unit one.</p><p>FIG. 5 is a block diagram of vector processing unit zero.</p><p>FIG. 6 is a diagram further illustrating the relationship of the primary processor core and vector processing unit zero.</p><p>FIG. 7 is a block diagram of vector processing unit one.</p><p>FIG. 8 is a block diagram of the graphics processor interface (\u201cGIF\u201d) showing its possible data paths.</p><p>FIG. 9 is a block diagram of the image processing unit (\u201cIPU\u201d).</p><p>FIG. 10 is a block diagram of the S bus interface (\u201cSIF\u201d).</p><p>FIG. 11 is a block diagram of the graphics processor.</p><p>FIG. 12 is a block diagram of the process of rendering pixels in the graphics processor.</p><p>FIG. 13 is a block diagram of the process of texture mapping in the graphics processor.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</h4><p>As discussed above, the present invention provides a computer system for providing high resolution computer graphics. The invention is particularly suited for interactive devices operating in real time or with other response time requirements (e.g., simulators and game machines). A preferred embodiment of the present invention, designed for a computer game machine, is described below.</p><p>FIG. 1 is a block diagram of computer system <b>1</b>. Computer system <b>1</b> consists primarily of primary processor <b>3</b>, graphics processor <b>5</b>, main memory <b>7</b> and input/output processor <b>9</b>.</p><p>Primary processor <b>3</b> is a single 240 mm<sup>2 </sup>chip, created using a 0.25-micron photolithography process, with 10.5 million transistors which operates at 300 MHz. Primary processor <b>3</b> is connected to graphics processor <b>5</b> by a 64-bit bus <b>11</b> and to main memory <b>7</b> by a pair of 16-bit buses <b>13</b>. Primary processor <b>3</b> is further connected to input/output processor <b>9</b> by a 32-bit SBUS <b>15</b>. Graphics processor <b>5</b> is connected to a monitor (not shown) through monitor connection <b>17</b>. Input/output processor <b>9</b> transmits and receives data through input/output device connections <b>19</b>.</p><p>FIG. 2 shows the major components of primary processor <b>3</b>. Primary processor <b>3</b> includes a 128-bit internal primary processor bus <b>21</b>, primary processor core <b>23</b>, floating point unit (FPU) <b>25</b>, a first vector processing unit (VPU<b>0</b>) <b>27</b>, a second vector processing unit (VPU<b>1</b>) <b>29</b>, image processing unit (IPU) <b>31</b>, dynamic random access memory controller (DRAMC) <b>33</b>, S-bus interface (SIF) <b>35</b>, direct memory access controller (DMAC) <b>37</b>, timer <b>39</b>, interrupt controller (INTC) <b>41</b> and graphics processor interface (GIF) <b>43</b>.</p><p>FIG. 3 shows the primary components of primary processor core <b>23</b>. Primary processor core <b>23</b> is the CPU of computer system <b>1</b>. Primary processor core <b>23</b> has a 2-way superscalar architecture for enabling two instructions to be executed per cycle.</p><p>The primary components of the primary processor core include a 32-bit program counter <b>45</b>. The program counter <b>45</b> contains a 64-entry branch target address cache (BTAC) for use in performing branch predictions. Primary processor core <b>23</b> predicts whether a conditional branch will be taken and whether to prefetch code from the appropriate location. When a branch instruction is executed, its address and that of the next instruction to be executed (the chosen destination of the branch) are stored in the branch target address cache. This information is used to predict which way the next instruction will branch when it is executed so that instruction prefetch can continue.</p><p>The instruction address from program counter <b>45</b> is transmitted to the instruction translation look-aside buffer <b>47</b>. Instruction translation look-aside buffer <b>47</b> is a table used in a virtual memory system for listing the physical address page number associated with each virtual address page number. Instruction translation look-aside buffer <b>47</b> is used in conjunction with instruction cache <b>49</b> whose tags are based on virtual addresses. Instruction cache <b>49</b> is an on-chip memory which is much faster than main memory <b>7</b> and which sits in between primary processor core <b>23</b> and main memory <b>7</b>. Instruction cache <b>49</b> stores recently accessed data to speed up subsequent accesses to the same data. Instruction cache <b>49</b> does this exclusively with instructions.</p><p>A virtual address is presented simultaneously to the instruction translation look-aside buffer <b>47</b> and to instruction cache <b>49</b> so that cache access and the virtual-to-physical address translation can proceed in parallel (the translation is done \u201con the side\u201d). If the requested address is not cached, then the physical address is used to locate the requested data in main memory <b>7</b>. Instruction cache <b>49</b> is a 2-way set associative cache. It receives physical instruction addresses from the instruction translation look-aside buffer <b>47</b> and the virtual instruction addresses from the program counter <b>45</b>. The instruction cache <b>49</b> receives cached instructions over BIU bus <b>51</b>.</p><p>Instruction cache <b>49</b> also performs an instruction prefetch to minimize the time primary processor core <b>23</b> spends waiting for instructions to be fetched from main memory <b>7</b>. Instructions following the one currently being executed are loaded into a prefetch queue when the external busses are idle. If the primary processor core <b>23</b> executes a branch instruction, or receives an interrupt, then the queue must be flushed and reloaded from the new address.</p><p>Instruction issue logic and staging register <b>53</b> receives the appropriate instructions from the instruction cache <b>49</b> as determined by program counter <b>45</b>, and then determines how to route the instructions to the appropriate one of six pipelines <b>65</b>, <b>67</b>, <b>63</b>, <b>61</b>, <b>71</b> and <b>73</b>. Instruction issue logic and staging register <b>53</b> can pass the instructions to either general purpose registers <b>55</b> or the pipelines themselves.</p><p>General purpose registers <b>55</b> contain 32 128-bit general purpose registers. This large number of registers allows for the handling of many instructions in parallel. These registers are passed information from the result and move buses <b>57</b>. General Purpose registers <b>55</b> can also transmit information to, and receive information from, operand/bypass logic <b>59</b>. An operand is an argument of the machine language instruction set of primary processor core <b>23</b>. Operand/bypass logic <b>59</b> can also receive information from the result and move busses <b>57</b>. This scheme allows operand/bypass logic <b>59</b> to take operands from the pipelines for immediate use, thus improving performance. If necessary, data can be stored back in the general purpose registers <b>55</b>. The operand/bypass logic <b>59</b> can also send appropriate data to scratchpad RAM <b>77</b> and data cache <b>75</b>. Operand/bypass logic <b>59</b> can, of course, also pass appropriate data to the appropriate pipes of the pipelines.</p><p>Each of the 6 pipelines, pipelines <b>65</b>, <b>67</b>, <b>63</b>, <b>61</b>, <b>71</b> and <b>73</b>, is a sequence of functional units (\u201cstages\u201d) for performing a task in several steps, like an assembly line in a factory. Each pipeline is passed operands from the operand/bypass logic <b>59</b>, or the instruction issue logic staging register <b>53</b>, and passes its results to the result and move bus <b>57</b>. Each functional unit of a pipeline receives inputs from the previous unit and produces outputs which are stored in an output buffer. One stage's output buffer is the next stage's input buffer. This arrangement allows all the stages to work in parallel thus giving greater throughput than if each input had to pass through the whole pipeline before the next input could enter.</p><p>Four of the six pipelines are integer pipelines. The two primary integer pipelines are I0 pipeline <b>61</b> and I1 pipeline <b>63</b>. These pipelines each contain a complete 64-bit ALU (arithmetic logic unit), a shifter, and a multiply accumulate unit. The ALU performs addition, subtraction multiplication of integers, AND, OR, NOT, XOR and other arithmetic and Boolean operations. I1 pipeline <b>63</b> contains a LZC (leading zero counting) unit. Pipelines IO <b>61</b> and I<b>1</b><b>63</b> also share a single 128-bit multimedia shifter. These two pipes are configured dynamically into a single 128-bit execution pipe per instruction to execute certain 128-bit instructions, such as Multimedia, ALU, Shift and MAC instructions.</p><p>LS pipe (load/store pipe) <b>65</b> and BR pipe (travel pipe) <b>67</b> also are integer pipelines. LS pipe <b>65</b> contains logic to support 128-bit load and store instructions which can access main memory <b>7</b>. BR pipe <b>67</b> contains logic to execute a branch instruction.</p><p>The remaining pipelines, C1 pipe <b>71</b> and C2 pipe <b>73</b> support the two coprocessors of system <b>1</b>, floating point unit (FPU) <b>25</b> and vector processing unit (VPUO) <b>27</b> (see FIG. <b>2</b>).</p><p>Floating point registers <b>69</b> are used to hold and pass data for C1 pipe <b>71</b>. This pipe contains logic to support the floating point unit <b>25</b> as a coprocessor. There are 32 32-bit floating point registers <b>69</b> which are given data by the operand/bypass logic <b>59</b>.</p><p>C2 pipe <b>73</b> contains logic to support VPU<b>0</b><b>27</b> as a coprocessor.</p><p>As noted above, all of the pipelines provide their output to result and move bus <b>57</b>. Result and move bus <b>57</b> passes the data back to operand/bypass logic <b>59</b>. Operand/bypass logic <b>59</b> sends data that are finished with computation to data cache <b>75</b> and the scratchpad RAM <b>77</b>.</p><p>Data cache <b>75</b> is a 2-way set associative cache which is 8 KB in size. Data cache <b>75</b> loads a necessary word from a cache line first (sub-block ordering) and permits a hazard-free cache-line hit while a previous load is still under process (hit-under-miss).</p><p>The smallest unit of memory than can be transferred between the main memory and the cache is known as a \u201ccache line\u201d or \u201ccache block\u201d. Rather than reading a single word or byte from main memory at a time, a whole line is read and cached at once. This scheme takes advantage of the principle of locality of reference: if one location is read, then nearby locations (particularly following locations) are likely to be read soon afterwards. It also takes advantage of page-mode DRAM which allows faster access to consecutive locations.</p><p>The output from data cache <b>75</b> is also buffered in write back buffer <b>79</b>. Data cache <b>75</b> has a write back protocol. Under this protocol, cached data is only written to main memory <b>7</b> when a later write runs out of memory in the cache and forces out the previous cache. Write back buffer <b>79</b> is an 8-entry by 16-byte first-in-first-out (FIFI) buffer (\u201cFIFO\u201d). Its use allows write requests to data cache <b>75</b> to be stored until the main internal primary processor bus <b>21</b> is free. This scheme increases the performance of primary processor core <b>23</b> by decoupling the processor from the latencies of main internal primary processor bus <b>21</b>.</p><p>Scratchpad RAM <b>77</b> is 16 KB of static RAM or (sRAM). As discussed above, scratchpad RAM <b>77</b> is used as a double buffer to hide latency of main memory <b>7</b> from the primary processor core <b>23</b>. Scratchpad RAM <b>77</b> has external DMA read and write capability for further speeding up access to main memory <b>7</b>. Response buffer <b>81</b> buffers scratchpad RAM <b>77</b> from primary processor internal bus <b>21</b>.</p><p>Memory management unit <b>83</b> supports virtual memory and paging by translating virtual addresses into physical addresses. Memory management unit <b>83</b> can operate in a 32-bit and 64-bit data mode. Memory management unit <b>83</b> has a 48-double-entry full-set-associative address translation look-aside buffer (TLB). In other words, it has 48 entries of even/odd page pairs for 96 pages total. A page is a group of memory cells in RAM that are accessed as parts of a single operation. That is, all the bits in the group of cells are changed at the same time. The page size for memory management unit <b>83</b> can range from 4 KB to 16 MB by multiples of 4. The virtual address size is 32-bits and the physical address size is 32-bits.</p><p>Memory management unit <b>83</b> sends updates via TLB refill bus <b>85</b> to data address translation look-aside buffer (DTLB) <b>87</b> and instruction address translation look-aside buffer <b>47</b>. These data refresh the tables in these functional units. Instruction address translation look-aside buffer <b>47</b> has 2 entries and translation look-aside buffer <b>87</b> has 4 entries.</p><p>Data translation look-aside buffer <b>87</b> translates virtual data addresses to physical data addresses. The physical data addresses are sent to either data cache <b>75</b> or result and move bus <b>57</b>.</p><p>Uncached accelerated buffer (UCAB) <b>88</b> is also passed from memory management unit <b>83</b>. Uncached accelerated buffer (UCAB) <b>88</b> is a 2 entry by 4 by 16-byte buffer. It caches 128 sequential bytes of old data during an uncached accelerated load miss. If the address hits in the UCAB <b>88</b>, the loads from the uncached accelerated space get the data from this buffer.</p><p>Bus interface unit <b>89</b> connects primary processor main internal bus <b>21</b> to the BIU bus <b>51</b> and thus to primary processor core <b>23</b>.</p><p>An instruction set is the collection of machine language instructions that a particular processor understands. In general, the instruction set that operates a processor characterizes the processor. The instruction set for computer system <b>1</b> has 64-bit words that conform to most of the MIPS III (and partially to the MIPS IV) specifications. Specifically, the instruction set implements all the MIPS III instructions with the exception of 64-bit multiply, 64-bit divide, load-linked and store conditional statements. The instruction set for computer system <b>1</b> implements the prefetch instructions and conditional move instructions of the MIPS IV specification. The instruction set also includes special primary processor Core instructions for primary processor core <b>23</b>, such as multiply/add (a 3-operand multiply, multiply-add instruction) and 128-bit multimedia instructions. These instructions allow for the parallel processing of 64-bits\u00d72, or 32-bits\u00d74, or 16-bits\u00d78 or 8-bits\u00d716. The instruction set also includes 11 pipeline operation instructions, an interrupt enable/disable instruction and primary processor core instructions. The instruction set also includes instructions for 3 coprocessors. There is an embedded coprocessor which is used for error checking in primary processor core <b>23</b>. A second coprocessor, COP1, is FPU <b>25</b>. This coprocessor is controlled by instructions that are part of the primary processor instruction set. The third coprocessor, COP2, is vector processing unit (VPUO) <b>27</b>, and is controlled in two ways. In a macro mode, a program can issue macro-instructions to primary processor core <b>23</b> to control vector processing unit (VPUO) <b>27</b>. These macro-instructions are part of the primary processor core instruction set. The vector processing unit (VPUO) <b>27</b> also can be controlled directly in a micro mode (see below). The macro mode and the micro mode each has its own instruction set.</p><p>As discussed above, primary processor core <b>23</b> is the central processor of computer system <b>1</b>. This processor is supported by a series of additional functional units in primary processor <b>3</b>. Main internal primary processor bus <b>21</b> (FIG. 2) connects primary processor core <b>23</b> to these functional units. Main internal primary processor bus <b>21</b> has separate data and address buses. The data bus is 128-bits wide. Main internal primary processor bus <b>21</b> has 8/16/32/64/128-bit burst access.</p><p>However, one functional unit is not connected to the main internal primary processor bus <b>21</b>. Referring back to FIG. 2, floating point unit <b>25</b> is a coprocessor that has both a 32-bit single-precision floating-point multiply-add arithmetic logical unit and a 32 bit single-precision floating-point divide calculator. This unit is tightly coupled to CPU core <b>23</b>.</p><p>Vector processing unit zero (VPU<b>0</b>) <b>27</b> is a coprocessor used for non-stationary geometry processing. This processing includes physical modeling and other complicated matrix computations. Referring to FIG. 4, vector processing unit zero <b>27</b> consists of vector unit zero (VU<b>0</b>) <b>91</b>, vector unit memory zero (VUMem<b>0</b>) <b>93</b>, and vector interface zero (VIF<b>0</b>) <b>95</b>. Vector processing unit zero <b>27</b> is tightly coupled to primary processor core <b>23</b> by VPU0 coprocessor bus <b>97</b> which is separate from the main internal primary processor bus <b>21</b>. Thus the operation resources and registers for vector processing unit zero <b>27</b> can be operated directly from primary processor core <b>23</b> by using coprocessor macroinstructions. However, vector processing unit zero <b>27</b> can also execute microprograms independently of the primary processor core <b>23</b>.</p><p>Vector unit zero <b>91</b> is a floating-point vector processor unit. Vector unit zero <b>91</b> has a built-in instruction memory, MircoMem<b>0</b><b>99</b>. MicroMem<b>0</b><b>99</b> is 4 KB in size. MicroMem<b>0</b><b>99</b> executes programs composed of 64-bit microinstructions from 64-bit long instruction word (LIW) instruction sets. These instructions are used by the vector unit zero core <b>101</b> to operate on the data stored in the VU0 registers <b>103</b>.</p><p>FIG. 5 shows the vector unit zero <b>91</b> in more detail. Vector unit zero <b>91</b> divides the 64-bit LIWs into an upper instruction field <b>105</b> of 32 bits and a lower instruction field <b>107</b> of 32 bits. Vector unit zero <b>91</b> has pipelines which are logically divided into upper execution unit <b>109</b> and lower execution unit <b>111</b>. Upper execution unit <b>109</b> has four 32-bit single-precision floating-point multiply-add arithmetic logical units (FMAC ALUs), called FMACx <b>113</b>, FMACy <b>115</b>, FMACz <b>117</b>, and FMACw <b>119</b>. These four FMACs allow simultaneous operation on the coordinates of a vertex of an object being manipulated, whether the coordinates are XYZW, RGBA, STQR, or NxNyNzNw. The lower execution unit <b>111</b> has one 32-bit single-precision floating-point division/square root calculation unit (FDIV) <b>121</b>, as well as a 16-bit integer ALU (IALU) <b>123</b>, a load/store unit (LSU) <b>125</b>, a BRU <b>127</b> (a unit for controlling program jumping and branching), and a random number generator (RANDU) <b>129</b>. This division allows each execution unit to be addressed by a 32-bit instruction (the upper and lower instruction fields of the 64-bit LIW). Thus, vector unit zero <b>91</b> can simultaneously perform a floating point product-sum calculation and a floating-point division or integer calculation.</p><p>Vector unit zero <b>91</b> has several different types of vector unit zero <b>91</b> registers <b>103</b> (FIG. <b>4</b>). Referring again to FIG. 5, these registers include 32 128-bit floating-point registers <b>131</b>, which are equivalent to four single precision floating point values each. For a product-sum calculation, two 128-bit registers can be specified as source registers and one 128-bit register can be specified as a destination register. These 32 128-bit floating-point registers <b>131</b> also act as renamed data registers when 32 128-bit floating-point registers <b>131</b> acts as a coprocessor under the direct control of the primary processor core <b>23</b>.</p><p>Vector unit zero <b>91</b> also has 16 16-bit integer registers <b>133</b>. These registers are used for loop counters and load/store calculations. Vector unit zero <b>91</b> also has a series of special registers <b>135</b>. These special registers include the four ACC Registers, which are accumulators for the four FMAC ALUs, the single 32-bit I Register where intermediate values are stored, the Q register where the results of FDIV are stored, and the 23-bit R Register where the random numbers generated by RANDU are stored. Vector unit zero <b>91</b> also has a series of control registers <b>137</b> which allow primary processor <b>3</b> to use vector unit zero <b>91</b> as a coprocessor.</p><p>Vector processor unit zero <b>27</b> also includes vector unit memory zero <b>93</b> (FIGS. <b>4</b> and <b>5</b>), which is structured in 128-bit (32-bit\u00d74) units. Vector unit memory zero <b>93</b> is 4 KB in size and is connected to the LSU <b>125</b> (FIG. 5) by a 128-bit wide bus. By using floating point registers <b>131</b> and the vector unit memory zero <b>93</b> (built in data memory), vector processor unit zero <b>27</b> can execute floating-point vector operations on 4 32-bit words concurrently.</p><p>Vector processor unit zero <b>27</b> has two modes of operation. In the micro mode, vector processor unit zero <b>27</b> operates as an independent processor by implementing micro-instructions stored in MicroMem<b>0</b><b>99</b>. This mode allows for highly efficient parallelism. Vector processor unit zero <b>27</b> also has a macro mode. In the macro mode, the primary processor core <b>23</b> takes control of vector processor unit zero <b>27</b> as a coprocessor, and can be controlled by primary processor core <b>23</b> coprocessor instructions.</p><p>Vector interface zero (VIFO) <b>95</b> is a packet expansion engine that implements a data unpacking function. Vector interface zero <b>95</b> can efficiently reconstruct DMA-transferred packets of different data lengths for vector unit memory zero <b>93</b>. Data such as display lists is stored in main memory <b>7</b> in formats optimized for fast data transmission and retrieval. These formats are in different data lengths than the actual data would be in its native state. Vector interface zero <b>95</b> allows such optimizations to occur without primary processor core <b>23</b> having to spend computational power unpacking these data.</p><p>Vector interface zero <b>95</b> can also start a microprogram. Thus a method for operating vector processor unit zero <b>27</b> in micro mode is to send vector interface zero <b>95</b> a DMA packet chain direct from scratchpad RAM <b>77</b> or main memory <b>7</b> with a micro-instruction program, the vector data to be processed, and the instruction to start the micro-instruction program.</p><p>FIG. 6 illustrates in detail the tightly coupled connection between vector processor unit zero <b>27</b> and primary processor core <b>23</b>. Vector processor unit zero <b>27</b> coprocessor bus <b>97</b> (FIG. 4) is actually <b>3</b> separate connections. These connections, shown in FIG. 6, include a 128-bit bus <b>139</b> which allows primary processor core <b>23</b> to control vector processor unit zero <b>27</b> floating point registers <b>131</b>. These connections also include a 32-bit bus <b>141</b> which gives primary processor core <b>23</b> control over integer registers <b>133</b> of vector processor unit zero <b>27</b>, and a 32-bit bus <b>143</b> which gives the primary processor core <b>23</b> control over upper execution unit <b>109</b>.</p><p>Referring again to FIG. 4, vector processing unit one (VPU<b>1</b>) <b>29</b> is an independent processor used for stationary geometry processing. These calculations include simple geometry transformations such as translation, rotation, and other calculations such as certain light modeling calculations. Vector processing unit one <b>29</b> consists of vector unit one (VU<b>1</b>) <b>145</b>, vector unit memory one (VM Mem<b>1</b>) <b>147</b>, and vector interface one (VIF<b>1</b>) <b>149</b>. Vector processing unit one <b>29</b> is connected to the main internal primary processor bus <b>21</b>.</p><p>Vector unit one <b>145</b> is a floating-point vector processor unit. Vector unit one <b>145</b> has several elements shown in FIG. <b>7</b>. MicroMem<b>1</b><b>151</b> is a built-in instruction memory which is 16 KB in size. MicroMem<b>1</b><b>151</b> executes programs composed of 64-bit micro-instructions from 64-bit long instruction word (LIW) instruction sets. The 64-bit LIWs can be divided into an upper instruction field <b>153</b> of 32 bits and a lower instruction field <b>155</b> of 32 bits.</p><p>The pipelines of vector unit one <b>145</b> are logically divided into upper execution unit <b>157</b> and lower execution unit <b>159</b>. The upper execution unit <b>157</b> has four (4) 32-bit single-precision floating-point multiply-add arithmetic logical units (FMAC ALUs), called FMACx <b>161</b>, FMACy <b>163</b>, FMACz <b>165</b>, and FMACw <b>167</b>. Lower execution unit <b>159</b> has one 32-bit single-precision floating-point division/square root calculation unit (FDIV) <b>169</b>, as well as a 16-bit integer ALU (IALU) <b>171</b>, a Load/Store Unit (LSU) <b>173</b>, a BRU (a unit for controlling program jumping and branching) <b>175</b>, and a random number generator (RANDU) <b>177</b>. Lower execution unit <b>159</b> also has an elementary function unit (EFU) <b>179</b>. Elementary function unit <b>179</b> performs exponential, logarithmic and trigonometric functions. Elementary function unit <b>179</b> also performs calculations on scalar or vector values and outputs a scalar value. This division of pipelines between upper execution unit <b>157</b> and lower execution unit <b>159</b> allows each execution unit to be addressed by a 32-bit instruction (the upper and lower instruction fields of the 64-bit LIW). Thus vector unit one <b>145</b> can simultaneously perform a floating point product-sum calculation and a floating-point division or integer calculation.</p><p>Vector unit one <b>145</b> also contains 32 128-bit floating-point registers <b>181</b>. Each of these registers can contain four single precision floating point values. For a product-sum calculation, two 128-bit registers can be specified as source registers and one 128-bit register can be specified as a destination register. Vector Unit One <b>145</b> also contains 16 16-bit integer registers <b>183</b>. These registers are used for loop counters and load/store calculations. Vector unit one <b>145</b> also has a series of special registers <b>185</b>. These special registers <b>185</b> include four ACC Registers, which are accumulators for four FMAC ALUs, a single 32-bit I Register where intermediate values are stored, a Q register where the results of FDIV are stored, a 23-bit R Register where the random numbers generated by RANDU are stored, and a P register which records the value generated by EFU <b>179</b>. Vector unit one <b>145</b> also contains control registers <b>187</b>.</p><p>Vector unit one <b>145</b> also contains vector unit memory one <b>147</b>, a date memory which is structured into 128-bit (32-bit\u00d74) units. Vector unit memory one <b>147</b> is 16 KB in size and is connected to load/store unit <b>173</b> by a 128-bit wide bus. By using floating point registers <b>181</b> and vector unit memory one <b>147</b>, the vector unit one <b>145</b> can execute floating-point vector operations on 4 32-bit elements concurrently.</p><p>Vector processing unit one <b>29</b> (FIG. 4) has only the micro mode of operation. In the micro mode, the vector unit one <b>145</b> operates as an independent processor by implementing micro-instructions stored in MicroMem<b>1</b><b>151</b>. This mode allows for highly efficient parallelism as it requires minimal intervention by primary processor core <b>5</b>.</p><p>Vector processing unit one <b>29</b> also contains a packet expansion engine, vector interface one (VIF<b>1</b>) <b>149</b>, for implementing a data unpacking function. Vector interface one <b>149</b> can efficiently reconstruct DMA-transferred packets of different data length. Data such as display lists are stored in main memory <b>7</b> in formats optimized for fast data transmission and retrieval. These formats are in data lengths different from the lengths of the actual data in its original state. Vector interface one <b>149</b> allows such optimizations to occur without primary processor core <b>23</b> having to spend computational power unpacking these data. Referring back to FIG. 2, other specialized functional units are included in primary processor <b>3</b>. Graphics processor interface <b>43</b> is one such specialized functional unit. Graphics processor interface <b>43</b> acts as the interface between primary processor <b>3</b> and graphics processor <b>5</b> (FIG. <b>1</b>). Graphics processor interface <b>43</b> is essentially an arbitration unit that can decide whether to allow data from primary processor core <b>23</b> and vector processor unit zero <b>27</b>, as opposed to the vector processor unit one <b>29</b>, to pass through to graphics processor <b>5</b> as these units generate parallel data streams.</p><p>Referring to FIG. 8, graphics processor interface <b>43</b> contains control logic and control registers <b>189</b>, packing logic <b>191</b>, and a 256-byte embedded FIFO register <b>193</b> (first-in, first-out) that caches the inputted data. There is a second buffer <b>195</b> to hold the output of the graphics processor interface <b>43</b> before sending these data to graphics processor <b>5</b>.</p><p>Graphics processor interface <b>43</b> allows three possible paths for data to the graphics processor <b>5</b>. The first path is PATH<b>1</b><b>197</b>, which transfers data from vector unit memory one <b>147</b> to graphics processor <b>5</b>. PATH<b>2</b><b>199</b> is the data transfer path from vector interface one (VIF<b>1</b>) <b>149</b>. PATH<b>3</b><b>201</b> is the direct data transfer path from the main internal primary processor bus <b>21</b> to graphics processor interface <b>43</b>, running through the embedded FIFO register <b>193</b>. PATH<b>3</b><b>201</b> is used when transferring data from main memory <b>7</b> or scratchpad memory <b>77</b> to graphics processor <b>5</b>. Graphics processor interface <b>43</b> arbitrates between transfer requests for the different paths, favoring PATH<b>1</b><b>197</b> over either PATH<b>2</b><b>199</b> or PATH<b>3</b><b>201</b>.</p><p>Graphics processor <b>5</b> is passed data in a format consisting on two or more graphics processor primitives, each headed by a GIFtag. The GIFtag is 128-bit in length, and denotes the size of the following GRAPHICS PROCESSOR primitive and its data format (or mode). The GIFtag can designate the register in graphics processor <b>5</b> to which the data should be passed, thus specifying the data. Graphics processor interface <b>43</b> is also passed one of three modes for graphics processor interface <b>43</b> to operate in: PACK, REGLIST, and IMAGE. The first mode designates the need to eliminate extraneous data from the primitive by using the GIF's packing logic <b>171</b>, allowing graphics processor interface <b>43</b> to output a display list. The second mode designates that the graphics processor primitives being passed are already in display list format. The third mode is used for transferring image data such as texture data to graphics processor <b>5</b>.</p><p>A detailed description of image processing unit (IPU) <b>31</b> is shown in FIG. <b>9</b>. Image processing unit <b>31</b> is an image data decompression processor primarily involved with the interpreting and decoding of an MPEG2 bit stream. This operation generally is used to generate MPEG encoded texture data for the rendering engine. Image processing unit <b>31</b> also includes macro block decoder <b>203</b> for performing macro block decoding. This processing is used to generate data upon which primary processor core <b>23</b> performs motion compensation. IPU <b>31</b> does not perform motion compensation.</p><p>Image processing unit <b>31</b> also contains units for performing a set of post processing functions. These units include color space conversion <b>205</b> and dither and vector quantization <b>207</b>. Color space conversion <b>205</b> converts the YCrCb data of the MPEG2 data stream into RGBA format. YCrCb is a chrominance/luminance color space model used in the British PAL television standard. Y specifies luminance, Cr and Cb specify chrominance (blue/yellow and red/cyan (or blue-green) components). Dither is used to smoothly convert 32-bit RGB format data to a 16-bit RGB format data. Vector quantization <b>207</b> uses the Color Look-Up Table (CLUT) to convert 16-bit RGB data to a 4-bit or 16-bit index number used in color calculations such as texture mapping. The Color Look Up Table (CLUT) is a table which establishes a correspondence between the global palette (64K colors, for example), and the subset of colors, i.e. the limited palette (made of 16 or 256 colors), used by a particular texture.</p><p>Image processing unit <b>31</b> also contains two 128-bit FIFO registers <b>209</b> for input and output, two 64-bit registers, and two 32-bit registers.</p><p>FIG. 10 shows a detailed description of S-bus interface (SIF) <b>35</b>. S-bus interface <b>35</b> is the interface unit to input output processor <b>9</b> (FIG. <b>1</b>). S-bus interface <b>35</b> is connected to input output processor <b>9</b> by a 32-bit bus, S-bus <b>15</b>. S-bus <b>15</b> is a 32-bit bus for backward-compatibility reasons because input output processor <b>9</b> is a 32-bit processor. S-bus interface <b>35</b> carries out the necessary conversion of 128-bit data to 32-bit data with packing/unpacking logic <b>211</b>, storing the data to be packed and unpacked in SFIFO register <b>213</b>. S-bus interface <b>35</b> also contains control registers <b>215</b>.</p><p>Another specialized functional unit shown in FIG. 10 is direct memory access controller (DMAC) <b>33</b> which has 10 channels for direct memory transfers. Direct memory access allows memory transfers to occur without the mediation of the primary processor core <b>23</b>, thus saving processing time. Memory transfer channels exist between main memory <b>7</b> and scratchpad RAM <b>77</b>. Memory transfer channels also exist between main memory <b>7</b> and/or scratchpad RAM <b>77</b> and vector interface zero <b>95</b>, vector interface one <b>149</b>, graphic processor interface <b>25</b>, image processing unit <b>31</b>, and the S-bus interface <b>35</b>. The DMA channels dealing with S-bus interface <b>35</b> transfer memory to S-bus <b>15</b> in cooperation with the corresponding IOP DMAC <b>217</b>. Again, IOP DMAC <b>217</b> allows input/output processor core <b>219</b> to not be involved in a memory transfer, such as to input/output processor memory <b>221</b>.</p><p>Another specialized functional unit is the dynamic random access memory controller (DRAMC) <b>37</b> (FIG. 2) which controls the access to main memory <b>7</b>. In this embodiment, dynamic random access memory controller <b>37</b> controls Rambus direct random access memory, which is used in the 32 MB of main memory <b>7</b>. Rambus direct random access memory is a specialized type of RAM allowing for very quick access. This special memory technology allows very high bandwidth of data transfer at up to 600 MHz with low latency. The fastest current memory technologies used by PCs (SDRAM), on the other hand, can deliver data at a maximum speed of only about 100 MHz.</p><p>Another specialized functional unit is interrupt controller (INTC) <b>41</b> (FIG. <b>2</b>). Interrupt controller <b>41</b> signals device interrupts from each device to primary processor core <b>23</b>, and from DMAC <b>37</b>.</p><p>Another specialized functional unit is timer <b>39</b> (FIG. <b>2</b>). Timer <b>39</b> contains four separate timers.</p><p>In operation, primary processor <b>3</b> takes advantage of the inherent parallelism and differentiation of the functional units in its design. One operation performed is patterned processing. Such processing involves images that can be generated by control point and matrix operations. These operations include perspective conversion, parallel light source calculation, creation of secondary curved surfaces, and similar such calculations. In non-patterned processing, on the other hand, images are generated by complex polygon operations. Such operations include the simulation of deductive reasoning or physical phenomena. Patterned processing generally is performed by vector processing unit one <b>29</b>, while non-patterned processing generally is performed by primary core <b>23</b> in combination with vector processing unit zero <b>27</b>.</p><p>There are several methods of taking advantage of this architecture. An example is a race-car game. In such a game, it is advantageous to calculate the position of the car's axles based upon physical modeling of the situation (speed of the car, angle of the car, surface and angle of the road, etc.). Primary processor core <b>23</b> with vector processing unit zero <b>27</b> are responsible for calculating the position of these axles. However, once these calculations are made, the position of the tires and the body of the car are determined. The object data, which would include the dimensions of the tire, car body, etc, then would be calculated based upon the control points generated by calculating the position of the axles. Thus, the actual position of these objects would be determined. Vector processor unit one <b>29</b> would be used to carryout these relatively simpler calculations. Vector processor unit one <b>29</b> is much more efficient at carrying out these simpler calculations. This division of responsibility frees Primary processor core <b>23</b> to perform other operations. Vector processor unit one <b>29</b> would then pass the display list generated to the graphics processor <b>5</b> to be rendered. The display list is a data format which defines one of seven primitives graphics processor <b>5</b> can draw, the conditions under which each primitive is to be drawn, and the vertices of the primitives.</p><p>A second example of the advantages of the architecture of computer system <b>1</b> is to display as a scene in a game, for example, a water drop falling against a background of skyscrapers. The calculations involving the water drop would be physically modeled. The Primary processor core <b>23</b> would perform these calculations. The Primary processor core <b>23</b>, with vector processing unit zero <b>27</b>, then would generate a display list which would be passed to graphics processor <b>5</b> to be rendered. Simultaneously, vector processor unit one <b>29</b> would take object data of the skyscrapers from main memory <b>7</b> and generate their position in the background using simple matrix calculations. Primary processor core <b>23</b>, with vector processing unit zero <b>27</b>, would also generate the matrices used to manipulate this object data. Thus, each processor works separately on the calculations for which it is suited to achieve parallelism.</p><p>Graphics processor <b>5</b> is a high performance rendering engine. The primary function of graphics processor <b>5</b> is to take display lists which define primitives, such as line or triangles (polygons), from the primary processor <b>3</b> and render these primitives in the frame buffer. Graphics processor <b>5</b> has logic to perform a variety of specialized calculations useful in rendering the primitives. Graphics processor <b>5</b> can be described in functional units, as shown in FIG. <b>1</b>.</p><p>The first functional unit is the Host I/F <b>301</b>. HOST I/F <b>301</b> is an interface between the main bus and priamry processor <b>3</b>.</p><p>Setup/Rasterizing Preprocessor <b>303</b> is a functional unit that takes the display list data of primitives and their vertices and gives out the value for each pixel of such variables as RGBA, Z value, texture value, and fog value. The rasterization uses a digital differential analyzer (DDA) algorithm, an algorithm commonly used for line drawing.</p><p>The \u201cA\u201d in RGBA is the alpha channel. The alpha channel is the portion of each pixel's data that is reserved for (usually) transparency information. The alpha channel is really a mask which specifies how the pixel's colors should be merged with another pixel when the two are overlaid, one on top of the other.</p><p>The pixel pipelines <b>305</b> processes a maximum of 16 pixels in parallel. The pixel pipelines operate on 32-bit words. The pipeline performs such processes as texture mapping, fogging, and alpha-blending and determining the final drawing color based on pixel information such as the alpha channel and the coverage.</p><p>Memory I/F <b>307</b> reads and writes data from local memory <b>309</b>. Local memory <b>309</b> is 4 MB of RAM memory on graphic processor <b>5</b>. Local memory <b>309</b> contains the frame buffer, Z-buffer, texture buffer and CLUT. Local memory <b>309</b> has a 1024-bit read port and a 1024 bit write port for writing to and reading from the frame buffer, and a 512-bit port for texture reading. The first two ports are associated with frame page buffer <b>311</b>, and the last port with texture page buffer <b>313</b>. Frame page buffer <b>311</b> can, for example, simultaneously send and receive sixteen (16) 64-bit pixel descriptions from Memory I/F <b>307</b>, the 64-bit pixel descriptions including a 32-bit RGBA variable and a 32-bit Z variable. The texture page buffer can pass sixteen (16) 32-bit texels a cycle to the pixel pipeline <b>305</b>.</p><p>The frame buffer is an area where image data of drawing results are stored. The frame buffer can store pixels in RGBA32 (8 bits/8 bits/8 bits/8 bits) RGB24 (8 bits/8 bits/8 bits), and RGBA16 (5 bits/5 bits/5 bits/1 bit) formats. These formats are all stored in 32-bit words. The pixels can be designated in two kinds of coordinate systems. The primitive coordinate system, which is the coordinate system of the drawing space, designates the vertex coordinate value during the drawing phase. The rectangular area in the frame buffer where drawing actually takes place is defined in this space. The window coordinate system is the system of coordinates which takes the upper left hand corner of the frame buffer as its origin. The calculation of memory addresses is based on these coordinates. The two coordinate systems are intraconvertible by an offset value for x and y.</p><p>The Z coordinate is stored in the Z-buffer in 32, 24, and 16 bit formats.</p><p>In addition to the data formats defined for the frame buffer, the IDTEX8 and IDTEX4 formats are used in the texture buffer. These data formats represent vectors pointing to a color in a color lookup table (CLUT). The CLUT is used to convert a texel value from an index to RGBA color data. The CLUT is stored in the CLUT buffer.</p><p>The PCRTC (Cathode Ray Tube Control) <b>315</b> displays the contents of the frame memory in the specified output format. Such formats include VESA standard, NTSC, and PAL. The VESA standards are for computer monitors, and include the SVGA (Super VGA) standard. The NTSC standard for television, used primarily in the United States, defines a composite video signal with a refresh rate of 60 half-frames (interlaced) per second. Each frame contains 525 lines and can contain 16 million different colors. PAL is the television standard used in Europe.</p><p>In operation, graphics processor <b>5</b> receives a display list comprising seven types of primitives, including a point, a line, a line strip, a triangle, a triangle strip, a triangle fan and a sprite. The strips and fan are more efficient to draw as they utilize shard vertices. The sprite is an independent triangle defined by two diagonally opposite corner vertices. A sprite is often used to write text (e.g., a billboard in the background of a race game). The primitives in the display list will also give the drawing attributes of the primitive. These drawing attributes include shading method, texture mapping, fogging, alpha-blending, anti-aliasing, texture coordinates, and context. Context informs graphics processor <b>5</b> whether a primitive was generated by primary processor core <b>23</b> in combination with vector processor unit zero <b>27</b> or by vector processor unit one <b>29</b>. Context, therefore, allows all of the other drawing attributes to be set to one of two defaults previously set, thus saving graphics processor <b>5</b> processing time. This feature expedites switching between the two sources, and thus promotes efficient parallel processing of geometry data. All of these drawing attributes are set in drawing environment registers <b>317</b> (FIG. <b>12</b>).</p><p>Graphics processor <b>5</b> will then read the vertex information following the primitive definition and drawing attributes, and begin the drawing process. The vertex information can be up to a set of four 32-bit coordinates. These coordinates can include, for example, the XYZW homogeneous coordinate of each vertex, the RGBA color data of each vertex and texture coordinates STQR (homogeneous coordinates). Other data potentially passed includes the vector normals of a vertex of a polygon, Nx, Ny, Nz, Nw (used in calculations such as light reflection). These vector normals are expressed in homogeneous coordinates.</p><p>Homogeneous coordinates are coordinates under which the transformation of scaling, rotation and translation can all be accomplished by matrix multiplication without vector addition. This representation has clear advantages because of its ease of manipulation. A point represented in homogeneous coordinates is expressed with an additional coordinate to the point. So, a two-dimensional point is represented in homogeneous coordinates by three coordinates.</p><p>FIG. 12 diagrams the processes applied to pixel data in graphics processor <b>5</b> during setup (preprocessing) <b>319</b>, the gradient (amount of change) of the values of the variables received for the vertices of the primitives are calculated. Values of the needed variables then are calculated along the drawn lines outlining the primitives. Rasterizing <b>321</b> then takes place. This logic implements a DDA (Digital Differential Analyzer) which fills in the pixels inside the primitive. The number of pixels written per cycle varies. With texture mapping deactivated, 16 pixels are generated concurrently. When texture mapping is activated, 8 pixels are generated concurrently. For example, associated with a pixel could be X, Y, Z values, R, G, B, A values, texture coordinates and a fog value. All these values could pass into pixel pipelines <b>305</b> (FIG. 11) simultaneously.</p><p>In pixel pipelines <b>305</b>, there are a series of optional graphic effects applied to each pixel. These effects, shown in FIG. 12, include texture mapping <b>323</b>, anti-aliasing <b>325</b>, fogging <b>327</b>, pixel testing <b>329</b> and alpha-blending <b>331</b>.</p><p>Graphics processor <b>5</b> fills pixels in the following manner. In the case of a triangle primitive, graphics processor <b>5</b> institutes a novel feature called a \u201cmoving stamp.\u201d In the prior art, an arbitrary triangle was filled using a rectangular stamp of a certain number of pixels by a certain number of pixels. This stamp improved efficiency in calculating the values for the pixels to be filled in the triangle by calculating the needed values for the first pixel (in the corner of the stamp). For each pixel thereafter calculated within the stamp, the calculations can be made in reference to the first pixel. Obviously part of these calculations involves whether the pixel should be written to the frame buffer at all (it should not if the pixel lies within the stamp but outside the triangle).</p><p>This algorithmic approach, as implemented in the prior art, has certain drawbacks. The stamp is fixed in reference to an axis, such as the y-axis. Thus, the stamp propagates along the x-axes of the triangle, until all of the triangle of that y-region had been filled, and then the stamp would increment up the y-axis by the height of the rectangle. The stamp would then start moving again in the x-direction at the exact same x-coordinate. If the left triangle side was at all sloped, therefore, many calculations were wasted by checking to see if pixels should be written into a part of the stamp well outside the triangle.</p><p>The \u201cmoving stamp\u201d by contrast is able, within certain increments, to shift the x-coordinate of its starting point when incrementing up the y-axis. This shifting is a more efficient method for filling pixels within the triangle. For any given stamp over the edge of the triangle, the stamp is likely to have less area outside the triangle.</p><p>Texture mapping <b>323</b> is performed on the pixels in the pipeline, if this option has been activated. Texture mapping is in essence the \u201cpainting\u201d of a bitmap texture onto a polygon. Texture mapping <b>323</b> for graphics processor <b>5</b> is shown in greater detail in FIG. <b>13</b>. The color of a given pixel written to the frame buffer is determined by a combination of a texel color and the pixel color derived from the rasterization process. The texel color is determined from either the S,T,Q or U,V. These coordinates both refer to a texture map, a bitmapped image which contains texels (texture pixels) that are to be painted onto the polygon.</p><p>The S,T,Q coordinates are the texture coordinate system, a homogeneous system. The normalized coordinates s,t are derived from s=S/Q, and t=T/Q 335. These coordinates are useful for applying texture mapping with perspective correction. Perspective correction removes the distortion that appears when a texture map is applied to a polygon in space. Perspective correction takes into account the depth of a scene and the spatial orientation of a polygon while rendering texels onto the surface of a polygon. The S,T,Q coordinates also assists in performing MIPMAP calculations to determine the correct LOD (Level of Detail). MIP mapping is a technique of precomputing anti-aliased texture bitmaps at different scales (levels of detail), where each image in the map is one quarter of the size of the previous one. When the texture is viewed from different distances, the correct scale texture is selected by the renderer so that fewer rendering artifacts are experienced, such as Moir\u00e9 patterns.</p><p>The U,V coordinate system is the texel coordinate system. The texture coordinate system is converted at block <b>339</b> into the texel coordinate system after the above calculations have been run. The texture map can be up to 1024 by 1024 texels. The LOD calculation <b>337</b> involves choosing the right level of detail of the MIPMAP to be used.</p><p>After the selection of a S,T,Q derived U,V versus an original U,V value <b>341</b>, the memory address calculation <b>343</b> is made. This is complicated by attempts to address a texel outside the texture map. This problem can be addressed by wrapping or repeating the texture, or clamping the texture such that the texels on the edge are stretched out to the size needed to be addressable by the address calculated.</p><p>This calculated address is then sent to the texture buffer <b>345</b>, and a texel value is sent to the Bit Expansion engine <b>347</b>. If the texel value is not in a format with 8 bits for each variable of RGBA (RGBA32 format), the format is converted. Either RGBA16 or RGBA24 under goes a bit expansion, or a IDTEX8 or IDTEX4 format is referenced to the appropriate CLUT and converted to an RGBA32 format.</p><p>The texel value is then sent on to filtering <b>349</b>. Filtering options include point sampling, and bilinear interpolation in the MIPMAP itself. Bilinear interpolation is an algorithm for interpolating image data in order to estimate the intensity or color of the image in between pixel centers. The interpolated value is calculated as a weighted sum of the neighboring pixel values.</p><p>There are seven possible MIPMAPs (seven levels of detail) derivable from the primary texture map created by the game developer. Given certain settings, it is possible to select linear interpolation between two adjacent MIPMAPs after each have undergone bilinear interpolation in order to avoid jumps between MIPMAPs in a game where the point of observation is advancing. This is trilinear filtering.</p><p>A final value, a texel color, must be blended with the RGBA value of the pixel (called a color fragment) by a function <b>351</b>. Several functions are possible, depending on the effect one wishes to generate. These functions are MODULATE (the final value is the multiplication of the fragment value with the texel value for each color), DECAL (the final value is the textel value), HIGHLIGHT (the final color values are determined by Vv=Vf*Vt+Af, and where Av=At+Af), and HIGHLIGHT2 (the color values are calculated as in highlight, but the final alpha value is the fragment alpha value). By multiplication what is meant is A*B=(AxB)&gt;&gt;7, and the result is clamped between 0 and 0xff.</p><p>After texture is applied, a fogging effect may be applied at block <b>325</b> (FIG. <b>12</b>). This effect blends the set fog value (often gray) with the RGBA value produced above. Fogging works such that the farther objects become increasingly obscured. In other words, the contrast between the fog color and objects in the image gets lower the deeper an object appears in the scene. Fogging may be used to provide a back-clipping plane where objects too distant to be seen clearly are removed to speed up the rendering of a scene.</p><p>An anti-aliasing effect may be applied at block <b>327</b>. Anti-aliasing is a method of reducing or preventing aliasing artifacts when rendering by using color information to simulate higher screen resolutions. In the graphics processor <b>5</b>, anti-aliasing is performed by taking the coverage value (ratio of area which covers the pixel) produced by the DDA for each pixel on the edge of a primitive, treating it as alpha, and performing alpha blending between the original primitive color (the source color) of the pixel and the destination color of the pixel (the color currently in the frame buffer for the current location). Thus, when the coverage of a pixel is partial, the pixel behind it will blend through. Therefore, graphics processor <b>5</b> implements anti-aliasing as a type of alpha blending, which is described further below. However, if one is antialiasing, then one cannot be using alpha blending for other purposes.</p><p>Again referring to FIG. 12, four pixel tests <b>329</b> are applied to the pixel. The scissoring test tests if the pixels position is outside a defined rectangle in the windows coordinate system. This test is not optional. A failed pixel is not processed any further. The Alpha test compares a pixel's alpha value against a set value. The comparison can be set to any equality or inequality. The effect of failing the test can also be controlled, with the RGB, A, and Z variables can be either not written or written depending on the setting. The destination alpha test compares the alpha of the pixel to the alpha value of the pixel in the same position currently in the frame buffer. A failed pixel is not processed further. The depth test compares the Z value of a pixel against the Z value of the corresponding pixel in the frame buffer. A failed pixel is not processed further. This test essentially implements Z-buffering. The other tests provide a game developer with a multitude of possible pixel manipulations to create new graphical effects.</p><p>Alpha blending <b>331</b> generates an output color based on the depth test output color generated above (Source Color or Cs), and the color of the pixel in the same position in the frame buffer (destination color, or Cd). The basic calculation is</p><p><maths><formula-text>Final Output Color={[(<i>Cs,Cd </i>or 0)\u2212(<i>Cs, Cd </i>or 0)]*(<i>As, Ad, FIX</i>0)}+(<i>Cs, Cd</i>, or 0) </formula-text></maths></p><p>where X*Y=(X\u00d7Y)&gt;&gt;7. Thus a multitude of calculations are possible, all allowing different sorts of blending between the source and destination color in an amount depending on the value of alpha. In the specific case of antialiasing, the formula reduces to Cs*As+Cd*(0\u00d780\u2212As).</p><p>Graphics processor <b>5</b> will then send these values for a final formatting at block <b>333</b>. The RGB values of the pixel will be dithered if they are to go to the frame buffer in RGBA16 format. If after alpha blending, the value of RGB is beyond the accepted value then a color clamp is applied to bring the values into range. Alpha values for pixels can be corrected to a preset value. The pixels are then format converted, packed into a number of bits specified by the developer (RGBA32, RGBA24, or RGBA16). The pixel values of RGBA are written to the frame buffer, and the pixel Z values are written to the Z buffer. Cathode ray tube controller <b>315</b> (FIG. 11) will then convert the frame buffer into the appropriate standard signal for a monitor.</p><p>Input output processor (IPO) <b>9</b> (FIG. 1) serves multiple functions in the computer system <b>1</b>. Input output processor <b>9</b> is a complete 32-bit CPU in its own right. This architecture provides backward compatibility with earlier game systems. Input output processor <b>9</b> also manages all input and output data for the primary processor <b>3</b>, except for the output to the video monitor. Input output processor <b>9</b> can deal with USB, IEEE1394, and other standard input and output data.</p><p>Sound processor unit (SPU<b>2</b>) is a sound synthesis processor, which is composed of two cores and equipped with local memory and external I/O. The two cores have the following functions: (1) reproduce the sound data input successively from the host; (2) process voices; (3) output the voice-processed sound data to the host successfully; and (4) perform digital effects processing. The two cores, CORE0 and CORE1, are functionally equivalent, and are connected to each other such that the output of CORE0 is the input to CORE1, and the output of CORE1 is the final mixed sound signal. The functional blocks of the SPU include: (1) the host interface; (2) the register RAM; (3) the CORE0; (4) the CORE1; (5) the memory interface; (6) the local memory; and (7) the output block. The Host Interface is connected by the a 32-bit bus to the IOP. The register RAM sets the function of the SPU2. All the registers are 16-bits in width. The local memory is 2 Mbytes of RAM. The local memory is divided into four functional areas: (1) the sound data input area; (2) the sound data output area; (3) the waveform data area; and (4) the digital effect work are. The sound data input area has data written in by the host, and outputted to the SPU2 cores. The sound data output area is buffer in this area, and is read by the host. The digital effect work area is in fact two areas used by the cores as scratch space for digital effect delay processing.</p><p>The preferred embodiments described above include numerous variations and combinations which are within the spirit and scope of the invention. The foregoing description should be understood as an illustration of the invention, therefore, rather than as a limitation. The scope of the invention is described by the following claims.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Masakazu", "last_name": "Suzuoki", "name": ""}, {"first_name": "Akio", "last_name": "Ohba", "name": ""}, {"first_name": "Masaaki", "last_name": "Oka", "name": ""}, {"first_name": "Toshiyuki", "last_name": "Hiroi", "name": ""}, {"first_name": "Teiji", "last_name": "Yutaka", "name": ""}, {"first_name": "Toyoshi", "last_name": "Okada", "name": ""}, {"first_name": "Masayoshi", "last_name": "Tanaka", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "SONY COMPUTER ENTERTAINMENT INC."}, {"first_name": "", "last_name": "SONY COMPUTER ENTERTAINMENT INC.", "name": ""}, {"first_name": "", "last_name": "SONY NETWORK ENTERTAINMENT PLATFORM INC.", "name": ""}, {"first_name": "", "last_name": "SONY COMPUTER ENTERTAINMENT INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06T  15/00        20110101A I20110122RMEP"}], "national_classes": [{"primary": true, "label": "712002"}], "ecla_classes": [{"label": "G06T  15/00A"}, {"label": "K63F300:20G"}], "cpc_classes": [{"label": "A63F2300/203"}, {"label": "G06T  15/005"}, {"label": "G06T  15/005"}, {"label": "A63F2300/203"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "2000-02-11", "application_date": "2000-02-11", "family_members": [{"ucid": "US-20040085321-A1", "titles": [{"lang": "EN", "text": "Game system with graphics processor"}]}, {"ucid": "US-6891544-B2", "titles": [{"lang": "EN", "text": "Game system with graphics processor"}]}, {"ucid": "US-6807620-B1", "titles": [{"lang": "EN", "text": "Game system with graphics processor"}]}, {"ucid": "US-20050184994-A1", "titles": [{"lang": "EN", "text": "Multiprocessor computer system"}]}]}