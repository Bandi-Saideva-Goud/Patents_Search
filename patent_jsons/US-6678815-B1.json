{"patent_number": "US-6678815-B1", "publication_id": 73680150, "family_id": 29780672, "publication_date": "2004-01-13", "titles": [{"lang": "EN", "text": "Apparatus and method for reducing power consumption due to cache and TLB accesses in a processor front-end"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11627003\" source=\"national office\"><p>An apparatus and method for reducing power consumption in a processor front end are provided. The processor includes an instruction cache, a TLB, and a branch predictor. For sequential code execution, the instruction cache is disabled unless the next instruction fetch will cross a cache line boundary, thus reducing unnecessary accesses to the instruction cache. The TLB is disabled unless the next instruction fetch will cross a page boundary, thus reducing unnecessary TLB look-ups. For code branching, the branch predictor is configured to include, for each target address, an indication of whether the target address is in the same page as the corresponding branch address. When a branch occurs so as to cause access to a given entry in the branch predictor, the TLB is disabled if the target address is in the same page as the branch address.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50606172\"><p>An apparatus and method for reducing power consumption in a processor front end are provided. The processor includes an instruction cache, a TLB, and a branch predictor. For sequential code execution, the instruction cache is disabled unless the next instruction fetch will cross a cache line boundary, thus reducing unnecessary accesses to the instruction cache. The TLB is disabled unless the next instruction fetch will cross a page boundary, thus reducing unnecessary TLB look-ups. For code branching, the branch predictor is configured to include, for each target address, an indication of whether the target address is in the same page as the corresponding branch address. When a branch occurs so as to cause access to a given entry in the branch predictor, the TLB is disabled if the target address is in the same page as the branch address.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00001\" num=\"1\"><claim-text>1. A processor comprising:</claim-text><claim-text>a translation look-aside buffer (TLB); and </claim-text><claim-text>a disable circuit to selectively disable the TLB by maintaining a plurality of branch addresses and, for each of the branch addresses, a corresponding target address and a corresponding TLB disable bit, setting the value of each of the TLB disable bits based on whether each target address is on the same page as the corresponding branch address, and selectively disabling the TLB for an instruction branch based on the value of one of the TLB disable bits which corresponds to the instruction branch. </claim-text></claim>"}, {"num": 2, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00002\" num=\"2\"><claim-text>2. A processor comprising:</claim-text><claim-text>a translation look-aside buffer (TLB); </claim-text><claim-text>a branch predictor including; </claim-text><claim-text>a plurality of branch addresses and, for each of the branch addresses, a corresponding target address and a corresponding TLB disable bit, and </claim-text><claim-text>a comparator to set the value of each of the TLB disable bits based on whether each target address is on the same page as the corresponding branch address; </claim-text><claim-text>a disable circuit to selectively disable the TLB for an instruction branch based on the value of the TLB disable bit corresponding to the instruction branch; and </claim-text><claim-text>for each of the branch addresses, a second TLB disable bit to support a plurality of different page sizes. </claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00003\" num=\"3\"><claim-text>3. A processor as recited an <claim-ref idref=\"US-6678815-B1-CLM-00002\">claim 2</claim-ref>, wherein each said TLB disable bit is for use in disabling a TLB for instruction branches that do not cross a page boundary.</claim-text></claim>"}, {"num": 4, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00004\" num=\"4\"><claim-text>4. A processor comprising a branch predictor, the branch predictor including a plurality of entries, each of the entries including a branch address, a target address corresponding to the branch address, and a plurality of translation look-aside buffer (TLB) disable bits corresponding to the branch address and the target address, wherein at least one of the plurality of TLB disable bits supports a plurality of page sizes.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00005\" num=\"5\"><claim-text>5. A processor as recited in <claim-ref idref=\"US-6678815-B1-CLM-00004\">claim 4</claim-ref>, wherein the TLB disable bit is for use in disabling a TLB for instruction branches that do not cross a page boundary.</claim-text></claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00006\" num=\"6\"><claim-text>6. A processor comprising:</claim-text><claim-text>an instruction fetch unit including an instruction address generator to selectively disable an instruction cache based on a current instruction fetch address, wherein the address generator includes </claim-text><claim-text>a first logic element to determine whether the next instruction fetch address is in the same cache line as the current instruction fetch address by performing a logic operation on a first predetermined subset of the current instruction fetch address, and </claim-text><claim-text>a cache disable circuit to disable the instruction cache if the next instruction fetch address is in the same cache line as the current instruction fetch address; </claim-text><claim-text>an instruction decoder; </claim-text><claim-text>an instruction execution unit; </claim-text><claim-text>an instruction translation look-aside buffer(TLB); and </claim-text><claim-text>a branch predictor, the branch predictor including: </claim-text><claim-text>a plurality of branch addresses and, for each of the branch addresses, a corresponding target address and a corresponding TLB disable bit, and </claim-text><claim-text>a comparator to set the value of each of the TLB disable bits by determining whether each target address is on the same page as the corresponding branch address. </claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00007\" num=\"7\"><claim-text>7. A processor as recited in <claim-ref idref=\"US-6678815-B1-CLM-00006\">claim 6</claim-ref>, wherein the instruction address generator further includes:</claim-text><claim-text>a second logic element to determine whether the next instruction fetch address is in the same page as the current instruction fetch address by performing a logic operation on a second predetermined subset of the current instruction fetch address, and </claim-text><claim-text>a TLB disable circuit to disable the TLB if the next instruction fetch address is in the same page as the current instruction fetch address. </claim-text></claim>"}, {"num": 8, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00008\" num=\"8\"><claim-text>8. A processor as recited in <claim-ref idref=\"US-6678815-B1-CLM-00006\">claim 6</claim-ref>, further comprising a first TLB disable circuit to selectively disable the instruction TLB for an instruction branch based on the value of the TLB disable bit corresponding to the instruction branch.</claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00009\" num=\"9\"><claim-text>9. A processor as recited in <claim-ref idref=\"US-6678815-B1-CLM-00008\">claim 8</claim-ref>, wherein the instruction address generator further includes:</claim-text><claim-text>a third logic element to determine whether the next instruction fetch address is in the same page as the current instruction fetch address by performing a logic operation on a second predetermined subset of the current instruction fetch address, and </claim-text><claim-text>a second TLB disable circuit to disable the instruction TLB if the next instruction fetch address is in the same page as the current instruction fetch address. </claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00010\" num=\"10\"><claim-text>10. A processor comprising:</claim-text><claim-text>an instruction cache; </claim-text><claim-text>an instruction translation look-aside buffer (TLB); and </claim-text><claim-text>an instruction fetch unit including an instruction address generator to selectively disable the instruction cache or the instruction TLB based on a current instruction fetch address, wherein the address generator includes </claim-text><claim-text>a first logic element to determine whether the next instruction fetch address is in the same cache line as the current instruction fetch address by performing a logic operation on a first predetermined subset of the current instruction fetch address, </claim-text><claim-text>a cache disable circuit to disable the instruction cache if the next instruction fetch address is in the same cache line as the current instruction fetch address, </claim-text><claim-text>a second logic element to determine whether the next instruction fetch address is in the same page as the current instruction fetch address by performing a logic operation on a second predetermined subset of the current instruction fetch address, </claim-text><claim-text>a TLB disable circuit to disable the instruction TLB if the next instruction fetch address is in the same page as the current instruction fetch address; and </claim-text><claim-text>a branch predictor including </claim-text><claim-text>a plurality of branch addresses and, for each of the branch addresses, a corresponding target address and a corresponding TLB disable bit, and </claim-text><claim-text>a comparator to set the value of each of the TLB disable bits by determining whether each target address is on the same page as the corresponding branch address. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00011\" num=\"11\"><claim-text>11. A processor as recited in <claim-ref idref=\"US-6678815-B1-CLM-00010\">claim 10</claim-ref>, further comprising a second TLB disable circuit to selectively disable the TLB for an instruction branch based on the value of the TLB disable bit corresponding to the instruction branch.</claim-text></claim>"}, {"num": 12, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00012\" num=\"12\"><claim-text>12. A microprocessor comprising:</claim-text><claim-text>(a) an instruction cache; </claim-text><claim-text>(b) an instruction translation look-aside buffer (TLB); </claim-text><claim-text>(c) an instruction fetch unit; </claim-text><claim-text>(d) an instruction decoder; </claim-text><claim-text>(e) an instruction execution unit; </claim-text><claim-text>(f) a branch predictor including </claim-text><claim-text>(f)(1) a plurality of branch addresses and, for each of the branch addresses, a corresponding target address and a corresponding TLB disable bit, and </claim-text><claim-text>(f)(2) a comparator to set the value of each of the TLB disable bits by determining whether each target address is on the same page as the corresponding branch address; and </claim-text><claim-text>(g) a disable circuit to selectively disable the instruction cache or the instruction TLB based on a current instruction fetch address, wherein the disable circuit includes </claim-text><claim-text>(g)(1) a branch portion to selectively disable the instruction TLB for an instruction branch based on the value of the TLB disable bit corresponding to the instruction branch, and </claim-text><claim-text>(g)(2) an address generator to selectively disable the instruction cache or the TLB during sequential instruction fetching, wherein the address generator includes </claim-text><claim-text>(g)(2)(i) an instruction cache disable circuit including </claim-text><claim-text>first determining means for determining whether the next instruction fetch address is in the same cache line as the current instruction fetch address, and </claim-text><claim-text>cache disabling means for disabling the instruction cache if the next instruction fetch address is in the same cache line as the current instruction fetch address, and </claim-text><claim-text>(g)(2)(ii) a TLB disable circuit including </claim-text><claim-text>second determining means for determining whether the next instruction fetch address is in the current instruction fetch address, and </claim-text><claim-text>TLB disabling means for disabling the instruction TLB if the next instruction fetch address is in the same page as the current instruction fetch address. </claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00013\" num=\"13\"><claim-text>13. A microprocessor as recited in <claim-ref idref=\"US-6678815-B1-CLM-00012\">claim 12</claim-ref>, wherein the first determining means comprises a logic gate to perform a logic operation of a partial subset of the current instruction fetch address, such that the cache disabling means disables the instruction cache if the output of the logic gate has a predetermined value.</claim-text></claim>"}, {"num": 14, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00014\" num=\"14\"><claim-text>14. A microprocessor as recited in <claim-ref idref=\"US-6678815-B1-CLM-00012\">claim 12</claim-ref>, wherein the first determining means comprises a comparator to compare the current instruction fetch address with a difference between a cache line boundary and a largest instruction fetch size of the instruction fetch unit.</claim-text></claim>"}, {"num": 15, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00015\" num=\"15\"><claim-text>15. A microprocessor as recited in <claim-ref idref=\"US-6678815-B1-CLM-00012\">claim 12</claim-ref>, wherein the second determining means comprises logic gate to perform a logic operation of a partial subset of selected bits of the current instruction fetch address, such that the first TLB disabling means disables the instruction TLB if the output of the logic gate has a predetermined value.</claim-text></claim>"}, {"num": 16, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6678815-B1-CLM-00016\" num=\"16\"><claim-text>16. A microprocessor as recited in <claim-ref idref=\"US-6678815-B1-CLM-00012\">claim 12</claim-ref>, wherein the second determining means comprises a comparator to compare the current instruction fetch address with a difference between a page boundary and a largest instruction fetch size of the instruction fetch unit.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54115034\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>FIELD OF THE INVENTION</h4><p>The present invention pertains to power consumption in a processor front end. More particularly, the present invention relates to reducing power consumption due to cache and TLB accesses in a processor front-end.</p><h4>BACKGROUND OF THE INVENTION</h4><p>A processor is a computing device that executes instructions to operate upon data in a computer system. A processor implemented on a single-chip is sometimes referred to as a \u201cmicroprocessor\u201d. The data and instructions used by a processor are generally stored in memory. The circuitry responsible for fetching and decoding instructions is often referred to as the \u201cfront end\u201d of the processor. One problem associated with many processors is that of reducing or limiting power consumption in the processor. This problem is becoming increasingly more difficult to solve as processor clock speeds increase and as the number of transistors used to implement processors increase.</p><p>Many modern processors include one or more cache memories to allow faster access to frequently used instructions and data. Commonly, such caches include both an instruction cache and a data cache. A cache normally includes a tag array containing the address tags of cached information and a data array containing the cached information. Each time data is fetched from the cache, power is consumed. Accesses to an instruction cache, therefore, contribute to the overall power consumption in the processor front end.</p><p>A processor which uses virtual addressing may also include a translation look-aside buffer (TLB). The TLB contains a mapping (e.g., a look-up table) of virtual addresses to physical addresses. The mapping is commonly divided into units of memory called \u201cpages\u201d. Each time a look-up is made to the TLB, power is consumed. Hence, accesses to an instruction TLB also contribute to the overall power consumption in the processor front end.</p><p>Despite the fact that code flow is often linear (incremental, or sequential), existing processors will continually perform look-ups to the tag array and data array of the instruction cache, and to the TLB, even if the entry being accessed is not changing. The reason for this is that the instruction fetch size is less than an entire cache line or, in the case of the TLB, less than an entire page. This approach may be dictated by the instruction queue topology, cache line size, instruction width, routing limitations, etc., however, it also has a wasteful effect on power usage. A potential solution to this problem is to increase the instruction fetch size. That approach might provide some benefit, however, as the fetch size increases, the chances of fetching unneeded code (due to spatial locality) increases, and again power can be wasted. Also, increasing the fetch size can increase bus widths and cache area costs. Hence, a better solution to reducing power consumption in a processor front end due to instruction cache and TLB accesses is needed.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>The present invention is illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which:</p><p>FIG. 1A is a block diagram of a microprocessor front end in which the instruction cache and instruction TLB are selectively disabled to reduce power consumption;</p><p>FIG. 1B illustrates a variation of the microprocessor of FIG. 1A;</p><p>FIG. 2 shows an address generator of a processor Instruction Fetch Unit (IFU);</p><p>FIG. 3 shows an address generator of a processor IFU, configured to generate signals to selectively disable the instruction cache and instruction TLB;</p><p>FIG. 4 shows the format of a 64-byte memory space of a processor;</p><p>FIG. 5 shows a variation of the address generator of FIG. 3, in which comparators are replaced by simple logic gates;</p><p>FIG. 6 illustrates how the instruction TLB can be selectively disabled for sequential code execution;</p><p>FIG. 7 illustrates how the instruction cache tag array can be selectively disabled for sequential code execution;</p><p>FIG. 8 illustrates how the instruction cache data array can be selectively disabled for sequential code execution;</p><p>FIG. 9 illustrates the inclusion of a TLB disable bit in the branch predictor; and</p><p>FIG. 10 illustrates how the instruction TLB can be selectively disabled for code branching.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION</h4><p>A method and apparatus for reducing power consumption due to instruction cache and instruction TLB accesses in a processor are described. Note that in this description, references to \u201cone embodiment\u201d or \u201can embodiment\u201d mean that the feature being referred to is included in at least one embodiment of the present invention. Further, separate references to \u201cone embodiment\u201d in this description do not necessarily refer to the same embodiment; however, neither are such embodiments mutually exclusive, unless so stated and except as will be readily apparent to those skilled in the art.</p><p>The power reduction technique described herein applies to a processor that includes, or has access to, an instruction cache and/or an instruction TLB. As described in greater detail below, instruction cache accesses are limited to occur only once each time the instruction stream crosses a cache line boundary, and TLB look-ups are limited to occur only once each time the instruction stream crosses a page boundary. Also as described in greater detail below, the technique addresses power consumption during both sequential code execution and branching. For code branching, a branch predictor in the processor is configured to include, for each target address, an indication of whether the target address is in the same page as the corresponding branch address. When a branch subsequently occurs so as to cause access to a given branch predictor entry, the TLB is disabled if the target address is in the same page as the corresponding branch address.</p><p>FIG. 1A shows, in block diagram form, a microprocessor <b>1</b> in which the instruction cache and TLB are selectively disabled to reduce power consumption. As shown, the microprocessor <b>1</b> is coupled within the computer system to a system memory <b>2</b> over a system bus <b>3</b>. The computer system may be any conventional computer system, such as a personal computer (PC), a hand-held device such as a Personal Digital Assistant (PDA), cellular/wireless telephone, or the like. The microprocessor <b>1</b> may be a conventional microprocessor, such as found in such computer systems, such as a programmable, general-purpose microprocessor, Digital Signal Processor (DSP), or the like. The front end of the microprocessor <b>1</b> includes an Instruction Fetch Unit (IFU) <b>4</b>, an instruction decoder <b>5</b>, and an instruction cache <b>7</b>. In operation, the IFU <b>4</b> fetches instructions from either system memory <b>2</b> or instruction cache <b>7</b>. The instruction decoder decodes the fetched instructions, which are then executed by execution unit <b>6</b> in the microprocessor <b>1</b>. The microprocessor <b>1</b> may be pipelined, in which case one or more instructions are executed while others are being fetched and decoded.</p><p>The IFU <b>4</b> includes an address generator <b>10</b> to generate addresses of instructions to be fetched, a branch predictor <b>8</b>, and an instruction TLB <b>9</b>. Branch predictor <b>8</b> performs conventional branch prediction functions such as are well-known in the art, in addition to the operations described below. The address generator <b>10</b> also provides a Cache Disable signal to the instruction cache <b>7</b> to selectively disable the instruction cache (both its tag array and its data array) for sequential code execution. The instruction TLB <b>9</b> is coupled to receive a TLB DisableBr signal from the branch predictor <b>8</b> and a TLB DisableSeq signal from the address generator <b>10</b>. The TLB DisableBr signal is used to selectively disable the instruction TLB <b>9</b> for instruction branching, while the TLB DisableSeq signal is used to selectively disable the instruction TLB <b>9</b> for sequential code execution. Note that while both signals TLB DisableBr (for branching) and TLB DisableSeq (for sequential execution) are shown and described herein, in various embodiments, only one of these signals may be generated and used. However, it is believed that using both signals (e.g., combining them together to disable the instruction TLB <b>9</b>) will be more effective at reducing power consumption in the front end than using only one of them. As shown in FIG. 1B, these two disable signals TLB DisableBr and TLB DisableSeq may be combined, such as through an OR gate <b>12</b>, to provide a single disable signal TLB Disable to the TLB <b>9</b>.</p><p>FIG. 2 shows an example of a conventional address generator that may be used in the IFU of a microprocessor. The address generator includes an incrementor <b>21</b>, two-input multiplexers <b>22</b> and <b>23</b>, and a one clock cycle buffer <b>24</b>. The output of multiplexer <b>23</b> is the Instruction Fetch Address of the next instruction to be fetched, which is applied to the input of the buffer <b>24</b>. The output of the buffer <b>24</b> is applied to one input of the incrementor <b>21</b>, a second input of which receives the Address Increment Value. The output of incrementor <b>21</b> is applied to one input of multiplexer <b>22</b>, the other input of which receives the output of buffer <b>24</b>. The output of multiplexer <b>22</b> is applied to one input of multiplexer <b>23</b>. Sequential instruction addresses are generated using the incrementor <b>21</b>, by incrementing the previously generated Instruction Fetch Address from buffer <b>24</b>. Instruction branch addresses are generated by the Branch Predictor <b>8</b>. The Branch Address select and Address Increment/Stall# signals are used to cause the Instruction Fetch Address to be as set forth in the following table:</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"70pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"77pt\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"70pt\"></colspec><thead><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry></entry><entry></entry><entry>Resulting Instruction</entry></row><row><entry>Branch Address Select</entry><entry>Address Increment/Stall#</entry><entry>Fetch Address</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry>0</entry><entry>0</entry><entry>Previous Instruction</entry></row><row><entry></entry><entry></entry><entry>Fetch Address (Stall)</entry></row><row><entry>0</entry><entry>1</entry><entry>Incremental Instruction</entry></row><row><entry></entry><entry></entry><entry>Fetch Address</entry></row><row><entry>1</entry><entry>0</entry><entry>Instruction Branch</entry></row><row><entry></entry><entry></entry><entry>Address</entry></row><row><entry>1</entry><entry>1</entry><entry>Instruction Branch</entry></row><row><entry></entry><entry></entry><entry>Address</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>In contrast, FIG. 3 shows the address generator <b>10</b> of processor <b>1</b>, which generates the signals Cache Disable and TLB DisableSeq to selectively disable the instruction cache <b>7</b> and TLB <b>9</b>, respectively, for sequential code execution. Accordingly, the address generator <b>10</b> is essentially the same as the address generator shown in FIG. 2 except for the addition of disable circuitry <b>30</b> to generate the aforementioned disable signals. As shown, the disable circuit <b>30</b> includes comparators <b>31</b> in <b>32</b>, one clock cycle buffers <b>33</b> and <b>34</b>, OR gates <b>35</b> and <b>37</b>, AND gates <b>36</b> and <b>38</b>, and inverters <b>39</b> and <b>40</b>. Each of comparators <b>31</b> in <b>32</b> receives, as one input, the current Instruction Fetch Address. As its second input, comparator <b>31</b> receives a value representing the cache line boundary minus the largest instruction fetch size. Comparator <b>32</b> receives, as its second input, a value representing the page boundary minus the largest instruction fetch size. Comparator <b>31</b> outputs a signal A to buffer <b>33</b>, while comparator <b>32</b> outputs signal B to buffer <b>34</b>. The output of buffer <b>33</b> is provided to one input of OR gate <b>35</b>, the other input of which is the output of inverter <b>39</b>. Inverter <b>39</b> outputs the inversion of the Address Increment/Stall# signal. The output of buffer <b>34</b> is provided to one input of OR gate <b>37</b>, the other input of which is the output of inverter <b>39</b>. The output of OR gate <b>35</b> is provided to one input of AND gate <b>36</b>, the other input of which is the output of inverter <b>40</b>. Inverter <b>40</b> provides inversion of the Branch Address Select signal. The output of OR gate <b>37</b> is provided to one input of AND gate <b>38</b>, the other input of which is the output of inverter <b>40</b>. The output of AND gate <b>36</b> is the Cache Disable signal, while the output of AND gate <b>38</b> is the TLB DisableSeq signal.</p><p>In operation, signal A represents a comparison of the current Instruction Fetch Address with: a cache line boundary minus the largest instruction fetch size. One clock cycle after an Instruction Fetch Address is generated, if the sequential (incrementing) address path is selected (Branch Address Select is \u201c0\u201d and Address Increment/Stall# is \u201c1\u201d), and the previous instruction fetch address was not within a fetch increment of crossing a cache line boundary, then the cache line being accessed must be the same as the cache line read by the last access, and a cache tag look-up is therefore unnecessary (unless the cache line has been modified). A cache tag look-up is also unnecessary if the Instruction Fetch Address is repeating (i.e., Branch Address Select is \u201c0\u201d and Address Increment/Stall# is \u201c0\u201d). Accordingly, the Cache Disable signal is asserted in such a case.</p><p>It is possible to make the Cache Disable function more accurate. For example, multiple comparators can be used to generate signal A, one comparator per possible fetch increment size, and the results can be multiplexed based upon the actual increment used. However, for some possible implementations, the vast majority of instruction fetches will be cacheable and, therefore, will use the largest fetch size. Thus, further optimization for such implementations would yield only a slight power improvement while adding logic to a potentially critical path (Cache Disable). The lack of this optimization would not cause incorrect behavior, only additional cache tag look-ups relative to an optimal solution.</p><p>Signal B represents a comparison of the current Instruction Fetch Address with: a page boundary minus the largest instruction fetch size. One clock cycle after an Instruction Fetch Address is generated, if the sequential (incrementing) address path is selected and the previous instruction fetch address was not within a fetch increment of crossing a page boundary, then the page being accessed must be the same as the page read by the last access, and a TLB look-up is therefore unnecessary (unless the TLB has been modified). A TLB look-up is also unnecessary if the instruction fetch address is repeating. In that case, the TLB DisableSeq signal is asserted.</p><p>Two possible alternatives for making the TLB DisableSeq function more accurate are as follows. First, multiple comparators can be used to generate signal B, one comparator per possible increment size, and then the results can be multiplexed based upon the actual increment used. As an alternative, the comparators can be modified to take into account the actual page size of the last page accessed, instead of performing the comparison based upon the boundary for a predetermined minimum (e.g., 4K byte) page size. However, with respect to the first alternative, assuming the vast majority of 64 byte instruction fetches are cacheable, they will use the largest fetch size. Thus, the first optimization would yield only a slight power improvement and add logic to a potentially critical path (TLB Look-up Disable).</p><p>As for the second optimization, adding logic to support variable page size comparisons would reduce the number of TLB look-ups by only a very small number compared to supporting only fixed page-size comparisons (assuming a linear code flow and 32-byte instruction fetches). Consider linear code flow with 32-byte fetches executing through a 16K block. If only 4K pages are supported, the number of TLB look-ups required to support the 512 fetches (16K/32) is four. If both 4K and 16K pages are supported, and the entire 16K block is represented by one 16K page, then the number of TLB look-ups required to support the 512 fetches is one, or a savings of three out of 512 look-ups. Thus, little power improvement is gained at a substantial logic cost. If these alternatives are not used, the result will not be incorrect operation, just additional TLB look-ups relative to a more optimal solution.</p><p>In further alternative embodiments, the comparators <b>31</b> and <b>32</b> can be replaced by simple logic gates, such as the NAND gates <b>51</b> and <b>52</b> shown in FIG. <b>5</b>. Before examining such an embodiment in greater detail, refer to FIG. 4, which schematically shows an example of a 64-bit address for a 64-bit addressable computer system. As shown, bits [<b>12</b>] through [<b>63</b>] of the address represent the index of a 4K-byte page within the memory space; bits [<b>6</b>] through [<b>11</b>] represent the index of a 64-byte cache line within a 4K-byte page; bits [<b>4</b>] and [<b>5</b>] represent the index of a 16-byte instruction fetch within a 64-byte cache line; and bits [<b>0</b>] through [<b>3</b>] represent the byte address within the 16-byte instruction fetch block. Referring now to FIG. 5, an alternative embodiment of the address generator <b>10</b> is shown. If the largest instruction fetch size is 16 bytes and a cache line is 64 bytes, then signal A will be active if any of the Instruction Fetch Address bits that form the index of the instruction fetch within a cache line are \u201c0\u201d. In this example, signal A in FIG. 5 would be active if either bit [<b>5</b>] or bit [<b>4</b>] (or both) of the current Instruction Fetch Address is \u201c0\u201d. Hence, in the embodiment of FIG. 5, bits [<b>4</b>] and [<b>5</b>] are input to NAND gate <b>51</b>, which replaces comparator <b>31</b> in FIG. <b>3</b>.</p><p>Similarly, if the largest instruction fetch size is 16 bytes and a page is 4K bytes, then signal B will be active if any of the bits that form the index of a cache line within a page as well as the bits that form the index of the instruction fetch within a cache line are \u201c0\u201d. In this example, signal B in FIG. 5 would be active if any of bits [<b>4</b>] through [<b>11</b>] of the current Instruction Fetch Address are \u201c0\u201d. Hence, in the embodiment of FIG. 5, bits [<b>4</b>] through [<b>11</b>] are input to NAND gate <b>52</b>, which replaces comparator <b>32</b> in FIG. <b>3</b>.</p><p>FIG. 6 illustrates how the TLB DisableSeq signal can be used to selectively disable the TLB <b>9</b> for sequential code execution. As shown, the TLB DisableSeq signal is applied to one input of a two-input AND gate <b>63</b>, the other input of which is the output of an inverter <b>62</b>. The input of inverter <b>62</b> is a Translation State Change signal, the purpose of which is described below. The output of AND gate <b>63</b> is applied to the TLB <b>9</b> to selectively disable the TLB <b>9</b>. The output of AND gate <b>63</b> is also applied as a selection signal to the two-input multiplexer <b>64</b>. The \u201c0\u201d input of the multiplexer <b>64</b> is the output (i.e., physical address, permissions, etc.) of the TLB <b>9</b>. The \u201c1\u201d input of multiplexer <b>64</b> is the output of multiplexer <b>64</b> fed back through a one clock cycle buffer <b>65</b>.</p><p>In operation (when the instruction queue has available space), Instruction Fetch Addresses are continually fed to the instruction cache <b>7</b> and the instruction TLB <b>9</b>. With the addition of the TLB disable logic described above, the Instruction TLB is modified such that when the output of AND gate <b>63</b> is asserted (\u201c1\u201d), the Content Addressable Memories (CAMs) (not shown) of the TLB <b>9</b> do not evaluate and the TLB <b>9</b> is not read. Instead, the Physical Address bits [<b>12</b>] through [x] (where x is the most significant physical address bit supported), permissions, etc., are supplied by buffer <b>65</b>, which contains the most recently read information from the TLB <b>9</b>. It may not be necessary to save the permissions, etc. by noting that if the previous access did not have any TLB-related faults (and the current privilege levels etc. have not changed), then the current access to the same page cannot have any TLB-related faults either.</p><p>In addition to the TLB DisableSeq signal, the Translation State Change signal is used (generated by logic not shown), when desired, to force the TLB to perform a look-up for a given access regardless of the value of the TLB DisableSeq signal. The Translation State Change signal is asserted in the event of a processor state change that could cause previously read page information to be considered stale. It remains asserted until a subsequent TLB access is performed and the last read TLB information in buffer <b>65</b> can be updated.</p><p>FIG. 7 illustrates how the Cache Disable signal can be used to selectively disable the tag array of the instruction cache <b>7</b> for sequential code execution. As shown, the Cache Disable signal is applied to one input of a two-input AND gate <b>75</b>, the other input of which is the output of an inverter <b>74</b>. The input of inverter <b>74</b> is a Cache State Change signal, the purpose of which is described below. The output of AND gate <b>75</b> is applied to the cache tag decoders <b>73</b> and cache tag array sense amplifiers <b>72</b> of the instruction cache <b>7</b> to selectively disable the cache tag array <b>71</b>. The output of AND gate <b>75</b> is also applied as a selection signal to the two-input multiplexer <b>77</b>. The \u201c0\u201d input of the multiplexer <b>64</b> is the output of the way/entry hit comparators <b>76</b>. The \u201c1\u201d input of multiplexer <b>77</b> is the output of multiplexer <b>77</b> fed back through a one clock cycle buffer <b>78</b>.</p><p>In operation (when the instruction queue has available space), Instruction Fetch Addresses are continually fed to the instruction cache <b>7</b> and the TLB <b>9</b>. With the addition of the cache disable logic described above, the instruction cache tag arrays are modified such that, when the output of AND gate <b>75</b> is asserted (\u201c1\u201d), the cache tag decoders <b>73</b> do not evaluate, the cache tag sense amplifiers <b>72</b> are disabled, and the cache way/entry hit comparators <b>76</b> do not perform cache hit/miss detections. Instead, the way/entry hit signals are supplied by buffer <b>78</b>, which contains the most recently generated information from the cache tags.</p><p>The Cache State Change signal is used (generated by logic not shown), when desired, to force the cache tags to perform a look-up for a given access regardless of the value of the Cache Disable signal. It is asserted in the event of a processor state change that could cause previously read cache line information to be considered stale. It remains asserted until a subsequent cache access is performed and the last read cache information in buffer <b>78</b> can be updated. These cases may include: modification of the TLB <b>9</b> (if the cache is virtual), disabling/enabling of the cache <b>7</b> via software, or modification of the cache line currently being accessed.</p><p>Note that detection of modifications to the cache line currently being accessed can be achieved in a number of ways, but for architectures which support total store ordering rules, ordered stores which are perceived from external sources (different threads within a single processor appear as external sources) must reach visibility (affect the instruction cache) in order. For at least one contemplated 64-bit architecture, ordered stores which are initiated by the same processor and thread as the instruction fetch are not guaranteed to be seen by the instruction cache at all, until a Flush Cache operation to the same address as the ordered store is executed, followed by an Instruction Serialization. (An Instruction Serialization causes a pipeline flush and a flush of any instruction prefetching buffers, followed by a branch to the address immediately following the Instruction Serialization instruction once the Instruction Serialization is architecturally committed.)</p><p>To account for store ordering rules, plus possible cache line modifications, some detection methods are as follows. As a first approach, assume that all snoops to the instruction cache would modify the current access line. Instruction Serialization operations appear as branches. This approach is simple, but is less power efficient than more exacting approaches. However, if the cache line size and the instruction fetch sizes are relatively close (e.g., the cache line size is two to four times the fetch size), then the incidence of snoops relative to the incidence of cache line crossings may be small. This method is only a partial solution, since cache line replacements will still result in a \u201cmodification to a cache line\u201d (actually a modification to a cache line location), without a snoop being generated. To complete this solution, cache lines targeted for replacement would have to count as \u201csnoops\u201d (although these \u201csnoop\u201d detections could be made exact, i.e., count only if to the current line being accessed with a smaller cost than that of the third approach, below).</p><p>As a second approach, assume that all external snoops to the instruction cache (including snoops generated by other threads of the same processor) would modify the current access line. Instruction Serialization operations appear as branches. This approach is also simple, but is less power efficient than more exacting approaches. However, if the cache line size and the instruction fetch sizes are relatively close (e.g., the cache line size is two to four times the fetch size), then the incidence of snoops relative to the incidence of cache line crossings may be small. This method is also only a partial solution, since cache line replacements will still result in a \u201cmodification to a cache line\u201d (actually a modification to a cache line location), without a snoop being generated. To complete this solution, cache lines targeted for replacement would have to count as \u201csnoops\u201d (although these \u201csnoop\u201d detections could be made exact, i.e. count only if to the line being accessed with a smaller cost than that of the fourth approach, below).</p><p>As a third approach, only snoops which hit the current access line count as modifications to the line. Instruction Serialization operations appear as branches. This approach requires some form of index/way comparator to provide detection (added complexity/area/power). Again, this method is only a partial solution, since cache line replacements will still result in a \u201cmodification to a cache line\u201d (actually a modification to a cache line location), without a snoop being generated. To complete this solution, cache lines targeted for replacement would have to count as \u201csnoops\u201d.</p><p>As a fourth approach, only external snoops which hit the current access line count as modifications to the line. Instruction Serialization operations appear as branches. This approach also requires some form of index/way comparator to provide detection (added complexity/area/power). Again, this method is only a partial solution, since cache line replacements will still result in a \u201cmodification to a cache line\u201d (actually a modification to a cache line location), without a snoop being generated. To complete this solution, cache lines targeted for replacement would have to count as \u201csnoops\u201d.</p><p>FIG. 8 illustrates how the Cache Disable signal can be used to selectively disable the data array of the instruction cache. The data array <b>81</b> stores instructions represented by the tags stored in the tag array <b>71</b>. As shown, the output of AND gate <b>75</b> is applied to the cache data array decoders <b>83</b> and cache data array sense amplifiers <b>82</b> of the instruction cache <b>7</b>, to selectively disable the data array <b>81</b>. The output of AND gate <b>75</b> is also applied as the selection signal to the two-input alignment multiplexer <b>89</b> and as input to inverter <b>80</b>. The output of inverter <b>80</b> is used as the enable input of buffer <b>88</b>. The four-input Way multiplexer <b>86</b> receives an input from each of the four ways of the instruction cache <b>7</b>, and is controlled by a multi-bit Way/Hit Information selection signal formed by the outputs of the way/entry hit comparators <b>76</b> (FIG. <b>7</b>). The output of Way multiplexer <b>86</b> is applied to one input of multiplexer <b>89</b>, and also to a second input of multiplexer <b>89</b> through enabled buffer <b>88</b>. The output of multiplexer <b>89</b> (a cache line of data) is then fed to alignment multiplexer <b>87</b>, which is used to select the instruction fetch sub-block from within the line.</p><p>In operation (when the instruction queue has available space), Instruction Fetch Addresses are continually fed to the instruction cache <b>7</b> and the TLB <b>9</b>. With the addition of the cache disable logic described above (the same signal used by the cache tags), the data array <b>81</b> of the instruction cache <b>7</b> can be modified such that when the output of AND gate <b>75</b> is asserted (\u201c1\u201d), the data array decoders <b>83</b> do not evaluate and the sense amplifiers <b>82</b> are disabled. Instead, the data for multiplexer <b>89</b> is supplied by buffer <b>88</b> containing the last cache line read from the data array <b>81</b>. With this modification, instead of reading a partial cache line from the data array <b>81</b> each time an instruction fetch is requested (and using the alignment multiplexer <b>87</b> to select which sub-block of the data read is to be passed to the instruction queue), an entire line is read each time an instruction fetch is requested. The line is then simultaneously passed to multiplexer <b>89</b> and enabled buffer <b>88</b>. The output of multiplexer <b>89</b> is passed to the alignment multiplexer <b>87</b> to select which sub-block of the data read is to be passed to the instruction queue. Subsequent accesses to the same cache line will then be satisfied by the line buffer <b>88</b>. As with the tag array <b>71</b>, the Cache State Change signal can be used to force the data array <b>81</b> to perform a look-up for a given access regardless of the value of the Cache Disable signal. Ideally, multiplexers <b>89</b> and <b>87</b> would be combined into a single level.</p><p>While various schemes may be used to reduce redundant accesses to the instruction cache <b>7</b> and TLB <b>9</b> when the instruction stream is flowing serially, it is also desirable to have a technique to reduce redundant accesses to these structures as a result of branches. Although a branch will frequently cause a change in which cache line the instruction stream is fetching, branches are much less likely to cause page transitions. One way of addressing this problem is to compare the branch predictor virtual address output with the last instruction fetch virtual address to detect if they were to the same page. However, this approach could require large (e.g., 72-bit) CAMs to be placed in the critical path of the branch predictor address generation. To avoid this logic, its timing effects, and to save power, a branch page predictor may be used, as will now be described.</p><p>FIG. 9 schematically illustrates the branch predictor <b>8</b> of microprocessor <b>1</b>. As indicated above, however, the use of this power reduction technique for branching is optional. As shown, the branch page predictor <b>8</b> includes a branch prediction table <b>91</b> and a comparator <b>92</b>. The branch prediction table <b>91</b> includes a number of entries, each of which includes a branch address <b>93</b>, a valid bit <b>94</b> indicating whether the entry is currently valid, the target address <b>95</b> corresponding to the branch address <b>93</b>, and a TLB Look-up Disable bit <b>96</b>. Optionally, the branch prediction table <b>91</b> may also include branch history information (not shown) for each entry. In operation, when a new entry is placed into the branch prediction table <b>91</b>, comparator <b>92</b> makes a comparison between the virtual address of the current branch instruction (the instruction used to initiate branch prediction) and the target virtual address, masked by the current page size, to determine whether or not the branch address and its corresponding target address are within the same virtual page. If they are, then the comparator <b>92</b> sets the TLB Look-up Disable bit for the new branch predictor entry. Later, when the branch predictor <b>8</b> is used, the TLB Look-up Disable bit will be read out with the target address, such that the front end logic will know whether or not a new TLB look-up is required, or whether instead, previously retrieved information can be used. For branch addresses not supplied by the branch prediction table (such as in the event of a branch mispredict), a TLB look-up will be required, and TLB Look-up Disable would not be asserted.</p><p>Note that this technique does not require a determination of whether the current fetch and the last fetch are in the same page to be made at the time of an instruction fetch, which is a timing-critical point in the front-end process. Instead, the comparison is made and stored prior to fetch time. Further, this technique avoids re-comparison for each fetch, which tends to further reduce power consumption. (Note that the same code may be executed several times, such as in a procedure.)</p><p>For some implementations, the TLB Look-up Disable bits may be continually updated each time a branch predictor entry is added or verified after use. Thus, TLB look-ups can be reduced even when branching, with minimal logic additions, and without adding any logic to the critical paths of the branch predictor <b>8</b>. Note that in the case where page mappings are changed/modified, it is possible that page sizes can change. In this case, the TLB Look-up Disable bits would have to be cleared for the affected pages (until new comparisons could be made and the bits updated). Alternatively, it may be more area-efficient to clear all TLB Look-up Disable bits <b>96</b> each time the page mappings are changed/modified (until new comparisons could be made and the bits updated).</p><p>FIG. 10 illustrates how a TLB Look-up Disable bit can be used to selectively disable the TLB <b>9</b> for code branching. As shown, the TLB look up disable bit is applied in the address generator <b>10</b> to one input of an AND gate <b>101</b>, the other input of which is the Branch Address Select signal. The output of AND gate <b>101</b> is the TLB DisableBr signal, which is applied to the TLB <b>9</b> to selectively disable the TLB <b>9</b> (i.e., when the target address is in the same page as the branch address). Alternatively, as illustrated in FIG. 1B, the TLB DisableBr signal may be combined with the TLB DisableSeq signal using a logic (e.g., OR) gate.</p><p>Various adaptations can be made to this TLB disabling technique for code branching. For example, instead of dealing with multiple page sizes, the comparator <b>92</b> can be made to only support the minimum page size. With this adaptation, branches that cross the minimum page size boundary but are actually in the same page as the current instruction will still cause TLB look-ups, however, changes/modifications to the page mappings will not require any TLB Look-up Disable bits to be cleared. Thus, the TLB Look-up Disable bits will only need to be modified when a new branch predictor entry is created. Additionally, the comparator would be simplified. Most branches will still be covered with this adaptation.</p><p>As another adaptation, two or more bits could be used to indicate TLB Look-up Disable. For example, one bit may be used to indicate whether the target address is in the same page as the branch address when the minimum page size is currently in use, while a second bit may be used to indicate whether the target address is in the same page as the branch address when a larger-than-minimum page size (current page size) is being used. If either bit is set, the branch target address will not require a new TLB look-up. One bit supports multiple page sizes, as described earlier, while the other supports the minimum page size as described in the previous adaptation. For this case, in the event that page mappings are changed/modified, all TLB Look-up Disable Bits supporting multiple page sizes can be cleared (without determination as to whether they belong to one of the affected pages) with minimal effect, since the TLB Look-up Disable Bits supporting only the minimum page size will remain unchanged (they would still be updated as new comparisons were made later).</p><p>Thus, a method and apparatus for reducing power consumption due to instruction cache and TLB accesses in a processor have been described. Although the present invention has been described with reference to specific exemplary embodiments, it will be evident that various modifications and changes may be made to these embodiments without departing from the broader spirit and scope of the invention as set forth in the claims. Accordingly, the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Gregory S.", "last_name": "Mathews", "name": ""}, {"first_name": "Edward T.", "last_name": "Grochowski", "name": ""}, {"first_name": "Chih-Hung", "last_name": "Chung", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTEL CORPORATION"}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/00        20060101A I20051110RMEP"}], "national_classes": [{"primary": true, "label": "711205"}, {"primary": false, "label": "711137"}, {"primary": false, "label": "711204"}, {"primary": false, "label": "713320"}, {"primary": false, "label": "711206"}, {"primary": false, "label": "712239"}], "ecla_classes": [{"label": "Y02B60:12F"}, {"label": "S06F212:652"}, {"label": "S06F212:6032"}, {"label": "G06F  12/10L"}], "cpc_classes": [{"label": "G06F2212/652"}, {"label": "G06F2212/1028"}, {"label": "G06F2212/652"}, {"label": "G06F2212/1028"}, {"label": "G06F  12/0882"}, {"label": "G06F2212/655"}, {"label": "G06F  12/0882"}, {"label": "G06F2212/655"}, {"label": "G06F  12/1027"}, {"label": "Y02D  10/00"}, {"label": "Y02D  10/00"}, {"label": "G06F  12/1027"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "2000-06-27", "application_date": "2000-06-27", "family_members": [{"ucid": "US-6678815-B1", "titles": [{"lang": "EN", "text": "Apparatus and method for reducing power consumption due to cache and TLB accesses in a processor front-end"}]}]}