{"patent_number": "US-6240506-B1", "publication_id": 72673660, "family_id": 22601244, "publication_date": "2001-05-29", "titles": [{"lang": "EN", "text": "Expanding instructions with variable-length operands to a fixed length"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72562321\"><p>A microprocessor configured to predecode instructions with variable address and operand lengths into a uniform format with constant address and operand lengths is disclosed. The microprocessor may comprise a predecode unit configured to receive instruction bytes from a main memory subsystem. The predecode unit is configured to detect instructions having prefix bytes that override default operand and address field lengths. This information, combined with the instruction's default operand and address length, allows the predecode unit to expand addresses and operands that are shorter than the predetermined uniform length. The operands and addresses are expanded by padding them with constants. Once the instructions are padded to a uniform format, they are stored in an instruction cache. An address translation table may be used to translate fetch addresses, thereby compensating for the offset created by the padding constants. The microprocessor may also be configured to detect the execution of instructions that modify segment default address and operand lengths. Upon detecting the execution of this type of instruction, the microprocessor may be configured to flush the contents of the instruction cache and address translation table. An optional secondary cache may store unpadded versions of the instructions to speed rebuilding of the instruction cache and address translation table after a flush. A computer system and method for predecoding instructions are also disclosed.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00001\" num=\"1\"><claim-text>1. A microprocessor comprising:</claim-text><claim-text>a predecode unit configured to receive instruction bytes from a main memory subsystem, wherein said predecode unit is configured to detect instructions having prefix bytes that override default operand and address field lengths, wherein said predecode unit is configured, in response to detecting said prefix bytes, to expand the operand fields and the address fields that are shorter than a predetermined length; and </claim-text><claim-text>an instruction cache coupled to said predecode unit, wherein said instruction cache is configured to receive and store predecoded instructions, including said expanded operand fields and said expanded address fields, from said predecode unit. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00002\" num=\"2\"><claim-text>2. The microprocessor as recited in claim <b>1</b>, wherein said predecode unit is configured to expand said operand and address fields to said predetermined length by padding with constants.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00003\" num=\"3\"><claim-text>3. The microprocessor as recited in claim <b>2</b>, wherein said predecode unit is further configured to delete prefix bytes that override default operand and address field lengths before an instruction is stored in said instruction cache.</claim-text></claim>"}, {"num": 4, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00004\" num=\"4\"><claim-text>4. The microprocessor as recited in claim <b>2</b>, further comprising an address translation table coupled to said instruction cache, wherein said address translation table is configured to store pointers to instructions stored within said instruction cache.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00005\" num=\"5\"><claim-text>5. The microprocessor as recited in claim <b>4</b>, wherein each pointer stored in said address translation table corresponds to a particular instruction address and points to an adjusted storage location that stores the corresponding instruction in said instruction cache, wherein each pointer compensates for changes in the corresponding instruction's storage location position resulting from said expanded operand fields and said expanded address fields.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00006\" num=\"6\"><claim-text>6. The microprocessor as recited in claim <b>1</b>, wherein said predecode unit is configured to detect and delete any prefix bytes that override default operand and address field lengths before the instructions are stored in the instruction cache.</claim-text></claim>"}, {"num": 7, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00007\" num=\"7\"><claim-text>7. A microprocessor comprising:</claim-text><claim-text>a predecode unit configured to receive instruction bytes from a main memory subsystem, wherein said predecode unit is configured to detect instructions having prefix bytes that override default operand and address field lengths, wherein said predecode unit is configured to expand operand and address fields that are shorter than a predetermined length, wherein said predecode unit is configured to expand said operand and address fields to said predetermined length by padding with constants; </claim-text><claim-text>an instruction cache coupled to said predecode unit, wherein said instruction cache is configured to receive and store predecoded instructions from said predecode unit; </claim-text><claim-text>and </claim-text><claim-text>an address translation table coupled to said instruction cache, wherein said address translation table is configured to store pointers to instructions stored within said instruction cache, wherein each pointer stored in said address translation table corresponds to a particular instruction address and points to the corresponding instruction in said instruction cache, wherein said microprocessor is configured to detect the execution of instructions that change the default operand and address size of a segment in said microprocessor, and, wherein said instruction cache and said address translation table are configured to flush stored instructions and pointers upon receiving a signal from said microprocessor that the default operand or default address size of a memory segment has changed. </claim-text></claim>"}, {"num": 8, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00008\" num=\"8\"><claim-text>8. A microprocessor comprising:</claim-text><claim-text>a predecode unit configured to receive instruction bytes from a main memory subsystem, wherein said predecode unit is configured to detect instructions having prefix bytes that override default operand and address field lengths, wherein said predecode unit is configured to expand operand and address fields that are shorter than a predetermined length, wherein said predecode unit is configured to expand said operand and address fields to said predetermined length by padding with constants; </claim-text><claim-text>an instruction cache coupled to said predecode unit, wherein said instruction cache is configured to receive and store predecoded instructions from said predecode unit; and </claim-text><claim-text>an address translation table coupled to said instruction cache, wherein said address translation table is configured to store pointers to instructions stored within said instruction cache, wherein each pointer stored in said address translation table corresponds to a particular instruction address and points to the corresponding instruction in said instruction cache, wherein said microprocessor is configured to detect the execution of instructions that change the default operand and address size of a segment in said microprocessor, and, wherein said instruction cache and said address translation table are configured to flush stored instructions and pointers upon receiving a signal from said microprocessor that the default operand and address size of a code segment has changed. </claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00009\" num=\"9\"><claim-text>9. The microprocessor as recited in claim <b>8</b>, wherein said predecode unit is further configured to generate one or more predecode bits for each instruction byte, wherein said predecode unit is configured to store said predecode bits in said instruction cache with said predecoded instructions.</claim-text></claim>"}, {"num": 10, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00010\" num=\"10\"><claim-text>10. The microprocessor as recited in claim <b>8</b>, further comprising a secondary cache coupled to said predecode unit, wherein said predecode unit is configured to store all instruction bytes received and corresponding predecode bits in said secondary cache without padding.</claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00011\" num=\"11\"><claim-text>11. The microprocessor as recited in claim <b>10</b>, wherein said predecode unit is configured to rebuild said instruction cache after said instruction cache is flushed using instructions and predecode information stored in said secondary cache.</claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00012\" num=\"12\"><claim-text>12. The microprocessor as recited in claim <b>11</b>, wherein said predecode unit is further configured to rebuild said address translation table after said instruction cache is flushed using instructions stored in said secondary cache.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00013\" num=\"13\"><claim-text>13. A method for predecoding instructions comprising:</claim-text><claim-text>reading a plurality of instruction bytes from a main memory subsystem; </claim-text><claim-text>detecting instructions within the plurality of instruction bytes that have prefix bytes which override the instruction's default address and operand field size; </claim-text><claim-text>expanding the address fields and the operand fields that are smaller than a predetermined size in response to detecting said prefix bytes; and </claim-text><claim-text>storing the instructions, including said expanded operand fields and said expanded address fields, in an instruction cache. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00014\" num=\"14\"><claim-text>14. The method as recited in claim <b>13</b>, further comprising maintaining an address translation table for the predecoded instructions stored the instruction cache, wherein the address translation table translates addresses by adjusting for the expanded address and operand fields.</claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00015\" num=\"15\"><claim-text>15. The method as recited in claim <b>14</b>, further comprising generating one or more predecode bits for each instruction byte.</claim-text></claim>"}, {"num": 16, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00016\" num=\"16\"><claim-text>16. A method for predecoding instructions comprising:</claim-text><claim-text>reading a plurality of instruction bytes from a main memory subsystem; </claim-text><claim-text>detecting instructions within the plurality of instruction bytes that have prefix bytes which override the instruction's default address and operand field size; </claim-text><claim-text>expanding address and operand fields that are smaller than a predetermined size; </claim-text><claim-text>storing the instructions in an instruction cache; </claim-text><claim-text>maintaining an address translation table for the predecoded instructions stored the instruction cache; </claim-text><claim-text>generating one or more predecode bits for each instruction byte; and </claim-text><claim-text>storing each instruction in unaltered form with any corresponding predecode bits in a secondary cache. </claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00017\" num=\"17\"><claim-text>17. The method as recited in claim <b>16</b>, further comprising:</claim-text><claim-text>detecting the execution of instructions that modify segment descriptors, and </claim-text><claim-text>flushing the instruction cache and the address translation table. </claim-text></claim>"}, {"num": 18, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00018\" num=\"18\"><claim-text>18. The method as recited in claim <b>17</b>, further comprising rebuilding the instruction cache and address translation table after said flushing by predecoding instructions from the secondary cache.</claim-text></claim>"}, {"num": 19, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00019\" num=\"19\"><claim-text>19. The method as recited in claim <b>17</b>, wherein said flushing comprises invalidating entries corresponding to the modified segment.</claim-text></claim>"}, {"num": 20, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00020\" num=\"20\"><claim-text>20. A computer system comprising:</claim-text><claim-text>a first microprocessor; </claim-text><claim-text>a CPU bus coupled to said first microprocessor; and </claim-text><claim-text>a modem coupled to said CPU bus, </claim-text><claim-text>wherein said first microprocessor comprises: </claim-text><claim-text>a predecode unit configured to receive instruction bytes from a main memory subsystem, wherein said predecode unit is configured to detect instructions having prefix bytes that override default operand and address field lengths, wherein said predecode unit is configured, in response to detecting said prefix bytes, to expand operand and address fields that are shorter than a predetermined length, wherein said predecode unit is configured to expand said operand and address fields to said predetermined length by padding with constants, wherein said predecode unit is further configured to delete any prefix bytes that override default operand and address field lengths; and </claim-text><claim-text>an instruction cache coupled to said predecode unit, wherein said instruction cache is configured to receive and store predecoded instructions, including said expanded operand fields and said expanded address fields, from said predecode unit. </claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6240506-B1-CLM-00021\" num=\"21\"><claim-text>21. The computer system as recited in claim <b>20</b>, further comprising a second microprocessor coupled to said first microprocessor via said CPU bus.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54552042\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><h4>CROSS REFERENCE AND RELATED APPLICATIONS</h4><p>The following applications generally relate to this application:</p><p>U.S. patent application Ser. No. . 09/158,440, filed on Sep. 21, 1998, currently pending;</p><p>U.S. patent application Ser. No. . 09/157,721, filed on Sep. 21, 1998, currently pending.</p><p>U.S. patent application Ser. No. . 09/157,647, filed on Sep. 21, 1998, currently pending;</p><p>U.S. patent application Ser. No. . 09/157,626, filed on Sep. 21, 1998, currently pending;</p><p>U.S. patent application Ser. No. . 09/157,719, filed on Sep. 21, 1998, currently pending; and</p><p>U.S. patent application Ser. No. . 09/002,902, filed on Jan. 5, 1998, issued as U.S. Pat. No. 6,081,884 on Jun. 27, 2000.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention relates to microprocessors configured to execute variable-length instruction sets, and in particular, instruction sets having address and operand size prefixes.</p><p>2. Description of the Relevant Art</p><p>The number of software applications written for the x86 instruction set is immense. As a result, despite the introduction of newer and more advanced instruction sets, microprocessor designers have continued to design microprocessors capable of executing the x86 instruction set.</p><p>The x86 instruction set is relatively complex and is characterized by a plurality of variable-length instructions. A generic format illustrative of the x86 instruction set is shown in FIG. <b>1</b>. As the figure illustrates, an x86 instruction consists of from one to five optional prefix bytes <b>102</b>, followed by an operation code (opcode) field <b>104</b>, an optional addressing mode (Mod R/M) byte <b>106</b>, an optional scale-index-base (SIB) byte <b>108</b>, an optional displacement field <b>110</b>, and an optional immediate data field <b>112</b>.</p><p>The opcode field <b>104</b> defines the basic operation for a particular instruction. The default operation of a particular opcode may be modified by one or more of the optional prefix bytes <b>102</b>. For example, one of prefix bytes <b>102</b> may be used to override the default segment used in memory addressing or to instruct the processor to repeat a string operation a number of times.</p><p>Two prefix bytes are of particular importance. A prefix byte of 66(hex) represents the OPSIZ prefix, which reverses the default the operand size for an instruction. A prefix byte of 67(hex) represents the ADRSIZ prefix, which reverses the default address size for an instruction. The default operand and address size of an instruction is determined by a default bit within the instruction's segment descriptor. If the default bit is set, then the default address and operand size is 32-bits. A prefix of 66(hex) or 67(hex) will override a set default bit, thereby allowing an instruction to use a 16-bit opcode or address, respectively. Similarly, if the default bit is not set, then the default address and operand size is 16-bits. A prefix of 66(hex) or 67(hex) will then override the unasserted default bit and allow the instruction following the prefix to use a 32-bit opcode or address, respectively. Thus, not only does the length of an x86 instruction depend upon how many prefix bytes precede the instruction, but also upon the value of the default bit in the instruction's segment descriptor and the presence of specific prefix bytes 66(hex) and 67(hex).</p><p>The opcode field <b>104</b> follows prefix bytes <b>102</b> (if present) and may be one or two bytes in length. The addressing mode (Mod R/M) byte <b>106</b> specifies the registers used as well as memory addressing modes. The scale-index-base (SIB) byte <b>108</b> is used only in 32-bit base-relative addressing using scale and index factors. A base field within SIB byte <b>108</b> specifies which register contains the base value for the address calculation, and an index field within SIB byte <b>108</b> specifies which register contains the index value. A scale field within SIB byte <b>108</b> specifies the power of two by which the index value will be multiplied before being added, along with any displacement, to the base value. The next instruction field is a displacement field <b>110</b>, which is optional and may be from one to four bytes in length. Displacement field <b>110</b> contains a constant used in address calculations. The optional immediate field <b>112</b>, which may also be from one to four bytes in length, contains a constant used as an instruction operand. The shortest x86 instructions are only one byte long, and comprise a single opcode byte. The 80286 sets a maximum length for an instruction at 10 bytes, while the 80386 and 80486 both allow instruction lengths of up to 15 bytes.</p><p>The complexity of the x86 instruction set poses many difficulties in implementing high performance x86 -compatible microprocessors. In particular, the variable length of x86 instructions, the nature of the prefix bytes, and reliance upon the segment descriptor makes scanning, aligning, and decoding instructions difficult. Scanning refers to reading a group of instruction bytes (either from an instruction cache within the microprocessor or from an external memory) and determining the boundaries of instructions contained therein. Alignment refers to the process of masking off undesired instruction bytes and shifting the desired instruction bytes so that the first bit of the desired instruction is in a desired position. Decoding instructions typically involves identifying each field within a particular instruction, e.g., the opcode and operand fields. Decoding typically takes place after the instruction has been fetched from the instruction cache, scanned, and aligned.</p><p>One method for aligning instructions involves generating a number of predecode bits for each instruction byte read from main memory. The predecode bits provide information about the instruction byte they are associated with. For example, an asserted predecode start bit indicates that the associated instruction byte is the first byte of an instruction. Similarly, an asserted predecode end bit indicates that the associated instruction byte is the last byte of an instruction. Once the predecode bits for a particular instruction byte are calculated, they are stored together with the instruction byte in an instruction cache. When a \u201cfetch\u201d is performed, i.e., a number of instruction bytes are read from the instruction cache, the associated start and end bits are also read. The start and end bits may then be used to generate valid masks for the individual instructions with the fetch. A valid mask is a series of bits in which each bit corresponds to a particular instruction byte. Valid mask bits associated with the first byte of an instruction, the last byte of the instruction, and all bytes between the first and last bytes of the instruction are asserted. All other valid mask bits are not asserted.</p><p>Turning now to FIG. 2, an exemplary valid mask is shown. The figure illustrates a portion of a fetch block <b>120</b> and its associated start and end bits <b>122</b> and <b>124</b>. Assuming a valid mask <b>126</b> for instruction B <b>128</b> is to be generated, start and end bits <b>122</b> and <b>124</b> would be used to generate the mask. Valid mask <b>126</b> could then be used to mask off all bytes within fetch <b>120</b> that are not part of instruction B <b>128</b>. Once the boundaries of an instruction have been determined, alignment and decoding may be performed.</p><p>Unfortunately, the tasks of scanning and aligning x86 instructions typically require a number of cascaded levels of logic. Thus, scanning and alignment may require a significant amount of time and, when added to the time required to perform decoding, may create a significant delay before any instructions are available to the functional stages of the microprocessor's pipeline. As microprocessors increase the number of instructions they are able to execute per clock cycle, slow instruction scanning and alignment may become a performance limiting factor. Therefore, a mechanism for reducing the complexity and time required for instruction scanning and alignment is needed.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above may in part be solved by a microprocessor configured to receive instructions having varying address and operand sizes and then predecode them into a single fixed-sized format. During predecode, the microprocessor may be configured to detect prefix bytes that override an instruction'default address and operand length, thus allowing the instructions to be \u201crecast\u201d into a single fixed size format. Advantageously, in some embodiments this may simplify instruction scanning and alignment.</p><p>In one embodiment, the microprocessor may comprise a predecode unit and an instruction cache. The predecode unit may be configured to receive instruction bytes from a main memory subsystem. The predecode unit may then be configured to detect instructions having prefix bytes that override default operand and address field lengths. The predecode unit may also be configured to expand operand and address fields that are shorter than a predetermined length. The instruction cache, which is coupled to a predecode unit, is configured to receive and store the predecoded instructions from the predecode unit. In one embodiment, the predecode unit may be configured to expand the operand and address field to the predetermined length by padding them with constants (e.g., zero) to increase uniformity of the address and operand fields. Advantageously, increasing the uniformity may in some embodiments improve scanning and alignment times.</p><p>In another embodiment, the predecode unit may be further configured to delete any prefix bytes that override default operand and address field lengths before the instruction is stored in the instruction cache. Instead, the deleted prefix bytes are reflected in the reformatted instruction by compacting multiple prefix bytes into a uniformly sized set of bits. This may further improve uniformity among instructions by reducing the number of potential prefix bytes. In another embodiment, the microprocessor may further comprise an address translation table coupled to the instruction cache. In one embodiment, the address translation table may operate similarly to a translation lookaside buffer (TLB). The address translation table may be configured to store pointers to instructions stored within the instruction cache. The address translation table may allow access to padded instructions despite the offsetting effect of the padding constants.</p><p>The microprocessor may further be configured to detect the execution of instructions that change the default operand and address size of a segment. Upon detecting the execution of such and instruction, the microprocessor may be configured to flush the contents of the instruction cache and address translation table because they may no longer be accurate representations of the original instructions. In another embodiment, the microprocessor may be configured to only flush instructions corresponding to the changed memory segment. Alternatively, flushing may occur only when a code segment has been changed (i.e., not a data segment).</p><p>In still another embodiment, the predecode unit may be further configured to generate one or more predecode bits for each instruction byte. These predecode bits may be stored in the instruction cache along with the predecoded instructions to further speed scanning and alignment times.</p><p>The microprocessor may also be configured with a secondary cache coupled to the predecode unit. The predecode unit may be configured to store all instruction bytes received and all corresponding predecode bits generated in the secondary cache. The secondary cache is configured to store an unpadded and unaltered version of the instruction bytes received. This may allow the contents of the instruction cache and address translation table to be more rapidly rebuilt after a flush occurs.</p><p>A method for predecoding instructions is also contemplated. In one embodiment, the method comprises reading a plurality of instruction bytes from a main memory subsystem. Next, instructions within the plurality of instruction bytes that have prefix bytes overriding the instructions' default address and operand field sizes are detected. With this information, address and operand fields that are smaller than a predetermined size are expanded using padding constants. The expanded instructions are then stored in an instruction cache. An address translation table for the predecoded instructions stored in the instruction cache may be maintained. Furthermore, one or more predecode bits may be generated for each instruction byte. In addition, an unaltered version of each instruction may be stored in a secondary cache along with any corresponding predecode bits.</p><p>In another embodiment, the method may further comprise detecting the execution of instructions that modify segment descriptors (which determine default address and operand lengths). Upon detecting the execution of such an instruction, the instruction cache and address translation table may be flushed. The secondary cache may then be used to rebuild the contents of the instruction cache and address translation table.</p><p>A computer system capable of rapid instruction decoding is also contemplated. In one embodiment, the computer system comprises a microprocessor coupled to a CPU bus. The microprocessor may be configured as described above. The computer system may further comprise a number of peripheral devices (e.g. a modem) coupled to the microprocessor via the CPU bus. In another embodiment, the computer system may further comprise additional microprocessors coupled to each other via the CPU bus.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram illustrating the generic format of the x86 instruction set.</p><p>FIG. 2 is a block diagram illustrating one embodiment of a valid mask.</p><p>FIG. 3 is a block diagram illustrating one embodiment of a microprocessor configured to predecode instructions for rapid scanning and alignment.</p><p>FIG. 4 is a block diagram illustrating details of one embodiment of a segment descriptor.</p><p>FIG. 5 is a table illustrating details of the combined effect that changes in the segment descriptor of FIG. <b>4</b> and selected instruction prefix bytes have on address and operand length.</p><p>FIG. 6 is a diagram illustrating one embodiment of the address translation table from FIG. <b>3</b>.</p><p>FIG. 7 is a flowchart illustrating one embodiment of a method for creating uniform address and operand lengths.</p><p>FIG. 8 is a flowchart illustrating one embodiment of a method for accessing stored predecoded instruction.</p><p>FIG. 9 is a block diagram of one embodiment of a computer system configured to use the microprocessor from FIG. <b>3</b>.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the present invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF SEVERAL EMBODIMENTS</h4><p>Turning now to FIG. 3, a block diagram of one embodiment of a microprocessor <b>10</b> that is configured to predecode instructions having varying address and operand lengths is shown. In this embodiment, microprocessor <b>10</b> includes a prefetch/predecode unit <b>12</b>, a branch prediction unit <b>14</b>, and an address translation table <b>36</b> coupled to an instruction cache <b>16</b>. An optional secondary cache <b>40</b> is coupled to prefetch/predecode unit <b>12</b>. Scan/alignment unit <b>18</b> is coupled between instruction cache <b>16</b>, decode units <b>20</b>A-C, and a microcode read-only memory (MROM) unit <b>34</b>. Decode units <b>20</b>A-C and MROM unit <b>34</b> are coupled to reservation stations <b>22</b>A-C, which are in turn coupled to functional units <b>24</b>A-C. A reorder buffer <b>32</b> is coupled to a register file <b>30</b>, and a load/store unit <b>26</b> is coupled to a data cache <b>28</b>. Functional units <b>24</b>A-C, data cache <b>28</b>, load store unit <b>26</b>, reorder buffer <b>32</b>, register file <b>30</b>, MROM unit <b>34</b>, decode units <b>20</b>A-C, and reservation stations <b>22</b>A-C are coupled together by result bus <b>38</b>.</p><p>Generally speaking, instruction cache <b>16</b> is a high speed cache memory provided to temporarily store instructions before they are fetched and conveyed to scan/alignment unit <b>18</b>. In one embodiment, instruction cache <b>16</b> is configured to store up to 64 kilobytes of instruction code organized in cache lines of 64 bytes each (where each byte consists of eight bits). Cache lines represent the smallest resolution for writes to instruction cache <b>16</b>. For example, a 64-byte cache line means each write to instruction cache <b>16</b> will involve storing one or more 64-byte blocks of instruction bytes. Instruction bytes are stored in instruction cache <b>16</b> by prefetch/predecode unit <b>12</b>, which prefetches the desired bytes from a main memory (not shown). It is noted that instruction cache <b>16</b> could be implemented in a set-associative, fully-associative, or direct-mapped configuration. Furthermore, instruction cache <b>16</b> may be addressed in a number of different ways, e.g., physically or linearly addressed.</p><p>Prefetch/predecode unit <b>12</b> prefetches instruction code from the main memory sub-system for storage within instruction cache <b>16</b>. A variety of specific code prefetching techniques and algorithms may be employed by prefetch/predecode unit <b>12</b>. As prefetch/predecode unit <b>12</b> receives instructions from the main memory subsystem, prefetch/predecode unit <b>12</b> is configured to detect each instruction's default address and operand size. In embodiments having a segmented memory model (e.g., x86 compatible embodiments of microprocessor <b>10</b>), this may be determined by reading the segment descriptor of the segment from which the instruction was read. This is described in greater detail below (see Segments and Segment Descriptors). In x86 compatible embodiments, an instruction's default address and operand size may be either sixteen or thirty-two bytes.</p><p>Prefetch/predecode unit <b>12</b> is also configured to detect prefix bytes that alter an instruction's default address and operand length. For example, in the x86 architecture a prefix byte of 66(hex) overrides the default operand size. If the default operand size for an instruction is 32 bytes (as specified by the instruction's segment descriptor), a 66(hex) prefix byte will result in a 16 byte operand. Similarly, if the default operand size for the instruction is 16 bytes (as specified by the instruction's segment descriptor), a 66(hex) prefix byte will result in a 32 byte operand. Prefix byte 67(hex) operates in the same manner for address size. If the default address size for an instruction is 32 bytes (as specified by the instruction's segment descriptor), a 67(hex) prefix byte will result in a 16 byte address. Similarly, if the default address size for the instruction is 16 bytes (as specified by the instruction's segment descriptor), a 67(hex) prefix byte will result in a 32 byte address.</p><p>Once an instruction's address and operand sizes have been determined, prefetch/predecode unit <b>12</b> is configured to predecode the instruction to a uniform address and operand size format. For example, in x86-compatible embodiments prefetch/predecode unit <b>12</b> may be configured to predecode all instructions to a uniform format with 32-bit addresses and operands. Any instructions detected having 16-bit operands or addresses may be \u201cpadded\u201d so that they have 32-bit addresses and operands. For example, a sixteen bit operand having a value of C4AB(hex) may be padded with a constant (e.g., zero) to create a 32-bit operand having a value of 0000C4AB(hex). Once the instructions have been predecoded, they may be stored in instruction cache <b>16</b>. Prefix bytes that do not influence operand or address size may be compressed into a fixed length (e.g., one byte) and then stored as part of the instructions.</p><p>Note, however, instructions that are expanded by padding may require additional storage space. The additional bytes that are added to the instructions by padding may also shift each instruction's location. To remedy this, in one embodiment microprocessor <b>10</b> may utilize address translation table <b>36</b>. Address translation table <b>36</b> is configured to store the address of each instruction stored in instruction cache <b>16</b>, along with a pointer to the corresponding storage location in instruction cache <b>16</b> where the instruction is stored. Secondary cache <b>40</b> may be used to store unpadded versions of instructions for use when instruction cache <b>16</b> and address translation table <b>36</b> need to be rebuilt. More details regarding the operation of address translation table <b>36</b>, instruction cache <b>16</b>, and secondary instruction cache <b>40</b> will be disclosed further below.</p><p>In addition to predecoding instructions to a uniform format, in another embodiment prefetch/predecode unit <b>12</b> may also be configured to generates the following predecode bits for each instruction byte: a start bit, an end bit, and a functional bit. As previously noted, asserted start bits mark the first byte of each instruction, while asserted end bits mark the last byte of each instruction. Asserted functional bits mark the opcode bytes of each instruction. The predecode bits form tags which may be used to speed alignment and decoding. The predecode tags may also include additional information such as whether a particular instruction may be decoded directly by decode units <b>20</b>A-B or whether the instruction is to be executed by invoking a microcode procedure stored within MROM unit <b>34</b>. The predecode tags may be stored along with the instruction bytes in instruction cache <b>16</b>.</p><p>Scan/alignment unit <b>18</b>, which is coupled to instruction cache <b>16</b>, is configured to receive each instruction (and any associated predecode information, if necessary) output from instruction cache <b>16</b>. Scan/alignment unit <b>18</b> receives each instruction, scans the corresponding predecode information, if any, and determines the boundaries of each instruction and each field within each instruction. Once aligned, each instruction is conveyed to one of decode units <b>20</b>A-C. In one embodiment, scan/alignment unit <b>18</b> may be configured to detect predecode tags indicative of MROM instructions (i.e., instructions that are executed by invoking a sequence of microcode instructions) and route them to MROM unit <b>34</b>.</p><p>Before describing the operation of prefetch/predecode unit <b>12</b>, address translation table <b>36</b>, and instruction caches <b>16</b> and <b>40</b> in greater detail, other general aspects of microprocessor <b>10</b> will be discussed. Note the configurations illustrated below are meant for explanatory purposes only. Numerous other configurations of microprocessor <b>10</b> are possible and contemplated. For example, instead of implementing instruction cache <b>16</b> and data cache <b>28</b> separately as shown, in some embodiments a unified instruction and data cache may be used.</p><p>Decode units <b>20</b>A-C are configured to receive aligned instructions from scan/alignment units <b>18</b>A-B and decode them into an internal, bit-encoded, fixed-length format. In one embodiment, each decode unit <b>20</b>A-C may be configured to receive and decode one or more instructions per clock cycle.</p><p>To improve the flow of data from instruction cache <b>16</b> to decode units <b>20</b>A-C, each decode unit may have a FIFO (first-in first-out) memory buffer at its input to receive and store the aligned instructions until the respective decode unit is ready to begin decoding them. For example, each decode unit may have a 32-byte FIFO configured to store two instructions (each up to a maximum of sixteen bytes long). Note that decode units <b>20</b>A-C are drawn as single boxes for exemplary purposes only. Each decode unit <b>20</b>A-C may comprises a number of individual decoders each configured to decode a single instruction.</p><p>Microprocessor <b>10</b> may be configured to support out of order execution, and thus employ reorder buffer <b>32</b> to keep track of the original program sequence for register read and write operations, to implement register renaming, to allow for speculative instruction execution and branch misprediction recovery, and to facilitate precise exceptions. As will be appreciated by those of skill in the art, a temporary storage location for storing speculative register states is reserved within reorder buffer <b>32</b> upon decode of an instruction that involves the update of a register. Reorder buffer <b>32</b> may be implemented in a first-in-first-out (FIFO) memory wherein speculative results move to the \u201cbottom\u201d of the buffer as they are validated and written to the register file, thus making room for new entries at the \u201ctop\u201d of the buffer. Other specific configurations of reorder buffer <b>32</b> are also possible, as will be described further below. If a branch prediction is incorrect, the results of speculatively-executed instructions along the mispredicted path can be invalidated in the buffer before they are written to register file <b>30</b>.</p><p>The bit-encoded execution instructions and immediate data provided at the outputs of decode units <b>20</b>A-<b>20</b>C are routed directly to respective reservation station units <b>22</b>A-<b>22</b>C. In one embodiment, each reservation station unit <b>22</b>A-<b>22</b>C is capable of holding instruction information (i.e., bit encoded execution bits as well as operand values, operand tags and/or immediate data) for up to three pending instructions awaiting issue to the corresponding functional unit. It is noted that for the embodiment shown in the figure, each decode unit <b>20</b>A-<b>20</b>C is associated with a dedicated reservation station unit <b>22</b>A-<b>22</b>C, and that each reservation station unit <b>22</b>A-<b>22</b>C is similarly associated with a dedicated functional unit <b>24</b>A-<b>24</b>C. Accordingly, three dedicated \u201cissue positions\u201d are formed by decode units <b>20</b>A-C, reservation station units <b>22</b>A-C and functional units <b>24</b>A-C. Instructions aligned and dispatched to issue position <b>0</b> through decode unit <b>20</b>A are passed to reservation station unit <b>22</b>A and subsequently to functional unit <b>24</b>A for execution. Similarly, instructions aligned and dispatched to decode unit <b>20</b>B are passed to reservation station unit <b>22</b>B and into functional unit <b>24</b>B, and so on.</p><p>Upon decode of a particular instruction, if a required operand is a register location, register address information is routed to reorder buffer <b>32</b> and register file <b>30</b> simultaneously. Those of skill in the art will appreciate that the x86 register file includes eight 32 bit real registers (i.e., typically referred to as EAX, EBX, ECX, EDX, EBP, ESI, EDI and ESP). Reorder buffer <b>32</b> contains temporary storage locations for results which change the contents of these registers to thereby allow out of order execution. A temporary storage location of reorder buffer <b>32</b> is reserved for each instruction which, upon decode, is determined to modify the contents of one of the real registers. Therefore, at various points during execution of a particular program, reorder buffer <b>32</b> may have one or more locations which contain the speculatively executed contents of a given register. If following decode of a given instruction it is determined that reorder buffer <b>32</b> has a previous location or locations assigned to a register used as an operand in the given instruction, reorder buffer <b>32</b> forwards to the corresponding reservation station either: 1) the value in the most recently assigned location, or 2) a tag for the most recently assigned location if the value has not yet been produced by the functional unit that will eventually execute the previous instruction. If reorder buffer <b>32</b> has a location reserved for a given register, the operand value (or tag) is provided from reorder buffer <b>32</b> rather than from register file <b>30</b>. If there is no location reserved for a required register in reorder buffer <b>32</b>, the value is taken directly from register file <b>30</b>. If the operand corresponds to a memory location, the operand value is provided to the reservation station unit through load/store unit <b>26</b>.</p><p>Reservation station units <b>22</b>A-<b>22</b>C are provided to temporarily store instruction information to be speculatively executed by the corresponding functional units <b>24</b>A-<b>24</b>F. As stated previously, each reservation station unit <b>22</b>A-<b>22</b>F may store instruction information for up to three pending instructions. Each of the three reservation stations <b>22</b>A-<b>22</b>C contain locations to store bit-encoded instructions to be speculatively executed by the corresponding functional unit and the values of operands. If a particular operand is not available, a tag for that operand is provided from reorder buffer <b>32</b> and is stored within the corresponding reservation station <b>22</b>A-<b>22</b>C until the result has been generated (i.e., by completion of the execution of a previous instruction). It is noted that when an instruction is executed by one of the functional units <b>24</b>A-<b>24</b>C, the result of that instruction is passed directly to any reservation stations <b>22</b>A-<b>22</b>C that are waiting for that result at the same time the result is passed to update reorder buffer <b>32</b> (this technique is commonly referred to as \u201cresult forwarding\u201d).</p><p>Instructions are issued to their corresponding functional units for execution after the values of any required operand(s) are made available. In some cases, an operand associated with a pending instruction within one of reservation station units <b>22</b>A-<b>22</b>C will be tagged with the location of a previous result value stored in reorder buffer <b>32</b> that corresponds to an instruction which modifies the required operand. In this situation the instruction is not issued to the corresponding functional unit <b>24</b>A-C until the operand result for the previous instruction has been received. Accordingly, the order in which instructions are executed may not be the same as the order of the original program instruction sequence (i.e., they may be executed \u201cout-of-order\u201d). Reorder buffer <b>32</b> ensures that data coherency is maintained in situations where read-after-write dependencies occur.</p><p>In one embodiment, each of the functional units <b>24</b>A-C is configured to perform integer arithmetic operations of addition and subtraction, as well as shifts, rotates, logical operations, and branch operations. It is noted that a floating point unit (not shown) may also be employed to accommodate floating point operations.</p><p>Each of the functional units <b>24</b>A-C also provide information regarding the execution of conditional branch instructions to branch prediction unit <b>14</b>. If a branch prediction was incorrect, branch prediction unit <b>14</b> flushes instructions after the mispredicted branch that have entered the instruction processing pipeline, and causes prefetch/predecode unit <b>12</b> to fetch the required instructions from instruction cache <b>16</b> or main memory. In this situation, the results of executed instructions occurring after the mispredicted branch instruction are discarded, including those which were speculatively executed and temporarily stored in load/store unit <b>26</b> and reorder buffer <b>32</b>.</p><p>Results produced by functional units <b>24</b>A-C are sent to reorder buffer <b>32</b> if a register value is being updated, and to load/store unit <b>26</b> if the contents of a memory location is changed. If the result is to be stored in a register, reorder buffer <b>32</b> stores the result in the location reserved for the value of the register when the instruction was decoded. As stated previously, results are also broadcast to reservation station units <b>22</b>A-<b>2</b>C where pending instructions may be waiting for the results of previous instruction executions to obtain the required operand values.</p><p>Generally speaking, load/store unit <b>26</b> provides an interface between functional units <b>24</b>A-<b>24</b>C and data cache <b>28</b>. In one embodiment, load/store unit <b>26</b> is configured with a load/store buffer with eight storage locations for data and address information for pending loads or stores. Decode units <b>20</b>A-C arbitrate for access to the load/store unit <b>26</b>. When the buffer is full, decode units <b>20</b>A-C wait until more storage space becomes available in load/store unit <b>26</b> for additional load or store requests. Load/store unit <b>26</b> also performs dependency checking for load instructions against pending store instructions to ensure that data coherency is maintained.</p><p>Data cache <b>28</b> is a high speed cache memory provided to temporarily store data being transferred between load/store unit <b>26</b> and the main memory subsystem. In one embodiment, data cache <b>28</b> has a capacity of storing up to 32 kilobytes of data. It is understood that data cache <b>28</b> may be implemented in a variety of specific memory configurations, including set-associative, direct mapped, and fully-associative configurations.</p><p>Segments and Segment Descriptors</p><p>In processors having a segmented memory model, the address space is divided into segments. Each program can access only data contained in those segments. Within each segment the addressing is linear, and the program can access byte <b>0</b>, byte <b>1</b>, byte <b>2</b>, and so on. The addressing is relative to the start of the segment, however, and the hardware address associated with software address zero is hidden from the programmer. Each segment has its own descriptor which stores specific information about the corresponding segment, e.g., the segment base address.</p><p>Turning now to FIG. 4, an exemplary format for a segment descriptor in the x86 architecture is shown. Fields <b>140</b>A-B stores the base address portion of the descriptor and have a combined total length of 32 bits. Fields <b>150</b>A-B store the limit or the last addressable unit of the segment. Fields <b>150</b>A-B have a combined total length of 20 bits. Granularity bit <b>142</b> is closely related to limit field <b>150</b>A-B. Granularity bit <b>142</b> specifies whether the resolution of the segment is a byte (G=0) or a page (G=1). A page is typically defined as 4,096 bytes. Default bit <b>144</b> determines the default address and operand size for the segment. A default bit <b>144</b> of zero sets a default operand and address size of 16 bytes. Conversely, a default bit of one sets a default operand and address size of 32 bytes. The interaction of default bit <b>144</b> and various instruction prefix bytes will be described in further detail below. Bit <b>146</b> is set to zero and is reserved for future use. AUVL bit <b>148</b> is available for use by system programmers. Possible uses include marking segments for garbage collection or indicating segments having based addresses that should not be modified. Access rights field <b>152</b> stores various access information about the segment. For example, type information is included to indicate the types of operations allowed on the segments (e.g., read-only, read-write, etc.). Bit <b>154</b> is set to zero and is also reserved for future use. Base address field <b>156</b> stores the base address for the segment.</p><p>Turning now to FIG. 5, a table showing the interaction between prefix bytes 66(hex) and 67(hex) and segment descriptor default flag <b>144</b> are shown. As the figure illustrates, prefix byte 66(hex) overrides the default operand size. Similarly, prefix byte 67(hex) overrides the default address size.</p><p>Details of Address Translation Table</p><p>Turning now to FIG. 6, details of one embodiment of address translation table <b>36</b> are shown. In this embodiment, address translation table <b>36</b> is configured to be set associative, with each set (i.e., row) comprising multiple ways (i.e., columns). When prefetch/predecode unit <b>12</b> has completed predecoding an instruction, it is conveyed to instruction cache <b>16</b> for storage. In parallel, prefetch/predecode unit <b>12</b> is configured to convey the address of the instruction to address translation table <b>36</b>, which allocates a storage location to the instruction. An index portion <b>60</b> of the instruction's address is used to select the set or row. The storage location may then be selected from any of the available storage locations within the row. For example, if table <b>36</b> is configured as a 4-way set-associative array, then each instruction may be allocated one of the four different storage locations that comprise the set or row corresponding to the index portion of the instruction's address. If none of the four storage locations is available (i.e., if they are all full), then one of the storage locations may be overwritten based on some type of replacement scheme, e.g., a least recently used (LRU) scheme. Note, table <b>36</b> may be implemented in other configurations, e.g., as a fully-associative array.</p><p>Once the instruction is stored in a storage location within instruction cache <b>16</b> and a storage location in address translation table <b>36</b> has been allocated, the pointer to the instruction's storage location within instruction cache <b>16</b> is stored in address translation table <b>36</b>. This mechanism allows instructions to be padded and stored in any location within instruction cache <b>16</b>. Address translation table <b>36</b> thus provides a convenient mechanism for accessing instructions that have been offset and that have had their lengths modified.</p><p>Upon receiving a requested fetch address <b>44</b>, address translation table <b>36</b> is configured to select a set <b>66</b> of storage locations using index portion <b>60</b>. From selected set <b>66</b> the stored address tags are compared with tag portion <b>62</b> in tag compare/way selection unit <b>70</b> to determine if there is a match. If there is a match, the pointer corresponding to the matching address tag in the selected set is conveyed to instruction cache <b>16</b>. In response, instruction cache <b>16</b> is configured to output the instruction stored at that location. The instruction is then routed to scan/alignment unit <b>18</b>.</p><p>Note the embodiment illustrated in FIG. 5 may be modified in any number of ways. For example, in one embodiment address translation table <b>36</b> may store multiple pointers for each address tag. In this manner, address translation table <b>36</b> may store sequences of pointers that indicate sequences were run of instructions of indicative of a predicted order of execution for the instructions stored in instruction cache <b>16</b>. In another alternative, instruction cache <b>16</b> may be utilized without address translation table <b>36</b>. For example, instruction cache <b>16</b> may be configured similarly to address translation table <b>36</b>, except for storing the predecoded instruction in place of the pointer.</p><p>In one embodiment instruction cache <b>16</b> may comprise a plurality of fixed length instruction storage locations. Each storage location may be configured to store one fixed length instruction. In this embodiment, instruction cache <b>16</b> may be configured to output only the single instruction corresponding to the pointer received from address translation table <b>36</b>. In this embodiment scan/alignment unit <b>18</b> may be greatly simplified. In another embodiment instruction cache <b>16</b> may be configured to output a fixed number of bytes starting with the byte pointed to by the pointer received from address translation table <b>36</b>. Alternatively, instruction cache <b>16</b> may output the entire cache line corresponding to pointer <b>64</b>. In yet another embodiment, instruction cache <b>16</b> may also be set-associative. In such an embodiment, portions of pointer <b>64</b> may be used to index a particular set within instruction cache <b>16</b>, whereas other portions of pointer <b>64</b> may be compared with pointer tags stored in each way of instruction cache <b>16</b>.</p><p>Method for Predecoding</p><p>Turning now to FIG. 7, one embodiment of a method for predecoding instructions having variable address and operand lengths is shown. Note while this method (as in the examples above) assumes an x86-compatible instruction set, the embodiments described herein may be modified to also predecode other instruction sets having prefix bytes that influence address and operand length.</p><p>As shown in the figure, upon receiving a requested fetch or prefetch address, instruction bytes are read from a main memory subsystem (step <b>160</b>). Next, predecode bits may be generated for each of the instruction bytes (step <b>162</b>). The instruction's segment descriptor default bit is examined to determine the instruction's default address and operand size (step <b>164</b>). If the instruction's segment descriptor default size bit is not set, the instruction's default address and operand size is 16 bits. The instruction's prefix bytes (if any) are also examined. If a prefix byte 66 (hex) is not present, then the operand has a length of 16 bits. Prefetch/predecode unit <b>12</b> is then configured to pad the operand with constants until it achieves a length of 32 bits (step <b>168</b>). If, however, a prefix byte of 66 (hex) is present, then the instructions operand length is already 32 bits. Thus, prefetch/predecode unit need not pad the operand. Next, prefetch/predecode unit <b>12</b> determines whether or not a prefix byte of 67 (hex) is present (step <b>170</b>). If the prefix byte is not present, then prefetch/predecode unit <b>12</b> is configured to pad any addresses within the instruction until they are 32 bit long (step <b>172</b>).</p><p>Prefetch/predecode unit <b>12</b> is configured to perform similarly when the instruction segment descriptor default bit is asserted (i.e., a 32-bit default address and operand length). In this case, if a prefix byte of the 66 (hex) is present (step <b>174</b>), then the instruction operand length is 16 bits. Thus, prefetch/predecode unit <b>12</b> is configured to pad any operands to a length of 32 bits (step <b>176</b>). Similarly, if a prefix byte of 67 (hex) is present, then prefetch/predecode unit <b>12</b> is configured to pad the addresses to 32 bits (step <b>180</b>). As the figure indicates, if neither prefix bytes are present, then prefetch/predecode unit <b>12</b> is configured route the instruction to instruction cache <b>16</b> without modification. Once prefetch/predecode unit <b>12</b> has completed predecoding the instruction, it is routed to instruction cache <b>16</b> for storage along with any corresponding predecode bits (step <b>182</b>). Prefetch/predecode unit <b>12</b> is also configured to store a corresponding pointer into address translation table <b>36</b> as previously discussed (step <b>184</b>). Optionally, prefetch/predecode unit <b>12</b> may also store an unmodified version of the instruction into secondary instruction cache <b>40</b>.</p><p>Turning now to FIG. 8, one embodiment of a method for accessing stored predecoded instruction is shown. First, a fetch address is generated and conveyed to prefetch/predecode unit <b>12</b> (step <b>130</b>). Next, the fetch address is conveyed to address translation table <b>36</b> which uses the fetch address to look up a corresponding pointer to an instruction storage location within instruction cache <b>16</b> (step <b>132</b>). Since each instruction stored in instruction cache <b>16</b> has a corresponding entry in address translation table <b>36</b>, the presence (or lack thereof) of a pointer for a particular fetch address indicates whether or not there is an instruction cache hit (step <b>134</b>). If a corresponding pointer is stored within address translation table <b>36</b>, then this pointer is used to access the desired instruction in instruction cache <b>16</b> (step <b>138</b>). If, however, a corresponding pointer is not present within address translation table <b>36</b>, then the desired instruction is fetched from the main memory subsystem as previously discussed in FIG. 7 (step <b>136</b>). Once the instruction is read from instruction cache <b>16</b>, it is scanned, aligned, decoded, and executed (step <b>140</b>). As previously noted, each instruction's segment descriptor determines the instruction's default operand and address length. Since a number of instructions may complete execution after a particular instruction is predecoded, the predecoded instruction's segment descriptor may be changed. For example, a second instruction completing execution after a first instruction is predecoded (and before the first instruction is executed) may overwrite the segment descriptor relied upon when predecoding the first instruction. This change may render the predecoded version of the first instruction incorrect. If prefetch/predecode unit <b>12</b> predecodes the first instruction assuming an incorrect default address and operand length, the padded version of the first instruction stored in instruction cache <b>16</b> will be incorrect.</p><p>While changes to a segment descriptor may occur relatively infrequently, microprocessor <b>10</b> may be configured to detect such changes when they occur (step <b>142</b>). When an instruction modifies a segment descriptor, microprocessor <b>10</b> may be configured to flush any following instruction in the pipeline (i.e., instructions in scan/alignment unit <b>18</b>, decode units <b>20</b>A-C, reservation stations <b>22</b>A-C, functional units <b>24</b>A-C, and load/store unit <b>26</b>). Similarly, microprocessor <b>10</b> may be configured to flush instruction cache <b>16</b> and address translation table <b>36</b> to prevent any improperly predecoded instruction from executing. Then, subsequent instructions are fetched from the main memory subsystem as previously disclosed (step <b>146</b>). This effectively rebuilds address translation table <b>36</b> and instruction cache <b>16</b>. Note, in some embodiments of microprocessor <b>10</b>, optional secondary instruction cache <b>40</b> may be used to rebuild address translation table <b>36</b> and instruction cache <b>16</b> upon a segment descriptor change.</p><p>Exemplary Computer System</p><p>Turning now to FIG. 9, a block diagram of one embodiment of a computer system <b>200</b> configured to use microprocessor <b>10</b> is disclosed. Computer system <b>200</b> is coupled to a variety of system components through a bus bridge <b>202</b> as shown. Other embodiments are possible and contemplated. In the depicted system, a main memory <b>204</b> is coupled to bus bridge <b>202</b> through a memory bus <b>206</b>, and a graphics controller <b>208</b> is coupled to bus bridge <b>202</b> through an AGP bus <b>210</b>. Finally, a plurality of PCI devices <b>212</b>A-<b>212</b>B are coupled to bus bridge <b>202</b> through a PCI bus <b>214</b>. A secondary bus bridge <b>216</b> may further be provided to accommodate an electrical interface to one or more EISA or ISA devices <b>218</b> through an EISA/ISA bus <b>220</b>. Microprocessor <b>10</b> is coupled to bus bridge <b>202</b> through a CPU bus <b>224</b>.</p><p>Bus bridge <b>202</b> provides an interface between microprocessor <b>10</b>, main memory <b>204</b>, graphics controller <b>208</b>, and devices attached to PCI bus <b>214</b>. When an operation is received from one of the devices connected to bus bridge <b>202</b>, bus bridge <b>202</b> identifies the target of the operation (e.g. a particular device or, in the case of PCI bus <b>214</b>, that the target is on PCI bus <b>214</b>). Bus bridge <b>202</b> routes the operation to the targeted device. Bus bridge <b>202</b> generally translates an operation from the protocol used by the source device or bus to the protocol used by the target device or bus.</p><p>In addition to providing an interface to an ISA/EISA bus for PCI bus <b>214</b>, secondary bus bridge <b>216</b> may further incorporate additional functionality, as desired. For example, in one embodiment, secondary bus bridge <b>216</b> includes a master PCI arbiter (not shown) for arbitrating ownership of PCI bus <b>214</b>. An input/output controller (not shown), either external from or integrated with secondary bus bridge <b>216</b>, may also be included within computer system <b>200</b> to provide operational support for a keyboard and mouse <b>222</b> and for various serial and parallel ports (e.g., a modem port for connecting a modem), as desired. An external cache unit (not shown) may further be coupled to CPU bus <b>224</b> between microprocessor <b>10</b> and bus bridge <b>202</b> in other embodiments. Alternatively, the external cache may be coupled to bus bridge <b>202</b> and cache control logic for the external cache may be integrated into bus bridge <b>202</b>.</p><p>Main memory <b>204</b> is a memory in which application programs are stored and from which microprocessor <b>10</b> primarily executes. A suitable main memory <b>204</b> comprises DRAM (Dynamic Random Access Memory), and preferably a plurality of banks of SDRAM (Synchronous DRAM) or RDRAM (Rambus DRAM).</p><p>PCI devices <b>212</b>A-<b>212</b>B are illustrative of a variety of peripheral devices such as, for example, network interface cards, video accelerators, audio cards, hard or floppy disk drives or drive controllers, SCSI (Small Computer Systems Interface) adapters and telephony cards. Similarly, ISA device <b>218</b> is illustrative of various types of peripheral devices, such as a modem, a sound card, and a variety of data acquisition cards such as GPIB or field bus interface cards.</p><p>Graphics controller <b>208</b> is provided to control the rendering of text and images on a display <b>226</b>. Graphics controller <b>208</b> may embody a typical graphics accelerator generally known in the art to render three-dimensional data structures which can be effectively shifted into and from main memory <b>204</b>. Graphics controller <b>208</b> may therefore be a master of AGP bus <b>210</b> in that it can request and receive access to a target interface within bus bridge <b>202</b> to thereby obtain access to main memory <b>204</b>. A dedicated graphics bus accommodates rapid retrieval of data from main memory <b>204</b>. For certain operations, graphics controller <b>208</b> may further be configured to generate PCI protocol transactions on AGP bus <b>210</b>. The AGP interface of bus bridge <b>202</b> may thus include functionality to support both AGP protocol transactions as well as PCI protocol target and initiator transactions. Display <b>226</b> is any electronic display upon which an image or text can be presented. A suitable display <b>226</b> includes a cathode ray tube (\u201cCRT\u201d), a liquid crystal display (\u201cLCD\u201d), etc.</p><p>It is noted that, while the AGP, PCI, and ISA or EISA buses have been used as examples in the above description, any bus architectures may be substituted as desired. It is further noted that computer system <b>200</b> may be a multiprocessing computer system including additional microprocessors (e.g. microprocessor <b>10</b><i>a </i>shown as an optional component of computer system <b>200</b>). Microprocessor <b>10</b><i>a </i>may be similar to microprocessor <b>10</b>. More particularly, microprocessor <b>10</b><i>a </i>may be an identical copy of microprocessor <b>10</b>. Microprocessor <b>10</b><i>a </i>may share CPU bus <b>224</b> with microprocessor <b>10</b> (as shown in FIG. 3) or may be connected to bus bridge <b>202</b> via an independent bus.</p><p>It will be appreciated by those skilled in the art having the benefit of this disclosure that this invention is believed to be capable of use with any microprocessor or computer system configured to execute instructions with prefix bytes that influence opcode and or address length. Furthermore, it is also to be understood that the form of the invention shown and described is to be taken as exemplary. Various modifications and changes may be made without departing from the spirit and scope of the invention as set forth in the claims. It is intended that the following claims be interpreted to embrace all such modifications and changes.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Paul K.", "last_name": "Miller", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}, {"first_name": "", "last_name": "ADVANCED MICRO DEVICES, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  15/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/30        20060101A I20051008RMEP"}, {"label": "G06F   9/318       20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712213"}, {"primary": false, "label": "712205"}, {"primary": false, "label": "712E09029"}, {"primary": false, "label": "712E09037"}, {"primary": false, "label": "712210"}], "ecla_classes": [{"label": "G06F   9/38C2"}, {"label": "G06F   9/38B9"}, {"label": "G06F   9/30U4"}, {"label": "G06F   9/30T2A"}], "cpc_classes": [{"label": "G06F   9/30152"}, {"label": "G06F   9/3816"}, {"label": "G06F   9/30178"}, {"label": "G06F   9/382"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1998-10-02", "application_date": "1998-10-02", "family_members": [{"ucid": "US-6240506-B1", "titles": [{"lang": "EN", "text": "Expanding instructions with variable-length operands to a fixed length"}]}]}