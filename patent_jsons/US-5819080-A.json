{"patent_number": "US-5819080-A", "publication_id": 71841874, "family_id": 24327956, "publication_date": "1998-10-06", "titles": [{"lang": "EN", "text": "Microprocessor using an instruction field to specify condition flags for use with branch instructions and a computer system employing the microprocessor"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA37824104\"><p>A microprocessor is provided including a branch prediction unit configured to select one of multiple sets of condition flags for use by a branch instruction according to the segment register override prefix byte which may be included with the instruction. Branch instructions may be scheduled distant from the instruction which sets the condition flags tested by the branch instruction. Numerous instructions may be placed between the two instructions, such that the condition flags may be available at the time the instruction is fetched. The branch instruction may be executed without stalling until the condition flags are available. In another embodiment, the branch prediction unit is configured to predict the direction a branch instruction may take according to a branch prediction scheme. Additionally, upon detection of a segment override prefix byte, the branch prediction unit uses an alternative branch prediction scheme. The alternative branch prediction scheme may be to predict the branch taken if a particular segment register override prefix byte is detected, and to predict the branch not taken if another particular segment register override prefix byte is detected.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. A microprocessor comprising:<claim-text>an address translation unit configured to generate a physical address from a logical address and a segment value;</claim-text><claim-text>a plurality of segment registers coupled to said address translation unit wherein at least one of said plurality of segment registers stores said segment value;</claim-text><claim-text>a first control unit coupled to said address translation unit wherein said first control unit is configured to detect an instruction field indicative of one of said plurality of segment registers and to convey a signal to said address translation unit indicative of said one of said plurality of segment registers;</claim-text><claim-text>a configuration register for storing a value indicative of an address translation mode of said microprocessor; and</claim-text><claim-text>a branch prediction unit for handling branch instructions wherein said branch prediction unit is configured to modify the handling of a branch instruction according to said instruction field.</claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. The microprocessor as recited in claim 1 further comprising multiple sets of condition flags indicative of the results of executing instructions.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. The microprocessor as recited in claim 2 further comprising an execution unit wherein said execution unit is configured to select one of said multiple sets of condition flags to modify according to the results of executing an instruction including said instruction field, and wherein said execution unit is configured to select said one of said multiple sets of condition flags according to said instruction field.</claim-text></claim>"}, {"num": 4, "parent": 2, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. The microprocessor as recited in claim 2 wherein said branch prediction unit is configured to select one of said multiple sets of condition flags for use by said branch instruction.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. The microprocessor as recited in claim 4 wherein said one of said multiple sets of condition flags is used by said branch instruction to determine the direction of the branch instruction.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. The microprocessor as recited in claim 1 wherein said branch prediction unit is configured to choose a default one of said multiple sets of condition flags if said instruction field is not detected.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. The microprocessor as recited in claim 1 wherein said branch prediction unit is configured to handle said branch instruction according to a branch prediction scheme.</claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. The microprocessor as recited in claim 7 wherein said branch prediction unit is configured to predict said branch instruction taken if said branch instruction includes a particular value within said instruction field.</claim-text></claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. The microprocessor as recited in claim 7 wherein said branch prediction unit is configured to predict said branch instruction not taken if said branch instruction includes another particular value within said instruction field.</claim-text></claim>"}, {"num": 10, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. The microprocessor of claim 1:<claim-text>wherein the configuration register stores a first value when the microprocessor is in a flat memory address translation mode, and a second value when the microprocessor is in a different address translation mode, and;</claim-text><claim-text>wherein the branch prediction unit modifies handling of a branch instruction in response to said first value stored in the configuration register.</claim-text></claim-text></claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. A computer system comprising:<claim-text>a main memory; and</claim-text><claim-text>a microprocessor coupled to said main memory wherein said microprocessor comprises:<claim-text>an address translation unit configured to generate a physical address from a logical address and a segment value;</claim-text><claim-text>a plurality of segment registers coupled to said address translation unit wherein at least one of said plurality of segment registers stores said segment value;</claim-text><claim-text>a first control unit coupled to said address translation unit wherein said first control unit is configured to detect an instruction field indicative of one of said plurality of segment registers and to convey a signal to said address translation unit indicative of said one of said plurality of segment registers;</claim-text><claim-text>a configuration register for storing a value indicative of an address translation mode of said microprocessor; and</claim-text><claim-text>a branch prediction unit for handling branch instructions wherein said branch prediction unit is configured to modify the handling of a branch instruction according to said instruction field.</claim-text></claim-text></claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim num=\"12\"><claim-text>12. The computer system as recited in claim 11 further comprising an external cache coupled between said microprocessor and said main memory.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES67185078\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention relates to the field of microprocessors and, more particularly, to mechanisms for expanding microprocessor functionality within an existing microprocessor architecture.</p><p>2. Description of the Relevant Art</p><p>Microprocessor manufacturers continue to develop new products which execute x86 instructions in order to maintain compatibility with the vast amount of software developed for previous 80\u00d786 generations--the 8086/8, 80286, 80386, and 80486. Maintaining software compatibility has forced many architectural compromises in newer products. In order to retain the functions of earlier products, hardware has often been simply modified or extended in order to increase capability and performance. One area that is often extended to increase capability and performance is the memory addressing model.</p><p>Early x86 microprocessors implemented a memory addressing model using segmentation. In segmentation, a memory address is specified by an instruction using two parts: a segment and an offset within the segment. This type of memory address may be referred to as a \"virtual\" or \"logical\" address. The segment selector is stored in a segment register and indicates where the segment is located in main memory (if the processor is running in unprotected mode) or points to a segment descriptor stored in a segment descriptor table in main memory. The segment descriptor contains information about the segment, including its base address. The base address is added to the offset to form the physical address. Each x86 instruction which has the ability to access memory has a default segment register from which it draws its segment data. The x86 architecture defines six segment registers: CS, DS, SS, ES, FS, and GS. CS is the default segment register used for code (instruction) storage. DS is the default segment register used for data accesses of instructions which do not manipulate stack values. For stack accesses, SS is the default segment register. ES is the default segment register used for string manipulation instructions. The default segment may be overridden in favor of another segment register for a particular instruction by adding a segment override prefix byte to the instruction. The segment override prefix byte is a field of the instruction. As used herein, the term \"instruction field\" refers to one or more bytes within the bytes which form an instruction.</p><p>Beginning with the 80386, special paging circuitry was added to the segmented address generation hardware to allow the implementation of paged memory systems. Programmers are developing operating systems which use paged memory systems. Paged memory systems offer the ability to load smaller portions of programs into main memory at any given time and provide additional built-in protection checking for programs running simultaneously. Additional information regarding the paging structure and segmentation in the x86 architecture may be found within the publication \"Programming the 80386\" by Crawford, et al., SYBEX, Inc., San Francisco, 1987. This publication is incorporated herein by reference in its entirety.</p><p>Memory segmentation is typically not used when implementing such paged memory systems upon microprocessors which implement 32 bit logical addressing. Memory segmentation cannot be \"turned off,\" but may be effectively disabled through the use of a \"flat\" memory model made possible with the advent of 32 bit logical addressing. A flat memory model is created by making all segment registers point to the same memory segment (i.e., making all memory segments overlap). This overlapping is accomplished by storing the same segment information in all segment registers. Programmers using the paging mechanism typically implement the flat memory model.</p><p>The flat memory model has a major impact on the utility of the segment registers. Holding redundant segment address information makes the two general purpose segment registers added with the 80286 microprocessor, FS and GS, virtually useless. (The other segment registers are implicitly referenced by 80\u00d786 instructions, but they contain redundant information). In addition, operating systems may detect attempts to use these registers for other useful purposes and may generate an exception. Since these registers are used for address generation, loading a segment register with an improper value might enable a program to corrupt the memory space being used by another program, or by the operating system itself. A constructive use for explicit references to segment registers under the flat memory model is desired.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by a microprocessor according to the present invention. The present microprocessor includes a branch prediction unit configured to select one of multiple sets of condition flags for use by a branch instruction according to the segment register override prefix byte included with the instruction. Advantageously, branch instruction functionality may be enhanced through the use of segment register override prefix bytes. The segment override prefix bytes may therefore offer a constructive use with branch instructions even if the flat memory model is employed. Branch instructions may be scheduled distant from the instruction which sets the condition flags tested by the branch instruction. Numerous instructions may be placed between the two instructions, such that the condition flags may be available at the time the instruction is fetched. Therefore, the branch instruction may be executed without stalling until the condition flags are available. Performance of the microprocessor may be increased due to the decreased stalling of branch instructions.</p><p>In another embodiment, the branch prediction unit is configured to predict the direction a branch instruction may take according to a branch prediction scheme. Additionally, upon detection of a segment override prefix byte, the branch prediction unit uses an alternative branch prediction scheme. The alternative branch prediction scheme may be to predict the branch taken if a particular segment register override prefix byte is detected, and to predict the branch not taken if another particular segment register override prefix byte is detected.</p><p>Broadly speaking, the present invention contemplates a microprocessor comprising several units. An address translation unit is included, and is configured to generate a physical address from a logical address and a segment value. Coupled to the address translation unit is a plurality of segment registers. At least one of the plurality of segment registers stores the segment value utilized by the address translation unit. Additionally coupled to the address translation unit is a first control unit, which is configured to detect an instruction field indicative of one of the plurality of segment registers and to convey a signal to the address translation unit indicative of that segment register. A configuration register for storing a value indicative of an address translation mode of the microprocessor is included. Still further, a branch prediction unit for handling branch instructions is included. The branch prediction unit is configured to modify the handling of a branch instruction according to the instruction field.</p><p>The present invention further contemplates a computer system. The computer system comprises a main memory coupled to a microprocessor similar to the above contemplated microprocessor.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of a computer system which includes an 80\u00d786 microprocessor.</p><p>FIG. 2 is a block diagram illustrating the address translation unit of FIG. 1 including structures which generate physical memory addresses in 80\u00d786 microprocessors operating in real mode.</p><p>FIG. 3 is a block diagram illustrating the address translation unit of FIG. 1 including structures which generate physical memory addresses in 80\u00d786 microprocessors operating in protected mode.</p><p>FIG. 4 is a block diagram of a portion of a microprocessor including a cache controller which is selectively enabled through segment register selection information.</p><p>FIG. 5 is a block diagram of a portion of a microprocessor including a data prefetch unit which is selectively enabled through segment register selection information.</p><p>FIG. 6 is a block diagram of a portion of a microprocessor including a branch prediction unit which receives control information through segment register selection information.</p><p>FIG. 7 is a block diagram of a portion of a microprocessor including a branch prediction unit configured to detect and use segment register selection information.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>Turning now to FIG. 1, a block diagram of a computer system 100 including a microprocessor 101 is shown. In one embodiment, microprocessor 101 implements the 80\u00d786 microprocessor architecture. Microprocessor 101 is coupled to an external cache unit 102 and a main memory 104. In some embodiments, external cache unit 102 is not included. External cache unit 102 is used to speed the transfer of recently accessed data and instructions which are not stored in the internal cache of microprocessor 101. Microprocessor 101 includes a bus interface unit 106 which orchestrates the transfer of information from the internal units of Microprocessor 101 to external cache unit 102 and/or main memory 104. Internal cache unit 108 stores instruction and data information for use by fetch unit 110 and execution unit 112. In one embodiment, internal cache unit 108 includes a unified instruction and data cache. In another embodiment, separate instruction and data caches are configured into internal cache unit 108.</p><p>Fetch unit 110 fetches instructions from internal cache unit 108 and passes the instructions to instruction decode unit 114. Instruction decode unit 114 decodes the received instructions for dispatch to execution unit 112. Operands which reside in registers are fetched by instruction decode unit 114 and provided with the instruction when the instruction is dispatched to execution unit 112. Execution unit 112 is configured to execute instructions once the operands are available. As will be appreciated by those skilled in the art, x86 instructions sometimes have operands which are stored in memory at an address specified in a register, by an offset, or by some combination of registers and offsets. In order to retrieve operands stored in memory, execution unit 112 passes segment register identification information and a calculated offset to address translation unit 116. Segment register identification information is generated from either segment override prefix bytes or from the default segment register for the associated instruction. Based on the translation mode of microprocessor 101, address translation unit 116 translates the address via the segmentation method and optionally via the paging method described above.</p><p>In one embodiment, the translated address is passed by address translation unit 116 to the internal cache unit. In other embodiments, a cache access is started by execution unit 112 and completed using the translated address from address translation unit 116. In still another embodiment, internal cache unit 108 is addressed with an untranslated address. In this embodiment, address translation unit 116 is accessed when a cache miss occurs, or when cache lines are removed from internal cache unit 108 and returned to main memory 104.</p><p>Generally speaking, address translation unit 116 is configured to receive segment register identification information and an offset and to translate this information into a physical address. If flat addressing mode is in effect, the segment register identification information is unimportant since the segment registers each contain the same value. Therefore, features may be added to microprocessor 101 by interpreting the segment identification information passed to address translation unit 116. Features added in this way may be transparent, such that code written to take advantage of the features will run correctly on processors which implement the x86 architecture but do not implement the added features and such that code which was written without awareness of the features will run correctly on processors which implement the added features. Features added in this way may also be non-transparent, such that code written to take advantage of the features may not run correctly on processors which do not implement the features and such that code written without awareness of the features may not run on processors which implement the features. Additionally, features may be added in a non-transparent fashion by using the value stored within the selected segment register (i.e. the segment register specified by the segment register override prefix) to control a feature. When the value stored is used, the feature is non-transparent because address translation unit 114 is configured to ignore (when performing translations) the portion of the segment register used to control the feature. Since this functionality is not a part of the 80\u00d786 architecture, the adding of features controlled by the values stored in a segment register is non-transparent. Many different features are contemplated, as will be revealed below after a discussion of address translation unit 116 in more detail.</p><p>FIG. 2 shows address translation unit 116 of FIG. 1 in more detail for the case of real mode physical address generation. In this mode, address translation unit 116 generates 20-bit physical addresses. Address translation unit 116 is presented with segment register identification information and a 16-bit offset value. Multiplexor 204 uses the segment register selection information to provide the contents of one of the segment registers to the shift register 206. (8086/8 microprocessors have only four of the six segment registers shown: CS, DS, ES, and SS). Shift register 206 then shifts this value four binary bit positions to the left, forming the 20-bit base address of a memory segment. Adder 208 adds the 16-bit offset to the 20-bit segment base address, resulting in a 20-bit physical address for a location in memory.</p><p>FIG. 3 shows address translation unit 116 of FIG. 1 in more detail for the case of protected mode physical address generation. Protected mode is not available on 8086/8 microprocessors. As in real mode, address translation unit 116 is presented with segment register identification information and an offset value. In protected mode, however, the segment register contains an index into one of two tables of memory segment information residing in main memory. The tables contain information about the translation of the address, including the base address of the segment and the size of the segment.</p><p>Beginning with the 80286 microprocessor, two general purpose segment registers were added (FS and GS), bringing the total number of segment registers to six. Information about six memory segments may be loaded into the six segment registers. Typically shadow registers associated with each segment register store the data from the associated segment descriptor, including the base addresses of the segment. In the 80286, segment base addresses are 24 bits long. In the 80386 and 80486, segment base addresses are 32 bits long. Multiplexor 304 uses the segment register identification information to provide the contents of one of the base addresses of the corresponding memory segment. Adder 306 adds the offset to the segment base address, resulting in a physical address for a location in memory (assuming paging circuitry 308 is disabled). In the 80286, offsets are 16 bits long, and physical addresses are 24 bits long. In the 80386 and 80486, offsets may be 16 or 32 bits long, and physical addresses are 32 bits long. If paging circuitry 308 is enabled, the address formed by adder 306 is translated yet again according to a paging algorithm. The paging algorithm uses high order bits of the address formed by adder 306 to index into a page directory containing addresses of page tables. The address of the page table is added to a second range of bits from adder 306 to find a particular page directory entry. The information stored therein is used to translate the address formed by adder 306 to a physical address.</p><p>In flat addressing mode, the paging algorithm is used for the translation and the address generated by adder 306 is the same as the logical address, as noted above. Therefore, the segment registers are of very little use. Of particularly little use are segment registers FS and GS, which are not default segment registers for x86 instructions. Therefore, the segment register override prefix bytes referring to the FS and GS registers may be used to enable expanded features of microprocessor 101. Furthermore, segment register override prefix bytes which specify the default segment register for an instruction may be used in a second embodiment. It is noted that the second embodiment may also be used when flat memory addressing is not in effect.</p><p>FIG. 4 is a block diagram of a portion of microprocessor 101 including a cache control unit 404. Cache control unit 404 is configured within internal cache unit 108 and is coupled to execution unit 112 and to a control register 402. Cache control unit 404 is selectively enabled using segment register identification information, provided by the execution unit 112, and using the contents of an enabling bit 400 in control register 402. When enabling bit 400 is set, the cache controller 404 selectively stores data associated with the instruction which produced the segment register identification information in internal cache unit 108. This cacheability selection is in addition to the architectural cacheability selection of the x86 architecture as embodied in the PCD bit of the page table entry. In one embodiment, the data is stored unless the FS segment register is specified by a segment register override prefix byte for the associated instruction. Other embodiments may use other segment register overrides for this function.</p><p>In another embodiment, the value stored within the selected segment register is conveyed to cache control unit 404. The cacheability of a particular address is thereby determined by the value conveyed.</p><p>If enabling bit 400 is cleared, the segment register identification information is not used to determine cacheability of a particular address. In another embodiment, the cacheability trait for an address is conveyed to external cache 102 (shown in FIG. 1).</p><p>In yet another embodiment, cache controller 404 is configured to selectively store a line in write-through or writeback mode. When enabling bit 400 is set, the cache controller 404 selectively stores data associated with the instruction which produced the segment register identification information in internal cache unit 108 in a write-through or writeback mode. This mode selection is in addition to the architectural write-through selection of the x86 architecture as embodied in the PWT bit of the page table entry. In one embodiment, the data is stored in writeback mode unless the FS segment register is specified by a segment register override prefix byte for the associated instruction. Other embodiments may use other segment register override prefix bytes for this function. In yet another embodiment, the value stored within the selected segment register is conveyed to cache control unit 404. The write-through or writeback mode of a particular address is thereby determined by the value conveyed. If enabling bit 400 is cleared, the segment register identification information is not used to determine the write-through or writeback mode of a particular address. In another embodiment, the write-through or writeback trait for an address is conveyed to external cache 102 (shown in FIG. 1).</p><p>Cache control unit 404 has another embodiment which implements a cache flush or cache clean operation dependent on a particular value of segment register identification information associated with an instruction. A cache flush operation causes a cache line containing the address of the cache flush operation to be removed from the cache. If the line is modified with respect to main memory, the modified value is written back to main memory. A cache clean operation is similar to the flush operation in that a modified cache line is written back to main memory. However, the cache clean operation does not remove the line from the cache. These operations affect a single cache line, as opposed to the INVD and WBINVD instructions of the x86 architecture which affect the entire cache at once. The GS segment override prefix byte is used to cause a flush operation in this embodiment, and the ES segment override prefix byte is used to cause a clean operation. Other embodiments may use other segment register override prefix bytes for these functions, or may use the value stored in the selected segment register to specify these functions. If the value stored in the selected segment register is used, then the value is conveyed to cache control unit 404 along with the segment identification value.</p><p>In still another embodiment, cache control unit 404 implements a speculative miss line fill function based on the use of the FS segment register override prefix byte. In this embodiment, if the FS segment override prefix byte is specified for a particular instruction and the address associated with that instruction misses internal cache unit 108, then the cache line containing the address is fetched from main memory even if the instruction was executed by execution unit 112 speculatively. Sometimes, a particular instruction may appear to be speculative to microprocessor 101 even though the address is correct and will be needed by the program in the near future. If a programmer or is aware is aware of this situation, it could specify that a cache miss for the instruction be speculatively fetched into internal cache 108. When used in the context of instruction execution, the term \"speculative\" means that an instruction is executed before that instruction is known to be required by the sequential execution of instructions in a program.</p><p>Another embodiment of cache controller 404 is configured to allocate a cache line for a store instruction which misses internal cache 108 if the ES segment register override prefix byte is included in the store instruction. If enabling bit 400 is not set, then store instructions which miss internal cache 108 are written to main memory without fetching the associated cache line into internal cache 108. If enabling bit 400 is set, then store instructions that miss internal cache 108 will cause a cache line fill of the associated data bytes to occur if the store instruction includes the ES segment register override prefix byte. If the ES segment register override prefix byte is not included, then the cache line fill will not occur and the store data will be written to main memory. In still a further embodiment, a store instruction which misses the cache will cause a cache line to be allocated but the associated data bytes will not be fetched from memory. The data bytes provided by the store instruction will be stored into the cache line. However, the other data bytes of the cache line are marked invalid in internal cache 108 until additional store instructions cause the other data bytes to become valid. In an alternative embodiment, the other data bytes are set to zero. An additional embodiment of cache control unit 404 is configured to used the value stored in the selected segment register to specify the above mentioned speculative miss line fill functions.</p><p>In one embodiment, control register 402 is control register 0 present in 80386 and later microprocessors. The enabling bit 400 is bit 31 of control register 0, the paging bit. When bit 31 is set, paging is enabled.</p><p>FIG. 5 is a block diagram of a portion of microprocessor 101 including a data prefetch unit 500. Data prefetch unit 500 is coupled to execution unit 112 and to control register 402. Data prefetch unit 500 is selectively enabled using segment register identification information, provided by the execution unit 112, and using the contents of enabling bit 400 in control register 402. When enabling bit 400 is set, data prefetch unit 500 prefetches data associated with cache lines stored in consecutive groups of bytes of main memory 104 (shown in FIG. 1) starting at the address indicated by the instruction. The cache lines are stored by internal cache unit 108. If enabling bit 400 is not set, then the data prefetch unit remains idle. In one embodiment, data prefetch unit 500 begins prefetching if the FS segment register override is used for an instruction. The number of consecutive cache lines fetched by data prefetch unit 500 may vary from embodiment to embodiment. In another embodiment, data prefetching begins under the control of the value stored in the selected segment register. Additionally, the number of consecutive cache lines to fetch may be specified by the value stored in the selected segment register.</p><p>In yet another embodiment, data prefetch unit 500 implements other prefetching schemes. It is noted that many prefetching schemes are suitable for data prefetch unit 500, including a stride based prefetching scheme and other \"smart\" prefetching schemes. Various \"smart\" prefetching schemes are well-known, and typically involve generating prefetch addresses via a predetermined algorithm other than fetching sequential addresses.</p><p>FIG. 6 is a block diagram of a portion of microprocessor 101 including a branch prediction unit 600 which is including in fetch unit 110. Branch prediction unit 600 is coupled to execution unit 112 and to a control register 402. Branch prediction unit 600 implements the branch prediction scheme embodied within fetch unit 110, as well as an alternative scheme. The alternative scheme is enabled through segment register identification information, provided by execution unit 112, and the contents of enabling bit 400 in control register 402. If enabling bit 400 is not set, then the branch prediction scheme of branch prediction unit 600 is used. If enabling bit 400 is set, then the branch prediction scheme of branch prediction unit 600 is used except when a branch instruction includes the FS or GS segment register override prefix bytes. In this case, the alternative branch prediction scheme is used. It is noted that \"branch prediction\" refers to predicting whether a branch instruction causes program execution to continue at a new address specified by the branch instruction or causes program execution to continue at an instruction subsequent to the branch instruction within main memory 104. If the branch instruction causes program execution to continue at the new address (or target address), then the branch is said to be \"taken\". Alternatively, if the branch instruction causes program execution to continue at the subsequent instruction, the branch is said to be \"not taken\".</p><p>In one embodiment, the alternative branch prediction scheme is as follows: If the branch instruction includes the FS segment register override prefix byte, the branch is predicted taken. If the GS segment register override prefix byte is included, the branch is predicted not taken. It is noted that branch prediction unit 600 may execute the branch instructions as well as predict the branches taken or not taken. If microprocessor 101 is configured in this fashion, branch prediction unit 600 does not receive segment identification information from execution unit 112. Instead, branch prediction unit 600 detects the segment register override prefix byte. Such an embodiment is shown in FIG. 7. As shown in FIG. 7, branch prediction unit 600 receives enabling bit 400 from control register 402. As instructions are fetched by fetch unit 110, branch prediction unit 600 detects branch instructions and forms branch predictions. The prediction may be based upon segment register override prefix bytes included within the branch instruction as described above. It is additionally noted that branch prediction unit 600 may be configured to detect the segment identification information associated with a branch instruction even if branch prediction unit 600 does not execute the branch instructions. In such an embodiment, branch prediction unit 600 allows execution unit 112 to determine if the branch prediction is correct by executing the branch instruction. However, branch prediction unit 600 detects the use of a segment register override prefix byte when the instruction is fetched and forms the branch prediction in accordance with any detected prefix bytes.</p><p>The abovementioned uses for the segment register identification information are transparent uses, except for the embodiments which use the value stored in the selected segment register (instead of the existence of a particular segment override prefix byte) to control a feature. Non-transparent uses are also contemplated, as described below.</p><p>Two exemplary non-transparent uses may be implemented within execution unit 112. First, a segment register override prefix byte may be used to create instructions which do not modify the condition flags. As will be appreciated by those skilled in the art, \"condition flags\" are indicative of information regarding the result of executing an instruction. In the x86 microprocessor architecture, the condition flags include a carry flag indicative of a carry out of an arithmetic operation and a zero flag indicative of a zero result from an operation, among others. An exemplary instruction which may be modified to not change the condition flags in accordance with a generated result is the ADD instruction. Typically, the ADD instruction modifies the condition flags. An ADD instruction which uses a memory operand could be modified to an ADD instruction which does not modify the condition flags by using the segment register override prefix byte. In one embodiment, the FS segment register override prefix byte indicates that the ADD instruction will not modify the condition flags. This functionality allows for the scheduling of branches which are dependent upon a condition flag generated by a particular operation.</p><p>As used herein, the term \"scheduling\" refers to ordering instructions in as efficient a fashion as possible while still achieving the desired results. For example, an instruction which depends upon another instruction may be scheduled such that other instructions are placed between the two instructions. In this manner, stalls generated while the dependent instruction receives the data from the instruction upon which it depends may be eliminated. When the dependent instruction reaches execution, the value may be stored in a register or a memory location. For example, numerous instructions may be executed between the branch instruction and the instruction it depends upon for condition flags if those numerous instructions do not modify the condition flags. Therefore, the condition flags are set to the appropriate values many cycles prior to the branch instruction being executed. Instead of predicting the branch, branch prediction unit 600 may deterministically choose the direction the branch instruction will take.</p><p>Another embodiment which aids the scheduling of branch instructions is to implement multiple sets of condition flags. In this manner, multiple sets of conditions may be maintained simultaneously. Segment register override prefix bytes may be used with instructions which modify the condition flags to indicate which of multiple sets of condition flags to modify. A segment register override prefix byte may then be included with a branch instruction to indicate which of multiple sets of condition flags should be used to determine the branch direction (e.g. taken or not taken). If no segment register override prefix byte is included with respect to an instruction, then a default set of condition flags are associated with the instruction. It is noted that the condition flags may be stored in execution unit 112, branch prediction unit 600, or within both units simultaneously.</p><p>Another non-transparent use of segment register override prefix bytes may be embodied within instruction decode unit 114. As mentioned above, instruction decode unit 114 reads the register(s) specified as operands of an instruction and passes the values to execution unit 112 along with the instruction. In this embodiment, segment register override prefix bytes are used to select one of multiple register banks which store data. Each register bank may include the full complement of x86 registers. In this manner, the register set of the architecture may be expanded without changing the instruction encodings. As will be appreciated by those skilled in the art, a larger register set allows more operand values to be held in registers (which may be accessed quickly) and so accesses to memory (which typically require a longer period of time) are lessened. In one embodiment, no segment register override prefix byte specifies the first bank of registers, a segment register override prefix byte indicating the FS segment register specifies a second bank of registers, a segment register override prefix byte indicating the GS segment register specifies a third bank of registers, and a segment register override prefix byte indicating the ES segment register specifies a fourth bank of registers. In another embodiment, the value stored within the selected segment register is used to select the appropriate register bank from numerous register banks. It is noted that each register bank may be configured with a portion of the x86 registers as opposed to the entire register set.</p><p>It is noted that many other non-transparent uses may be created for segment register override prefix bytes. The present invention contemplates transparent and non-transparent functions implemented through the use of segment register override prefix bytes. It is additionally noted that while the above embodiments are 80\u00d786 microprocessors, any microprocessor implemented in any microprocessor architecture may benefit from a similar expansion of the architecture.</p><p>Aspects regarding other portions of a microprocessor may be found in the co-pending, commonly assigned patent application entitled \"High Performance Superscalar Microprocessor\", Ser. No. 08/146,382, filed Oct. 29, 1993 by Witt, et al. Additionally, information may be found in the co-pending, commonly assigned patent application entitled \"High Performance Superscalar Instruction Alignment Unit\", Ser. No. 08/377,865, filed Jan. 25, 1995 by Tran, et al. The disclosures of both of the aforementioned applications are hereby incorporated by reference in their entirety.</p><p>Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Drew J.", "last_name": "Dutton", "name": ""}, {"first_name": "David S.", "last_name": "Christie", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}, {"first_name": "", "last_name": "ADVANCED MICRO DEVICES, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/32        20060101A I20051008RMEP"}, {"label": "G06F  12/08        20060101A I20051008RMEP"}, {"label": "G06F   9/318       20060101A I20051008RMEP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712239"}, {"primary": false, "label": "712E09035"}, {"primary": false, "label": "712E09052"}, {"primary": false, "label": "711E1204"}, {"primary": false, "label": "712E09047"}, {"primary": false, "label": "711E12021"}, {"primary": false, "label": "712234"}, {"primary": false, "label": "712233"}, {"primary": false, "label": "712E09079"}], "ecla_classes": [{"label": "G06F   9/30B"}, {"label": "G06F   9/30X2"}, {"label": "G06F  12/08B2"}, {"label": "G06F  12/08B18"}, {"label": "G06F   9/38E2S"}, {"label": "G06F   9/38D2"}], "cpc_classes": [{"label": "G06F   9/3846"}, {"label": "G06F  12/0888"}, {"label": "G06F  12/0804"}, {"label": "G06F   9/30185"}, {"label": "G06F   9/383"}, {"label": "G06F   9/30094"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1996-01-02", "application_date": "1996-01-02", "family_members": [{"ucid": "US-5819080-A", "titles": [{"lang": "EN", "text": "Microprocessor using an instruction field to specify condition flags for use with branch instructions and a computer system employing the microprocessor"}]}]}