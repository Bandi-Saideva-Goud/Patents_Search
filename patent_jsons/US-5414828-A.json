{"patent_number": "US-5414828-A", "publication_id": 71033862, "family_id": 24131372, "publication_date": "1995-05-09", "titles": [{"lang": "EN", "text": "Apparatus for configuring relative position of a cache memory in a cache memory array"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA37423917\"><p>A cache memory which includes a cache controller formed on a single substrate. A plurality of the memories may be used in an array. The memories themselves determine how many other memories are in an array and each of their relative positions in the array. From this information, each memory sets the range of its set fields and the size of its tag fields. This is done on reset with the configuration information being distributed among the memories themselves, without being centrally stored, and in a manner transparent to the software.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. A cache memory for operation in a cache memory array comprising at least one cache memory, said cache memory comprising:<claim-text>a data storage array;</claim-text><claim-text>selection circuit coupled to said data storage array for selecting data from said data storage array, said selection circuit for receiving an incoming address and for comparing said incoming address with stored addresses, each of said stored addresses corresponding to data in said data storage array, said selection circuit for selecting data from said data storage array based upon said comparison;</claim-text><claim-text>logic circuit for generating a configuration signal for each cache memory in said cache memory array, wherein one configuration signal is active during each clock cycle, starting in an initial time period, for a different cache memory;</claim-text><claim-text>configuration circuit coupled to said logic circuit for receiving a configuration signal and for sensing said configuration signal every clock cycle to count, from said initial time period, clock cycles until an active configuration signal is sensed to determine an order for said cache memory in said cache memory array, said configuration circuit for generating a ready signal, upon receipt of said active configuration signal, indicating said order of said cache memory in said cache memory array, and for sensing, each clock cycle, said ready signal, generated from a different cache memory in said cache memory array, to indicate a total number of cache memories in said cache memory array, said configuration circuit for generating at least one control signal to indicate said total number of cache memories in said cache memory array; and</claim-text><claim-text>control circuit coupled to said selection circuit and to said configuration circuit for receiving said control signal said control circuit for utilizing n contiguous bits in said incoming address as enable bits to enable one cache memory in said cache memory array when said cache memory array comprises more than one cache memory, where n is a positive integer, and said control circuit for dynamically configuring n as a function of said control signal, and wherein one cache memory is enabled if said n contiguous bits in said incoming address correspond to a predetermined combination of n contiguous bits in said stored addresses such that only one cache memory in said cache memory array is enabled in response to said incoming address.</claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. The cache memory defined by claim 1, wherein n equals two when said at least one control signal indicates that the total number of said cache memories in said cache memory array is greater than two but not greater than four.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. The cache memory defined by claim 1, wherein said cache memory comprises storage for tag fields coupled to said selection circuit, each of said tag fields being part of a corresponding one of said stored addresses that is compared in said selection of data, a first number of bits of said tag fields being considered by said selection circuit in said selection of data when said control signal indicates that only one cache memory is present in said cache memory array, and wherein fewer than said first number of bits of said tag fields are considered by said selection circuit in said selection of data when said control signal indicates that said cache memory array comprises more than one cache memory.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. The cache memory defined by claim 1, wherein n equals one when said control signal indicates that two of said cache memories are present in said cache memory array.</claim-text></claim>"}, {"num": 5, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. A computer system comprising:<claim-text>at least one processor; a cache memory array comprising at least one cache memory coupled to said processor;</claim-text><claim-text>logic circuit for generating a configuration signal for each cache memory in said cache memory array, wherein one configuration signal is active during each clock cycle, starting in an initial time period, for a different cache memory; and</claim-text><claim-text>a configuration circuit for each cache memory in said cache memory array coupled to said logic circuit for receiving a configuration signal and for sensing said configuration signal every clock cycle to count, from said initial time period, clock cycles until an active configuration signal is sensed to determine an order for said cache memory in said cache memory array, said configuration circuit for generating a ready signal, upon receipt of said active configuration signal, indicating said order of said cache memory in said cache memory array, and for sensing, each clock cycle, said ready signal, generated from a different cache memory in said cache memory array, to indicate a total number of cache memories in said cache memory array, said configuration circuit for generating at least one control signal to indicate said total number of cache memories in said cache memory array, wherein said control signal is utilized by each cache memory to configure said cache memory array based on said total number of cache memories in said cache memory array.</claim-text></claim-text></claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. A method for enabling a cache memory for operation in a cache memory array comprising at least one cache memory, said method comprising the steps of:<claim-text>storing data in a data storage array;</claim-text><claim-text>generating a configuration signal for each cache memory in said cache memory array, wherein one configuration signal is active during each clock cycle, starting in an initial time period, for a different cache memory;</claim-text><claim-text>sensing said configuration signal every clock cycle;</claim-text><claim-text>counting, from said initial time period, clock cycles until an active configuration signal is sensed to determine an order for said cache memory in said cache memory array,</claim-text><claim-text>generating a ready signal, upon receipt of said active configuration signal, indicating said order of said cache memory in said cache memory array;</claim-text><claim-text>sensing, each clock cycle, said ready signal, generated from a different cache memory in said cache memory array, to indicate a total number of cache memories in said cache memory array;</claim-text><claim-text>generating at least one control signal to indicate said total number of cache memories in said cache memory array; and</claim-text><claim-text>receiving an incoming address;</claim-text><claim-text>enabling one cache memory in said cache memory array by utilizing n contiguous bits, where n is a positive integer, in said incoming address as enable bits when said cache memory array comprises more than one cache memory by determining n as a function of said control signal, and enabling said cache memory if said n contiguous bits in said incoming address correspond to a predetermined combination of n contiguous bits such that only one cache memory in said cache memory array is enabled in response to said incoming address.</claim-text></claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES66669595\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This is a continuation of application Ser. No. 07/865,367, filed Apr. 8, 1992, now abandoned, which is a divisional of application Ser. No. 07/534,750, filed Jun. 7, 1990, now abandoned.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The invention relates to the field of cache controllers and cache memories, particularly for microprocessors.</p><p>2. Prior Art</p><p>The cache controller and cache memory of the present invention is intended for use with the Intel 386\u2122 microprocessor, although the invention described may be used with other processing units. Intel Corporation manufactures the Part No. 82385, a high performance 32-bit cache controller for use with the Intel 386\u2122. This part is used in conjunction with a 32 Kbyte cache memory. Many of the signals used in the Intel 82385 and some of the circuitry of this prior art controller are incorporated in the controller of the present invention. A description of the Intel 82385 can be found in \"Microprocessor and Peripheral Handbook, Vol. 1 Microprocessor\", published by Intel Corporation beginning at page 4-287.</p><p>With the Intel 82385 as well as other prior art cache controllers, the controller provides an interface between a microprocessors local bus and a system bus. The controller also communicates with the cache memory. The controller typically includes the local bus interface, system bus interface, cache directory and cache control circuitry. An ordinary static memory is often used for the cache memory.</p><p>The present invention is a departure from the Intel 82385 in that the cache controller and cache memory are fabricated on a single chip. Moreover, one, two or four of these chips may be used as part of a cache array. The chips themselves are able to determine how many other members are in this array and each chip determines its relative position in the array.</p><p>The prior art discloses numerous computer systems where circuits may be added into the system with the system recognizing the additional circuits and adjusting for them. For example, microprocessor systems are made with \"bit-slice\"  circuits allowing several of the circuits to be coupled together to provide a microprocessor of a desired width (e.g., 4-bit, 8-bit microprocessor, etc.). Memory is frequently added to a computer system with the system adapting to the additional memory. In some cases, a microprocessor writes and reads into different address locations in order to determine how much memory is present on a bus. In other cases, the memory modules contain information concerning its resources.</p><p>As will be seen, the present invention provides a unique method and apparatus for configuring a cache array. The information concerning how many cache memories there are in the array and the relative position of each is distributed among the cache memories and, in effect, is transparent to the overall system. Each of the cache memories is identical, thus there is no need to preprogram or otherwise identify a memory before it is placed in the array.</p><h4>SUMMARY OF THE INVENTION</h4><p>A cache controller/cache memory is described which is formed on a single substrate. A plurality of these memories may be employed in an array. Each of the memories includes a cache directory for providing storage for a plurality of tag fields and a plurality of set fields. And, as is typically the case, the set fields based on incoming addresses select predetermined ones of the stored tag fields for comparison with an incoming address. A control means for the cache memory generates signals representing the relative position of the cache memory in an array with other of such cache memories and controls the range of the set fields and the size of the tag fields based on these signals. In the currently preferred embodiment, the signals representing the relative position of the cache memory in the array is generated within the memory itself, is not centrally stored and the range of the set fields and the size of the tag fields are adjusted in a manner transparent to the software.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1A illustrates the address bits allocation for the tag field, set field and line select bits when one cache memory is used in the present invention.</p><p>FIG. 1B illustrates the address bit allocation for the tag field, set field and line select bits when two cache memories are used in the present invention.</p><p>FIG. 1C illustrates the address bit allocation for the tag field, set field and line select bits when four cache memories are used in the present invention,</p><p>FIG. 1D illustrates the tag field range and set field size with one cache memory in an array.</p><p>FIG. 1E illustrates the tag field range and set field size with four cache memories in an array.</p><p>FIG. 2 illustrates the logic implemented by the cache controller of the present invention.</p><p>FIG. 3 is a block diagram illustrating the controller/cache memory of the present invention.</p><p>FIG. 4 is a block diagram of a microcomputer system containing two of the invented cache memories.</p><p>FIG. 5A is a block diagram of a microcomputer system with two of the invented cache memories.</p><p>FIG. 5B illustrates a plurality of waveforms associated with the block diagram of FIG. 5A.</p><p>FIG. 6A is a block diagram of a microcomputer system with four of the invented cache memories.</p><p>FIG. 6B illustrates a plurality of waveforms associated with the block diagram of FIG. 6A.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE PRESENT INVENTION</h4><p>A cache controller/cache memory, fabricated on a single die or chip is described. In the following description, numerous specific details are set forth such as specific binary states, number of bits, etc. in order to provide a thorough understanding of the present invention. It will be obvious to one skilled in the art that the present invention may be practiced without these specific details. In other instances, well known circuits are not described in detail in order not to unnecessarily obscure the present invention.</p><h4>Overview of the Present Invention</h4><p>A cache controller and cache memory fabricated on a single substrate is described. (In the following description, the combination of the controller and cache or cache memory is sometimes referred to simply as the controller/cache memory or the cache memory). In the currently preferred embodiment the controller/cache memory is fabricated employing metal-oxide-semiconductor (MOS) technology, more specifically complementary MOS technology. Any one of a plurality of well-known processes may be used to fabricate the cache memory. In the currently preferred embodiment, each of the controller/cache memories includes a controller and 16 Kbytes of cache memory. Many aspects of the currently preferred embodiment are not described since they are well-known in the prior art and are used in the prior art cache controllers, particularly the Intel 82385 and the cache memory of the Intel 486\u2122.</p><p>In general, the controller/cache memory of the present invention is coupled between the local bus of a microprocessor and a system bus. One, two or four controller/cache identical memories may be used. In the currently preferred embodiment, the number of cache memories in the cache memory array is essentially transparent in the system.</p><p>The information concerning how many cache memories there are and the address range associated with each is distributed among the cache memories themselves. Self-configuration automatically occurs upon activation of the system and, more particularly, at the time the reset signal appears.</p><p>The information concerning the number of cache memories in the system and the relative position of each of them (e.g., whether a particular cache memory is 1 of 1, 1 of 4, 2 of 4, etc.) is determined by each of the cache memories in an array. Each cache memory includes a configuration terminal which is wired differently (external to the cache memory) depending upon the cache memory's position in the array, as will be seen.</p><p>For instance, when the computer system is fabricated, four sockets can be included within the system for a cache array, each for receiving one of the invented cache memories. A user may then place one, two or four cache memories in the system as desired. Each socket is identically wired except for one lead or pin, the \"configuration terminal\". The first cache memory in the array has its configuration terminal coupled to ground, the second to the reset line, the third to the Ready0#line and the fourth to the V<sub>cc</sub> potential. As will be seen, when the system is reset, each of the memories is able to determine its position in the array and the total number of cache memories in the array.</p><p>The size of the tag fields and the range of the set fields of the cache directory change depending on the number of cache memories in the array. In the currently preferred embodiment, two bits (A<sub>12</sub> and A<sub>13</sub>), in effect, shift from being part of the tag field to being part of the set field. These bits are used to enable different ones of the cache memory in the array.</p><h4>Currently Preferred Embodiment of the Cache Controller/Cache Memory</h4><p>As mentioned, each chip or substrate includes both the cache controller and a 16 Kbyte cache memory. The features of the Intel 82385 for the most part are incorporated in the present invention. Additionally, each controller/cache memory can map four gigabytes of main memory into its 16K cache memory such that in a maximum configuration (four controller/cache memories in an array) four gigabytes of main memory are mapped into a 64K cache. The cache memory is unified for code and data. The controller provides a cache consistency mechanism which guarantees that the cache memory has the most recently updated version of the main memory. Consistency support does not impact the performance of the microprocessor coupled to the controller/cache memory. The internal structure of the controller/cache memory in many ways is similar to the controller/cache memory commercially available as part of the Intel 486\u2122 except that the controller/cache memory size is double that of the Intel 486\u2122. For example, the controller/cache memory of the present invention is four-way set associative and employs a pseudo LRU replacement algorithm. The line size is 16 bytes and a full line is fetched from memory for every miss condition. The controller/cache memory's write mechanism employs a write through algorithm enhanced by a four deep write buffer. Cache consistency is provided by the SAHOLD/SEADS# snooping mechanism, similar to that employed in the Intel 486\u2122. In actual performance, the controller/cache memory of the present invention is able to run a zero wait state, 33 mHz, non-pipelined read cycle with the Intel 386\u2122 microprocessor if the data exists in the cache memory. Obviously, if the data does not exist in the cache memory, the performance will depend on the system bus latency. Memory write cycles can run with zero wait states if the write buffer is not filled.</p><p>Referring now to FIG. 3, the portions of the controller/cache memory needed to understand the present invention are illustrated, The cache or cache memory 10--that is, where the data is stored, is shown as memory 10. Four banks of memory are used for the 4-way associative cache. As is typically the case, the data storage comprises a static random access memory, more specifically, where each bit of data is stored in a six transistor bistable cell.</p><p>Data is addressed in the cache memory 10 by the set selector 12. The set selector 12, includes a plurality of set fields (8 bits wide). For each combination of the address bits A<sub>4</sub> through A<sub>11</sub>, the set selector selects data in the four banks of the cache memory 10 and four tag fields in the tag storage 13.</p><p>As is commonly done in cache controllers, the tag field or fields is compared with the incoming address to determine if the data is present in the cache memory 10. Comparator 15 compares the incoming address bits A<sub>12</sub> through A<sub>31</sub> with the four tag fields. The result of this comparison either selects one of the four banks of cache memory as indicated by line 19 coupled to the line selector 11, or a miss is issued as indicated by line 18. The address bits A<sub>2</sub> and A<sub>3</sub> are for double-word selection through selector 14. Data is coupled to (and from) the cache memory on the bus 17.</p><p>As will be described in greater detail, the address bits A<sub>12</sub> and A<sub>13</sub> in effect shift from tag bits to set bits as cache memories are added to the array. More specifically, the bits A<sub>12</sub> and A<sub>13</sub> are used to enable specific ones of the controller/cache memories as indicated by the enable memory circuit 16.</p><p>The control and configuration circuit 20 determines how many controller/cache memories are in the array and the particular memories relative position in the array (e.g., 1 of 1,2 of 4, etc.). The control and configuration circuit 20 receives: a CONF# signal on line/terminal 21, a reset signal on line/terminal 22, a clocking or timing signal on line/terminal 23, and receives and provides a Ready0# signal on line/terminal 24. From these signals, the control and configuration circuit 20 determines whether the particular memory is 1 of 1, 1 of 2, 2 of 2, 1 of 4, 2 of 4, 3 of 4, or 4 of 4 in an array. This information is coupled to the enable memory circuit 16 and as will be discussed, determines how the bits A<sub>12</sub> and A<sub>13</sub> are used. If, by way of example, there are two controller/cache memories in an array, bit A<sub>12</sub> is used to determine which of the two memories is selected while bit A<sub>13</sub> remains part of the tag field and participates in the comparison process. The signals XA<sub>12</sub> and XA<sub>13</sub> on lines 29 and 30 respectively, issue from the circuit 20 and determine whether the comparator considers bits A<sub>12</sub> and/or A<sub>13</sub> in the comparison process. Again, by way of example, if there are four controller/cache memories in an array both bits A<sub>12</sub> and A<sub>13</sub> are ignored as part of the comparison process.</p><p>Also as will be discussed later, when there are more than one controller/cache memory in an array, the first of the memories provides the control signals for the system bus. Thus, if a signal is provided on line 28 indicating that a particular controller/cache memory is \"1 of 1\", the system bus control signal driver 28 is activated, allowing signals to be driven on to the system bus from the \"1 of 1\" controller/cache memory for all the memories in the array.</p><p>The logic implemented by the control and configuration circuit 20 insofar as it involves the present invention is shown in FIG. 2.</p><p>On reset, as will now be described, each of the controller/cache memories determine its relative position in an array and how many memories are in the array (1 of 4, 2 of 4, etc.). As indicated by block 34, when the reset signal is high, circuit 20 senses the potential on terminal 21. If this potential is a first predetermined signal, (in the preferred embodiment, ground potential, that is, CONF# is active) the memory is the primary or first (NO. 1.) memory in an array. (The number of other memories in the array is not known at this time by memory NO. 1.) The sensing of the first predetermined signal is indicated by line 51 in FIG. 2 and the recognition by the memory of its status as NO. 1 in the array by block 35. As indicated by block 37, this first controller/cache memory counts the number of Ready0# signals that occur during the next four clocking signals to determine how many other controller/cache memories are in the array. Specifically, if no Ready0# signals are counted as indicated by line 41, it is the only memory in the array, if one Ready0#signal is sensed there are two memories in the array, and, if two signals are counted there are four memories in the array as indicated by line 43.</p><p>If, on the other hand, on reset when terminal 21 is sensed, a second predetermined signal is found (specifically, 5 volts) the controller/cache memory knows that it is not NO. 1 and proceeds as indicated by line 52 to step 36.</p><p>On the next clock signal after reset, the potential on the configuration terminal is again sensed by the memories except by the NO. 1 memory. As indicated by the block 36, if the CONF# terminal is high (line 49) the circuit provides a Ready0# signal on terminal 24 (block 38) and as indicated by block 44 this memory now counts Ready0# signals (if no longer reacts to the potential on the configuration terminal). The memory knows it is NO. 2 in the array. If no Ready0# signals are received the memory is \"2 of 2\", and if one Ready0# signal is counted, the memory is \"2 of 4\".</p><p>In contrast, at step 36, if the CONF# signal is low (indicated by line 50) the configuration terminal is again sampled after two clock cycles as indicated by block 39. If at this sampling, CONF# is high (line 47) the memory is \"3 of 4\" (block 45). If at step 39 the CONF# signal is low (line 48), the memory provides a signal on a Ready0# signal (block 40) and then knows that it is \"4 of 4\" (block 46).</p><p>The logic illustrated by FIG. 2 is readily implemented using well known circuits and, as mentioned, is part of the control and configuration circuit 20 of FIG. 3.</p><p>Referring to FIGS. 1A and 1 D, if there is only one controller/cache memory in an array, the tag fields consist of address bits A<sub>12</sub> through A<sub>31</sub> and the set fields consists of bits A<sub>4</sub> through A<sub>11</sub>. The address A<sub>4</sub> through All then selects a set (1 of 256 sets).</p><p>Referring to FIG. 1B, if there are two controller/cache memories in an array, the tag field becomes narrower and consists of address bits A<sub>13</sub> through A<sub>31</sub> and, in effect, A<sub>12</sub> is moved to and becomes part of the set field. Specifically, A<sub>12</sub> is used to select one of the two cache memories through the enable memory circuit of FIG. 3. This is equivalent to A<sub>12</sub> being the highest order set bit. Thus, if A<sub>12</sub> is low, the first memory is selected and the set field is 0-255 as indicated by line 42 of FIG. 2. On the other hand, if A<sub>12</sub> is high, the second of the memories is selected and the set field ranges from 256 to 511 as indicated by the \"2 of 2\" line emerging from block 44 of FIG. 2.</p><p>Referring now to FIGS. 1C and 1 E, assume there are four controller/cache memories in an array. For this case, the tag fields consists of bits A<sub>14</sub> through A<sub>31</sub> with the address bits A<sub>12</sub> and A<sub>13</sub> being effectively part of the set fields. These two bits, as indicated by FIG. 3 are used to select one of the four memories in the array. By way of example, if a particular memory knows that it is \"4 or 4\" it communicates this information to the enable memory circuit 16 from the circuit 20 and the enable memory circuit 16 enables the memory when A<sub>12</sub> and A<sub>13</sub> are both high. Similarly, the \"1 or 4\" memory in the array is enabled when both address bits A<sub>12</sub> and A<sub>13</sub> are low, this causes the set field to have the range of 0-255 as indicated by line 43 of FIG. 2. For the second memory in an array of 4 memories, the set field has a range of 256- 511 since this memory is enabled when A<sub>13</sub> is low and A<sub>12</sub> is high. Similarly, the third memory is enabled when A<sub>13</sub> is high and A<sub>12</sub> is low, providing a set field with a range of 512-767; and finally, the fourth memory is enabled when both A<sub>12</sub> and A<sub>13</sub> are high providing a set field range of 768- 1023. In FIG. 1E the \"X's\" at the right end of the tag fields are used to indicate that for the four memory case, the bits A<sub>12</sub> and A<sub>13</sub> are ignored as part of the comparison and have been shifted to and operate as part of the set field.</p><h4>Use of Invented Controller/Cache Memory in Microprocessor Systems</h4><h4>A. Configuration</h4><p>Referring first to FIG. 4, a typical microcomputer system employing one of the invented controller/cache memory 60 is illustrated. The memory 60 is coupled to a local bus 57 and to a system bus 62. A processor 55 (such as the Intel 386\u2122) is coupled to the local bus 57; a coprocessor 56 (such as the Intel 387\u2122) is also coupled to this bus. The system bus 62 is coupled to a main memory 63 such as a DRAM memory. Other peripherals are typically connected to the system bus 62. For the arrangement of FIG. 4, the configuration terminal 21 is coupled to ground as it is for the first (NO. 1) memory in the array (no matter how many others, if any, are in the array). For the arrangement of FIG. 4, the Ready0# terminal 24 and the Ready1# terminal 25 are shown connected together, and connected to the processor and coprocessor. (In subsequent examples, these ready lines are shown not directly connected as will be discussed.) Decoder 65 asserts on line 67 LBA# and/or NPI# whenever an access is made to an address which is used by a local bus device or to an address which requires non-posted accesses. The decoder's programming depends on the specific implementation of the system in which the memory 60 is used. The SKEN# and SWP# signals on lines 66 are provided by decoder 64 for accesses to non-cacheable addresses or to write-protected addresses.</p><p>Importantly, it should be noted that the first memory 60 used in an array has its configuration terminal 21 coupled to ground. Hence, upon reset CONF# will be high as indicated by line 51 of FIG. 2, informing the memory 60 that it is the first in the array. As previously mentioned, a signal on line 28 of FIG. 3 causes driver 28 memory NO. 1 to provide control signals for the bus 62. During the next few clock cycles for the arrangement of FIG. 4, no ready signals will be sensed on line 24 and thus, the conditions represented by line 41 of FIG. 2 are met; that is, memory 60 is the only cache memory in the array.</p><p>In FIG. 5A, a computer system is illustrated with includes two controller/cache memories identified as memories 60a (NO.1) and 60b (NO.2). The only difference between these memories' coupling to the system is in their configuration terminal connections. Note the configuration terminal 21a of memory 60a is again coupled to ground, while the configuration terminal 21b of memory 60b is coupled to the reset line. Otherwise, both memories are coupled in the same manner to the buses and lines in the system. For example, both memories receive the reset signal on their reset terminal as well as the clocking signal (not illustrated). The Ready0# terminals of both memories are coupled to logic circuit 68. This circuit is an ordinary OR gate which receives other inputs such as on line 69 to allow a logical ORing of other ready signals to the processor and coprocessor (from devices other than the array). The Ready1# signal, the output of the logic circuit 68, is coupled to the line/terminals 25.</p><p>As will be seen, the fact that the configuration terminal of the second memory is coupled to the reset line allows the second memory to determine its place in the array. In FIG. 5B, the clocking signal 74 is shown which, as mentioned, is applied to both memories. Also, the reset signal 75 is shown which is coupled to the reset terminal of both memories and the configuration terminal of memory 60b. During reset when the reset signal is high, the control circuits of both memories 60a and 60b sense the signal on their respective configuration terminals as represented by block 34 of FIG. 2. Memory 60a senses the potential on line 21a which is ground potential. This is indicated by the arrow 72. The complement of this signal (CONF#) is high as indicated by line 51 in FIG. 2 alerting memory 60a  to its status as the primary (NO. 1) memory in the array. Memory 60b, on the other hand, at this time (reset still active) senses a high potential on its configuration terminal as shown by arrow 71. Accordingly, memory 60b determines that it is not NO. 1 in the array. After the reset signal become inactive, and under control of the clocking signals as indicated by line 73, memory 60b again senses the potential on its configuration terminal. This time it finds the potential low since the reset signal has dropped in potential. The complement of this low signal is shown by line 49 in FIG. 2. Memory 60b then provides a signal on line 24, this is shown as waveform 76 in FIG. 5B and is represented by block 38 of FIG. 2. (In the current implementation, two clock cycles occur before waveform 76 is provided). The waveform 76 is sensed by memory 60a on line 24. Memory 60a having counted one count (there will only be one ready signal in the first few clocking cycles since there are no other memories in the array) determines that there are two memories in the array as indicated by line 42 of FIG. 2. Similarly, since there are no additional ready signals, the NO. 2 memory determines that it is \"2of 2\" in the array.</p><p>Referring now to FIG. 6A, a computer system is again shown, however this time with four controller/cache memories 60a, 60b, 60c and 60d in an array. Each of the memories is coupled to both the local bus and the system bus as in the previous examples. The memories receive the Ready1# signal, the reset signal on their reset terminal and clock signal on their clocking terminal (the latter two terminals are not illustrated in this figure). The only difference between the memories insofar as their coupling in the system of FIG. 6A is concerned, is that the configuration terminal of 21a of memory 60a is coupled to ground, the configuration terminal 21b of memory 60b is coupled to the reset line, the configuration 21c of memory 60c is coupled to the Ready0# line and finally, the configuration terminal 21d of memory 60d is coupled to the V<sub>cc</sub> potential (5 Volts).</p><p>The waveforms in 6B, in conjunction with the logic diagram of FIG. 2, illustrates the initialization occuring on reset for the system of FIG. 6A.</p><p>When the reset signal is high, as previously indicated by arrows 71 and 72, memories 60a and 60b sense their configuration terminal. During this time, memory 60d senses the waveform 80 as indicated by arrow 78, a high potential (Ready0# is high at this time). Thus, memory 60c proceeds to step or block 36 of FIG. 2. Likewise memory 60c, as indicated by arrow 79 and waveform 81 senses a positive potential, the complement of which is low; memory 60c hence is logically at block 36. At the time indicated by the arrow 73, both memories 60c and 60d again sense their configuration terminal. There is no change in the potential for waveforms 80 and 81 at the time represented by arrow 73 and accordingly, the logic associated with these memories proceeds to block 39 of FIG. 2. After two clock cycles as indicated by arrow 82, waveform 80 drops in potential because memory 60b has issued a Ready0# signal (waveform 76). Thus, memory 60c determines that it is \"3 of 4\"  as indicated by line 47 of FIG. 2. Then memory 60d issues a Ready0# signal (waveform 77) thereby informing memories 60a and 60b that there are four memories in the array. Since the configuration terminal of memory 60d is always high (CONF# low) this memory knows that it is \"4 or 4\" in the array.</p><h4>B. Bus Driving</h4><p>On the local bus 57, the Ready0# signal is the only signal driven by all of the cache memories. Nominally, the Ready0# line 24 is not driven, rather a pull-up device external to the memories is used to maintain this line at V<sub>cc</sub>. Typically, a resistor couples this line to V<sub>cc</sub>. During cacheable read cycles, the selected memory drives Ready0# active until Ready1# (line 25) is sense active, then the selected memory drives Ready0# inactive for one clock phase; line 25 is then released by the memory and allowed to be pulled up by the external pull-up device. In other cycles, the primary (NO. 1 memory) drives Ready0# in the same manner. On the data bus, the selected memory drives the data bus during the \"T2\" portion of the read cycle, thereby ensuring no contention with the processor when a read cycle follows the write cycle.</p><p>On the system bus 62 as mentioned, the primary memory drives all the system bus signals except the SADS#. Thus, the possibility of contention exists only for the SADS# signal. The SADS# line is nominally not driven by any of the memories, but rather left floating with the line carrying this signal coupled to a pull-up device. All the memories in the array, including the primary, after driving the SADS# line active, drive it inactive for one clock phase then allow it to float. During line fills, the SADS# line signal is driven by the memory which detects the miss. In all other cycles, including write cycles, the SADS# line is driven by the primary memory.</p><p>Thus, by the simple connection to the configuration terminal to the various signals available in the computer system, each of the four controller/cache memories determines how many memories are in the array of memories and its relative position in the array. Moreover, each of the memories adjusts its tag field and set fields in a manner totally transparent to the computer system to provide additional cache memory.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Eran", "last_name": "Yarkoni", "name": ""}, {"first_name": "Nabeel", "last_name": "Sakran", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTEL CORPORATION"}], "ipc_classes": [{"primary": true, "label": "G06F  13/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMJP"}, {"label": "G06F  12/06        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711118"}, {"primary": false, "label": "711E12088"}, {"primary": false, "label": "711E12041"}], "ecla_classes": [{"label": "S06F212:601"}, {"label": "G06F  12/06K4P"}, {"label": "G06F  12/08B22"}], "cpc_classes": [{"label": "G06F2212/601"}, {"label": "G06F  12/0893"}, {"label": "G06F  12/0893"}, {"label": "G06F2212/601"}, {"label": "G06F  12/0676"}, {"label": "G06F  12/0676"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1990-06-07", "application_date": "1993-07-19", "family_members": [{"ucid": "US-5448711-A", "titles": [{"lang": "EN", "text": "Configuration apparatus for determining relative position of a cache memory in a cache memory array"}]}, {"ucid": "JP-H05108484-A", "titles": [{"lang": "EN", "text": "CACHE MEMORY"}, {"lang": "JA", "text": "\u30ad\u30e4\u30c4\u30b7\u30e6\u30e1\u30e2\u30ea"}]}, {"ucid": "US-5414828-A", "titles": [{"lang": "EN", "text": "Apparatus for configuring relative position of a cache memory in a cache memory array"}]}, {"ucid": "US-5418928-A", "titles": [{"lang": "EN", "text": "Apparatus for configuring relative of a cache memory in a cache memory array"}]}]}