{"patent_number": "US-6507862-B1", "publication_id": 73281010, "family_id": 23199454, "publication_date": "2003-01-14", "titles": [{"lang": "EN", "text": "Switching method in a multi-threaded processor"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50435403\"><p>A processor includes logic for attaining a very fast exception handling functionality while executing non-threaded programs by invoking a multithreaded-type functionality in response to an exception condition. The processor, while operating in multithreaded conditions or while executing non-threaded programs, progresses through multiple machine states during execution. The very fast exception handling logic includes connection of an exception signal line to thread select logic, causing an exception signal to evoke a switch in thread and machine state. The switch in thread and machine state causes the processor to enter and to exit the exception handler immediately, without waiting to drain the pipeline or queues and without the inherent timing penalty of the operating system's software saving and restoring of registers.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00001\" num=\"1\"><claim-text>1. A method of operating a processor comprising:</claim-text><claim-text>running one or more program applications concurrently; </claim-text><claim-text>executing a plurality of execution threads in a multiple-thread pipeline including a plurality of multiple-bit flip-flops that hold the plurality of execution threads, the execution threads for executing issued instructions for the program applications; </claim-text><claim-text>switching the execution threads in the multiple-thread pipeline including: </claim-text><claim-text>freezing an active state in the pipeline; </claim-text><claim-text>activating a previously idle thread in the pipeline while holding the state of the newly frozen thread in the pipeline; and </claim-text><claim-text>subsequently resuming execution of the frozen thread at the precise state of the frozen thread immediately prior to the thread switch; </claim-text><claim-text>wherein the multiple-thread pipeline includes a plurality of pulse-based high-speed flip-flops, the pulse-based high-speed flip-flops having a latch structure coupled to a plurality of select-bus lines, the select-bus lines selecting an active thread from among the plurality of execution threads. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00002\" num=\"2\"><claim-text>2. A method according to <claim-ref idref=\"US-6507862-B1-CLM-00001\">claim 1</claim-ref> further comprising:</claim-text><claim-text>detecting a cache miss; </claim-text><claim-text>generating a cache miss stall signal in response to the cache miss stall; and </claim-text><claim-text>freezing an active state in the pipeline in response to the cache miss stall signal. </claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00003\" num=\"3\"><claim-text>3. A method according to <claim-ref idref=\"US-6507862-B1-CLM-00001\">claim 1</claim-ref> further comprising:</claim-text><claim-text>issuing instructions for the program applications in-order. </claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00004\" num=\"4\"><claim-text>4. A method according to <claim-ref idref=\"US-6507862-B1-CLM-00001\">claim 1</claim-ref> further comprising:</claim-text><claim-text>issuing instructions for the program applications in-order; and </claim-text><claim-text>managing a machine state of the individual execution threads separately and independently. </claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00005\" num=\"5\"><claim-text>5. A method according to <claim-ref idref=\"US-6507862-B1-CLM-00001\">claim 1</claim-ref> further comprising:</claim-text><claim-text>loading data from a storage and storing data to a storage via a plurality of load/store units that are individually allocated to individual threads in the multiple-thread pipeline. </claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00006\" num=\"6\"><claim-text>6. A method according to <claim-ref idref=\"US-6507862-B1-CLM-00001\">claim 1</claim-ref> further comprising:</claim-text><claim-text>concurrently executing a plurality of execution threads in a plurality of multiple-thread pipelines so that the processor executes the one or more program applications with vertical threading and horizontal threading. </claim-text></claim>"}, {"num": 7, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00007\" num=\"7\"><claim-text>7. A method of operating a processor comprising:</claim-text><claim-text>running one or more program applications concurrently; </claim-text><claim-text>executing a plurality of execution threads in a multiple-thread pipeline including a plurality of multiple-bit flip-flops that hold the plurality of execution threads, the execution threads for executing issued instructions for the program applications, the executing operation including: </claim-text><claim-text>holding a plurality of threads in the multiple-thread pipeline simultaneously including an active thread and one or more inactive threads; </claim-text><claim-text>receiving notification of a stall condition; </claim-text><claim-text>in response to receipt of the stall condition, stalling the active thread immediately including immediately deactivating a currently active thread and activating a currently inactive thread while the state of the threads in the multiple-thread pipeline remains the same; </claim-text><claim-text>wherein executing a plurality of execution threads in a multiple-thread pipeline includes: </claim-text><claim-text>latching data in pulse-based high-speed flip-flops; and </claim-text><claim-text>selecting an active thread from among the plurality of execution threads using select-bus lines. </claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00008\" num=\"8\"><claim-text>8. A method according to <claim-ref idref=\"US-6507862-B1-CLM-00007\">claim 7</claim-ref> further comprising:</claim-text><claim-text>detecting a cache miss; </claim-text><claim-text>generating a cache miss stall signal in response to the cache miss stall; and </claim-text><claim-text>freezing an active state in the pipeline in response to the cache miss stall signal. </claim-text></claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00009\" num=\"9\"><claim-text>9. A method according to <claim-ref idref=\"US-6507862-B1-CLM-00007\">claim 7</claim-ref> further comprising:</claim-text><claim-text>issuing instructions for the program applications in-order. </claim-text></claim>"}, {"num": 10, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00010\" num=\"10\"><claim-text>10. A method according to <claim-ref idref=\"US-6507862-B1-CLM-00007\">claim 7</claim-ref> further comprising:</claim-text><claim-text>issuing instructions for the program applications in-order; and </claim-text><claim-text>managing a machine state of the individual execution threads separately and independently. </claim-text></claim>"}, {"num": 11, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00011\" num=\"11\"><claim-text>11. A method according to <claim-ref idref=\"US-6507862-B1-CLM-00007\">claim 7</claim-ref> further comprising:</claim-text><claim-text>loading data from a storage and storing data to a storage via a plurality of load/store units that are individually allocated to individual threads in the multiple-thread pipeline. </claim-text></claim>"}, {"num": 12, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00012\" num=\"12\"><claim-text>12. A method according to <claim-ref idref=\"US-6507862-B1-CLM-00007\">claim 7</claim-ref> further comprising:</claim-text><claim-text>concurrently executing a plurality of execution threads in a plurality of multiple-thread pipelines so that the processor executes the one or more program applications with vertical threading and horizontal threading. </claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00013\" num=\"13\"><claim-text>13. A processor comprising:</claim-text><claim-text>means for running one or more program applications concurrently; </claim-text><claim-text>means for executing a plurality of execution threads in a multiple-thread pipeline including a plurality of multiple-bit flip-flops that hold the plurality of execution threads, the execution threads for executing issued instructions for the program applications, the executing operation including: </claim-text><claim-text>means for holding a plurality of threads in the multiple-thread pipeline simultaneously including an active thread and one or more inactive threads; </claim-text><claim-text>means for receiving notification of a stall condition; </claim-text><claim-text>means responsive to receipt of the stall condition for stalling the active thread immediately including: </claim-text><claim-text>immediately deactivating a currently active thread and activating a currently inactive thread while the state of the threads in the multiple-thread pipeline remains the same; and </claim-text><claim-text>means for loading data from a storage and storing data to a storage via a plurality of load/store units that are individually allocated to individual threads in the multiple-thread pipeline. </claim-text></claim>"}, {"num": 14, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00014\" num=\"14\"><claim-text>14. A processor comprising:</claim-text><claim-text>means for running one or more program applications concurrently; </claim-text><claim-text>means for executing a plurality of execution threads in a multiple-thread pipeline including a plurality of multiple-bit flip-flops that hold the plurality of execution threads, the execution threads for executing issued instructions for the program applications; </claim-text><claim-text>means for switching the execution threads in the multiple-thread pipeline including: </claim-text><claim-text>means for freezing an active state in the pipeline; </claim-text><claim-text>means for activating a previously idle thread in the pipeline while holding the state of the newly frozen thread in the pipeline; </claim-text><claim-text>means for subsequently resuming execution of the frozen thread at the precise state of the frozen thread immediately prior to the thread switch; and </claim-text><claim-text>means for loading data from a storage and storing data to a storage via a plurality of load/store units that are individually allocated to individual threads in the multiple-thread pipeline. </claim-text></claim>"}, {"num": 15, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00015\" num=\"15\"><claim-text>15. A method of operating a processor comprising:</claim-text><claim-text>selecting a thread from among a plurality of execution threads, other threads being nonselected threads; </claim-text><claim-text>activating a machine state for the selected execution thread; </claim-text><claim-text>executing the selected execution thread in a shared pipeline; </claim-text><claim-text>freezing nonselected threads in the shared pipeline without executing; </claim-text><claim-text>allocating a load/store unit to individual threads of the plurality of execution threads; and </claim-text><claim-text>accessing the allocated load/store units according to the executing thread. </claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00016\" num=\"16\"><claim-text>16. A method according to <claim-ref idref=\"US-6507862-B1-CLM-00015\">claim 15</claim-ref> further comprising:</claim-text><claim-text>sharing a data storage unit among the plurality of execution threads. </claim-text></claim>"}, {"num": 17, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00017\" num=\"17\"><claim-text>17. A method according to <claim-ref idref=\"US-6507862-B1-CLM-00015\">claim 15</claim-ref> further comprising:</claim-text><claim-text>sharing an instruction control logic among the plurality of execution threads. </claim-text></claim>"}, {"num": 18, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6507862-B1-CLM-00018\" num=\"18\"><claim-text>18. A method according to <claim-ref idref=\"US-6507862-B1-CLM-00015\">claim 15</claim-ref> further comprising:</claim-text><claim-text>sharing an external cache control unit among the plurality of execution threads.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53860824\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><h4>CROSS-REFERENCE</h4><p>The present invention is related to subject matter disclosed in the following cop-ending patent applications:</p><p>1. U.S. patent application Ser. No. 09/309,732 entitled \u201cProcessor with Multiple-Thread, Vertically-Threaded Pipeline\u201d naming William Joy, Marc Tremblay, Gary Lauterbach, and Joseph Chamdani as inventors and filed on even date herewith;</p><p>2. U.S. patent application Ser. No. 09/309,731, now U.S. Pat. No. 6,351,808, entitled \u201cVertically-Threaded Processor with Multi-Dimensional Storage\u201d naming William Joy, Marc Tremblay, Gary Lauterbach, and Joseph Chamdani as inventors and filed on even date herewith;</p><p>3. U.S. patent application Ser. No. 09/309,730 entitled \u201cMulti-Threaded Processor By Multiple-Bit Flip-Flop Global Substitution\u201d naming William Joy, Marc Tremblay, Gary Lauterbach, and Joseph Chamdani as inventors and filed on even date herewith;</p><p>4. U.S. patent application Ser. No. 09/309,734 entitled \u201cMultiple-Thread Processor with Single-Thread Interface Shared among Threads\u201d naming William Joy, Marc Tremblay, Gary Lauterbach, and Joseph Chamdani as inventors and filed on even date herewith; and</p><p>5. U.S. patent application Ser. No. 09/309,733, now U.S. Pat. No. 6,341,347, entitled \u201cThread Switch Logic in a Multiple-Thread Processor\u201d naming William Joy, Marc Tremblay, Gary Lauterbach, and Joseph Chamdani as inventors and filed on even date herewith.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates to processor or computer architecture. More specifically, the present invention relates to multiple-threading processor architectures and methods of operation and execution.</p><p>2. Description of the Related Art</p><p>In many commercial computing applications, a large percentage of time elapses during pipeline stalling and idling, rather than in productive execution, due to cache misses and latency in accessing external caches or external memory following the cache misses. Stalling and idling are most detrimental, due to frequent cache misses, in database handling operations such as OLTP, DSS, data mining, financial forecasting, mechanical and electronic computer-aided design (MCAD/ECAD), web servers, data servers, and the like. Thus, although a processor may execute at high speed, much time is wasted while idly awaiting data.</p><p>One technique for reducing stalling and idling is hardware multithreading to achieve processor execution during otherwise idle cycles. Hardware multithreading involves replication of some processor resources, for example replication of architected registers, for each thread. Replication is not required for most processor resources, including instruction and data caches, translation look-aside buffers (TLB), instruction fetch and dispatch elements, branch units, execution units, and the like.</p><p>Unfortunately duplication of resources is costly in terms of integrated circuit consumption and performance.</p><p>Accordingly, improved multithreading circuits and operating methods are needed that are economical in resources and avoid costly overhead which reduces processor performance.</p><h4>SUMMARY OF THE INVENTION</h4><p>A processor reduces wasted cycle time resulting from stalling and idling, and increases the proportion of execution time, by supporting and implementing both vertical multithreading and horizontal multithreading. Vertical multithreading permits overlapping or \u201chiding\u201d of cache miss wait times. In vertical multithreading, multiple hardware threads share the same processor pipeline. A hardware thread is typically a process, a lightweight process, a native thread, or the like in an operating system that supports multithreading. Horizontal multithreading increases parallelism within the processor circuit structure, for example within a single integrated circuit die that makes up a single-chip processor. To further increase system parallelism in some processor embodiments, multiple processor cores are formed in a single die. Advances in on-chip multiprocessor horizontal threading are gained as processor core sizes are reduced through technological advancements.</p><p>The described processor structure and operating method may be implemented in many structural variations. For example two processor cores are combined with an on-chip set-associative L2 cache in one system. In another example, four processor cores are combined with a direct RAMBUS interface with no external L2 cache. A countless number of variations are possible. In some systems, each processor core is a vertically-threaded pipeline.</p><p>In a further aspect of some multithreading system and method embodiments, a computing system may be configured in many different processor variations that allocate execution among a plurality of execution threads. For example, in a \u201c1C2T\u201d configuration, a single processor die includes two vertical threads. In a \u201c4C4T\u201d configuration, a four-processor multiprocessor is formed on a single die with each of the four processors being four-way vertically threaded. Countless other \u201cnCkT\u201d structures and combinations may be implemented on one or more integrated circuit dies depending on the fabrication process employed and the applications envisioned for the processor. Various systems may include caches that are selectively configured, for example as segregated L1 caches and segregated L2 caches, or segregated L1 caches and shared L2 caches, or shared L1 caches and shared L2 caches.</p><p>In an aspect of some multithreading system and method embodiments, in response to a cache miss stall a processor freezes the entire pipeline state of an executing thread. The processor executes instructions and manages the machine state of each thread separately and independently. The functional properties of an independent thread state are stored throughout the pipeline extending to the pipeline registers to enable the processor to postpone execution of a stalling thread, relinquish the pipeline to a previously idle thread, later resuming execution of the postponed stalling thread at the precise state of the stalling thread immediately prior to the thread switch.</p><p>In another aspect of some multithreading system and method embodiments, a processor include a \u201cfour-dimensional\u201d register structure in which register file structures are replicated by N for vertical threading in combination with a three-dimensional storage circuit. The multi-dimensional storage is formed by constructing a storage, such as a register file or memory, as a plurality of two-dimensional storage planes.</p><p>In another aspect of some multithreading system and method embodiments, a processor implements N-bit flip-flop global substitution. To implement multiple machine states, the processor converts 1-bit flip-flops in storage cells of the stalling vertical thread to an N-bit global flip-flop where N is the number of vertical threads.</p><p>In one aspect of some processor and processing method embodiments, the processor improves throughput efficiency and exploits increased parallelism by introducing multithreading to an existing and mature processor core. The multithreading is implemented in two steps including vertical multithreading and horizontal multithreading. The processor core is retrofitted to support multiple machine states. System embodiments that exploit retrofitting of an existing processor core advantageously leverage hundreds of man-years of hardware and software development by extending the lifetime of a proven processor pipeline generation.</p><p>In another aspect of some multithreading system and method embodiments, a processor includes logic for tagging a thread identifier (TID) for usage with processor blocks that are not stalled. Pertinent non-stalling blocks include caches, translation look-aside buffers (TLB), a load buffer asynchronous interface, an external memory management unit (MMU) interface, and others.</p><p>In a further aspect of some multithreading system and method embodiments, a processor includes a cache that is segregated into a plurality of N cache parts. Cache segregation avoids interference, \u201cpollution\u201d, or \u201ccross-talk\u201d between threads. One technique for cache segregation utilizes logic for storing and communicating thread identification (TID) bits. The cache utilizes cache indexing logic. For example, the TID bits can be inserted at the most significant bits of the cache index.</p><p>In another aspect of some multithreading system and method embodiments, a processor includes a thread switching control logic that performs a fast thread-switching operation in response to an L1 cache miss stall. The fast thread-switching operation implements one or more of several thread-switching methods. A first thread-switching operation is \u201coblivious\u201d thread-switching for every N cycle in which the individual flip-flops locally determine a thread-switch without notification of stalling. The oblivious technique avoids usage of an extra global interconnection between threads for thread selection. A second thread-switching operation is \u201csemi-oblivious\u201d thread-switching for use with an existing \u201cpipeline stall\u201d signal (if any). The pipeline stall signal operates in two capacities, first as a notification of a pipeline stall, and second as a thread select signal between threads so that, again, usage of an extra global interconnection between threads for thread selection is avoided. A third thread-switching operation is an \u201cintelligent global scheduler\u201d thread-switching in which a thread switch decision is based on a plurality of signals including: (1) an L1 data cache miss stall signal, (2) an instruction buffer empty signal, (3) an L2 cache miss signal, (4) a thread priority signal, (5) a thread timer signal, (6) an interrupt signal, or other sources of triggering. In some embodiments, the thread select signal is broadcast as fast as possible, similar to a clock tree distribution. In some systems, a processor derives a thread select signal that is applied to the flip-flops by overloading a scan enable (SE) signal of a scannable flip-flop.</p><p>In an additional aspect of some multithreading system and method embodiments, a processor includes anti-aliasing logic coupled to an L1 cache so that the L1 cache is shared among threads via anti-aliasing. The L1 cache is a virtually-indexed, physically-tagged cache that is shared among threads. The anti-aliasing logic avoids hazards that result from multiple virtual addresses mapping to one physical address. The anti-aliasing logic selectively invalidates or updates duplicate L1 cache entries.</p><p>In another aspect of some multithreading system and method embodiments, a processor includes logic for attaining a very fast exception handling functionality while executing non-threaded programs by invoking a multithreaded-type functionality in response to an exception condition. The processor, while operating in multithreaded conditions or while executing non-threaded programs, progresses through multiple machine states during execution. The very fast exception handling logic includes connection of an exception signal line to thread select logic, causing an exception signal to evoke a switch in thread and machine state. The switch in thread and machine state causes the processor to enter and to exit the exception handler immediately, without waiting to drain the pipeline or queues and without the inherent timing penalty of the operating system's software saving and restoring of registers.</p><p>An additional aspect of some multithreading systems and methods is a thread reservation system or thread locking system in which a thread pathway is reserved for usage by a selected thread. A thread control logic may select a particular thread that is to execute with priority in comparison to other threads. A high priority thread may be associated with an operation with strict time constraints, an operation that is frequently and predominantly executed in comparison to other threads. The thread control logic controls thread-switching operation so that a particular hardware thread is reserved for usage by the selected thread.</p><p>In another aspect of some multithreading system and method embodiments, a processor includes logic supporting lightweight processes and native threads. The logic includes a block that disables thread ID tagging and disables cache segregation since lightweight processes and native threads share the same virtual tag space.</p><p>In a further additional aspect of some embodiments of the multithreading system and method, some processors include a thread reservation functionality.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>The features of the described embodiments are specifically set forth in the appended claims. However, embodiments of the invention relating to both structure and method of operation, may best be understood by referring to the following description and accompanying drawings.</p><p>FIGS. 1A and 1B are timing diagrams respectively illustrating execution flow of a single-thread processor and a vertical multithread processor.</p><p>FIGS. 2A, <b>2</b>B, and <b>2</b>C are timing diagrams respectively illustrating execution flow of a single-thread processor, a vertical multithread processor, and a vertical and horizontal multithread processor.</p><p>FIG. 3 is a schematic functional block diagram depicting a design configuration for a single-processor vertically-threaded processor that is suitable for implementing various multithreading techniques and system implementations that improve multithreading performance and functionality.</p><p>FIGS. 4A, <b>4</b>B, and <b>4</b>C are diagrams showing an embodiment of a pulse-based high-speed flip-flop that is advantageously used to attain multithreading in an integrated circuit. FIG. 4A is a schematic block diagram illustrating control and storage blocks of a circuit employing high-speed multiple-bit flip-flops. FIG. 4B is a schematic circuit diagram that shows a multiple-bit bistable multivibrator (flip-flop) circuit. FIG. 4C is a timing diagram illustrating timing of the multiple-bit flip-flop.</p><p>FIG. 5 is a schematic block diagram illustrating an N-bit \u201cthread selectable\u201d flip-flop substitution logic that is used to create vertically multithreaded functionality in a processor pipeline while maintaining the same circuit size as a single-threaded pipeline.</p><p>FIG. 6 is a schematic block diagram illustrating a thread switch logic which rapidly generates a thread identifier (TID) signal identifying an active thread of a plurality of threads.</p><p>FIGS. 7A and 7B are, respectively, a schematic block diagram showing an example of a segregated cache and a pictorial diagram showing an example of an addressing technique for the segregated cache.</p><p>FIG. 8 is a schematic block diagram showing a suitable anti-aliasing logic for usage in various processor implementations including a cache, such as an L1 cache, and L2 cache, or others.</p><p>FIG. 9 is a schematic functional block diagram depicting a design configuration for a single-chip dual-processor vertically-threaded processor that is suitable for implementing various multithreading techniques and system implementations that improve multithreading performance and functionality.</p><p>FIG. 10 is a schematic functional block diagram depicting an alternative design configuration for a single-processor vertically-threaded processor that is suitable for implementing various multithreading techniques and system implementations that improve multithreading performance and functionality.</p><p>FIG. 11 is a schematic functional block diagram depicting an alternative design configuration for a single-chip dual-processor vertically-threaded processor that is suitable for implementing various multithreading techniques and system implementations that improve multithreading performance and functionality.</p><p>FIG. 12 is a schematic block diagram illustrating a processor and processor architecture that are suitable for implementing various multithreading techniques and system implementations that improve multithreading performance and functionality.</p><p>FIG. 13 is a schematic perspective diagram showing a multi-dimensional register file.</p><p>FIG. 14 is a schematic circuit diagram showing a conventional implementation of register windows.</p><p>FIG. 15 is a schematic circuit diagram showing a plurality of bit cells of a register windows of the multi-dimensional register file that avoids waste of integrated circuit area by exploiting the condition that only one window is read and only one window is written at one time.</p><p>FIGS. 16A and 16B are, schematic circuit diagram illustrates a suitable bit storage circuit storing one bit of the local registers for the multi-dimensional register file with eight windows.</p><p>FIGS. 17A and 17B are, respectively, a schematic pictorial diagram and a schematic block diagram illustrating sharing of registers among adjacent windows.</p><p>FIGS. 18A, <b>18</b>B, <b>18</b>C and <b>18</b>D are a schematic circuit diagram illustrating an implementation of a multi-dimensional register file for registers shared across a plurality of windows.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>The use of the same reference symbols in different drawings indicates similar or identical items.</p><h4>DESCRIPTION OF THE EMBODIMENT(S)</h4><p>Referring to FIGS. 1A and 1B, two timing diagrams respectively illustrate execution flow <b>110</b> in a single-thread processor and instruction flow <b>120</b> in a vertical multithread processor. Processing applications such as database applications spend a significant portion of execution time stalled awaiting memory servicing. FIG. 1A is a highly schematic timing diagram showing execution flow <b>110</b> of a single-thread processor executing a database application. In an illustrative example, the single-thread processor is a four-way superscalar processor. Shaded areas <b>112</b> correspond to periods of execution in which the single-thread processor core issues instructions. Blank areas <b>114</b> correspond to time periods in which the single-thread processor core is stalled waiting for data or instructions from memory or an external cache. A typical single-thread processor executing a typical database application executes instructions about 30% of the time with the remaining 70% of the time elapsed in a stalled condition. The 30% utilization rate exemplifies the inefficient usage of resources by a single-thread processor.</p><p>FIG. 1B is a highly schematic timing diagram showing execution flow <b>120</b> of similar database operations by a multithread processor. Applications such as database applications have a large amount inherent parallelism due to the heavy throughput orientation of database applications and the common database functionality of processing several independent transactions at one time. The basic concept of exploiting multithread functionality involves utilizing processor resources efficiently when a thread is stalled by executing other threads while the stalled thread remains stalled. The execution flow <b>120</b> depicts a first thread <b>122</b>, a second thread <b>124</b>, a third thread <b>126</b> and a fourth thread <b>128</b>, all of which are shown with shading in the timing diagram. As one thread stalls, for example first thread <b>122</b>, another thread, such as second thread <b>124</b>, switches into execution on the otherwise unused or idle pipeline. Blank areas <b>130</b> correspond to idle times when all threads are stalled. Overall processor utilization is significantly improved by multithreading. The illustrative technique of multithreading employs replication of architected registers for each thread and is called \u201cvertical multithreading\u201d.</p><p>Vertical multithreading is advantageous in processing applications in which frequent cache misses result in heavy clock penalties. When cache misses cause a first thread to stall, vertical multithreading permits a second thread to execute when the processor would otherwise remain idle. The second thread thus takes over execution of the pipeline. A context switch from the first thread to the second thread involves saving the useful states of the first thread and assigning new states to the second thread. When the first thread restarts after stalling, the saved states are returned and the first thread proceeds in execution. Vertical multithreading imposes costs on a processor in resources used for saving and restoring thread states.</p><p>Referring to FIGS. 2A, <b>2</b>B, and <b>2</b>C, three highly schematic timing diagrams respectively illustrate execution flow <b>210</b> of a single-thread processor, execution flow <b>230</b> of a vertical multithread processor, and execution flow <b>250</b> a combined vertical and horizontal multithread processor. In FIG. 2A, shaded areas <b>212</b> showing periods of execution and blank areas <b>214</b> showing time periods in which the single-thread processor core is idle due to stall illustrate the inefficiency of a single-thread processor.</p><p>In FIG. 2B, execution flow <b>230</b> in a vertical threaded processor includes execution of a first thread <b>232</b>, and a second thread <b>234</b>, both shaded in the timing diagram, and an idle time shown in a blank area <b>240</b>. Efficient instruction execute proceeds as one thread stalls and, in response to the stall, another thread switches into execution on the otherwise unused or idle pipeline. In the blank areas <b>240</b>, an idle time occurs when all threads are stalled. For vertical multithread processor maintains a separate processing state for T executing threads. Only one of the threads is active at one time. The vertical multithreaded processor switches execution to another thread on a cache miss, for example an L1 cache miss.</p><p>A horizontal threaded processor, using a technique called chip-multiple processing, combines multiple processors on a single integrated circuit die. The multiple processors are vertically threaded to form a processor with both vertical and horizontal threading, augmenting executing efficiency and decreasing latency in a multiplicative fashion. In FIG. 2C execution flow <b>250</b> in a vertical and horizontal threaded processor includes execution of a first thread <b>252</b> executing on a first processor, a second thread <b>254</b> executing on the first processor, a first thread <b>256</b> executing on a second processor and a second thread <b>258</b> executing on the second processor. An idle time is shown in a blank area <b>260</b> for both the first and second processors. Execution of the first thread <b>252</b> and the second thread <b>254</b> on the first processor illustrate vertical threading. Similarly, execution of the first thread <b>256</b> and the second thread <b>258</b> on the second processor illustrate vertical threading. In the illustrative embodiment, a single integrated circuit includes both the first processor and the second processor, the multiple processors executing in parallel so that the multithreading operation is a horizontal multiple-threading or integrated-circuit chip multiprocessing (CMP) in combination with the vertical multithreading of the first processor and the second processor. The combination of vertical multithreading and horizontal multithreading increases processor parallelism and performance, and attains an execution efficiency that exceeds the efficiency of a processor with only vertical multithreading. The combination of vertical multithreading and horizontal multithreading also advantageously reduces communication latency among local (on-chip) multi-processor tasks by eliminating much signaling on high-latency communication lines between integrated circuit chips. Horizontal multithreading further advantageously exploits processor speed and power improvements that inherently result from reduced circuit sizes in the evolution of silicon processing.</p><p>For each vertical threaded processor, efficient instruction execute proceeds as one thread stalls and, in response to the stall, another thread switches into execution on the otherwise unused or idle pipeline. In the blank areas <b>260</b>, an idle time occurs when all threads are stalled.</p><p>Vertical multithreading is advantageously used to overcome or hide cache miss stalls, thereby continuing execution of the processor despite stalls. Vertical multithreading thus improves performance in commercial multiprocessor and multithreading applications. Vertical multithreading advantageously accelerates context switching time from millisecond ranges to nanosecond ranges. Vertical multithreading is highly advantageous in all processing environments including embedded, desktop, and server applications, and the like.</p><p>Horizontal multithreading or circuit chip multiprocessing further increases on-chip parallelism by exploiting increasingly smaller processor core sizes.</p><p>Although the illustrative example shows execution of two concurrent vertical multithreading processors with each concurrent vertical multithreading processor executing two threads, in other examples various numbers of concurrently executing processors may execute various numbers of threads. The number of threads that execute on one processor may be the same or different from the number of threads executing concurrently and in parallel on another processor.</p><p>In some processor designs, vertical and horizontal multithreading is incorporated into the fundamental design of the processors, advantageously creating modular and flexible structures that promote scalability of design. In other processor designs, multithreading is incorporated into existing and mature processor designs to leverage existing technological bases and increasing performance of multiprocessing and multithreading applications. One highly suitable example of processor design for retrofitting with multithreading functionality is an UltraSPARC processor. In some designs, vertical and horizontal multithreading are achieved with minimal retrofitting of an existing processor core, advantageously reducing logic and physical design changes and avoiding global chip re-routing, recomposing, and the expense of heavy redesign of integrated circuits.</p><p>Referring to FIG. 3, a schematic functional block diagram depicts a design configuration for a single-processor vertically-threaded processor <b>300</b> that is suitable for implementing various multithreading techniques and system implementations that improve multithreading performance and functionality. The single-processor vertically-threaded processor <b>300</b> has a single pipeline shared among a plurality of machine states or threads, holding a plurality of machine states concurrently. A thread that is currently active, not stalled, is selected and supplies data to functional blocks connected to the pipeline. When the active thread is stalled, the pipeline immediately switches to a non-stalled thread, if any, and begins executing the non-stalled thread.</p><p>The single-processor vertically-threaded processor <b>300</b> includes a thread <b>0</b> machine state block <b>310</b> that defines a machine state of a first thread (thread <b>0</b>). The single-processor vertically-threaded processor <b>300</b> also includes a thread <b>1</b> machine state block <b>312</b> that defines a machine state of a second thread (thread <b>1</b>) that \u201cshadows\u201d the machine state of thread <b>0</b>. The thread <b>0</b> machine state block <b>310</b> and the thread <b>1</b> machine state block <b>312</b> are fabricated in a single integrated circuit logic structure using a high-speed multi-bit flip-flop design and a \u201cfour-dimensional\u201d register file structure and supply instructions from thread <b>0</b> and thread <b>1</b> to a shared processor pipeline <b>314</b> using vertical threading. The multiple-dimensional register file employs register file structures that are replicated by N for vertical threading in combination with a three-dimensional storage circuit. The three-dimensional storage is formed by constructing a storage, such as a register file or memory, as a plurality of two-dimensional storage planes.</p><p>In response to a cache miss stall the processor <b>300</b> freezes the entire pipeline state of an executing thread in the shared processor pipeline <b>314</b>. The processor <b>300</b> issues instructions manages the machine state of each thread separately and independently. The functional properties of an independent thread state are stored throughout the pipeline extending to the pipeline registers to allow the processor <b>300</b> to postpone execution of a stalling thread by freezing the active state in the pipeline, relinquish the pipeline <b>314</b> to a previously idle thread by activating the previously idle thread in the pipeline while holding the state of the newly idle thread in the pipeline, and later resume execution of the postponed stalling thread at the precise state of the stalling thread immediately prior to the thread switch.</p><p>The shared processor pipeline <b>314</b> is coupled to a dual load/store unit including a thread <b>0</b> load/store unit <b>316</b> and a thread <b>1</b> load/store unit <b>318</b> that execute load and store data accesses for instruction threads <b>0</b> and <b>1</b>, respectively. The load/store units generate a virtual address of all load and store operations for accessing a data cache, decoupling load misses from the pipeline through a load buffer (not shown), and decoupling the stores through a store buffer. Up to one load or store is issued per cycle.</p><p>The shared processor pipeline <b>314</b> and the dual load/store unit are connected to a data memory interface <b>320</b> including a shared data cache and a shared data memory management unit (DMMU). The shared data cache is used to cache data for both thread <b>0</b> and thread <b>1</b> instruction sequences. In an illustrative processor <b>300</b>, the data cache is a write-through non-allocating 16-kilobyte direct-mapped 32-byte line cache. The data cache is virtually-indexed and physically-tagged using a tag array that is dual-ported so that tag updates resulting from line fills do not collide with tag reads for incoming loads. Snoops to the data cache use the second tag port so that an incoming load processed without delay by the snoop. The shared data memory management unit (DMMU) manages virtual to physical address translation.</p><p>The dual load/store units are also connected to an external cache control unit (ECU) <b>322</b>, which is connected to an external cache bus <b>324</b>. The external cache control unit <b>322</b> is also connected to an UltraPort Architecture Interconnect (UPA) bus <b>326</b> via a memory interface unit (MIU) <b>328</b>. The external cache control unit <b>322</b> and the memory interface unit (MIU) <b>328</b> are unified between thread <b>0</b> and thread <b>1</b> to perform functions of cache miss processing and interfacing with external devices to supply, in combination, a plurality of execution threads to the thread <b>0</b> machine state block <b>310</b> and the thread <b>1</b> machine state block <b>312</b> via a shared instruction control block <b>330</b>. The unified external cache control unit <b>322</b> and memory interface unit (MIU) <b>328</b> include thread identifier (TID) tagging to specify and identify a transaction that is accessed via the external cache bus <b>324</b> and the UPA bus <b>326</b>. In the processor <b>300</b>, TID logging is only internal to the processor <b>300</b> (integrated circuit chip). Outside the integrated circuit chip, hardware interacts with the processor <b>300</b> in the manner of an interaction with a single CPU with one UPA bus, and one external cache bus interface. In contrast, software outside the integrated circuit chip interacts with the processor <b>300</b> in the manner of an interaction with two logical CPUs.</p><p>The instruction control block <b>330</b> includes an instruction (L1) cache, a branch prediction unit, NFRAM, and an instruction memory management unit (IMMU) all of which are shared between the multiple threads, thread <b>0</b> and thread <b>1</b>. In an illustrative processor, the instruction cache is a 16 kilobyte two-way set-associative cache with 32-byte blocks. The instruction cache is physically indexed and physically tagged. The set is predicted as part of a \u201cnext field\u201d so that only index bits of an address are needed to address the cache. The instruction memory management unit (IMMU) supports virtual to physical address translation of instruction program counters (PCs). To prefetch across conditional branches, dynamic branch prediction is implemented in hardware based on a two-bit history of a branch. In an illustrative processor, a next-field is associated with every four instructions in the instruction cache points to the next cache line to be fetched. Up to twelve instructions are stored in an instruction buffer and issued to the pipeline.</p><p>The external cache control unit <b>322</b> manages instruction (L1) cache and data cache misses, and permits up to one access every other cycle to the external cache. Load operations that miss in the data cache are remedied by multiple-byte data cache fills on two consecutive accesses to the external cache. Store operations are fully pipelined and write-through to the external cache. Instruction prefetches that miss the instruction cache are remedied by multiple-byte instruction cache fills using four consecutive accesses to the parity-protected external cache.</p><p>The external cache control unit <b>322</b> supports DMA accesses which hit in the external cache and maintains data coherence between the external cache and the main memory (not shown).</p><p>The memory interface unit (MIU) <b>328</b> controls transactions to the UPA bus <b>326</b>. The UPA bus <b>326</b> runs at a fraction (for example, \u2153) of the processor clock.</p><p>Vertical multithreading advantageously improves processor performance in commercial application workloads which have high cache miss rates with a high miss penalty, low processor utilization (30%-50% on OLTP), and latency periods that present an opportunity to overlap execution to utilize cache miss wait times.</p><p>Vertical multithreading is also highly advantageous in sequential and parallel processing applications with frequent context switches.</p><p>Vertical multithreading does impose some costs on a processor in terms of resources used to save and restore thread states. The costs vary depending on the implementation of multithreading resources. For example, a software implementation typically incurs a time expense that negates any gain in latency. In another example, pipeline stages may be duplicated while attempting to share as many resources as possible, disadvantageously resulting in a high cost in silicon area.</p><p>An advantageous technique for implementing vertical multithreading, called a high-speed multi-bit flip-flop design, involves designing pipeline registers (flops) with multiple storage bits. The individual bits of a flip-flop are allocated to a separate thread. When a first thread stalls, typically due to a cache miss, the active bit of a flip-flop is removed from the pipeline pathway and another bit of the flip-flop becomes active. The states of the stalled thread are preserved in a temporarily inactive bit of the individual flip-flops in a pipeline stage. The high-speed multi-bit flip-flop design utilizes placement of a multiple-bit flip-flop at the end of the individual pipeline stages. The individual bits of the multiple-bit flip-flop are individually accessible and controllable to allow switching from a first thread to a second thread when the first thread stalls.</p><p>Referring to FIG. 4A, a schematic block diagram illustrates control and storage blocks of a circuit employing high-speed multiple-bit flip-flops. A multiple-bit flip-flop storage block <b>410</b> includes a storage header block <b>412</b> and a multiple-bit flip-flop block <b>414</b>. The storage header block <b>412</b> supplies timing signals and thread select signals to the multiple-bit flip-flop block <b>414</b>. Input signals to the storage header block <b>412</b> include a clock signal <b>14</b>i clk that is supplied from external to the multiple-bit flip-flop storage block <b>410</b>, a combined scan enable and clock enable signal se_ce_l, and a thread identifier (TID) signal tid_g that is supplied from thread select circuitry external to the multiple-bit flip-flop storage block <b>410</b>. The storage header block <b>412</b> derives an internal flip-flop clock signal elk, the inverse of the internal flip-flop clock signal clk_l, and a scan clock signal sclk from the external clock <b>14</b>clk and the scan enable and clock enable signal se_ce_I. The storage header block <b>412</b> asserts an internal thread ID signal tid based on the thread identifier (TID) signal tid_g. The storage header block <b>412</b> drives one or more flip-flop cells in the multiple-bit flip-flop block <b>414</b>. Typically, the multiple-bit flip-flop block <b>414</b> includes from one to 32 bistable multivibrator cells, although more cells may be used. The internal flip-flop clock signal clk, the inverse of the internal flip-flop clock signal clk_l, the scan clock signal sclk, and the internal thread ID signal tid are supplied from the storage header block <b>412</b> to the multiple-bit flip-flop block <b>414</b>.</p><p>In addition to the internal flip-flop clock signal elk, the inverse of the internal flip-flop clock signal clk_l, the scan clock signal sclk, and the internal thread ID signal tid, the multiple-bit flip-flop block <b>414</b> also receives an input signal d and a scan chain input signal si.</p><p>Referring to FIG. 4B, a schematic circuit diagram shows a multiple-bit bistable multivibrator (flip-flop) circuit. A conventional flip-flop is a single-bit storage structure and is commonly used to reliably sample and store data. A flip-flop is typically a fundamental component of a semiconductor chip with a single phase clock and a major determinant of the overall clocking speed of a microcontroller or microprocessor. A novel pulse-based multiple-bit high-speed flip-flop <b>400</b> is used to accelerate the functionality and performance of a processor.</p><p>An individual cell of the pulse-based multiple-bit high-speed flip-flop <b>400</b>, includes an input stage with a push-pull gate driver <b>402</b>. The push-pull gate driver <b>402</b> operates as a push-pull circuit for driving short-duration pulses to a multiple-bit storage circuit <b>428</b> and an output line q via an inverter <b>438</b>. The push-pull gate driver <b>402</b> has four MOSFETs connected in series in a source-drain pathway between VDD and VCC references including a p-channel MOSFET <b>418</b>, a p-channel MOSFET <b>420</b>, an n-channel MOSFET <b>422</b>, and an n-channel MOSFET <b>424</b>. P-channel MOSFET <b>418</b> and n-channel MOSFET <b>424</b> have gate terminals connected to the input signal d. The p-channel MOSFET <b>420</b> has a source-drain pathway connected between the p-channel MOSFET <b>418</b> and node <b>426</b>, and has a gate terminal connected to the inverse of the internal flip-flop clock signal clk_L. The n-channel MOSFET <b>422</b> has a source-drain pathway connected between the node <b>426</b> and the n-channel MOSFET <b>424</b>, and a gate terminal connected to the internal flip-flop clock signal elk. When the inverse clock signal clk_l and the input signal d are simultaneously low, the node <b>426</b> is brought high by the p-channel MOSFET <b>418</b> and the p-channel MOSFET <b>420</b>. When the internal flip-flop clock signal clk and the input signal d are simultaneously high, the node <b>426</b> is brought low by the n-channel MOSFET <b>424</b> and n-channel MOSFET <b>422</b>. Accordingly, the short duration pulses are generated by operation of the p-channel MOSFET <b>420</b> and the n-channel MOSFET <b>422</b> that drive the sample data on input terminal d to the node <b>426</b> on assertion of the clock signal clk. When the internal flip-flop clock signal clk is asserted, the node <b>426</b> holds a value that is the inverse of the input signal d. Driving strengths of the transistors <b>418</b>, <b>420</b>, <b>422</b>, and <b>424</b> are selected for different functionality during various conditions such as data sampling and propagation, thread switching, and scanning.</p><p>The illustrative multiple-bit storage circuit <b>428</b> includes two storage cells <b>430</b> and <b>440</b>, although other embodiments may include a single storage cell or more storage cells. A storage cell <b>430</b> or <b>440</b> includes a switch <b>432</b> or <b>442</b>, respectively, and a static memory element or latch <b>434</b> or <b>444</b>, respectively. The switch is used to select a particular latch according to the thread identifier (TID) that is active during a short-duration clock pulse. When the internal flip-flop clock signal elk is asserted, the inverse of the input signal d is latched by the storage cell <b>430</b> or <b>440</b> that is selected by the thread identifier (TID). In the illustrative system, the storage cell <b>430</b> is latched when the TID value is 0 so that the memory element <b>434</b> holds the inverse of the input signal d. Similarly, the storage cell <b>440</b> is latched the value of input signal d when the TID value is 1. Other embodiments of a pulse-based multiple-bit high-speed flip-flop <b>400</b> may be utilized that include additional storage cells, for example using a multiple-bit TID and a plurality of switches, multiplexer, or other functionally equivalent switch to select between storage cells.</p><p>The multiple-bit storage circuit <b>428</b> is connected to the node <b>426</b> and thus connected to the data path from the node <b>426</b> to the output line q, but is not inserted into the data path between the node <b>426</b> and the output line q. Specifically, a single line forms the input terminal and the output terminal to the storage cells <b>430</b> and <b>440</b> so that the multiple-bit storage circuit <b>428</b> does not interpose a delay between the node <b>426</b> and the inverter <b>438</b>. The connection of the multiple-bit storage circuit <b>428</b> outside the path of data flow prevents delay of the data signal, increasing the rate of propagation of the data signal. The resulting improvement in data transmission rate increases the amount of time available for signal computation in a computing system, improving system operating speed. In contrast, a conventional pipeline generally contains conventional storage elements or latches that are located in the path of data flow, slowing the propagation of a signal and reducing the time for signal computation in a processor, resulting in a reduction is processor execution speed.</p><p>The short-duration pulse at the node <b>426</b> activates the static memory element or latch <b>434</b>, <b>444</b> selected by the TID. The latches <b>434</b> and <b>444</b> are edge-triggered for sampling data in a small time window, and can be configured for operation with both positive edges and negative edges of pulse signals. The multiple-bit pulse-based high-speed flip-flop <b>400</b> is connected to bus select lines to determine which bit is active of a plurality of bits. At any one time only a single bit is active and the active bit holds and drives an output signal on an output line q via the inverter <b>438</b>. When the active bit is switched with one of the inactive bits, the output signal of the latch <b>434</b> or <b>444</b> changes accordingly.</p><p>Bits of the pulse-based high-speed flip-flop <b>400</b> may be made scannable selectively.</p><p>In one example, the high-speed flip-flop <b>400</b> is a master-slave flip-flop that replaces a single-bit master-slave flip-flop. Other types of flip-flops, which are well-known in the electronics arts may be converted to multiple-bit flip-flops for usage in a multi-threaded processor.</p><p>Referring to FIG. 4C, a timing diagram illustrates timing of the multiple-bit flip-flop <b>400</b>. The clock and inverted clock signals clk and clk_l generate a clock pulse <b>450</b> so that data present on the input line d just before the clock transition, or \u201cedge\u201d, determines the output state on line q after the clock has changed. The internal flip-flop clock signal clk is asserted to generate the clock pulse <b>450</b>, so that the node <b>426</b> holds a value that is the inverse of the input signal d. During the clock pulse <b>450</b>, the inverse of the input signal d is latched onto the storage cell <b>430</b> or the storage cell <b>440</b> as determined by the thread identifier (TID). The flip-flop <b>400</b> samples the signal in a small time-duration window to produce an edge-trigger functionality.</p><p>When the internal flip-flop clock signal clk is no longer asserted, the signal at the node <b>426</b> is determined by the storage cells <b>430</b> and <b>440</b>, determined by the TID control signal. Following a suitable delay that is sufficient to for latching the sample signal at the node <b>426</b> onto the latch <b>434</b> or <b>444</b>, a secondary pulse <b>452</b> is driven onto the node <b>426</b> inverted by the inverter <b>438</b> and driven to the output line q.</p><p>In the illustrative pulse-based high-speed flip-flop <b>400</b>, the latches <b>434</b> and <b>444</b> are advantageously removed from the direct path of signal propagation and thus do not degrade signal speed. The pulse-based high-speed flip-flop <b>400</b> has a zero setup time but a relatively long hold time.</p><p>In contrast, a conventional flip-flop includes a storage element that is in the path of data flow, slowing propagation of the signal and shortening the time duration that is left for signal computation, thereby reducing system operating speed. The described flip-flop <b>400</b> includes a storage element that is not in the direct path of signal propagation and does not hinder system operating speed.</p><p>Referring to FIG. 5, a schematic block diagram illustrates an N-bit \u201cthread selectable\u201d flip-flop substitution logic <b>500</b>, that is used in some multithreading system and method configurations. A processor includes an implementation of N-bit flip-flop global substitution to support multiple machine states. The processor design includes replacement of 1-bit flip-flops in logic of the stalling vertical thread to N-bit global flip-flops where N is the number of vertical threads. The flip-flop substitution logic <b>500</b> advantageously converts the single-bit flip-flop logic into multiple-bit flip-flop logic without increasing the surface area of the integrated circuit, maintaining the same footprint so that the die size of the integrated circuit remains the same while forming multiple thread data paths. The flip-flop substitution logic <b>500</b> advantageously generates the multiple thread paths without using multiplexers to select between threads. Usage of multiplexers would increase the integrated circuit area, negating the inherent advantages of the flip-flop substitution logic <b>500</b>.</p><p>The N-bit \u201cthread selectable\u201d flip-flop substitution logic <b>500</b> is used to create vertically multithreaded functionality in a processor pipeline while maintaining the same circuit size, including area, aspect ratio, metal footprint, and terminal locations, as a single-threaded pipeline. The N-bit \u201cthread selectable\u201d flip-flop substitution logic <b>500</b> adds an extra bit or a plurality of extra bits of storage in each 1-bit flip-flop that is allocated for handling pipeline stalls. The N-bit \u201cthread selectable\u201d flip-flop substitution logic <b>500</b> is activated by a scan enable (SE) signal of a scannable flip-flop for selecting an active thread. The thread is selected based on a thread identifier (TID) signal. The illustrative N-bit \u201cthread selectable\u201d flip-flop substitution logic <b>500</b> depicts a two-bit substitution logic, including a T0-bit storage <b>510</b> and a T1-bit storage <b>512</b>, for handling storage for two execution threads. The illustrative N-bit \u201cthread selectable\u201d flip-flop substitution logic <b>500</b> is a simple D flip-flop with a single-bit thread identifier (TID) selecting the T1-bit storage <b>512</b> and the inverse of the TID signal selecting the T0-bit storage <b>510</b>.</p><p>In one class of processor designs, the N-bit \u201cthread selectable\u201d flip-flop substitution logic <b>500</b> is advantageously used to retrofit an existing single thread processor to a multithreaded configuration. Accordingly, the N-bit \u201cthread selectable\u201d flip-flop substitution logic <b>500</b> is employed to replace most of the standard 1-bit flip-flops in a processor with a special type of flip-flop (FF) that has multiple bits of state and is thread-selectable. In a specific application, the N-bit \u201cthread selectable\u201d flip-flop substitution logic <b>500</b> is used to implement a MegaSPARC multiple-thread processor from a mature UltraSPARC-II processor core design.</p><p>Each bit in the N-bit \u201cthread selectable\u201d flip-flop substitution logic <b>500</b> corresponds to an individual machine state of a thread, forming what may be called a \u201cvirtual CPU\u201d. Only one bit is active at any time so that only one of a plurality of virtual CPUs occupy the pipeline at one time. When the active virtual CPU receives a data cache or instruction cache miss, the virtual CPU sends a fill request to an external cache and initiates a thread switch allowing another virtual CPU to become active.</p><p>Although the illustrative example shows an N-bit \u201cthread selectable\u201d flip-flop substitution logic <b>500</b> where N is two and the processor implementation handles two threads, any suitable number of bits may be implemented for the number N based on desired computing applications, as well as processing considerations in creating storage structures and switches in a specified circuit size.</p><p>In the illustrative processor, the N-bit \u201cthread selectable\u201d flip-flop substitution logic <b>500</b> is implemented in most, but not all of the functional components of the processor. The N-bit \u201cthread selectable\u201d flip-flop substitution logic <b>500</b> is implemented for flip-flops in functional components including control/status registers and pipeline stage registers. Other processor components including processor back-end logic such as external cache and memory interface components may implement conventional flip-flops. The backend logic that handles cache fill requests is shared by all virtual CPUs so that multiple-bit flip-flop conversion is not necessary.</p><p>The fill request for the virtual CPU that is replaced is processed even when the virtual CPU is inactive. When data returns for the fill request, the data is buffered temporarily to be filled into the L1 cache (either data cache or instruction cache) later when the thread again becomes active. Until the replaced virtual CPU becomes active, the currently active (replacing) virtual CPU continues processing until the replacing virtual CPU encounters a thread switch, such as an L1 cache miss. Upon the occurrence of the thread switch signal terminating the replacing virtual CPU, the processor switches to another virtual CPU which is not stalled (possibly the first replaced virtual CPU). If all virtual CPUs are stalled awaiting cache misses, the pipeline is vacant and stalls until data returns for at least one virtual CPU.</p><p>For misses on an instruction fetch, the backend logic handles the instruction cache fill of an inactive virtual CPU in the same manner. To avoid a mis-speculated thread switch, a virtual CPU is not replaced until the instruction cache miss causes an empty condition of the instruction buffer.</p><p>In some vertical multithreading processor designs, vertical multithreading is advantageously implemented using a fast, for example nanosecond duration, context switch that improves performance of sequential and parallel processing applications which are subject to frequent context switching. The fast, nanosecond range context switch or thread switch is highly advantageous in comparison to conventional context switching techniques that generally take place in a time range in the order of microseconds to milliseconds, several orders of magnitude slower than the context switching described herein. The fast, nanoseconds range context switching is attained by the capability of freezing the pipeline and by passing multiple threads of data through a multiple-threaded structure that stores data for multiple threads concurrently, for example, through usage of multiple-bit flip-flops. Data of an active thread updates the data storage while data in inactive threads remains frozen. Thread switching occurs by switching thread pathways between the updating states and frozen states. In contrast, conventional context switching requires draining of the full pipeline and storing of data from the register files of a first thread into a memory and restoring data of a second thread from a memory to the register files. All are highly time-consuming operations.</p><p>In some applications context switches typically are made in response to interrupts, including hardware and software interrupts, both internal and external, of a processor. Computing applications subject to frequent context switches include disk server, network server, web server, telecommunications applications and the like.</p><p>In an illustrative system, the fast, nanoseconds range context switch is implemented in hardware, advantageously eliminating software overhead during saving and restoration of the processor state. Referring to FIG. 6, a schematic block diagram illustrates a thread switch logic <b>610</b> which generates a thread identifier (TID) signal identifying an active thread of a plurality of threads.</p><p>A processor includes the thread switch logic <b>610</b> to attain a very fast exception handling functionality while executing non-threaded programs by invoking a multithreaded-type functionality in response to an exception condition. The processor, while operating in multithreaded conditions or while executing nonthreaded programs, progresses through multiple machine states during execution. The very fast exception handling logic includes connection of an exception signal line to thread select logic, causing an exception signal or trap to evoke a switch in thread state and machine state. The switch in thread state and machine state causes the processor to enter and to exit the exception handler immediately, without invoking typical operating system or software handling and without the inherent timing penalty of the operating system's software saving and restoring of registers. Connection of the exception line directly to the thread select logic advantageously causes an exception condition to evoke a context or thread switch that significantly reduces software or system overhead penalty.</p><p>Usage of the multi-threaded, multi-processor configuration in combination with the thread switch logic <b>610</b> and the operation of various compiler techniques accelerates the execution of sequential programs. For example, a compiler may be optimized to automatically generate speculative parallel threads in sequential, non-numeric programs. The compiler may also be optimized to speculatively move load instructions ahead of store instructions and execute the load and store instructions in separate parallel threads.</p><p>In another example, the compiler may be controlled to launch speculative parallel threads (epochs) on loop iterations with speculative execution in which branch conditions are predicted. In circumstances of unsafe speculation, the compiler may control execution to execute a plurality of threads to cover all possible branch conditions and to select results from the thread of the correct branch. In some processor implementations, two additional bits are appended to lines of the L1 data cache to store an indication of whether data in the line is speculatively loaded or speculatively stored so that nonspeculative results are rapidly retired.</p><p>Sequential programs are also made more efficient by extending an invalidation-based cache coherence protocol to compare epoch numbers of a store snoop hit condition to a speculatively-loaded cache line.</p><p>The fast, nanoseconds range context switch operates in conjunction with thread switching logic such as the pulse-based high-speed flip-flop <b>400</b> to improve speed of thread switching. The pulse-based high-speed flip-flop <b>400</b> enables virtually instantaneous switching between threads, saving of the machine state of a stalled thread, and machine state restoration of an activated thread. The fast, nanoseconds range, context switching rapidly controls which thread is activated by the pulse-based high-speed flip-flop <b>400</b>. The thread switch logic <b>610</b> receives a plurality of input signals that evoke a context switch and thread switch. In an illustrative processor, input terminals to the thread switch logic <b>610</b> include an L1_load_miss terminal, an L1_instruction_miss terminal, an instruction_buffer_empty terminal, a thread_priority terminal, an MT_mode terminal, an external_interrupt terminal, and an internal_interrupt terminal. The thread switch logic <b>610</b> generates a thread identifier (TID) signal based on signals to the input terminals. The thread switch logic <b>610</b> generates the TID signal with a thread switch delay or overhead of one processor cycle.</p><p>Other processors may include other signals that generate a thread switch signal (TID). For example, some processors may be configured to switch threads on an L2 cache miss.</p><p>The thread switch logic <b>610</b> generates signals to allow the processor to switch context to another thread in response to an L1 cache load miss which pulses the L1 load miss terminal, and in response to an L1 cache instruction miss which pulses the L1_instruction_miss terminal. The thread switch logic <b>610</b> also generates signals allowing the processor to switch context to another thread when an instruction buffer is empty, generating a signal to the instruction_buffer_empty terminal. The thread switch logic <b>610</b> also switches context in response to external and internal interrupts which pulse the external_interrupt terminal and the internal_interrupt terminal, respectively.</p><p>The thread switch logic <b>610</b> permits control of thread selection based on priority of a particular thread via signals to the thread_priority terminal. The thread switch logic <b>610</b> is typically implemented as a control processor, microcontroller, microcode control logic, a logic circuit, or the like, all of which are well known in the electronics arts. Accordingly, fast thread switching upon an occurrence of an L1 cache miss may be selected.</p><p>In other applications, thread reservations may be selected on the basis of which process or context is the busiest. In these applications, the thread switch logic <b>610</b> implements a thread reservation system or thread locking system in which a thread pathway is reserved for usage by a selected thread. The thread switch logic <b>610</b> may select a particular thread that is to execute with priority in comparison to other threads. A high priority thread may be associated with an operation with strict time constraints, an operation that is frequently and predominantly executed in comparison to other threads. thread switch logic <b>610</b> controls thread-switching operation so that a particular hardware thread is reserved for usage by the selected thread.</p><p>In one example of a priority operation, a JAVA\u2122 server typically includes a master process and a plurality of slave processes. The thread switch logic <b>610</b> reserves a hardware thread for the master process, which determines which slave process is permitted to execute at any time. The master process is therefore selected as a reserved thread that reserves a particular reserved hardware thread and is thus locked into the reserved hardware thread. The master process continues to execute in the reserved hardware thread but allocates nonreserved hardware threads among the plurality of slave threads.</p><p>In other applications, the thread switch logic <b>610</b> may be configured to support native threads in an operating system, for example Solaris native threads may be supported in Java applications.</p><p>Thread switch logic <b>610</b> includes an MT_mode terminal supplying multithreading mode signals to select particular threads for multi-processor execution.</p><p>The thread switch logic <b>610</b> supports a fast thread switch with a very small delay, for example three cycles or less. In some multithreading system and method embodiments, a processor performs a fast thread-switching operation in response to an L1 cache miss stall.</p><p>In other implementations, the thread switch logic <b>610</b> implements one or more of several thread-switching methods. A first thread-switching operation is \u201coblivious\u201d thread-switching for every N cycle in which the individual flip-flops locally determine a thread-switch without notification of stalling. The oblivious technique, typically implemented using a simple counter for counting cycles between switches, avoids usage of an extra global interconnection, such as wire or metal, between threads for thread selection.</p><p>A second thread-switching operation is \u201csemi-oblivious\u201d thread-switching for use with a load-use stall or \u201cpipeline stall\u201d signal. The pipeline stall signal operates in two capacities, first as a notification of a pipeline stall, and second as a thread select signal between threads so that, again, usage of an extra global interconnection between threads for thread selection is avoided. One suitable implementation of the semi-oblivious thread-switching technique employs a connection with a load/store unit global stall signal (lsu_stall_e) in UltraSPARC-I and UltraSPARC-II processors.</p><p>A third thread-switching operation is an \u201cintelligent global scheduler\u201d thread-switching in which a thread switch decision is selectively programmed, based on one or more signals. In one example an intelligent global scheduler uses signals such as: (1) an L1 data cache miss stall signal, (2) an L1 load miss signal, (3) an instruction buffer empty signal, (4) an instruction queue empty signal, (5) an L2 cache miss signal, (6) a thread priority signal, (7) a thread timer signal, (8) an interrupt signal, or other sources of triggering. In some embodiments, the thread select signal is broadcast as fast as possible, similar to a clock tree distribution. In some systems, a processor derives a thread select signal that is applied to the flip-flops by overloading a scan enable (SE) signal of a scannable flip-flop.</p><p>Various processor implementations include a thread switch logic <b>610</b> that segregates a cache in a processor into a plurality of N cache parts. Referring to FIG. 7A, a schematic block diagram shows an example of a cache <b>700</b> which is segregated into a first segregated cache portion <b>710</b> and a second segregated cache portion <b>712</b>, each of which include a plurality of storage regions. In one example, the first segregated cache portion <b>710</b> and the second segregated cache portion <b>712</b> each have a capacity of 8 kB, segregating a 16kB directed-mapped 32-byte line cache. Although the illustrative example shows the cache <b>700</b> segregated into two equallysized portions, other examples may segregate a cache into any number of portions. The cache portions may be equal in size or differing in size. Referring to FIG. 7B, a pictorial diagram shows an example of an addressing technique for the segregated cache <b>700</b>. A 64-bit virtual address storage <b>720</b> includes a cache virtual address tag bit field <b>722</b> with virtual address bits [<b>63</b>:<b>13</b>], a thread ID (TID) and index bits field <b>724</b> with index bits [<b>12</b>:<b>5</b>], and a byte offset bit field <b>726</b> with virtual address bits [<b>4</b>:<b>0</b>]. The index bits field <b>724</b> segregates the cache into two thread portions, the first thread segregated cache portion <b>710</b> and the second thread segregated cache portion <b>712</b>.</p><p>Cache segregation is selectively applied in a single cache or a plurality of caches including L1 caches, L2 caches, external caches, and the like. Cache segregation avoids interference, \u201ccross-talk\u201d, or \u201cpollution\u201d between threads. One technique for cache segregation utilizes logic for storing and communicating thread identification (TID) bits. The cache utilizes cache indexing logic. For example, the TID bits can be inserted at the most significant bits of the cache index. Sharing of an L2 cache among threads is easily-implemented since the L2 cache is physically indexed.</p><p>Various processor implementations include an anti-aliasing logic, shown in FIG. 8, which is coupled to a cache <b>810</b>, such as an L1 cache, and L2 cache, or others. For example, a processor may include anti-aliasing logic coupled to an L1 cache so that the L1 cache is shared among threads via anti-aliasing. In an illustrative example, the cache is a 16 kB direct-mapped virtually-indexed, physically-tagged (VIPT) cache <b>810</b> that is shared among threads. The cache <b>810</b> is addressed using a 64-bit virtual address storage <b>820</b> including cache virtual address tag bit field <b>822</b>, a cache index <b>812</b>, and byte offset bit field <b>826</b>. The cache index <b>812</b> is configured to include a thread ID (TID) <b>823</b> and index bits field <b>824</b>.</p><p>The anti-aliasing logic stores data to the same physical address (PA), shown as PA=B, from two different threads that map to two different indexed entries n and n+256. The anti-aliasing logic operates during a store to the cache <b>810</b> by comparing the physical address at the two indexed entries. If the physical addresses match, the duplicate entry is either invalidated or updated. The anti-aliasing logic avoids hazards that result from multiple virtual addresses mapping to one physical address. The anti-aliasing logic selectively invalidates or updates duplicate L1 cache entries.</p><p>Various processor implementations include native thread logic associated with the thread switch logic <b>610</b> and the anti-aliasing logic that supports lightweight processes and native threads. The logic supporting native threads and lightweight processes includes logic that disables thread ID tagging and disables cache segregation since lightweight processes and native threads share the same virtual address space. A lightweight process is a simplified, minimal-context process or thread that is typically designed to efficiently execute kernel functions. The lightweight process has very little context so is easily and efficiently switched into and out of execution. The lightweight process thus executes efficiently without thread ID tagging and cache segregation. The thread switch logic <b>610</b> accommodates lightweight processes by disabling thread ID tagging and cache segregation, advantageously avoiding allocation of cache and other resources to threads that do not utilize the resources.</p><p>Referring to FIG. 9, a schematic functional block diagram depicts a design configuration for a single-chip dual-processor vertically-threaded processor <b>900</b> that is suitable for implementing various multithreading techniques and system implementations that improve multithreading performance and functionality. The single-processor vertically-threaded processor <b>300</b> shown in FIG. 3 executes a vertical multithreading alone. In contrast, the single-chip dual-processor vertically-threaded processor <b>900</b> executes with both horizontal multithreading and vertical multithreading. The single-chip dual-processor vertically-threaded processor <b>900</b> has two processors on a single chip including a first vertical multithreading processor <b>902</b> and a second vertical multithreading processor <b>904</b>.</p><p>The first vertical multithreading processor <b>902</b> includes a thread <b>0</b> machine state block <b>910</b> that defines a machine state of a first thread (thread <b>0</b>) and a thread <b>1</b> machine state block <b>912</b> that defines a machine state of a second thread (thread <b>1</b>) that \u201cshadows\u201d the machine state of thread <b>0</b>. The thread <b>0</b> machine state block <b>910</b> and the thread <b>1</b> machine state block <b>912</b> have the single integrated circuit logic structure using high-speed multi-bit flip-flop design and four-dimensional register file structure, and supply instructions from thread <b>0</b> and thread <b>1</b> to a shared processor pipeline <b>914</b> using vertical threading. The shared processor pipeline <b>914</b> is connected to a dual load/store unit including a thread <b>0</b> load/store unit <b>916</b> and a thread <b>1</b> load/store unit <b>918</b> that execute load and store data accesses for instruction threads <b>0</b> and <b>1</b>, respectively.</p><p>The shared processor pipeline <b>914</b> and the dual load/store unit are connected to a shared data cache and a shared data memory management unit (DMMU). The shared data cache is used to cache data for both thread <b>0</b> and thread <b>1</b> computations.</p><p>The second vertical multithreading processor <b>904</b> includes a thread <b>2</b> machine state block <b>940</b> that defines a machine state of a third thread (thread <b>2</b>) and a thread <b>3</b> machine state block <b>942</b> that defines a machine state of a fourth thread (thread <b>3</b>) that \u201cshadows\u201d the machine state of thread <b>2</b>. The thread <b>2</b> machine state block <b>940</b> and the thread <b>3</b> machine state block <b>942</b> have the single integrated circuit logic structure using high-speed multi-bit flip-flop design and four-dimensional register file structure, and supply instructions from thread <b>2</b> and thread <b>3</b> to a shared processor pipeline <b>944</b> using vertical threading. The shared processor pipeline <b>944</b> is connected to a dual load/store unit including a thread <b>2</b> load/store unit <b>946</b> and a thread <b>3</b> load/store unit <b>948</b> that execute load and store data accesses for instruction threads <b>0</b> and <b>1</b>, respectively.</p><p>The shared processor pipeline <b>944</b> and the dual load/store unit are connected to a shared data cache and a shared data memory management unit (DMMU). The shared data cache is used to cache data for both thread <b>2</b> and thread <b>3</b> computations.</p><p>An instruction control block <b>960</b> includes an instruction (L<b>1</b>) cache, a branch prediction unit, NFRAM, and an instruction memory management unit (IMMU) all of which are shared between the multiple threads, thread <b>2</b> and thread <b>3</b>.</p><p>The two dual load/store units are also connected to an external cache control unit (ECU) <b>922</b>, which is connected to an external cache bus <b>924</b>. The external cache control unit <b>922</b> is also connected to an UltraPort Architecture Interconnect (UPA) bus <b>926</b> via a memory interface unit (MIU) <b>928</b>. The external cache control unit <b>922</b> and the memory interface unit (MIU) <b>928</b> are unified between four threads, thread <b>0</b>, thread <b>1</b>, thread <b>2</b>, and thread <b>3</b> to perform functions of cache miss processing and interfacing with external devices to supply, in combination, a plurality of execution threads to the thread <b>0</b> machine state block <b>910</b>, the thread <b>1</b> machine state block <b>912</b>, the thread <b>2</b> machine state block <b>940</b>, and the thread <b>3</b> machine state block <b>942</b> via a shared instruction control blocks <b>930</b> and <b>960</b>. The unified external cache control unit <b>922</b> and memory interface unit (MIU) <b>928</b> include thread identifier (TID) tagging to specify and identify the thread that is accessed via the external cache bus <b>924</b> and the UPA bus <b>926</b>.</p><p>The unified external cache control unit <b>922</b> and memory interface unit (MIU) <b>928</b> perform operations of cache miss processing and interfacing with external devices. Miss processing for a thread (a virtual CPU) takes place when the thread is inactive. In addition, multiprocessing is simplified when a multithread processor operates in the manner of a single processor to an external device. Therefore, in some processors the unified external cache control unit <b>922</b> and memory interface unit (MIU) <b>928</b> are shared structures with logical enhancements to support multiple threads but do not use flip-flops to duplicate ECU and MIU functionality for each thread.</p><p>The external cache bus <b>924</b> and the UPA bus <b>926</b> interfaces are shared between threads using a single port identifier.</p><p>The external cache control unit <b>922</b> manages instruction (L1) cache and data cache misses in both the first vertical multithreading processor <b>902</b> and the second vertical multithreading processor <b>904</b>, and permits up to one access every other cycle to the external cache. The external cache control unit <b>922</b> supports DMA accesses which hit in the external cache and maintains data coherence between the external cache and the main memory (not shown). The memory interface unit (MIU) <b>928</b> controls transactions to the UPA bus <b>926</b>.</p><p>The single-chip dual-processor vertically-threaded processor <b>900</b> also includes an on-chip L2 cache tag RAM <b>938</b> to support a two-way external L2 cache.</p><p>The single-chip dual-processor vertically-threaded processor <b>900</b> reduces wasted cycle time resulting from stalling and idling, and increases the proportion of execution time, by supporting and implementing both vertical multithreading and horizontal multithreading. Vertical multithreading permits overlapping or \u201chiding\u201d of cache miss wait times. In vertical multithreading, multiple hardware threads share the same processor pipeline. A hardware thread is typically a process, a lightweight process, a native thread, or the like in an operating system that supports multithreading, such as a Solaris UNIX operating system. Horizontal multithreading is attained by utilizing a plurality of pipelines, increasing parallelism within the processor circuit structure. The single-chip dual-processor vertically-threaded processor <b>900</b> attains vertical multithreading within a single integrated circuit die that makes up a single-chip processor. To further increase system parallelism the single-chip dual-processor vertically-threaded processor <b>900</b> executes with horizontal multithreading using multiple processor cores formed in a single die. Advances in on-chip multiprocessor horizontal threading are gained as processor core sizes are reduced through technological advancements.</p><p>The illustrative processor <b>900</b> and other multithreaded processors described herein employ thread level parallelism and operates on multiple independent threads, possibly attaining a multiplicative factor of the performance of a processor having the same resources and clock rate but utilizing traditional non-thread parallelism.</p><p>Thread level parallelism is particularly useful for Java\u2122 applications which are bound to have multiple threads of execution. Java\u2122 methods including \u201csuspend\u201d, \u201cresume\u201d, \u201csleep\u201d, and the like include effective support for threaded program code. In addition, Java\u2122 class libraries are thread-safe to promote parallelism. (Java\u2122, Sun, Sun Microsystems and the Sun Logo are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries. All SPARC trademarks, including UltraSPARC I and UltraSPARC II, are used under license and are trademarks of SPARC International, Inc. in the United States and other countries. Products bearing SPARC trademarks are based upon an architecture developed by Sun Microsystems, Inc.) Furthermore, the thread model of the multithreaded processor <b>900</b> and other described multithreaded processors supports a dynamic compiler which runs as one thread while a second thread is used by the current application. In the illustrative system, the compiler applies optimizations based on \u201con-the-fly\u201d profile feedback information while dynamically modifying the executing code to improve execution on each subsequent run. For example, a \u201cgarbage collector\u201d may be executed as a first thread, copying objects or gathering pointer information, while the application is executing as a second thread.</p><p>Referring to FIG. 10, a schematic functional block diagram shows an alternative design configuration for a single-processor vertically-threaded processor <b>1000</b> that is suitable for implementing various multithreading techniques and system implementations that improve multithreading performance and functionality. The single-processor vertically-threaded processor <b>1000</b> is two-way vertically threaded with a single processor but with dual thread pipelines in a die. In an illustrative embodiment, the pipeline is based on an UltraSPARC IIi design with a peripheral component interconnect (PCI) interface and executes up to a 600 MHz processor clock frequency. The single-processor vertically-threaded processor <b>1000</b> includes a thread <b>0</b> machine state block <b>1010</b> that defines a machine state of a first thread (thread <b>0</b>) and incorporates a processor pipeline. The thread <b>0</b> machine state and pipeline block <b>1010</b> is shadowed by a thread <b>1</b> machine state block <b>1012</b> that defines a machine state of a second thread (thread <b>1</b>). The thread <b>0</b> machine state and pipeline block <b>1010</b> and shadow thread <b>1</b> machine state block <b>1012</b> are formed in a single integrated circuit logic structure using the previously-described high-speed multi-bit flip-flop design and a \u201cfour-dimensional\u201d register file structure. The four-dimensional register file structure is formed in a plurality of layers of storage cells. The storage cell layers have a two-dimensional form including storage storing data bytes or words including a plurality of bits. Vertical threading introduces a fourth dimension since the three-dimensional register file is defined for a plurality of machine states that are duplicated for the registers. The multiple-dimension register file multiplicatively increases the register file storage capacity without changing the integrated circuit size since the size depends on the number and density of devices across the surface area of a semiconductor die. A suitable multiple-dimension register file is disclosed in more detail in U.S. Pat. No. 5,721,868, entitled \u201cRAPID REGISTER FILE ACCESS BY LIMITING ACCESS TO A SELECTABLE REGISTER SUBSET\u201d, issued Feb. 24, 1998 (Yung et al) which is incorporated by reference herein in its entirety.</p><p>The multiple-dimension register file structure is highly advantageous for increasing processor performance without increasing size, and for decreasing processor size while maintaining or increasing processor performance. A further advantage of the multiple-dimension register file is that a single-threaded processor may be converted to a multithreaded processor while maintaining the same circuit footprint size, wiring configuration, packaging, and the like. Accordingly, a multithreaded processor is advantageously produced while exploiting legacy characteristics of a single-threaded processor model.</p><p>The thread <b>0</b> machine state and pipeline block <b>1010</b> and shadow thread <b>1</b> machine state block <b>1012</b> execute instructions of thread <b>0</b> and thread <b>1</b> using vertical threading. The thread <b>0</b> machine state and pipeline block <b>1010</b> and shadow thread <b>1</b> machine state block <b>1012</b> are coupled to an external cache control unit (ECU) <b>1022</b>, which is connected to an external L2 cache Static Random Access Memory (SRAM) <b>1024</b>.</p><p>The external cache control unit <b>1022</b> is also connected to a peripheral component interconnect (PCI) bus <b>1032</b> via a PCI controller <b>1030</b>. The external cache control unit <b>1022</b> is further connected to a Dynamic Random Access Memory (DRAM) <b>1034</b> and an UltraPort Architecture Interconnect (UPA) bus <b>1026</b> via a memory control unit (MCU) <b>1028</b>. The external cache control unit <b>1022</b> and the memory control unit (MCU) <b>1028</b> are unified between thread <b>0</b> and thread <b>1</b> to perform functions of cache miss processing and interfacing with external devices to supply, in combination, a plurality of execution threads to the thread <b>0</b> machine state block <b>1010</b> and the thread <b>1</b> machine state block <b>1012</b>. The unified external cache control unit <b>1022</b> and memory control unit (MCU) <b>1028</b> include thread identifier (TID) tagging to specify and identify the thread that is accessed via the L2 cache SRAM <b>1024</b>, the PCI bus <b>1032</b>, the DRAM <b>1034</b>, and the UPA bus <b>1026</b>. The PCI controller <b>1030</b> and the MCU <b>1028</b> are shared between threads using a single port identifier. Thread ID tagging is implemented in processor components that are non-stalling including, for example, a carry (logN)-bit TID in L1 and L2 caches (both data and instruction caches), translation look-aside buffers (TLBs), asynchronous interfaces of load buffers, an external memory management unit (MMU) interface, and the like. In non-stalling components, only a single thread passes through the component at one time so that no stalled state exists that would be stored. The thread ID bits identify which thread is active in the component.</p><p>The external cache control unit <b>1022</b> manages instruction (L1) cache and data cache misses, and permits up to one access every other cycle to the external cache. Load operations that miss in the data cache are remedied by multiple-byte data cache fills on two consecutive accesses to the external cache. Store operations are fully pipelined and write-through to the external cache. Instruction prefetches that miss the instruction cache are remedied by multiple-byte instruction cache fills using four consecutive accesses to the parity-protected external cache.</p><p>The external cache control unit <b>1022</b> supports DMA accesses which hit in the external cache and maintains data coherence between the external cache and the main memory (not shown).</p><p>The memory control unit (MCU) <b>1028</b> controls transactions to the UPA bus <b>1026</b> and the DRAM <b>1034</b>. The UPA bus <b>1026</b> runs at a fraction (for example, <b>\u2153) of the processor clock. </b></p><p>An illustrative single-processor vertically-threaded processor <b>1000</b> is constructed on a die smaller than 100 mm<sup>2 </sup>and has a power dissipation of less than 10 W at a clock rate of 200 MHz. The illustrative single-processor vertically-threaded processor <b>1000</b> has an estimated gain in computational efficiency of 30% over a single-thread processor having similar performance specifications per thread.</p><p>Referring to FIG. 11, a schematic functional block diagram illustrates an alternative design configuration for a single-chip dual-processor vertically-threaded processor <b>1100</b> that is suitable for implementing various multithreading techniques and system implementations that improve multithreading performance and functionality. The single-chip dual-processor vertically-threaded processor <b>1100</b> includes two processor cores on a single die with each processor core being two-way vertically threaded, effectively forming four processors on one die. The two processor cores share an on-chip four-way set-associative L2 cache, and share an external cache control unit that controls access of the L2 cache. Sharing of the on-chip L2 cache advantageously attains cache coherency among the plurality of processors on a single die. In the illustrative single-chip dual-processor vertically-threaded processor <b>1100</b>, each of the two processor cores includes separate peripheral component interconnect (PCI), DRAM, and UltraPort Architecture Interconnect (UPA) interfaces.</p><p>The single-chip vertically-threaded processor <b>1000</b> shown in FIG. 10 executes a vertical multithreading alone. In contrast, the single-chip dual-processor vertically-threaded processor <b>1100</b> executes with both horizontal multithreading and vertical multithreading. The single-chip dual-processor vertically-threaded processor <b>1100</b> has two processors on a single chip including a first vertical multithreading processor <b>1102</b> and a second vertical multithreading processor <b>1104</b>, both of which are two-way vertically threaded with a single processor but having dual thread pipelines in a die. In an illustrative embodiment, the pipelines are based on an UltraSPARC IIi design with a peripheral component interconnect (PCI) interface and executes up to a 600 MHz processor clock frequency.</p><p>The first vertical multithreading processor <b>1102</b> includes a thread <b>0</b> machine state block <b>1110</b> that defines a machine state of a first thread (thread <b>0</b>) and incorporates a processor pipeline. The thread <b>0</b> machine state and pipeline block <b>1110</b> is shadowed by a thread <b>1</b> machine state block <b>1112</b> that defines a machine state of a second thread (thread <b>1</b>). The thread <b>0</b> machine state and pipeline block <b>1110</b> and shadow thread <b>1</b> machine state block <b>1112</b> are formed in a single integrated circuit logic structure covering about half a semiconductor die and using the previously-described high-speed multi-bit flip-flop design and a \u201cfour-dimensional\u201d register file structure. In some processors, the register file may be allocated to a single vertical multithreading processor. In other processors, the register file may be shared among a plurality of vertical multithreading processors.</p><p>The thread <b>0</b> machine state and pipeline block <b>1110</b> and shadow thread <b>1</b> machine state block <b>1112</b> execute instructions of thread <b>0</b> and thread <b>1</b> using vertical threading. The thread <b>0</b> machine state and pipeline block <b>1110</b> and shadow thread <b>1</b> machine state block <b>1112</b> are coupled to an external cache control unit (ECU) <b>1122</b>, which is connected to an on-chip L2 cache SRAM <b>1124</b> via an external cache control unit (ECU) arbiter <b>1125</b>. The L2 cache SRAM <b>1124</b> and the ECU arbiter <b>1125</b> are shared between the first vertical multithreading processor <b>1102</b> and the second vertical multithreading processor <b>1104</b>. In an illustrative processor <b>1100</b>, the L2 cache SRAM <b>1124</b> is a 1 Megabyte, four-way L2 cache.</p><p>The external cache control unit <b>1122</b> is also connected to a peripheral component interconnect (PCI) bus <b>1132</b> via a PCI controller <b>1130</b>. The external cache control unit <b>1122</b> is further connected to a DRAM <b>1134</b> and an UltraPort Architecture Interconnect (UPA) bus <b>1126</b> via a memory control unit (MCU) <b>1128</b>. The external cache control unit <b>1122</b> and the memory control unit (MCU) <b>1128</b> are unified between thread <b>0</b> and thread <b>1</b> to perform functions of cache miss processing and interfacing with external devices to supply, in combination, a plurality of execution threads to the thread <b>0</b> machine state block <b>1110</b> and the thread <b>1</b> machine state block <b>1112</b>. The unified external cache control unit <b>1122</b> and memory control unit (MCU) <b>1128</b> include thread identifier (TID) tagging to specify and identify the thread that is accessed via the L2 cache SRAM <b>1124</b>, the PCI bus <b>1132</b>, the DRAM <b>1134</b>, and the UPA bus <b>1126</b>. The PCI controller <b>1130</b> and the MCU <b>1128</b> are shared between thread <b>0</b> and thread <b>1</b> using a single port identifier.</p><p>The external cache control unit <b>1122</b> manages instruction (L1) cache and data cache misses, and permits up to one access every other cycle to the external cache. Load operations that miss in the data cache are remedied by multiple-byte data cache fills on two consecutive accesses to the external cache. Store operations are fully pipelined and write-through to the external cache. Instruction prefetches that miss the instruction cache are remedied by multiple-byte instruction cache fills using four consecutive accesses to the parity-protected external cache.</p><p>The external cache control unit <b>1122</b> supports DMA accesses which hit in the external cache and maintains data coherence between the external cache and the main memory (not shown).</p><p>The memory control unit (MCU) <b>1128</b> controls transactions to the UPA bus <b>1126</b> and the DRAM <b>1134</b>. The UPA bus <b>1126</b> runs at a fraction (for example, \u2153) of the processor clock.</p><p>The second vertical multithreading processor <b>1104</b> includes a thread <b>2</b> machine state block <b>1140</b> that defines a machine state of a third thread (thread <b>2</b>) and incorporates a processor pipeline. The thread <b>2</b> machine state and pipeline block <b>1140</b> is shadowed by a thread <b>3</b> machine state block <b>1142</b> that defines a machine state of a fourth thread (thread <b>3</b>). The thread <b>2</b> machine state and pipeline block <b>1140</b> and shadow thread <b>3</b> machine state block <b>1142</b> are formed in a single integrated circuit logic structure covering about half a semiconductor die and using the previously-described high-speed multi-bit flip-flop design and a \u201cfour-dimensional\u201d register file structure. The thread <b>2</b> machine state and pipeline block <b>1140</b> and shadow thread <b>3</b> machine state block <b>1142</b> execute instructions of thread <b>2</b> and thread <b>3</b> using vertical threading. The thread <b>2</b> machine state and pipeline block <b>1140</b> and shadow thread <b>3</b> machine state block <b>1142</b> are coupled to an external cache control unit (ECU) <b>1152</b>, which is connected to the on-chip L2 cache SRAM <b>1124</b> via the external cache control unit (ECU) arbiter <b>1125</b>. The L2 cache SRAM <b>1124</b> and the ECU arbiter <b>1125</b> are shared between the first vertical multithreading processor <b>1102</b> and the second vertical multithreading processor <b>1104</b>.</p><p>The external cache control unit <b>1152</b> is also connected to the peripheral component interconnect (PCI) bus <b>1132</b> via a PCI controller <b>1160</b>. The external cache control unit <b>1152</b> is further connected to a DRAM <b>1164</b> and the UltraPort Architecture Interconnect (UPA) bus <b>1126</b> via a memory control unit (MCU) <b>1158</b>. The external cache control unit <b>1152</b> and the memory control unit (MCU) <b>1158</b> are unified between thread <b>2</b> and thread <b>3</b> to perform functions of cache miss processing and interfacing with external devices to supply, in combination, a plurality of execution threads to the thread <b>2</b> machine state block <b>1140</b> and the thread <b>3</b> machine state block <b>1142</b>. The unified external cache control unit <b>1152</b> and memory control unit (MCU) <b>1158</b> include thread identifier (TID) tagging to specify and identify the thread that is accessed via the L2 cache SRAM <b>1124</b>, the PCI bus <b>1132</b>, the DRAM <b>1134</b>, and the UPA bus <b>1126</b>. The TID is supported by logic for usage with processor blocks that are not stalled. Pertinent non-stalling blocks include caches, translation look-aside buffers (TLB), a load buffer asynchronous interface, a store buffer asynchronous interface, an external memory management unit (MMU) interface, and others. The PCI controller <b>1160</b> and the MCU <b>1158</b> are shared between thread <b>2</b> and thread <b>3</b> using a single port identifier.</p><p>The load buffer and store buffer interfaces are shared structures which are implemented to maintain compatibility with multiple threads. Upon a thread switch, a new thread does not change the state of a shared structure in a manner that is incompatible with the replaced thread. The load buffer and store buffer interfaces maintain thread compatibility by physical duplication of structures and by checking read-after-write status of the storages. In particular, load operations are checked against a store buffer in an alternative thread so that read-after-write status information is stored and augmented to store results of read-after-write checks against all store buffers.</p><p>Store buffer data cache hit bits are not reset. Therefore, following a thread switch, a load in thread <b>2</b> can replace a line that is a destination of an as yet incomplete store in thread <b>1</b>. Since the store buffer data cache hit bits are not reset, another thread switch can result in the thread <b>1</b> store writing to a different line. The read-after-write check on the other store buffer prevents the load from progressing ahead of stores in the other store buffer and prevents replacing of a line that is a destination of an incomplete store.</p><p>In addition, if a store in thread <b>1</b> writes the data cache but not the external cache, in the absence of a read-after-write check on the other store buffer, a load in thread <b>2</b> can receive the updated value before the other processors in the system, resulting in a TSO violation. Therefore, the data cache write complete notification for a store operation should not disable a read-after-write across threads.</p><p>The external cache control unit <b>1152</b> manages instruction (L1) cache and data cache misses, and permits up to one access every other cycle to the external cache. The external cache control unit <b>1152</b> supports DMA accesses which hit in the external cache and maintains data coherence between the external cache and the main memory (not shown).</p><p>The memory control unit (MCU) <b>1158</b> controls transactions to the UPA bus <b>1126</b> and the DRAM <b>1134</b>.</p><p>An illustrative single-chip dual-processor vertically-threaded processor <b>1100</b> executes at a clock frequency of up to 600MHz, is constructed on a die smaller than 250 mm<sup>2</sup>, and has a power dissipation of less than 10 W at a clock rate of 200 MHz. The illustrative single-chip dual-processor vertically-threaded processor <b>1100</b> has an estimated gain in computational efficiency of 130% over a single-thread processor having similar performance specifications per thread.</p><p>Countless other structures and combinations may be implemented on one or more integrated circuit dies depending on the fabrication process employed and the applications envisioned for the processor. The other processor configurations may be configured with varying numbers of on-chip or off-chip processor cores, varying numbers of vertical threads per pipeline, and different configurations of interfaces, memory and I/O control units, storage devices, and the like. For example, in a \u201c1C2T\u201d configuration, a single processor die includes two vertical threads. In another example, one advantageous configuration includes four processor cores with each core vertically multithreaded to produce a square-shaped die. In a \u201c4C4T\u201d configuration, a four-processor multiprocessor is formed on a single die with each of the four processors being four-way vertically threaded. An operating system controls operations of the <b>4</b>C<b>4</b>T configuration processor as a 16-way sequential multiprocessor.</p><p>Some processors may include either on-chip or external Resettable Dynamic RAM (RDRAM) in place of an external cache. Various processors may or may not include an on-chip L2 cache. Various systems may include caches that are selectively configured, for example as segregated L1 caches and segregated L2 caches, or segregated L1 caches and shared L2 caches, or shared L1 caches and shared L2 caches.</p><p>Referring to FIG. 12, a schematic block diagram illustrates a processor <b>1200</b> and processor architecture that are suitable for implementing various multithreading techniques and system implementations that improve multithreading performance and functionality. An instruction cache <b>1212</b> supplies instructions to a decode unit <b>1214</b>. The instruction cache <b>1214</b> receives instructions from a prefetch unit <b>1216</b> that is supplied with instructions from either a branch unit <b>1218</b> or an external cache (not shown) via a cache control/system interface <b>1222</b>. In some processors the cache control/system interface <b>1222</b> includes an external cache control unit (ECU) and a memory interface unit (MUI). Instructions from the external cache are supplied when the prefetch unit <b>1216</b> supplies a virtual address to an instruction translation look-aside buffer (TLB) <b>1220</b>. Instructions from the external cache are supplied to a predecode unit <b>1224</b> and contain various control information to the instruction cache <b>1212</b>. The various control information includes signals such as a designation that an instruction is a branch instruction.</p><p>Instructions from decode unit <b>1214</b> are supplied to an instruction buffer <b>1226</b> and accessed by dispatch unit <b>1228</b>. In some processors instruction buffering is supplied by multiple instruction buffers <b>1226</b> connected in parallel. In the illustrative processor <b>1200</b>, the dispatch unit <b>1228</b> supplies four decoded instructions at one time on a bus <b>1230</b>. The instructions are supplied to one of eight functional units. The dispatch unit <b>1228</b> checks for data dependencies, control dependencies and structural hazards, such as availability of functional units and memory ports. The dispatch unit <b>1228</b> then, based on results of the checking operation, dispatches up to four instructions in a cycle.</p><p>Integer-type functional units, including a load/store unit <b>1232</b>, a first integer arithmetic logic unit (ALU) <b>1234</b>, and a second integer ALU unit <b>1236</b>, share a set of integer registers <b>1248</b>. Floating-point-type functional units, including a first floating-point unit <b>1238</b>, a second floating-point unit <b>1240</b>, a third floating-point unit <b>1242</b>, a first graphical unit <b>1244</b>, and a second graphical unit <b>1246</b> share floating-point registers <b>1250</b>. The integer functional units share an integer completion unit <b>1252</b> and the floating point functional units share a floating point completion unit <b>1254</b>. The processor <b>1200</b> also includes an on-chip data cache <b>1256</b> and a data translation look-aside buffer (TLB) <b>1258</b>.</p><p>Referring to FIG. 13, a schematic perspective diagram shows a multi-dimensional register file <b>1300</b> that is advantageous for usage in a multithreaded processor. Both integer and floating point register files are typically not implemented with flip-flops so that the described multiple-bit flip-flop is not useful in the typical register file to increase the storage capacity. However, the capacity of the register files may otherwise be expanded using other techniques and structures, such as the multi-dimensional register file <b>1300</b> structure.</p><p>A register file is a datapath component that is highly determinative of performance in a superscalar processor. The access time of the register file is a factor that impacts processor cycle time. The register file consumes a relatively large portion of the superscalar processor since a large number of ports is very useful in such processors. Typically ten or more ports are used for a three-scalar microprocessor and the size of the register file increases as a quadratic function of the number of ports.</p><p>The multi-dimensional register file <b>1300</b> advantageously uses the area inherently consumed by the metal wires used for bitlines and wordlines for each storage cell to hold N sets of registers. The individual sets of the N sets is logically a plane in the third dimension. The configuration of multiple planes is used to create a plurality of register windows and to form extra register sets for real-time tasks, microtask switching, or storage for multiple execution threads. In some storages, a data array of a three-dimensional, eight-window, ten-ported register file is six times smaller than a flat register file. Access time is improved by shortening bus lines and by sharing a large buffer between bit cells. The multi-dimensional register file <b>1300</b> is advantageously implemented in high-performance superscalar microprocessors.</p><p>The large number of registers and increased functionality of a register file that includes a plurality of register windows are conventionally implemented in a microprocessor at the expense of a large increase in circuit size, cost, and difficulty in implementation. For example, for a conventional register file having a window of 32 registers with eight overlapping registers between windows would contain a total of 128 registers, not including global registers, and would be several times larger than conventional register files without windows. The functionality added by windows plus the larger number of registers make the implementation of a register file with windows challenging since RISC processors tend to base cycle time, through heavy pipelining, on basic datapath blocks such as the register file, ALUs, and caches. A conventional register file with windows implemented in a conventional way has exactly one window active for all reads and one window active for all writes.</p><p>The multi-dimensional register file <b>1300</b> exploits the fact that not all windows need to be accessed simultaneously to conserve circuitry among windows. The individual planes <b>1310</b> in the multi-dimensional register file <b>1300</b> represent a separate window. For sake of simplicity, the multi-dimensional register file <b>1300</b> is shown with four non-overlapping windows. The concept of the multi-dimensional register file <b>1300</b> applies to the support of context switching so that the individual planes <b>1310</b> represent a separate context. Context switching between microtasks is rapidly accomplished by simply changing the context number, as shown in FIG. 13 as changing the window pointer <b>1312</b>.</p><p>The current context number or window pointer <b>1312</b> is decoded through a separate decoder <b>1314</b> and a corresponding plane <b>1310</b> is selected. The register index for the selected window is decoded in the manner of a conventional register file. Upon selection of a register, the register contents are driven on a data bus that is shared by all windows or contexts. For sake of simplicity, FIG. 13 only shows a read portion of the logic for the multi-dimensional register file <b>1300</b>. Write logic (not shown) includes a separate decoder (not shown) for a write window pointer which selects a different plane <b>1310</b>. Separate data lines are inherently included for single phase pipelines, so no additional lines need be included for the separate write window port. Note that an additional window decode line may be added to attain a higher performance.</p><p>A conventional implementation of register windows in a register file results in a large flat configuration. For a superscalar processor with multiple ports, the conventional implementation results in having a single bit of information wastefully stored beneath several metal wires. FIG. 14 is a schematic circuit diagram showing a bit cell <b>1410</b> of a conventional implementation of register windows of a register file with ten ports including seven read ports and three write ports. Ten separate word lines <b>1412</b>, seven single-ended sense-amplifier lines (not shown) for the read lines and three single-ended write bit lines <b>1416</b> are included, resulting in a 10\u00d710 grid <b>1418</b>. For a four-layer metal process, the word lines are typically on the second layer and the bit lines are on the third layer. Power and ground potentials are routed on the fourth layer and the first layer is used for local connections in the bit cells. For an 0.5 micron process with a metal pitch of 1.5 micron, the 10\u00d710 grid <b>1418</b> results in an area of 225 square microns. Beneath the 10\u00d710 grid <b>1418</b>, a single bit of information is stored, a poor utilization of the available area for logic devices. For double-sensed sense amplifiers and differential writes, the wasted area is even larger. A grid of 10\u00d720 is typically required, resulting in an effective area of 450 microns to store a single bit of information.</p><p>The data array of a windowed register file with 128 64-bit registers implemented in the illustrative conventional manner approximately measures 128*64*225=1.84 square millimeters for the single-ended scheme and 128*64*450=3.68 square millimeters for the double-ended configuration. For a 64-bit superscalar processor with a relatively large register file, for example, 32 registers, the data array represents approximately two-thirds of the total area of the register file.</p><p>Referring to FIG. 15, a schematic circuit diagram showing a plurality of bit cells <b>1510</b> of a register windows of the multi-dimensional register file <b>1300</b> that avoids waste of integrated circuit area by exploiting the condition that only one window is read and only one window is written at one time. The otherwise wasted area is used to store bits of information of a plurality of windows at a corresponding plurality of depths at one lateral position in the integrated circuit area. For example, bit i of a register j for a plurality of windows {<b>0</b>, <b>1</b>, <b>2</b>, . . , <b>7</b>} is stored at one position in a 10\u00d710 grid <b>1518</b> at a plurality of depths. The multiple bits at a plurality of depths are addressed by specifying a bit i, register j, and window k. Thus an eight-window register file is addressed using three additional lines for specifying a selected one of eight windows. Thus the 10\u00d710 grid <b>1518</b> is addressed by supplying three address lines in addition to the address lines for addressing a 10\u00d710 single-window register file. Accordingly, the 10\u00d710 grid <b>1518</b> is addressed by 13\u00d710 addressing lines. In the illustrative multi-dimensional register file <b>1300</b>, eight bits of information are stored, rather than a single bit of information, in an area only 30% larger than the area for a single-window 10\u00d710 grid <b>1418</b>.</p><p>For a single-ended register file storage example, each bit utilizes about 36 square microns (6.15 times smaller) in comparison to the 225 square microns in a conventional single-window implementation. The benefits are even greater for a double-ended implementation in which a bit uses about 73 square microns in comparison to the 450 square microns of a conventional double-windowed storage. The double-ended storage attains the same ratio of savings, 6.15 times smaller, but results in an even larger gain in total saved area.</p><p>The 10\u00d710 grid <b>1518</b> is shown for illustrative purposes only. A grid may have any suitable dimension (for example 10\u00d720 or others), depending on a desired application, functionality, and capacity.</p><p>Referring to FIG. 16, a schematic circuit diagram illustrates a suitable bit storage circuit <b>1600</b> storing one bit of the local registers for the multi-dimensional register file <b>1300</b> with eight non-overlapping windows. The multi-dimensional register file <b>1300</b> is useful for fast context switching or for implementing local registers which are not shared across a window.</p><p>The illustrative bit storage circuit <b>1600</b> represents a storage cell <b>1610</b> with seven read ports <b>1612</b>, single-ended read bit lines <b>1614</b>, three write ports <b>1616</b>, differential write bit lines <b>1618</b>, separate read <b>1619</b> and write windows <b>1620</b>, and a decoded (one-hot) current window pointer <b>1622</b>. The storage cell <b>1610</b> does not allow multiple write operations to the same register at one time. The single-ended read bit lines <b>1614</b> use significantly less area than a differential sense amplifier implementation (seven lines versus fourteen lines). Single-ended read bit line sensing improves read sensing speed without compromising noise margin by precharging the read bit line above the trip point of the sense amplifier. For example in a typical 3.3V CMOS process, assuming TTLH, the read bit line is precharged to 1.31V which is 0.61V above the sense amplifier trip point of 0.70V. After the read bit line is precharged, selection of one of the memory cells on the read bit line can result in either continuation of the precharged state which the sense amplifier reads as a logic \u201c1\u201d, or discharging of the bit line below the sense amplifier trip point, resulting in a read of a logic \u201c0\u201d.</p><p>The differential write bit lines <b>1618</b> allow fast write and robust noise margins. Using a separate window pointer for reads and writes attains a higher performance by allowing more than one window to co-exist in a pipeline. By disallowing multiple writes to the same physical register in the same cycle, the design is simplified without affecting performance since such writes are indicative of an inefficient condition and inherently unsuitable in an in-order processor. Two consecutive writes in the same cycle without an intermediate read operation is not a common programming practice.</p><p>Write address decoding takes place in two stages. Predecoders (not shown) are simple static gates. Four-input AND gates perform second stage decoding. One of the four input signals is a write enable signal. Write decoders are disabled when the corresponding write enable is disabled.</p><p>The decoded current window pointer <b>1622</b> simplifies logic for each bit cell and produces a speed advantage since the pointer can be decoded in parallel with a register index.</p><p>Select lines <b>1624</b> (rps<b>0</b>, rps<b>1</b>,. . . , rps<b>7</b>) for the storage cell <b>1610</b> select a register N and cross the full width of the 64-bit register. Read address decoding is performed in two stages using precoders (not shown) that are simple static gates while final stage decoders (not shown) are three-input NAND domino-type gates. To significantly increase the address decoding rate, read address signals are differentially precharged to allow evaluation to begin immediately when address input signals become valid.</p><p>The decoded current window pointer <b>1622</b> is represented by eight signals (rcwp<b>0</b>, rcwp<b>1</b>,. . . , rcwp<b>7</b>), only one of which is active at one time. The decoded current window pointer <b>1622</b> selects the window within which register N is accessed. Cross-coupled inverters <b>1626</b> are used to store each bit cell. A local inverter <b>1628</b> amplifies the signals locally and isolates each cell, avoiding charge sharing. Data read from the individual bit cell is buffered through an inverter INV<b>2</b> which contains a large pull-down transistor (50 microns versus 8 microns for a corresponding pull-up transistor). The seven bit lines <b>1624</b> are precharged so that read access time is determined by read bit line pulldown speed. Inverter INV<b>1</b> and a pmos transistor TPFB pull a node cc of an intermediate local data bus up to VDD.</p><p>Three write select lines <b>1630</b> are wps<b>0</b>, wps<b>1</b>, and wps<b>2</b>. Differential writes are implemented so three pairs of differential write bit lines <b>1632</b> are used (wdc<b>0</b>, wdt<b>0</b>, wdc<b>1</b>, wdt<b>1</b>, wdc<b>2</b>, and wdc<b>2</b>). The separate decoded current window pointer <b>1622</b> is used for the write operations so only one of the eight signals (wcwp<b>0</b>, wcwp<b>1</b>, . . . , wcwp<b>7</b>) is active at one time.</p><p>Referring to FIG. 17A, a schematic pictorial diagram illustrates sharing of registers among adjacent windows. Overlapping windows allow a calling function to send parameters to a receiver without additional load and store operations. A calling function has a current calling window <b>1710</b> that uses \u201cOUTS\u201d registers <b>1712</b> to pass parameters to an adjacent current receiver window <b>1720</b> where the registers become \u201cINS\u201d registers <b>1722</b> for the receiver. Similarly, on a return from a function call, the receiver can return results through the \u201cINS\u201d registers <b>1722</b>, which become the \u201cOUTS\u201d registers for the original receiver.</p><p>The discussion of FIG. 16 described how bit cells from adjacent windows reside together beneath the metal wires used for accessing a single cell and for supplying window decode signals. Using the same concept for the \u201cINS\u201d and \u201cOUTS\u201d registers, bits for In<sub>n </sub>of window<sub>w </sub>all reside in one point in the circuit area. Referring to FIG. 17B, a schematic block diagram shows a four-window register file including a set of four bits containing data for bit<sub>i </sub>of register IN<sub>n </sub>of window<sub>w+1 </sub>which is the same as bit<sub>i </sub>of register OUT<sub>n </sub>of window<sub>w</sub>. For a particular window pointer, for example window<sub>0</sub>, two bit cells, representing the IN and the OUT register are accessible.</p><p>Referring to FIG. 18, a schematic circuit diagram illustrates an implementation of a multi-dimensional register file <b>1300</b> including registers shared across a plurality of windows. An illustrative storage <b>1800</b> includes bit cells <b>1810</b> containing data for IN<sub>i </sub>and OUT<sub>i </sub>registers of window<sub>j</sub>, two bit cells may be accessed simultaneously by always selecting two possibly addressed cells in the set of eight cells for each window select. For example, assertion of current window pointer rcwp<b>1</b> selects two cells, cc<b>0</b> as a possible IN register and cc<b>1</b> as a possible OUT register. Content of the two cells cc<b>0</b> and cc<b>1</b> is driven on separate local buses ccin and ccout. Selection of data for each read port of the IN register or the OUT register is handled by a decoder (not shown). Separate lines supply the IN registers and the OUT registers to select the correct register. A single large buffer with a wide pulldown transistor is included for each bus to conditionally discharge the bit lines.</p><p>Write circuitry includes special logic to prevent erroneous overwrites between the IN registers and the OUT registers. Logic <b>1820</b> driving the current write window is similar to logic <b>1822</b> driving the current read window. One and only one of the current window pointers (wcwp<b>0</b>, wcwp<b>1</b>, . . . , wcwp<b>7</b>) is asserted and selects two cells, one IN bit cell and one OUT bit cell. Signals applied at the write decoder level determine whether to drive data from the IN bit cell or the OUT bit cell. Separate signals select a write operation to an IN cell (for example wps<b>0</b>_in) and a write operation to an OUT cell (for example, wps<b>1</b>_out). Since a write operation is data-destructive, a write operation to an IN register is prevented from corrupting the corresponding OUT register and vice-versa, which could occur even though the write data is forwarded to one of the two local write data buses. Write data from one port either is sent to the IN local bus or to the OUT local bus, but not to both. The relatively large capacitance of the local buses could eventually overwrite the content of one of the bit cells since the write window pointer supplies direct access. To prevent the potential write disturbance, pull-up transistors TPPU<b>1</b>, TPPU<b>2</b>, TPPU<b>3</b>, and TPPU<b>4</b> are used to precharge the local write data lines of inactive ports, effectively operating as a read disturb of the bit cell with little impact on the voltage levels. A condition of two write ports attempting to write to the same IN register or the same OUT register is prevented since multiple write operations to the same destination register are not allowed.</p><p>The multi-dimensional register file <b>1300</b> has many advantageous characteristics. For example, a capability to pass parameters on function calls and function call returns without having to store and retrieve data through the stack significantly increases performance since load and store operations are often a bottleneck in modem high-performance processors.</p><p>Context-switching performance of the processor <b>1200</b> is improved by context-switchable storage structures such as a register file with \u201cwindows\u201d. The windows support different \u201ccontexts\u201d for function calls. In one example, the register file with windows is configured as a multiple-dimensional structure with \u201cplanes\u201d for fast context switching.</p><p>In conventional processors, the data array portion consumes about two-thirds of the total area of a register file. Usage of the multi-dimensional register file <b>1300</b> advantageously reduces the data array size by a factor of four to six times for a register file with eight planes. The total area conserved depends on various design trade-offs including: (1) differential versus single-ended bit read sensing, (2) decoded versus encoded plane/window routing, and (3) differential versus single-ended writing. In comparison to conventional \u201csingle-window\u201d register files, multiple contexts are attained essentially without cost in terms of integrated circuit area using the multi-dimensional register file <b>1300</b> in circuits here read-port and write-port interconnects dominate the cell area of the registers.</p><p>In addition to greatly saving circuit area, the multi-dimensional register file <b>1300</b> advantageously attains faster access times, primarily by reducing the total capacitance on the bit lines. One bit line only connects to one window in a conventional \u201csingle-window\u201d implementation, in comparison to all windows in the multi-dimensional register file <b>1300</b>. The multi-dimensional register file <b>1300</b> results in a reduced total area and shorter bit lines, reducing capacitance. A bit line driver, due to logic sharing among bit cells, may be enlarged, increasing bit line discharge. In addition, independent decoding between the window pointer and the register index results in faster operation.</p><p>The multi-dimensional register file <b>1300</b> is advantageously used for processors including high-performance superscalar processors as a register file but the applied techniques and structures may otherwise be used in other types of storage devices. For example, multiple-dimension storage structures may otherwise be implemented in various VLIW memory structures, which typically utilize many ports, and to fast context-switching processors which support several contexts through a single structure.</p><p>The described processor structure and operating method may be implemented in many structural variations. For example two processor cores are combined with an on-chip set-associative L2 cache in one system. In another example, four processor cores are combined with a direct RAMBUS interface with no external L2 cache. A countless number of variations are possible. In some systems, each processor core is a vertically-threaded pipeline.</p><p>While the invention has been described with reference to various embodiments, it will be understood that these embodiments are illustrative and that the scope of the invention is not limited to them. Many variations, modifications, additions and improvements of the embodiments described are possible. For example, those skilled in the art will readily implement the steps necessary to provide the structures and methods disclosed herein, and will understand that the process parameters, materials, and dimensions are given by way of example only and can be varied to achieve the desired structure as well as modifications which are within the scope of the invention. Variations and modifications of the embodiments disclosed herein may be made based on the description set forth herein, without departing from the scope and spirit of the invention as set forth in the following claims. For example, although the illustrative processors include a specified number of threads per pipeline and a specified number of pipelines per integrated circuit chip, various other numbers of threads and pipelines may be implemented in other examples, depending on desired processor applications, semiconductor fabrication techniques, and various size parameters of the processor.</p><p>The descriptions contained herein relate to many aspects of processor structure and operating techniques, including structural and functional aspects of various processor components. The structures and techniques are described that are highly useful in combination. However, various structures and techniques are also innovative and highly advantageous when employed alone or in multiple various subcombinations. The invention is to be limited by the claims alone and various limitations that are described in the specification but not included in a particular claim are not to be considered inherent to the claim merely by inclusion in the specification.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "William N.", "last_name": "Joy", "name": ""}, {"first_name": "Marc", "last_name": "Tremblay", "name": ""}, {"first_name": "Gary", "last_name": "Lauterbach", "name": ""}, {"first_name": "Joseph I.", "last_name": "Chamdani", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "SUN MICROSYSTEMS, INC."}, {"first_name": "", "last_name": "Oracle America, Inc.", "name": ""}, {"first_name": "", "last_name": "SUN MICROSYSTEMS, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/46"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/48        20060101A I20051008RMEP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "718107"}, {"primary": false, "label": "712E09053"}, {"primary": false, "label": "712219"}, {"primary": false, "label": "712228"}, {"primary": false, "label": "712229"}, {"primary": false, "label": "718108"}], "ecla_classes": [{"label": "G06F   9/38E2"}, {"label": "G06F   9/38H"}, {"label": "G06F   9/48C4"}, {"label": "G06F   9/38E4"}], "cpc_classes": [{"label": "G06F   9/3851"}, {"label": "G06F   9/4843"}, {"label": "G06F   9/3861"}, {"label": "G06F   9/3861"}, {"label": "G06F   9/3851"}, {"label": "G06F   9/3842"}, {"label": "G06F   9/4843"}, {"label": "G06F   9/3842"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1999-05-11", "application_date": "1999-05-11", "family_members": [{"ucid": "WO-2000068781-A9", "titles": [{"lang": "EN", "text": "SWITCHING METHOD IN A MULTI-THREADED PROCESSOR"}, {"lang": "FR", "text": "PROCEDE DE COMMUTATION DANS UN PROCESSEUR A PROCESSUS ELEMENTAIRES MULTIPLES"}]}, {"ucid": "WO-2000068781-B1", "titles": [{"lang": "EN", "text": "SWITCHING METHOD IN A MULTI-THREADED PROCESSOR"}, {"lang": "FR", "text": "PROCEDE DE COMMUTATION DANS UN PROCESSEUR A PROCESSUS ELEMENTAIRES MULTIPLES"}]}, {"ucid": "WO-2000068781-A2", "titles": [{"lang": "EN", "text": "SWITCHING METHOD IN A MULTI-THREADED PROCESSOR"}, {"lang": "FR", "text": "PROCEDE DE COMMUTATION DANS UN PROCESSEUR A PROCESSUS ELEMENTAIRES MULTIPLES"}]}, {"ucid": "US-6507862-B1", "titles": [{"lang": "EN", "text": "Switching method in a multi-threaded processor"}]}, {"ucid": "DE-60002200-D1", "titles": [{"lang": "EN", "text": "SWITCHING METHOD IN A MULTITHREAD PROCESSOR"}, {"lang": "DE", "text": "UMSCHALTUNGSVERFAHREN IN EINEM MULTITHREADPROZESSOR"}]}, {"ucid": "EP-1185929-B1", "titles": [{"lang": "FR", "text": "PROCEDE DE COMMUTATION DANS UN PROCESSEUR A PROCESSUS ELEMENTAIRES MULTIPLES"}, {"lang": "EN", "text": "SWITCHING METHOD IN A MULTI-THREADED PROCESSOR"}, {"lang": "DE", "text": "UMSCHALTUNGSVERFAHREN IN EINEM MULTITHREADPROZESSOR"}]}, {"ucid": "EP-1185929-A2", "titles": [{"lang": "FR", "text": "PROCEDE DE COMMUTATION DANS UN PROCESSEUR A PROCESSUS ELEMENTAIRES MULTIPLES"}, {"lang": "EN", "text": "SWITCHING METHOD IN A MULTI-THREADED PROCESSOR"}, {"lang": "DE", "text": "UMSCHALTUNGSVERFAHREN IN EINEM MULTITHREADPROZESSOR"}]}, {"ucid": "US-20020078122-A1", "titles": [{"lang": "EN", "text": "Switching method in a multi-threaded processor"}]}, {"ucid": "DE-60002200-T2", "titles": [{"lang": "EN", "text": "SWITCHING METHOD IN A MULTITHREAD PROCESSOR"}, {"lang": "DE", "text": "UMSCHALTUNGSVERFAHREN IN EINEM MULTITHREADPROZESSOR"}]}, {"ucid": "WO-2000068781-A3", "titles": [{"lang": "EN", "text": "SWITCHING METHOD IN A MULTI-THREADED PROCESSOR"}, {"lang": "FR", "text": "PROCEDE DE COMMUTATION DANS UN PROCESSEUR A PROCESSUS ELEMENTAIRES MULTIPLES"}]}, {"ucid": "US-7316021-B2", "titles": [{"lang": "EN", "text": "Switching method in a multi-threaded processor"}]}, {"ucid": "US-6694347-B2", "titles": [{"lang": "EN", "text": "Switching method in a multi-threaded processor"}]}, {"ucid": "US-20040162971-A1", "titles": [{"lang": "EN", "text": "Switching method in a multi-threaded processor"}]}]}