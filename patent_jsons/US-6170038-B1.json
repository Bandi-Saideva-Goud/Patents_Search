{"patent_number": "US-6170038-B1", "publication_id": 72541379, "family_id": 25498157, "publication_date": "2001-01-02", "titles": [{"lang": "EN", "text": "Trace based instruction caching"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72493892\"><p>A cache memory is constituted with a data array and control logic. The data array includes a number of data lines, and the control logic operates to store a number of trace segments of instructions in the data lines, including trace segments that span multiple data lines. In one embodiment, each trace segment includes one or more trace segment members having one or more instructions, with each trace segment member occupying one data line, and the data lines of a multi-line trace segment being sequentially associated (logically). Retrieval of the trace segment members of a multi-line trace segment is accomplished by first locating the data line storing the first trace segment member of the trace segment, and then successively locating the remaining data lines storing the remaining trace segment members based on the data lines' logical sequential associations.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00001\" num=\"1\"><claim-text>1. A cache-memory apparatus comprising:</claim-text><claim-text>a) a first state machine to operate the cache-memory apparatus in an execution mode, wherein trace segment members of trace segments of instructions stored in a plurality of data lines are looked up and output; and </claim-text><claim-text>b) a second state machine to operate, independent of the first state machine, the cache-memory apparatus in a trace segment build mode wherein trace segment members of trace segments of instructions are built and stored into the data lines. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00002\" num=\"2\"><claim-text>2. The apparatus as set forth in claim <b>1</b>, wherein when operating in the execution mode, the apparatus operates in one of a plurality of states including a trace segment head lookup state, a trace segment body lookup state, and a trace segment tail lookup state, for looking up trace segment heads, trace segment bodies, and trace segment tails respectively.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00003\" num=\"3\"><claim-text>3. The apparatus as set forth in claim <b>2</b>, wherein the plurality of states further include a microcode sequencer lookup state for retrieving micro-ops of a macro instruction from a microcode sequencer.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00004\" num=\"4\"><claim-text>4. The apparatus as set forth in claim <b>1</b>, wherein when operating in the trace segment build mode, the apparatus operates in one of a plurality of states including a fill buffer transfer state for transferring a trace segment member from a fill buffer into a data array, the first trace segment member being built along a predicted execution direction.</claim-text></claim>"}, {"num": 5, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00005\" num=\"5\"><claim-text>5. A processor comprising:</claim-text><claim-text>a) an execution unit; and </claim-text><claim-text>b) a cache memory coupled to the execution unit, the cache memory having a first state machine to operate the cache memory in an execution mode, wherein trace segment members of trace segments of instructions stored in a plurality of data lines are looked up and output, and a second state machine to operate, independent of the first state machine, the cache memory in a trace segment build mode wherein trace segment members of trace segments of instructions are built and stored into the data lines. </claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00006\" num=\"6\"><claim-text>6. The processor as set forth in claim <b>5</b>, wherein when operating the cache memory in the execution mode, the first state machine operates the cache memory in one of a plurality of states including a trace segment head lookup state, a trace segment body lookup state, and a trace segment tail lookup state, for looking up trace segment heads, trace segment bodies, and trace segment tails respectively.</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00007\" num=\"7\"><claim-text>7. The processor as set forth in claim <b>6</b>, wherein the plurality of states further include a microcode sequencer lookup state for retrieving micro-ops of a macro instruction from a microcode sequencer.</claim-text></claim>"}, {"num": 8, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00008\" num=\"8\"><claim-text>8. The processor as set forth in claim <b>5</b>, wherein when operating the cache memory in the trace segment build mode, the second state machine operates the cache memory in one of a plurality of states including a fill buffer transfer state for transferring a trace segment member from a fill buffer into a data array, the first trace segment member being built along a predicted execution direction.</claim-text></claim>"}, {"num": 9, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00009\" num=\"9\"><claim-text>9. A computer system comprising:</claim-text><claim-text>a) a processor including a cache memory having a first state machine to operate the cache memory in an execution mode, wherein trace segment members of trace segments of instructions stored in a plurality of data lines are looked up and output, and a second state machine to operate, independent of the first state machine, the cache memory in a trace segment build mode wherein trace segment members of trace segments of instructions are built and stored into the data lines; and </claim-text><claim-text>b) an input/output component coupled to the processor. </claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00010\" num=\"10\"><claim-text>10. The computer system as set forth in claim <b>9</b>, wherein when operating the cache memory in the execution mode, the first state machine operates the cache memory in one of a plurality of states including a trace segment head lookup state, a trace segment body lookup state, and a trace segment tail lookup state, for looking up trace segment heads, trace segment bodies, and trace segment tails respectively.</claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00011\" num=\"11\"><claim-text>11. The computer system as set forth in claim <b>10</b>, wherein the plurality of states further include a microcode sequencer lookup state for retrieving micro-ops of a macro instruction from a microcode sequencer.</claim-text></claim>"}, {"num": 12, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00012\" num=\"12\"><claim-text>12. The computer system as set forth in claim <b>9</b>, wherein when operating the cache memory in the trace segment build mode, the second state machine operates the cache memory in one of a plurality of states including a fill buffer transfer state for transferring a trace segment member from a fill buffer into a data array, the first trace segment member being built along a predicted execution direction.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00013\" num=\"13\"><claim-text>13. A cache-memory apparatus comprising:</claim-text><claim-text>a) a first state machine to operate the cache-memory apparatus in an execution mode, wherein trace segment members of trace segments of instructions stored in a plurality of data lines are looked up and output; and </claim-text><claim-text>b) a second state machine to operate, concurrent with the first state machine, the cache-memory apparatus in a trace segment build mode wherein trace segment members of trace segments of instructions are built and stored into the data lines. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00014\" num=\"14\"><claim-text>14. The cache-memory apparatus as set forth in claim <b>13</b>, wherein when operating the cache-memory apparatus in the execution mode, the first state machine operates the cache-memory apparatus in one of a plurality of states including a trace segment head lookup state, a trace segment body lookup state, and a trace segment tail lookup state, for looking up trace segment heads, trace segment bodies, and trace segment tails respectively.</claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00015\" num=\"15\"><claim-text>15. The cache-memory apparatus as set forth in claim <b>14</b>, wherein the plurality of states further include a microcode sequencer lookup state for retrieving micro-ops of a macro instruction from a microcode sequencer.</claim-text></claim>"}, {"num": 16, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00016\" num=\"16\"><claim-text>16. The cache-memory apparatus as set forth in claim <b>13</b>, wherein when operating the cache memory apparatus in the trace segment build mode, the second state machine operates the cache-memory apparatus in one of a plurality of states including a fill buffer transfer state for transferring a trace segment member from a fill buffer into a data array, the first trace segment member being built along a predicted execution direction.</claim-text></claim>"}, {"num": 17, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00017\" num=\"17\"><claim-text>17. A processor comprising:</claim-text><claim-text>a) an execution unit; and </claim-text><claim-text>b) a cache memory coupled to the execution unit, the cache memory having a first state machine to operate the cache memory in an execution mode, wherein trace segment members of trace segments of instructions stored in a plurality of data lines are looked up and output, and a second state machine to operate, concurrent with the first state machine, the cache memory in a trace segment build mode wherein trace segment members of trace segments of instructions are built and stored into the data lines. </claim-text></claim>"}, {"num": 18, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6170038-B1-CLM-00018\" num=\"18\"><claim-text>18. A computer system comprising:</claim-text><claim-text>a) a processor including a cache memory having a first state machine to operate the cache memory in an execution mode, wherein trace segment members of trace segments of instructions stored in a plurality of data lines are looked up and output, and a second state machine to operate, concurrent with the first state machine, the cache memory in a trace segment build mode wherein trace segment members of trace segments of instructions are built and stored into the data lines; and </claim-text><claim-text>b) an input/output component coupled to the processor.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54443578\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This nonprovisional application is a continuation of nonprovisional application Ser. No. 08/956,375 filed Oct. 23, 1997, now U.S. Pat. No. 6,018,786, and titled \u201cTrace Based Instruction Caching\u201d.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates to the field of computer systems. More specifically, the present invention relates to the art of instruction caching.</p><p>2. Background Information</p><p>Historically, cached instructions are stored and organized in an instruction cache in accordance with the instructions' spatial relationship. Typically, each cache line stores instructions that are located spatially adjacent to each other in main memory. This spatial approach to caching instructions has at least one disadvantage in that it typically requires multiple cache lines to be accessed whenever execution of a program necessitates branching out from the middle of a cache line or branching into the middle of a cache line.</p><p>In U.S. Pat. No. 5,381,533, Peleg and Weiser disclosed an alternative approach to organizing cached instructions that overcome the above discussed and other disadvantages of the spatial approach. Under Peleg and Weiser's approach, cached instructions are stored and organized in accordance with the predicted order of execution. Basic blocks of instructions that are predicted to be sequentially executed are organized into trace segments and stored in the cache lines, one trace segment per cache line. The successor basic blocks stored into a cache line to form a trace segment are the branch target basic blocks if the branch instructions located at the end of the corresponding predecessor basic blocks are predicted to be taken; otherwise the successor basic blocks are the fall through basic blocks. The successive basic blocks within a cache line are retrieved sequentially by way of the first instruction of the first basic block, upon locating the first instruction.</p><p>Because the Peleg and Weiser approach does not provide for trace segments to span multiple cache lines, address matching to locate the next cache line must be performed each time the instruction supply stored in a cache line is exhausted. As a result, the Peleg and Weiser approach has at least the disadvantage of being limiting in the amount of instructions that can be supplied to the execution units of a processor over a period of time. This limitation is especially undesirable for modern processors with very high instruction execution rates.</p><p>Melvin et al., in their article entitled Hardware Support for Large Atomic Units in Dynamically Scheduled Machines, Proceedings of the 21st Annual Workshop on Microprogramming and Microarchitecture, Nov. 30-Dec. 2, 1988, San Diego, Calif., have proposed storing and organizing cached instructions by execution atomic units. Each cache entry (presumably, a cache line) is to comprise an execution atomic unit. An execution atomic unit is a smallest group of micro-ops that the processor can issue as an indivisible unit. Micro-ops are micro-instructions employed by the processor to implement macro-instructions. A fill unit is proposed for building the execution atomic units. The fill unit is to receive the micro-ops from a pre-fetch buffer and micro-op generator. There are at least two conditions under which the building of an execution atomic unit would terminate. The first is when a change of flow control is detected, and the second is when there are no longer enough empty micro-op slots in the fill unit for the next macro-instruction.</p><p>The Melvin approach suffers from a number of disadvantages including at least the disadvantages of allowing basically only one basic block per atomic execution unit, and having to cache all decoded micro-ops of a marco-instruction. The later is especially undesirable if the macro-instruction set includes complex macro-instructions that decode into a large number of micro-ops.</p><p>Thus, it is desirable to have a new approach for storing and organizing cached instructions, including decoded micro-ops, that has the advantages of Peleg et al., and Melvin et al., but without their disadvantages.</p><h4>SUMMARY OF THE INVENTION</h4><p>A cache memory is constituted with a data array and control logic. The data array includes a number of data lines, and the control logic operates to store a number of trace segments of instructions in the data lines, including trace segments that span multiple data lines.</p><p>In one embodiment, each trace segment includes one or more trace segment members having one or more instructions, with each trace segment member occupying one data line, and the data lines of a multi-line trace segment being sequentially associated (logically). Retrieval of the trace segment members of a multi-line trace segment is accomplished by first locating the data line storing the first trace segment member of the trace segment, and then successively locating the remaining data lines storing the remaining trace segment members based on the data lines' logical sequential associations. In one embodiment, the instructions are micro-ops of macro-instructions.</p><p>In one embodiment, a location address is maintained for each data line storing the first trace segment member of a trace segment. The data line storing the first trace segment member of a trace segment is located by address matching an access address against the location addresses maintained. In one embodiment, the address matching is performed using a subset of the address bits, and a matching data line is validated as to whether the data line indeed contains the first trace segment member being sought. In an N ways of S sets embodiment, storing of trace segment members is further qualified with a criteria of ensuring the address matching subset of the location addresses maintained in association with the various ways of a data line set, if any, is unique.</p><p>In one embodiment, at least partial control information sequentially associating each data line of a trace segment with its predecessor as well its successor data line in a logical manner is maintained, where applicable. The successive data lines of a multi-line trace segment are located, relying at least in part on the partial sequential association control information maintained. In one N ways of S sets embodiment, for each data line of a trace segment, a way index indexing into a way of the set of the predecessor data line, as well as a way index indexing into a way of the set of the successor data line is maintained, when applicable. Additionally, a predetermined set relationship between the successive data lines of a multi-line trace segment is maintained.</p><p>In one embodiment, a number of data line terminating conditions are employed to terminate caching of instructions of a trace segment in one data line, and continue caching of the instructions of the trace segment in another data line. In one embodiment, a number of trace segment terminating conditions are also employed to terminate caching of instructions as one trace segment, and continue caching of instructions as a new trace segment.</p><p>In one embodiment, the control logic includes two state machines operating the cache memory in an execution mode and a trace segment build mode. Each mode includes a number of operating states. Trace segments are built under the trace segment build mode, and their members are subsequently located and retrieved under the execution mode.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF DRAWINGS</h4><p>The present invention will be described by way of exemplary embodiments, but not limitations, illustrated in the accompanying drawings in which like references denote similar elements, and in which:</p><p>FIG. 1 is a block diagram illustrating a cache memory constituted and operated, in accordance with one embodiment of the present invention;</p><p>FIG. 2 is a block diagram illustrating the manner in which cached instructions are organized in the data array, in accordance with one embodiment;</p><p>FIGS. <b>3</b>-<b>5</b> illustrate the content of a tag entry, a data line and a micro-op, in accordance with one embodiment;</p><p>FIGS. <b>6</b>-<b>7</b> are two state diagrams illustrating the manner in which control logic operates the cache memory, in accordance with one embodiment;</p><p>FIGS. <b>8</b>-<b>9</b> are pipeline diagrams illustrating the manner in which cache reads are performed, in accordance with one embodiment;</p><p>FIGS. <b>10</b>-<b>11</b> are pipeline diagrams illustrating the manner in which coordination with a microcode sequencer is made, in accordance with one embodiment;</p><p>FIG. 12 is a pipeline diagram illustrating the manner in which coordination with a next instruction pointer (IP) generation circuitry is made, in accordance with one embodiment;</p><p>FIG. 13 is a pipeline diagram illustrating the manner in which fetching of micro-ops is performed, in accordance with one embodiment;</p><p>FIG. 14 is a pipeline diagram illustrating the manner in which cache writes are performed, in accordance with one embodiment;</p><p>FIG. 15 is a block diagram illustrating how tail maintenance is performed, when a trace segment is overwritten, in accordance with one embodiment; and</p><p>FIG. 16 is a block diagram illustrating a computer system suitable for practicing the present invention, in accordance with one embodiment.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>In the following description, various aspects of the present invention will be described. However, it will be apparent to those skilled in the art that the present invention may be practiced with only some or all aspects of the present invention. For purposes of explanation, specific numbers, materials and configurations are set forth in order to provide a thorough understanding of the present invention. However, it will also be apparent to one skilled in the art that the present invention may be practiced without the specific details. In other instances, well known features are omitted or simplified in order not to obscure the present invention.</p><p>Referring now to FIG. 1 a block diagram illustrating one embodiment of the cache memory of the present invention is shown. As illustrated, cache memory <b>10</b> of the present invention comprises data array <b>14</b> and control logic <b>26</b>, coupled to each other as shown. For the illustrated embodiment, cache memory <b>10</b> further comprises tag array <b>12</b>, immediate extractor <b>18</b>, and fill buffers <b>20</b>, coupled to each other and to the above enumerated elements as shown.</p><p>As in conventional cache memories, data array <b>14</b> comprises a plurality of data lines, and tag array <b>12</b> comprises a plurality of tag entries corresponding to the data lines. Together, the tag entries and the corresponding data lines form cache lines of cache memory <b>10</b>. However, unlike conventional cache memories, control logic <b>26</b> operates cache memory <b>10</b> to cache instructions in data array <b>14</b>, organizing the cached instructions by trace segments, e.g. <b>28</b>, including trace segments that span multiple data lines. Each trace segment includes one or more trace segment members of one or more instructions, with each trace segment member occupying one data line, and the data lines of a multi-line trace segment being sequentially associated (logically). Retrieval of the trace segment members of a multi-line trace segment is accomplished by first locating the data line storing the first trace segment member of the multi-line trace segment, and then successively locating the remaining data lines storing the remaining trace segment members based the data lines' logical sequential associations (to be described more fully below). In one embodiment, the instructions are decoded micro-ops of macro-instructions.</p><p>Those skilled in the art will also appreciate that by trace caching instructions or decoded micro-ops in this manner, i.e. allowing a trace segment to span multiple data lines, the amount of instructions that can be supplied to the execution units of a processor will be larger than the rate that can be sustained by the prior art approaches. Furthermore, by virtue of allowing multi-data line trace caching, the size of the program loops that will be automatically unrolled will be larger, effectively eliminating the need for a compiler to perform loop unrolling optimization to \u201cmaximize\u201d exploitation of processor performance. As a result, the generated code of programs will be more compact, which in turn will lead to memory space and instruction fetch time savings.</p><p>FIG. 2 illustrates trace segment <b>28</b> of the present invention in further detail, in the context of an exemplary 4-way 256 sets embodiment of data array <b>14</b> storing instructions that are decoded micro-ops of macro-instructions. Based on the descriptions to follow, those skilled in the art will appreciate that other sizes of set associate cache, as well as other non-set associate organizations may be employed to practice the present invention. Moreover, the instructions may be instructions of any kind. Furthermore, for ease of explanation, the first trace segment member of a trace segment will be referred to as a trace segment head, with the last trace segment member of a trace segment referred to as a trace segment tail, and the intermediate trace segment members referred to as trace segment bodies. In the degenerate case of a two-member trace segment, the second trace segment member is a trace segment body as well as a trace segment tail, and in the degenerate case of a single member trace segment, the singular trace segment member is a trace segment head, a trace segment body, as well as a trace segment tail at the same time.</p><p>For the illustrated embodiment, a location address is maintained for each data line storing the first trace segment member of a trace segment. The data line storing the first trace segment member of a trace segment is located by address matching an access address against the location addresses maintained. Furthermore, the address matching is performed using a subset of the address bits, and a matching data line is validated as to whether the data line indeed contains the first trace segment member being sought. Additionally, storing of trace segment members is further qualified with a criteria of ensuring the address matching subset of the location addresses maintained in association with the various ways of a data line set, if any, is unique.</p><p>In an alternate embodiment, other trace segment members are also associated with memory addresses. In yet another alternate embodiment, address matching is performed using all address bits.</p><p>For the illustrated embodiment, partial control information sequentially associating each data line storing a trace segment body or tail with its predecessor data line in a logical manner is maintained. Similarly, partial control information sequentially associating each data line storing a trace segment head or body with its successor data line in a logical manner is also maintained. The successive data lines of a multi-line trace segment are located, relying in part on the partial sequential association control information maintained. More specifically, for each data line storing a trace segment body or tail, a way index indexing into a way of the set of the predecessor data line is maintained, and for each data line storing a trace segment head or body, a way index indexing into a way of the set of the successor data line is maintained. Additionally, a predetermined set relationship between the successive data lines of a multi-line trace segment is maintained.</p><p>For the illustrated embodiment, a number of data line terminating conditions is employed to terminate caching of instructions of a trace segment in one data line, and continue caching of the instructions of the trace segment in another data line. Furthermore, a number of trace segment terminating conditions are also employed to terminate caching of instructions as one trace segment, and continue caching of instructions as a new trace segment.</p><p>For the illustrated embodiment, the data line terminating conditions include the encountering of a \u201ccomplex\u201d macro-instruction that decodes into a \u201clarge\u201d number of micro-ops. Only a predetermined number of micro-ops of the encountered complex macro-instruction are stored in the current data line, and the micro-ops of the next macro-instruction will be cached in a new data line. What constitutes a \u201ccomplex\u201d macro-instruction is application dependent. It will be appreciated by those skilled in the art that the present invention may be practiced with none or all decoded micro-ops of a macro-instruction being cached.</p><p>For the illustrated embodiment, the data line terminating conditions further include the encountering of a branch micro-op after a predetermined threshold of maximum allowable branch micro-ops per trace segment has been reached. The branch micro-op will be cached in a new data line. In one embodiment, the predetermined threshold is two. However, it will be appreciated by those skilled in the art, the present invention may be practiced with or without a predetermined thresholds for maximum allowable branch instructions or branch micro-ops per trace segment, and if one is employed, the threshold may be less than or greater than two.</p><p>For the illustrated embodiment, the data line terminating conditions further include the condition of not having enough room for all the micro-ops of a \u201cnew\u201d macro-instruction. The micro-ops of the \u201cnew\u201d macro-instruction will be cached in a new data line instead. In other words, for the illustrated embodiment, all micro-ops of a macro-instruction are cached in the same date line. However, it will be appreciated by those skilled in the art, the present invention may be practiced with micro-ops of a macro-instruction cached in more than one data line.</p><p>For the illustrated embodiment, the data line terminating conditions further include the condition of fill buffers <b>20</b> getting full. However, it will be appreciated by those skilled in the art, the present invention may be practiced with a data line taking multiple fills from a fill buffer.</p><p>For the illustrated embodiment, the trace segment terminating conditions include the encountering of an indirect branch macro-instruction, a call, or a return. However it will be appreciated by those skilled in the art, that with additional tracking, the present invention may be practiced with each trace segment having more than one indirect branch macro-instruction, a call, and/or a return.</p><p>For the illustrated embodiment, the trace segment terminating conditions further include the encountering of a branch misprediction notification, as well as an interrupt/exception.</p><p>For the illustrated embodiment, the trace segment terminating conditions further include the encountering of a \u201clong running\u201d trace segment having a number of micro-ops that exceeds a predetermined maximum allowable trace segment length in terms of number of micro-ops per trace segment. In one embodiment, the predetermined maximum is 64 sets. However, as will be appreciated by those skill in the art, the present invention may be practiced with or without a predetermined maximum, and if one is employed, the maximum value may be lesser than or greater than 64 sets.</p><p>FIG. 3 illustrates in further detail one embodiment of a tag entry in tag array <b>12</b> in accordance with the present invention. For the illustrated embodiment, tag entry <b>30</b> comprises bit <b>36</b> (Head) and bit <b>38</b> (Tail) for denoting whether the corresponding data line is a trace segment head and/or a trace segment tail. If neither bits are set, the corresponding data line is a trace segment body. If both bits are set, the corresponding data line is also a trace segment body, as well as the trace segment head and tail, i.e. the \u201csingular-member\u201d degenerate case described earlier. For the illustrated embodiment, tag entry <b>30</b> further comprises bits <b>34</b> (LA) for storing a linear address in the event that the corresponding data line is a trace segment head, and bit <b>32</b> (Valid) for denoting whether bits <b>34</b> are valid.</p><p>For the illustrated embodiment, tag entry <b>30</b> further comprises bits <b>40</b> (Next Way) and bits <b>42</b> (Prev Way) for facilitating sequential retrieval of the immediate successor trace segment member. More specifically, bits <b>40</b> and <b>42</b> specify the \u201cway\u201d location of the successor and predecessor data lines. For the illustrated embodiment, tag entry <b>30</b> does not include any bits for denoting the set identifications for the successor and predecessor data lines. For the illustrated embodiment, the set identification of the successor and predecessor data lines are always X+1 modulo S and X\u22121 modulo S, respectively, where X is the set identification of the current data line, and S is number of sets of data array <b>14</b>. In an alternate embodiment, additional bits may be employed to specify the set identifications of the successor and predecessor data lines; in other words, the successor and predecessor data lines may be located in any set.</p><p>For the illustrated embodiment, tag entry <b>30</b> further comprises bits <b>48</b> (uIP), bits <b>50</b> (NLIP), and bit <b>56</b> (uIP valid) for identifying the next micro-op instruction pointer (uIP), the next macro-instruction linear instruction pointer (NLIP), and whether uIP is valid. UIP is also used as an entry pointer into a read-only-memory (ROM) for micro-ops of an encountered complex macro-instruction. UIP valid, when set, serves to imply the fact that instruction caching in the corresponding data line was terminated as a result of the encounter of a complex macro-instruction. In one embodiment, NLIP is maintained for a trace segment tail only. In an alternate embodiment, NLIP is maintained for a trace segment head and a trace segment body, as well as a trace segment tail. Maintaining an NLIP with each trace segment member bas the advantage of not having to calculate it in real time, in the event it is needed while accessing the trace segment members, e.g. when the remaining trace segment is overwritten (to be explained more fully below).</p><p>Each tag entry is constructed when the corresponding data line is put together. More specifically, for the embodiment of cache memory <b>10</b> illustrated in FIG. 1, each tag entry is constructed in fill buffers <b>20</b>, while the corresponding data line is constructed. The manner in which each tag entry is constructed, and the usage of these fields will be described in more detail below.</p><p>FIGS. 4 and 5 illustrate in further detail one embodiment of a data line in data array <b>14</b>. As shown, for the illustrated embodiment, each data line <b>52</b> comprises six micro-ops (uOPs) <b>54</b>. Each uOP <b>54</b> comprises bit <b>58</b> (uOP valid) denoting whether the uOP is valid or not, and bits <b>70</b>-<b>76</b> (src<b>0</b>, src<b>1</b>, dest and uop code) denoting the source registers, the destination register, as well as the uOP code respectively. For the illustrated embodiment, each uOP <b>54</b> further comprises bits <b>60</b> (delta IP) denoting the delta increment for the macro-instruction's instruction pointer, bit <b>62</b> (delta IP valid) denoting whether delta IP denoted by bits <b>60</b> is valid or not, bits <b>64</b> (Br Tgt) specifying a branch target address if the uOP is a branch micro-op, and bits <b>68</b> (FOP code) denoting a floating point opcode if the uOP is a floating point operation. For the illustrated embodiment, this information is provided by a macro-instruction decoder. The purpose and usage of these fields are known in the art; accordingly they will not be further described.</p><p>It should be noted that some of the information described as being stored in tag entry <b>30</b> may be stored in the corresponding data line <b>52</b>, and vice versa. It should also be noted that the specific number of bit(s) used for each field can be selected according to various design considerations, and that the numbers specified herein are for ease of understanding the present invention.</p><p>Referring now back to FIG. 1, as described earlier, for the illustrated embodiment, cache memory <b>10</b> includes fill buffers <b>20</b>. Linear instruction pointer (LA) <b>34</b> of a trace segment head (stored in the corresponding tag entry <b>30</b>) is also routed to a branch address calculation circuitry for calculating branch addresses. Beside head LA <b>34</b>, NLIP <b>50</b> is routed to a next instruction pointer calculation circuitry for calculating the next instruction pointer, whose input includes the output of the branch address calculation circuitry. Micro-op instruction pointer (uIP) <b>48</b> is routed to a microcode sequencer for fetching the remaining uOPs of a complex macro-instruction.</p><p>Fill buffers <b>20</b> are used to build up the data lines along the predicted execution direction before they are transferred to tag and data array <b>12</b> and <b>14</b>, as the data width of the datapath from a memory to a decoder, and therefore from the decoder to fill buffers <b>20</b>, is smaller than the size of a data line. For the illustrated embodiment, fill buffers <b>20</b> include multiple buffers to facilitate constructing multiple data lines at the same time. Fill buffers <b>20</b> collect the address and control information as well as the decoded uOPs that get stored into the tag entries of tag array <b>12</b>, and corresponding data lines of data array <b>14</b> respectively.</p><p>Control logic <b>26</b>, in addition to tag and data arrays <b>12</b> and <b>14</b>, also controls the operation of fill buffers <b>20</b>. FIGS. 6 and 7 illustrate the manner in which control logic. <b>26</b> operates the embodiment of cache memory <b>10</b> illustrated in FIG. <b>1</b>. Control logic <b>26</b> operates cache memory <b>10</b> basically in one of two complementary modes, an execution mode, which is illustrated in FIG. 6, and a trace segment building mode, which is illustrated in FIG. <b>7</b>. In one embodiment, the two complementary modes operate exclusive of one another, whereas in another embodiment, with the provision of arbitration circuitry for shared resources, the two complementary modes may operate concurrently. In one embodiment, the two complementary modes are controlled by two corresponding state machines, an execution mode state machine and a trace segment building mode state machine. Of course, the present invention may be practiced with more or less state machines.</p><p>Execution mode state machine operates in one of seven states, idle state <b>78</b>, head lookup state <b>80</b>, body lookup state <b>82</b>, tail state <b>84</b>, microcode sequencer (MS) state <b>86</b>, body miss state <b>88</b>, and trace build state <b>90</b>. As shown, execution mode state machine starts off in idle state <b>78</b>, upon reset or upon detection by an execution unit of a uOP branch misprediction condition. Execution mode state machine transitions from idle state <b>78</b> to head lookup state <b>80</b> when control logic <b>26</b> is informed by an execution unit of a macro branch misprediction condition, or a fetch from LIP or it detects an end of trace segment build condition.</p><p>While in head lookup state <b>80</b>, execution mode state machine causes a trace segment head to be looked up by address matching a next IP, provided by the next IP calculation circuitry, against the memory addresses maintained for the trace segment heads. Execution mode state machine will cause the trace segment lookup process to be restarted with a \u201cnew\u201d next IP, if a macro branch misprediction condition is detected by an execution unit, prior to the completion of the current lookup. If the head lookup process proceeds to the end, the process will result in either a cache hit or cache miss.</p><p>If the head lookup process results in a cache hit, and the trace segment head is not also a trace segment tail, and the trace segment head data line did not end with a complex macro-instruction, execution mode state machine causes the micro-ops of the trace segment head to be output to the execution units, and transitions to body lookup state <b>82</b>. If the head lookup process results in a cache hit, the trace segment head is also a trace segment tail, and the trace segment head/tail data line did not end with a complex macro-instruction, execution mode state machine causes the micro-ops of the trace segment head/tail to be output to the execution units, and transitions the state machine to tail state <b>84</b>. If the head lookup process results in a cache hit, and the trace segment head data line ends with a complex macro-instruction, execution mode state machine causes the micro-ops of the trace segment head to be output to the execution units, and transitions the state machine to MS state <b>86</b>. If the lookup process results in a cache miss, cache memory <b>10</b> transitions the state machine to trace build state <b>90</b>.</p><p>While in body look up state <b>82</b>, execution mode state machine causes the next trace segment body to be looked up. For the illustrated embodiment, as described earlier, the next trace segment body is located in the data line of set X+1 modulo S in way W indexed by next way bits <b>40</b> of the current tag entry, where X is the current set, S is the number of sets of data array <b>14</b>, and W is the indexed way. In an alternate embodiment, the next trace segment body is located in the data line of set Y (denoted by a set identifier bit) in way W indexed by next way bits <b>40</b> of the current tag entry. Once located, execution mode state machine causes the uOPs of the trace segment body to be output to the execution units. Execution mode state machine remains in this state and continues to cause the next trace segment bodies to be looked up, and their uOPs to be output, upon locating them, as long as it is getting cache hits, and haven't reached the trace segment tail, nor encountering a data line ending with a complex macro-instruction, nor informed of a macro/micro branch misprediction condition by one of the execution units. For the illustrated embodiment, decoded micro-ops of a macro-instruction may include one or more branch micro-ops.</p><p>While in body look up state <b>82</b>, if control logic <b>26</b> is informed of the detection of a macro branch misprediction by one of the execution units, execution mode state machine aborts the body lookup process, and transitions back to head lookup state <b>80</b>. If the body lookup process results in a cache hit, and the data line does not end with a complex macro-instruction, but the data line is a trace segment tail, execution mode state machine transitions to tail state <b>84</b> after the uOPs of the trace segment tail has been output. If the body lookup process results in a cache hit, and the data line ended with a complex macro-instruction, execution mode state machine transitions to microcode sequencer (MS) state <b>86</b> after the uOPs of the data line has been output. If the body lookup process results in a cache miss, execution mode state machine transitions to body miss state <b>88</b>.</p><p>At tail state <b>84</b>, execution mode state machine unconditionally returns to head lookup state <b>80</b>. Similarly, at body miss state <b>88</b>, execution mode state machine also unconditionally returns to head lookup state <b>80</b>. It is possible to get a cache miss while looking up a trace segment body, because for the illustrated embodiment, the trace segment body may be overwritten by another trace segment, due to the manner in which replacement data line targets are selected (by way prediction, least recently used (LRU), and the like).</p><p>At MS state <b>86</b>, execution mode state machine allows the microcode sequencer to output the remaining uOPs of the data line ending complex macro-instruction. Execution mode state machine allows the microcode sequencer to do so until all remaining uOPs have been output, as long as it is not informed of the detection of a macro/micro branch misprediction condition by an execution unit. Execution mode state machine aborts the allowance if it is informed of the detection of a macro/micro branch misprediction condition by an execution unit. Execution mode state machine transitions back to head lookup state <b>80</b> if it is informed of the detection of a macro branch misprediction condition. Execution mode state machine transitions back to idle state <b>78</b> if it is informed of the detection of a micro branch misprediction condition.</p><p>However, if control logic <b>26</b> is informed by the microcode sequencer that it has finished outputting the remaining uOPs of the data line ending complex macro-instruction, execution mode state machine transitions to body lookup state <b>82</b> if the data line is not a trace segment tail, and to tail state <b>84</b> if the data line is a trace segment tail.</p><p>At trace build state <b>90</b>, execution mode state machine unconditionally transitions to idle state <b>78</b> on detection of a trace segment ending condition (denoted by the complementary trace segment build mode state machine). [In other words, trace build state <b>90</b> of execution mode is essentially a wait state.]</p><p>Trace segment build mode state machine operates in one of seven states, idle state <b>92</b>, fetch request state <b>94</b>, waiting for uOPs state <b>96</b>, bypassing uOPs state <b>98</b>, fill buffer write to arrays state <b>100</b>, MS and fill buffer write to arrays state <b>102</b>, and head lookup state <b>104</b>. As shown, trace segment build state machine starts off in idle state <b>92</b>, upon reset or upon detection by an execution unit of a macro/micro branch misprediction condition. Trace segment build mode state machine transitions from idle state <b>92</b> to fetch request state <b>94</b> when control logic <b>26</b> detects a need to issue an instruction fetch request, i.e. an access to cache memory <b>10</b> has resulted in a cache miss.</p><p>At fetch request state <b>94</b>, trace segment build mode state machine causes an instruction fetch request to be issued to an instruction fetch unit, and transitions to waiting for uOPs state <b>96</b>. At waiting for uOPs state <b>96</b>, trace segment build mode state machine remains in the state, until valid uOPs are provided to fill buffers <b>22</b>. At such time, trace segment build mode state machine transitions to bypass uOPs state <b>98</b>. At bypass uOPs state <b>98</b>, trace segment build mode state machine causes the valid uOPs from fill buffers <b>20</b> to be by-passed to the execution units, and continues to do so, until a data line terminating condition is encountered. If the data line terminating condition is the encountering of a complex macro-instruction, trace segment build mode state machine transitions to microcode sequencer and fill buffer write to tag and data arrays state <b>102</b>. For other data line terminating conditions, if the bypassed uOPs built up in fill buffers <b>20</b> are not cacheable, trace segment build mode state machine returns to waiting for uOPs state <b>96</b>, otherwise trace segment build mode state machine transitions from bypass uOPs state <b>98</b> to fill buffer write to arrays state <b>100</b>.</p><p>At fill buffer write to arrays state <b>100</b>, the completed data line is transferred into corresponding locations in tag and data arrays <b>12</b> and <b>14</b>. Recall that for the illustrated embodiment, the locations in data array <b>14</b> are the locations of one of the ways of set X+1 modulo S. Recall that for an alternate embodiment, the locations in data array <b>14</b> are the locations of one of the ways of an indexed set. In one embodiment, the way is selected by way prediction. Alternatively, an LRU approach may be used. Furthermore, when used in conjunction with the partial address matching approach for looking up a trace segment head, the LRU approach may be further qualified with the assurance that the tag matching subsets of the tag addresses for set X+1 module S (or an indexed set) will be unique. In other words, if a non-LRU way has a corresponding tag matching subset of its tag address that is the same as the tag matching subset of the tag address of the incoming data line, that non-LRU way is selected instead of the LRU way.</p><p>Upon writing the data line into tag and data arrays <b>12</b> and <b>14</b>, trace segment build mode state machine transitions back to waiting for uOPs state <b>96</b> if the data line that was just written into data array <b>14</b> is not a trace segment tail (i.e., a trace end condition was not encountered). If the written data line is a trace segment tail, trace segment build mode state machine transitions back to idle state <b>92</b> if next linear instruction pointer (NLIP) is not known, otherwise, trace segment build mode state machine transitions to head lookup state <b>104</b>.</p><p>At MS and fill buffer write to tag and data arrays state <b>102</b>, the completed data line is written into tag and data arrays <b>12</b> and <b>14</b> as described earlier for state <b>100</b>. However, trace segment build mode state machine does not transition out of the state until it has been signaled by the MS that the remaining micro-ops of the complex macro-instruction have all been output for the execution units. Upon completion of output by the MS, as in state <b>100</b>, trace segment build mode state machine transitions to waiting for uOPs state <b>96</b> if the written data line was not a trace segment tail (i.e., a trace end condition was not encountered). If the written data line is a trace segment tail, trace segment build mode state machine transitions to idle state <b>92</b> if the NLIP is unknown, and to the head lookup state <b>104</b> if the NLIP is known. Additionally, trace segment build mode state machine transitions to the idle state if control logic <b>26</b> receives notification that a micro-op branch misprediction has been detected by one of the execution units.</p><p>At head lookup state <b>104</b>, trace segment build mode state machine causes the trace segment head to be looked up based on the known NLIP (through complementary execution mode state machine). Trace segment build mode state machine transitions to idle state <b>92</b> if the lookup resulted in a hit (as informed by complementary execution mode state machine), otherwise, trace segment build mode state machine transitions to fetch request state <b>94</b>. From fetch request state <b>94</b>, trace segment build mode state machine transitions to the other states as described earlier.</p><p>Referring now to FIGS. <b>8</b>-<b>15</b>, wherein eight pipeline diagrams illustrating one embodiment each of the various pipeline stages employed to pipeline the various operations described earlier are shown. These diagrams will be referenced to aid describing one embodiment each of pipelining the various operations described earlier. The operations themselves will not be re-described. Refer to the earlier description for details. In each of these figures, the time period denoted by the vertical solid lines represents one clock period. The time periods denoted by the vertical dotted lines represent fractions of one clock period. Those skilled in the art will appreciate that other time division or pipeline approaches, including even a non-pipeline approach, may be employed to perform the above described operations.</p><p>FIG. 8 illustrates one embodiment of the pipeline stages employed to pipeline a trace segment head lookup operation. As illustrated, when looking up a trace segment head, tag array <b>12</b> is accessed during the first half of a clock period. Content address matching (CAM) lookup is performed during the first quarter of the clock period. For the illustrated embodiment, only predetermined subsets of the tag addresses bits are employed during the CAM lookup. In turn, data array <b>14</b> is accessed during the second and third quarters of the clock period, using the result of the CAM lookup performed during the first quarter of the clock period. Full tag matching is performed for the potential hit tag entry during the third quarter of the clock period. The retrieved data is then either allowed to be output or invalidated during the fourth quarter of the clock period, depending on the result of the full tag matching.</p><p>FIG. 9 illustrates one embodiment of the pipeline stages employed to pipeline a non-trace segment head lookup, i.e., a trace segment body/tail lookup. As illustrated, when looking up a trace segment body/tail, tag array <b>12</b> is accessed during the first half of a clock period. Concurrently, the way information retrieved from the predecessor trace segment head/body is obtained during the first quarter of the clock period. In turn, data array <b>14</b> is accessed during the second and third quarters of the clock period, using the obtained way information, and the predetermined set relationship. Full tag matching is then performed during the third quarter of the clock period. Recall that a trace segment body/tail may be overwritten. The retrieved data is then either allowed to be output or invalidated during the fourth quarter of the clock period, depending on the result of the full tag matching.</p><p>FIG. 10 illustrates one embodiment of the pipeline stages employed to pipeline uOP output switching to a microcode sequencer. Tag array <b>12</b> is accessed during the first half of a first clock period. During the second half of the first clock period, detection for the microcode sequencer switch condition is performed, i.e., to detect whether the current data line is terminated by a complex macro-instruction. If the condition is detected, the uOP IP, and a selection signal for use to select the uOPs output by the microcode sequencer are output. The read-only-memory (ROM) of the microcode sequencer is accessed in the first half of a second clock period, and any additional processing required by the microcode sequencer is performed in the second half of the second clock period. The output uOPs are then delivered to the next pipeline stage in a third clock period.</p><p>FIG. 11 illustrates one embodiment of the pipeline stages employed to pipeline uOP output switching from a microcode sequencer. The ROM of the microcode sequencer is accessed during the first half of a first clock period. Additional processing required by the microcode sequencer is performed in the second half of the first clock period, including detection for the switch back condition, i.e., the remaining uOPs of the data line terminating complex macro-instruction have been output. If the switch back condition is detected, the microcode sequencer outputs a \u201cswitch back\u201d signal to cache memory <b>10</b>. Tag array <b>12</b> is then accessed in the first half of a second clock period, and operations continue during the second half of the second clock period, as described earlier with reference to FIGS. 8 and 9.</p><p>FIG. 12 illustrates one embodiment of the pipeline stages employed to pipeline outputting of the NLIP to a next IP calculation circuitry. As described earlier, tag array <b>12</b> is accessed during the first half of a first clock period. During the second half of the first clock period, tag matching etc., including the detection of a trace ending condition are performed. Upon detection of a trace ending condition, the NLIP retrieved from tag array <b>12</b> for the current tag entry is output to the next IP calculation circuitry. The \u201cnew\u201d NLIP is returned in the second clock period (if no branch target is predicted).</p><p>FIG. 13 illustrates one embodiment of the various pipeline stages employed to pipeline a fetch request in response to a cache miss. As shown, the fetch request (referred to as a demand type) is issued in the next clock period following a cache miss resulted from a trace head lookup. For the illustrated embodiment, an instruction translation look-aside buffer (iTLB) is accessed during the next clock period.</p><p>FIG. 14 illustrates one embodiment of the various pipeline stages employed to pipeline writing of a completed data line into data array <b>14</b>. As shown, the \u201cLRU\u201d way of a current set X is determined in a first clock period. As described earlier, in an embodiment where partial tag matching is performed when looking up a trace segment head, the \u201cLRU\u201d way is qualified with the criteria of assuring unique partial tag addresses for all ways of a set. Concurrently, during the first clock period, the previous way of set X\u22121 modulo S for the selected way of current set X is determined. (Note that if the previous way of set X\u22121 modulo S for the selected way of set X is not null, it means the selected way of set X is currently used by another trace segment, which is about to be overwritten.) The uOPs are bypassed and written into data array <b>14</b> in a second and a third clock period as shown. Concurrently, during the second clock period, the LRU information for set X is updated. Finally, in a third clock period, the previous tail information in set X\u22121 modulo S is updated. If the next way of set X\u22121 modulo S for the selected way of set X is not null, the data line corresponding to the next set of set X\u22121 modulo S is established as the trace segment tail of the other trace segment. In an alternate embodiment, a trace segment member is unconditionally marked as the trace segment tail in the second clock period, and then corrected if necessary in the third clock period.</p><p>FIG. 15 illustrates the tail maintenance, and the overwritten scenario in further detail. Shown are two exemplary trace segments TS<b>1</b> and TS<b>2</b>. For ease of explanation, TS<b>1</b> includes trace segment body <b>102</b> and trace segment tail <b>104</b>, stored in set X\u22122 modulo S, way <b>0</b> and set X\u22121 modulo S, way <b>0</b>, respectively, whereas TS<b>2</b> includes trace segment bodies <b>106</b> and <b>108</b>, and trace segment tail <b>110</b>, stored in set X\u22122 modulo S, way <b>1</b>, set X\u22121 modulo S, way <b>1</b>, and set X, way <b>1</b>, respectively. Set X, way <b>1</b> was selected to store a new trace segment tail <b>112</b> for TS<b>1</b>. To properly associate set X, way <b>1</b> to TS<b>1</b>, the previous way field of set X, way <b>1</b> is modified to index to way <b>0</b>, as shown. The tail information of set X, way <b>1</b> was already set, thus no change is needed. Had set X, way <b>1</b> was not previously used to store a trace segment tail, the tail information will be set.</p><p>In addition, to properly establishing the data line of set X, way <b>1</b> as the trace segment tail of TS<b>1</b>, the next way field, and tail information of TS<b>1</b>'s previous tail stored in set X\u22121 modulo S, way <b>0</b> have to be updated. As shown, the next way field for set X\u22121 modulo S, way <b>0</b> is updated to index way <b>1</b>, and the tail information is cleared. Furthermore, in one embodiment, the control information for TS<b>2</b> has to be updated. As shown, the immediate predecessor to overwritten trace segment tail <b>110</b>, that is prior trace segment body <b>108</b> of TS<b>2</b> is converted into trace segment tail <b>108</b> for TS<b>2</b> instead. This is accomplished by setting the tail bit for set X\u22121 modulo S, way <b>1</b>.</p><p>FIG. 16 illustrates one embodiment of a computer system suitable for practicing the present invention. As shown, exemplary computer system <b>100</b> comprises one embodiment of cache memory <b>10</b>\u2032 of the present invention. Additionally, exemplary computer system <b>100</b> comprises a branch prediction unit <b>102</b> (which includes branch target address calculation circuitry as well as next IP calculation circuitry), microcode sequencer <b>104</b>, multiplexor <b>106</b>, execution units <b>108</b>, instruction table look-aside buffer (ITLB) <b>112</b>, and decoder <b>114</b>. These elements are coupled to each other as shown.</p><p>Cache memory <b>10</b>\u2032 is constituted and operates as earlier described. The rest of the other elements <b>102</b>-<b>114</b> are intended to represent a broad category of these elements found in the art. In one embodiment, all of these elements <b>10</b>\u2032 and <b>102</b>-<b>114</b> are disposed in the same processor integrated circuit (chip). In other embodiments, various ones of the elements may reside on separate chips.</p><p>While the method and apparatus of the present invention have been described in terms of the above illustrated embodiments, those skilled in the art will recognize that the invention is not limited to the embodiments described. The present invention can be practiced with modification and alteration within the spirit and scope of the appended claims. The description is thus to be regarded as illustrative instead of restrictive on the present invention.</p><p>Thus, a method and apparatus for trace based instruction caching has been described.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Robert F.", "last_name": "Krick", "name": ""}, {"first_name": "Glenn J.", "last_name": "Hinton", "name": ""}, {"first_name": "Michael D.", "last_name": "Upton", "name": ""}, {"first_name": "David J.", "last_name": "Sager", "name": ""}, {"first_name": "Chan W.", "last_name": "Lee", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTEL CORPORATION"}], "ipc_classes": [{"primary": true, "label": "G06F   9/26"}, {"primary": false, "label": "G06F  12/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711125"}, {"primary": false, "label": "711003"}, {"primary": false, "label": "711E1202"}, {"primary": false, "label": "712230"}], "ecla_classes": [{"label": "G06F  12/08B14"}], "cpc_classes": [{"label": "G06F  12/0875"}, {"label": "G06F  12/0875"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1997-10-23", "application_date": "1999-11-22", "family_members": [{"ucid": "US-6170038-B1", "titles": [{"lang": "EN", "text": "Trace based instruction caching"}]}]}