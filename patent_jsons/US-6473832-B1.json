{"patent_number": "US-6473832-B1", "publication_id": 73210114, "family_id": 23218275, "publication_date": "2002-10-29", "titles": [{"lang": "EN", "text": "Load/store unit having pre-cache and post-cache queues for low latency load memory operations"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11430007\" source=\"national office\"><p>A processor has pre-cache and post-cache buffers. The pre-cache (or LS1) buffer stores memory operations which have not yet probed the data cache. The post-cache (or LS2) buffer stores the memory operations which have probed the data cache. As a memory operation probes the data cache, it is moved from the LS1 buffer to the LS2 buffer. Since misses and stores which have probed the data cache do not reside in the LS1 buffer, the scan logic for selecting memory operations from the LS1 buffer to probe the data cache may be simple and low latency, allowing for the load latency to the data cache for load hits to be relatively low. Furthermore, since the memory operations which have probed the data cache have been removed from the LS1 buffer, the simple scan logic may support high performance features such as allowing hits to proceed under misses, etc. Additionally, since the LS2 buffer receives memory operations which have probed the data cache and thus may be waiting for retirement or fill data from memory, reprobing from the LS2 buffer may be less performance critical than probing from the LS1 buffer. Accordingly, the LS2 buffer may be made deeper than the LS1 buffer to queue numerous misses and/or stores. In this fashion, it may be possible to maximize the use of external bus bandwidth to service the misses.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50402508\"><p>A processor has pre-cache and post-cache buffers. The pre-cache (or LS1) buffer stores memory operations which have not yet probed the data cache. The post-cache (or LS2) buffer stores the memory operations which have probed the data cache. As a memory operation probes the data cache, it is moved from the LS1 buffer to the LS2 buffer. Since misses and stores which have probed the data cache do not reside in the LS1 buffer, the scan logic for selecting memory operations from the LS1 buffer to probe the data cache may be simple and low latency, allowing for the load latency to the data cache for load hits to be relatively low. Furthermore, since the memory operations which have probed the data cache have been removed from the LS1 buffer, the simple scan logic may support high performance features such as allowing hits to proceed under misses, etc. Additionally, since the LS2 buffer receives memory operations which have probed the data cache and thus may be waiting for retirement or fill data from memory, reprobing from the LS2 buffer may be less performance critical than probing from the LS1 buffer. Accordingly, the LS2 buffer may be made deeper than the LS1 buffer to queue numerous misses and/or stores. In this fashion, it may be possible to maximize the use of external bus bandwidth to service the misses.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00001\" num=\"1\"><claim-text>1. A processor comprising:</claim-text><claim-text>a data cache; and </claim-text><claim-text>a load/store unit coupled to said data cache, said load/store unit including: </claim-text><claim-text>first logic configured to select load and store memory operations to probe said data cache; </claim-text><claim-text>a buffer coupled to receive said load and store memory operations, said buffer comprising a plurality of entries; and </claim-text><claim-text>second logic configured to allocate entries from said plurality of entries for said load and store memory operations, said second logic allocating said entries responsive to said load and store memory operations probing said data cache. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00002\" num=\"2\"><claim-text>2. The processor as recited in <claim-ref idref=\"US-6473832-B1-CLM-00001\">claim 1</claim-ref> wherein said load/store unit further comprises a second buffer including a second plurality of entries, and wherein said first logic is configured to allocate entries from said second plurality of entries to said load and store memory operations in response to detecting said load and store memory operations within an instruction stream.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00003\" num=\"3\"><claim-text>3. The processor as recited in <claim-ref idref=\"US-6473832-B1-CLM-00002\">claim 2</claim-ref> further comprising a decode unit coupled to said load/store unit, wherein said decode unit is configured to decode instructions and to thereby detect said load and store memory operations corresponding to said instructions.</claim-text></claim>"}, {"num": 4, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00004\" num=\"4\"><claim-text>4. The processor as recited in <claim-ref idref=\"US-6473832-B1-CLM-00002\">claim 2</claim-ref> further comprising a plurality of address generation units, wherein said plurality of address generation units are configured to generate data addresses corresponding to said load and store memory operations, and wherein said second buffer is coupled to receive said data addresses and to associate said data addresses with corresponding load and store memory operations.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00005\" num=\"5\"><claim-text>5. The processor as recited in <claim-ref idref=\"US-6473832-B1-CLM-00004\">claim 4</claim-ref> wherein said first logic is configured to select a particular memory operation to probe said data cache concurrent with or subsequent to receiving a corresponding data address from one of said plurality of address generation units.</claim-text></claim>"}, {"num": 6, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00006\" num=\"6\"><claim-text>6. The processor as recited in <claim-ref idref=\"US-6473832-B1-CLM-00004\">claim 4</claim-ref> wherein said corresponding data address comprises a virtual address.</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00007\" num=\"7\"><claim-text>7. The processor as recited in <claim-ref idref=\"US-6473832-B1-CLM-00006\">claim 6</claim-ref> wherein said data cache is configured to translate said virtual address to a physical address concurrent with probing.</claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00008\" num=\"8\"><claim-text>8. The processor as recited in <claim-ref idref=\"US-6473832-B1-CLM-00007\">claim 7</claim-ref> wherein said buffer is coupled to receive said physical address and to associate said physical address with said particular memory operation.</claim-text></claim>"}, {"num": 9, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00009\" num=\"9\"><claim-text>9. The processor as recited in <claim-ref idref=\"US-6473832-B1-CLM-00006\">claim 6</claim-ref> wherein said virtual address comprises a linear address.</claim-text></claim>"}, {"num": 10, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00010\" num=\"10\"><claim-text>10. The processor as recited in <claim-ref idref=\"US-6473832-B1-CLM-00001\">claim 1</claim-ref> wherein said first logic is configure to select said load and store memory operations to probe said data cache in a program order.</claim-text></claim>"}, {"num": 11, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00011\" num=\"11\"><claim-text>11. The processor as recited in <claim-ref idref=\"US-6473832-B1-CLM-00001\">claim 1</claim-ref> wherein said data cache is configured to forward data for a first load memory operation which hits said data cache, said first load memory operation being subsequent to one or more load memory operations which miss said data cache and are stored in said buffer.</claim-text></claim>"}, {"num": 12, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00012\" num=\"12\"><claim-text>12. A method for performing memory operations in a processor, the method comprising:</claim-text><claim-text>selecting a memory operation to probe a data cache; </claim-text><claim-text>probing said data cache with said memory operation; and </claim-text><claim-text>storing said memory operation in a buffer of load and store memory operations responsive to said selection, each of said load and store memory operations in said buffer having probed said data cache. </claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00013\" num=\"13\"><claim-text>13. The method as recited in <claim-ref idref=\"US-6473832-B1-CLM-00012\">claim 12</claim-ref> wherein said storing comprises storing a load memory operation into said buffer independent of a hit/miss status of said load memory operation in said data cache.</claim-text></claim>"}, {"num": 14, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00014\" num=\"14\"><claim-text>14. The method as recited in <claim-ref idref=\"US-6473832-B1-CLM-00012\">claim 12</claim-ref> further comprising:</claim-text><claim-text>detecting said memory operation within an instruction stream; and </claim-text><claim-text>storing said memory operation into a second buffer. </claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00015\" num=\"15\"><claim-text>15. The method as recited in <claim-ref idref=\"US-6473832-B1-CLM-00014\">claim 14</claim-ref> further comprising deleting said memory operation from said second buffer independent of a hit/miss status of said load memory operation in said data cache.</claim-text></claim>"}, {"num": 16, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00016\" num=\"16\"><claim-text>16. The method as recited in <claim-ref idref=\"US-6473832-B1-CLM-00014\">claim 14</claim-ref> wherein said detecting comprises decoding an instruction corresponding to said memory operation.</claim-text></claim>"}, {"num": 17, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00017\" num=\"17\"><claim-text>17. The method as recited in <claim-ref idref=\"US-6473832-B1-CLM-00014\">claim 14</claim-ref> further comprising, subsequent to said detecting, receiving a data address into said buffer, said data address generated by an address generation unit.</claim-text></claim>"}, {"num": 18, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00018\" num=\"18\"><claim-text>18. The method as recited in <claim-ref idref=\"US-6473832-B1-CLM-00014\">claim 14</claim-ref> wherein said selecting is performed from said second buffer according to a program order of said instruction stream.</claim-text></claim>"}, {"num": 19, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00019\" num=\"19\"><claim-text>19. A computer system comprising:</claim-text><claim-text>a processor including: </claim-text><claim-text>a data cache; and </claim-text><claim-text>a load/store unit coupled to said data cache, said load/store unit including: </claim-text><claim-text>first logic configured to select load and store memory operations to probe said data cache; </claim-text><claim-text>a buffer coupled to receive said load and store memory operations, said buffer comprising a plurality of entries; and </claim-text><claim-text>second logic configured to allocate entries from said plurality of entries for said load and store memory operations, said second logic allocating said entries responsive to said load and store memory operations probing said data cache; and </claim-text><claim-text>an input/output (I/O) device for providing communication between said computer system and another computer system to which said I/O device is coupled. </claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00020\" num=\"20\"><claim-text>20. The computer system as recited in <claim-ref idref=\"US-6473832-B1-CLM-00019\">claim 19</claim-ref> wherein said I/O device comprises a modem.</claim-text></claim>"}, {"num": 21, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00021\" num=\"21\"><claim-text>21. The computer system as recited in <claim-ref idref=\"US-6473832-B1-CLM-00019\">claim 19</claim-ref> further comprising a second processor including:</claim-text><claim-text>a second data cache; and </claim-text><claim-text>a second load/store unit coupled to said second data cache, said second load/store unit including: </claim-text><claim-text>third logic configured to select load and store memory operations to probe said second data cache; </claim-text><claim-text>a second buffer coupled to receive said load and store memory operations, said second buffer comprising a second plurality of entries; and </claim-text><claim-text>fourth logic configured to allocate entries from said second plurality of entries for said load and store memory operations, said fourth logic allocating said entries responsive to said load and store memory operations probing said second data cache. </claim-text></claim>"}, {"num": 22, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00022\" num=\"22\"><claim-text>22. The processor as recited in <claim-ref idref=\"US-6473832-B1-CLM-00001\">claim 1</claim-ref> wherein said second logic is configured to allocate a first entry of said plurality of entries for a first load memory operation independent of a hit/miss status of said first load memory operation in said data cache.</claim-text></claim>"}, {"num": 23, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6473832-B1-CLM-00023\" num=\"23\"><claim-text>23. The processor as recited in <claim-ref idref=\"US-6473832-B1-CLM-00002\">claim 2</claim-ref> wherein said first logic is configured to delete a first load memory operation from said second buffer responsive to selecting said first load memory operation to probe said data cache and independent of a hit/miss status of said first load memory operation in said data cache.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53659716\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention is related to the field of processors and, more particularly, to load/store units within processors.</p><p>2. Description of the Related Art</p><p>Processors are more and more being designed using techniques to increase the number of instructions executed per second. Superscalar techniques involve providing multiple execution units and attempting to execute multiple instructions in parallel. Pipelining, or superpipelining, techniques involve overlapping the execution of different instructions using pipeline stages. Each stage performs a portion of the instruction execution process (involving fetch, decode, execution, and result commit, among others), and passes the instruction on to the next stage. While each instruction still executes in the same amount of time, the overlapping of instruction execution allows for the effective execution rate to be higher. Typical processors employ a combination of these techniques and others to increase the instruction execution rate.</p><p>As processors employ wider superscalar configurations and/or deeper instruction pipelines, memory latency becomes an even larger issue than it was previously. While virtually all modem processors employ one or more caches to decrease memory latency, even access to these caches is beginning to impact performance.</p><p>More particularly, as processors allow larger numbers of instructions to be in-flight within the processors, the number of load and store memory operations which are in-flight increases as well. As used here, an instruction is \u201cin-flight\u201d if the instruction has been fetched into the instruction pipeline (either speculatively or non-speculatively) but has not yet completed execution by committing its results (either to architected registers or memory locations). Additionally, the term \u201cmemory operation\u201d is an operation which specifies a transfer of data between a processor and memory (although the transfer may be accomplished in cache). Load memory operations specify a transfer of data from memory to the processor, and store memory operations specify a transfer of data from the processor to memory. Load memory operations may be referred to herein more succinctly as \u201cloads\u201d, and similarly store memory operations may be referred to as \u201cstores\u201d. Memory operations may be implicit within an instruction which directly accesses a memory operand to perform its defined function (e.g. arithmetic, logic, etc.), or may be an explicit instruction which performs the data transfer only, depending upon the instruction set employed by the processor. Generally, memory operations specify the affected memory location via an address generated from one or more operands of the memory operation. This address will be referred to herein in as a \u201cdata address\u201d generally, or a load address (when the corresponding memory operation is a load) or a store address (when the corresponding memory operation is a store). On the other hand, addresses which locate the instructions themselves within memory are referred to as \u201cinstruction addresses\u201d.</p><p>Since memory operations are part of the instruction stream, having more instructions in-flight leads to having more memory operations in-flight. Unfortunately, adding additional ports to the data cache to allow more operations to occur in parallel is generally not feasible beyond a few ports (e.g. 2) due to increases in both cache access time and area occupied by the data cache circuitry. Accordingly, relatively larger buffers for memory operations are often employed. Scanning these buffers for memory operations to access the data cache is generally complex and, accordingly, slow. The scanning may substantially impact the load memory operation latency, even for cache hits.</p><p>Additionally, data caches are finite storage for which some load and stores will miss. A memory operation is a \u201chit\u201d in a cache if the data accessed by the memory operation is stored in cache at the time of access, and is a \u201cmiss\u201d if the data accessed by the memory operation is not stored in cache at the time of access. When a load memory operation misses a data cache, the data is typically loaded into the cache. Store memory operations which miss the data cache may or may not cause the data to be loaded into the cache. Data is stored in caches in units referred to as \u201ccache lines\u201d, which are the minimum number of contiguous bytes to be allocated and deallocated storage within the cache. Since many memory operations are being attempted, it becomes more likely that numerous cache misses will be experienced. Furthermore, in many common cases, one miss within a cache line may rapidly be followed by a large number of additional misses to that cache line. These misses may fill, or come close to filling, the buffers allocated within the processor for memory operations. An efficient scheme for buffering memory operations is therefore needed.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by a processor having pre-cache and post-cache buffers as described herein. The pre-cache (or LS1) buffer stores memory operations which have not yet probed the data cache. The post-cache (or LS2) buffer stores the memory operations which have probed the data cache. As a memory operation probes the data cache, it is moved from the LS1 buffer to the LS2 buffer. Since misses and stores which have probed the data cache do not reside in the LS1 buffer, the scan logic for selecting memory operations from the LS1 buffer to probe the data cache may be simple and low latency, allowing for the load latency to the data cache for load hits to be relatively low. Furthermore, since the memory operations which have probed the data cache have been removed from the LS1 buffer, the simple scan logic may support high performance features such as allowing hits to proceed under misses, etc. Additionally, since the LS2 buffer receives memory operations which have probed the data cache and thus may be waiting for retirement or fill data from memory, reprobing from the LS2 buffer may be less performance critical than probing from the LS1 buffer. Accordingly, the LS2 buffer may be made deeper than the LS1 buffer to queue numerous misses and/or stores. In this fashion, it may be possible to maximize the use of external bus bandwidth to service the misses.</p><p>Broadly speaking, a processor is contemplated comprising a data cache and a load/store unit coupled thereto. The load/store unit includes first logic, second logic, and a buffer. The first logic is configured to select load and store memory operations to probe the data cache. The buffer is coupled to receive the load and store memory operations, and comprises a plurality of entries. The second logic is configured to allocate entries from the plurality of entries for the load and store memory operations, responsive to the load and store memory operations probing the data cache.</p><p>A method for performing memory operations in a processor is contemplated. A memory operation is selected to probe a data cache. The data cache is probed with the memory operation. The memory operation is stored in a buffer of load and store memory operations responsive to its selection. Each of the load and store memory operations in the buffer has probed the data cache.</p><p>Additionally, a computer system is contemplated, including a processor comprising a data cache and a load/store unit similar to the above-described processor. The computer system further includes an input/output (I/O) device. The input/output (I/O) device provides communication between the computer system and another computer system to which the I/O device is coupled.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of one embodiment of a processor.</p><p>FIG. 2 is a block diagram of one embodiment of a decode unit, a reservation station, a functional unit, a reorder buffer, a load/store unit, a data cache, and a bus interface unit shown in FIG. <b>1</b>.</p><p>FIG. 3 is a block diagram of one embodiment of a load/store unit.</p><p>FIG. 4 is a timing diagram illustrating one embodiment of a data cache access pipeline from a first buffer (LS1) illustrated in FIG. <b>3</b>.</p><p>FIG. 5 is a timing diagram illustrating one embodiment of a data cache access pipeline from a second buffer (LS2) illustrated in FIG. <b>3</b>.</p><p>FIG. 6 is a block diagram of one embodiment of an entry within LS1.</p><p>FIG. 7 is a block diagram of one embodiment of an entry within LS2.</p><p>FIG. 8 is a circuit diagram illustrating a portion of one embodiment of selection logic for LS1.</p><p>FIG. 9 is a circuit diagram illustrating a portion of one embodiment of selection logic for LS2.</p><p>FIG. 10 is a timing diagram illustrating data forwarding with and without a dependency link file.</p><p>FIG. 11 is a block diagram of one embodiment of a load/store unit and a data cache, with the load/store unit employing a dependency link file.</p><p>FIG. 12 is a timing diagram illustrating exemplary loads and stores performed by two processors.</p><p>FIG. 13 is a block diagram of a portion of one embodiment of a load/store unit including snoop hardware.</p><p>FIG. 14 is a flowchart illustrating operation of one embodiment of control logic shown in FIG. 13 during a snoop request.</p><p>FIG. 15 is a flowchart illustration operation of one embodiment of control logic shown in FIG. 13 during a reprobe operation.</p><p>FIG. 16 is a diagram illustrating an example of snoop resync operation.</p><p>FIG. 17 is a block diagram of a portion of one embodiment of a load/store unit including self-modifying code checking hardware.</p><p>FIG. 18 is a state machine which may be employed by one embodiment of the load/store unit shown in FIG. <b>17</b>.</p><p>FIG. 19 is a block diagram of a portion of one embodiment of an instruction cache which may be used with the load/store unit shown in FIG. <b>17</b>.</p><p>FIG. 20 is a flowchart illustrating operation of one embodiment of self-modifying code check control logic shown in FIG. <b>10</b>.</p><p>FIG. 21 is a block diagram of a portion of one embodiment of a load/store unit including exponential backoff.</p><p>FIG. 22 is a state machine which may be employed by one embodiment of a bus interface unit including exponential backoff.</p><p>FIG. 23 is a flowchart illustrating operation of one embodiment of control logic illustrated in FIG. <b>21</b>.</p><p>FIG. 24 is a timing diagram illustrating an example of exponential backoff.</p><p>FIG. 25 is a block diagram of one embodiment of a computer system including the processor shown in FIG. <b>1</b>.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</h4><h4>Processor Overview</h4><p>Turning now to FIG. 1, a block diagram of one embodiment of a processor <b>10</b> is shown. Other embodiments are possible and contemplated. As shown in FIG. 1, processor <b>10</b> includes a prefetch/predecode unit <b>12</b>, a branch prediction unit <b>14</b>, an instruction cache <b>16</b>, an instruction alignment unit <b>18</b>, a plurality of decode units <b>20</b>A-<b>20</b>C, a plurality of reservation stations <b>22</b>A-<b>22</b>C, a plurality of functional units <b>24</b>A-<b>24</b>C, a load/store unit <b>26</b>, a data cache <b>28</b>, a register file <b>30</b>, a reorder buffer <b>32</b>, an MROM unit <b>34</b>, and a bus interface unit <b>37</b>. Elements referred to herein with a particular reference number followed by a letter will be collectively referred to by the reference number alone. For example, decode units <b>20</b>A-<b>20</b>C will be collectively referred to as decode units <b>20</b>.</p><p>Prefetch/predecode unit <b>12</b> is coupled to receive instructions from bus interface unit <b>37</b>, and is further coupled to instruction cache <b>16</b> and branch prediction unit <b>14</b>. Similarly, branch prediction unit <b>14</b> is coupled to instruction cache <b>16</b>. Still further, branch prediction unit <b>14</b> is coupled to decode units <b>20</b> and functional units <b>24</b>. Instruction cache <b>16</b> is further coupled to MROM unit <b>34</b> and instruction alignment unit <b>18</b>. Instruction alignment unit <b>18</b> is in turn coupled to decode units <b>20</b>. Each decode unit <b>20</b>A-<b>20</b>C is coupled to load/store unit <b>26</b> and to respective reservation stations <b>22</b>A-<b>22</b>C. Reservation stations <b>22</b>A-<b>22</b>C are further coupled to respective functional units <b>24</b>A-<b>24</b>C. Additionally, decode units <b>20</b> and reservation stations <b>22</b> are coupled to register file <b>30</b> and reorder buffer <b>32</b>. Functional units <b>24</b> are coupled to load/store unit <b>26</b>, register file <b>30</b>, and reorder buffer <b>32</b> as well. Data cache <b>28</b> is coupled to load/store unit <b>26</b> and to bus interface unit <b>37</b>. Bus interface unit <b>37</b> is further coupled to an L2 interface to an L2 cache and a bus. Finally, MROM unit <b>34</b> is coupled to decode units <b>20</b>.</p><p>Instruction cache <b>16</b> is a high speed cache memory provided to store instructions. Instructions are fetched from instruction cache <b>16</b> and dispatched to decode units <b>20</b>. In one embodiment, instruction cache <b>16</b> is configured to store up to 64 kilobytes of instructions in a 2 way set associative structure having 32 byte lines (a byte comprises 8 binary bits). Alternatively, any other desired configuration and size may be employed. For example, it is noted that instruction cache <b>16</b> may be implemented as a fully associative, set associative, or direct mapped configuration.</p><p>Instructions are stored into instruction cache <b>16</b> by prefetch/predecode unit <b>12</b>. Instructions may be prefetched prior to the request thereof from instruction cache <b>16</b> in accordance with a prefetch scheme. A variety of prefetch schemes may be employed by prefetch/predecode unit <b>12</b>. As prefetch/predecode unit <b>12</b> transfers instructions to instruction cache <b>16</b>, prefetch/predecode unit <b>12</b> generates three predecode bits for each byte of the instructions: a start bit, an end bit, and a functional bit. The predecode bits form tags indicative of the boundaries of each instruction. The predecode tags may also convey additional information such as whether a given instruction can be decoded directly by decode units <b>20</b> or whether the instruction is executed by invoking a microcode procedure controlled by MROM unit <b>34</b>, as will be described in greater detail below. Still further, prefetch/predecode unit <b>12</b> may be configured to detect branch instructions and to store branch prediction information corresponding to the branch instructions into branch prediction unit <b>14</b>. Other embodiments may employ any suitable predecode scheme.</p><p>One encoding of the predecode tags for an embodiment of processor <b>10</b> employing a variable byte length instruction set will next be described. A variable byte length instruction set is an instruction set in which different instructions may occupy differing numbers of bytes. An exemplary variable byte length instruction set employed by one embodiment of processor <b>10</b> is the x86 instruction set.</p><p>In the exemplary encoding, if a given byte is the first byte of an instruction, the start bit for that byte is set. If the byte is the last byte of an instruction, the end bit for that byte is set. Instructions which may be directly decoded by decode units <b>20</b> are referred to as \u201cfast path\u201d instructions. The remaining x86 instructions are referred to as MROM instructions, according to one embodiment. For fast path instructions, the functional bit is set for each prefix byte included in the instruction, and cleared for other bytes. Alternatively, for MROM instructions, the functional bit is cleared for each prefix byte and set for other bytes. The type of instruction may be determined by examining the functional bit corresponding to the end byte. If that functional bit is clear, the instruction is a fast path instruction. Conversely, if that functional bit is set, the instruction is an MROM instruction. The opcode of an instruction may thereby be located within an instruction which may be directly decoded by decode units <b>20</b> as the byte associated with the first clear functional bit in the instruction. For example, a fast path instruction including two prefix bytes, a Mod R/M byte, and an immediate byte would have start, end, and functional bits as follows:</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"offset\" colwidth=\"42pt\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"126pt\"></colspec><thead><row><entry></entry><entry align=\"center\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry><entry>Start bits</entry><entry>10000</entry></row><row><entry></entry><entry>End bits</entry><entry>00001</entry></row><row><entry></entry><entry>Functional bits</entry><entry>11000</entry></row><row><entry></entry><entry align=\"center\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>According to one particular embodiment, early identification of an instruction that includes a scale-index-base (SIB) byte is advantageous for MROM unit <b>34</b>. For such an embodiment, if an instruction includes at least two bytes after the opcode byte, the functional bit for the Mod R/M byte indicates the presence of an SIB byte. If the functional bit for the Mod R/M byte is set, then an SIB byte is present. Alternatively, if the functional bit for the Mod R/M byte is clear, then an SIB byte is not present.</p><p>MROM instructions are instructions which are determined to be too complex for decode by decode units <b>20</b>. MROM instructions are executed by invoking MROM unit <b>34</b>. More specifically, when an MROM instruction is encountered, MROM unit <b>34</b> parses and issues the instruction into a subset of defined fast path instructions to effectuate the desired operation. MROM unit <b>34</b> dispatches the subset of fast path instructions to decode units <b>20</b>.</p><p>Processor <b>10</b> employs branch prediction in order to speculatively fetch instructions subsequent to conditional branch instructions. Branch prediction unit <b>14</b> is included to perform branch prediction operations. In one embodiment, branch prediction unit <b>14</b> employs a branch target buffer which caches up to two branch target addresses and corresponding taken/not taken predictions per 16 byte portion of a cache line in instruction cache <b>16</b>. The branch target buffer may, for example, comprise 2048 entries or any other suitable number of entries. Prefetch/predecode unit <b>12</b> determines initial branch targets when a particular line is predecoded. Subsequent updates to the branch targets corresponding to a cache line may occur due to the execution of instructions within the cache line. Instruction cache <b>16</b> provides an indication of the instruction address being fetched, so that branch prediction unit <b>14</b> may determine which branch target addresses to select for forming a branch prediction. Decode units <b>20</b> and functional units <b>24</b> provide update information to branch prediction unit <b>14</b>. Decode units <b>20</b> detect branch instructions which were not predicted by branch prediction unit <b>14</b>. Functional units <b>24</b> execute the branch instructions and determine if the predicted branch direction is incorrect. The branch direction may be \u201ctaken\u201d, in which subsequent instructions are fetched from the target address of the branch instruction. Conversely, the branch direction may be \u201cnot taken\u201d, in which subsequent instructions are fetched from memory locations consecutive to the branch instruction. When a mispredicted branch instruction is detected, instructions subsequent to the mispredicted branch are discarded from the various units of processor <b>10</b>. In an alternative configuration, branch prediction unit <b>14</b> may be coupled to reorder buffer <b>32</b> instead of decode units <b>20</b> and functional units <b>24</b>, and may receive branch misprediction information from reorder buffer <b>32</b>. A variety of suitable branch prediction algorithms may be employed by branch prediction unit <b>14</b>.</p><p>Instructions fetched from instruction cache <b>16</b> are conveyed to instruction alignment unit <b>18</b>. As instructions are fetched from instruction cache <b>16</b>, the corresponding predecode data is scanned to provide information to instruction alignment unit <b>18</b> (and to MROM unit <b>34</b>) regarding the instructions being fetched. Instruction alignment unit <b>18</b> utilizes the scanning data to align an instruction to each of decode units <b>20</b>. In one embodiment, instruction alignment unit <b>18</b> aligns instructions from three sets of eight instruction bytes to decode units <b>20</b>. Decode unit <b>20</b>A receives an instruction which is prior to instructions concurrently received by decode units <b>20</b>B and <b>20</b>C (in program order). Similarly, decode unit <b>20</b>B receives an instruction which is prior to the instruction concurrently received by decode unit <b>20</b>C in program order.</p><p>Decode units <b>20</b> are configured to decode instructions received from instruction alignment unit <b>18</b>. Register operand information is detected and routed to register file <b>30</b> and reorder buffer <b>32</b>. Additionally, if the instructions require one or more memory operations to be performed, decode units <b>20</b> dispatch the memory operations to load/store unit <b>26</b>. Each instruction is decoded into a set of control values for functional units <b>24</b>, and these control values are dispatched to reservation stations <b>22</b> along with operand address information and displacement or immediate data which may be included with the instruction. In one particular embodiment, each instruction is decoded into up to two operations which may be separately executed by functional units <b>24</b>A-<b>24</b>C.</p><p>Processor <b>10</b> supports out of order execution, and thus employs reorder buffer <b>32</b> to keep track of the original program sequence for register read and write operations, to implement register renaming, to allow for speculative instruction execution and branch misprediction recovery, and to facilitate precise exceptions. A temporary storage location within reorder buffer <b>32</b> is reserved upon decode of an instruction that involves the update of a register to thereby store speculative register states. If a branch prediction is incorrect, the results of speculatively-executed instructions along the mispredicted path can be invalidated in the buffer before they are written to register file <b>30</b>. Similarly, if a particular instruction causes an exception, instructions subsequent to the particular instruction may be discarded. In this manner, exceptions are \u201cprecise\u201d (i.e. instructions subsequent to the particular instruction causing the exception are not completed prior to the exception). It is noted that a particular instruction is speculatively executed if it is executed prior to instructions which precede the particular instruction in program order. Preceding instructions may be a branch instruction or an exception-causing instruction, in which case the speculative results may be discarded by reorder buffer <b>32</b>.</p><p>The instruction control values and immediate or displacement data provided at the outputs of decode units <b>20</b> are routed directly to respective reservation stations <b>22</b>. In one embodiment, each reservation station <b>22</b> is capable of holding instruction information (i.e., instruction control values as well as operand values, operand tags and/or immediate data) for up to five pending instructions awaiting issue to the corresponding functional unit. It is noted that for the embodiment of FIG. 1, each reservation station <b>22</b> is associated with a dedicated functional unit <b>24</b>. Accordingly, three dedicated \u201cissue positions\u201d are formed by reservation stations <b>22</b> and functional units <b>24</b>. In other words, issue position <b>0</b> is formed by reservation station <b>22</b>A and functional unit <b>24</b>A. Instructions aligned and dispatched to reservation station <b>22</b>A are executed by functional unit <b>24</b>A. Similarly, issue position <b>1</b> is formed by reservation station <b>22</b>B and functional unit <b>24</b>B; and issue position <b>2</b> is formed by reservation station <b>22</b>C and functional unit <b>24</b>C.</p><p>Upon decode of a particular instruction, if a required operand is a register location, register address information is routed to reorder buffer <b>32</b> and register file <b>30</b> simultaneously. Those of skill in the art will appreciate that the x86 register file includes eight 32 bit real registers (i.e., typically referred to as EAX, EBX, ECX, EDX, EBP, ESI, EDI and ESP). In embodiments of processor <b>10</b> which employ the x86 processor architecture, register file <b>30</b> comprises storage locations for each of the 32 bit real registers. Additional storage locations may be included within register file <b>30</b> for use by MROM unit <b>34</b>. Reorder buffer <b>32</b> contains temporary storage locations for results which change the contents of these registers to thereby allow out of order execution. A temporary storage location of reorder buffer <b>32</b> is reserved for each instruction which, upon decode, is determined to modify the contents of one of the real registers. Therefore, at various points during execution of a particular program, reorder buffer <b>32</b> may have one or more locations which contain the speculatively executed contents of a given register. If following decode of a given instruction it is determined that reorder buffer <b>32</b> has a previous location or locations assigned to a register used as an operand in the given instruction, the reorder buffer <b>32</b> forwards to the corresponding reservation station either: 1) the value in the most recently assigned location, or 2) a tag for the most recently assigned location if the value has not yet been produced by the functional unit that will eventually execute the previous instruction. If reorder buffer <b>32</b> has a location reserved for a given register, the operand value (or reorder buffer tag) is provided from reorder buffer <b>32</b> rather than from register file <b>30</b>. If there is no location reserved for a required register in reorder buffer <b>32</b>, the value is taken directly from register file <b>30</b>. If the operand corresponds to a memory location, the operand value is provided to the reservation station through load/store unit <b>26</b>.</p><p>In one particular embodiment, reorder buffer <b>32</b> is configured to store and manipulate concurrently decoded instructions as a unit. This configuration will be referred to herein as \u201cline-oriented\u201d. By manipulating several instructions together, the hardware employed within reorder buffer <b>32</b> may be simplified. For example, a line-oriented reorder buffer included in the present embodiment allocates storage sufficient for instruction information pertaining to three instructions (one from each decode unit <b>20</b>) whenever one or more instructions are dispatched by decode units <b>20</b>. By contrast, a variable amount of storage is allocated in conventional reorder buffers, dependent upon the number of instructions actually dispatched. A comparatively larger number of logic gates may be required to allocate the variable amount of storage. When each of the concurrently decoded instructions has executed, the instruction results are stored into register file <b>30</b> simultaneously. The storage is then free for allocation to another set of concurrently decoded instructions. Additionally, the amount of control logic circuitry employed per instruction is reduced because the control logic is amortized over several concurrently decoded instructions. A reorder buffer tag identifying a particular instruction may be divided into two fields: a line tag and an offset tag. The line tag identifies the set of concurrently decoded instructions including the particular instruction, and the offset tag identifies which instruction within the set corresponds to the particular instruction. It is noted that storing instruction results into register file <b>30</b> and freeing the corresponding storage is referred to as \u201cretiring\u201d the instructions. It is further noted that any reorder buffer configuration may be employed in various embodiments of processor <b>10</b>.</p><p>As noted earlier, reservation stations <b>22</b> store instructions until the instructions are executed by the corresponding functional unit <b>24</b>. An instruction is selected for execution if: (i) the operands of the instruction have been provided; and (ii) the operands have not yet been provided for instructions which are within the same reservation station <b>22</b>A-<b>22</b>C and which are prior to the instruction in program order. It is noted that when an instruction is executed by one of the functional units <b>24</b>, the result of that instruction is passed directly to any reservation stations <b>22</b> that are waiting for that result at the same time the result is passed to update reorder buffer <b>32</b> (this technique is commonly referred to as \u201cresult forwarding\u201d). An instruction may be selected for execution and passed to a functional unit <b>24</b>A-<b>24</b>C during the clock cycle that the associated result is forwarded. Reservation stations <b>22</b> route the forwarded result to the functional unit <b>24</b> in this case. In embodiments in which instructions may be decoded into multiple operations to be executed by functional units <b>24</b>, the operations may be scheduled separately from each other.</p><p>In one embodiment, each of the functional units <b>24</b> is configured to perform integer arithmetic operations of addition and subtraction, as well as shifts, rotates, logical operations, and branch operations. The operations are performed in response to the control values decoded for a particular instruction by decode units <b>20</b>. It is noted that a floating point unit (not shown) may also be employed to accommodate floating point operations. The floating point unit may be operated as a coprocessor, receiving instructions from MROM unit <b>34</b> or reorder buffer <b>32</b> and subsequently communicating with reorder buffer <b>32</b> to complete the instructions. Additionally, functional units <b>24</b> may be configured to perform address generation for load and store memory operations performed by load/store unit <b>26</b>. In one particular embodiment, each functional unit <b>24</b> may comprise an address generation unit for generating addresses and an execute unit for performing the remaining functions. The two units may operate independently upon different instructions or operations during a clock cycle.</p><p>Each of the functional units <b>24</b> also provides information regarding the execution of conditional branch instructions to the branch prediction unit <b>14</b>. If a branch prediction was incorrect, branch prediction unit <b>14</b> flushes instructions subsequent to the mispredicted branch that have entered the instruction processing pipeline, and causes fetch of the required instructions from instruction cache <b>16</b> or main memory. It is noted that in such situations, results of instructions in the original program sequence which occur after the mispredicted branch instruction are discarded, including those which were speculatively executed and temporarily stored in load/store unit <b>26</b> and reorder buffer <b>32</b>. It is further noted that branch execution results may be provided by functional units <b>24</b> to reorder buffer <b>32</b>, which may indicate branch mispredictions to functional units <b>24</b>.</p><p>Results produced by functional units <b>24</b> are sent to reorder buffer <b>32</b> if a register value is being updated, and to load/store unit <b>26</b> if the contents of a memory location are changed. If the result is to be stored in a register, reorder buffer <b>32</b> stores the result in the location reserved for the value of the register when the instruction was decoded. A plurality of result buses <b>38</b> are included for forwarding of results from functional units <b>24</b> and load/store unit <b>26</b>. Result buses <b>38</b> convey the result generated, as well as the reorder buffer tag identifying the instruction being executed.</p><p>Load/store unit <b>26</b> provides an interface between functional units <b>24</b> and data ache <b>28</b>. In one embodiment, load/store unit <b>26</b> is configured with a first load/store buffer having storage locations for data and address information for pending loads or stores which have not accessed data cache <b>28</b> and a second load/store buffer having storage locations for data and address information for loads and stores which have access data cache <b>28</b>. For example, the first buffer may comprise 12 locations and the second buffer may comprise <b>32</b> locations. Decode units <b>20</b> arbitrate for access to the load/store unit <b>26</b>. When the first buffer is full, a decode unit must wait until load/store unit <b>26</b> has room for the pending load or store request information. Load/store unit <b>26</b> also performs dependency checking for load memory operations against pending store memory operations to ensure that data coherency is maintained. A memory operation is a transfer of data between processor <b>10</b> and the main memory subsystem. Memory operations may be the result of an instruction which utilizes an operand stored in memory, or may be the result of a load/store instruction which causes the data transfer but no other operation. Additionally, load/store unit <b>26</b> may include a special register storage for special registers such as the segment registers and other registers related to the address translation mechanism defined by the x86 processor architecture.</p><p>Data cache <b>28</b> is a high speed cache memory provided to temporarily store data being transferred between load/store unit <b>26</b> and the main memory subsystem. In one embodiment, data cache <b>28</b> has a capacity of storing up to 64 kilobytes of data in an two way set associative structure. It is understood that data cache <b>28</b> may be implemented in a variety of specific memory configurations, including a set associative configuration, a fully associative configuration, a direct-mapped configuration, and any suitable size of any other configuration.</p><p>In one particular embodiment of processor <b>10</b> employing the x86 processor architecture, instruction cache <b>16</b> and data cache <b>28</b> are linearly addressed and physically tagged. The linear address is formed from the offset specified by the instruction and the base address specified by the segment portion of the x86 address translation mechanism. Linear addresses may optionally be translated to physical addresses for accessing a main memory. The linear to physical translation is specified by the paging portion of the x86 address translation mechanism. The physical address is compared to the physical tags to determine a hit/miss status.</p><p>Bus interface unit <b>37</b> is configured to communicate between processor <b>10</b> and other components in a computer system via a bus. For example, the bus may be compatible with the EV-6 bus developed by Digital Equipment Corporation. Alternatively, any suitable interconnect structure may be used including packet-based, unidirectional or bidirectional links, etc. An optional L2 cache interface may be employed as well for interfacing to a level two cache.</p><p>Load/Store Unit</p><p>A more detailed discussion of one embodiment of load/store unit <b>26</b> is next provided. Other embodiments are possible and contemplated. FIG. 2 illustrates load/store unit <b>26</b>, reorder buffer <b>32</b>, data cache <b>28</b>, bus interface unit (BIU) <b>37</b>, decode unit <b>20</b>A, reservation station <b>22</b>A, and functional unit <b>24</b>A to highlight certain interconnection therebetween according to one embodiment of processor <b>10</b>. Other embodiments may employ additional, alternative, or substitute interconnect as desired. Interconnect between decode units <b>20</b>B-<b>20</b>C, reservation stations <b>22</b>B-<b>22</b>C, functional units <b>24</b>B-<b>24</b>C, and other units shown in FIG. 2 may be similar to that shown in FIG. <b>2</b>.</p><p>Decode unit <b>20</b>A receives an instruction from instruction alignment unit <b>18</b> and decodes the instruction. Decode unit <b>20</b>A provides the decoded instruction to reservation station <b>22</b>A, which stores the decoded instruction until the instruction is selected for execution. Additionally, if the instruction specifies a load or store memory operation, decode unit <b>20</b>A signals load/store unit <b>26</b> via L/S lines <b>46</b>A. Similar signals from decode units <b>20</b>B-<b>20</b>C may be received by load/store unit <b>26</b> as well. L/S lines <b>46</b>A indicate whether a load memory operation, a store memory operation, or both are specified by the instruction being decoded. For example, L/S lines <b>46</b>A may comprise a load line and a store line. If no memory operation is specified, then signals on both lines re deasserted. The signal on the load line is asserted if a load memory operation is specified, and similarly the signal on the store line is asserted if a store memory operation is specified. Both signals are asserted if both a load memory operation and a store memory operation are specified. In response to signals on L/S lines <b>46</b>A, load/store unit <b>26</b> allocates an entry in a load/store buffer included therein to store the corresponding memory operation.</p><p>In addition to the above, decode unit <b>20</b>A provides information to reorder buffer <b>32</b> about the instruction being decoded. Reorder buffer <b>32</b> receives the information (as well as similar information from other decode units <b>20</b>B-<b>20</b>C) and allocates reorder <b>10</b> buffer entries in response thereto. The allocated reorder buffer entries are identified by reorder buffer tags, which are transmitted to load/store unit <b>26</b> upon an instruction tags bus <b>48</b>. Instruction tags bus <b>48</b> may be configured to transmit a tag for each possible instruction (e.g. three in the present embodiment, one from each of decode units <b>20</b>A-<b>20</b>C). Alternatively, in an embodiment employing the line-oriented structure described above, reorder buffer <b>32</b> may be configured to transmit a line tag for the line, and load/store unit <b>26</b> may augment the line tag with the offset tag of the issue position which is signalling a particular load or store.</p><p>Reorder buffer <b>32</b> is further configured to perform dependency checking for register operands of the instruction. The register operands are identified in the instruction information transmitted by decode units <b>20</b>. For store memory operations, the store data is a source operand which load/store unit <b>26</b> receives in addition to the store address. Accordingly, reorder buffer <b>32</b> determines the instruction which generates the store data for each store memory operation and conveys either the store data (if it is available within reorder buffer <b>32</b> or register file <b>30</b> upon dispatch of the store memory operation) or a store data tag for the store data on a store data/tags bus <b>50</b>. If the instruction corresponding to the store memory operation is an explicit store instruction which stores the contents of a register to memory, the instruction tag of the instruction which generates the store data (or the store data, if it is available) is conveyed. On the other hand, the instruction itself generates the store data if the instruction includes the store memory operation as an implicit operation. In such cases, reorder buffer <b>32</b> provides the instruction tag of the instruction as the store data tag.</p><p>Although not illustrated in FIG. 2 for simplicity in the drawing, reservation station <b>22</b>A receives operand tags and/or data for the instruction from reorder buffer <b>32</b> as well. Reservation station <b>22</b>A captures the operand tags and/or data and awaits delivery of any remaining operand data (identified by the operand tags) from result buses <b>38</b>. Once an instruction has received its operands, it is eligible for execution by functional unit <b>24</b>A. More particularly, in the embodiment shown, functional unit <b>24</b>A includes an execution unit (EXU) <b>40</b> and an address generation unit (AGU) <b>42</b>. Execution unit <b>40</b> performs instruction operations (e.g. arithmetic and logic operations) to generate results which are forwarded on result bus <b>38</b>A (one of result buses <b>38</b>) to load/store unit <b>26</b>, reservation stations <b>22</b>, and reorder buffer <b>32</b>. AGU <b>42</b> generates data addresses for use by a memory operation or operations specified by the instruction, and transmits the data addresses to load/store unit <b>26</b> via address bus <b>44</b>A. It is noted that other embodiments may be employed in which AGU <b>42</b> and execution unit <b>40</b> share result bus <b>38</b>A and in which functional unit <b>24</b>A includes only an execution unit which performs address generation and other instruction execution operations. Load/store unit <b>26</b> is further coupled to receive result buses and address buses from the execution units and AGUs within other functional units <b>24</b>B-<b>24</b>C as well.</p><p>Since the embodiment shown employs AGU <b>42</b>, reservation station <b>22</b>A may select the address generation portion of an instruction for execution by AGU <b>42</b> once the operands used to form the address have been received but prior to receiving any additional operands the instruction may have. AGU <b>42</b> transmits the generated address to load/store unit <b>26</b> on address bus <b>44</b>A, along with the instruction tag of the instruction for which the data address is generated. Accordingly, load/store unit <b>26</b> may compare the tag received on address bus <b>44</b>A to the instruction tags stored in the load/store buffer to determine which load or store the data address corresponds to.</p><p>Load/store unit <b>26</b> monitors the result tags provided on result buses <b>38</b> to capture store data for store memory operations. If the result tags match a store data tag within load/store unit <b>26</b>, load/store unit <b>26</b> captures the corresponding data and associates the data with the corresponding store instruction.</p><p>Load/store unit <b>26</b> is coupled to data cache <b>28</b> via a data cache interface. Load/store unit <b>26</b> selects memory operations to probe data cache <b>28</b> via the data cache interface, and receives probe results from the data cache interface. Generally speaking, a \u201cprobe\u201d of the data cache for a particular memory operation comprises transmitting the data address of the particular memory operation to data cache <b>28</b> for data cache <b>28</b> to determine if the data address hits therein. Data cache <b>28</b> returns a probe result (e.g. a hit/miss indication) to load/store unit <b>26</b>. In addition, if the particular memory operation is a load and hits, data cache <b>28</b> forwards the corresponding load data on a result bus <b>38</b>D to reservation stations <b>22</b>, reorder buffer <b>32</b>, and load/store unit <b>26</b>. In one embodiment, data cache <b>28</b> includes two ports and may thus receive up to 2 probes concurrently. Data cache <b>28</b> may, for example, employ a banked configuration in which cache lines are stored across at least two banks and two probes may be serviced concurrently as long as they access different banks. In one particular embodiment, data cache <b>28</b> may employ 8 banks. Various embodiments of the data cache interface are described in further detail below.</p><p>Data cache <b>28</b> is configured to allocate cache lines in response to probes that miss, and communicates with bus interface unit <b>37</b> to fetch the missing cache lines. Additionally, data cache <b>28</b> transmits evicted cache lines which have been modified to us interface unit <b>37</b> for updating main memory.</p><p>Bus interface unit <b>37</b> is coupled to data cache <b>28</b> and load/store unit <b>26</b> via a snoop interface <b>52</b> as well. Snoop interface <b>52</b> may be used by bus interface unit <b>37</b> to determine if coherency activity needs to be performed in response to a snoop operation received from the bus. Generally, a \u201csnoop operation\u201d is an operation performed upon a bus for the purpose of maintaining memory coherency with respect to caches connected to the bus (e.g. within processors). When coherency is properly maintained, a copy of data corresponding to a particular memory location and stored in one of the caches is consistent with the copies stored in each other cache. The snoop operation may be an explicit operation, or may be an implicit part of an operation performed to the address of the particular memory location. Generally, the snoop operation specifies the address to be snooped (the \u201csnoop address\u201d) and the desired state of the cache line if the address is stored in the cache. Bus interface unit transmits a snoop request via snoop interface <b>52</b> to data cache <b>28</b> and load/store unit <b>26</b> to perform the snoop operation.</p><p>Reorder buffer <b>32</b> manages the retirement of instructions. Reorder buffer <b>32</b> communicates with load/store unit <b>26</b> via retire interface <b>54</b> to identify instructions either being retired or ready for retirement. For example, in one embodiment stores do not update data cache <b>28</b> (or main memory) until they are retired. Additionally, certain load instruction may be restricted to be performed non-speculatively. Reorder buffer <b>32</b> may indicate memory operations which are retired or retireable to load/store unit <b>26</b> via retirement interface <b>54</b>. Accordingly, the instruction information provided by decode units <b>20</b> to reorder buffer <b>32</b> for each instruction may include an indication of whether or not the instruction includes a load or store operation. Load/store unit <b>26</b> may return an acknowledgment to reorder buffer <b>32</b> that a particular memory operation is logged as retired, and reorder buffer <b>32</b> may subsequently retire the corresponding instruction.</p><p>Since the load/store buffer may become full at times, load/store unit <b>26</b> may employ a flow control mechanism to stall subsequent memory operations at decode units until sufficient entries are freed (via completion of earlier memory operations) within the load/store buffer for the subsequent memory operations. For example, load/store unit <b>26</b> may broadcast a count of the number of free entries to decode units <b>20</b>, which may stall if the count indicates that insufficient entries are available for the memory operations of instructions being decoded. According to one particular embodiment, the instructions being concurrently decoded by decode units <b>20</b> move to reservation stations <b>22</b> in lockstep (so that a line may be allocated in reorder buffer <b>32</b> for the instructions, as described above with respect to FIG. <b>1</b>). In such an embodiment, decode units <b>20</b> may stall until sufficient entries are available for all memory operations within the set of concurrently decoded instructions. Alternatively, load/store unit <b>26</b> may employ a stall signal for stalling subsequent memory operations until buffer entries are available. Any suitable flow control mechanism may be used.</p><p>Turning now to FIG. 3, a block diagram of one embodiment of load/store unit <b>26</b> is shown. Other embodiments are possible and contemplated. In the embodiment of FIG. 3, load/store unit <b>26</b> includes a first load/store buffer (LS1 buffer) <b>60</b>, a second load/store buffer (LS2 buffer) <b>62</b>, an LS1 control logic <b>64</b>, an LS2 control logic <b>66</b>, a temporary buffer <b>68</b>, segment adders <b>70</b>, a port <b>0</b> multiplexor (mux) <b>72</b>, a port <b>1</b> mux <b>74</b>, and an LS2 reprobe mux <b>76</b>. Segment adders <b>70</b> are coupled to receive data addresses from AGUs <b>42</b> within functional units <b>24</b>A-<b>24</b>C (e.g. address bus <b>44</b>AA, part of address bus <b>44</b>A shown in FIG. 2, conveys the data address from AGU <b>42</b> within functional unit <b>24</b>A). Muxes <b>70</b> and <b>72</b> are coupled to receive the data addresses from AGUs <b>42</b> and the outputs of segment adders <b>70</b>, as well as being coupled to LS1 buffer <b>60</b>. Mux <b>72</b> also receives an input from LS2 reprobe mux <b>76</b>. Furthermore, LS1 buffer <b>60</b> is coupled to segment adders <b>70</b>, LS1 control logic <b>64</b>, temporary buffer <b>68</b>, instruction tags bus <b>48</b>, store data/tags bus <b>50</b>, and results buses <b>38</b><i>a </i>(the result data portion of result buses <b>38</b>). LS1 control logic <b>64</b> is coupled to muxes <b>72</b> and <b>74</b> and to LS2 control logic <b>66</b>. Furthermore, LS1 control logic <b>64</b> is coupled to receive address tags from AGUs <b>42</b> (e.g. address tag us <b>44</b>AB, part of address tag bus <b>44</b>A shown in FIG. 2, conveys the address tag from GU <b>42</b> within functional unit <b>24</b>A), result tags via result tags buses <b>38</b><i>b </i>(the result tag portion of result buses <b>38</b>), and L/S lines <b>46</b> (including L/S lines <b>46</b>A from decode unit <b>20</b>A). Temporary buffer <b>68</b> and LS2 buffer <b>62</b> are coupled to results buses <b>38</b><i>a </i>and result tags buses <b>38</b>b. LS2 buffer <b>62</b> is further coupled to receive a miss address buffer (MAB) tag on a MAB tag bus <b>78</b> and a physical address on a physical address bus <b>80</b> from data cache <b>28</b>. LS2 buffer <b>62</b> is still further coupled to mux <b>76</b>, LS2 control logic <b>66</b>, and temporary buffer <b>68</b>. LS2 control logic <b>66</b> is further coupled to mux <b>76</b>, retire interface <b>54</b>, result tags buses <b>38</b>b, snoop interface <b>52</b>, hit/miss signals <b>82</b> from data cache <b>28</b>, and a fill tag bus <b>84</b> from bus interface unit <b>37</b>.</p><p>Generally speaking, load/store unit <b>26</b> includes a pre-cache buffer (LS1 buffer <b>60</b>) and a post-cache buffer (LS2 buffer <b>62</b>). Memory operations are allocated into LS1 buffer <b>60</b> upon dispatch within processor <b>10</b>, and remain within LS1 buffer <b>60</b> until selected to probe data cache <b>28</b>. Subsequent to probing data cache <b>28</b>, the memory operations are moved to LS2 buffer <b>62</b> independent of the probe status (e.g. hit/miss, etc.). Since LS1 buffer <b>60</b> stores memory operations which have yet to probe data cache <b>28</b> and the memory operations are removed from LS1 buffer <b>60</b> upon probing data cache <b>28</b>, a relatively simple scanning scheme may be used to select memory operations to probe data cache <b>28</b>. Since the scheme is simple, it may be performed rapidly and may aid in keeping load latency low for loads which hit data cache <b>28</b>. Additionally, since memory operations are deleted from LS1 after probing data cache <b>28</b>, the size (i.e. number of entries) of LS1 buffer <b>60</b> may be relatively small as compared to the total number of memory operations which may be in-flight.</p><p>Memory operations which miss may subsequently be selected through LS2 reprobe mux <b>76</b> and port <b>0</b> mux <b>72</b> to reprobe data cache <b>28</b>. The term \u201creprobe\u201d, as used herein, refers to probing a cache for a second or subsequent attempt after the first probe for a particular memory operation. Additionally, store memory operations may be held in LS2 buffer <b>62</b> until the stores are in condition for retirement. LS2 buffer <b>62</b> may be made deeper than LS1 buffer <b>60</b>, allowing for large numbers of misses to be stored therein. Since, in many cases, memory operations accessing the same cache line tend to be near each other in an instruction stream, a relatively large number of misses to the same cache line may be queued in LS2 buffer <b>62</b>. Subsequent memory operations which hit data cache <b>28</b> may then be selected from LS1 buffer <b>60</b> and serviced. Average cache bandwidth may thereby be increased. Furthermore, by allowing the queuing of numerous cache misses in LS2, it may be possible in many cases to keep bus interface unit <b>37</b> busy servicing numerous cache line fetch requests from data cache <b>28</b>, thereby maximizing use of external bus bandwidth.</p><p>In response to signals on L/S lines <b>46</b>, LS1 control logic <b>64</b> allocates entries within LS1 buffer <b>60</b> to the identified load and store memory operations. The respective instruction tags and store data/tags (if applicable) are received into the allocated entries by LS1 buffer <b>60</b> under the control of LS1 control logic <b>64</b>. Subsequently, the corresponding data addresses are received from the AGUs (identified by the address tags received by LS1 control logic <b>64</b>) and are stored into the allocated entries.</p><p>A memory operation which has received its address becomes eligible to probe data cache <b>28</b>. LS1 control logic <b>64</b> scans the LS1 buffer entries for memory operations to probe data cache <b>28</b>, and generates selection controls for port <b>0</b> mux <b>72</b> and port <b>1</b> mux <b>74</b>. Accordingly, up to two memory operations may probe data cache <b>28</b> per clock cycle in the illustrated embodiment. According to one particular implementation, LS1 control logic <b>64</b> selects memory operations for probing data cache <b>28</b> in program order. Accordingly, LS1 control logic <b>64</b> may be configured to limit scanning to the oldest memory operations within LS1 buffer <b>60</b>. The \u201cprogram order\u201d of the memory operations is the order the instructions would be executed in if the instructions were fetched and executed one at a time. Furthermore, the program order of instructions speculatively fetched (according to branch predictions, for example) is the order the instructions would be executed in as stated above under the assumption that the speculation is correct. Instructions which are prior to other instructions in the program order are said to be older than the other instructions. Conversely, instructions which are subsequent to other instructions in program order are said to be younger than the other instructions. It is noted that other implementations may select memory operations to probe data cache <b>28</b> out of order, as desired.</p><p>LS1 control logic <b>64</b> is configured to select a memory operation to probe data cache <b>28</b> as the data address is received (provided, in the present embodiment, that the memory operation is within an entry being scanned by LS1 control logic <b>64</b>). If the address tags received from the AGUs <b>42</b> match an instruction tag of an otherwise selectable memory operation, LS1 control logic <b>64</b> selects the corresponding data address received from the AGU <b>42</b> via one of muxes <b>72</b> and <b>74</b>.</p><p>While the data address may be selected for probing as it is provided to load/store unit <b>26</b>, the data address is also provided to one of segment adders <b>70</b>. Segment adders <b>70</b> are included in the present embodiment to handle the segmentation portion of the x86 addressing scheme. Embodiments which do not employ the x86 instruction set architecture may eliminate segment adders <b>70</b>. Generally, AGUs <b>42</b> generate a virtual address corresponding to the memory operation. The virtual address is the address generated by adding the address operands of an instruction. The virtual address is translated through an address translation mechanism specified by the instruction set architecture employed by processor <b>10</b> to a physical address. The physical address identifies a memory location within main memory. In the x86 architecture, a two-tiered translation scheme is defined from a logical address (or virtual address) to a linear address through a segmentation scheme and then to the physical address through a paging scheme. Since AGUs <b>42</b> add the address operands of the instruction, the data address provided by the AGUs is a logical address. However, modern instruction code is generally employing a \u201cflat addressing mode\u201d in which the segment base addresses (which are added to the logical address to create the linear address) are programmed to zero. Accordingly, load/store unit <b>26</b> presumes that the segment base address is zero (and hence the logical and linear addresses are equal) and selects the logical address to probe data cache <b>28</b>. Segment adders <b>70</b> add the segment base address of the selected segment for the memory operation and provide the linear address to muxes <b>72</b> and <b>74</b> and to LS1 buffer <b>60</b> for storage. If the segment base address for a particular memory operation is non-zero and the memory operation was selected to probe data cache <b>28</b> upon receiving the logical address, LS1 control logic <b>64</b> may cancel the previous access (such that load data is not forwarded) and select the corresponding linear address from the output of the corresponding segment adder <b>70</b> for probing data cache <b>28</b>. In other alternative embodiments, AGUs <b>42</b> may receive the segment base address and generate linear addresses. Still other embodiments may require flat addressing mode and segment base addresses may be ignored.</p><p>Muxes <b>72</b> and <b>74</b> are coupled to receive data addresses from entries within LS1 buffer <b>60</b> as well. The data address corresponding to a memory operation is stored in the LS1 entry assigned to the memory operation upon receipt from the AGUs <b>42</b>. The data address is selected from the entry upon selecting the memory operation to probe data cache <b>28</b>. It is noted that, in addition to the data address, other information may be transmitted to data cache <b>28</b> via muxes <b>70</b> and <b>72</b>. For example, an indication of whether the memory operation is a load or store may be conveyed. The instruction tag of the memory operation may be conveyed for forwarding on result buses <b>38</b>D with the load data for load memory operations. The size of the operation (for muxing out the appropriate data) may be conveyed as well. Any desirable information may be transmitted according to design choice.</p><p>Store data may be provided for a store memory operation while the store memory operation resides in LS1 buffer <b>60</b>. Accordingly, LS1 control logic <b>64</b> may monitor result tags buses <b>38</b><i>b</i>. If a tag matching a store data tag within LS1 buffer <b>64</b> is received, the corresponding store data from the corresponding one of result buses <b>38</b><i>a </i>is captured into the entry having the matching store data tag.</p><p>LS1 control logic <b>64</b> removes memory operations from LS1 buffer <b>60</b> in response to the memory operations probing data cache <b>28</b>. In one particular embodiment, memory operations are removed the cycle after they are selected for probing data cache <b>28</b>. The cycle after may be used to allow, in cases in which a memory operation is selected upon generation of the data address by one of AGUs <b>42</b>, for the data address to propagate into LS1 buffer <b>60</b>. Other embodiments may chose to remove the memory operations during the cycle that the memory operations are selected. Because the memory operations are removed the cycle after they are selected, LS1 control logic <b>64</b> is configured to scan the oldest 4 entries in LS1 buffer <b>60</b> to select memory operations for probing data cache <b>28</b> (up to two entries selected in the previous clock cycle and up to two entries being selectable in the present clock cycle).</p><p>Memory operations removed from LS1 buffer <b>60</b> are moved to temporary buffer <b>68</b>. Temporary buffer <b>68</b> may be provided to ease timing constraints in reading entries from LS1 buffer <b>60</b> and writing them to LS2 buffer <b>62</b>. Accordingly, temporary buffer <b>68</b> is merely a design convenience and is entirely optional. The clock cycle after a memory operation is moved into temporary buffer <b>68</b>, it is moved to LS2 buffer <b>62</b>. Since store data may be received upon results buses <b>38</b> during the clock cycle a store memory operation is held in temporary buffer <b>68</b>, temporary buffer <b>68</b> monitors result tags on result tags buses <b>38</b><i>b </i>and captures data from result buses <b>38</b><i>a </i>in a manner similar to LS1 buffer <b>60</b> capturing the data.</p><p>Accordingly, memory operations which have probed data cache <b>28</b> are placed into LS2 buffer <b>62</b>. In the present embodiment, all memory operations are placed into LS2 buffer <b>62</b> after an initial probe of data cache <b>28</b>. Stores are held in LS2 buffer <b>62</b> until they can be committed to data cache <b>28</b> (i.e. until they are allowed to update data cache <b>28</b>). In general, stores may be committed when they become non-speculative. In one embodiment, stores may be committed in response to their retirement (as indicated via retirement interface <b>54</b>) or at any time thereafter. Loads are held in LS2 buffer <b>62</b> until they retire as well in the present embodiment. Load hits remain in LS2 buffer <b>62</b> for snooping purposes. Load misses are held in LS2 at least until the cache line accessed by the load is being transferred into data cache <b>28</b>. In response to the cache line (or portion thereof including the load data) being scheduled for updating the cache, the load miss is scheduled for reprobing data cache <b>28</b>. Upon reprobing, the load miss becomes a load hit (and the load data is forwarded by data cache <b>28</b>) and is retained as such until retiring.</p><p>LS2 control logic <b>66</b> allocates entries within LS2 buffer <b>62</b> for memory operations which have probed data cache <b>28</b>. Additionally, LS2 control logic <b>66</b> receives probe status information from data cache <b>28</b> for each of the probes on hit/miss signals <b>82</b>. The hit/miss information is stored in the LS2 buffer entry corresponding to the memory operation for which the probe status is provided. In one embodiment, data cache <b>28</b> includes address translation circuitry which, in parallel with access to the data cache, attempts to translate the virtual address to the physical address. If a translation is not available within the address translation circuitry, the probe may be identified as a miss until a translation is established (by searching software managed translation tables in main memory, for example). In one specific implementation, the address translation circuitry within data cache <b>28</b> comprises a two level translation lookaside buffer (TLB) structure including a 32 entry level-one TLB and a 4 way set associative, 256 entry level-two TLB.</p><p>If the data address of the memory operation is successfully translated by data cache <b>28</b>, the corresponding physical address is provided on physical address bus <b>80</b>. LS2 control logic causes the corresponding entry to overwrite the virtual address with the physical address. However, certain virtual address bits may be separately maintained for indexing purposes on reprobes and store data commits for embodiments in which data cache <b>28</b> is virtually indexed and physically tagged.</p><p>For memory operations which miss data cache <b>28</b>, data cache <b>28</b> allocates an entry in a miss address buffer included therein. The miss address buffer queues miss addresses for transmission to bus interface unit <b>37</b>, which fetches the addresses from the L2 cache or from main memory. A tag identifying the entry within the miss address buffer (the MAB tag) is provided on MAB tag bus <b>78</b> for each memory operation which misses. It is noted that data cache <b>28</b> allocates miss address buffer entries on a cache line basis. Accordingly, subsequent misses to the same cache line receive the same MAB tag and do not cause an additional miss address buffer entry to be allocated.</p><p>Bus interface unit <b>37</b> subsequently fetches the missing cache line and returns the cache line as fill data to data cache <b>28</b>. Bus interface unit <b>37</b> also provides the MAB tag corresponding to the cache line as a fill tag on fill tag bus <b>84</b>. LS2 control logic <b>66</b> compares the fill tag to the MAB tags within LS2 buffer <b>62</b>. If a match on the MAB tag occurs for a load memory operation, then that load may be selected for reprobing data cache <b>28</b>. If more than one match is detected, the oldest matching load may be selected with other memory operations selected during subsequent clock cycles. Stores which match the MAB tag are marked as hits, but wait to become non-speculative before attempting to commit data.</p><p>In one embodiment, the cache line of data is returned using multiple packets. Each load memory operation may record which packet it accesses (or the packet may be discerned from the appropriate address bits of the load address), and bus interface unit <b>37</b> may identify the packet being returned along with the fill tag. Accordingly, only those loads which access the packet being returned may be selected for reprobing.</p><p>Bus interface unit <b>37</b> provides the fill tag in advance of the fill data to allow a load to be selected for reprobing and to be transmitted to data cache <b>28</b> via port <b>0</b> to arrive at the data forwarding stage concurrent with the packet of data reaching data cache <b>28</b>. The accessed data may then be forwarded.</p><p>Since stores are moved to LS2 buffer <b>62</b> after probing data cache <b>28</b> and subsequent loads are allowed to probe data cache <b>28</b> from LS1 buffer <b>60</b> and forward data therefrom, it is possible that a younger load accessing the same memory location as an older store will probe data cache <b>28</b> prior to the older store committing its data to data cache <b>28</b>. The correct result of the load is to receive the store data corresponding to the older store. Accordingly, LS2 control logic <b>66</b> monitors the probe addresses and determines if older stores to those addresses are within LS2 buffer <b>62</b>. If a match is detected and the store data is available within LS2 buffer <b>62</b>, LS2 control logic <b>66</b> signals data cache <b>28</b> to select data provided from LS2 buffer <b>62</b> for forwarding and provides the selected data. On the other hand, if a match is detected and the store data is not available within LS2 buffer <b>62</b>, forwarding of data from data cache <b>28</b> is cancelled. The load is moved into LS2 buffer <b>62</b>, and is selected for reprobing until the store data becomes available. Additional details regarding store to load forwarding are provided further below.</p><p>Generally, LS2 control logic <b>66</b> is configured to scan the entries within LS2 buffer <b>62</b> and select memory operations to reprobe data cache <b>28</b>. Load misses are selected to reprobe in response to the data being returned to data cache <b>28</b>. Loads which hit older stores are selected to reprobe if they are not currently reprobing. Stores are selected to reprobe in response to being retired. If multiple memory operations are selectable, LS2 control logic <b>66</b> may select the oldest one of the multiple memory operations. If LS2 control logic <b>66</b> is using port <b>0</b> (via port <b>0</b> mux <b>72</b>), LS2 control logic <b>66</b> signals LS1 control logic <b>64</b>, which selects the LS2 input through port <b>0</b> mux <b>72</b> and disables selecting a memory operation from LS1 buffer <b>60</b> on port <b>0</b> for that clock cycle.</p><p>LS2 control logic <b>66</b> is further coupled to receive snoop requests from bus interface unit <b>37</b> via snoop interface <b>52</b>. Generally, memory operations in LS2 buffer <b>62</b> are snooped since they have probed data cache <b>28</b> and hence may need corrective action in response to the snoop operation. For example, load hits (which have forwarded data to dependent instructions) may need to be discarded and reexecuted. Stores may be storing a cache state from their probe, which may need to be changed. By contrast, memory operations within LS1 buffer <b>60</b> have not probed data cache <b>28</b> and thus may not need to be snooped.</p><p>LS2 control logic <b>66</b> receives the snoop request, examines the LS2 buffer entries against the snoop request, and responds to bus interface unit <b>37</b> via snoop interface <b>52</b>. Additionally, LS2 control logic <b>66</b> may perform updates within LS2 buffer entries in response to the snoop. Additional details regarding snooping in LS2 buffer <b>62</b> are described below.</p><p>Generally speaking, a buffer is a storage element used to store two or more items of information for later retrieval. The buffer may comprise a plurality of registers, latches, flip-flops, or other clocked storage devices. Alternatively, the buffer may comprise a suitably arranged set of random access memory (RAM) cells. The buffer is divided into a number of entries, where each entry is designed to store one item of information for which the buffer is designed. Entries may be allocated and deallocated in any suitable fashion. For example, the buffers may be operated as shifting first-in, first-out (FIFO) buffers in which entries are shifted down as older entries are deleted. Alternatively, head and tail pointers may be used to indicate the oldest and youngest entries in the buffer, and entries may remain in a particular storage location of the buffer until deleted therefrom. The term \u201ccontrol logic\u201d as used herein, refers to any combination of combinatorial logic and/or state machines which performs operations on inputs and generates outputs in response thereto in order to effectuate the operations described.</p><p>It is noted that, in one embodiment, load/store unit <b>26</b> attempts to overlap store probes from LS1 with the data commit of an older store on the same port. This may be performed because the store probe is only checking the data cache tags for a hit/miss, and is not attempting to retrieve or update data within the data storage. It is further noted that, while the above description refers to an embodiment in which all memory operations are placed in LS2 buffer <b>62</b>, other embodiments may not operate in this fashion. For example, load hits may not be stored in LS2 buffer <b>62</b> in some embodiments. Such embodiments may be employed, for example, if maintaining strong memory ordering is not desired.</p><p>Turning next to FIG. 4, a timing diagram is shown illustrating an exemplary pipeline for a memory operation probing data cache <b>28</b> from LS1 buffer <b>60</b>. Other embodiments employing different pipelines are possible and contemplated. In FIG. 4, clock cycles are delimited by vertical solid lines. A horizontal dashed line is shown as well. Pipeline stages related to other portions of processor <b>10</b> are shown to illustrate the interface of other elements to load/store unit <b>26</b>.</p><p>Clock cycle CLKO is the decode/dispatch cycle for an instruction specifying the memory operation. During clock cycle CLKO, the decode unit <b>20</b> decoding the instruction signals load/store unit <b>26</b> regarding the memory operation. LS1 control logic <b>64</b> allocates an LS1 buffer entry for the memory operation during the decode/dispatch stage for the corresponding instruction. Additionally, the decode unit <b>20</b> transmits the decoded instruction to the corresponding reservation station <b>22</b>.</p><p>During clock cycle CLK<b>1</b>, the address generation unit generates the data address for the memory operation and transmits the data address to load/store unit <b>26</b>. During this clock cycle, the memory operation participates in the scan performed by LS1 control logic <b>64</b> (by virtue of the data address being provided) and is selected to probe data cache <b>28</b>. Accordingly, the memory operation is in the scan pipeline stage of the LS1 pipeline.</p><p>During clock cycle CLK<b>2</b>, the data address is transmitted to data cache <b>28</b>. As illustrated by the arrow within clock cycle CLK<b>2</b>, the memory operation is moved from LS1 buffer <b>60</b> to temporary buffer <b>68</b> at the end of clock cycle CLK<b>2</b>. The memory operation is in the address to data cache stage of the LS1 pipeline during clock cycle CLK<b>2</b>.</p><p>During clock cycle CLK<b>3</b>, the data address accesses data cache <b>28</b>. Data corresponding to the memory operation (if the memory operation is a load) is forwarded at the end of clock cycle CLK<b>3</b>. Additionally, the memory operation is moved from temporary buffer <b>68</b> to LS2 buffer <b>62</b>. The memory operation is in the cache access stage during clock cycle CLK<b>3</b>.</p><p>During clock cycle CLK<b>4</b>, an instruction dependent upon the memory operation (if the memory operation is a load) may be executed. Accordingly, the pipeline illustrated in FIG. 4 provides for a three clock cycle address generation to dependent operation execution load latency. Additionally, the memory operation is in the response pipeline stage during clock cycle CLK<b>4</b>. Data cache <b>28</b> provides hit/miss information and the physical address during the response stage. Accordingly, LS2 control logic <b>66</b> associates hit/miss information and the physical address with a memory operation in the response stage.</p><p>During clock cycle CLK<b>5</b>, the memory operation is in a response<b>2</b> pipeline stage. During this stage, the miss address buffer tag identifying the miss address buffer entry assigned to the cache line accessed by the memory operation (if the memory operation is a miss) is provided by data cache <b>28</b>. Accordingly, LS2 control logic <b>66</b> associates a MAB tag received from data cache <b>28</b> with a memory operation in the response<b>2</b> stage.</p><p>Turning next to FIG. 5, a timing diagram illustrating an exemplary pipeline for a memory operation reprobing data cache <b>28</b> from LS2 buffer <b>62</b> is shown. Other embodiments employing different pipelines are possible and contemplated. In FIG. 5, clock cycles are delimited by vertical solid lines. A horizontal dashed line is shown as well. Pipeline stages related to other portions of processor <b>10</b> are shown to illustrate the interface of other elements to load/store unit <b>26</b>.</p><p>During clock cycle CLKO, the memory operation participates in a scan of LS2 buffer entries and is selected to reprobe data cache <b>28</b>. As illustrated by the arrow beneath clock cycle CLKO, the memory operation may be selected if a fill tag matching the MAB tag for the memory operation is received, if the memory operation is a load which hits an older store within LS2 buffer <b>62</b> (for which the data was not available on the previous probe), or if the memory operation is a store which has been retired by reorder buffer <b>32</b>.</p><p>During clock cycle CLK<b>1</b>, the memory operation selected during the Scan<b>1</b> stage enters the Scan<b>2</b> stage. During the Scan<b>2</b> stage, the memory operation is selected through muxes <b>76</b> and <b>72</b> for transmission to data cache <b>28</b>. Accordingly, LS2 control logic <b>66</b> selects the memory operation in the Scan<b>2</b> stage through multiplexor <b>76</b>. Clock cycles CLK<b>2</b>, CLK<b>3</b>, CLK<b>4</b>, and CLK<b>5</b> are the address to data cache, cache access, response, and response<b>2</b> stages of the LS2 buffer reprobe pipeline and are similar to the corresponding stages described above. Accordingly, for the present embodiment, bus interface unit <b>37</b> may provide the MAB tag 4 clocks prior to providing the corresponding data, to allow selection of a load which accesses that corresponding fill data to be in the cache access stage during the clock cycle in which the fill data arrives at data cache <b>28</b> (and hence the fill data may be forwarded).</p><p>It is noted that the timing between the instruction pipeline stages above the dotted lines in FIGS. 4 and 5 and the memory operation pipeline stages below the dotted lines may be extended from those shown in FIGS. 4 and 5. For example, in FIG. 4, the address may not be generated exactly in the clock cycle immediately following the decode/dispatch cycle. Operands may not be available, or older instructions may be selected for address generation instead. Furthermore, a memory operation may not be scanned for access during the clock cycle the address is provided, as other older memory operations may be scanned instead.</p><p>Turning next to FIG. 6, a block diagram illustrating exemplary information which may be stored in one embodiment of an LS1 buffer entry <b>90</b> is shown. Other embodiments are possible and contemplated.</p><p>LS1 buffer entry <b>90</b> includes a valid field <b>92</b>A which indicates the validity of the entry as well as certain fields within the entry. For example, valid field <b>92</b>A may comprise a valid bit indicating whether or not the entry is valid, a data valid bit indicating whether or not store data is valid (if applicable), and an address valid bit indicating whether or not the data address is valid.</p><p>Type field <b>92</b>B stores the type of memory operation represented within LS1 buffer entry <b>90</b>. The memory operation may be a load, a store, or a load/store (for load-op-store instruction as may occur in the x86 instruction set architecture). Load/store types may probe data cache <b>28</b> once, and forward the data based on the probe, then subsequently perform the store when the instruction is retired. Accordingly, load/store types may occupy a single entry for both the load and the store memory operations.</p><p>Address field <b>92</b>C stores the data address of the memory operation, and store data field <b>92</b>D stores the store data corresponding to a store memory operation. Instruction tag field <b>92</b>E stores the instruction tag assigned by reorder buffer <b>32</b> to the instruction corresponding to the memory operation. The instruction tag is used to capture the data address from address buses <b>44</b>. Additionally, the instruction tag may be used to determine when the corresponding instruction is retired by reorder buffer <b>32</b> and may be used for loads as the result tag for forwarding data. Data tag field <b>92</b>F stores the store data tag identifying the source of the store data for a store memory operation.</p><p>The address valid bit within valid field <b>92</b>A indicates if address field <b>92</b>C is valid. However, the data address may be provided by AGUs <b>42</b> and be selected for probing data cache <b>28</b> prior to the data address becoming valid in LS1 buffer entry <b>90</b>. ATagM field <b>92</b>G is used to indicate that the address tag provided by AGUs <b>42</b> in the previous clock cycle matched instruction tag field <b>92</b>E for providing selection controls for port <b>0</b> mux <b>72</b> and port <b>1</b> mux <b>74</b>. In one embodiment, ATagM field <b>92</b>G may comprise a bit for each issue position to identify the issue position from which the data address is received. Accordingly, ATagM field <b>92</b>G may be used to determine which LS1 entry should capture an address presented to LS1 buffer <b>60</b> from one of segment adders <b>70</b>.</p><p>As illustrated in FIG. 4, removing an entry from LS1 buffer <b>60</b> may be delayed from the clock cycle in which the entry is selected for probing. Accordingly, accessed bit <b>92</b>H is provided within LS1 buffer entry <b>90</b>. Accessed bit <b>92</b>H may be set to indicate that the memory operation was selected in the previous clock cycle for probing, and therefore should not be selected in the present clock cycle. Certain types of memory operations may be predetermined to be performed non-speculatively according to the instruction set architecture employed by processor <b>10</b> or according to design choice. Non-speculative bit <b>921</b> may be used to indicate such a memory operation.</p><p>Finally, a general control field <b>92</b>J may be included for additional control bits as desired. For example, an embodiment of processor <b>10</b> employing the x86 instruction set architecture may include control information specific to the x86 architecture within control field <b>92</b>J. For example, information related to the accessed segment, segment limit violations, and segment attributes may be stored in control field <b>92</b>J. Furthermore, information such as the size of the memory operation (i.e. number of contiguous bytes affected by the memory operation) may be included, as may be any other desired control information according to design choice.</p><p>Turning next to FIG. 7, a block diagram illustrating exemplary information which may be stored in one embodiment of an LS2 buffer entry <b>94</b> is shown. Other embodiments are possible and contemplated.</p><p>LS2 buffer entry <b>94</b> includes a valid field <b>96</b>A which indicates the validity of the entry as well as certain fields within the entry. For example, valid field <b>92</b>A may comprise a valid bit indicating whether or not the entry is valid, a data valid bit indicating whether or not store data is valid (if applicable), and a physical address valid bit indicating whether or not the physical data address is valid (i.e. whether or not a valid translation has been performed by data cache <b>28</b>).</p><p>LS2 buffer entry <b>94</b> further includes a type field <b>96</b>B, an address field <b>96</b>C, a store data field <b>96</b>D, an instruction tag field <b>96</b>E, and a data tag field <b>96</b>F similar to the fields <b>92</b>B-<b>92</b>F described above. Additionally, store data field <b>96</b>D may be used in the case of a load which hits an older store within LS2 buffer <b>62</b>. For these cases, the store instruction tag of the store which the load hits is stored into data field <b>96</b>D of the load entry. For subsequent reprobes, the older store can be located by comparing the store instruction tag instead of trying to scan for the address and prioritize the hits. Additional details regarding store to load forwarding for one embodiment of load/store unit <b>26</b> are provided further below. LS2 buffer <b>94</b> further includes a nonspeculative bit <b>96</b>L similar to nonspeculative bit <b>921</b> described above.</p><p>MAB tag field <b>96</b>G stores the MAB tag assigned by data cache <b>28</b> for a memory operation which misses. Similar to the accessed bit <b>92</b>H, accessed bit <b>96</b>H indicates that LS2 buffer entry <b>94</b> has been selected to access data cache <b>28</b> and is not currently eligible for selection. Additionally, LS2 buffer entry <b>94</b> includes a pipe field <b>96</b>I which tracks the pipe stage occupied by the memory operation stored in the entry after it has been selected. pipe field <b>96</b>I may, for example, comprise a bit for each pipe stage. The bit for the first pipe stage may be set in response to selecting the memory operation in the entry, and then the field may be shifted each clock cycle as the memory operation progresses through the pipeline. Alternatively, an encoded value may be used. Information received from data cache <b>28</b> may be associated with the corresponding memory operation by scanning pipe fields <b>96</b>I for a memory operation which is in the pipe stage at which the information is generated.</p><p>As mentioned above, memory operations may remain in LS2 buffer <b>62</b> after being retired by reorder buffer <b>32</b>. Retired bit <b>96</b>J is used to identify the entry as corresponding to an instruction which has been retired. Additionally, LS2 buffer entry <b>94</b> includes an last in buffer (LIB) bit <b>96</b>K. LIB bit <b>96</b>K is used when comparing stores within LS2 buffer <b>62</b> to loads probing data cache <b>28</b> for the first time. The last in buffer bit indicates that the store within the corresponding entry is the last (e.g. youngest) entry within the buffer to update the data address specified by that store. Accordingly, in the case in which multiple stores within the buffer are hit by a load, the store with the LIB bit set is selected as the store upon which the load is dependent. Complex hit prioritization logic may thereby be avoided. The same comparator circuitry used to compare probing loads against LS2 buffer <b>62</b> may be used to compare probing stores as well. If a probing store hits a store in LS2 buffer <b>62</b> for which LIB bit <b>96</b>K is set, the LIB bit <b>96</b>K is reset. Alternatively, a second bit may be set and interpreted as resetting LIB bit <b>96</b>K. LIB bit <b>96</b>K is set for a store buffer entry as the store buffer entry is allocated.</p><p>Miss bit <b>96</b>M is used to identify whether or not the memory operation stored in LS2 buffer entry <b>94</b> is a miss in data cache <b>28</b>. Miss bit <b>96</b>M is set according to the hit/miss information provided by data cache <b>28</b> on hit/miss lines <b>82</b> (either on initial probe or reprobe). Additionally, LS2 buffer entry <b>94</b> includes a self-modifying code (SMC) field <b>96</b>N for use with the SMC state machine described in more detail below for one embodiment of load/store unit <b>26</b>. Snoop resync bit <b>96</b>O is used to indicate synchronization due to snoops, as described below in more detail. Store load forward bit <b>96</b>P is used to signify that the current entry is a load which hits an older store within LS2 buffer <b>62</b> (for which data is not available). Loads which hit earlier stores are selected for reprobing until the store data becomes available (at which time the data is forwarded for the load). A memory type field <b>96</b>Q is included in LS2 buffer entry <b>94</b> as well. The memory type may be provided by data cache <b>28</b> upon translating the address of the memory operation. Among other things, the memory type may indicate if the memory operation is cacheable or non-cacheable. This information may be used for determining whether or not SMC checks are to be performed, according to one embodiment described below.</p><p>Finally, a general control field <b>96</b>R may be included for additional control bits as desired. For example, additional information from the translation of the address which is specific to the instruction set architecture. In one embodiment, a reprobe bit may be included to indicate that a store hit must reprobe because intervening activity caused the line to be evicted. Additionally, the way of data cache <b>28</b> that hits may be stored for use in updating data cache <b>28</b> with store data. Yet another bit may be defined to indicate that bus interface unit <b>37</b> is in the process of acquiring a state for a cache line updated by a store which will allow the store to complete. Still further, linear address bits which have been translated but which are used for indexing may be stored in control field <b>96</b>R. Control information may be included or excluded according to design choice.</p><p>Turning now to FIG. 8, a circuit diagram illustrating exemplary scan logic for an LS1 buffer entry is shown. Other embodiments and specific implementations are possible and contemplated. Any suitable logic may be used, including Boolean equivalents of the logic illustrated in FIG. <b>8</b>. Other schemes may include additional or substitute selection criteria, as desired.</p><p>As illustrated in FIG. 8, an LS1 entry may be eligible for selection if the data address is valid (AV) or a tag match is detected for addresses being provided by the AGUs <b>42</b> (ATagM). Additionally, the entry is not eligible if it has been accessed for probing (ACC) or is restricted for executing nonspeculatively (NonSpec) until indicated as retireable by reorder buffer <b>32</b>.</p><p>The outcome of the logic shown in FIG. 8 is that the corresponding entry is selectable for probing data cache <b>28</b>. In one embodiment, load/store unit <b>28</b> limits the scan to the four oldest entries in LS1 buffer <b>60</b>. Accordingly, selection logic similar to the shown in FIG. 8 may be employed for the four oldest entries, and may be qualified with whether or not older entries exist and are not selected.</p><p>Turning next to FIG. 9, a circuit diagram illustrating exemplary scan logic for an LS2 buffer entry is shown. Other embodiments and specific implementations are possible and contemplated. Any suitable logic may be used, including Boolean equivalents of the logic illustrated in FIG. <b>8</b>. Other schemes may include additional or substitute selection criteria, as desired.</p><p>For the embodiment of FIG. 9, an LS2 buffer entry may be eligible for reprobing if a fill tag provided by bus interface unit <b>37</b> matches the MAB tag of that entry and the entry is a miss, or if the entry is a load which hits a store for which data is not available (STLF) or if the entry is retired (RET) and is a store. Additionally, the entry is selectable if it is valid and not accessed (ACC).</p><p>Similar to the embodiment of FIG. 8, the outcome of the logic shown in FIG. 9 is that the corresponding entry is selectable for reprobing data cache <b>28</b>. The selectability of an entry may be qualified with whether or not older selectable entries exist.</p><p>Dependency Link File</p><p>As mentioned above, load/store unit <b>26</b> is configured to handle the cases in which a probing load memory operation hits an older store memory operation stored in LS2 buffer <b>62</b>. Generally speaking, a load memory operation is said to \u201chit\u201d a store memory operation if the load memory operation accesses at least one byte which is updated by the store memory operation. Similarly, the load address may be determined to hit the store address if the load address (and the size of the operation) indicate that at least one byte updated by the store is accessed by the load.</p><p>Generally, load/store unit <b>26</b> compares data addresses of memory operations probing data cache <b>28</b> from LS1 buffer <b>60</b> to memory operations within LS2 buffer <b>62</b>. If a probing load hits a store in LS2 buffer <b>62</b> and the store data is available with LS2 buffer <b>62</b>, the store data is transmitted to data cache <b>28</b> for forwarding in place of any load data which may be in cache. On the other hand, a probing load may hit a store in LS2 buffer <b>62</b> for which store data is not available. For this case, forwarding of data from data cache <b>28</b> is cancelled and the load memory operation is selected for reprobing from LS2 buffer <b>62</b> until the store data becomes available (according to the scan mechanism described above). Eventually, the store data may become available within LS2 buffer <b>62</b> and forwarded therefrom during a reprobing by the load, or the store may update data cache <b>28</b> and the data may be forwarded from data cache <b>28</b> during a reprobing by the load. Finally, store memory operations which hit store memory operations in the buffer may cause the LIB bit for the hit store memory operations to be reset.</p><p>In order to simplify the determination of which store is hit by a load which reprobes from LS2 buffer <b>62</b>, the store instruction tag of the store hit by the load upon initial probing from LS1 buffer <b>60</b> is recorded in the LS2 buffer entry of the load. During reprobings from LS2 buffer <b>62</b>, instead of comparing the data address of the load to the data addresses of stores within LS2 buffer <b>62</b>, the store instruction tag recorded for the load is compared to the store instruction tags within LS2 buffer <b>62</b>. If the store instruction tag recorded for the load matches a store instruction tag within LS2 buffer <b>62</b> and the store data is available, the store data is forwarded for the load in a manner similar to the initial probe case described above. Similarly, if the store instruction tag recorded for the load matches a store instruction tag within LS2 buffer <b>62</b> and the store data is not available, forwarding is cancelled and the load is selected again for reprobing at a later time. If the store instruction tag recorded for the load does not match a store instruction tag, the data is forwarded from data cache <b>28</b>.</p><p>Generally speaking, store data is \u201cavailable\u201d from a storage location if the store data is actually stored in that storage location. If the data may at some later point be stored in the storage location but is not yet stored there, the data is \u201cnot available\u201d, \u201cnot yet available\u201d, or \u201cunavailable\u201d. For example, store data may be not available in a LS2 buffer entry if the store data has not been transmitted from the source of the store data to the LS2 buffer entry. The source of the store data is the instruction which executes to produce the store data, and may be the same instruction to which the store corresponds (an instruction specifying a memory operand as the destination) or may be an older instruction. The store data tag identifies the source of the store data and hence is compared to result tags from the execution units <b>40</b> to capture the store data.</p><p>While the above described mechanism, loads dependent on older stores receive the correct data. However, in many cases the above mechanism may lead to significant delays in the forwarding of data for a load (as measured from the store data becoming available). FIG. 10 is a timing diagram illustrating an example of such a delay according to one embodiment of load/store unit <b>26</b>. Similar to the timing diagrams above, FIG. 10 illustrates a set of clock cycles delimited by vertical solid lines. The pipeline stages of load/store unit <b>26</b> which a load hitting an older store is occupying during each clock cycle of the example are listed within each clock cycle. Accordingly, the load is in the cache access stage during clock cycle CLK<b>0</b>, the response stage during clock cycle CLK<b>1</b>, the response<b>2</b> stage during clock cycle CLK<b>2</b>, the scan<b>1</b> stage during clock cycle CLK<b>3</b>, the scan<b>2</b> stage during clock cycle CLK<b>4</b>, the address to data cache stage during clock cycle LK<b>5</b>, and the cache access stage again during clock cycle CLK<b>6</b>.</p><p>In the example, store data is made available at the end of clock cycle CLKO. To achieve the minimum latency for the load, it would be desirable to forward the data during clock cycle CLK<b>0</b>. Dependent operations could then execute in clock cycle CLK<b>1</b>. However, according to one embodiment, the store data may not be forwarded. Accordingly, the store data is forwarded upon reprobe of data cache <b>28</b> during clock cycle CLK<b>6</b>.</p><p>It is noted that even more significant delays could be experienced. For example, the load might not be immediately selected in the Scan<b>1</b> stage of clock cycle CLK<b>4</b>. Multiple clock cycles may elapse before the load is selected to reprobe data cache <b>28</b>. Furthermore, even if the load were not in the pipeline at the time the store data arrives in clock cycle CLK<b>0</b> (e.g. if the load were sitting idle in LS2 buffer <b>62</b>), a significant delay may be experienced prior to the load being selected for reprobing. Still further, even if LS2 control logic <b>66</b> were configured to select the load for reprobing in response to receiving the store data, a delay of four clock cycles (in the present embodiment) would be experienced.</p><p>One embodiment of load/store unit <b>26</b> may employ a forwarding mechanism which allows for forwarding of the store data upon receipt of the store data (independent of the reprobing of the corresponding load). Such an embodiment may forward store data to instructions dependent upon the load during, e.g., clock cycle CLKO shown in FIG. <b>10</b>.</p><p>FIG. 11 illustrates one embodiment of a portion of load/store unit <b>26</b> and data cache <b>28</b>. Other embodiments are possible and contemplated. In the embodiment of FIG. 11, load/store unit <b>26</b> includes LS2 buffer <b>62</b>, LS2 control logic <b>66</b>, a data forward mux <b>100</b>, address comparators <b>102</b>A-<b>102</b>B, a dependency link file <b>104</b>, a dependency link file control logic <b>106</b>, and store data tag comparators <b>108</b>A-<b>108</b>B. Additionally, in the embodiment of FIG. 11, data cache <b>28</b> includes a port <b>1</b> data mux <b>110</b>, a port <b>0</b> data mux <b>112</b>, and a LS2 forward data mux <b>114</b>. LS2 buffer <b>62</b> is coupled to data forward mux <b>100</b>, comparators <b>102</b>A-<b>102</b>B, and LS2 control logic <b>66</b>. LS2 control logic <b>66</b> is further coupled to muxes <b>100</b>, <b>110</b>, <b>112</b>, and <b>114</b>. LS2 control logic <b>66</b> is further coupled to dependency link file control logic <b>106</b>, dependency link file <b>104</b>, and comparators <b>102</b>A-<b>102</b>B. Dependency link file <b>104</b> is coupled to receive instruction tags corresponding to data cache ports <b>0</b> and <b>1</b>, to LS2 data forward mux <b>114</b>, to comparators <b>108</b>A-<b>108</b>B, and to dependency link file control logic <b>106</b>. Dependency link file control logic <b>106</b> is further coupled to mux <b>114</b> and comparators <b>108</b>A-<b>108</b>B. Comparators <b>102</b>A-<b>102</b>B are coupled to receive data addresses presented on ports <b>0</b> and <b>1</b> of data cache <b>28</b>. Comparators <b>108</b>A-<b>108</b>B are coupled to receive result tags on buses <b>38</b>b. Mux <b>114</b> is coupled to mux <b>112</b>. Mux <b>112</b> is coupled to provide results on result bus <b>38</b>DA, and similarly mux <b>110</b> is coupled to provide results on result bus DB. Result buses <b>38</b>DA-<b>38</b>DB may form one embodiment of result buses <b>38</b>D as shown in FIG. <b>2</b>.</p><p>Generally speaking, load/store unit <b>26</b> is configured to detect a load which hits a store for which the corresponding store data is not available. In response to detecting such a load, load/store unit <b>26</b> allocates an entry in dependency link file <b>104</b> for the load. The dependency link file entry stores a load identifier (e.g. the instruction tag assigned by reorder buffer <b>32</b> to the instruction corresponding to the load) identifying the load which hits the store and a store data identifier (e.g. the store data tag) identifying the source of the store data corresponding to the store hit by the load. Load/store unit <b>26</b> monitors results buses <b>38</b> for the store data tags stored within dependency link file <b>104</b>. Upon detecting that store data is being provided on one of result buses <b>38</b>, load/store unit <b>26</b> directs data cache <b>28</b> to forward the data from the corresponding result bus onto a result bus from data cache <b>28</b>. Additionally, the load identifier from the corresponding entry is forwarded as the result tag. In this manner, the store data is directly forwarded, during the clock cycle the store data is provided, to any operations dependent upon the load data. Advantageously, the latency from receiving store data to forwarding the store data to a previously probing load may be reduced. In one embodiment, the latency may be reduced to zero clock cycles.</p><p>As described above, load addresses are compared to store addresses within LS2 buffer <b>62</b> to detect loads which hit older stores. Accordingly, comparators such as comparators <b>102</b> are provided. Comparators <b>102</b> are provided to compare addresses on each port of data cache <b>28</b> to the data addresses stored within LS2 buffer <b>62</b>. As an example, one embodiment of data cache <b>28</b> includes two ports, each of which may receive a different load address during a clock cycle. Such an embodiment may include two comparators <b>102</b> for each LS2 buffer entry. For simplicity in the drawing, not all of the comparators <b>102</b> have not been illustrated. If an address on one of the ports to data cache <b>28</b> hits a data address within LS2 buffer <b>62</b>, the corresponding comparator <b>102</b> asserts a signal to LS2 control logic <b>66</b>. LS2 control logic <b>66</b> determines if the port is being used for a load, if the entry which is hit is a store, and whether or not the corresponding store data is available.</p><p>If a load hit on a store entry is detected and the corresponding store data is available, LS2 control logic <b>66</b> selects the store data using data forward mux <b>100</b>, and provides the data to either LS2 data forward mux <b>114</b> or to port <b>1</b> mux <b>110</b>, based upon the port for which the hit is detected. Accordingly, data forward mux <b>100</b> may comprise a set of independent muxes, one for each port. Additionally, LS2 control logic <b>66</b> asserts a corresponding signal to data cache <b>28</b> for data cache <b>28</b> to select the forwarded data in place of cache data read from data cache <b>28</b> for the hitting load.</p><p>If a load hit on a store is detected and the corresponding store data is not available, LS2 control logic <b>66</b> signals data cache <b>28</b> to cancel data forwarding. Additionally, LS2 control logic <b>66</b> signals dependency link file control logic <b>106</b> that a load hitting a store with unavailable data has been detected. Additionally, LS2 control logic <b>66</b> reads the store data tag from the entry which is hit and provides the store data tag to dependency link file <b>104</b> (or alternatively causes LS2 buffer <b>62</b> to transmit the store data tag to dependency link file <b>104</b>). If more than one store is detected as being hit by a load, LS2 control logic <b>66</b> selects the entry for which the LIB bit <b>96</b>K is set.</p><p>Dependency link file <b>104</b> is also coupled to receive the instruction tags corresponding to the memory operations probing data cache <b>28</b> via ports <b>0</b> and <b>1</b>. In response to the signal from LS2 control logic <b>66</b>, dependency link file control logic <b>106</b> allocates an entry within dependency link file <b>104</b>. The load instruction tag and the store s data tag of the store hit by the load are stored into the allocated entry of dependency link file <b>104</b>.</p><p>Dependency link file control logic <b>106</b> monitors the result tags upon result buses <b>38</b> to detect the store data tags stored within dependency link file <b>104</b>. Accordingly, comparators <b>108</b> (including comparators <b>108</b>A-<b>108</b>B) are provided. In general, the number of comparators may be the number of result tags monitored multiplied by the number of entries within dependency link file <b>104</b>. For simplicity in the drawing, not all comparators <b>108</b> are shown in FIG. <b>11</b>. Comparators <b>108</b>, upon detecting equality between the store data tag of the corresponding entry and a result tag upon result tags buses <b>38</b><i>b</i>, signals dependency link file control logic <b>106</b>. Dependency link file control logic causes the corresponding load instruction tag to be read from dependency link file <b>104</b> and to be provided to mux <b>114</b>. In addition, based upon the result bus from which the result tag matching the store data tag is received, dependency link file control logic <b>106</b> signals data cache <b>28</b> to select the corresponding data (and the load instruction tag) through LS2 data forward mux <b>114</b> and through port <b>0</b> mux <b>112</b> onto port <b>0</b> result bus <b>38</b>DA. In this manner, the store data is forwarded as load data for the corresponding load. Finally, dependency link file control logic <b>106</b> deletes the entry for which data is forwarded from dependency link file <b>104</b>, allowing for a subsequent load to be allocated to that entry.</p><p>In one embodiment, dependency link file <b>104</b> is used to forward load data if the following conditions are met: (i) the load address and the store address which is hit match exactly (i.e. identify the same byte); and (ii) the store size is equal to or greater than the load size (i.e. the store updates every byte accessed by the load). Other embodiments may employ more or fewer restrictions, as desired.</p><p>In the present embodiment, load/store unit <b>26</b> uses port <b>0</b> of data cache <b>28</b> to forward the load data for a load represented in dependency link file <b>104</b>. Accordingly, upon detecting that load data is to be forwarded, dependency link file control logic <b>106</b> may signal LS1 control logic <b>64</b> and LS2 control logic <b>66</b>. Control logics <b>64</b> and <b>66</b> may inhibit selecting an operation for port <b>0</b> and may stall the port <b>0</b> pipeline to allow use of port <b>0</b> result bus <b>38</b>DA by dependency link file <b>104</b>.</p><p>If LS2 control logic <b>66</b> determines that a store upon one of data cache ports <b>0</b> and <b>1</b> hits an older store, the LIB bit for the older store is reset. The LIB bit for the store on the data cache port is set upon storing of the entry into LS2 buffer <b>62</b>. Finally, if LS2 control logic <b>66</b> determines that a store hits an older load, the hit detected by comparators <b>102</b> is ignored.</p><p>It is noted that more than one store data tag within dependency link file <b>104</b> may be detected as being forwarded during a clock cycle. In the present embodiment, dependency link file control logic <b>106</b> may select one entry for forwarding and invalidate the other entries. Subsequent reprobes by the loads corresponding to the invalidated entries may cause the corresponding data to be forwarded from LS2 buffer <b>62</b>. Alternatively, a mux similar to mux <b>114</b> may be provided for port <b>1</b> as well, to allow the forwarding of a second load from dependency link file <b>104</b>. In yet another alternative, dependency link file control logic <b>106</b> may be configured to capture the store data for the additional entries within dependency link file <b>106</b> and forward the data during subsequent clock cycles.</p><p>In the present embodiment, dependency link file <b>104</b> is a performance enhancement, but does not supplant the reprobe mechanism for forwarding data. Accordingly, in cases in which dependency link file <b>104</b> is full upon detection of a load hitting a store with unavailable data, dependency link file control logic <b>106</b> may not allocate an entry. While any number of dependency link file entries may be employed as desired, in one embodiment 4 entries are provided. During a subsequent reprobe, an entry may be allocated if available in the same fashion as entries are allocated upon an initial probing from LS1 buffer <b>60</b>. Still further, loads for which dependency link file entries are allocated still participate in LS2 scanning and reprobing in the present embodiment. Subsequent to forwarding of load data for a load via dependency link file <b>104</b>, the load may reprobe data cache <b>28</b> and have the store data forwarded from LS2 buffer <b>62</b> in the manner described above. This extra forwarding may be harmless since the previous forwarding via dependency link file <b>104</b> satisfies dependencies on the load. It is still further noted that, if a reprobe of a load for which a dependency link file entry is already allocated is performed, dependency link file control logic <b>106</b> inhibits allocating another entry for the load (e.g. by comparing the load instruction tag to the tags stored in dependency link file <b>104</b>).</p><p>In yet another embodiment, dependency link file <b>104</b> may be used to forward data in all cases of load hit store without data available. In such an embodiment, if a load hits a store without available data and dependency link file <b>104</b> is full, the load is selected for reprobing until an entry becomes available. However, upon allocation of a dependency link file entry the load may be prevented from reprobing and the store data is forwarded using dependency link file <b>104</b>.</p><p>It is further noted that, while the present embodiment is shown for use with LS2 buffer <b>62</b>, other embodiments are contemplated in which dependency link file <b>104</b> is employed within an embodiment of load/store unit <b>26</b> having a conventional store queue storing only store memory operations which have probed data cache <b>28</b>.</p><p>It is noted that, while one embodiment of load/store unit <b>26</b> employing the dependency link file described above reduces the store data to load forward latency to zero clock cycles, another contemplated embodiment may capture the store data and forward during a succeeding clock cycle. While the latency in such an embodiment would be one clock cycle, timing problems may be eased for such an approach. Yet other embodiments may employ additional clock cycles of latency from store data to load forwarding using the dependency link file described. It is noted that dependency link file <b>104</b> may be viewed as a buffer having a plurality of entries, each entry storing the load instruction tag and corresponding store data tag as described above.</p><p>Snoop Resync for Load Ordering</p><p>Turning now to FIG. 12, a timing diagram is shown illustrating exemplary loads and stores performed by a pair of processors (processor <b>1</b> and processor <b>2</b>). The timing diagram illustrates a problem which may occur in processors which: (i) implement an instruction set architecture requiring strong memory ordering; and (ii) allow loads which hit to proceed before older loads which are misses are serviced from memory.</p><p>Above the timing diagram in FIG. 12, a list of the program order of the exemplary memory operations is shown, with older operations listed prior to younger operations. Accordingly, processor <b>1</b> performs a store to an address A<b>1</b> followed by a store to an address A<b>2</b> (according to the program order), while processor <b>2</b> performs a load from address A<b>2</b> followed by a conditional branch based on the value stored at A<b>2</b> and a load from address A<b>1</b>. The sequence executed by processor <b>2</b> may be used, for example, if address A<b>1</b> identifies a memory location used as a semaphore for passing control of a memory location identified by address A<b>2</b> from processor to processor. Generally, a processor checks the semaphore to determine if another processor controls the protected memory location(s) prior to reading or taking control of the protected memory location(s). If the semaphore is non-zero, for example, the protected memory location(s) may be controlled by another processor. The reading processor may inhibit access to the protected memory location(s) (e.g. via the conditional branch) until the semaphore is updated to a zero value. Use of a semaphore in the manner shown for processor <b>2</b>, along with having strong memory ordering, can guarantee that the load from address A<b>2</b> (executed by processor <b>2</b>) receives the update of A<b>1</b> performed by processor <b>1</b>.</p><p>Generally, strong memory ordering requires that memory operations performed by a processor be detected by other processors as occurring in program order. The timing diagram of FIG. 12 illustrates a case in which the order of the stores by processor <b>1</b> may appear to occur out of order to the instruction stream executed by processor <b>2</b> by allowing loads to receive data out of order. As the timing diagram illustrates, the load from A<b>1</b> can be completed within processor <b>2</b> as a hit in the data cache prior to the store to A<b>1</b> by processor <b>1</b>. Subsequently, the store to A<b>2</b> may be performed by processor <b>1</b> followed by the load from A<b>2</b> by processor <b>2</b>. In this sequence of events, the load from A<b>2</b> by processor <b>2</b> would receive the updated value according to the store to A<b>2</b>, but the load from A<b>1</b> (which follows the load to A<b>2</b> in program order) would not receive the updated value according to the store to A<b>1</b>. If the store to A<b>2</b> is a value allowing the conditional branch to be not taken, strong memory ordering rules would be violated.</p><p>As described above, one embodiment of load/store unit <b>26</b> performs stores in program order (by updating data cache <b>28</b> or providing the stores to bus interface unit <b>37</b> upon retirement of the store memory operations). Loads, on the other hand, may complete out of order in general. More particularly, loads probe data cache <b>28</b> in program order but a load which hits (either an older store or in data cache <b>28</b>) may forward data prior to older load misses being serviced and load misses may be serviced out of order. Accordingly, processor <b>10</b> may experience a strong memory ordering violation if the load from A<b>2</b> misses and the load from A<b>1</b> hits (or misses and is serviced prior to the load from A<b>2</b>). More generally, processor <b>10</b> may experience a strong memory ordering violation if a load hit is snoop hit by an update-type operation prior to an older load miss being serviced.</p><p>Turning next to FIG. 13, one embodiment of a portion of one embodiment of load/store unit <b>26</b> which may handle strong memory ordering correctly is shown. Other embodiments are possible and contemplated. The portion of load/store unit <b>26</b> illustrated in FIG. 13 includes LS2 buffer <b>62</b>, LS2 control logic <b>66</b>, reprobe mux <b>76</b>, and a plurality of comparators <b>120</b>A-<b>120</b>B. Comparators <b>120</b>A-<b>120</b>B are coupled to LS2 buffer <b>62</b> and to receive a snoop address corresponding to a snoop request on snoop address bus <b>52</b>A (part of snoop interface <b>52</b>). Additionally, comparators <b>120</b>A-<b>120</b>B are coupled to LS2 control logic <b>66</b>. LS2 control logic <b>66</b> is coupled to LS2 buffer <b>62</b> and reprobe mux <b>70</b>, and is coupled to receive a snoop type on a SnpType bus <b>52</b>B (part of snoop interface <b>52</b>) and a fill tag on fill tag bus <b>84</b> from bus interface unit <b>37</b>. LS2 control logic <b>66</b> is further coupled to a resync line <b>122</b> to reorder buffer <b>32</b>.</p><p>Generally speaking, load/store unit <b>26</b> is configured to store load memory operations into LS2 buffer <b>62</b> independent of the memory operations data cache hit/miss status. Additionally, LS2 control logic <b>66</b> is configured to snoop memory operations within LS2 buffer <b>62</b> against snoop requests from bus interface unit <b>37</b>. If a load which is a data cache hit (a \u201cload hit\u201d for discussion of FIGS. 12-16) is snoop hit by a snoop invalidate request (e.g. due to a store to the address by another processor), LS2 control logic <b>66</b> scans the older memory operations within LS2 buffer <b>62</b>. If any older load memory operations within LS2 buffer <b>62</b> are data cache misses (a \u201cload miss\u201d for discussion of FIGS. <b>12</b>-<b>16</b>), a synchronization indication is set for that older load memory operation. Subsequently, the older load miss is completed. LS2 control logic <b>66</b> detects the synchronization indication while completing the load miss, and signals reorder buffer <b>32</b>. Reorder buffer <b>32</b> responds to the signal by synchronizing to the instruction corresponding to the completing load miss. Advantageously, the load hit which was performed out of order and which was found to violate strong memory ordering rules is discarded and reexecuted. When reexecuted, the load hit may receive the updated value for the memory location accessed and strong ordering may be achieved.</p><p>Generally, a \u201csnoop invalidate request\u201d is a type of snoop request which causes the snooped cache line (if found) to be invalidated. Similarly, a snoop invalidate operation is a snoop operation which causes the snooped cache line (if found) to be invalidated. Among other reasons, a snoop invalidate operation may be initiated if a store to the snooped cache line is being performed by another processor, to allow that processor to establish proper ownership of the cache line prior to performing the store. The term \u201cownership\u201d refers to the level of access to a cache line which is granted to a particular processor storing the cache line, and to the level of responsibility of that particular processor for maintaining coherency of that cache line. The ownership may be determined by the ownership maintained by other processors as well as by system level considerations, and is generally one of several states defined according to a coherency scheme. For example, the MOESI coherency scheme defines the modified state (in which the processor has exclusive use of the cache line and has modified it with respect to the data stored in main memory), the owned state (in which the processor is responsible for maintaining coherency of the cache line but has shared the modifications made by the processor with at least one other processor), the exclusive state (in which the processor has exclusive use of the cache line but has not modified it), the shared state (in which two or more processors have shared use of the cache line), and the invalid state (in which the processor has no use of the cache line). Other coherency schemes (such as the MESI, MOSI, etc.) schemes are possible as well.</p><p>As used herein, the term \u201csynchronization\u201d refers to restoring the speculative state of the processor to a state consistent with a particular point in the instruction sequence being executed. More particularly, the speculative state of processor does not reflect execution of any instructions beyond the particular point. Instructions may be fetched starting at the particular point subsequent to the synchronization. Generally, synchronization may be performed to correct the effects of incorrect speculative execution.</p><p>In one embodiment, the synchronization indication within LS2 buffer <b>62</b> comprises snoop resync bit <b>96</b>O. Snoop resync bit <b>96</b>O may be set to indicate that synchronization is to be performed upon completion of the corresponding load.</p><p>Accordingly, upon detecting a snoop hit for a snoop invalidate request on a load hit within LS2 buffer <b>62</b>, LS2 control logic <b>66</b> scans LS2 buffer <b>62</b> for older load miss entries and sets the corresponding snoop resync bit <b>96</b>O. Alternatively, the bit may be set initially and cleared to indicate synchronization, as desired. Load misses may be indicated, e.g., by the miss bit <b>96</b>M being set in the corresponding LS2 buffer entry.</p><p>The snoop requests conveyed to load/store unit <b>26</b> include a snoop address provided on snoop address bus <b>52</b>A and a snoop type conveyed on SnpType bus <b>52</b>B.</p><p>The snoop address is compared, via comparators <b>120</b>, to the data address stored in each entry of LS2 buffer <b>62</b>. Accordingly, a comparator <b>120</b> may be included for each LS2 buffer entry. Comparators <b>120</b>A-<b>120</b>B are illustrated as exemplary comparators to maintain simplicity in the drawing. If the comparator <b>120</b> detects that the snoop address is within the same cache line as the data address of the corresponding memory operation, the comparator signals LS2 control logic <b>66</b>. LS2 control logic <b>66</b> examines the identified entry or entries and the snoop type provided by bus interface unit <b>37</b>. If the snoop type is invalidate and the identified entry is a hit, LS2 control logic <b>66</b> scans the older LS2 buffer entries and sets the corresponding snoop resync bits <b>96</b>O if any older load misses are found. LS2 control logic <b>66</b> may perform other snoop operations using the output of comparators <b>120</b>, as desired. For example, a store which hit data cache <b>28</b> during its initial probe may be indicated to be a miss in response to a probe, so that the store will be reprobed before attempting to commit data to the cache.</p><p>The older load miss entries are subsequently completed in response to a fill tag from bus interface unit <b>37</b> matching the MAB tag assigned to the older load miss, in the present embodiment. Generally, a memory operation is referred to as \u201ccomplete\u201d if status corresponding to the memory operation has been returned to reorder buffer <b>32</b>. Reorder buffer <b>32</b> is configured to retire the memory operation according to the returned status (which may indicate synchronization, exception, etc.). Synchronization may be indicated by asserting the resync signal on resync line <b>122</b> while data is being forwarded for the corresponding load memory operation (e.g. during the cache access stage of the pipeline embodiment shown above). Other signal lines may be used to report other status, as desired.</p><p>Reorder buffer <b>32</b> may respond to the resync signal in a manner similar to branch mispredictions: by discarding the instructions subsequent to the instruction corresponding to the load for which the resync signal is asserted, and refetching the instructions. Since the load hit which was snoop hit in order to cause the synchronization is subsequent to the load miss in program order, the load hit is discarded, refetched, and reexecuted. It is noted that memory operations within LS1 buffer <b>60</b> and LS2 buffer <b>62</b> corresponding to discarded instructions are deleted. Any suitable discard scheme may be employed by reorder buffer <b>32</b>. For example, reorder buffer <b>32</b> may broadcast the tag of the instruction for which subsequent instructions are to be discarded, and load/store unit <b>26</b> (and other portions of processor <b>10</b>) may discard the corresponding instructions and memory operations. Alternatively, reorder buffer <b>32</b> may communicate with load/store unit <b>26</b> to identify memory operations to be discarded using retire interface <b>54</b>. Load/store unit <b>26</b> may forward random data for loads to be discarded, and dependent instructions may execute and return results to reorder buffer <b>32</b>, which may then discard the instructions.</p><p>Upon reexecution, the correct value for the load will be read from memory (since the snoop invalidate request is also transmitted to data cache <b>28</b> and causes the cache line accessed by the load to be invalidated). In this manner, strong memory ordering is observed while allowing load hits to generally precede load misses where strong memory ordering is not violated.</p><p>It is noted that the term \u201ccache line\u201d has been used herein to describe the granularity upon which coherency is maintained. However, other granularities corresponding to a portion of a cache line or multiple cache lines may be used. Accordingly, coherency may be maintained on a \u201ccache block\u201d basis, which may be a portion of a cache line, a cache line, or multiple cache lines, as desired.</p><p>Turning next to FIG. 14, a flowchart is shown illustrating the operations performed by the embodiment of LS2 control logic <b>66</b> shown in FIG. 13 in response to a snoop operation. Other embodiments are possible and contemplated. LS2 control logic <b>66</b> determines if the snoop request hits a load hit and the snoop type is invalidate (decision block <b>126</b>). If the snoop request does hit a load hit and the snoop type is invalidate, LS2 control logic <b>66</b> scans the older LS2 entries and sets the snoop resync bit for each load miss (step <b>128</b>). Conversely, if the snoop request does not hit a load hit or the snoop type is not invalidate, LS2 control logic <b>66</b> does nothing. Optionally, other snoop activities may be performed in connection with maintaining coherency, as desired.</p><p>In an alternative embodiment, LS2 control logic <b>66</b> may set the snoop resync bit for the load hit which is hit by the snoop. When each load miss is reprobed, the LS2 control logic <b>66</b> may scan LS2 buffer <b>62</b> to determine if any valid entries have the snoop resync bit set. If at least one snoop resync bit is set, LS2 control logic <b>66</b> may return resync status for the load miss.</p><p>Turning next to FIG. 15, a flowchart is shown illustrating the operations performed by the embodiment of LS2 control logic <b>66</b> shown in FIG. 13 in order to complete a load miss operation. Other embodiments are possible and contemplated. LS2 control logic <b>66</b> determines if a load miss is in the data forward pipeline stage of the pipeline (decision block <b>130</b>). For example, in the present embodiment the data forward pipeline stage is the cache access stage. LS2 control logic <b>66</b> may determine if a load miss is in the cache access stage by examining its pipe field <b>96</b>I, for example. If no load miss is in the data forward pipeline stage, then no action is taken with respect to the resync signal. On the other hand, if a load miss is in the data forward pipeline stage, LS2 control logic <b>66</b> examines the corresponding snoop resync bit <b>96</b>O (step <b>132</b>). If the corresponding snoop resync bit <b>96</b>O is set, then LS2 control logic <b>66</b> asserts the resync signal on resync line <b>122</b> to return resync status (step <b>134</b>). On the other hand, if the corresponding snoop resync bit <b>96</b>O is clear, then LS2 control logic <b>66</b> deasserts the resync signal to return normal status (step <b>136</b>). It is noted that other status, such as exceptions, may be returned in the normal status state from other logic.</p><p>Turning next to FIG. 16, an example is shown of the operation of one embodiment of LS2 buffer <b>62</b> for processor <b>2</b> in the timing diagram of FIG. <b>12</b>. Select portions of the LS2 buffer entries are illustrated, including address field <b>96</b>C (Addr in FIG. <b>16</b>), miss bit <b>96</b>M (Miss in FIG. <b>16</b>), and snoop resync bit <b>96</b>O (SR in FIG. <b>16</b>).</p><p>At reference numeral <b>140</b>, LS2 buffer <b>62</b> is shown subsequent to detecting the load miss for address A<b>2</b> and the load hit for address A<b>1</b>. Accordingly, an LS2 buffer entry containing address A<b>2</b> has the miss bit set and the snoop resync bit clear, while an LS2 buffer entry containing address A<b>1</b> has the miss bit and the snoop resync bit clear .</p><p>After receiving the snoop invalidate request corresponding to processor <b>1</b>'s store to address A<b>1</b>, reference numeral <b>142</b> illustrates the state of LS2 buffer <b>62</b>. The snoop resync bit for the entry containing address A<b>2</b> has been set by virtue of the load to address A<b>2</b> being older than the load hit to address A<b>1</b> and the load to address A<b>2</b> being a miss.</p><p>Subsequent to the snoop invalidate request, bus interface unit <b>37</b> returns the fill tag matching the MAB tag for the load to address A<b>2</b>. Load/store unit <b>26</b> returns resync status to reorder buffer <b>32</b> for the load to address A<b>2</b>, and processor <b>2</b> synchronizes. The synchronization causes the entry for address A<b>1</b> to be discarded. At reference numeral <b>144</b>, the state of LS2 buffer <b>62</b> subsequent to the synchronization (and retirement of the instruction corresponding to the load to address A<b>2</b>) is illustrated. LS2 buffer <b>62</b> is empty at reference numeral <b>144</b>.</p><p>Processor <b>2</b> refetches the discarded instructions, including the load to address A<b>1</b>. At reference numeral <b>146</b>, the state of LS2 buffer <b>62</b> upon probing for the load to address A<b>1</b> is shown. Accordingly, the miss bit for the load to address A<b>1</b> is set. Finally, the fill tag matching the MAB tag for the load to address A<b>1</b> is returned from bus interface unit <b>37</b>, along with data reflecting processor <b>1</b>'s update to address A<b>1</b>. The correct data is forwarded within processor <b>2</b>. Subsequent to retiring the load to address A<b>1</b>, LS2 buffer <b>62</b> is empty (reference numeral <b>148</b>).</p><p>Self-Modifying Code Checks</p><p>Turning now to FIG. 17, a block diagram of one embodiment of a portion of one embodiment of load/store unit <b>26</b> is shown. Other embodiments are possible and contemplated. The embodiment shown in FIG. 17 is configured to initiate self-modifying code (SMC) checks for store memory operations. In other words, the embodiment shown is configured to initiate a check to determine if a store memory operation modifies memory locations which have been fetched as instructions and are in-flight within processor <b>10</b>. The embodiment of FIG. 17 includes LS2 buffer <b>62</b>, LS2 control logic <b>66</b>, and a plurality of comparators <b>150</b>A-<b>150</b>B. Comparators <b>150</b>A-<b>150</b>B are coupled to receive retire tags from reorder buffer <b>32</b> via a retire tags bus <b>54</b>A (part of retire interface <b>54</b>), and are coupled to LS2 buffer <b>62</b> and LS2 control logic <b>66</b>. LS2 control logic <b>66</b> is further coupled to LS2 buffer <b>62</b> and to resync line <b>122</b>, an SMC check line <b>152</b>, an address bus <b>154</b>, an SMC result line <b>156</b>, and an I-stream UC line <b>158</b>. Resync line <b>122</b> is coupled to reorder buffer <b>32</b> and the other interconnect is coupled to instruction cache <b>16</b>.</p><p>Generally speaking, the apparatus described herein attempts to minimize the number of explicit SMC checks performed within processor <b>10</b>. SMC checks generally involve transmitting the store address to destinations within processor <b>10</b> at which information regarding the instructions in-flight within processor <b>10</b> is stored. The store address is compared to the instruction addresses of the in-flight instructions to determine if the store updates any of the in-flight instructions. If it is determined that in-flight instructions have been updated, corrective action is taken (e.g. discarding the instructions subsequent to the instruction corresponding to the store in program order and refetching those instructions). Updating of the cache and returning status for the store is delayed until the check is completed, which may take several clock cycles.</p><p>More particularly, the apparatus shown attempts to minimize SMC checks for non-cacheable stores. SMC checks for cacheable stores may be minimized, for example, by maintain exclusion between data cache <b>28</b> and instruction cache <b>16</b>. In other words, a particular cache line is allowed to exist in at most one of data cache <b>28</b> and instruction cache <b>16</b> at any given point in time. By maintaining exclusion, SMC checks for stores which hit in data cache <b>16</b> may be skipped because instructions cannot be fetched from the cache line without evicting the cache line from data cache <b>28</b> (which would cause the store to be a miss). Therefore, SMC checks may be performed for cacheable stores which miss. Alternatively, an indication may be included within each data cache line to indicate whether or not the cache line is also stored in instruction cache <b>16</b>. If a store is a miss or a hit for a cache line which is also stored in instruction cache <b>16</b>, the SMC check is performed. Other embodiments for handling cacheable store SMC checks are contemplated. It is noted that the cacheability of a store may be determined during translation of the store address (which is performed during probing of data cache <b>28</b> prior to placing the stores in LS2 buffer <b>62</b>). For example, in the embodiment described above, the memory type field <b>96</b>Q may store cacheability information for the store memory operation.</p><p>For non-cacheable stores, caching policies are ineffective for minimizing SMC checks since there is no corresponding cache line. However, if the store is non-cacheable, then instruction fetches from the same memory locations are also non-cacheable. Instruction cache <b>16</b> tracks the cacheability of the instructions in-flight within processor <b>10</b>. If one or more in-flight instructions are non-cacheable, then instruction cache <b>16</b> asserts an I-stream UC signal on I-stream UC line <b>158</b>. The asserted I-stream UC signal indicates to load/store unit <b>26</b> that at least one non-cacheable instruction is in-flight, while the deasserted I-stream UC signal indicates that each in-flight instruction is cacheable. It is noted that the terms non-cacheable and uncacheable may be used herein. The terms non-cacheable and uncacheable are intended to be synonymous herein and indicate that the memory locations referenced by the store address or instruction address are inhibited from storage within caches.</p><p>LS2 control logic <b>66</b> determines whether or not to perform SMC checks for a particular store once the particular store is otherwise in condition for updating the affected memory locations (either in data cache <b>28</b> or through bus interface unit <b>37</b> to other cache levels and/or main memory). In the present embodiment, a store may perform its update in response to being indicated as retireable by reorder buffer <b>32</b>. Accordingly, comparators <b>150</b>A-<b>150</b>B are provided. Reorder buffer <b>32</b> provides retire tags (instruction tags corresponding to memory operations being retired by reorder buffer <b>32</b>) to comparators <b>150</b>A-<b>150</b>B. Comparators <b>150</b>A-<b>150</b>B compare the retire tags to the instruction tags within each LS2 buffer entry to locate memory operations being retired. Accordingly, the number of comparators may be equal to the number of memory operations which may be concurrently retired by reorder buffer <b>32</b> multiplied by the number of entries within LS2 buffer <b>62</b>. However, for simplicity in the drawing, only comparators <b>150</b>A-<b>150</b>B have been illustrated. In one embodiment, up to two memory operations may be retired by reorder buffer <b>32</b> concurrently.</p><p>Comparators <b>150</b>A-<b>150</b>B signal LS2 control logic <b>66</b> if a match is detected between the retire tags and the instruction tag within the corresponding entry. LS2 control logic <b>66</b> determines if the identified entries are stores, and if an SMC check is to be performed. If the store is cacheable, LS2 control logic <b>66</b> determines whether or not to perform an SMC check as described above. If the store is non-cacheable, an SMC check is performed if the I-stream UC signal is asserted. If an SMC check is not indicated, LS2 control logic <b>66</b> returns normal status for the store and marks the store as retired within LS2 buffer <b>62</b> (e.g. via the retired bit <b>96</b>J within the corresponding entry).</p><p>If an SMC check is indicated, LS2 control logic <b>66</b> initiates an SMC check by asserting an SMC check signal on SMC check line <b>152</b> and transmitting the store data address on address bus <b>154</b> to instruction cache <b>16</b>. Instruction cache <b>16</b> performs the SMC check, and returns a result upon SMC result line <b>156</b>. For example, instruction cache <b>16</b> may assert a signal indicating that the SMC check is complete and provide a second signal identifying the result as an SMC hit (correction is to be performed) or an SMC miss (correction is not to be performed). If the result is SMC hit, LS2 control logic <b>66</b> returns a synchronization indication to reorder buffer <b>32</b> via resync line <b>122</b>. Otherwise, normal status is returned for the store (allowing reorder buffer <b>32</b> to retire the corresponding instruction). Reorder buffer <b>32</b> may synchronize after the store in a manner similar to mispredicted branches, by discarding the instructions subsequent to the instruction corresponding to the store and refetching the instructions. Since the instructions are fetched after the store has updated the targeted memory locations, the correct instructions are fetched upon refetching.</p><p>It is noted that LS2 control logic <b>66</b> may use comparisons between the retire tags and LS2 buffer entries for other purposes as well, depending upon other design considerations. For example, the retire tags may also identify memory operations which have already returned status to reorder buffer <b>32</b> and hence are actually being retired by reorder buffer <b>32</b>. LS2 control logic <b>66</b> may delete load hits from LS2 buffer</p><p>Turning next to FIG. 18, a state machine diagram illustrative of the performance of an SMC check for a store is shown. Other embodiments are possible and contemplated. The embodiment shown in FIG. 18 may be implemented, for example, by storing the current state for each store in the SMC field <b>96</b>N of the corresponding LS2 buffer entry.</p><p>The SMC state machine is initially in an SMC idle state <b>160</b>. The SMC state machine remains in the SMC idle state if the store is not yet retireable (as indicated by receiving a retire tag for the store). Upon receiving an indication that the store is retireable, the SMC state machine transitions to one of two states: SMC check state <b>162</b> or SMC complete state <b>164</b>. SMC check state <b>162</b> is selected if the store is a cacheable store for which an SMC check is to be performed or if the store is non-cacheable and the I-stream UC signal is asserted. Additionally, the SMC check signal is asserted and the store address of the store is transmitted to instruction cache <b>16</b>. On the other hand, the SMC state machine transitions from SMC idle state <b>160</b> to SMC complete state <b>164</b> if LS2 control logic <b>66</b> determines that the store does not require an SMC check. Normal status is returned to reorder buffer <b>32</b> in this case, and the store is indicated as retired within the corresponding LS2 buffer entry.</p><p>The SMC state machine remains in SMC check state <b>162</b> until an SMC result is provided by instruction cache <b>16</b>. Upon receiving the SMC result, the SMC state machine transitions to SMC complete state <b>164</b>. Additionally, LS2 control logic <b>66</b> returns either a synchronization status or a normal status in response to the SMC result provided.</p><p>The SMC state machine remains in SMC complete state <b>164</b> until the store is selected for updating the memory locations specified by the store address. Generally, the store will be selected quickly as it is the oldest operation within LS2 buffer <b>62</b> (by virtue of being retired). Upon selection, the store is transmitted to data cache <b>28</b> for updating if the store is cacheable, or is transmitted to bus interface unit <b>37</b> if the store is non-cacheable. The store may then be deleted from LS2 buffer <b>62</b>, effectively returning the SMC state machine to SMC idle state <b>160</b>.</p><p>Turning next to FIG. 19, a block diagram of a portion of instruction cache <b>16</b> is shown. For simplicity in the drawing, only portions of instruction cache <b>16</b> involved in performing an SMC check for in-flight instructions are shown. Other portions may include the instruction cache storage and control, instruction address translation, etc. Other embodiments are possible and contemplated. In the embodiment of FIG. 19, instruction cache <b>16</b> includes an in-flight buffer <b>170</b>, fetch logic <b>172</b>, SMC logic <b>174</b>, snoop/victim comparators <b>176</b>A-<b>176</b>B, and SMC comparators <b>178</b>A-<b>178</b>B. Fetch logic <b>172</b> is coupled to provide a fetch address which is being fetched from instruction cache <b>16</b> (or main memory) and the state of the fetch address to in-flight buffer <b>170</b>. Instructions become in-flight upon their fetch from instruction cache <b>16</b> or main memory into the instruction processing pipeline of processor <b>10</b>. In-flight buffer <b>170</b> is further coupled to SMC logic <b>174</b>, snoop/victim comparators <b>176</b>A-<b>176</b>B, and SMC comparators <b>178</b>A-<b>178</b>B. SMC logic <b>174</b> is further coupled to snoop/victim comparators <b>176</b>A-<b>176</b>B and SMC comparators <b>178</b>A-<b>178</b>B. Additionally, SMC logic <b>174</b> is coupled to receive an SMC check signal on SMC check line <b>152</b> and to provide an SMC result signal on SMC result line <b>156</b> and an I-stream UC signal on I-stream UC line <b>158</b>. SMC logic <b>174</b> is further coupled to provide a fetch in-flight buffer (IFB) tag to reorder buffer <b>32</b> on a fetch IFB tag bus <b>180</b> and to receive a retire IFB tag from reorder buffer <b>32</b> on a retire IFB tag bus <b>182</b>. SMC comparators <b>178</b>A-<b>178</b>B are coupled to receive an SMC address on address bus <b>154</b>. Snoop/victim comparators <b>176</b>A-<b>176</b>B are coupled to receive a snoop or victim address from fetch logic <b>172</b>.</p><p>Generally speaking, in-flight buffer <b>170</b> stores instruction addresses of in-flight instructions. Additionally, in-flight buffer <b>170</b> stores a state corresponding to the instruction addresses. In one embodiment, the state may include prefetch buffer, cache, or not cached. The prefetch buffer state indicates that the instructions are stored in a prefetch buffer employed by instruction cache <b>16</b> (not shown). The cache state indicates that the instructions are stored in instruction cache <b>16</b>. The not cached state indicates that the instructions are not stored in instruction cache <b>16</b> (for example, because the instructions are in a non-cacheable area of memory, or because the instructions are a miss in instruction cache <b>16</b>, or because the instructions were previously a hit in instruction cache <b>16</b> but later were removed from instruction cache <b>16</b> due to a probe invalidation or other cache replacement). SMC logic <b>174</b> allocates an entry within in-flight buffer <b>170</b> in response to an instruction address being fetched by fetch logic <b>172</b>. The entry is identified by an IFB tag which is transmitted through the pipeline to reorder buffer <b>32</b> along with the fetched instructions. Reorder buffer <b>32</b> records the IFB tag and returns the IFB tag in response to retiring or discarding the instructions corresponding to the IFB tag. SMC logic <b>174</b> deletes the corresponding entry within in-flight buffer <b>170</b> in response to the retiring IFB tag. Accordingly, the instruction addresses within in-flight buffer <b>170</b> represent the in-flight instructions. It is noted that, in one embodiment, reorder buffer <b>32</b> may concurrently retire instructions corresponding to more than one IFB tag. In such an embodiment, reorder buffer <b>32</b> may provide the youngest IFB tag on retire IFB tag bus <b>182</b>. SMC logic <b>174</b> may delete each entry older than the entry identified by the retiring IFB tag (e.g. at a rate of one entry per clock cycle or any other suitable rate).</p><p>SMC logic <b>174</b> generates the I-stream UC signal in response to the states of the in-flight instructions. If one or more in-flight instructions are not cached, as indicated by the not-cached states in in-flight buffer <b>170</b>, SMC logic <b>174</b> asserts the I-stream UC signal. If all instructions are cached or in the prefetch buffers, then SMC logic <b>174</b> deasserts the I-stream UC signal.</p><p>In one embodiment, fetch addresses are recorded on a fetch block granularity. Instruction cache <b>16</b> provides a block of contiguous instruction bytes in response to a fetch address (the \u201cfetch block\u201d), which may comprise one or more instructions. The fetch block is passed to instruction scanning and alignment logic as a group (e.g. into an instruction queue or other similar mechanism). In various embodiments, the fetch block may comprise a cache line, or a predefined portion of a cache line, according to design choice. The fetch block is represented by one entry within in-flight buffer <b>170</b>. The number of entries for in-flight buffer <b>170</b> may be determined according to the number of fetch blocks which may be in-flight within processor <b>10</b>, and therefore may be dependent upon the number of pipeline stages in processor <b>10</b>, the superscalar issue width, the number of reorder buffer entries, etc. In one specific implementation, <b>32</b> entries are provided although any number may be used.</p><p>SMC logic <b>174</b> performs SMC checks responsive to the SMC check signal provided by load/store unit <b>26</b>. In parallel with SMC logic <b>174</b> receiving the SMC check signal, SMC comparators <b>178</b> receive the SMC address. SMC comparators <b>178</b> are coupled to corresponding entries within in-flight buffer <b>170</b>. Accordingly, the number of SMC comparators <b>178</b> may be equal to the number of entries within in-flight buffer <b>170</b>. For simplicity in the drawing, SMC comparators <b>178</b>A-<b>178</b>B are illustrated. Comparators <b>178</b> compare the SMC address to the instruction addresses recorded within in-flight buffer <b>170</b>. Comparators <b>178</b> are configured to compare the addresses exclusive of the bits which define an offset within the fetch block, and hence perform a compare to determine if the SMC address is within the same fetch block as the addresses recorded within in-flight buffer <b>170</b>. If a match is detected, the corresponding comparator <b>178</b> signals SMC logic <b>174</b>. SMC logic <b>174</b> asserts signals on SMC result line <b>156</b> to indicate that an SMC hit has been detected if one or more of comparators <b>178</b> signals a match and an SMC check is being signalled. On the other hand, if an SMC check is signalled and none of comparators <b>178</b> indicate a match, then SMC logic <b>174</b> asserts signals on SMC result line <b>156</b> to indicate that an SMC miss has been detected.</p><p>It is noted that the SMC address may be provided to other portions of instruction cache <b>16</b> as well. For example, the SMC address may be provided to instruction cache storage and control, to cause the eviction of a cache line matching the SMC address. Additionally, instruction cache <b>16</b> may include one or more miss buffers for cache lines to be transferred from bus interface unit <b>37</b>, and the SMC check may be performed against the miss buffers as well.</p><p>The state of a fetch block provided by fetch logic <b>172</b> along with the instruction address represents the state of the fetch block upon fetch thereof. The state may change while the instructions are in-flight, and SMC logic <b>174</b> is configured to monitor for such state changes and to update in-flight buffer <b>170</b> to reflect the changes. For example, a snoop invalidate request may cause a cache line to be evicted from instruction cache <b>16</b>. Similarly, instruction cache misses may cause the eviction of a cache line to store the instruction bytes of the missing instruction cache line. Other conditions may cause a cache line to be evicted according to design choice. For example, an embodiment of processor <b>10</b> which maintains exclusion between instruction cache <b>16</b> and data cache <b>28</b> may cause an instruction cache eviction when the cache line is allocated into data cache <b>28</b>.</p><p>Fetch logic <b>172</b> provides victim addresses (of cache lines which are being evicted) and snoop addresses to comparators <b>176</b>A-<b>176</b>B. As with comparators <b>178</b>, comparators <b>176</b> may be provided for each in-flight buffer entry. However, for simplicity in the drawing, comparators <b>176</b>A-<b>176</b>B are shown. Furthermore, if concurrent comparisons of snoop addresses and victim addresses are desired, separate comparators <b>176</b> may be provided for each input address. These addresses are compared (on a cache line basis, which may differ from the fetch block basis) to addresses within in-flight buffer entries. In other words, address bits which provide an offset within the cache line are excluded from the comparison performed by comparators <b>176</b>. If a comparator <b>176</b> detects a match, a corresponding signal is asserted to SMC logic <b>174</b>. In response, SMC logic <b>174</b> changes the state of the identified entry to not cached (which may result in the assertion of the I-stream NC signal, if the I-stream NC signal is deasserted).</p><p>It is noted that in-flight buffer may be used for other purposes as well, according to design choice. It if further noted that, in other embodiments, SMC checks may be performed in reorder buffer <b>32</b> and pipeline stages prior to reorder buffer <b>32</b>, as desired.</p><p>Turning now to FIG. 20, a flowchart illustrating operations which may be performed by one embodiment of SMC logic <b>174</b> is shown. Other embodiments are possible and contemplated. While the steps shown in FIG. 20 are illustrated in a particular order for ease of understanding, any suitable order may be used. Additionally, steps may be performed in parallel by combinatorial logic within SMC logic <b>174</b>.</p><p>If an SMC check is signalled (decision block <b>300</b>), SMC logic <b>174</b> determines if comparators <b>178</b> are indicating an SMC hit (decision block <b>302</b>). If an SMC hit is detected, SMC logic <b>174</b> signals load/store unit <b>26</b> that an SMC hit has occurred for the SMC check (step <b>304</b>). Conversely, if an SMC hit is not detected, SMC logic <b>174</b> signals load/store unit <b>26</b> that an SMC miss has been detected (step <b>306</b>).</p><p>If a fetch occurs (decision block <b>308</b>), SMC logic <b>174</b> allocates an in-flight buffer entry for the instruction address and transmits an IFB tag corresponding to the entry (step <b>310</b>). If a retire IFB tag is received (decision block <b>312</b>), SMC logic <b>174</b> deallocates the identified in-flight buffer entry (step <b>314</b>). If a snoop or eviction is detected by comparators <b>176</b> (decision block <b>316</b>), SMC logic <b>174</b> sets the state of the affected entry to not cached (step <b>318</b>). Finally, SMC logic <b>174</b> asserts the I-stream UC signal if one or more in-flight buffer entries are in the not-cached state (step <b>320</b>).</p><p>Exponential Backoff</p><p>Turning now to FIG. 21, a block diagram of one embodiment of a portion of one embodiment of load/store unit <b>26</b> is shown. Other embodiments are possible and contemplated. In the embodiment of FIG. 21, load/store unit <b>26</b> includes LS2 buffer <b>62</b>, LS2 control logic <b>66</b>, comparators <b>120</b>A-<b>120</b>B, snoop address bus <b>54</b>A and snoop type bus <b>54</b>B. The above elements are coupled together in a manner similar to that described above for the embodiment of FIG. <b>13</b>. Additionally, the embodiment of FIG. 21 includes a time stamp counter register <b>330</b>, a time stamp incrementor <b>332</b>, and a backoff delay mux <b>334</b>. Time stamp counter register <b>330</b> is coupled to time stamp incrementor <b>332</b> and to backoff delay mux <b>334</b>. Backoff delay mux <b>334</b> is coupled to receive selection controls from LS2 control logic <b>66</b> and to provide a backoff delay signal to bus interface unit <b>37</b>. LS2 control logic <b>66</b> is further coupled to a backoff line <b>336</b>, which is further coupled to bus interface unit <b>37</b>.</p><p>Generally speaking, load/store unit <b>26</b> is configured to avoid deadlock in multiprocessor systems for cases in which two or more processors are attempting to obtain ownership of a particular cache line. Load/store unit <b>26</b> may accomplish deadlock avoidance by detecting cases in which a snoop hit to a memory operation within LS2 buffer <b>62</b> causes processor <b>10</b> to lose sufficient ownership to complete that memory operation. For example, processor <b>10</b> loses sufficient ownership to complete a load memory operation if a previously valid cache line accessed by the load is invalidated. On the other hand, processor <b>10</b> loses sufficient ownership to complete a store memory operation if a cache line accessed by the store is previously in a state other than invalid or shared and the cache line is changed to invalid or shared in response to a snoop hit. In response to losing sufficient ownership, load/store unit <b>26</b> is configured to signal bus interface unit <b>37</b> to backoff (via a backoff signal on backoff line <b>336</b>) and to increase the initial backoff time. The backoff time is increased each time the ownership is gained and then lost before the affected memory operation can be completed. Eventually, the memory operation may be completed (after the other processor successfully completes its memory operation) and the backoff time may be reset to its initial value. The term \u201cbackoff time\u201d refers to a time interval during which processors are configured to inhibit attempting to reestablish ownership of a cache line for which ownership was lost via a snoop operation. It is noted that load/store unit <b>26</b> may be configured to perform the backoff internally (e.g. by not attempting to transmit commands to bus interface unit <b>37</b> for transmittal on the bus).</p><p>As described above for the embodiment of FIG. 13, comparators <b>120</b> (including comparators <b>120</b>A-<b>120</b>B and other comparators for other LS2 buffer entries) are configured to compare the snoop address of a snoop operation to the addresses within LS2 buffer <b>62</b>. If a snoop hit is detected for an entry, LS2 control logic <b>66</b> updates the status of that entry to reflect the state that the corresponding cache line is being updated S to (in parallel, by data cache <b>28</b>, in response to the snoop address and snoop type). Additionally, if the new state of the cache line indicates that processor <b>10</b> lost sufficient ownership of the cache line to complete the memory operation within LS2 buffer <b>62</b>, LS2 control logic <b>66</b> may be configured to increase the backoff time employed by bus interface unit <b>37</b>.</p><p>In one particular embodiment, LS2 control logic <b>66</b> may update store memory operations which are hit by a snoop to indicate that the store memory operations are misses or require a state change from shared to exclusive before they can be completed. Subsequently, these stores may be selected for fetching the corresponding cache line from memory or for performing the state change. After successfully completing these operations, the store may be completed. Additionally, an embodiment may handle load memory operations in a manner similar to the embodiment shown in FIG. <b>13</b>.</p><p>LS2 control logic <b>66</b> may limit increasing backoff times to cases in which sufficient ownership is lost for the oldest memory operation within LS2 buffer <b>62</b>. In this manner, backoff is not increased each time ownership is lost by any memory operation within LS2 buffer <b>62</b>. If deadlock would otherwise occur for a particular memory operation, that memory operation will eventually become the oldest memory operation in-flight as older memory operations successfully complete. Additionally, such an embodiment may be simpler to implement than other embodiments.</p><p>Still further, such an embodiment may successfully prevent deadlock in cases in which an instruction performs a memory operation which is misaligned across a cache line boundary (i.e. the memory operation accesses one or more bytes from a first cache line and one or more bytes from a second, succeeding cache line). Memory operations which are misaligned across a cache line boundary require sufficient ownership of both cache lines to complete. Load/store unit <b>26</b> may handle misaligned cases by performing two memory operations derived from the same instruction (one accessing each cache line). Accordingly, backoff may be implemented for the first of the cache lines (when it becomes oldest), preventing processors from swapping ownership of the two cache lines without one processor achieving ownership of both cache lines simultaneously long enough to complete the memory operation.</p><p>In the present embodiment, the backoff time employed by bus interface unit <b>37</b> may be derived from time stamp counter register <b>330</b>. Generally, time stamp counter register <b>330</b> may be employed by processor <b>10</b> to measure time elapsed. In other words, the difference between the values stored in time stamp counter register <b>330</b> at two arbitrary points in time reflects the time elapsed between those two points. Time stamp incrementor <b>332</b> may, for example, increment time stamp counter register <b>330</b> each clock cycle. In another embodiment, time stamp counter register <b>330</b> may be incremented in a clock-frequency-independent fashion to correctly reflect real time. For example, time stamp incrementor <b>332</b> may receive a signal independent of the clock signals used to clock processor <b>10</b>, and may increment time stamp counter register <b>330</b> once per interval of the received signal.</p><p>Backoff delay mux <b>334</b>, under the control of LS2 control logic <b>66</b>, is configured to select a backoff delay for use by bus interface unit <b>37</b>. In one embodiment, backoff delay mux <b>334</b> selects a bit from a predetermined range of bits within time stamp counter register <b>330</b>. The least significant bit within the range specifies the initial and minimum backoff time, and the increased backoff times may be selected by selecting other bits within the range. More particularly, a transition of the selected bit may indicate the expiration of the backoff interval. A transition of a bit is a change in binary state of the bit (i.e. from one to zero or zero to one). Since the least significant bit in the range transitions more often as the value in time stamp counter register <b>330</b> is incremented, the least significant bit specifies the minimum backoff time. Other, more significant bits within the range transition at increasingly longer intervals (actually, an exponential increase as increasingly significant bits are selected in the present embodiment).</p><p>Accordingly, upon detecting that the backoff time is to be increased, LS2 control logic <b>66</b> may control backoff delay mux <b>334</b> to select the next significant bit within the range. Generally, the next significant bit within a multi-bit value is the bit adjacent to but more significant than the currently selected bit within the multi-bit value. Accordingly, each time ownership is gained and lost by processor <b>10</b>, the backoff delay is selected as a more significant bit than the previous selection. The more significant bits within time stamp counter register <b>330</b> transition less frequently, and hence the backoff delay is increased.</p><p>Upon detecting that the oldest memory operation within LS2 buffer <b>62</b> is completed successfully, LS2 control logic <b>66</b> signals backoff delay mux <b>334</b> to select the least significant bit within the predetermined range, thereby resetting the backoff delay to its initial value.</p><p>Turning next to FIG. 22, a backoff state machine illustrative of backing off within one embodiment of bus interface unit <b>37</b> is shown. Other embodiments are possible and contemplated. In the embodiment of FIG. 22, the backoff state machine includes a normal state <b>340</b> and an inhibit state <b>342</b>. The backoff state machine is typically in the normal state, and remains in the normal state unless signalled by load/store unit <b>26</b> to backoff While the backoff state machine is in normal state <b>340</b>, bus interface unit performs transfers of data between instruction cache <b>16</b>, data cache <b>28</b>, the L2 cache, and the bus interface. If signalled to backoff, the backoff state machine transitions to inhibit state <b>342</b>. In inhibit state <b>342</b>, bus interface unit <b>37</b> inhibits initiating transfers of data on the bus interface. Bus interface unit <b>37</b> remains in inhibit state <b>342</b> until the backoff delay specified by load/store unit <b>26</b> expires. Upon expiration of the backoff delay, the backoff state machine returns to normal state <b>340</b>.</p><p>It is noted that, while the above description indicates that bus interface unit <b>37</b> inhibits all memory operations while the backoff state machine is in inhibit state <b>342</b>, other embodiments may allow initiating limited transfers of data. For example, transferring data due to a snoop hit may be initiated during inhibit state <b>342</b>. Other embodiments may still further allow transfers of data corresponding to memory operations other than the ones for which backoff was detected while in inhibit state <b>342</b>.</p><p>Turning now to FIG. 23, a flowchart is shown illustrating operation of one embodiment of LS2 control logic <b>66</b> as shown in FIG. <b>21</b>. Other embodiments are possible and contemplated. While the steps shown in FIG. 23 are illustrated in a particular order for ease of understanding, any suitable order may be used. Additionally, steps may be performed in parallel by combinatorial logic within LS2 control logic <b>66</b>.</p><p>LS2 control logic <b>66</b> determines if a snoop hit is detected for an LS2 buffer entry, and if the snoop hit causes the memory operation in the entry to lose sufficient ownership to complete (decision block <b>350</b>). If decision block <b>350</b> results in a true outcome, LS2 control logic <b>66</b> signals backoff delay mux <b>334</b> to select the next significant time stamp counter bit as the backoff delay (step <b>352</b>). Additionally, LS2 control logic <b>66</b> assert the backoff signal to bus interface unit <b>37</b> (step <b>354</b>). Conversely, if decision block <b>350</b> results in a false outcome, LS2 control logic <b>66</b> leaves the currently selected time stamp counter bit as the backoff delay (step <b>356</b>).</p><p>If LS2 control logic <b>66</b> determines that the memory operation (for which loss of sufficient ownership lead to increasing the backoff delay) is successfully completed or aborted by processor <b>10</b> (decision block <b>358</b>), LS2 control logic <b>66</b> signals backoff delay mux <b>334</b> to select the least significant of the selectable time stamp counter bits as the backoff delay (step <b>360</b>). In other words, the backoff delay is reset to its initial value.</p><p>Turning next to FIG. 24, a timing diagram is shown illustrating exemplary operation of two processors (processor <b>1</b> and processor <b>2</b>) both attempting to perform a store which is misaligned across cache lines A<b>1</b> and A<b>2</b>. Prior to initiating the activities shown in FIG. 24, processor <b>1</b> has exclusive ownership of cache line A<b>1</b> and no ownership (invalid) of cache line A<b>2</b>. Processor <b>2</b>, on the other hand, has no ownership of cache line A<b>1</b> and exclusive ownership of cache line A<b>2</b>. For purposes of the example, each processor may have the portion of the store to A<b>1</b> as the oldest entry in LS2 buffer <b>62</b> and the portion of the store to A<b>2</b> as the second oldest entry in LS2 buffer <b>62</b>.</p><p>At approximately the same time, processor <b>1</b> initiates an operation to gain write access to cache line A<b>2</b> (reference numeral <b>370</b>) and processor <b>2</b> initiates an operation to gain write access to cache line A<b>1</b> (reference numeral <b>372</b>). For example, each processor may initiate a read operation (to read the cache line of data) with an indication that the data is to be modified (and hence that an exclusive copy is requested). In response to snooping the access by processor <b>1</b> to address A<b>2</b>, processor <b>2</b> loses ownership of cache line A<b>2</b>. Similarly, in response to snooping the access by processor <b>2</b> to address A<b>1</b>, processor <b>1</b> loses ownership of cache line A<b>1</b>. Additionally, since the store to address A<b>1</b> is the oldest entry in LS2 buffer <b>62</b>, processor <b>1</b> initiates a backoff interval using the initial backoff time interval.</p><p>While processor <b>1</b> is backed off, processor <b>2</b> attempts to reestablish ownership of cache line A<b>2</b> (reference numeral <b>374</b>). Again, the operation may be a read with modify intent. Processor <b>1</b> loses ownership of cache line A<b>1</b> in response to snooping processor <b>2</b>'s operation. Processor <b>2</b> then has exclusive ownership of both cache lines A<b>1</b> and A<b>2</b>. However, prior to processor <b>2</b> completing the store operation, processor <b>1</b>'s backoff interval expires and processor <b>1</b> attempts to reestablish ownership of cache line A<b>1</b> (reference numeral <b>376</b>). Processor <b>1</b> snoops the operation and loses ownership of cache line A<b>1</b>. Additionally, processor <b>1</b> enters a backoff interval of the initial length as well.</p><p>Similar to processor <b>2</b>'s operation during processor <b>1</b>'s backoff period, processor <b>1</b> attempts to reestablish ownership of cache line A<b>1</b> (reference numeral <b>378</b>). Processor <b>1</b> then has exclusive ownership of both cache lines A<b>1</b> and A<b>2</b>. However, prior to processor <b>1</b> completing the store operation, processor <b>2</b>'s backoff interval expires and processor <b>2</b> attempts to reestablish ownership of cache line A<b>1</b> (reference numeral <b>380</b>). Processor <b>1</b> snoops the operation and loses ownership of cache line A<b>1</b>. Additionally, processor <b>1</b> enters a backoff interval of expanded length due to the repeated loss of ownership. During the expanded backoff interval, processor <b>2</b> attempts to reestablish ownership of cache line A<b>2</b> (reference numeral <b>382</b>). Additionally, due to the additional time available during the expanded backoff interval, processor <b>2</b> completes its store (arrow <b>384</b>).</p><p>Subsequently, the expanded backoff interval expires and processor <b>1</b> attempts to gain ownership of cache lines A<b>1</b> and A<b>2</b> (reference numerals <b>386</b> and <b>388</b>, respectively). Since processor <b>2</b> has completed its write operation, processor <b>2</b> allows processor <b>1</b> to obtain ownership of both cache lines (and provides the updated copies to maintain coherency).</p><p>Computer System</p><p>Turning now to FIG. 25, a block diagram of one embodiment of a computer system <b>200</b> including processor <b>10</b> coupled to a variety of system components through a bus bridge <b>202</b> is shown. Other embodiments are possible and contemplated. In the depicted system, a main memory <b>204</b> is coupled to bus bridge <b>202</b> through a memory bus <b>206</b>, and a graphics controller <b>208</b> is coupled to bus bridge <b>202</b> through an AGP bus <b>210</b>. Finally, a plurality of PCI devices <b>212</b>A-<b>212</b>B are coupled to bus bridge <b>202</b> through a PCI bus <b>214</b>. A secondary bus bridge <b>216</b> may further be provided to accommodate an electrical interface to one or more EISA or ISA devices <b>218</b> through an EISA/ISA bus <b>220</b>. Processor <b>10</b> is coupled to bus bridge <b>202</b> through a CPU bus <b>224</b> and to an optional L2 cache <b>228</b>.</p><p>Bus bridge <b>202</b> provides an interface between processor <b>10</b>, main memory <b>204</b>, graphics controller <b>208</b>, and devices attached to PCI bus <b>214</b>. When an operation is received from one of the devices connected to bus bridge <b>202</b>, bus bridge <b>202</b> identifies the target of the operation (e.g. a particular device or, in the case of PCI bus <b>214</b>, that the target is on PCI bus <b>214</b>). Bus bridge <b>202</b> routes the operation to the targeted device. Bus bridge <b>202</b> generally translates an operation from the protocol used by the source device or bus to the protocol used by the target device or bus.</p><p>In addition to providing an interface to an ISA/EISA bus for PCI bus <b>214</b>, secondary bus bridge <b>216</b> may further incorporate additional functionality, as desired. An input/output controller (not shown), either external from or integrated with secondary bus bridge <b>216</b>, may also be included within computer system <b>200</b> to provide operational support for a keyboard and mouse <b>222</b> and for various serial and parallel ports, as desired. An external cache unit (not shown) may further be coupled to CPU bus <b>224</b> between processor <b>10</b> and bus bridge <b>202</b> in other embodiments. Alternatively, the external cache may be coupled to bus bridge <b>202</b> and cache control logic for the external cache may be integrated into bus bridge <b>202</b>. L2 cache <b>228</b> is further shown in a backside configuration to processor <b>10</b>. It is noted that L2 cache <b>228</b> may be separate from processor <b>10</b>, integrated into a cartridge (e.g. slot <b>1</b> or slot A) with processor <b>10</b>, or even integrated onto a semiconductor substrate with processor <b>10</b>.</p><p>Main memory <b>204</b> is a memory in which application programs are stored and from which processor <b>10</b> primarily executes. A suitable main memory <b>204</b> comprises DRAM (Dynamic Random Access Memory). For example, a plurality of banks of SDRAM (Synchronous DRAM) or Rambus DRAM (RDRAM) may be suitable.</p><p>PCI devices <b>212</b>A-<b>212</b>B are illustrative of a variety of peripheral devices such as, for example, network interface cards, video accelerators, audio cards, hard or floppy disk drives or drive controllers, SCSI (Small Computer Systems Interface) adapters and telephony cards. Similarly, ISA device <b>218</b> is illustrative of various types of peripheral devices, such as a modem, a sound card, and a variety of data acquisition cards such as GPIB or field bus interface cards.</p><p>Graphics controller <b>208</b> is provided to control the rendering of text and images on a display <b>226</b>. Graphics controller <b>208</b> may embody a typical graphics accelerator generally known in the art to render three-dimensional data structures which can be effectively shifted into and from main memory <b>204</b>. Graphics controller <b>208</b> may therefore be a master of AGP bus <b>210</b> in that it can request and receive access to a target interface within bus bridge <b>202</b> to thereby obtain access to main memory <b>204</b>. A dedicated graphics bus accommodates rapid retrieval of data from main memory <b>204</b>. For certain operations, graphics controller <b>208</b> may further be configured to generate PCI protocol transactions on AGP bus <b>210</b>. The AGP interface of bus bridge <b>202</b> may thus include functionality to support both AGP protocol transactions as well as PCI protocol target and initiator transactions. Display <b>226</b> is any electronic display upon which an image or text can be presented. A suitable display <b>226</b> includes a cathode ray tube (\u201cCRT\u201d), a liquid crystal display (\u201cLCD\u201d), etc.</p><p>It is noted that, while the AGP, PCI, and ISA or EISA buses have been used as examples in the above description, any bus architectures may be substituted as desired. It is further noted that computer system <b>200</b> may be a multiprocessing computer system including additional processors (e.g. processor <b>10</b><i>a </i>shown as an optional component of computer system <b>200</b>). Processor <b>10</b><i>a </i>may be similar to processor <b>10</b>. More particularly, processor <b>10</b><i>a </i>may be an identical copy of processor <b>10</b>. Processor <b>10</b><i>a </i>may be connected to bus bridge <b>202</b> via an independent bus (as shown in FIG. 25) or may share CPU bus <b>224</b> with processor <b>10</b>. Furthermore, processor <b>10</b><i>a </i>may be coupled to an optional L2 cache <b>228</b><i>a </i>similar to L2 cache <b>228</b>.</p><p>It is still further noted that the present discussion may refer to the assertion of various signals. As used herein, a signal is \u201casserted\u201d if it conveys a value indicative of a particular condition. Conversely, a signal is \u201cdeasserted\u201d if it conveys a value indicative of a lack of a particular condition. A signal may be defined to be asserted when it conveys a logical zero value or, conversely, when it conveys a logical one value. Additionally, various values have been described as being discarded in the above discussion. A value may be discarded in a number of manners, but generally involves modifying the value such that it is ignored by logic circuitry which receives the value. For example, if the value comprises a bit, the logic state of the value may be inverted to discard the value. If the value is an n-bit value, one of the n-bit encodings may indicate that the value is invalid. Setting the value to the invalid encoding causes the value to be discarded. Additionally, an n-bit value may include a valid bit indicative, when set, that the n-bit value is valid. Resetting the valid bit may comprise discarding the value. Other methods of discarding a value may be used as well.</p><p>It is noted that, while a variety of embodiments described above showed comparators coupled to buffers for comparing values within the buffers to input values, these buffers may equivalently be implemented as content addressable memories (CAMs), at least for the portions of the entries being compared, as desired. It is further noted that various embodiments above may be used separately from other embodiments, or may be used in combination with one or more other embodiments, as desired. Furthermore, an embodiment combining the operation of all the above embodiments is contemplated.</p><p>Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Hebbalalu S.", "last_name": "Ramagopal", "name": ""}, {"first_name": "William Kurt", "last_name": "Lewchuk", "name": ""}, {"first_name": "William Alexander", "last_name": "Hughes", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}, {"first_name": "", "last_name": "GLOBALFOUNDRIES U.S. INC.", "name": ""}, {"first_name": "", "last_name": "GLOBALFOUNDRIES INC.", "name": ""}, {"first_name": "", "last_name": "WILMINGTON TRUST, NATIONAL ASSOCIATION", "name": ""}, {"first_name": "", "last_name": "GLOBALFOUNDRIES INC.", "name": ""}, {"first_name": "", "last_name": "ADVANCED MICRO DEVICES", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711118"}, {"primary": false, "label": "712E0905"}, {"primary": false, "label": "711125"}, {"primary": false, "label": "712E09046"}, {"primary": false, "label": "711126"}, {"primary": false, "label": "712E09048"}, {"primary": false, "label": "711123"}, {"primary": false, "label": "712E0906"}], "ecla_classes": [{"label": "G06F   9/38H"}, {"label": "G06F   9/38D4"}, {"label": "G06F   9/38E2"}, {"label": "G06F   9/38D"}], "cpc_classes": [{"label": "G06F   9/3824"}, {"label": "G06F   9/3842"}, {"label": "G06F   9/3834"}, {"label": "G06F   9/3824"}, {"label": "G06F   9/3853"}, {"label": "G06F   9/3855"}, {"label": "G06F   9/3861"}, {"label": "G06F   9/3855"}, {"label": "G06F   9/3828"}, {"label": "G06F   9/3842"}, {"label": "G06F   9/3834"}, {"label": "G06F   9/3828"}, {"label": "G06F   9/3853"}, {"label": "G06F   9/3861"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1999-05-18", "application_date": "1999-05-18", "family_members": [{"ucid": "US-6473832-B1", "titles": [{"lang": "EN", "text": "Load/store unit having pre-cache and post-cache queues for low latency load memory operations"}]}]}