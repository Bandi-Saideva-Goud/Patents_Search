{"patent_number": "US-5768574-A", "publication_id": 71721133, "family_id": 23913038, "publication_date": "1998-06-16", "titles": [{"lang": "EN", "text": "Microprocessor using an instruction field to expand the condition flags and a computer system employing the microprocessor"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA37774383\"><p>A microprocessor is provided which is configured to detect the presence of segment override prefixes in instruction code sequences being executed in flat memory mode, and to use the prefix value or the value stored in the associated segment register to selectively enable condition flag modification for instructions. An instruction which modifies the condition flags and a branch instruction intended to branch based on the condition flags set by the instruction may be separated by numerous instructions which do not modify the condition flags. When the branch instruction is decoded, the condition flags it depends on may already be available. In another embodiment of the present microprocessor, the segment register override bytes are used to select between multiple sets of condition flags. Multiple conditions may be retained by the microprocessor for later examination. Conditions which a program utilizes multiple times in a program may be maintained while other conditions may be generated and utilized.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. A microprocessor comprising:<claim-text>an address translation unit configured to generate a physical address from a logical address and a segment value;</claim-text><claim-text>a plurality of segment registers coupled to said address translation unit wherein the plurality of segment registers store different segment values when a flat memory address translation mode is not in use, and wherein each of said plurality of segment registers stores a same segment value when the flat memory address translation mode is in use;</claim-text><claim-text>a first control unit coupled to said address translation unit wherein said first control unit is configured to detect an instruction field indicative of one of said plurality of segment registers and to convey a signal to said address translation unit indicative of said one of said plurality of segment registers;</claim-text><claim-text>a configuration register for storing a first value when the flat memory address translation mode is in use, and a second value when the flat memory address translation mode is not in use; and</claim-text><claim-text>an execution unit for executing instructions wherein said execution unit is configured to modify the execution of said instructions in response to said signal and said first value.</claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. The microprocessor as recited in claim 1 wherein said execution unit is configured to modify a set of condition flags according to the results of executing an instruction.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. The microprocessor as recited in claim 2 wherein said execution unit is configured to leave said set of condition flags unchanged when executing an instruction including said instruction field.</claim-text></claim>"}, {"num": 4, "parent": 2, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. The microprocessor as recited in claim 2 wherein said execution unit includes multiple sets of condition flags indicative of the results of executing an instruction.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. The microprocessor as recited in claim 4 wherein said execution unit is configured to select one of said multiple sets of condition flags to modify according to the results of executing an instruction including said instruction field, and wherein said execution unit is configured to select said one of said multiple sets of condition flags according to said instruction field.</claim-text></claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. A microprocessor comprising:<claim-text>an address translation unit configured to generate a physical address from a logical address and a segment value;</claim-text><claim-text>a plurality of segment registers coupled to said address translation unit wherein the plurality of segment registers store different segment values when a flat memory address translation mode is not in use, and wherein each of said plurality of segment registers stores a same segment value when the flat memory address translation mode is in use;</claim-text><claim-text>a first control unit coupled to said address translation unit wherein said first control unit is configured to detect an instruction field indicative of one of said plurality of segment registers and to convey a signal to said address translation unit indicative of said one of said plurality of segment registers;</claim-text><claim-text>a configuration register for storing a first value when the flat memory address translation mode is in use, and a second value when the flat memory address translation mode is not in use; and</claim-text><claim-text>an execution unit for executing instructions wherein said execution unit is to modify the execution of said instructions in response to first value and said same value.</claim-text></claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. The microprocessor as recited in claim 6 wherein said execution unit is configured to modify a set of condition flags according to the results of executing an instruction.</claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. The microprocessor as recited in claim 7 wherein said execution unit is configured to leave said set of condition flags unchanged when executing an instruction including said instruction field according to said segment value.</claim-text></claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. The microprocessor as recited in claim 7 wherein said execution unit includes multiple sets of condition flags indicative of the results of executing an instruction.</claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. The microprocessor as recited in claim 9 wherein said execution unit is configured to select one of said multiple sets of condition flags to modify according to the results of executing an instruction including said instruction field, and wherein said execution unit is configured to select said one of said multiple sets of condition flags according to said segment value.</claim-text></claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. A computer system comprising:<claim-text>a main memory; and</claim-text><claim-text>a microprocessor coupled to said main memory wherein said microprocessor comprises:<claim-text>an address translation unit configured to generate a physical address from a logical address and a segment value;</claim-text></claim-text><claim-text>a plurality of segment registers coupled to said address translation unit wherein the plurality of segment registers store different segment values when a flat memory address translation mode is not in use, and wherein each of said plurality of segment registers stores a same segment value when the flat memory address translation mode is in use;</claim-text><claim-text>a first control unit coupled to said address translation unit wherein said first control unit is configured to detect an instruction field indicative of one of said plurality of segment registers and to convey a signal to said address translation unit indicative of said one of said plurality of segment registers;</claim-text><claim-text>a configuration register for storing a first value when the flat memory address translation mode is in use, and a second value when the flat memory address translation mode is not in use; and</claim-text><claim-text>an execution unit for executing instructions wherein said execution unit is configured to modify the execution of said instructions in response to said first value and said signal.</claim-text></claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim num=\"12\"><claim-text>12. The computer system as recited in claim 11 further comprising an external cache memory unit coupled between said main memory and said microprocessor.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"13\"><claim-text>13. A computer system comprising:<claim-text>a main memory; and</claim-text><claim-text>a microprocessor coupled to said main memory wherein said microprocessor comprises:<claim-text>an address translation unit configured to generate a physical address from a logical address and a segment value;</claim-text><claim-text>a plurality of segment registers coupled to said address translation unit wherein the plurality of segment registers store different segment values when a flat memory address translation mode is not in use, and wherein each of said plurality of segment registers stores a same segment value when the flat memory address translation mode is in use;</claim-text><claim-text>a first control unit coupled to said address translation unit wherein said first control unit is configured to detect an instruction field indicative of one of said plurality of segment registers and to convey a signal to said address translation unit indicative of said one of said plurality of segment registers;</claim-text><claim-text>a configuration register for storing a first value when the flat memory address translation mode is in use, and a second value when the flat memory address translation mode is not in use; and</claim-text><claim-text>an execution unit for executing instructions wherein said execution unit is configured to modify the execution of said instructions in response to said first value and said segment value.</claim-text></claim-text></claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"14\"><claim-text>14. The computer system as recited in claim 13 further comprising an external cache memory unit coupled between said main memory and said microprocessor.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES67128613\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This application is a continuation of application Ser. No. 08/481,704, filed Jun. 7, 1995 now abandoned.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention relates to the field of microprocessors and, more particularly, to mechanisms for expanding microprocessor functionality within an existing microprocessor architecture.</p><p>2. Description of the Relevant Art</p><p>Microprocessor manufacturers continue to develop new products which execute x86 instructions in order to maintain compatibility with the vast amount of software developed for previous 80\u00d786 generations--the 8086/8, 80286, 80386, and 80486. Maintaining software compatibility has forced many architectural compromises in newer products. In order to retain the functions of earlier products, hardware has often been simply modified or extended in order to increase capability and performance. One area that is often extended to increase capability and performance is the memory addressing model.</p><p>Early x86 microprocessors implemented a memory addressing model using segmentation. In segmentation, a memory address is specified by an instruction using two parts: a segment and an offset within the segment. The segment selector is stored in a segment register and indicates where the segment is located in main memory (if the processor is running in unprotected mode) or points to a segment descriptor stored in a segment descriptor table in main memory. The segment descriptor contains information about the segment, including its base address. The base address is added to the offset to form the physical address. Each x86 instruction that has the ability to access memory has a default segment register from which it draws its segment data. The x86 architecture defines six segment registers: CS, DS, SS, ES, FS, and GS. CS is the default segment register used for code (instruction) storage. DS is the default segment register used for instructions that do not manipulate stack values. For stack accesses, SS is the default segment register. ES is the default segment register used for string manipulation instructions. The default segment may be overridden in favor of another segment register for a particular instruction by adding a segment override prefix byte to the instruction. The segment override prefix byte is a field of the instruction. As used herein, the term \"instruction field\" refers to one or more bytes within the bytes which form an instruction.</p><p>Beginning with the 80386, special paging circuitry was added to the segmented address generation hardware to allow the implementation of paged memory systems. Programmers are developing operating systems which use paged memory systems. Paged memory systems offer the ability to load smaller portions of programs into main memory at any given time and provide additional built-in protection checking for programs running simultaneously. Additional information regarding the paging structure and segmentation in the x86 architecture may be found within the publication \"Programming the 80386\" by Crawford, et al., SYBEX, Inc., San Francisco, 1987. This publication is incorporated herein by reference in its entirety.</p><p>Memory segmentation is typically not used when implementing such paged memory systems. Memory segmentation cannot be \"turned off,\" but may be effectively disabled through the use of a \"flat\" memory model. A flat memory model is created by making all segment registers point to the same memory segment (i.e., making all memory segments overlap). This overlapping is accomplished by storing the same segment information in all segment registers. Programmers using the paging mechanism typically implement the flat memory model.</p><p>The flat memory model has a major impact on the utility of the segment registers. Holding redundant segment address information makes the two general purpose segment registers added with the 80286 microprocessor, FS and GS, virtually useless. (The other segment registers are implicitly referenced by 80\u00d786 instructions, but are only marginally useful since they contain redundant information). In addition, operating systems may detect attempts to use these registers for other useful purposes and may generate an exception. Since these registers are used for address generation, loading a segment register with an improper value might enable a program to corrupt the memory space being used by another program, or the operating system itself. A constructive use for explicit references to segment registers under the flat memory model is desired.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by a microprocessor according to the present invention. The microprocessor is configured to detect the presence of segment override prefixes in instruction code sequences being executed in flat memory mode, and to use the prefix value or the value stored in the associated segment register to selectively enable or disable condition flag modification for instructions. Advantageously, an instruction which modifies the condition flags and a branch instruction intended to branch based on the condition flags set by the instruction may be separated by numerous instructions which do not modify the condition flags. When the branch instruction is decoded, the condition flags it depends on may already be available. Therefore, the branch instruction may be executed more quickly than if it were placed directly subsequent to the instruction upon which it depends.</p><p>In another embodiment of the present microprocessor, the segment register override bytes are used to select between multiple sets of condition flags. Advantageously, multiple conditions may be retained by the microprocessor for later examination. As with the embodiment above, branch instructions may be separated from the instructions upon which they depend for setting of the condition flags. Additionally, conditions which a program utilizes multiple times may be maintained while other conditions may be generated and utilized. Advantageously, the number of instructions may be reduced for programs having the need to store multiple conditions, since the multiple conditions may be stored and referenced in the multiple sets of condition flags instead of being stored and loaded when needed. Therefore, such programs may be executed in a shorter interval of time.</p><p>Broadly speaking, the present invention contemplates a microprocessor comprising an execution unit, an address translation unit, a plurality of segment registers, a first control unit, and a configuration register. The address translation unit is configured to generate a physical address from a logical address and a segment value. Coupled to the address translation unit, the segment registers store the segment value. The first control unit is coupled to the address translation unit and is configured to detect an instruction field indicative of one of the plurality of segment registers and to convey a signal to the address translation unit indicative of the detected one of the plurality of segment registers. The configuration register stores a value indicative of an address translation mode of the microprocessor. The execution unit executes instructions and is configured to receive the signal and to modify the execution of the instructions according to the signal. The present invention further contemplates a computer system comprising the above mentioned microprocessor and a main memory.</p><p>The present invention still further contemplates a microprocessor comprising an execution unit, an address translation unit, a plurality of segment registers, a first control unit, and a configuration register. The address translation unit is configured to generate a physical address from a logical address and a segment value. Coupled to the address translation unit, the segment registers store the segment value. The first control unit is coupled to the address translation unit and is configured to detect an instruction field indicative of one of the plurality of segment registers and to convey a signal to the address translation unit indicative of the detected one of the plurality of segment registers. The configuration register stores a value indicative of an address translation mode of the microprocessor. The execution unit executes instructions and is configured to receive the signal and to modify the execution of the instructions according to the signal. The present invention further contemplates a computer system comprising the above mentioned microprocessor and a main memory.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of a computer system which includes an 80\u00d786 microprocessor.</p><p>FIG. 2 is a block diagram illustrating the address translation unit of FIG. 1 including structures which generate physical memory addresses in 80\u00d786 microprocessors operating in real mode.</p><p>FIG. 3 is a block diagram illustrating the address translation unit of FIG. 1 including structures which generate physical memory addresses in 80\u00d786 microprocessors operating in protected mode.</p><p>FIG. 4 is a block diagram of a portion of a microprocessor including a cache controller which is selectively enabled through segment register selection information.</p><p>FIG. 5. is a block diagram of a portion of a microprocessor including a data prefetch unit which is selectively enabled through segment register selection information.</p><p>FIG. 6 is a block diagram of a portion of a microprocessor including a branch prediction unit which receives control information through segment register selection information.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>Turning now to FIG. 1, a block diagram of a computer system 100 including a microprocessor 101 is shown. In one embodiment, microprocessor 101 implements the 80\u00d786 microprocessor architecture. Microprocessor 101 is coupled to an external cache unit 102 and a main memory 104. In some embodiments, external cache unit 102 is not included. External cache unit 102 is used to speed the transfer of recently accessed data and instructions which are not stored in the internal cache of microprocessor 101. Microprocessor 101 includes a bus interface unit 106 which orchestrates the transfer of information from the internal units of microprocessor 101 to external cache unit 102 and/or main memory 104. Internal cache unit 108 stores instruction and data information for use by fetch unit 110 and execution unit 112. In one embodiment, internal cache unit 108 includes a unified instruction and data cache. In another embodiment, separate instruction and data caches are configured into internal cache unit 108.</p><p>Before discussing the unique features of the present invention, the units of microprocessor 101 will be described. Fetch unit 110 fetches instructions from internal cache unit 108 and passes the instructions to instruction decode unit 114. Instruction decode unit 114 decodes the received instructions for dispatch to execution unit 112. Operands which reside in registers are fetched by instruction decode unit 114 and provided with the instruction when the instruction is dispatched to execution unit 112. Execution unit 112 is configured to execute instructions once the operands are available. As will be appreciated by those skilled in the art, x86 instructions sometimes have operands which are stored in memory at an address specified in a register, by an offset, or by some combination of registers and offsets. In order to retrieve operands stored in memory, execution unit 112 passes segment register identification information and a calculated offset to address translation unit 116. Segment register identification information is generated from either segment override prefix bytes or from the default segment register for the associated instruction. Based on the translation mode of microprocessor 101, address translation unit 116 translates the address via the segmentation method and optionally via the paging method described above.</p><p>In one embodiment, the translated address is passed by address translation unit 116 to the internal cache unit. In other embodiments, a cache access is started by execution unit 112 and completed using the translated address from address translation unit 116. In still another embodiment, internal cache unit 108 is addressed with an untranslated address. In this embodiment, address translation unit 116 is accessed when a cache miss occurs, or when cache lines are removed from internal cache unit 108 and returned to main memory 104.</p><p>Generally speaking, address translation unit 116 is configured to receive segment register identification information and an offset and to translate this information into a physical address. If flat addressing mode is in effect, the segment register identification information is unimportant since the segment registers each contain the same value. Therefore, features may be added to microprocessor 101 by interpreting the segment identification information passed to address translation unit 116. Features added in this way may be transparent, such that code written to take advantage of the features will run correctly on processors which implement the x86 architecture but do not implement the added features and such that code which was written without awareness of the features will run correctly on processors which implement the added features. Features added in this way may also be non-transparent, such that code written to take advantage of the features may not run correctly on processors which do not implement the features and such that code written without awareness of the features may not run on processors which implement the features. Additionally, features may be added in a non-transparent fashion by using the value stored within the selected segment register (i.e. the segment register specified by the segment register override prefix) to control a feature. When the value stored is used, the feature is non-transparent because address translation unit 114 is configured to ignore (when performing translations) the portion of the segment register used to control the feature. Since this functionality is not a part of the 80\u00d786 architecture, the adding of features controlled by the values stored in a segment register is non-transparent. Many different features are contemplated, as will be revealed below after a discussion of address translation unit 116 in more detail.</p><p>FIG. 2 shows address translation unit 116 of FIG. 1 in more detail for the case of real mode physical address generation. In this mode, address translation unit 116 generates 20-bit physical addresses. Address translation unit 116 is presented with segment register identification information and a 16-bit offset value. Multiplexor 204 uses the segment register selection information to provide the contents of one of the segment registers to the shift register 206. (8086/8 microprocessors have only four of the six segment registers shown: CS, DS, ES, and SS). Shift register 206 then shifts this value four binary bit positions to the left, forming the 20-bit base address of a memory segment. Adder 208 adds the 16-bit offset to the 20-bit segment base address, resulting in a 20-bit physical address for a location in memory.</p><p>FIG. 3 shows address translation unit 116 of FIG. 1 in more detail for the case of protected mode physical address generation. Protected mode is not available on 8086/8 microprocessors. As in real mode, address translation unit 116 is presented with segment register identification information and an offset value. In protected mode, however, the segment register contains an index into one of two tables of memory segment information residing in main memory. The tables contain information about the translation of the address, including the base address of the segment and the size of the segment.</p><p>Beginning with the 80286 microprocessor, two general purpose segment registers were added (FS and GS), bringing the total number of segment registers to six. Information about six memory segments may be loaded into the six segment registers. Typically shadow registers associated with each segment register store the data from the associated segment descriptor, including the base addresses of the segment. In the 80286, segment base addresses are 24 bits long. In the 80386 and 80486, segment base addresses are 32 bits long. Multiplexor 304 uses the segment register identification information to provide the contents of one of the base addresses of the corresponding memory segment. Adder 306 adds the offset to the segment base address, resulting in a physical address for a location in memory (assuming paging circuitry 308 is disabled). In the 80286, offsets are 16 bits long, and physical addresses are 24 bits long. In the 80386 and 80486, offsets may be 16 or 32 bits long, and physical addresses are 32 bits long. If paging circuitry 308 is enabled, the address formed by adder 306 is translated yet again according to a paging algorithm. The paging algorithm uses high order bits of the address formed by adder 306 to index into a page directory containing addresses of page tables. The address of the page table is added to a second range of bits from adder 306 to find a particular page directory entry. The information stored therein is used to translate the address formed by adder 306 to a physical address.</p><p>In flat addressing mode, the paging algorithm is used for the translation and the address generated by adder 306 is the same as the logical address, as noted above. Therefore, the segment registers are of very little use. Of particularly little use are segment registers FS and GS, which are not default segment registers for x86 instructions. Therefore, the segment register override bytes referring to the FS and GS registers may be used to enable expanded features of microprocessor 101. Furthermore, segment register override bytes which specify the default segment register for an instruction may be used in another embodiment. It is noted that this other embodiment may also be used when flat memory addressing is not in effect.</p><p>FIG. 4 is a block diagram of a portion of microprocessor 101 including a cache control unit 404. Cache control unit 404 is configured within internal cache unit 108 and is coupled to execution unit 112 and to a control register 402. Cache control unit 404 is selectively enabled using segment register identification information, provided by the execution unit 112, and using the contents of an enabling bit 400 in control register 402. When enabling bit 400 is set, the cache controller 404 selectively stores data associated with the instruction which produced the segment register identification information in internal cache unit 108. This cacheability selection is in addition to the architectural cacheability selection of the x86 architecture as embodied in the PCD bit of the page table entry. In one embodiment, the data is stored unless the FS segment register is specified by a segment register override prefix byte for the associated instruction. Other embodiments may use other segment register overrides for this function.</p><p>In another embodiment, the value stored within the selected segment register is conveyed to cache control unit 404. The cacheability of a particular address is thereby determined by the value conveyed.</p><p>If enabling bit 400 is cleared, the segment register identification information is not used to determine cacheability of a particular address. In another embodiment, the cacheability trait for an address is conveyed to external cache 102 (shown in FIG. 1).</p><p>In yet another embodiment, cache controller 404 is configured to selectively store a line in write-through or writeback mode. When enabling bit 400 is set, the cache controller 404 selectively stores data associated with the instruction which produced the segment register identification information in internal cache unit 108 in a write-through or writeback mode. This mode selection is in addition to the architectural write-through selection of the x86 architecture as embodied in the PWT bit of the page table entry. In one embodiment, the data is stored in writeback mode unless the FS segment register is specified by a segment register override prefix byte for the associated instruction. Other embodiments may use other segment register override prefix bytes for this function. In yet another embodiment, the value stored within the selected segment register is conveyed to cache control unit 404. The write-through or writeback mode of a particular address is thereby determined by the value conveyed. If enabling bit 400 is cleared, the segment register identification information is not used to determine the write-through or writeback mode of a particular address. In another embodiment, the write-through or writeback trait for an address is conveyed to external cache 102 (shown in FIG. 1).</p><p>Cache control unit 404 has another embodiment which implements a cache flush or cache clean operation dependent on a particular value of segment register identification information associated with an instruction. A cache flush operation causes a cache line containing the address of the cache flush operation to be removed from the cache. If the line is modified with respect to main memory, the modified value is written back to main memory. A cache clean operation is similar to the flush operation in that a modified cache line is written back to main memory. However, the cache clean operation does not remove the line from the cache. These operations affect a single cache line, as opposed to the INVD and WBINVD instructions of the x86 architecture which affect the entire cache at once. The GS segment override prefix byte is used to cause a flush operation in this embodiment, and the ES segment override prefix byte is used to cause a clean operation. Other embodiments may use other segment register override prefix bytes for these functions, or may use the value stored in the selected segment register to specify these functions. If the value stored in the selected segment register is used, then the value is conveyed to cache control unit 404 along with the segment identification value.</p><p>In still another embodiment, cache control unit 404 implements a speculative miss line fill function based on the use of the FS segment register override prefix byte. In this embodiment, if the FS segment override prefix byte is specified for a particular instruction and the address associated with that instruction misses internal cache unit 108, then the cache line containing the address is fetched from main memory even if the instruction was executed by execution unit 112 speculatively. Sometimes, a particular instruction may appear to be speculative to microprocessor 101 even though the address is correct and will be needed by the program in the near future. If a programmer or compiler is aware of this situation, it could specify that a cache miss for the instruction be speculatively fetched into internal cache 108. When used in the context of instruction execution, the term \"speculative\" means that an instruction is executed before that instruction is know to be required by the sequential execution of instructions in a program.</p><p>Another embodiment of cache controller 404 is configured to allocate a cache line for a store instruction which misses internal cache 108 if the ES segment register override prefix byte is included in the store instruction. If enabling bit 400 is not set, then store instructions which miss internal cache 108 are written to main memory without fetching the associated cache line into internal cache 108. If enabling bit 400 is set, then store instructions that miss internal cache 108 will cause a cache line fill of the associated data bytes to occur if the store instruction includes the ES segment register override prefix byte. If the ES segment register override prefix byte is not included, then the cache line fill will not occur and the store data will be written to main memory. In still a further embodiment, a store instruction which misses the cache will cause a cache line to be allocated but the associated data bytes will not be fetched from memory. The data bytes provided by the store instruction will be stored into the cache line. However, the other data bytes of the cache line are marked invalid in internal cache 108 until additional store instructions cause the other data bytes to become valid. In an alternative embodiment, the other data bytes are set to zero. An additional embodiment of cache control unit 404 is configured to used the value stored in the selected segment register to specify the above mentioned speculative miss line fill functions.</p><p>In one embodiment, control register 402 is control register 0 present in 80386 and later microprocessors. The enabling bit 400 is bit 31 of control register 0, the paging bit. When bit 31 is set, paging is enabled.</p><p>FIG. 5 is a block diagram of a portion of microprocessor 101 including a data prefetch unit 500. Data prefetch unit 500 is coupled to execution unit 112 and to control register 402. Data prefetch unit 500 is selectively enabled using segment register identification information, provided by the execution unit 112, and using the contents of enabling bit 400 in control register 402. When enabling bit 400 is set, data prefetch unit 500 prefetches data associated with cache lines stored in consecutive groups of bytes of main memory 104 (shown in FIG. 1) starting at the address indicated by the instruction. The cache lines are stored by internal cache unit 108. If enabling bit 400 is not set, then the data prefetch unit remains idle. In one embodiment, data prefetch unit 500 begins prefetching if the FS segment register override is used for an instruction. The number of consecutive cache lines fetched by data prefetch unit 500 may vary from embodiment to embodiment. In another embodiment, data prefetching begins under the control of the value stored in the selected segment register. Additionally, the number of consecutive cache lines to fetch may be specified by the value stored in the selected segment register.</p><p>In yet another embodiment, data prefetch unit 500 implements other prefetching schemes. It is noted that many prefetching schemes are suitable for data prefetch unit 500, including a stride based prefetching scheme and other \"smart\" prefetching schemes. Various \"smart\" prefetching schemes are well-known.</p><p>FIG. 6 is a block diagram of a portion of microprocessor 101 including a branch prediction unit 600 which is including in fetch unit 110. Branch prediction unit 600 is coupled to execution unit 112 and to a control register 402. Branch prediction unit 600 implements the branch prediction scheme embodied within fetch unit 110, as well as an alternative scheme. The alternative scheme is enabled through segment register identification information, provided by execution unit 112, and the contents of enabling bit 400 in control register 402. If enabling bit 400 is not set, then the branch prediction scheme of branch prediction unit 600 is used. If enabling bit 400 is set, then the branch prediction scheme of branch prediction unit 600 is used except in the case that a noop instruction immediately prior to the branch instruction includes the FS or GS segment register override prefix bytes. In this case, the alternative branch prediction scheme is used.</p><p>In one embodiment, the alternative branch prediction scheme is to predict the branch taken if a prior noop includes the FS segment register override prefix byte, or to predict the branch not taken if the GS segment register override prefix byte is included. In the context of this application, the term \"noop\" does not refer to the NOP instruction of the x86 architecture. Instead, a \"noop\" is an instruction which does not change a register or memory, but does reference a memory location so that a segment register override prefix byte may be included with the instruction. An exemplary noop instruction would be an instruction which adds zero to the contents of a memory location. Additionally, the value stored in the selected segment register may be used to enable or disable the alternative branch prediction scheme.</p><p>The abovementioned uses for the segment register identification information are transparent uses, except for the embodiments which use the value stored in the selected segment register (instead of the existence of a particular segment override prefix byte) to control a feature. Non-transparent uses are also contemplated, as described below.</p><p>Two exemplary non-transparent uses may be implemented within execution unit 112. First, a segment register override byte may be used to create instructions which do not modify the condition flags. For example, the ADD instruction modifies the condition flags. An ADD instruction which uses a memory operand could be modified to an ADD instruction which does not modify the condition flags by using the segment register override prefix byte. In one embodiment, the FS segment register override prefix byte indicates that the ADD instruction will not modify the condition flags. This functionality allows for the scheduling of branches which are dependent on a condition flag generated by a particular operation. Numerous instructions may be executed between the branch instruction and the instruction it depends upon if the instructions do not modify the condition flags.</p><p>Another embodiment which aids the scheduling of branch instructions is to implement multiple sets of condition flags. In this manner, multiple sets of conditions may be maintained simultaneously. Segment register override prefix bytes may be used with instructions which modify the condition flags to indicate which of multiple sets of condition flags to modify. Noop instructions immediately prior to a branch instruction then use segment register override prefix bytes to indicate which of multiple sets of condition flags the branch instruction should use to determine the branch direction. If no segment register override prefix bytes are included with respect to an instruction, then a default set of condition flags are associated with the instruction. Another embodiment uses the value stored within the selected segment register to select the set of condition flags to be used by a particular instruction.</p><p>Another non-transparent use of segment register override prefix bytes may be embodied within instruction decode unit 114. As mentioned above, instruction decode unit 114 reads the register(s) specified as operands of an instruction and passes the values to execution unit 112 along with the instruction. In this embodiment, segment register override prefix bytes are used to select one of multiple register banks which store data. Each register bank includes the full complement of x86 registers. In this manner, the register set of the architecture may be expanded without changing the instruction encodings. As will be appreciated by those skilled in the art, a larger register set allows more operand values to be held in registers (which may be accessed quickly) and so accesses to memory (which typically require a longer period of time) are lessened. In one embodiment, no segment register override prefix byte specifies the first bank of registers, a segment register override prefix byte indicating the FS segment register specifies a second bank of registers, a segment register override prefix byte indicating the GS segment register specifies a third bank of registers, and a segment register override prefix byte indicating the ES segment register specifies a fourth bank of registers. In another embodiment, the value stored within the selected segment register is used to select the appropriate register bank from numerous register banks.</p><p>It is noted that many other non-transparent uses may be created for segment register override prefix bytes. The present invention contemplates transparent and non-transparent functions implemented through the use of segment register override prefix bytes. It is additionally noted that while the above embodiments are 80\u00d786 microprocessors, any microprocessor implemented in any microprocessor architecture may benefit from a similar expansion of the architecture.</p><p>Aspects regarding other portions of a microprocessor may be found in the co-pending, commonly assigned patent application entitled \"High Performance Superscalar Microprocessor\", Ser. No. 08/146,382, filed Oct. 29, 1993 by Witt, et al. now abandoned. Additionally, information may be found in the co-pending, commonly assigned patent application entitled \"High Performance Superscalar Instruction Alignment Unit\", Ser. No. 08/377,865, filed Jan. 25, 1995 by Tran, et al. The disclosures of both of the aforementioned applications are hereby incorporated by reference in their entirety.</p><p>Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Drew J.", "last_name": "Dutton", "name": ""}, {"first_name": "David S.", "last_name": "Christie", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}], "ipc_classes": [{"primary": true, "label": "G06F   9/32"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/32        20060101A I20051008RMEP"}, {"label": "G06F   9/318       20060101A I20051008RMEP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712226"}, {"primary": false, "label": "712E09051"}, {"primary": false, "label": "712E09079"}, {"primary": false, "label": "712E09035"}, {"primary": false, "label": "711206"}, {"primary": false, "label": "711209"}], "ecla_classes": [{"label": "G06F   9/30B"}, {"label": "G06F   9/30X2"}, {"label": "G06F   9/34"}, {"label": "G06F   9/38E2D"}], "cpc_classes": [{"label": "G06F   9/30094"}, {"label": "G06F   9/30185"}, {"label": "G06F   9/34"}, {"label": "G06F   9/3844"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1995-06-07", "application_date": "1997-08-19", "family_members": [{"ucid": "US-5768574-A", "titles": [{"lang": "EN", "text": "Microprocessor using an instruction field to expand the condition flags and a computer system employing the microprocessor"}]}]}