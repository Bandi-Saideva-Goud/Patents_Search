{"patent_number": "US-6658532-B1", "publication_id": 73627499, "family_id": 29550268, "publication_date": "2003-12-02", "titles": [{"lang": "EN", "text": "Cache flushing"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50585751\"><p>Portions of a cache are flushed in stages. An exemplary flushing of the present invention comprises flushing a first portion, performing operations other than a flush, and then flushing a second portion of the cache. The first portion may be disabled after it is flushed. The cache may be functionally divided into portions prior to a flush, or the portions may be determined in part by an abort signal. The operations may access either the cache or the memory. The operations may involve direct memory access or interrupt servicing.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00001\" num=\"1\"><claim-text>1. A method of flushing a cache comprising:</claim-text><claim-text>flushing a first portion of the cache; </claim-text><claim-text>disabling the first portion of the cache after the first portion has been flushed; </claim-text><claim-text>performing an operation other than a cache flush; and </claim-text><claim-text>flushing a second portion of the cache. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00002\" num=\"2\"><claim-text>2. The method of <claim-ref idref=\"US-6658532-B1-CLM-00001\">claim 1</claim-ref> wherein the performing an operation other than a cache flush comprises responding to an interrupt.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00003\" num=\"3\"><claim-text>3. The method of <claim-ref idref=\"US-6658532-B1-CLM-00001\">claim 1</claim-ref> further comprising:</claim-text><claim-text>executing at least one first command on a processor to initiate the flushing of the first portion; </claim-text><claim-text>executing at least one second command on a processor to initiate the performing an operation other than a cache flush. </claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00004\" num=\"4\"><claim-text>4. The method of <claim-ref idref=\"US-6658532-B1-CLM-00003\">claim 3</claim-ref> wherein the executing at least one first command, the executing at least one second command, the flushing the first portion of the cache, and the flushing the second portion of the cache are performed on a single chip.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00005\" num=\"5\"><claim-text>5. The method of <claim-ref idref=\"US-6658532-B1-CLM-00001\">claim 1</claim-ref> wherein the performing an operation other than a cache flush comprises:</claim-text><claim-text>receiving data from a peripheral; and </claim-text><claim-text>storing the data in a memory coupled to the cache. </claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00006\" num=\"6\"><claim-text>6. The method of <claim-ref idref=\"US-6658532-B1-CLM-00001\">claim 1</claim-ref> further comprising interleaving cache flush operations of different portions of a cache with other processor operations.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00007\" num=\"7\"><claim-text>7. The method of <claim-ref idref=\"US-6658532-B1-CLM-00001\">claim 1</claim-ref> further comprising:</claim-text><claim-text>receiving a signal from a peripheral that the peripheral requires access to the memory; </claim-text><claim-text>granting the peripheral access to the memory; and </claim-text><claim-text>flushing a second portion of the cache after the peripheral has accessed the memory. </claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00008\" num=\"8\"><claim-text>8. The method of <claim-ref idref=\"US-6658532-B1-CLM-00001\">claim 1</claim-ref> wherein the second portion is no greater than an entire cache.</claim-text></claim>"}, {"num": 9, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00009\" num=\"9\"><claim-text>9. The method of <claim-ref idref=\"US-6658532-B1-CLM-00001\">claim 1</claim-ref> wherein the cache is larger than the first and second portions combined.</claim-text></claim>"}, {"num": 10, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00010\" num=\"10\"><claim-text>10. The method of <claim-ref idref=\"US-6658532-B1-CLM-00001\">claim 1</claim-ref> wherein the flushing a first portion is in response to a cache flush command.</claim-text></claim>"}, {"num": 11, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00011\" num=\"11\"><claim-text>11. The method of <claim-ref idref=\"US-6658532-B1-CLM-00008\">claim 8</claim-ref> wherein the flushing a second portion is in response to a second instance of the cache flush command.</claim-text></claim>"}, {"num": 12, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00012\" num=\"12\"><claim-text>12. The method of <claim-ref idref=\"US-6658532-B1-CLM-00001\">claim 1</claim-ref> further comprising:</claim-text><claim-text>accessing the second portion of the cache after the disabling of the first portion. </claim-text></claim>"}, {"num": 13, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00013\" num=\"13\"><claim-text>13. The method of <claim-ref idref=\"US-6658532-B1-CLM-00001\">claim 1</claim-ref> wherein the cache comprises an L2 cache.</claim-text></claim>"}, {"num": 14, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00014\" num=\"14\"><claim-text>14. A method of flushing a cache comprising:</claim-text><claim-text>executing at least one first command on a processor to initiate the flushing of the first portion; </claim-text><claim-text>flushing a first portion of the cache; </claim-text><claim-text>aborting the flushing a first portion of the cache; </claim-text><claim-text>storing an indicator of the boundary of the first portion of the cache; </claim-text><claim-text>executing at least one second command on a processor to initiate the executing an operation other than a cache flush; </claim-text><claim-text>performing an operation other than a cache flush; </claim-text><claim-text>reading the indicator; and </claim-text><claim-text>flushing a second portion of the cache by beginning a cache flush at the boundary indicated by the indicator. </claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00015\" num=\"15\"><claim-text>15. The method of <claim-ref idref=\"US-6658532-B1-CLM-00014\">claim 14</claim-ref> further comprising aborting the flushing the second portion.</claim-text></claim>"}, {"num": 16, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00016\" num=\"16\"><claim-text>16. The method of <claim-ref idref=\"US-6658532-B1-CLM-00012\">claim 12</claim-ref> further comprising storing an indicator of the boundary of the second portion of the cache.</claim-text></claim>"}, {"num": 17, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00017\" num=\"17\"><claim-text>17. The method of <claim-ref idref=\"US-6658532-B1-CLM-00013\">claim 13</claim-ref> further comprising determining where to begin the flushing of a third portion based at least in part on the indicator of the boundary of the second portion.</claim-text></claim>"}, {"num": 18, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00018\" num=\"18\"><claim-text>18. A processor system comprising:</claim-text><claim-text>a processor; </claim-text><claim-text>a memory; </claim-text><claim-text>a cache controller; </claim-text><claim-text>a cache coupled to the processor and the memory, wherein a first portion of the cache is flushed in response to a cache flush command from the processor; </claim-text><claim-text>wherein the flushed portion of the cache is disabled in response to a disable command from the processor, the nonflushed portion of the cache remaining enabled in response to the disable command. </claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00019\" num=\"19\"><claim-text>19. The system of <claim-ref idref=\"US-6658532-B1-CLM-00018\">claim 18</claim-ref> further comprising:</claim-text><claim-text>a bus coupling a peripheral device to the memory; </claim-text><claim-text>a memory controller granting the peripheral device access to the memory; </claim-text><claim-text>and wherein a second portion of the cache is flushed and wherein interrupts are serviced during the time between the flushing of the first and second portions. </claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00020\" num=\"20\"><claim-text>20. The system of <claim-ref idref=\"US-6658532-B1-CLM-00019\">claim 19</claim-ref> wherein data buffers are configured during the time between the flushing of the first and second portions.</claim-text></claim>"}, {"num": 21, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00021\" num=\"21\"><claim-text>21. The system of <claim-ref idref=\"US-6658532-B1-CLM-00018\">claim 18</claim-ref> further comprising:</claim-text><claim-text>a peripheral transmitting a stream of data to the memory. </claim-text></claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00022\" num=\"22\"><claim-text>22. The system of <claim-ref idref=\"US-6658532-B1-CLM-00021\">claim 21</claim-ref> wherein the peripheral requests access to the memory at intervals of less than 200 microseconds.</claim-text></claim>"}, {"num": 23, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00023\" num=\"23\"><claim-text>23. The system of <claim-ref idref=\"US-6658532-B1-CLM-00018\">claim 18</claim-ref> wherein the enabled portion of the cache is accessed after the disable command.</claim-text></claim>"}, {"num": 24, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00024\" num=\"24\"><claim-text>24. The system of <claim-ref idref=\"US-6658532-B1-CLM-00018\">claim 18</claim-ref> further comprising a peripheral, wherein the peripheral accesses the memory after the flushed portion of the cache is disabled.</claim-text></claim>"}, {"num": 25, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00025\" num=\"25\"><claim-text>25. The system of <claim-ref idref=\"US-6658532-B1-CLM-00017\">claim 17</claim-ref> wherein the nonflushed portion of the cache is flushed after the peripheral accesses the memory.</claim-text></claim>"}, {"num": 26, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00026\" num=\"26\"><claim-text>26. The system of <claim-ref idref=\"US-6658532-B1-CLM-00018\">claim 18</claim-ref> wherein a cache flush command executed after the flushed portion of the cache is disabled does not affect the flushed portion of the cache that is disabled.</claim-text></claim>"}, {"num": 27, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00027\" num=\"27\"><claim-text>27. The system of <claim-ref idref=\"US-6658532-B1-CLM-00018\">claim 18</claim-ref> wherein a cache flush command executed after the flushed portion of the cache is disabled causes the flushing of at least a part of the nonflushed portion of the cache.</claim-text></claim>"}, {"num": 28, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00028\" num=\"28\"><claim-text>28. A computer system comprising:</claim-text><claim-text>a processor operable in at least a first state and a second state; </claim-text><claim-text>a memory: </claim-text><claim-text>a cache controller; </claim-text><claim-text>a cache coupled to the processor and the memory, the cache having at least two portions, each portion being adapted to independently flush; and </claim-text><claim-text>a computer program stored on a computer readable medium, the computer program comprising instructions for causing the processor to initiate a staged cache flush prior to a transition from a first state to a second state. </claim-text></claim>"}, {"num": 29, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00029\" num=\"29\"><claim-text>29. The computer system of <claim-ref idref=\"US-6658532-B1-CLM-00028\">claim 28</claim-ref> wherein the portions of the cache comprise different sizes.</claim-text></claim>"}, {"num": 30, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00030\" num=\"30\"><claim-text>30. The system of <claim-ref idref=\"US-6658532-B1-CLM-00028\">claim 28</claim-ref> wherein the size of at least one portion of the cache is predetermined.</claim-text></claim>"}, {"num": 31, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00031\" num=\"31\"><claim-text>31. The system of <claim-ref idref=\"US-6658532-B1-CLM-00028\">claim 28</claim-ref> wherein the size of at least one portion of the cache is not determined until after the flush is initiated.</claim-text></claim>"}, {"num": 32, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00032\" num=\"32\"><claim-text>32. A computer system comprising:</claim-text><claim-text>a processor operable in at least a first state and a second state; </claim-text><claim-text>a memory; </claim-text><claim-text>a cache controller; </claim-text><claim-text>a cache coupled to the processor and the memory, the cache having at least two portions, each portion being adapted to independently flush, wherein the portions of the cache comprise different sizes; </claim-text><claim-text>wherein the cache controller is configured to flush portions of the cache in stages, and wherein the cache controller is configured to flush the smallest portion of the cache last. </claim-text></claim>"}, {"num": 33, "parent": 32, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00033\" num=\"33\"><claim-text>33. The computer system of <claim-ref idref=\"US-6658532-B1-CLM-00032\">claim 32</claim-ref> further comprising:</claim-text><claim-text>a peripheral that signals the processor that it requires access to the memory; and </claim-text><claim-text>wherein the peripheral is granted access to the memory in between the flushing of different portions of the cache. </claim-text></claim>"}, {"num": 34, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00034\" num=\"34\"><claim-text>34. A computer system comprising:</claim-text><claim-text>a processor operable in at least a first state and a second state; </claim-text><claim-text>a memory; </claim-text><claim-text>a cache controller; </claim-text><claim-text>a cache coupled to the processor and the memory, the cache having at least two portions including a first portion and a second portion, each portion being adapted to independently flush; </claim-text><claim-text>wherein the size of the first portion is determined in part by the time between the start of the cache flush and a received abort signal. </claim-text></claim>"}, {"num": 35, "parent": 34, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00035\" num=\"35\"><claim-text>35. The computer system of <claim-ref idref=\"US-6658532-B1-CLM-00034\">claim 34</claim-ref> further comprising:</claim-text><claim-text>a peripheral that signals the processor that it requires access to memory; and </claim-text><claim-text>wherein the peripheral is granted access to the memory in between the flushing of different portions of the cache. </claim-text></claim>"}, {"num": 36, "parent": 34, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00036\" num=\"36\"><claim-text>36. The computer system of <claim-ref idref=\"US-6658532-B1-CLM-00034\">claim 34</claim-ref> wherein the abort signal is received after the initiation of a transition of the processor from the first state to a second state and before the transition is completed.</claim-text></claim>"}, {"num": 37, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00037\" num=\"37\"><claim-text>37. A method of flushing a cache comprising:</claim-text><claim-text>flushing at least a portion of a cache in response to a cache flush command; </claim-text><claim-text>receiving a flush abort signal; </claim-text><claim-text>aborting the flushing in response to the flush abort signal; </claim-text><claim-text>storing an indicator indicative of the Portion of the cache flushed prior to the aborting. </claim-text></claim>"}, {"num": 38, "parent": 37, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00038\" num=\"38\"><claim-text>38. The method of <claim-ref idref=\"US-6658532-B1-CLM-00037\">claim 37</claim-ref> further comprising:</claim-text><claim-text>flushing a second portion of the cache, the second portion being determined at least in part by the indicator. </claim-text></claim>"}, {"num": 39, "parent": 38, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00039\" num=\"39\"><claim-text>39. The method of <claim-ref idref=\"US-6658532-B1-CLM-00038\">claim 38</claim-ref> wherein the flushing a second portion includes, and is larger than, the at least a portion already flushed.</claim-text></claim>"}, {"num": 40, "parent": 38, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00040\" num=\"40\"><claim-text>40. The method of <claim-ref idref=\"US-6658532-B1-CLM-00038\">claim 38</claim-ref> wherein the flushing a second portion begins at the point where the prior flushing was aborted.</claim-text></claim>"}, {"num": 41, "parent": 37, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00041\" num=\"41\"><claim-text>41. The method of <claim-ref idref=\"US-6658532-B1-CLM-00037\">claim 37</claim-ref> further comprising preventing writes to the flushed portion of the cache after aborting the flushing.</claim-text></claim>"}, {"num": 42, "parent": 38, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00042\" num=\"42\"><claim-text>42. The method of <claim-ref idref=\"US-6658532-B1-CLM-00038\">claim 38</claim-ref> wherein the second portion is determined in part by criteria other than the indicator.</claim-text></claim>"}, {"num": 43, "parent": 38, "type": "dependent", "paragraph_markup": "<claim id=\"US-6658532-B1-CLM-00043\" num=\"43\"><claim-text>43. The method of <claim-ref idref=\"US-6658532-B1-CLM-00038\">claim 38</claim-ref> wherein the cache is larger than the at least a portion and second portion combined.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54025469\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND</h4><p>This invention relates to cache flushing.</p><p>A cache is flushed in order to make sure that the contents of the cache and a main memory are the same. Typically, a cache flush is initiated by a processor issuing a flush command. A cache controller will then write back data from the cache into the main memory.</p><h4>SUMMARY OF THE INVENTION</h4><p>Portions of a cache are flushed in stages. An exemplary flushing of the present invention comprises flushing a first portion, performing operations other than a flush, and then flushing a second portion of the cache. The first portion may be disabled after it is flushed. The cache may be functionally divided into portions prior to a flush, or the portions may be determined in part by an abort signal. The operations may access either the cache or the memory. The operations may involve direct memory access or interrupt servicing.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 is a block diagram of a processor system incorporating the invention.</p><p>FIG. 2 is a flow chart illustrating a flush of the cache of FIG. <b>1</b>.</p><p>FIG. 3 is a flow chart illustrating a flush of the cache of FIG. 1 combined with a processor transition.</p><p>FIG. 4 is a flow chart illustrating another embodiment of the cache flush.</p><p>FIG. 5 illustrates various L1 and L2 flush combinations.</p><p>FIG. 6 is a flowchart for an abort/retry flush with processor transition.</p><p>FIG. 7 is a flowchart of microcode for an abortable cache.</p><p>FIG. 8 is a flowchart of microcode for a flush loop.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION</h4><p>In FIG. 1, processor system <b>10</b> may be the core of a personal computer. Processor <b>20</b> uses caches <b>30</b> and <b>40</b> in conjunction with memory <b>50</b> to speed up data access. Cache <b>30</b>, the L1 cache, is typically smaller and faster than cache <b>40</b>, the L2 cache. Both caches provide faster access than memory <b>50</b>. Cache <b>30</b> is, for example, 32 Kbytes and operates at the processor speed. Cache <b>40</b> is, for example, 512 Kbytes and typically operates at about 50% of the processor speed. For example, a processor <b>20</b> operating at 450 MHZ may have a cache operating at 225 MHZ. On such a system, memory <b>50</b> may be operating on bus <b>100</b> with a bus speed of only 100 MHZ. Processor <b>20</b> can access memory <b>50</b> directly over bus <b>100</b>. Memory controller <b>70</b> arbitrates access to memory <b>50</b>. One function of memory controller <b>70</b> is to grant peripherals <b>90</b> direct memory access (DMA) to memory <b>50</b> via bus <b>100</b>. Peripherals <b>90</b> may also be granted access to memory <b>50</b> by signaling interrupt handler <b>80</b>. Interrupt handler <b>80</b> would then cause processor <b>20</b> to service the requested interrupt.</p><p>As one example of a peripheral, a digital video camera may be connected to bus <b>100</b> via a Universal Serial Bus (USB) interface (not shown). A camera or other peripheral may require periodic access to bus <b>100</b> in order to store information, such as video data, in memory <b>50</b>. Certain peripherals may require access to memory <b>50</b> about every 200 microseconds or even more often. A long cache flush is broken up into stages so that the peripheral will be able to transfer data smoothly to or from the memory. For example, the processor may be interrupted in order to create or rearrange data buffers during a memory-peripheral transfer. The cache flush is broken up into stages to allow for timely servicing of the interrupt.</p><p>Cache <b>30</b> and <b>40</b> are controlled by cache controller <b>60</b>. One function of cache controller <b>60</b> is to perform cache write backs. Upon receipt of a flush command from processor <b>20</b>, cache controller <b>60</b> will write back data from the flushed cache to memory <b>50</b>. The entire cache may then be written back. Alternatively, a subset of the cache may be written back that includes those areas of the cache where the memory and cache are not identical. Cache controller <b>60</b> and the cache <b>30</b> are on the same chip as processor <b>20</b>. Cache <b>40</b> may also be on the chip with processor <b>20</b>.</p><p>Cache <b>40</b> is shown, for example, as having three functional portions <b>42</b>, <b>44</b>, and <b>46</b>. Portion <b>46</b> is smaller than portions <b>42</b> and <b>44</b>. Each portion may be flushed and disabled independently of the status of the other two portions. Cache <b>40</b> may therefore be flushed in stages. For example, first portion <b>42</b> may be flushed and then disabled. Then portion <b>44</b> may be flushed and then disabled. Finally potion <b>46</b> may be flushed. In between successive flushes, the processor system performs memory intensive operations. For example, peripherals <b>90</b> may be allowed to store data in memory <b>50</b>, or processor <b>20</b> may service interrupts responsive to messages from interrupt handler <b>80</b>.</p><p>As shown in FIG. 2, in a staged L2 cache flush, the cache is functionally identified (<b>210</b>) as having two or more portions. A portion is selected and flushed (<b>220</b>). The flushed portion is then disabled (<b>230</b>). The remaining portions of the cache remain enabled. During the cache flush (<b>220</b>), processor <b>20</b> could not service interrupts. Once the flushed portion has been disabled, the processor can service interrupts. These interrupt service routines may access the cache or memory locations that are mirrored in the cache (<b>240</b>).</p><p>After the interrupts are serviced, an unflushed portion of the cache is flushed (<b>250</b>). If the cache is divided into more than two portions, this portion of the cache is disabled and interrupts may be serviced again. Once the entire cache has been flushed, the entire cache is reenabled. Flushing the L2 cache in stages allows for faster response time to interrupts, DMA requests, or other memory requests requiring servicing.</p><p>The size (the amount of data storage capacity) of the portions of the cache can vary, and may be configurable. The ratio of the sizes of the various portions may be a power of two. For example, first portion may be four or eight times the size of the second portion, or, in another example, a three portion cache may have portion ratios of 8:4:1.</p><p>FIG. 3 illustrates a staged L2 cache flush in conjunction with a processor transition. For example, processor <b>50</b> may be operating (<b>310</b>) in the Cl processor state within the G<b>0</b> operating state as defined in the Advanced Configuration and Power Interface Specification (\u201cACPI\u201d), Revision 1.0b, released Feb. 2, 1999. Portions of the ACPI are reprinted in the Appendix. One or more computer programs, for example, operating system software, application software, microcode, or otherwise, are stored on a computer readable medium and are executed on processor <b>50</b>. Processor <b>50</b> requests, in response to either user input, system status information, or otherwise, to enter the C<b>3</b> state, also within the G<b>0</b> operating state. Processor <b>50</b> selects(<b>320</b>) a different G<b>0</b> state. In this example, the C<b>3</b> state. Processor <b>50</b> then signals cache controller <b>60</b> to flush (<b>330</b>) a first portion of the L2 cache. Once the flush is complete, the first portion is disabled (<b>340</b>), and the interrupts are serviced (<b>350</b>). The second and last portion of the cache is then flushed (<b>360</b>). The last portion to be flushed is usually smaller in size than the first portion. Accordingly, the flush of this last portion is faster than the flush of the first portion. The second portion is disabled (<b>370</b>). Processor <b>50</b> then transitions (<b>380</b>) from the Cl state to the C<b>3</b> state. Interrupts cannot be serviced during a cache flush or during the transition. In some cases, peripherals may not access memory during those times. Likewise, access must be denied between the final flush and the transition. By making the final flush brief, the flush can be immediately followed by a transition without significantly impacting the total duration between memory or cache accesses. Following the transition, interrupts and caching are enabled (<b>390</b>).</p><p>In another embodiment shown in FIG. 4, the behavior of a cache flush instruction is modified. The cache flush instruction WBINVD (Write Back and Invalidate) ordinarily flushes the entire cache. After interrupts and caching are disabled (<b>405</b>), the behavior of the system in response to a WBINVD instruction is modified (<b>410</b>) to flush half of the L2 cache. The WBINVD is executed (<b>415</b>) to flush the L1 cache and one half of the L2 cache. The behavior of the system is then reconfigured (<b>420</b>) so that execution of the WBINVD instruction will flush the entire L2 cache. Once the flushed half of the L2 cache is disabled (<b>425</b>), interrupts and caching are enabled (<b>430</b>). Interrupts are then serviced (<b>435</b>). Interrupts and caching are again disabled (<b>440</b>) and the L1 cache and remainder of the L2 cache are flushed (<b>445</b>). Caching and interrupts are enabled (<b>455</b>) and interrupts are serviced again (<b>460</b>).</p><p>The final flush and transition now takes place. Caches and interrupts are disabled (<b>465</b>), the L1 cache is flushed (<b>470</b>) with the WBINVD instruction, the processor transitions (<b>475</b>) from one G<b>0</b> state to another. Once the transition is complete, the entire L2 cache is enabled (<b>480</b>). Interrupts and caching are also enabled (<b>485</b>).</p><p>The order of cache flushing is variable FIG. 5 illustrates some possibilities: First the L2 cache is flushed (<b>510</b>) and then disabled (<b>520</b>). Interrupts are serviced (<b>530</b>) or other operations performed before the next flush. Then the L<b>1</b> cache is flushed (<b>540</b>). Also, a series of caches within a cache hierarchy may be flushed in stages. In such a circumstance, a portion of the cache hierarchy is flushed by flushing one or more caches within a cache hierarchy. Two examples of a staged flush of a cache hierarchy are shown in FIG. <b>5</b>.</p><p>The L2 cache can be flushed in stages, followed by a flush of the L1 cache. Again interrupts can be serviced or other operations performed in between the three flushes. In either case, the L1 cache flush can be followed by a transition from one processor state to another.</p><p>Another embodiment of the invention has an abortable L2 cache so that a high latency L2 cache flush may be aborted and then resumed. The individual flushable portions of the cache are not predetermined. Rather, the size of the portions vary depending on the time between flush abort signals. Upon receipt of an abort signal, the flush may be aborted immediately, be aborted after a specified or predetermined time period, or be aborted after the flushing of a portion of the cache of a predetermined size. An indicator is stored indicating how much of the cache was flushed prior to the abort. The indicator is, for example, stored in a register named Flush MSR (Flush Model Specific Register). The indicator stores the last flushed segment, half-segment, word, or some other value. Software can use this register to communicate with the WBINVD microcode flow to tell it whether to use standard semantics or abort/retry semantics. Software retries the WBINVD until the L2 cache is completely flushed, providing windows between each iteration for the processor to service interrupts. With reference to FIG. 1, the flush MSR stores the boundary between portion <b>42</b> and <b>44</b> after portion <b>42</b> is flushed. After the first retry, the Flush MSR stores the boundary between portions <b>44</b> and <b>46</b>.</p><p>The processor is allowed to handle interrupts in between the flush abort and flush retry. When the flush is retried, the L1 cache is flushed, where needed, then the L2 cache abortable cache starts flushing where the prior flush left off. In a particular embodiment, the L2 cache is only aborted after 250 usec following the start of the flush. The cache flush abort/retry control may be implemented in either microcode or hardware state machines.</p><p>The cache flush abort/retry scheme is a generic architectural feature and could be used by a device driver or operating system where there is a need for reduced cache flush latency. The availability of this feature can be indicated by a feature flag in, for example, the processor. For microcode implementations, a microcode visible control register is used to accomplish a retriable flush. The microcode also uses the following hardware features: a) a saturating down-counter to know when the initial no-abort time has passed; b)a bit that the microcode can poll to determine if an interrupt is pending; c) a bit that blocks the interrupt pending bit; and d) a bit that the microcode can set that controls whether the L2 cache allocates new lines or not.</p><p>In an embodiment, the counter uses the bus clock as its time reference. The periods for the bus clock frequencies are 15 nsec, 10 nsec, 7.5 nsec, and 5 nsec for 66 MHZ, 100 MHZ, 133 MHZ, and 200 MHZ respectively. The counter counts 2.5 nsec time intervals and decrements by 6, 4, 3, or 2 ticks per 66 MHZ, 100 MHZ, 133 MHZ, and 200 MHZ bus clock respectively. The interrupt pending bit is set if there is an external interrupt, the counter has reached zero, and the blocking bit is not set.</p><p>In FIG. 6, an abortable L2 cache, flushed prior to a processor state transition, is controlled by microcode. Interrupts and caching are disabled (<b>610</b>). The Flush MSR is initialized (e.g. set to 0x80000000) (<b>615</b>). The WBINVD instruction is executed (<b>620</b>). If the L2 cache is completely flushed (Flush MSR equals zero), then a processor transition is performed (<b>630</b>). Interrupts and caching are enabled (<b>635</b>).</p><p>If the Flush MSR was not equal to zero, then the Flush MSR value is saved and Flush MSR is cleared (<b>645</b>). Interrupts and caching are enabled (<b>650</b>) and interrupts are serviced (<b>655</b>).</p><p>Interrupts and caching are then disabled (<b>660</b>), the Flush MSR is restored (<b>665</b>) and the flush is retried by executing WBINVD again (<b>620</b>).</p><p>Execution of a WBINVD instruction with an abortable cache flush triggers execution of the microcode flow shown in FIG. <b>7</b>. First the processor is prepared (<b>706</b>) for a flush operation. The L2 cache is then set to \u201cNo Allocate\u201d mode (<b>712</b>). In \u201cNo Allocate\u201d mode, the processor will be able to access and use the unflushed portions of the cache, but new data from memory will not be written into the cache, even if the processor must fetch data from memory.</p><p>The \u201cno-abort\u201d timer is initialized to the \u201cno-abort\u201d time period (<b>714</b>). Until this timer expires, abort requests will be postponed. The L1 cache instruction caches are invalidated (<b>716</b>). A single segment of code is used for both the L1 cache and abortable L2 cache. The code must be set up for the proper cache. The progress count is initialized to zero so that the L1 cache flush starts from the beginning of the cache, and flush aborts are blocked (<b>718</b>). The L1 cache data cache is then flushed (<b>720</b>). If the L2 cache is not being flushed (<b>722</b>), the processor is prepared for regular instruction execution (<b>724</b>). The Flush MSR is set to zero and the L2 cache is set to allocate mode (<b>728</b>). In this configuration, the next flush will be a regular flush. A message is generated indicating that the flush has been completed (<b>730</b>).</p><p>If the L2 cache is being flushed, the size of the L2 cache is determined and flush aborts are unblocked (<b>734</b>). The following sequence flushes an eight way L2 cache in two halves of four ways each. First, if ways <b>0</b> to <b>3</b> are enabled and not flushed (<b>736</b>) then ways <b>0</b> to <b>3</b> are flushed (<b>740</b>). The Flush MSR is set (<b>742</b>) to indicate that first half of the cache is flushed. If ways <b>4</b> to <b>7</b> are enabled (<b>744</b>) then the progress count is initialized from the Flush MSR register. If the flush had previously been aborted during the flush of the second half of the cache, then the flow would have come from block <b>736</b> directly to block <b>744</b> and to block <b>746</b>. In this case, the Flush MSR would hold the location where the last flush was aborted. Ways <b>4</b> to <b>7</b> are flushed (<b>748</b>). Alternatively, all ways of an N-way cache can be flushed in one functional block, e.g. block <b>740</b>. The flow then branches to block <b>724</b>.</p><p>The flush loop shown in FIG. 8 is executed by the Flush blocks (e.g., blocks <b>720</b>, <b>740</b>, and <b>748</b>) from FIG. <b>7</b>. The loop starts at block <b>802</b>. The progress count is subtracted from the set count(<b>804</b>). This value is placed in the set counter. The progress count is indicative of how much of the cache has been flushed. It is derived from the Flush MSR. The set count is the total number of sets in the cache. The set pointer is then set to point to the next set to be flushed (<b>806</b>). The ways of the current half set is flushed (<b>808</b>-<b>814</b>). If all sets are flushed then control returns to the flush flow in FIG. <b>7</b>.</p><p>If sets remain to be flushed (<b>816</b>) then the set counter is decremented (<b>820</b>). The set pointer is incremented to the next set (<b>822</b>). The progress count is also incremented (<b>824</b>). This keeps track of the progress of the flush in case of an abort. If there is no pending interrupt then the flush continues at block <b>808</b>. If there is a pending interrupt, the processor is prepared for normal execution (<b>828</b>). The progress count is saved in the Flush MSR (<b>832</b>) and the flow exits from the WBINVD instruction (<b>834</b>). Interrupts may now be serviced.</p><p>Other embodiment are within the scope of the following claims.</p><h4>APPENDIX</h4><h4>2.2 Global System State Definitions</h4><p>G<b>0</b>-Working:</p><p>A computer state where the system dispatches user mode (application) threads and they execute. In this state, devices (peripherals) are dynamically having their power state changed. The user will be able to select (through some user interface) various performance/power characteristics of the system to have the software optimize for performance or battery life. The system responds to external events in real time. It is not safe to disassemble the machine in this state.</p><p>4.7.2.6 Processor Power State Control</p><p>ACPI supports placing system processors into one of four power states in the G<b>0</b> working state. In the C<b>0</b> state the designated processor is executing code; in the C<b>1</b>-C<b>3</b> states it is not. While in the C<b>0</b> state, ACPI allows the performance of the processor to be altered through a defined \u201cthrottling\u201d process (the C<b>0</b> Throttling state in the diagram below). Throttling hardware lets the processor execute at a designated performance level relative to its maximum performance. The hardware to enter throttling is also described in this section.</p><p>In a working system (global G<b>0</b> working state) the OS will dynamically transition idle CPUs into the appropriate power state. ACPI defines logic on a per-CPU basis that the OS uses to transition between the different processor power states. This logic is optional, and is described through the FACP table and processor objects (contained in the hierarchical name space). The fields and flags within the FACP table describe the symmetrical features of the hardware, and the processor object contains the location for the particular CPU's clock logic (described by the P_BLK register block). The ACPI specification defines four CPU power states for the G<b>0</b> working state:C<b>0</b>, C<b>1</b>, C<b>2</b> and C<b>3</b>.</p><p>In the C<b>0</b> power state, the processor executes.</p><p>In the C<b>1</b> power state, the processor is in a low power state where it is able to maintain the context of the system caches. This state is supported through a native instruction of the processor (HLT for IA-PC processors), and assumes no hardware support is needed from the chipset.</p><p>In the C<b>2</b> power state, the processor is in a low power state where it is able to maintain the context of system caches. This state is supported through chipset hardware described in this section. The C<b>2</b> power state is lower power and has a higher exit latency than the C<b>1</b> power state.</p><p>In the C<b>3</b> power state, the processor is in a low power state where it is not necessarily able to maintain coherency of the processor caches with respect to other system activity (for example, snooping is not enabled at the CPU complex ). This state is supported through chipset hardware described in this section. The C<b>3</b> power state is lower power and has a higher exit latency than the C<b>2</b> power state.</p><p>The P_BLK registers provide optional support for placing the system processors into the C<b>2</b> or C<b>3</b> states. The P_LVL<b>2</b> register is used to sequence the selected processor into the C<b>2</b> state, and the P_LVL<b>3</b> register is used to sequence the selected processor into the C<b>3</b> state. Additional support for the C<b>3</b> state is provided through the bus master status and arbiter disable bits (BM_STS in the PM<b>1</b>_STS register and ARB_DIS in the PM<b>2</b>_CNT register). System software reads the P_LVL<b>2</b> or P_LVL<b>2</b> registers to enter the C<b>2</b> or C<b>3</b> power state. Hardware is required to put the processor into the proper clock state precisely on the read operation to the appropriate P_LVLx register.</p><p>Processor power state support is symmetric, all processors in a system are assumed by system software to support the same clock states. If processors have non-symmetric power state support, then the BIOS will choose and use the lowest common power states supported by all the processors in the system through the FACP table. For example, if the P<b>0</b> processor supports all power states up to and including the C<b>3</b> state, but the P<b>1</b> processor only supports the C<b>1</b> power state, then the ACPI driver will only place idle processors into the C<b>1</b> power state (P<b>0</b> will never be put into the C<b>2</b> or C<b>3</b> power states). Note that the C<b>1</b> power state must be supported; C<b>2</b> and C<b>3</b> are optional. (see the PROC_C<b>1</b> flag in the FACP table description in section 5.2.5).</p><p>4.7.2.6.1 C<b>2</b> Power State</p><p>The C<b>2</b> state puts the processor into a low power state optimized around multiprocessor (MP) and bus master systems. The system software will automatically cause an idle processor complex to enter a C<b>2</b> state if there are bus masters or MP processors active (which will prevent the OS from placing the processor complex into the C<b>3</b> state). The processor complex is able to snoop bus master or MP CPU accesses to memory while in the C<b>2</b> state. Once the processor complex has been placed into the C<b>2</b> power state, any interrupt (IRQ or reset) will bring the processor complex out of the C<b>2</b> power state.</p><p>4.7.2.6.2 C<b>3</b> Power State</p><p>The C<b>3</b> state puts the designated processor and system into a power state where the processor's cache context is maintained, but it is not required to snoop bus master or MP CPU accesses to memory. There are two mechanisms for supporting the C<b>3</b> power state:</p><p>Having the OS flush and invalidate the caches prior to entering the C<b>3</b> state.</p><p>Providing hardware mechanisms to prevent masters from writing to memory (UP only support).</p><p>In the first case the OS will flush the system caches prior to entering the C<b>3</b> state. As there is normally much latency associated with flushing processor caches, the ACPI driver is likely to only support this in MP platforms for idle processors. Flushing of the cache is through one of the defined ACPI mechanisms (described below, flushing caches).</p><p>In UP only platforms that provide the needed hardware functionality (defined in this section), the ACPI driver will attempt to place the platform into a mode that will prevent system bus masters from writing into memory while any processor is in the C<b>3</b> state. This is done by disabling bus masters prior to entering a C<b>3</b> power state. Upon a bus master requesting an access, the CPU will awaken from the C<b>3</b> state and re-enable bus master accesses.</p><p>The ACPI driver uses the BM_STS bit to determine which Cx power state to enter. The BM_STS is an optional bit that indicates when bus masters are active. The ACPI driver uses this bit to determine the policy between the C<b>2</b> and C<b>3</b> power states: lots of bus master activity demotes the CPU power state to the C<b>2</b> (or C<b>1</b> if C<b>2</b> is not supported), no bus master activity promotes the CPU power state to the C<b>3</b> power state. The ACPI driver keeps a running history of the BM_STS bit to determine CPU power state policy.</p><p>The last hardware feature used in the C<b>3</b> power state is the BM_RLD bit. This bit determines if the Cx power state is exited based on bus master requests. If set, then the Cx power state is exited upon a request from a bus master; if reset, the power state is not exited upon bus master requests. In the C<b>3</b> state, bus master requests need to transition the CPU back to the C<b>0</b> state (as the system is capable of maintaining cache coherency), but such a transition is not needed for the C<b>2</b> state. The ACPI driver can optionally set this bit when using a C<b>3</b> power state, and clear it when using a C<b>1</b>-C<b>2</b> power state.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "John W.", "last_name": "Horrigan", "name": ""}, {"first_name": "Namasivayam", "last_name": "Thangavelu", "name": ""}, {"first_name": "George", "last_name": "Vargese", "name": ""}, {"first_name": "Brian", "last_name": "Holscher", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTEL CORPORATION"}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/12"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711135"}, {"primary": false, "label": "711E1204"}, {"primary": false, "label": "711E12043"}], "ecla_classes": [{"label": "G06F  12/08B20"}, {"label": "G06F  12/08B22L"}, {"label": "G06F  12/08B2"}], "cpc_classes": [{"label": "G06F  12/0804"}, {"label": "G06F  12/0891"}, {"label": "G06F  12/0891"}, {"label": "G06F  12/0804"}, {"label": "G06F  12/0897"}, {"label": "G06F  12/0897"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1999-12-15", "application_date": "1999-12-15", "family_members": [{"ucid": "US-20040073751-A1", "titles": [{"lang": "EN", "text": "Cache flushing"}]}, {"ucid": "US-7089366-B2", "titles": [{"lang": "EN", "text": "Cache flushing"}]}, {"ucid": "US-7380063-B2", "titles": [{"lang": "EN", "text": "Cache flushing"}]}, {"ucid": "US-6658532-B1", "titles": [{"lang": "EN", "text": "Cache flushing"}]}, {"ucid": "US-20070005900-A1", "titles": [{"lang": "EN", "text": "Cache flushing"}]}]}