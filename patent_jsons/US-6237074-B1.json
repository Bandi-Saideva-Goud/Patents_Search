{"patent_number": "US-6237074-B1", "publication_id": 72677059, "family_id": 23769407, "publication_date": "2001-05-22", "titles": [{"lang": "EN", "text": "Tagged prefetch and instruction decoder for variable length instruction set and method of operation"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72558879\"><p>A pipelined processor in which the decoder can consume a portion of an instruction and hold that portion in sub-field shadow registers while retrieving the remainder of the instruction in a subsequent cycle or cycles. Each byte in a prefetch buffer is individually tagged such that the decoder can clear individual bytes in the prefetch buffer in order to allow additional instruction bytes to be prefetched before the current instruction is completely consumed and decoded by the decode stage. This allows for an optimal buffer size that is less than the maximum possible instruction length but large enough to hold a complete copy of the vast majority of instructions.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6237074-B1-CLM-00001\" num=\"1\"><claim-text>1. Pipelined processor having consecutive pipeline cycles and including at least a prefetch stage, a decode stage, and an execute stage, said instructions comprising instruction segments and said segments comprising instruction portions, said processor further comprising;</claim-text><claim-text>a line buffer in said prefetch stage for storing instruction portions retrieved from memory, said line buffer having a line width less than a maximum possible instruction width, </claim-text><claim-text>retrieving said means for retrieving instruction portions from said line buffer into said decode stage including a plurality of shadow registers for storing an instruction portion retrieved from said line buffer, </claim-text><claim-text>a decoder in said decode stage coupled to receive said instruction portions from said retrieving means, for decoding an instruction segment when said decoder has received a predetermined instruction segment from said retrieving means and for preventing decoding otherwise, and </claim-text><claim-text>control means for causing said shadow register to store an instruction portion until said retrieving means has retrieved all instruction portions comprising said predetermined instruction segment corresponding to said stored instruction portion and for causing said retrieving means to output said stored instruction portion along with any other retrieved instruction portion comprising said predetermined instruction segment when said retrieving means has retrieved all said instruction portions comprising said predetermined instruction portion, </claim-text><claim-text>wherein said control means comprises a multiplexer for selectively coupling said instruction portions from said retrieving means to said decoder (1) directly from said line buffer or (2) from said shadow registers, and </claim-text><claim-text>wherein said multiplexer complises a 2:1 multiplexer having a first input coupled to said shadow registers and a second input coupled directly to said line buffer and an output coupled to said decoder. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237074-B1-CLM-00002\" num=\"2\"><claim-text>2. The processor as set forth in claim <b>1</b> wherein said processor has a variable length instruction set in which instructions include an op-code portion, and may include either a first operand portion or a first operand portion and a second operand portion, and further wherein each of said shadow register includes a shadow register for storing said op-code portion and said first operand portion of said instruction.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237074-B1-CLM-00003\" num=\"3\"><claim-text>3. The processor as set forth in claim <b>2</b> wherein said processor further comprises means for determining if an instruction includes said second operand portion and wherein said control means is responsive to said instruction having said second operand portion for storing said op-code and first operand portions of said instruction in said shadow register if said instruction includes said second operand portion.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237074-B1-CLM-00004\" num=\"4\"><claim-text>4. The processor as set forth in claim <b>1</b> wherein said line buffer includes at least one storage position for storing an instruction portion and said prefetch stage further comprises a valid tag bit register for storing a valid tag bit corresponding to each storage position in said line buffer, said valid tag bit indicating whether said corresponding storage position holds an instruction portion which is to be decoded and wherein said control means further comprises resetting means for resetting the valid tag bit corresponding to a storage position so as to allow said prefetch stage to store additional instruction portions in said storage positions, when the instruction portion stored in said storage location has been retrieved by said retrieving means.</claim-text></claim>"}, {"num": 5, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6237074-B1-CLM-00005\" num=\"5\"><claim-text>5. In a pipelined processor, a method of retrieving instructions from memory and decoding said instructions, said instructions comprising instruction segments and said segments comprising instruction portions, comprising the steps of:</claim-text><claim-text>(1) continuously retrieving instruction portions from said memory in discrete time periods and storing said retrieved instruction portions in a buffer in a prefetch stage, </claim-text><claim-text>(2) continuously retrieving instruction portions from said buffer into a decode stage, </claim-text><claim-text>(3) continuously storing said instruction portions retrieved from said buffer in a shadow register, if less than a predetermined instruction segment of an instruction portion retrieved from said buffer in a shadow register, if less than a predetermined segment of an instruction corresponding to each of said instruction portions has been retrieved from said buffer and forwarding said stored instruction portions for decoding when all of a predetermined instruction segment corresponding to each of said instruction portions has been retrieved from said buffer, </claim-text><claim-text>(4) decoding said predetermined instruction segment, </claim-text><claim-text>wherein step (3) includes steps of causing said instruction portions stored in said shadow register to be forwarded for decoding along with a remaining portion of said instruction when said decode stage has retrieved all instruction portion of said predetermined segment, and </claim-text><claim-text>wherein said buffer includes at least one storage position for storing an instruction portion, </claim-text><claim-text>(5) storing a valid tag bit corresponding to each storage portion in said buffer, said valid tag bit indicating whether said corresponding storage position holds an instruction portion which is to be decoded and therefore cannot be overwritten; and </claim-text><claim-text>(6) clearing the valid tag bit corresponding to a storage position, so as to allow said storage position to be overwritten with another instruction portion, when the instruction portion stored in said storage location has been retrieved. </claim-text></claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6237074-B1-CLM-00006\" num=\"6\"><claim-text>6. A decode apparatus for a pipelined processor for decoding instructions, said instructions including dynamic control information and fixed control information comprising;</claim-text><claim-text>a decoder comprising: </claim-text><claim-text>a combinational logic circuit for decoding said dynamic control information, and </claim-text><claim-text>a memory for decoding said fixed information, </claim-text><claim-text>wherein an instruction includes an op-code portion and may include one or more prefix portions for setting prefix parameters: </claim-text><claim-text>a line buffer for storing instruction portions to be decoded; </claim-text><claim-text>an extraction circuit for extracting an instruction portion from said line buffer; </claim-text><claim-text>means for determining if said instruction portion includes said one or more prefix portions; and </claim-text><claim-text>said combinational logic including means for decoding said one or more prefix portions of an instruction before any other portion of said instruction, and </claim-text><claim-text>wherein said instruction may include plural prefix portions and wherein said combinational logic includes means for decoding each prefix portion successively. </claim-text></claim>"}, {"num": 7, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237074-B1-CLM-00007\" num=\"7\"><claim-text>7. The apparatus as set forth in claim <b>5</b> further comprising:</claim-text><claim-text>a prefix register for storing prefix parameter default conditions which will be used when said instruction is decoded, and </claim-text><claim-text>means for causing said prefix register to be re-written with said prefix parameter from a prefix portion of said instruction, if said instruction includes said prefix portion. </claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237074-B1-CLM-00008\" num=\"8\"><claim-text>8. An appartaus as set forth in claim <b>7</b> wherein said prefix information may include one or more of an addressing width for the instruction, a data width for the instruction, and whether a data bus is to be locked during the instruction.</claim-text></claim>"}, {"num": 9, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237074-B1-CLM-00009\" num=\"9\"><claim-text>9. The apparatus as set forth in claim <b>6</b> wherein said processor has a variable width instruction set and said line buffer is less wide than a maximum possible instruction width and further wherein said combinational logic circuit decodes said prefix portion of an instruction before any other portion of the instruction is decoded.</claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237074-B1-CLM-00010\" num=\"10\"><claim-text>10. The apparatus as set forth in claim <b>9</b> wherein said instructions may further include a first operand portion or a first and a second operand portion, wherein said extraction circuit comprises;</claim-text><claim-text>means for extracting said op-code portion and said first operand portion, if any, from said line buffer simultaneously after said prefix portion is decoded, and </claim-text><claim-text>means for extracting said second operand portion, if any, from said line buffer after said op-code portion and first operand portion, if any, are extracted. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237074-B1-CLM-00011\" num=\"11\"><claim-text>11. The apparatus as set forth in claim <b>10</b> further comprising;</claim-text><claim-text>a shadow buffer for storing said op-code portion and said first operand portion, and </claim-text><claim-text>control means for causing said shadow buffer to store said op-code portion and said first operand portion, when an instruction comprises a second operand, until said means for extracting has extracted said second operand. </claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237074-B1-CLM-00012\" num=\"12\"><claim-text>12. The apparatus as set forth in claim <b>11</b> wherein said means for extracting further comprises means for sending said op-code portion, first operand portion and second operand portion to said decoder simultaneously.</claim-text></claim>"}, {"num": 13, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237074-B1-CLM-00013\" num=\"13\"><claim-text>13. The apparatus as set forth in claim <b>6</b> wherein said instruction includes an op-code instruction portion and include a constant data instruction portion, and said dynamic information may include one or more of the width of the op-code portion, the width of the constant portion, the identity of a register from which data is to be retrieved by the instruction, the identity of a register to which data is to be written by the instruction, a pointer to a base address for addressing by instruction and a pointer to an index for addressing by the instruction.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54548234\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>FIELD OF THE INVENTION</h4><p>The invention pertains to the prefetch and decode stages of a pipelined microprocessor. More particularly, the invention pertains to a method and apparatus for prefetching and decoding variable length instructions using a tagged prefetch buffer smaller than the maximum allowable instruction width.</p><h4>BACKGROUND OF THE INVENTION</h4><p>Modem microprocessors employ pipelining techniques which allow multiple, consecutive instructions to be prefetched, decoded, and executed in separate stages simultaneously. Accordingly, in any given clock cycle, a first instruction may be executed while the next (second) instruction is simultaneously being decoded, and the instruction after that one (a third instruction) is simultaneously being fetched. Since less processing is performed on each instruction per cycle, cycle time can be made shorter. Thus, while it requires several clock cycles for a single instruction to be pre-fetched, decoded, and executed, it is possible to have a processor completing instructions as fast as one instruction per cycle with a very short cycle period, because multiple consecutive instructions are in various stages simultaneously.</p><p>Typically, buffers for temporarily holding data are used to define the boundary between consecutive stages of a microprocessor pipeline. The data calculated in a particular stage is written into these buffers before the end of the cycle. When the pipeline advances upon the start of a new cycle, the data is written out of the boundary buffers into the next stage where the data can be further processed during that next cycle.</p><p>Most pipelined microprocessor architectures have at least four stages including, in order of flow, 1) a prefetch stage, 2) a decode stage, 3) an execute stage, and 4) a write-back stage. In the prefetch stage, instructions are read out of memory (e.g., an instruction cache) and stored in a buffer. Depending on the particular microprocessor, in any given cycle, the prefetch buffer may receive one to several instructions.</p><p>In the decode stage, the processor reads an instruction out of the prefetch buffer and converts it into an internal instruction format which can be used by the microprocessor to perform one or more operations, such as arithmetic or logical operations. In the execute stage, the actual operations are performed. Finally, in the write-back stage, the results of the operations are written to the designated registers and/or other memory locations.</p><p>In more complex microprocessors, one or more of the four basic stages can be further broken down into smaller stages to simplify each individual stage and even further improve instruction completion speed.</p><p>Generally, instructions are read out of memory in a sequential address order. However, instruction branches, in which the retrieval of instructions from sequential address spaces is disrupted, are common, occurring on average about every six to nine instructions.</p><p>The hardware in an instruction prefetch stage typically comprises a prefetch buffer or prefetch queue which can temporarily hold instructions. Each cycle, the decode stage can take in the bytes of an instruction held in the prefetch stage for decoding during that cycle.</p><p>The hardware in a decode stage typically comprises at least a program counter and hardware for converting instructions into control lines for controlling the hardware in the execute stage. Alternately, the decode stage can include a microcode-ROM. The incoming instruction defines an entry point (i.e., an address) into the microcode-ROM at which the stored data defines the appropriate conditions for the execute stage control lines. The execute stage control data for the particular instruction may exist entirely at a single addressable storage location on the microcode-ROM or may occupy several sequentially addressable storage locations. The number of addressable storage locations in the microcode-ROM which must be accessed for a given instruction may be encoded in the instruction itself. Alternately, one or more data bits in the storage locations in the microcode-ROM may indicate whether or not another storage location should be accessed.</p><p>The control data output from the microcode-ROM is written into buffer registers for forwarding to the execute stage on the next cycle transition. The decode stage also includes hardware for extracting the operands, if any, from the instruction or from registers or memory locations and presenting the operands to the appropriate hardware in the execution stage.</p><p>Some microprocessor architectures employ what are known as variable width instruction sets. In such architectures, the instructions are not all the same width. For instance, in the instruction set for the 16/32 bit class x86 family of microprocessors developed by Intel Corporation of Santa Clara, Calif., an instruction can be anywhere from 1 to 16 bytes wide.</p><p>Some microprocessor architectures utilize a segmented address space in which the total memory space is broken down into a plurality of independent, protected address spaces. Each segment is defined by a base address and a segment limit. The base address, for instance, may be the lowest numerical address in the segment space. The segment limit defines the size of the segment. Accordingly, the end boundary of the segment is defined by the sum of the base address and the segment limit. Alternately, the base address may be the highest address and, as such, the end boundary of the segment would be the difference between the base address and the segment limit.</p><p>Software programs are written, compiled and assembled such that, when a program is running, instructions are normally retrieved from sequential addresses in memory for presentation into the pipeline. Accordingly, once a program is begun, the prefetch stage will normally continue to retrieve consecutive instructions for presentation to the decode stage from consecutive addresses in memory until that flow is interrupted. The most common way by which the sequential addressing of instructions can be interrupted is by a branch instruction. A branch instruction usually specifies, in some manner, the address from which the next instruction to be executed after the branch instruction is to be retrieved. Thus, when a branch instruction is executed in the execute stage, the execute stage halts the normal flow of instructions through the preceding stage of the pipe, e.g., the prefetch and decode stages, and instead supplies the next address for retrieving instructions to the prefetch stage. Accordingly, when a branch occurs, the instructions which had been retrieved from sequential addresses after the branch instruction which are in the pipe, i.e., the instructions in the prefetch and decode stages, should not be executed, but should be flushed from the pipe. The flow can be altered by mechanisms other than an executed branch instruction, such as an interrupt. Any change in program flow from sequential addressing is collectively referred to as a branch in this specification, even if it is not the result of a branch instruction.</p><p>To generate a linear address according to the x86 architecture, at the very least two quantities are added. Particularly, the base address of the particular segment, as indicated by the segment descriptor and an offset indicating the distance of the desired data (i.e., instruction) from the base of the segment must be added together. The offset itself may comprise up to three more parts, a base, index and displacement. If so, those quantities must be added to generate the offset before the offset could be added to the segment base. A more detailed discussion of segmented addressing in the x86 architecture can be found in <i>INTEL</i>486 <i>Microprocessor Family Programmer's Reference Manual</i>, 1992, Intel Corporation.</p><p>It is an object of the present invention to provide an improved pipelined microprocessor.</p><p>It is a further object of the present invention to provide a pipelined microprocessor architecture in which the prefetch line buffer has a line width less than the maximum possible instruction width in order to conserve semiconductor area, yet which is wide enough to accommodate the vast majority of instructions in a single line.</p><p>It is a further object of the present invention to provide a pipelined microprocessor architecture having a decode stage in which shadow buffers are used to temporarily store portions of instructions which are wider than the prefetch line buffer and therefore require multiple cycles to be loaded into the decode stage.</p><p>It is a further object of the present invention to provide a pipelined microprocessor architecture having a tagged prefetch buffer in which instruction bytes are individually tagged so that the prefetch buffer bytes can be cleared individually to allow data to be loaded more efficiently into the prefetch buffer.</p><p>It is a further object of the present invention to provide a pipelined microprocessor architecture having a decode stage in which dynamic information is decoded by hardware, while fixed information is decoded by use of an addressable ROM.</p><h4>SUMMARY OF THE INVENTION</h4><p>The invention relates to a method and apparatus for fetching and decoding variable length instructions in a pipelined processor. A prefetch line buffer defines the boundary between the prefetch stage and the decode stage. The decode stage pulls instruction bytes out of the line buffer for decoding. In order to conserve silicon space, the line buffer is less wide than the maximum possible instruction width. However, preferably, the line buffer is wide enough to accommodate the full instruction width of most instructions.</p><p>The decode stage includes a plurality of shadow buffers into which instruction bytes can be temporarily loaded and held in those situations where the instruction width is too wide to be loaded into the line buffer in a single cycle. Thus, part of the instruction can be loaded into the decode stage and the byte positions in the line buffer from which they were loaded can be cleared so that more instruction bytes can be prefetched. The remainder of the bytes of the instruction can be loaded into the line buffer and then into the decode stage on subsequent cycles, at which point the entire instruction, including the bytes newly loaded into the decode stage and the bytes stored in the shadow registers can be simultaneously decoded.</p><p>In a pipelined microprocessor embodying a preferred embodiment of the invention, an instruction may comprise up to three sub-fields, and each sub-field may comprise one or more bytes. Specifically, an instruction may include a prefix sub-field comprising one or more prefix bytes which indicate dynamic information such as the length of the address or data for that instruction, or whether the bus is to be locked during that instruction. The number of prefix bytes is variable, and, in the preferred embodiment can be anywhere from zero to fourteen bytes. The prefix sub-field, if any, is followed by the op-code sub-field, which may comprise one to three bytes. All instructions comprise at least one op-code byte. Finally, the op-code sub-field is followed by the constant data sub-field. The constant data sub-field can comprise one or two operands depending on the particular instruction. Depending on the number of constants and the size of each constant, the constant sub-field can be up to eight bytes in length. Many instructions do not include any constants.</p><p>The decode stage includes an instruction pointer into the line buffer which generates a demand instruction pointer (DIP), a temporary instruction pointer (TIP) and a next instruction pointer (NIP). The DIP holds the linear address of the first byte of the instruction currently in the decode stage. The x least significant bits (LSBs) of the DIP, where 2<sup>x </sup>is the width of the line buffer, identify the particular byte position in the line buffer of this byte. The TIP holds the address of the first instruction byte which has not yet been consumed by the decode stage. The x LSBs of the TIP point to the byte position in the line buffer of the first instruction byte which has not yet been consumed by the decode stage. The TIP will be the same as the DIP at the beginning of an instruction. The NIP holds the address of the first byte of the next instruction which will be loaded into the decode stage. The LSBs of the NIP point to the byte position in the line buffer of the first byte of the next instruction which will be loaded into the decode stage. A fourth pointer, TIPSHIFT, points to the address to which the TIP will be updated when the decode stage consumes bytes during a cycle. A fifth pointer, TIPOPLEN, points to the address of the first byte of the constant sub-field, if any.</p><p>Each byte in the line buffer is individually tagged with a valid bit indicating whether the data in that byte position in the line buffer is valid data to be loaded into the decode stage for decoding. Once a byte in the line buffer is actually loaded into the decode stage, its tag byte is reset so that the prefetch stage can prefetch and load another instruction byte in that byte position. Every time the TIP is updated, the valid bits of the bytes traversed by the TIP are reset.</p><p>The decode stage further includes a prefix flag register, prefix flag setting logic, op-code data extraction logic and constant data extraction logic. Each cycle, the inputs to the op-code data extraction unit are the three bytes following the TIP position in the line buffer. The op-code extraction logic includes circuitry for determining if the first of the three bytes is a prefix byte or an op-code byte. If the first byte is a prefix byte and it is tagged valid, TIPSHIFT is set to one and the prefix byte is forwarded to the prefix flag setting logic. The prefix flag setting logic sets an appropriate flag in the prefix flag register responsive to the prefix byte. The TIP is then updated (e.g. incremented by TIPSHIFT) and the process continues. Only one prefix byte per cycle is operated on by the decode stage.</p><p>When the first byte pointed to by the TIP is an op-code byte, the bytes are processed differently.</p><p>In particular, the data extraction unit includes logic for very quickly pre-decoding the op-code sub-field to determine the length of the op-code and constant data, if any, for that instruction. The op-code length is added to the TIP in order to generate the TIPOPLEN pointer. The op-code length and the length of the first operand in the constant data field are added to the TIP in order to generate the TIPSHIFT pointer. The constant data extraction unit loads the four bytes of data following the last byte of the op-code. Until it is determined that it has received valid bytes for the entire op-code sub-field and the first constant data, if any, the TIP pointer is not updated. If all of the bytes in the op-code sub-field and all of the bytes of the first operand in the constant data sub-field, if any, are tagged valid, the op-code extraction logic forwards the op-code sub-field bytes to an op-code assembly circuit and the constant data extraction unit forwards the constant sub-field bytes to an appropriate data port depending on the type of the constant data (e.g. immediate or displacement).</p><p>If the instruction had less than two operands, the op-code assembly circuitry iunmediately forwards the op-code bytes to address generation logic and control decode logic for decoding and the data port sends the operand data to decode stage buffers for loading into the execute stage in the next pipeline cycle. When the constant data sub-field includes two operands, the op-code and first constant are stored in shadow registers in the op-code assembly unit and the data port, respectively. The second constant is pulled out of the line buffer in a subsequent cycle and forwarded through the constant data extraction logic to another data port. During that subsequent cycle, the op-code sub-field and the first operand as well as the newly retrieved second operand are propagated through the decode stage.</p><p>The constant data extracted by the constant data extraction unit and loaded into the appropriate port or ports essentially is ready for forwarding to the execute stage without flurther processing. However, the op-code bytes extracted by the op-code data extraction unit and passed through the op-code assembly unit must first be decoded. Control decode logic and a microcode-ROM, responsive to the op-code byte or bytes, generate control signals for the execute stage which control the execute stage to perform the specified instruction. The control decode logic generates the control signals relating to dynamic information, such as the address and data lengths used by the instruction and whether the bus should be locked during execution of the instruction. The microcode-ROM generates the control signals relating to fixed operations such as the actual ALU operation to be performed (add, subtract, multiply, XOR, etc.) and the source and destination of data.</p><p>The above-described architecture is designed to perform multiple functions as simply and quickly as possible so that a substantial amount of instruction decoding can be performed in a single cycle.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 is a high level block diagram of a pipelined processor constructed according to a preferred embodiment of the present invention.</p><p>FIG. 2 is a block diagram illustrating the various possible sub-fields and individual bytes of an instruction used in a microprocessor constructed according to a preferred embodiment of the present invention.</p><p>FIG. 3 is a more detailed block diagram of the components of a prefetch stage, including the line buffer, of a microprocessor constructed according to a preferred embodiment of the present invention.</p><p>FIG. 4 is a high level block diagram of the decode stage of a microprocessor constructed according with a preferred embodiment of the present invention.</p><p>FIG. 5 is a more detailed block diagram of the control decode logic unit shown in FIG. 4 according to a preferred embodiment of the present invention.</p><p>FIG. 6 is a more detailed block diagram of the op-code assembly unit, immediate one data port assembly unit, displacement data port assembly unit and immediate two data port assembly unit shown in FIG. 4 according to a preferred embodiment of the present invention.</p><p>FIG. 7 is a block diagram illustrating control circuitry for generating line buffer valid bit reset signals according to a preferred embodiment of the present invention.</p><p>FIG. 8 is a block diagram of the instruction pointer unit shown in FIG. 4 according to a preferred embodiment of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF A PREFERRED INVENTION</h4><p>Overview of Architecture</p><p>The prefetch method and apparatus of the present invention is particularly adapted for use in a microprocessor having a variable width instruction set and more particularly a microprocessor using the instruction set for x86 microprocessors. However, the invention has broader application to any type of processor.</p><p>FIG. 1 is a block diagram generally illustrating the various pipeline stages of a microprocessor according to a preferred embodiment of the present invention. As shown, the microprocessor is pipelined into five stages, namely, 1) a prefetch stage, 2) a decode stage, 3) an execute stage, 4) a write-back stage, and 5) a second write-back stage.</p><p>As shown, the prefetch stage includes two prefetch buffers <b>12</b> and <b>14</b>. Prefetch buffer <b>12</b> is the line buffer from which the decode stage pulls instruction bytes. It is the only data interface between the prefetch and decode stages. The prefetch stage also includes a 1 kilobyte instruction cache <b>16</b> and a cache tag memory <b>18</b> for storing tag data related to the data in the instruction cache <b>16</b>. The instruction cache is direct mapped with a line size 8 bytes wide. Both prefetch buffers also are 8 bytes wide, containing byte positions 0 (least significant byte) through byte position 7 (most significant byte). The prefetch stage also includes prefetch logic <b>20</b> for performing various functions relating to the control of the loading of the prefetch buffers with instructions.</p><p>Referring to FIG. 2, all instructions in the x86 instruction set are considered herein to be comprised of up to three sub-fields, each sub-field having several possible byte widths. The three possible sub-fields are the prefix sub-field, the op-code sub-field, and the constant sub-field. Every instruction comprises at least an op-code sub-field. The opcode sub-field defines the function which the execute stage is to perform with respect to that instruction (e.g. add, subtract, multiply, XOR, data movement, etc.). The op-code sub-field can be 1, 2 or 3 bytes in length. The op-code sub-field will always include an op-code byte defining the function to be performed. It may also include a MODRIM byte. The MODR/M byte is an addressing mode specifier. It specifies whether an operand is in a register or memory location and, if in memory, it specifies whether a displacement, a base register, an index register, and scaling are to be used. When the MODR/M byte indicates that an index register will be used to calculate the address of an operand, the instruction may comprise a third byte, termed the scaled index byte (SIB). The SIB byte is included in the instruction to encode the base register, the index register and a scaling factor.</p><p>Certain instructions also include a third sub-field, the constant data sub-field. The constant data sub-field can specify one or two operands used by the instruction. Specifically, the constant data sub-field may comprise 1) a displacement data operand, 2) an immediate date operand, 3) a displacement data operand and an immediate data operand, or 4) two immediate data operands. When the addressing mode is one in which a displacement will be used to compute the address of an operand, the instruction includes a displacement data operand as part of the constant sub-field. A displacement data operand can be 1, 2 or 4 bytes in length. An immediate operand directly provides the value of an operand. An immediate operand may be 1, 2 or 4 bytes in length. Accordingly, the constant sub-field, if any, can be 1, 2, 3, 4, 5, 6, or 8 bytes wide.</p><p>Certain parameters, such as the segment register to be used by instructions, the address size and the operand size, are set to default conditions in the execute and/or decode stages. These parameters, however, can be overridden by prefix bytes in the prefix sub-field of an instruction. There are four basic types of prefix bytes, namely; an address prefix for selecting between 16 or 32 bit addressing, 2) an operand size prefix byte for selecting between 16 or 32 bit data size, 3) a segment override byte which specifies the segment register an instruction should use, and 4) an instruction prefix which can toggle between two states which determine the table from which the op-code byte is decoded. Accordingly, the use of the instruction prefix essentially doubles the possible number of instructions. Because a particular prefix byte type, e.g., address prefix, can appear more than once in a single instruction, there can be anywhere from 0 to 14 prefix bytes in an instruction.</p><p>Referring back to FIG. 1, the execute stage executes the instructions. It also computes memory addresses for purposes of fetching operands out of memory. With respect to branch instructions, it computes and outputs linear memory addresses which are returned to the prefetch stage for fetching instructions. A branch instruction usually includes an operand which specifies the address location to which instruction flow is to jump. The branch address can be specified as a relative address (by providing the number of addresses or bytes from the present address to the branch address) or as a more complex value which must be calculated from the operands in the branch instruction and/or other data).</p><p>Alternately, the operand might specify a register or memory location from which the address or a portion of the address is to be fetched. The operand might also specify a direct offset address from which the linear address can be generated by adding in the base address of the current segment. Any number of other methods could be used also.</p><p>The x86 architecture uses a segmented address space and has several complex addressing modes. To generate a physical address according to the x86 architecture, at the very least, two quantities must be added. Particularly, the base address of the particular segment and a value indicating the distance of the desired data from the base of the segment (a segment offset value) must be added. The segment offset value itself may comprise up to three more parts, namely, a base, an index, and a displacement.</p><p>In order to keep the architecture simple and inexpensive yet allow most addresses to be computed in a single cycle, the execute stage employs two adders so that two address additions can be performed in one cycle. Accordingly, all addresses which have only a scaled index and a displacement or a base and a displacement can be calculated in a single cycle. During branch instructions, a first adder <b>28</b> generates the segment offset by adding the necessary values. The two particular values which are added, of course, depend on the particular instruction, and are selected by multiplexers <b>74</b>, <b>76</b>, <b>78</b> and <b>80</b>. The second adder <b>30</b> adds the calculated segment offset from the first adder to the segment base in order to generate the linear address. The segment base is supplied from the shadow register <b>32</b> of the execute stage. The linear address is then used to fetch instructions into the prefetch stage.</p><p>The execute stage also includes a register file <b>36</b> which is used to resolve the source and destination information for all operations in the execute stage.</p><p>The write-back stage includes the bus interface unit <b>38</b>, debug logic <b>40</b> and register write-back logic <b>42</b>. A second write-back stage is provided for special cases and allows completion of an independent register operation out of order while a memory write access is still pending.</p><p>Prefetch</p><p>When prefetching instructions for decoding, program instruction retrieval normally flows sequentially through the address space. However, jumps in instruction flow from one address to a non-consecutive address are extremely common, the most typical such occurrence being when a branch occurs in program flow. Interrupts also causes branch instruction flow. When a branch occurs, it may take several cycles before an address can be generated, provided to memory, and the instruction retrieved. Accordingly, it is not always possible to fetch instructions and provide them to the prefetch stage quickly enough so that the decode stage has a waiting instruction to decode each cycle. Such down-time obviously deteriorates the overall performance of a microprocessor. Accordingly, it is desirable to keep the line buffer in the prefetch stage as full as possible with instructions to be decoded and executed. Therefore, when a branch or other event occurs which requires an extended number of cycles to fetch an instruction, the decoder can continue to pull instructions out of the line buffer and continue decoding instructions during these periods.</p><p>The pipelined microprocessor of the present invention utilizes a two tier prefetch buffer architecture. As previously noted, the microprocessor of the preferred embodiment of the invention has a one kilobyte instruction cache. Thus, instructions can be prefetched from the instruction cache <b>16</b> from an external memory. The line buffer <b>12</b> is the boundary between the prefetch stage and the decode stage and is the buffer from which the decode stage pulls instructions for decoding. Secondary prefetch buffer <b>14</b> is a second tier buffer which temporarily holds instructions retrieved from memory (external memory or cache memory) during cycles in which the line buffer <b>12</b> does not have space for some or all of the retrieved instruction bytes.</p><p>As will be described in greater detail below, in the preferred embodiment of the invention, the decode stage can pull out a maximum of seven instruction bytes per cycle. from the line buffer <b>12</b>. Specifically, the decode stage decodes, per cycle, (1) one prefix byte or (2) an op-code sub-field (of up to three bytes) and the first operand in the constant data sub-field (of up to four bytes), if any or (3) the second operand in the constant data sub-field (of up to four bytes). Accordingly, an instruction which has two operands in its constant data sub-field requires at least two cycles to be executed and possibly more if the instruction has any prefix bytes.</p><p>FIG. 3 shows a logical representation of the two tier prefetch stage apparatus according to a preferred embodiment of the present invention. The provision of a two tier prefetch buffer helps keep the line buffer <b>12</b> as full as possible on each cycle and, thus, helps avoid pipeline stalls caused the unavailability of instructions in the line buffer <b>12</b> for the decode stage to decode.</p><p>The decode stage pulls instructions for decoding only out of the line buffer <b>12</b>. Accordingly, line buffer <b>12</b> is the data interface between the prefetch stage and the decode stage. Prefetch buffer <b>14</b> is a secondary buffer into which retrieved instruction bytes which cannot be loaded directly into the line buffer <b>12</b> are stored. The instruction bytes loaded into secondary buffer <b>14</b> are held there until space becomes available in the line buffer <b>12</b>, at which time the bytes are loaded from the secondary buffer <b>14</b> into the line buffer <b>12</b>.</p><p>More specifically, as instruction bytes are returned from memory, they are loaded into byte positions within the buffers <b>12</b> and <b>14</b> which are dictated by their addresses. Particularly, the 3 LSBs of the address dictate the byte position in the 8 byte wide buffers into which the instruction byte should be loaded. Accordingly, each byte returned from memory can be loaded into only one byte position in each buffer. Loading instruction bytes into the prefetch buffers in this manner substantially simplifies circuitry throughout the processor. Cache line and prefetch buffer widths of 8 bytes are preferred because it achieves a substantial reduction in semiconductor area as compared to prior art architectures in which the prefetch buffer (or queue) is as wide as the maximum possible instruction width or wider. However, it is still wide enough to accommodate the vast majority of instructions in a single line. This allows the vast majority of instructions to be loaded into the decode stage and decoded in a single cycle.</p><p>Instructions are returned to the prefetch stage, either on line <b>50</b> from the instruction cache or on line <b>52</b> from external memory, responsive to a memory request. The prefetch stage includes a transparent latch <b>54</b> for timing purposes. It also includes multiplexers <b>56</b> and <b>58</b>.</p><p>The instruction bytes returned from memory (either external memory or cache memory) are loaded directly into the line buffer <b>12</b>, if the appropriate byte position in line buffer <b>12</b> is available. Those instructions bytes for which space does not currently exist in the line buffer <b>12</b> are loaded into the corresponding byte position in secondary prefetch buffer <b>14</b>. An instruction byte held in secondary prefetch buffer <b>14</b> will be loaded into the line buffer <b>12</b> when the corresponding byte position in the line buffer <b>12</b> becomes available (i.e., when the decode stage consumes the instruction byte that is currently occupying that byte position in the line buffer).</p><p>Each byte position in the prefetch buffers has associated with it a valid tag bit indicating whether or not the data contained in the corresponding byte position of the buffer is a valid instruction byte which is to be decoded. The valid tag bits are used to determine which byte positions are available for loading of incoming instruction bytes from memory and which byte positions are occupied by valid instruction bytes to be decoded and, therefore, cannot be overwritten with incoming instruction bytes.</p><p>The clock enable signals <b>70</b> and <b>72</b> of prefetch buffers <b>0</b> and <b>1</b>, respectively, and the select control lines <b>62</b> and <b>64</b> of multiplexers <b>58</b> and <b>56</b>, respectively, are used to direct the instruction bytes returned from memory into the appropriate prefetch buffer <b>12</b> or <b>14</b>. Multiplexers <b>56</b> and <b>58</b> are each 8 bytes wide, which is the same width as the cache lines and the prefetch buffers. Multiplexers <b>56</b> and <b>58</b> also each have 8 select control lines <b>64</b> and <b>62</b>, respectively, so that each byte can be individually selected. Also, each byte of the prefetch buffers <b>12</b> and <b>14</b> can be individually enabled by a separate clock enable signal. Accordingly, the clock enable signals <b>72</b> and <b>70</b> of prefetch buffers <b>12</b> and <b>14</b>, respectively, also are 8 bits wide.</p><p>The select control lines <b>64</b> and <b>62</b> of multiplexers <b>56</b> and <b>58</b>, respectively, and the clock enable signals <b>70</b> and <b>72</b> of prefetch buffers <b>12</b> and <b>14</b>, respectively, are controlled in accordance with the following scheme to assure proper loading of data. As instructions are fetched from the cache or external memory, all bytes in byte positions for which there is room in the line buffer <b>12</b> (i.e., for which the corresponding byte positions in line buffer <b>12</b> are tagged invalid) are loaded directly into the line buffer <b>12</b>, bypassing secondary buffer <b>14</b>. Simultaneously, valid instruction bytes in secondary buffer <b>14</b> which are in byte positions corresponding to an invalid tagged byte position in line buffer <b>12</b> are loaded from secondary prefetch buffer <b>14</b> into line buffer <b>12</b>. Valid bytes from memory and valid bytes from secondary prefetch buffer <b>14</b> will never co-exist in the same byte position since a memory request would not have been made unless the data in secondary prefetch buffer <b>14</b> in the byte position corresponding to the incoming data from memory was tagged invalid. In other words, a memory request would not be made by the prefetch stage unless there was room in the secondary prefetch buffer <b>14</b> for the returned data.</p><p>Those instruction bytes returned from memory for which room does not presently exist in line buffer <b>12</b> are loaded into secondary prefetch buffer <b>14</b>. After each fetch, the valid tag bits of both buffers are updated. This updating operation includes consideration of not only the bytes which were loaded into buffers <b>12</b> and <b>14</b> during that cycle, but also those bytes in line buffer <b>12</b> which were consumed by the decoder during that cycle and, therefore, can be reset from valid to invalid. A more detailed disclosure of the prefetch stage of the microprocessor of the present invention can be found in U.S. patent application Ser. No. 08/445,569 (now U.S. Pat. No. 5,680,564 issued Oct. 21, 1997), entitled \u201cTwo Tier Prefetch Structure And Method With Bypass\u201d, (Attorney Docket No. NSC1-65000) filed on even date herewith and incorporated herein by reference.</p><p>Decode</p><p>FIG. 4 is a high level block diagram of the decode stage of a pipelined microprocessor according to a preferred embodiment of the invention. The line buffer <b>12</b> is shown at the top of the diagram. The decode stage pulls instruction bytes out of byte positions in the line buffer <b>12</b> as dictated by a series of instruction pointers generated by instruction pointer generating circuit <b>100</b>. The instruction pointers include a demand-instruction pointer (DIP), a temporary instruction pointer (TIP), an op-code length pointer (TIPOPLEN), and a shift pointer (TIPSHIFT). The DIP is generated each cycle to point to the linear address of the first byte of the instruction currently being operated on by the decode stage. The three least significant bits of the DIP identify the particular byte position in the line buffer at which that first instruction byte exists (because the buffer width is 8 or 2<sup>3 </sup>bytes). The TIP is generated each cycle to point to the first byte of the instruction which has not yet been consumed by the decode stage. The three LSBs of the TIP point to the byte position in the line buffer <b>12</b> of the first byte of the instruction which has not yet been consumed. The TIP will be the same as the DIP at the beginning of an instruction. The TIPOPLEN pointer is set to the sum of the TIP pointer and the op-code length so that it points to the first byte of constant data. The three LSBs of the TIPOPLEN point to the byte position in the line buffer <b>12</b> of the first byte of constant data, if any, of the instruction. The TIPSHIFT pointer points to the address to which the TIP will be updated when the decode stage consumes bytes. The 3 LSBs of TIPSHIFT point to byte position in the line buffer of the byte to which the TIP will be updated. As will become clear, TIPSHIFT is controlled to be one of the following depending on the portion of an instruction that is currently being operated on by the decode stage. Particularly, TIPSHIFT will be (1) one, (2) the TIP pointer plus the length of the op-code sub-field and the first operand, if any, of the instruction currently in the decode stage, or (3) the TIP pointer plus the length of the second operand of the instruction currently in the decode stage.</p><p>The prefetch stage loads the line buffer and the decode stage consumes bytes from the line buffer in a circular queue fashion. In other words, the pointers are updated in a consecutive fashion from byte 0 through byte 7, and when byte 7 is consumed, the pointers wrap around back to byte 0. For instance, if a 4 byte instruction starts at byte position 6 in line buffer <b>12</b>, the next byte for that instruction appears at byte position 7, the one after that appears at byte position 0, and the last one appears at byte position 1.</p><p>In the terminology of this specification, bytes are \u201cconsumed\u201d by the decode stage when they are passed through the data extraction circuits <b>102</b> and <b>104</b> to the op-code assembly circuit <b>106</b> and/or constant data ports <b>108</b>, <b>110</b> and <b>112</b>, where they are either decoded or stored in shadow registers as described more fully below.</p><p>If an instruction has any prefix bytes, they are consumed one per cycle. All op-code bytes as well as all bytes of the first operand in the constant sub-field, if any, are consumed simultaneously in one cycle following the decoding of the last prefix byte. If there is a second operand in the constant sub-field, all of its bytes are consumed simultaneously in a subsequent cycle.</p><p>The decode stage comprises an op-code data extraction circuit <b>102</b>. It is an 8 byte to 3 byte extraction circuit. It takes in all 8 bytes from the line buffer <b>12</b> and selects the byte position in the line buffer pointed to by the TIP pointer and the two following bytes in a circular queue fashion. The op-code extraction circuit <b>102</b> includes circuitry for quickly determining if the first byte pointed to by the TIP pointer is an op-code byte or a prefix byte.</p><p>If it is a prefix byte and it is tagged valid, it is forwarded to op-code assembly circuit <b>106</b>, where it is directed into prefix decoding logic in control decode logic circuit <b>116</b>. Control decode logic <b>116</b> sets a flag in prefix flag register <b>114</b> corresponding to the information conveyed by the prefix byte. If the byte position in the line buffer <b>12</b> pointed to by the TIP is not tagged valid, the decode stage simply stalls until a subsequent cycle in which it is tagged as valid.</p><p>Prefix register <b>114</b> is shown in more detail in FIG. <b>5</b>. As shown, it is 7 bits wide and keeps track of dynamic information relating to the instruction in the decode stage. Particularly, the LOCK bit indicates whether or not the bus is to be locked during that instruction. The SEGOVRD bit indicates whether or not an override segment should be used for addressing during that instruction and identifies the particular segment to be used. Repeat is Equal (REPE) and Repeat is not Equal (REPNE) relate to string instructions in the x86 architecture. O<b>32</b> indicates whether the data for the instruction is 16 or 32 bits wide. A<b>32</b> indicates whether addressing for that instruction uses 16 or 32 bit wide addresses. Finally, the TWO BYTE bit indicates whether the op-code is a one or two byte op-code. All seven of the parameters controlled by the prefix register have default values to which the register is reset at the beginning of every instruction. If a prefix byte indicates dynamic information other than the corresponding default condition contained in the prefix flag register, the prefix flag register is rewritten with the new information.</p><p>Returning to FIG. 4, after the prefix byte is consumed, the TIP is incremented by one. This process is followed for each prefix byte in an instruction until the first byte in the op-code data extraction circuit <b>102</b> is an op-code byte, rather than a prefix byte.</p><p>When the first byte in the op-code extraction circuit <b>102</b> (i.e., the byte position pointed to by the TIP) is tagged valid and is an op-code byte, the bytes are processed differently. In particular, the op-code extraction unit <b>102</b> includes logic for very quickly pre-decoding the op-code field to determine whether the instruction includes constant data, whether the constant data comprises one or two operands, and the width of the op-code and each operand. The op-code width is added to the TIP in order to generate a TIPOPLEN pointer, which is used to load the constant data extraction unit <b>104</b> with the four bytes of data following the last byte of the op-code. Unless the op-code data extraction unit <b>102</b> determines that it has received valid bytes for the entire op-code sub-field and the first operand in the constant data sub-field, if any, it does not update the TIP.</p><p>If the instruction includes constant data, then constant data extraction unit <b>104</b> becomes relevant. Constant data extraction unit <b>104</b> is an 8 byte to 4 byte extractor which extracts the byte in the byte position in the line buffer pointed to by the TIPOPLEN pointer and the three consecutive following bytes (in modulo 8 arithmetic). The constant data extraction circuit <b>104</b> checks the valid bits corresponding to the first operand (which can be one, two or four bytes wide, as previously noted). When all the bytes of the op-code sub-field and all bytes of the first operand in the constant sub-field, if any, are tagged valid, the op-code extraction unit <b>102</b> consumes the op-code sub-field bytes by forwarding them to an op-code assembly circuit <b>106</b> and the constant data extraction circuit <b>104</b> consumes the first operand bytes by forwarding them to data port <b>108</b>, if it is immediate data, or data port <b>112</b>, if it is displacement data.</p><p>The TIP is now incremented by the number of bytes consumed, i.e., up to the location pointed to by the TIPSHIFT pointer. The three LSBs of the TIP pointer circularly address the line buffer. If the instruction was one having no constant data or only one operand in the constant data sub-field (so that the instruction has now been completely consumed), the DIP pointer is loaded with the TIP pointer value so that the DIP and TIP pointers both now point to the beginning of the next instruction. If, however, the instruction is one which includes a second operand, the DIP pointer is unchanged and the TIP pointer is updated to the TIPSHIFT pointer value. When the DIP and TIP pointers have been updated in this manner, the TIPOPLEN pointer is set equal to the TIP pointer (rather than TIP pointer plus op-code width) and TIPSHIFT is updated to the address of the first byte of the next instruction, i.e., to the NIP pointer value. The constant data extraction circuit <b>104</b> now takes in the next four bytes.</p><p>When all of the bytes of the second operand (which may be one, two or four bytes wide) are tagged valid, those bytes are consumed by the decode stage, i.e., forwarded to the immediate two data port <b>110</b>. Also, the TIP pointer is incremented to the first byte of the next instruction and the DIP pointer is loaded with the new TIP pointer value.</p><p>FIG. 6 is a more detailed block diagram of the op-code assembly circuit <b>106</b>, immediate one data port assembly circuit <b>108</b>, immediate 2 data port assembly circuit <b>110</b> and displacement data port assembly circuit <b>112</b>.</p><p>Referring first to op-code assembly circuit <b>106</b>, it comprises three one byte wide shadow registers <b>114</b>, <b>116</b> and <b>118</b> and three 2:1 multiplexers <b>120</b>, <b>122</b> and <b>124</b>. The first input terminals of the multiplexers <b>120</b>, <b>122</b>, <b>124</b> are coupled to receive the output of the corresponding shadow register <b>114</b>, <b>116</b>, <b>118</b>. The second input terminals of the multiplexers are coupled to receive the corresponding byte directly out of the op-code extraction circuit <b>102</b>. Basically, once the prefix bytes have been decoded and the prefix flag register updated, if the instruction has less than two operands in the constant data sub-field, then it can be extracted and decoded in the same cycle. In such situations, when the op-code byte or bytes and constant byte or bytes, if any, of the instruction are all valid, multiplexers <b>120</b>, <b>122</b> and <b>124</b> select their second inputs so as to pass through the bytes directly from the op-code extraction circuit <b>102</b> to be decoded. If, however, the instruction includes a second operand, then the decode stage does not consume the entire op-code sub-field and constant sub-field in a single cycle since the constant data extraction circuit <b>104</b> does not extract two operands simultaneously. Accordingly, when the instruction includes two operands, the op-code byte or bytes are loaded into shadow register <b>114</b>, <b>116</b>, <b>118</b> through the second inputs of the multiplexers <b>120</b>, <b>122</b> and <b>124</b> and the paths shown connecting the outputs of the multiplexers to the shadow registers. The op-code bytes will be held in these shadow registers until the remainder of the instruction (i.e., the second operand) can be loaded into the decode stage in a subsequent cycle. During the cycle in which the second operand is consumed, all of the op-code sub-field bytes can be read out of the shadow buffers <b>114</b>, <b>116</b> and <b>118</b> through the first input terminals of multiplexers <b>120</b>, <b>122</b>, and <b>124</b> simultaneously with the forwarding of the two operands to the remaining decode stage circuitry for decoding and presentation to the execute stage.</p><p>The handling of the first operand in the constant sub-field by the immediate one data port <b>108</b> and displacement data port <b>112</b> is essentially the same as described above with respect to the op-code assembly circuit <b>106</b> except that an alternate arrangement of the 2:1 multiplexers with respect to the shadow buffers is illustrated in order to show an alternate way of achieving a similar goal. Particularly, if the instruction includes only one operand and it is an immediate operand, 2:1 multiplexers <b>126</b>, <b>128</b>, <b>130</b> and <b>132</b> are controlled to select their second inputs so as to receive the data directly out of the constant extraction circuit <b>104</b> and forward it to the remaining decode stage circuitry. However, if there is a second operand, the immediate data is loaded into shadow registers <b>134</b>, <b>136</b>, <b>138</b>, and <b>140</b>. On a subsequent cycle, the second operand is extracted and multiplexers <b>126</b>, <b>128</b>, <b>130</b> and <b>132</b> are controlled to select their first input so as to output the data in the shadow registers <b>134</b>, <b>136</b>, <b>138</b> and <b>140</b>.</p><p>If, on the other hand, the first operand is displacement data, immediate one data port <b>108</b> does not operate. Instead, displacement data port <b>110</b> operates. Particularly, if there is only one operand, multiplexer <b>156</b>, <b>158</b>, <b>160</b> and <b>162</b> are controlled to select their second inputs so as to receive the data directly out of the constant data extraction circuit <b>104</b> and forward it to the-remaining decode stage circuitry. However, if there is a second operand, the displacement data is loaded into shadow registers <b>164</b>, <b>166</b>, <b>168</b> and <b>170</b> and, on a subsequent cycle, the second operand is extracted and multiplexers <b>156</b>, <b>158</b>, <b>160</b> and <b>162</b> are controlled to select their first inputs so as to output the data in the shadow registers <b>164</b>, <b>166</b>, <b>168</b> and <b>170</b>.</p><p>As shown, both the immediate one assembly port <b>108</b> and the displacement assembly port <b>110</b> include a second layer of two to one multiplexers <b>142</b>, <b>144</b>, <b>146</b>, <b>148</b> and <b>180</b>, <b>182</b>, <b>184</b>, <b>186</b>, respectively. Since both the immediate one assembly port <b>108</b> and the displacement assembly <b>110</b> operate exactly the same, the function and operation of these multiplexers will described with respect to the immediate one assembly port <b>108</b> only. Particularly, each of the multiplexers <b>142</b>, <b>144</b>, <b>146</b> and <b>148</b> have a first input coupled to ground and a second input coupled to the output of the preceding row of two to one multiplexers <b>126</b>, <b>128</b>, <b>130</b> and <b>132</b>. As previously noted, the operand data can be one, two or four bytes wide. If the data is four bytes wide, then all of multiplexers <b>134</b>, <b>136</b>, <b>138</b> and <b>140</b> select their second inputs, which are coupled to the preceding row of multiplexers <b>126</b>, <b>128</b>, <b>130</b> and <b>132</b>. However, if the data is less than four bytes wide or if there is no constant data, zeros must be forced out on the unused bytes. Accordingly, multiplexers <b>134</b>, <b>136</b>, <b>138</b> and <b>140</b> are individually controlled to select their first inputs, which are coupled to ground, if the corresponding byte positions are not occupied by constant data. For example, if an instruction has one immediate operand which is two bytes wide, multiplexers <b>146</b>, <b>148</b> are controlled to select their second inputs so as to output zeros in those byte positions while multiplexers <b>134</b> and <b>136</b> are controlled to select their first inputs so as to output the data byte.</p><p>When there is a second operand, the bytes of the second operand are forwarded out of constant extraction circuit <b>104</b> to the immediate two data port <b>112</b>. The immediate two data port <b>110</b> does not include shadow registers or the first layer of multiplexers found in the other data ports <b>108</b> and <b>112</b>. This is because, when an instruction has a second operand, it is always the last part of the instruction extracted and will never have to be held in the decode stage awaiting an additional part of the instruction. Accordingly, the second operand can always be forwarded directly out of the immediate two data port <b>110</b> to the remaining decode stage circuitry. It does, however, comprise the second layer of 2:1 multiplexers, <b>172</b>, <b>174</b>, <b>176</b>, and <b>178</b> for selecting between the second operand data bytes and zero.</p><p>FIG. 5 is a more detailed block diagram of control decode logic <b>116</b> shown in FIG. <b>4</b>. Control decode logic <b>116</b> decodes dynamic control information of the instruction, while the fixed functional instruction information is decoded by a microcode ROM <b>198</b>. Random logic circuit <b>188</b> receives the three bytes output by the op-code assembly circuit <b>106</b> as well as the corresponding valid tag bits. When the first byte is a valid prefix byte, the random logic <b>188</b> updates the prefix register <b>114</b> as previously described. When the incoming bytes comprise an op-code, operation differs. Random logic <b>188</b> includes a small combinational logic circuit which determines certain dynamic parameters of the instruction. First, random logic <b>188</b> determines if the instruction has a MODR/M byte and/or SIB byte in the op-code sub-field and generates three one bit signals, NOMODHIT, MODHIT, and SIBHIT. The op-code bytes are simultaneously decoded in three tables, <b>190</b>, <b>192</b> and <b>194</b> corresponding, respectively, to how the op-code byte(s) should be decoded if (1) there is no MODRIM byte, (2) there is a MODR/M byte, but no SIB byte, and (3) there is a MODR/M byte and a SIB byte. The data output from the tables <b>190</b>, <b>192</b>, <b>194</b> includes the length of the op-code and constant sub-fields of the instruction, the identity of the registers containing the base and index pointers to be used for addressing during that instruction, and the source and destination registers for data needed for or generated by that instruction. It also includes information as to when the decoding of the instruction is complete. The output of multiplexer <b>196</b> is latched into the buffers at the end of the decode stage for forwarding into the execute stage on the next pipeline cycle. The outputs of the three tables are forwarded to a 3:1 multiplexer <b>196</b>, which is controlled responsive to the three aforementioned HIT signals generated by random logic <b>188</b> to select the output signals from the appropriate one of the three tables <b>190</b>, <b>192</b>, and <b>194</b>. Alternately, tristates having outputs coupled to a common bus can be used in place of the multiplexer.</p><p>The dynamic control information includes the prefix parameters loaded into the prefix flag register <b>114</b>, such as op-code shift length, constant shift length, base and index pointers, and register sources and destinations. The dynamic control information also includes the aforementioned HIT signal information and the data output by the tables <b>190</b>, <b>192</b> and <b>194</b>.</p><p>Referring again to FIG. 4, part of the dynamic control information output by three to one multiplexer <b>196</b> is used by address generation logic <b>200</b> to generate a microcode ROM entry address. Address generation circuit <b>200</b> includes a small combinational logic cell and some multiplexers for generating the entry address into the microcode ROM for the particular instruction based on the op-code byte, certain MODRIM bits and certain dynamic control information received from the tables in the control decode logic <b>116</b> through multiplexer <b>196</b>. Responsive to a 12 bit address output from address generator <b>200</b>, microcode ROM <b>198</b> output instruction sequencing control lines for the execute stage. The condition of these control lines are latched into buffers at the bottom of the decode logic for forwarding into the execute stage on the next pipeline cycle.</p><p>As instructions are consumed by the decode stage, the valid tag bits in the line buffer <b>12</b> must be reset accordingly. FIG. 7 illustrates an exemplary circuit for resetting the valid tag bits. As shown, the 3 LSBs of the TIP pointer are input to a three to eight decoder <b>212</b> and the 3 LSBs of the TIPSHIFT pointer are input into another three to eight decoder <b>214</b>. The valid tag bits which are to be reset are those bits which are consumed by the decode stage in a given cycle, i.e., the bytes between TIP and TIPSHIFT. Thus, if TIP is pointing to byte position 2 in the line buffer <b>12</b> and TIPSHIFT is pointing to byte position 5 in the line buffer, the valid tag bits corresponding to byte positions 2, 3, and 4 should be reset, while the remaining valid tag bits, i.e., the tag bits of byte positions 0, 1, 5, 6 and 7, should not be altered by the decode stage reset circuit. (These bits, however, may be altered by prefetch stage circuitry to reflect the loading of instruction bytes into the line buffer from memory.)</p><p>The circuit shown in FIG. 7 generates eight reset bits, one corresponding to each byte position in the line buffer <b>12</b>. A logical one indicates that the corresponding byte has been consumed and the corresponding valid bit should be reset in the line buffer. A logical zero indicates that the corresponding byte has not been consumed by the decode stage and the corresponding valid tag bit should not be altered. The reset bits RO through R<b>7</b> are used in the prefetch stage as a mask, along with some other masks which indicate which byte positions in the line buffer <b>12</b> have received data from memory during that cycle, for updating the valid tag bits of the line buffer <b>12</b>. Particularly, if a reset bit is set, then logic in the prefetch stage resets the corresponding valid tag bit in the line buffer. If a reset bit is not asserted, the logic in the prefetch stage allows the previous condition of the valid tag bit to remain unchanged. A detailed description of the circuit shown in FIG. 7 can be found in U.S. patent application Ser. No. 08/451,535 (now U.S. Pat. No. 5,617,543 issued Apr. 3, 1997), entitled \u201cNon-Arithmetical Circular Buffer Cell Availability Status Indicator Circuit\u201d filed on even date herewith (Attorney Docket No. NSC1-64000) and incorporated herein by reference.</p><p>The prefetch stage circuitry for resetting the valid tag bits in the line buffer is described in detail in U.S. patent application Ser. No. 08/445,569 (now U.S. Pat. No. 5,680,564 issued Oct. 21, 1997), entitled \u201cTwo Tier Prefetch Buffer Structure and Method with Bypass\u201d filed on even date herewith (Attorney Docket No. NSC1-65000) and also incorporated herein by reference.</p><p>FIG. 8 illustrates in more detail the components of the instruction pointer generation circuit <b>100</b> of FIG. 4 for generating the DIP, TIP, TIPOPLEN and TIPSHIFT pointers. The 32 bit DIP pointer is collectively held within two registers <b>230</b> and <b>232</b>. The three LSBs are held in register <b>230</b> while the <b>29</b> MSBs are held in register <b>232</b>. The three LSBs of the TIP pointer are held in register <b>234</b>. An additional copy is kept in register <b>236</b>. The 3 LSBs of the DIP value always point to the byte position in the line buffer <b>12</b> at the beginning of the instruction currently being decoded by the decode stage. The 3 LSBs of the TIP value point to the byte position in the line buffer <b>12</b> which is the first sequential byte in the instruction which has not been consumed by the decode stage.</p><p>At the beginning of the decoding of each instruction, the TIP and DIP pointers are equal. There are four possible sets of control signals into the circuit shown in FIG. 8 depending upon the type of instruction which is being decoded and the portion of that instruction which is currently being consumed by the decode stage. Accordingly, as will become clear, the circuit of FIG. 8 can have its control lines set by a state machine. The four possible states of the circuit cover the following circumstances; (1) the decode stage is consuming a prefix byte, (2) the decode stage is consuming an op-code sub-field and the first operand in the constant data sub-field, if any, (3) the decode stage is consuming the second operand of an instruction and (4) a branch has occurred in the execute stage of the processor.</p><p>A first adder <b>238</b> has first and second inputs coupled to receive signals termed herein VAL<b>1</b> and VAL<b>2</b>. The values of VAL<b>1</b> and VAL<b>2</b> depend on which of the four states the circuit is in. When the decode stage detects that the first byte in the op-code extraction circuit <b>102</b> is a prefix byte, it goes into the first state and VAL<b>1</b> is set to one and VAL<b>2</b> is set to zero. When the decode stage detects that the first byte in the op-code extraction circuit <b>102</b> is an op-code byte, it goes into the second state and VAL<b>1</b> is set to the op-code width (which is pre-decoded from the op-code bytes, as previously mentioned) and VAL<b>2</b> is set to the first operand width (which is pre-decoded from the op-code bytes, also as previously mentioned). (The first operand width is zero if the instruction does not include an operand.) When the decode stage is extracting the second operand of a two operand instruction, it goes into the third state and VAL<b>1</b> is set to zero and VAL<b>2</b> is set to the width of the second operand. Finally, if the circuit <b>100</b> receives a BRANCH TAKEN signal from the execute stage, it goes into the fourth stage in which the condition of the inputs of adder <b>238</b> will not matter. As can be surmised, the adder <b>238</b> generates the value which should be added to the TIP pointer to generate the TIPSHIFT pointer, termed herein SHIFT LENGTH.</p><p>The adder <b>238</b> adds together the two values and outputs the sum to a first input of a second adder <b>240</b>. The second adder <b>240</b> receives the output of the 3 bit TIP register <b>234</b> at a second input. The adder <b>240</b> adds the two values to generate the 3 LSBs of the TIPSHIFT value. The output of adder <b>240</b> is sent to a 2:1 multiplexer <b>244</b>, the output of which feeds the DIP register <b>230</b> and the TIP register <b>234</b>. These connections allow the DIP and TIP pointers to be updated to TIPSHIFT as bytes are consumed, as will be described in more detail below.</p><p>A second pair of adders <b>246</b> and <b>248</b> perform a similar function of adding the TIP value. These adders, however, do the additions in a different order. Particularly, the first adder <b>246</b> adds VAL<b>1</b> to the 3 LSBs of the TIP value stored in the second TIP register <b>250</b> to generate the TIPOPLEN pointer. The TIPOPLEN pointer is then added by adder <b>248</b> to VAL<b>2</b> to generate another version of TIPSHIFT. The output of adder <b>248</b> is coupled to one input of a 2:1 multiplexer <b>236</b>. The output of multiplexer <b>250</b> is the input to the second TIP register <b>236</b>. Accordingly, TIP registers <b>234</b> and <b>236</b> are always updated.</p><p>The carry bit out of the third bit position of adder <b>240</b> is provided to a buffer circuit <b>254</b>. When there is a carry bit out of the third bit position of adder <b>240</b>, it means that a wrap around has occurred in the addressing of the bytes in the line buffer. Accordingly, the carry bit indicates that the value in the 29 MSB DIP register <b>232</b> must be incremented by one. Accordingly, buffer <b>254</b> outputs the select control signal to 2:1 multiplexer <b>256</b>. The first data input of multiplexer <b>256</b> is coupled to the output of the 29 MSB DIP register <b>232</b>. The second input to multiplexer <b>256</b> is the output of adder <b>258</b> which simply increments the DIP MSB value by one, as shown. When the carry bit in the third bit position of buffer <b>254</b> is asserted, multiplexer <b>256</b> selects the output of adder <b>258</b> as its input. Otherwise, it selects the value output from register <b>232</b>. Stated simply, this circuitry increments the MSB portion of the DIP register <b>232</b> by one whenever a wrap around occurs in the line buffer <b>12</b>.</p><p>The 2:1 multiplexers <b>244</b> and <b>250</b>, as well as the 2:1 multiplexer <b>252</b>, are provided so as to allow a different value to be loaded into these registers in the event of a branch. When the decoder stage receives a BRANCH TAKEN signal <b>231</b> from the execute stage, the pipeline stages preceding the execute stage (i.e., the prefetch and decode stages) must be flushed. Accordingly, the decode stage provides the BRANCH TAKEN signal to the select control inputs of multiplexers <b>244</b>, <b>250</b> and <b>252</b>. If the BRANCH TAKEN signal is not asserted, then multiplexers <b>244</b>, <b>250</b> and <b>252</b> select their first inputs so that the TIP and DIP registers <b>234</b>, <b>236</b>, <b>232</b> can be updated as previously described. However, if a branch is taken, then the DIP and TIP registers must be reloaded with the destination address of the branch instruction. Accordingly, when BRANCH TAKEN is asserted, multiplexers <b>244</b>, <b>250</b> and <b>252</b> select their second inputs which are coupled to received the branch address as generated elsewhere (usually in the execute stage).</p><p>The TIP and DIP registers <b>232</b>, <b>234</b> and <b>236</b> cannot necessarily be incremented by the sum of VAL<b>1</b> and VAL<b>2</b> each cycle. For instance, the decode stage must stall until all of the bytes in the line buffer corresponding to the portion of the instruction to be decoded are tagged valid. The necessary valid bytes may number anywhere from 1 (when it is a prefix byte or a one byte instruction) to seven (when the instruction includes a three byte op-code sub-field and a four byte operand). Also, the decode stage may need to stall for reasons unrelated to the availability of bytes in the line buffer. For example, the execute stage may be executing a very time consuming instruction so that even though the line buffer contains the necessary bytes to decode, the decode stage must stall because it cannot forward the decoded instruction to the execute stage until the execute stage has finished executing the previous instruction. Further, while the TIP pointer is updated every time bytes are consumed by the decode stage, DIP is updated only when the last byte of an instruction is consumed.</p><p>Accordingly, the clock enable signals <b>260</b> and <b>262</b> for the DIP and TIP registers, respectively, are controlled so as to be asserted to allow these registers to be updated to TIPSHIFT only when bytes are actually consumed and conditions are proper for updating.</p><p>Particularly, referring to the combinational logic shown in box <b>270</b> of FIG. 8, the clock enable <b>260</b> for the DIP registers <b>230</b> and <b>232</b> is asserted only when the BRANCH TAKEN signal is asserted or the last cycle, shift enough and the program counter advance signals are all asserted. The last cycle signal simply indicates that the last portion of the instruction is being consumed. It can be easily derived from the op-code of the instruction. The shift enough signal is a signal which indicates that the number of bytes needed to decode the relevant portion of the instruction are all tagged valid. This signal can be easily derived from logical combination of the data pre-decoded from the instruction as previously discussed and the line buffer valid tag bits. Finally, the program counter advance signal is asserted when the decode stage has completed the current decode cycle.</p><p>The TIP register clock enable signal <b>262</b> is asserted only if the program counter advances, and the shift enough signal is asserted. The logic circuitry shown in box <b>270</b> illustrates an exemplary circuit for generating the DIP and TIP clock enable signals <b>260</b> and <b>262</b> as just described.</p><p>Having thus described a few particular emobiments of the invention, various alterations, modifications and improvements will readily occur to those of skill in the art. Such alterations, modifications and improvement as are made obvious by this disclosure are intended to be part of this description though not expressly stated herein, and are intended to be within the spirit and scope of the invention. Accordingly, the foregoing description is by way of example only and is not limiting. The invention is limited only as defined in the following claims and equivalents thereto.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Christopher E.", "last_name": "Phillips", "name": ""}, {"first_name": "Robert J.", "last_name": "Divivier", "name": ""}, {"first_name": "Mario", "last_name": "Nemirovsky", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "NATIONAL SEMICONDUCTOR CORP."}, {"first_name": "", "last_name": "NATIONAL SEMICONDUCTOR CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/30        20060101A I20051008RMEP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711213"}, {"primary": false, "label": "712210"}, {"primary": false, "label": "711217"}, {"primary": false, "label": "712E09029"}, {"primary": false, "label": "712200"}, {"primary": false, "label": "712E09055"}], "ecla_classes": [{"label": "G06F   9/38B9"}, {"label": "G06F   9/38B"}, {"label": "G06F   9/38B8"}, {"label": "G06F   9/38P"}, {"label": "G06F   9/30T2"}], "cpc_classes": [{"label": "G06F   9/30149"}, {"label": "G06F   9/3816"}, {"label": "G06F   9/3814"}, {"label": "G06F   9/3867"}, {"label": "G06F   9/3802"}, {"label": "G06F   9/3863"}, {"label": "G06F   9/30149"}, {"label": "G06F   9/3867"}, {"label": "G06F   9/3802"}, {"label": "G06F   9/3816"}, {"label": "G06F   9/3814"}, {"label": "G06F   9/30149"}, {"label": "G06F   9/3816"}, {"label": "G06F   9/3867"}, {"label": "G06F   9/3814"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1995-05-26", "application_date": "1995-05-26", "family_members": [{"ucid": "EP-0772821-B1", "titles": [{"lang": "DE", "text": "MARKIERTER VORAUSLADUNGSABSTAND-UND BEFEHLSDEKODER VON VARIABLER L\u00c4NGE, BEFEHLSS\u00c4TZE UND IHRE VERWENDUNGSWEISE"}, {"lang": "EN", "text": "TAGGED PREFETCH AND INSTRUCTION DECODER FOR VARIABLE LENGTH INSTRUCTION SET AND METHOD OF OPERATION"}, {"lang": "FR", "text": "DISPOSITIF DE PREEXTRACTION MARQUE ET DECODEUR D'INSTRUCTIONS POUR INSTRUCTIONS DE LONGUEUR VARIABLE ET PROCEDE DE MISE EN  UVRE"}]}, {"ucid": "KR-970705079-A", "titles": [{"lang": "EN", "text": "Tag prefetch and instruction translator for variable length instruction set, and Tagged Prefetch and Instruction Decoder for Variable Length Instruction Set and Method of Operation"}, {"lang": "KO", "text": "\uac00\ubcc0\uae38\uc774 \uba85\ub839\uc5b4 \uc138\ud2b8\ub97c \uc704\ud55c \ud0dc\uadf8 \ud504\ub9ac\ud398\uce58\uc640 \uba85\ub839\uc5b4\ubc88\uc5ed\uae30 \ubc0f \uc791\ub3d9\ubc29\ubc95(Tagged Prefetch and Instruction Decoder for Variable Length Instruction Set and Method of Operation)"}]}, {"ucid": "DE-69624195-T2", "titles": [{"lang": "EN", "text": "MARKED PRELOADING DISTANCE AND COMMAND DECODER OF VARIABLE LENGTH, COMMAND SETS AND THEIR USE"}, {"lang": "DE", "text": "MARKIERTER VORAUSLADUNGSABSTAND-UND BEFEHLSDEKODER VON VARIABLER L\u00c4NGE, BEFEHLSS\u00c4TZE UND IHRE VERWENDUNGSWEISE"}]}, {"ucid": "DE-69624195-D1", "titles": [{"lang": "EN", "text": "MARKED VARIABLE LENGTH PRELOAD DISTANCE AND COMMAND DECODER, COMMAND SETS AND THEIR USE"}, {"lang": "DE", "text": "MARKIERTER VORAUSLADUNGSABSTAND-UND BEFEHLSDEKODER VON VARIABLER L\u00c4NGE, BEFEHLSS\u00c4TZE UND IHRE VERWENDUNGSWEISE"}]}, {"ucid": "US-6237074-B1", "titles": [{"lang": "EN", "text": "Tagged prefetch and instruction decoder for variable length instruction set and method of operation"}]}, {"ucid": "WO-1996037829-A1", "titles": [{"lang": "EN", "text": "TAGGED PREFETCH AND INSTRUCTION DECODER FOR VARIABLE LENGTH INSTRUCTION SET AND METHOD OF OPERATION"}, {"lang": "FR", "text": "DISPOSITIF DE PREEXTRACTION MARQUE ET DECODEUR D'INSTRUCTIONS POUR INSTRUCTIONS DE LONGUEUR VARIABLE ET PROCEDE DE MISE EN \u00d7UVRE"}]}, {"ucid": "EP-0772821-A1", "titles": [{"lang": "DE", "text": "MARKIERTER VORAUSLADUNGSABSTAND-UND BEFEHLSDEKODER VON VARIABLER L\u00c4NGE, BEFEHLSS\u00c4TZE UND IHRE VERWENDUNGSWEISE"}, {"lang": "EN", "text": "TAGGED PREFETCH AND INSTRUCTION DECODER FOR VARIABLE LENGTH INSTRUCTION SET AND METHOD OF OPERATION"}, {"lang": "FR", "text": "DISPOSITIF DE PREEXTRACTION MARQUE ET DECODEUR D'INSTRUCTIONS POUR INSTRUCTIONS DE LONGUEUR VARIABLE ET PROCEDE DE MISE EN  UVRE"}]}]}