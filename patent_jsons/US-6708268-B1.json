{"patent_number": "US-6708268-B1", "publication_id": 73760549, "family_id": 23071732, "publication_date": "2004-03-16", "titles": [{"lang": "EN", "text": "Microcontroller instruction set"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11660735\" source=\"national office\"><p>A microcontroller apparatus is provided with an instruction set for manipulating the behavior of the microcontroller. The apparatus and system is provided that enables a linearized address space that makes modular emulation possible. Direct or indirect addressing is possible through register files or data memory. Special function registers, including the Program Counter (PC) and Working Register (W), are mapped in the data memory. An orthogonal (symmetrical) instruction set makes possible any operation on any register using any addressing mode. Consequently, two file registers to be used in some two operand instructions. This allows data to be moved directly between two registers without going through the W register. Thus increasing performance and decreasing program memory usage.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50636841\"><p>A microcontroller apparatus is provided with an instruction set for manipulating the behavior of the microcontroller. The apparatus and system is provided that enables a linearized address space that makes modular emulation possible. Direct or indirect addressing is possible through register files or data memory. Special function registers, including the Program Counter (PC) and Working Register (W), are mapped in the data memory. An orthogonal (symmetrical) instruction set makes possible any operation on any register using any addressing mode. Consequently, two file registers to be used in some two operand instructions. This allows data to be moved directly between two registers without going through the W register. Thus increasing performance and decreasing program memory usage.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00001\" num=\"1\"><claim-text>1. A microcontroller comprising:</claim-text><claim-text>a central processing unit; </claim-text><claim-text>a data memory having a linearized address space coupled with said central processing unit being divided into n banks; </claim-text><claim-text>said central processing unit comprising: </claim-text><claim-text>a bank select unit which either accesses one of said banks or accesses a virtual bank, whereby said virtual bank combines partial memory space of two banks of said data memory and wherein said selected bank forms a register file; </claim-text><claim-text>an arithmetic logic unit coupled with said register file; </claim-text><claim-text>a plurality of special function registers being mapped to one of said banks in said data memory, wherein one of said special function registers is a working register being coupled with said arithmetic logic unit; </claim-text><claim-text>a program counter register within said central processing unit, said program counter mapped in said data memory; and </claim-text><claim-text>a working register within said central processing unit being coupled with said arithmetic logic unit, said working register mapped in said data memory; </claim-text><claim-text>wherein said microcontroller having an instruction set for controlling said arithmetic logic unit and wherein at least one instruction comprises a bit indicating whether said bank select unit accesses one of said banks or said virtual bank. </claim-text></claim>"}, {"num": 2, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00002\" num=\"2\"><claim-text>2. A microcontroller comprising:</claim-text><claim-text>a central processing unit; </claim-text><claim-text>a data memory coupled with said central processing unit being divided into n banks; </claim-text><claim-text>said central processing unit comprising: </claim-text><claim-text>a bank select unit for selecting one of said banks in said data memory, wherein said selected bank forms a register file; </claim-text><claim-text>an arithmetic logic unit coupled with said register file; </claim-text><claim-text>a plurality of special function registers being mapped to one of said banks in said data memory, wherein one of said special function registers is a working register being coupled with said arithmetic logic unit. </claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00003\" num=\"3\"><claim-text>3. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1111 kkkk kkkk, wherein the contents of said working register are added to an 8-bit literal \u2018k\u2019 and the result is placed in said working register, said literal \u2018k\u2019 is designated in said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00004\" num=\"4\"><claim-text>4. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0010 01da ffff ffff, wherein the contents of said working register are added to an \u2018f\u2019 register in said register file, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00005\" num=\"5\"><claim-text>5. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0010 00da ffff ffff, wherein the contents of said working register are added both to a Carry Flag and to the contents of an \u2018f\u2019 register in said register file, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00006\" num=\"6\"><claim-text>6. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1011 kkkk kkkk, wherein the contents of said working register are AND'ed with an 8-bit literal \u2018k\u2019 designated by said kkkk kkkk portion of said instruction, a result of said instruction is placed in said working register.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00007\" num=\"7\"><claim-text>7. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0010 01da ffff ffff, wherein the contents of said working register are AND'ed with the contents of an \u2018f\u2019 register in said register file, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00008\" num=\"8\"><claim-text>8. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0010 nnnn nnnn, wherein if a Carry bit is set to \u20181\u2019 then a program written with said instruction set will branch to an offset location designated in said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 9, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00009\" num=\"9\"><claim-text>9. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1001 bbba ffff ffff, wherein wherein a bit \u2018b\u2019 in a register \u2018f\u2019 in said register file is cleared, said bit \u2018b\u2019 is designated by said bbb portion of said instruction, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 10, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00010\" num=\"10\"><claim-text>10. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0110 nnnn nnnn, wherein if a negative bit is set to 1, then a program composed from said instructions of said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 11, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00011\" num=\"11\"><claim-text>11. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0011 nnnn nnnn, wherein if a Carry bit is set to 0, then a program composed from said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 12, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00012\" num=\"12\"><claim-text>12. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0111 nnnn nnnn, wherein if a Negative bit is set to 0, then a program composed from said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 13, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00013\" num=\"13\"><claim-text>13. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0101 nnnn nnnn, wherein if an Overflow bit is set to 0, then a program composed from said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 14, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00014\" num=\"14\"><claim-text>14. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0001 nnnn nnnn, wherein if a Zero bit is set to 0, then a program composed from said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 15, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00015\" num=\"15\"><claim-text>15. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1101 0nnn nnnn nnnn, wherein a program composed from said instruction set will branch to an offset location designed in said nnn nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 16, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00016\" num=\"16\"><claim-text>16. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1000 bbba ffff ffff, wherein a bit \u2018b\u2019 in a register \u2018f\u2019 in said register file is set, the location of said register \u2018f\u2019 is designated by said ffff ffff portion of said instruction, said bit \u2018b\u2019 is designated by said bbb portion of said instruction, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 17, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00017\" num=\"17\"><claim-text>17. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1011 bbba ffff ffff, wherein if a bit \u2018b\u2019 in register \u2018f\u2019 in said register file is set to 0, then the next instruction in a program composed from said instruction set is skipped, said bit \u2018b\u2019 is designated in said bbb portion of said instruction, a location of said \u2018f\u2019 register is designated in said ffff ffff portion of said instruction, and said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 18, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00018\" num=\"18\"><claim-text>18. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1010 bbba ffff ffff, wherein if a bit \u2018b\u2019 in a register \u2018f\u2019 in said register file is set to 1, then the next instruction of a program composed from said instruction set is skipped, said bit \u2018b\u2019 is designated in said bbb portion of said instruction, a location for said register \u2018f\u2019 is designated in said ffff ffff portion of said instruction, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 19, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00019\" num=\"19\"><claim-text>19. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0111 bbba ffff ffff, wherein a bit \u2018b\u2019 in a said register file location \u2018f\u2019 is inverted, said location \u2018f\u2019 is designated by said ffff ffff portion of said instruction, said bit \u2018b\u2019 is designated by said bbb portion of said instruction, and said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 20, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00020\" num=\"20\"><claim-text>20. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0100 nnnn nnnn, wherein if an Overflow bit is set to 1, then a program composed from said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 21, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00021\" num=\"21\"><claim-text>21. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0000 nnnn nnnn, wherein if a Zero bit is set to 1, then a program composed from said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 22, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00022\" num=\"22\"><claim-text>22. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 110s kkkk kkkk 1111 kkkk kkkk kkkk, wherein said instruction is a subroutine call of an entire 2 mega byte memory range, said \u2018s\u2019 bit of said instruction is used to modify the behavior of said instruction, said memory range designated by said kkkk kkkk kkkk portions of said instruction.</claim-text></claim>"}, {"num": 23, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00023\" num=\"23\"><claim-text>23. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 101a ffff ffff, wherein said instruction clears the contents of the specified register in said register file designated by said ffff ffff portion of said instruction, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 24, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00024\" num=\"24\"><claim-text>24. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0100, wherein said instruction resets a Watchdog Timer.</claim-text></claim>"}, {"num": 25, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00025\" num=\"25\"><claim-text>25. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0001 11da ffff ffff, wherein the contents of a register \u2018f\u2019 in said register file are complemented, said register \u2018f\u2019 designated by said ffff ffff portion of said instruction, said \u2018d\u2019 bit of said instruction designates whether a result of said instruction is stored back in said register \u2018f\u2019, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 26, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00026\" num=\"26\"><claim-text>26. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 001a ffff ffff, wherein the contents of a register file location \u2018f\u2019 designated in said ffff ffff portion of said instruction is compared to the contents of said working register, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 27, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00027\" num=\"27\"><claim-text>27. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 010a ffff ffff, wherein the contents of a register file location \u2018f\u2019 designated by said ffff ffff portion of said memory are compared to the contents of said working register, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 28, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00028\" num=\"28\"><claim-text>28. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 000a ffff ffff, wherein the contents of a register file location \u2018f\u2019 are compared to the contents of said working register, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank , said ffff ffff portion of said instruction used to designate an address for said register file location \u2018f\u2019.</claim-text></claim>"}, {"num": 29, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00029\" num=\"29\"><claim-text>29. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0111, wherein said instruction adjusts an eight bit value in said working register to produce a correctly packed BCD result.</claim-text></claim>"}, {"num": 30, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00030\" num=\"30\"><claim-text>30. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0100 11da ffff ffff, wherein the contents of a register \u2018f\u2019 in said register file are decremented, a data memory location for said register \u2018f\u2019 is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 bit of said instruction determines the placement of a result of said instruction, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 31, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00031\" num=\"31\"><claim-text>31. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 01da ffff ffff, wherein the contents of a register \u2018f\u2019 in said register file are decremented, said ffff ffff portion of said instruction designate a location for said register \u2018f\u2019, said \u2018d\u2019 bit of said instruction indicates if a result of said instruction is stored in said register \u2018f\u2019, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 32, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00032\" num=\"32\"><claim-text>32. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0010 11da ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file are decremented, said \u2018d\u2019 bit of instruction directs whether a result of said instruction is placed within said working register, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank , said ffff ffff portion of said instruction designating a memory location in said memory bank.</claim-text></claim>"}, {"num": 33, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00033\" num=\"33\"><claim-text>33. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 1111 kkkk kkkk 1111 kkkk kkkk kkkk, wherein wherein said instruction provides an unconditional branch for a program composed from said instruction set anywhere within a 2 megabyte memory range designated by said kkkk kkkk kkkk portions of said instruction.</claim-text></claim>"}, {"num": 34, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00034\" num=\"34\"><claim-text>34. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0001, wherein the execution of a program composed from said instruction set is halted.</claim-text></claim>"}, {"num": 35, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00035\" num=\"35\"><claim-text>35. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0010 10da ffff ffff, wherein the contents of a register \u2018f\u2019 in said register file are incremented, a data memory location for said register \u2018f\u2019 is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 bit of said instruction determines the placement of a result of said instruction, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 36, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00036\" num=\"36\"><claim-text>36. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0011 11da ffff ffff, wherein the contents of a register \u2018f\u2019, in said register file are incremented, a data memory location for said register \u2018f\u2019 is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 bit of said instruction determines the placement of a result of said instruction, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank , if said result of said instruction is 0, then the next instruction of a program composed from said instruction set will be discarded and a NOP instruction will be executed in place of said discarded instruction.</claim-text></claim>"}, {"num": 37, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00037\" num=\"37\"><claim-text>37. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0100 10da ffff ffff, wherein the contents of a register \u2018f\u2019 in said register file are incremented, a data memory location for said register \u2018f\u2019 is designated by said ffff ffff portion of said instruction, if said \u2018d\u2019 bit of said instruction is set to 1 then a result of said instruction is placed in said \u2018f\u2019 register, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank , if said result of said instruction is 0, then the next instruction of a program composed from said instruction set will be discarded and a NOP instruction will be executed in place of said discarded instruction.</claim-text></claim>"}, {"num": 38, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00038\" num=\"38\"><claim-text>38. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1001 kkkk kkkk, wherein the contents of said working register are OR'ed with an eight bit literal \u2018k\u2019, the location of said eight bit literal \u2018k\u2019 is designated in said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 39, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00039\" num=\"39\"><claim-text>39. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0001 00da ffff ffff, wherein said instruction performs an inclusive OR with said working register and an \u2018f\u2019 register in said register file, a data memory location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, if said \u2018d\u2019 bit of said instruction is set to 0 then a result of said instruction is placed back in said \u2018f\u2019 register, said \u2018a\u2019 indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 40, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00040\" num=\"40\"><claim-text>40. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 1110 00ff kkkk 1111 0000 kkkk kkkk, wherein a 12-bit literal \u2018k\u2019 is loaded into a file select register in said register file pointed to by said ff portion of said instruction, said 12-bit literal \u2018k\u2019 is encoded within said kkkk kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 41, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00041\" num=\"41\"><claim-text>41. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0101 00da ffff ffff, wherein the contents of a register \u2018f\u2019 in said register file are moved to a destination dependent upon a status of said \u2018d\u2019 bit of said instruction, if said \u2018d\u2019 bit is set to 0 then a result of said instruction is placed into said working register, if said \u2018d\u2019 bit is set to 1 then said result is placed back in said register \u2018f\u2019, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 42, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00042\" num=\"42\"><claim-text>42. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1100 ffff ffff ffff 1111 gggg gggg gggg, wherein the contents of a source memory location \u2018f\u2019 within said memory are moved to a destination memory location \u2018g\u2019 within said memory, a location of said source memory location \u2018f\u2019 can be anywhere in a 4096 byte data space and a location of said destination memory location \u2018g\u2019 can be anywhere within said data space.</claim-text></claim>"}, {"num": 43, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00043\" num=\"43\"><claim-text>43. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0001 kkkk kkkk, wherein an 8-bit literal \u2018k\u2019 is loaded into a Bank Select Register (BSR), said 8-bit literal \u2018k\u2019 is encoded within said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 44, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00044\" num=\"44\"><claim-text>44. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1110 kkkk kkkk, wherein an eight bit literal \u2018k\u2019 is loaded into said working register, said eight bit literal \u2018k\u2019 is encoded within said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 45, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00045\" num=\"45\"><claim-text>45. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1101 kkkk kkkk, wherein said instruction implements an unsigned multiplication between the contents of said working register and an 8-bit literal \u2018k\u2019, an address for said literal \u2018k\u2019 is contained within said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 46, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00046\" num=\"46\"><claim-text>46. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 001a ffff ffff, wherein said instruction implements an unsigned multiplication between the contents of said working register and a register file location \u2018f\u2019 in said register file, said address of said file location \u2018f\u2019 is contained within said ffff ffff portion of said instruction, said \u2018a\u2019 indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 47, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00047\" num=\"47\"><claim-text>47. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 110a ffff ffff, wherein said instruction negates the contents of an \u2018f\u2019 register in said register file whose address is designated by said ffff ffff portion of said instruction, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 48, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00048\" num=\"48\"><claim-text>48. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0000 1111 xxxx xxxx xxxx, wherein said instruction performs no operation, and the contents of said xxxx xxxx xxxx portion of said instruction are ignored.</claim-text></claim>"}, {"num": 49, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00049\" num=\"49\"><claim-text>49. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0110, wherein a top of stack (TOS) values is pulled of of a return stack and is discarded.</claim-text></claim>"}, {"num": 50, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00050\" num=\"50\"><claim-text>50. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0101, wherein a value equivalent to a program counter register plus two is pushed onto a top of a return stack.</claim-text></claim>"}, {"num": 51, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00051\" num=\"51\"><claim-text>51. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 1101 1nnn nnnn nnnn, wherein said instruction implements a subroutine call to a subroutine that is up to 1K from a current location within a program composed from said instruction set, said nnn nnnn nnnn portion of said instruction designates an offsetaddress to said subroutine.</claim-text></claim>"}, {"num": 52, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00052\" num=\"52\"><claim-text>52. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 1111 1111, wherein said instruction provides a way to execute a MCLR resent in software.</claim-text></claim>"}, {"num": 53, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00053\" num=\"53\"><claim-text>53. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0001 000s, wherein said instruction returns from an interrupt, said \u2018s\u2019 portion of said instruction manipulates the contents of a shadow register.</claim-text></claim>"}, {"num": 54, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00054\" num=\"54\"><claim-text>54. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0011 01da ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file are rotated one bit to the left through a Carry flag, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 55, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00055\" num=\"55\"><claim-text>55. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0100 01da ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file are rotated one bit to the left, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 56, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00056\" num=\"56\"><claim-text>56. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0011 00da ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file are rotated one bit to the right through a Carry flag, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 57, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00057\" num=\"57\"><claim-text>57. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0100 00da ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file are rotated one bit to the right, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 58, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00058\" num=\"58\"><claim-text>58. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 100a ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file are set to FFh, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 59, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00059\" num=\"59\"><claim-text>59. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0011, wherein a power-down status bit is cleared, a time-out status bit is set, and a Watchdog Timer and a postscaler are cleared.</claim-text></claim>"}, {"num": 60, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00060\" num=\"60\"><claim-text>60. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0101 01da ffff ffff, wherein the sum of an \u2018f\u2019 register in said register file and a carry flag are subtracted from said working register, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 61, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00061\" num=\"61\"><claim-text>61. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1000 kkkk kkkk, wherein the contents of said working register are subtracted form an eight bit literal \u2018k\u2019 and a result of said instruction is placed in said working register, a location for said literal \u2018k\u2019 is contained within said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 62, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00062\" num=\"62\"><claim-text>62. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0101 11da ffff ffff, wherein the contents of said working register are subtracted from an \u2018f\u2019 register in said register file, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 63, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00063\" num=\"63\"><claim-text>63. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0101 10da ffff ffff, wherein the sum of the contents of said working register and a carry flag are subtracted from an \u2018f\u2019 register in said register file, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 64, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00064\" num=\"64\"><claim-text>64. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0011 10da ffff ffff, wherein an upper nibble of an \u2018f\u2019 register in said register file is exchanged with a lower nibble of said \u2018f\u2019 register, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 65, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00065\" num=\"65\"><claim-text>65. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 10nn, wherein said nn portion of said instruction is a member selected from the group consisting of 00, 01, 10, or 11 that corresponds to a disposition of no change, post-increment, post-decrement, and pre-increment, respectively; said nn portion of said instruction used to determine the disposition of a 21-bit table pointer, the contents of a program memory location pointed to by said table pointer are loaded into an 8-bit table latch.</claim-text></claim>"}, {"num": 66, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00066\" num=\"66\"><claim-text>66. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 11nn, wherein said nn portion of said instruction is a member selected from the group consisting of 00, 01, 10, or 11 that corresponds to a disposition of no change, post-increment, post-decrement, and pre-increment, respectively; said nn portion of said instruction used to determine the disposition of a 21-bit table pointer, the contents of a table latch are written to a program memory location pointed to by said table pointer.</claim-text></claim>"}, {"num": 67, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00067\" num=\"67\"><claim-text>67. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 1110 0000, wherein said instruction is a debugger trap to 00028h.</claim-text></claim>"}, {"num": 68, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00068\" num=\"68\"><claim-text>68. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 1110 0001, wherein said instruction is a return from a debugger trap.</claim-text></claim>"}, {"num": 69, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00069\" num=\"69\"><claim-text>69. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 011a ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file is checked to determine if its value is equal to 0, a location of said \u2018f\u2019 register being designated by said ffff ffff portion of said instruction, if said value of \u2018f\u2019 register is equal to 0, then a next instruction is discarded and a NOP instruction is executed, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 70, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00070\" num=\"70\"><claim-text>70. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1010 kkkk kkkk, wherein the contents of said working register are XOR'ed with an 8-bit literal \u2018k\u2019 and a result of said instruction is placed into said working register, a location for said literal \u2018k\u2019 is designated in said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 71, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00071\" num=\"71\"><claim-text>71. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref> wherein said instruction set includes an instruction with an encoding of 0001 10da ffff ffff, wherein the contents of said working register are XOR'ed with the contents of an \u2018f\u2019 register in said register file, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit indicating whether said bank select unit accesses one of said banks or said virtual bank.</claim-text></claim>"}, {"num": 72, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00072\" num=\"72\"><claim-text>72. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1111 kkkk kkkk, wherein the contents of said working register are added to an 8-bit literal \u2018k\u2019 and the result is placed in said working register, said literal \u2018k\u2019 is designated in said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 73, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00073\" num=\"73\"><claim-text>73. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0010 01da ffff ffff, wherein the contents of said working register are added to an \u2018f\u2019 register in said register file, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 74, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00074\" num=\"74\"><claim-text>74. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0010 00da ffff ffff, wherein the contents of said working register are added both to a Carry Flag and to the contents of an \u2018f\u2019 register in said register file, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 75, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00075\" num=\"75\"><claim-text>75. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1011 kkkk kkkk, wherein the contents of said working register are AND'ed with an 8-bit literal \u2018k\u2019 designated by said kkkk kkkk portion of said instruction, a result of said instruction is placed in said working register.</claim-text></claim>"}, {"num": 76, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00076\" num=\"76\"><claim-text>76. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0010 01da ffff ffff, wherein the contents of said working register are AND'ed with the contents of an \u2018f\u2019 register in said register file, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 77, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00077\" num=\"77\"><claim-text>77. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0010 nnnn nnnn, wherein if a Carry bit is set to \u20181\u2019 then a program written with said instruction set will branch to an offset location designated in said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 78, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00078\" num=\"78\"><claim-text>78. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1001 bbba ffff ffff, wherein a bit \u2018b\u2019 in a register \u2018f\u2019 in said register file is cleared, said bit \u2018b\u2019 is designated by said bbb portion of said instruction, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 79, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00079\" num=\"79\"><claim-text>79. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0110 nnnn nnnn, wherein if a negative bit is set to 1, then a program composed from said instructions of said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 80, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00080\" num=\"80\"><claim-text>80. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0011 nnnn nnnn, wherein if a Carry bit is set to 0, then a program composed from said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 81, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00081\" num=\"81\"><claim-text>81. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0111 nnnn nnnn, wherein if a Negative bit is set to 0, then a program composed from said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 82, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00082\" num=\"82\"><claim-text>82. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0101 nnnn nnnn, wherein if an Overflow bit is set to 0, then a program composed from said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 83, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00083\" num=\"83\"><claim-text>83. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0001nnnn nnnn, wherein if a Zero bit is set to 0, then a program composed from said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 84, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00084\" num=\"84\"><claim-text>84. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1101 0nnn nnnn nnnn, wherein a program composed from said instruction set will branch to an offset location designed in said nnn nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 85, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00085\" num=\"85\"><claim-text>85. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1000 bbba ffff ffff, wherein a bit \u2018b\u2019 in a register \u2018f\u2019 in said register file is set, the location of said register \u2018f\u2019 is designated by said ffff ffff portion of said instruction, said bit \u2018b\u2019 is designated by said bbb portion of said instruction, said \u2018a\u2019 bit of said instruction is used to designate a memory bank.</claim-text></claim>"}, {"num": 86, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00086\" num=\"86\"><claim-text>86. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1011 bbba ffff ffff, wherein if a bit \u2018b\u2019 in register \u2018f\u2019 in said register file is set to 0, then the next instruction in a program composed from said instruction set is skipped, said bit \u2018b\u2019 is designated in said bbb portion of said instruction, a location of said \u2018f\u2019 register is designated in said ffff ffff portion of said instruction, and said \u2018a\u2019 bit of said instruction designates a memory bank.</claim-text></claim>"}, {"num": 87, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00087\" num=\"87\"><claim-text>87. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1010 bbba ffff ffff, wherein if a bit \u2018b\u2019 in a register \u2018f\u2019 in said register file is set to 1, then the next instruction of a program composed from said instruction set is skipped, said bit \u2018b\u2019 is designated in said bbb portion of said instruction, a location for said register \u2018f\u2019 is designated in said ffff ffff portion of said instruction, said \u2018a\u2019 bit in said instruction is used to designated a memory bank.</claim-text></claim>"}, {"num": 88, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00088\" num=\"88\"><claim-text>88. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0111 bbba ffff ffff, wherein a bit \u2018b\u2019 in a register file location \u2018f\u2019 is inverted, said location \u2018f\u2019 is designated by said ffff ffff portion of said instruction, said bit \u2018b\u2019 is designated by said bbb portion of said instruction, and said \u2018a\u2019 bit of said instruction designates a memory bank.</claim-text></claim>"}, {"num": 89, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00089\" num=\"89\"><claim-text>89. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0100 nnnn nnnn, wherein if an Overflow bit is set to 1, then a program composed from said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 90, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00090\" num=\"90\"><claim-text>90. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 0000 nnnn nnnn, wherein if a Zero bit is set to 1, then a program composed from said instruction set will branch to an offset location designated by said nnnn nnnn portion of said instruction.</claim-text></claim>"}, {"num": 91, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00091\" num=\"91\"><claim-text>91. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 10s kkkk kkkk 1111 kkkk kkkk kkkk, wherein said instruction is a subroutine call of an entire 2 mega byte memory range, said \u2018s\u2019 bit of said instruction is used to modify the behavior of said instruction, said memory range designated by said kkkk kkkk kkkk portions of said instruction.</claim-text></claim>"}, {"num": 92, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00092\" num=\"92\"><claim-text>92. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 101a ffff ffff, wherein said instruction clears the contents of the specified register in said register file designated by said ffff ffff portion of said instruction, said \u2018a\u2019 bit of said instruction used to modify the behavior of said instruction.</claim-text></claim>"}, {"num": 93, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00093\" num=\"93\"><claim-text>93. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0100, wherein said instruction resets a Watchdog Timer.</claim-text></claim>"}, {"num": 94, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00094\" num=\"94\"><claim-text>94. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0001 11da ffff ffff, wherein the contents of a register \u2018f\u2019 in said register file are complemented, said register \u2018f\u2019 designated by said ffff ffff portion of said instruction, said \u2018d\u2019 bit of said instruction designates whether a result of said instruction is stored back in said register \u2018f\u2019, said \u2018a\u2019 bit of said instruction is used to designated a memory bank.</claim-text></claim>"}, {"num": 95, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00095\" num=\"95\"><claim-text>95. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 001a ffff ffff, wherein the contents of a register file location \u2018f\u2019 designated in said ffff ffff portion of said instruction is compared to the contents of said working register, said \u2018a\u2019 bit of said instruction is used to designate a memory bank.</claim-text></claim>"}, {"num": 96, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00096\" num=\"96\"><claim-text>96. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 010a ffff ffff, wherein the contents of a register file location \u2018f\u2019 designated by said ffff ffff portion of said memory are compared to the contents of said working register, said \u2018a\u2019 bit of said instruction is used to designate a memory bank.</claim-text></claim>"}, {"num": 97, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00097\" num=\"97\"><claim-text>97. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 000a ffff ffff, wherein the contents of a register file location \u2018f\u2019 are compared to the contents of said working register, said \u2018a\u2019 bit of said instruction used to designated a memory bank, said ffff ffff portion of said instruction used to designate an address for said data memory location \u2018f\u2019.</claim-text></claim>"}, {"num": 98, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00098\" num=\"98\"><claim-text>98. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0111, wherein said instruction adjusts an eight bit value in said working register to produce a correctly packed BCD result.</claim-text></claim>"}, {"num": 99, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00099\" num=\"99\"><claim-text>99. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0100 11da ffff ffff, wherein the contents of a register \u2018f\u2019 in said register file are decremented, a data memory location for said register \u2018f\u2019 is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 bit of said instruction determines the placement of a result of said instruction, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 100, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00100\" num=\"100\"><claim-text>100. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 01da ffff ffff, wherein the contents of a register \u2018f\u2019 in said register file are decremented, said ffff ffff portion of said instruction designate a location for said register \u2018f\u2019, said \u2018d\u2019 bit of said instruction indicates if a result of said instruction is stored in said register \u2018f\u2019, said \u2018a\u2019 bit of said instruction indicates how a memory bank is selected.</claim-text></claim>"}, {"num": 101, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00101\" num=\"101\"><claim-text>101. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0010 11da ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file are decremented, said \u2018d\u2019 bit of instruction directs whether a result of said instruction is placed within said working register, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected, said ffff ffff portion of said instruction designating a memory location in said memory bank.</claim-text></claim>"}, {"num": 102, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00102\" num=\"102\"><claim-text>102. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 1111 kkkk kkkk 1111 kkkk kkkk kkkk, wherein wherein said instruction provides an unconditional branch for a program composed from said instruction set anywhere within a 2 megabyte memory range designated by said kkkk kkkk kkkk portions of said instruction.</claim-text></claim>"}, {"num": 103, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00103\" num=\"103\"><claim-text>103. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0001, wherein the execution of a program composed from said instruction set is halted.</claim-text></claim>"}, {"num": 104, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00104\" num=\"104\"><claim-text>104. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0010 10da ffff ffff, wherein the contents of a register \u2018f\u2019 in said register file are incremented, a data memory location for said register \u2018f\u2019 is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 bit of said instruction determines the placement of a result of said instruction, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 105, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00105\" num=\"105\"><claim-text>105. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0011 11da ffff ffff, wherein the contents of a register \u2018f\u2019 in said register file are incremented, a data memory location for said register \u2018f\u2019 is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 bit of said instruction determines the placement of a result of said instruction, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected, if said result of said instruction is 0, then the next instruction of a program composed from said instruction set will be discarded and a NOP instruction will be executed in place of said discarded instruction.</claim-text></claim>"}, {"num": 106, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00106\" num=\"106\"><claim-text>106. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0100 10da ffff ffff, wherein the contents of a register \u2018f\u2019 in said register file are incremented, a data memory location for said register \u2018f\u2019 is designated by said ffff ffff portion of said instruction, if said \u2018d\u2019 bit of said instruction is set to 1 then a result of said instruction is placed in said \u2018f\u2019 register, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected, if said result of said instruction is 0, then the next instruction of a program composed from said instruction set will be discarded and a NOP instruction will be executed in place of said discarded instruction.</claim-text></claim>"}, {"num": 107, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00107\" num=\"107\"><claim-text>107. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1001 kkkk kkkk, wherein the contents of said working register are OR'ed with an eight bit literal \u2018k\u2019, the location of said eight bit literal \u2018k\u2019 is designated in said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 108, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00108\" num=\"108\"><claim-text>108. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0001 00da ffff ffff, wherein said instruction performs an inclusive OR with said working register and an \u2018f\u2019 register in said register file, a data memory location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, if said \u2018d\u2019 bit of said instruction is set to 0 then a result of said instruction is placed back in said \u2018f\u2019 register, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 109, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00109\" num=\"109\"><claim-text>109. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1110 1110 00ff kkkk 1111 0000 kkkk kkkk, wherein a 12-bit literal \u2018k\u2019 is loaded into a file select register in said register file pointed to by said ff portion of said instruction, said 12-bit literal \u2018k\u2019 is encoded within said kkkk kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 110, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00110\" num=\"110\"><claim-text>110. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0101 00da ffff ffff, wherein the contents of a register \u2018f\u2019 in said register file are moved to a destination dependent upon a status of said \u2018d\u2019 bit of said instruction, if said \u2018d\u2019 bit is set to 0 then a result of said instruction is placed into said working register, if said \u2018d\u2019 bit is set to 1 then said result is placed back in said register \u2018f\u2019, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 111, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00111\" num=\"111\"><claim-text>111. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1100 ffff ffff ffff 1111 gggg gggg gggg, wherein the contents of a source memory location \u2018f\u2019 are moved to a destination memory location \u2018g\u2019, a location of said source \u2018f\u2019 can be anywhere in a 4096 byte data space and a location of said destination \u2018g\u2019 can be anywhere within said data space.</claim-text></claim>"}, {"num": 112, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00112\" num=\"112\"><claim-text>112. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0001 kkkk kkkk, wherein an 8-bit literal \u2018k\u2019 is loaded into a Bank Select Register (BSR), said 8-bit literal \u2018k\u2019 is encoded within said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 113, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00113\" num=\"113\"><claim-text>113. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1110 kkkk kkkk, wherein an eight bit literal \u2018k\u2019 is loaded into said working register, said eight bit literal \u2018k\u2019 is encoded within said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 114, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00114\" num=\"114\"><claim-text>114. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1101 kkkk kkkk, wherein said instruction implements an unsigned multiplication between the contents of said working register and an 8-bit literal \u2018k\u2019, an address for said literal \u2018k\u2019 is contained within said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 115, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00115\" num=\"115\"><claim-text>115. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 001a ffff ffff, wherein said instruction implements an unsigned multiplication between the contents said working register and a register file location \u2018f\u2019 in said register file, said address of said file location \u2018f\u2019 is contained within said ffff ffff portion of said instruction, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 116, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00116\" num=\"116\"><claim-text>116. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 1100a ffff ffff, wherein said instruction negates the contents of an \u2018f\u2019 register in said register file whose address is designated by said ffff ffff portion of said instruction, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 117, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00117\" num=\"117\"><claim-text>117. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0000 1111 xxxx xxxx xxxx, wherein said instruction performs no operation, and the contents of said xxxx xxxx xxxx portion of said instruction are ignored.</claim-text></claim>"}, {"num": 118, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00118\" num=\"118\"><claim-text>118. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0110, wherein a top of stack (TOS) values is pulled of of a return stack and is discarded.</claim-text></claim>"}, {"num": 119, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00119\" num=\"119\"><claim-text>119. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0101, wherein a value equivalent to a program counter register plus two is pushed onto a top of a return stack.</claim-text></claim>"}, {"num": 120, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00120\" num=\"120\"><claim-text>120. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 1101 1nnn nnnn nnnn, wherein said instruction implements a subroutine call to a subroutine that is up to 1K from a current location within a program composed from said instruction set, said nnn nnnn nnnn portion of said instruction designates an offset address to said subroutine.</claim-text></claim>"}, {"num": 121, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00121\" num=\"121\"><claim-text>121. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 1111 1111, wherein said instruction provides a way to execute a MCLR resent in software.</claim-text></claim>"}, {"num": 122, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00122\" num=\"122\"><claim-text>122. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0001 000s, wherein said instruction returns from an interrupt, said \u2018s\u2019 portion of said instruction manipulates the contents of a shadow register.</claim-text></claim>"}, {"num": 123, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00123\" num=\"123\"><claim-text>123. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0011 01da ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file are rotated one bit to the left through a Carry flag, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 124, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00124\" num=\"124\"><claim-text>124. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0100 Olda ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file are rotated one bit to the left, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 125, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00125\" num=\"125\"><claim-text>125. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0011 00da ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file are rotated one bit to the right through a Carry flag, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 126, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00126\" num=\"126\"><claim-text>126. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0100 00da ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file are rotated one bit to the right, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 127, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00127\" num=\"127\"><claim-text>127. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 100a ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file are set to FFh, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 128, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00128\" num=\"128\"><claim-text>128. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 0011, wherein a power-down status bit is cleared, a time-out status bit is set, and a Watchdog Timer and a postscaler are cleared.</claim-text></claim>"}, {"num": 129, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00129\" num=\"129\"><claim-text>129. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0101 01da ffff ffff, wherein the sum of an \u2018f\u2019 register in said register file and a carry flag are subtracted from said working register, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 130, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00130\" num=\"130\"><claim-text>130. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1000 kkkk kkkk, wherein the contents of said working register are subtracted form an eight bit literal \u2018k\u2019 and a result of said instruction is placed in said working register, a location for said literal \u2018k\u2019 is contained within said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 131, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00131\" num=\"131\"><claim-text>131. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0101 11da ffff ffff, wherein the contents of said working register are subtracted from an \u2018f\u2019 register in said register file, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 132, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00132\" num=\"132\"><claim-text>132. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0101 10da ffff ffff, wherein the sum of the contents of said working register and a carry flag are subtracted from an \u2018f\u2019 register in said register file, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 133, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00133\" num=\"133\"><claim-text>133. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0011 10da ffff ffff, wherein an upper nibble of an \u2018f\u2019 register is exchanged with a lower nibble of said \u2018f\u2019 register in said register file, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 134, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00134\" num=\"134\"><claim-text>134. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 10nn, wherein said nn portion of said instruction is a member selected from the group consisting of 00, 01, 10, or 11 that corresponds to a disposition of no change, post-increment, post-decrement, and pre-increment, respectively; said nn portion of said instruction used to determine the disposition of a 21-bit table pointer, the contents of a program memory location pointed to by said table pointer are loaded into an 8-bit table latch.</claim-text></claim>"}, {"num": 135, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00135\" num=\"135\"><claim-text>135. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 0000 11nn, wherein said nn portion of said instruction is a member selected from the group consisting of 00, 01, 10, or 11 that corresponds to a disposition of no change, post-increment, post-decrement, and pre-increment, respectively; said nn portion of said instruction used to determine the disposition of a 21-bit table pointer, the contents of a table latch are written to a program memory location pointed to by said table pointer.</claim-text></claim>"}, {"num": 136, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00136\" num=\"136\"><claim-text>136. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 1110 0000, wherein said instruction is a debugger trap to 00028h.</claim-text></claim>"}, {"num": 137, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00137\" num=\"137\"><claim-text>137. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 0000 1110 0001, wherein said instruction is a return from a debugger trap.</claim-text></claim>"}, {"num": 138, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00138\" num=\"138\"><claim-text>138. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0110 011a ffff ffff, wherein the contents of an \u2018f\u2019 register in said register file is checked to determine if its value is equal to 0, a location of said \u2018f\u2019 register being designated by said ffff ffff portion of said instruction, if said value of \u2018f\u2019 register is equal to 0, then a next instruction is discarded and a NOP instruction is executed, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 139, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00139\" num=\"139\"><claim-text>139. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0000 1010 kkkk kkkk, wherein the contents of said working register are XOR'ed with an 8-bit literal \u2018k\u2019 and a result of said instruction is placed into said working register, a location for said literal \u2018k\u2019 is designated in said kkkk kkkk portion of said instruction.</claim-text></claim>"}, {"num": 140, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00140\" num=\"140\"><claim-text>140. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00002\">claim 2</claim-ref> wherein said instruction set includes an instruction with an encoding of 0001 10da ffff ffff, wherein the contents of said working register are XOR'ed with the contents of an \u2018f\u2019 register in said register file, a location for said \u2018f\u2019 register is designated by said ffff ffff portion of said instruction, said \u2018d\u2019 portion of said instruction designates a location to which a result of said instruction is sent, said \u2018a\u2019 bit of said instruction affects which of a plurality of memory banks is selected.</claim-text></claim>"}, {"num": 141, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00141\" num=\"141\"><claim-text>141. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00001\">claim 1</claim-ref>, wherein said virtual bank consists of the lower half of a first bank and the upper half of a second band within said data memory.</claim-text></claim>"}, {"num": 142, "parent": 141, "type": "dependent", "paragraph_markup": "<claim id=\"US-6708268-B1-CLM-00142\" num=\"142\"><claim-text>142. A microcontroller as in <claim-ref idref=\"US-6708268-B1-CLM-00141\">claim 141</claim-ref>, wherein said first bank is the first bank within said data memory and said second bank is the last bank within said data memory.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54147887\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><h4>CROSS REFERENCE TO RELATED APPLICATION</h4><p>This application is related to the following applications: U.S. Pat. No. 6,055,211 for \u201cFORCE PAGE ZERO PAGING SCHEME FOR MICROCONTROLLERS USING DATA ACCESS MEMORY\u201d by Randy L. Yach, et al.; U.S. Pat. No. 5,905,880 for \u201cROBUST MULTIPLE WORK INSTRUCTION AND METHOD THEREFOR\u201d by Rodney J. Drake, et al.; U.S. Pat. No. 6,192,463. B1 for \u201cPROCESSOR ARCHITECTURE SCHEME FOR IMPLEMENTING VARIOUS ADDRESSING MODES AND METHOD THEREFOR\u201d by Sumit Mitra, et al.; U.S. application Ser. No. 08/958,940 for \u201cA SYSTEM FOR ALLOWING A TWO WORD INSTRUCTION TO BE EXECUTED IN A SINGLE CYCLE AND METHOD THEREFOR\u201d on Oct. 28, 1998 by Rodney J. Drake, et al.; U.S. Pat. No. 6,029,241 entitled \u201cPROCESSOR ARCHITECTURE SCHEME HAVING MULTIPLE SOURCE FOR SUPPLYING BANK ADDRESS VALUES AND METHOD THEREFORE\u201d by Igor Wojewoda, Sumit Mitra, and Rodney J. Drake; U.S. Pat. No. 6,098,160 for \u201cDATA POINTER FOR OUTPUTTING INDIRECT ADDRESSING MODE ADDRESSES WITHIN A SINGLE CYCLE AND METHOD THEREFOR\u201d by Rodney J. Drake, et al.; U.S. Pat. No. 5,958,039 for \u201cPRE-DECODED STACK POINTER WITH POST INCREMENT/DECREMENT OPERATION\u201d by Allen, et al.; and U.S. Pat. No. 5,987,583 for \u201cPROCESSOR ARCHITECTURE SCHEME AND INSTRUCTION SET FOR MAXIMIZING AVAILABLE OPCODES AND FOR IMPLEMENTING VARIOUS ADDRESSING MODES\u201d by Triece, et al. which are hereby incorporated herein by reference for all purposes.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><h4>FIELD OF THE INVENTION</h4><p>The present invention relates to microcontrollers and, more specifically, the present invention relates to opcode instructions that are gathered into an instruction set which are used to manipulate the behavior of the microcontroller.</p><h4>DESCRIPTION OF THE RELATED TECHNOLOGY</h4><p>Microcontroller units (MCU) have been used in the manufacturing and electrical industries for many years. FIG. 1 shows a typical core memory bus arrangement for mid-range MCU devices. In many cases, microcontrollers utilize reduced instruction set computing (RISC) microprocessors. The high performance of some of these devices can be attributed to a number of architectural features commonly found in RISC microprocessors. These features include:</p><p>Harvard architecture</p><p>Long Word Instructions</p><p>Single Word Instructions</p><p>Single Cycle Instructions</p><p>Instruction Pipelining</p><p>Reduced Instruction Set</p><p>Register File Architecture</p><p>Orthogonal (Symmetric) Instructions</p><p>Harvard Architecture:</p><p>As shown in FIG. 2, the Harvard architecture has the program memory <b>26</b> and data memory <b>22</b> as separate memories and are accessed by the CPU <b>24</b> from separate buses. This improves bandwidth over traditional von Neumann architecture (shown in FIG. 3) in which program and data are fetched by the CPU <b>34</b> from the same memory <b>36</b> using the same bus. To execute an instruction, a von Neumann machine must make one or more (generally more) accesses across the 8-bit bus to fetch the instruction. Then data may need to be fetched, operated on, and possibly written. As can be seen from this description, that bus can become extremely conjested.</p><p>In contrast to the von Neumann machine, under the Harvard architecture, all 14 bits of the instruction are fetched in a single instruction cycle. Thus, under the Harvard architecture, while the program memory is being accessed, the data memory is on an independent bus and can be read and written. These separated buses allow one instruction to execute while the next instruction is being fetched.</p><p>Long Word Instructions:</p><p>Long word instructions have a wider (more bits) instruction bus than the 8-bit Data Memory Bus. This is possible because the two buses are separate. This further allows instructions to be sized differently than the 8-bit wide data word which allows a more efficient use of the program memory, since the program memory width is optimized to the architectural requirements.</p><p>Single Word Instructions:</p><p>Single Word instruction opcodes are 14-bits wide making it possible to have all single word instructions. A 14-bit wide program memory access bus fetches a 14-bit instruction in a single cycle. With single word instructions, the number of words of program memory locations equals the number of instructions for the device. This means that all locations are valid instructions. Typically in the von Neumann architecture (shown in FIG. <b>3</b>), most instructions are multi-byte. In general however, a device with 4-KBytes of program memory would allow approximately 2K of instructions. This 2:1 ratio is generalized and dependent on the application code. Since each instruction may take multiple bytes, there is no assurance that each location is a valid instruction.</p><p>Instruction Pipeline:</p><p>The instruction pipeline is a two-stage pipeline which overlaps the fetch and execution of instructions. The fetch of the instruction takes one machine cycle (TCY), while the execution takes another TCY. However, due to the overlap of the fetch of current instruction and execution of previous instruction, an instruction is fetched and another instruction is executed every single TCY.</p><p>Single Cycle Instructions:</p><p>With the Program Memory bus being 14-bits wide, the entire instruction is fetched in a single TCY. The instruction contains all the information required and is executed in a single cycle. There may be a one-cycle delay in execution if the result of the instruction modified the contents of the Program Counter. This requires that the pipeline be flushed and a new instruction fetched.</p><p>Reduced Instruction Set:</p><p>When an instruction set is well designed and highly orthogonal (symmetric), fewer instructions are required to perform all needed tasks. With fewer instructions, the whole set can be more rapidly learned.</p><p>Register File Architecture:</p><p>The register files/data memory can be directly or indirectly addressed. All special function registers, including the program counter, are mapped in the data memory.</p><p>Orthogonal (Symmetric) Instructions:</p><p>Orthogonal instructions make it possible to carry out any operation on any register using any addressing mode. This symmetrical nature and lack of \u201cspecial instructions\u201d make programming simple yet efficient. In addition, the leaming curve is reduced significantly. The mid-range instruction set uses only two non-register oriented instructions, which are used for two of the cores features. One is the SLEEP instruction that places the device into the lowest power use mode. The other is the CLRWDT instruction which verifies the chip is operating properly by preventing the on-chip Watchdog Timer (WDT) from overflowing and resetting the device.</p><p>Clocking Scheme/Instruction Cycle:</p><p>The clock input (from OSC<b>1</b>) is internally divided by four to generate four non-overlapping quadrature clocks, namely Q<b>1</b>, Q<b>2</b>, Q<b>3</b>, and Q<b>4</b>. Internally, the program counter (PC) is incremented every Q<b>1</b>, and the instruction is fetched from the program memory and latched into the instruction register in Q<b>4</b>. The instruction is decoded and executed during the following Q<b>1</b> through Q<b>4</b>. The clocks and instruction execution flow are illustrated in FIGS. 4 and 5.</p><p>Instruction Flow/Pipelining:</p><p>An \u201cInstruction Cycle\u201d consists of four Q cycles (Q<b>1</b>, Q<b>2</b>, Q<b>3</b>, and Q<b>4</b>) as shown in FIGS. 4 that comprise the TCY as shown in FIGS. 4 and 5. Note that in FIG. 5, all instructions are performed in a single cycle, except for any program branches. Program branches take two cycles because the fetch instruction is \u201cflushed\u201d from the pipeline while the new instruction is being fetched and then executed.</p><p>Fetch takes one instruction cycle while decode and execute takes another instruction cycle. However, due to Pipelining, each instruction effectively executes in one cycle. If an instruction causes the program counter to change (e.g. GOTO) then an extra cycle is required to complete the instruction (FIG. <b>5</b>). The instruction fetch begins with the program counter incrementing in Q<b>1</b>. In the execution cycle, the fetched instruction is latched into the \u201cInstruction Register (IR)\u201d in cycle Q<b>1</b>. This instruction is then decoded and executed during the Q<b>2</b>, Q<b>3</b>, and Q<b>4</b> cycles. Data memory is read during Q<b>2</b> (operand read) and written during Q<b>4</b> (destination write). FIG. 5 shows the operation of the two-stage pipeline for the instruction sequence shown. At time TCY<b>0</b>, the first instruction is fetched from program memory. During TCY<b>1</b>, the first instruction executes while the second instruction is fetched. During TCY<b>2</b>, the second instruction executes while the third instruction is fetched. During TCY<b>3</b>, the fourth instruction is fetched while the third instruction (CALL SUB_<b>1</b>) is executed. When the third instruction completes execution, the CPU forces the address of instruction four onto the Stack and then changes the Program Counter (PC) to the address of SUB_<b>1</b>. This means that the instruction that was fetched during TCY<b>3</b> needs to be \u201cflushed\u201d from the pipeline. During TCY<b>4</b>, instruction four is flushed (executed as a NOP) and the instruction at address SUB_<b>1</b> is fetched. Finally during TCY<b>5</b>, instruction five is executed and the instruction at address SUB_<b>1</b> +1 is fetched.</p><p>While the prior art microcontrollers were useful, the various modules could not be emulated. Moreover, the type of microcontroller as described in FIG. 1 could not linearize the address space. Finally, the prior art microcontrollers are susceptible to compiler-error problems. What is needed is an apparatus, method, and system for a microcontroller that is capable of linearizing the address space in order to enable modular emulation. There is also a need in the art for reducing compiler errors.</p><h4>SUMMARY OF THE INVENTION</h4><p>The present invention overcomes the above-identified problems as well as other shortcomings and deficiencies of existing technologies by providing a microcontroller instruction set that eliminates many of the compiler errors experienced in the prior art. Moreover, an apparatus and system is provided that enables a linearized address space that makes modular emulation possible.</p><p>The present invention can directly or indirectly address its register files or data memory. All special function registers, including the Program Counter (PC) and Working Register (W), are mapped in the data memory. The present invention has an orthogonal (symmetrical) instruction set that makes it possible to carry out any operation on any register using any addressing mode. This symmetrical nature and lack of \u2018special optimal situations\u2019 make programming with the present invention simple yet efficient. In addition, the learning curve for writing software applications is reduced significantly. One of the present invention's enhancements over the prior art allows two file registers to be used in some two operand instructions. This allows data to be moved directly between two registers without going through the W register; and thus increasing performance and decreasing program memory usage.</p><p>The preferred embodiment of the present invention includes an ALU/W register, a PLA, an 8-bit multiplier, a program counter (PC) with stack, a table latch/table pointer, a ROM latch/IR latch, FSRs, interrupt vectoring circuitry, and most common status registers. Unlike the prior art, the design of the present invention obviates the need for a timer in a separate module, all reset generation circuitry (WDT, POR, BOR, etc.), interrupt flags, enable flags, INTCON registers, RCON registers, configuration bits, device ID word, ID locations, and clock drivers.</p><p>Additional embodiments will be clear to those skilled in the art upon reference to the detailed description and accompanying drawings.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 is a schematic block diagram of a prior art, mid-range microcontroller unit;</p><p>FIG. 2 is a schematic block diagram of the prior art Harvard architecture;</p><p>FIG. 3 is a schematic block diagram of the prior art von Neumann architecture;</p><p>FIG. 4 is a timing diagram of a prior art clock/instruction cycle;</p><p>FIG. 5 is a schematic illustration of the execution of multiple instructions;</p><p>FIG. 6 is a schematic block diagram of the microcontroller core of the present invention;</p><p>FIG. 7 is a timing diagram of the Q cycle activity of the present invention;</p><p>FIG. 8 is a timing diagram of the clock/instruction cycle of the present invention;</p><p>FIG. 9 is an instruction pipeline flow diagram of the present invention;</p><p>FIG. 10 is an instruction pipeline flow diagram of the present invention;</p><p>FIG. 11 is an instruction pipeline flow diagram of the present invention;</p><p>FIG. 12 is an instruction pipeline flow diagram of the present invention;</p><p>FIG. 13 is an instruction pipeline flow diagram of the present invention;</p><p>FIG. 14 is an instruction pipeline flow diagram of the present invention;</p><p>FIG. 15 is a block diagram of the status register of the present invention;</p><p>FIG. 16 is a block diagram of the program counter of the present invention;</p><p>FIG. 17 is a block diagram of the program counter of the present invention using the CALL and GOTO instructions;</p><p>FIG. 18 is a block diagram of the stack pointer register of the present invention;</p><p>FIG. 19 is a block diagram of the top of stack upper register of the present invention;</p><p>FIG. 20 is a block diagram of the top of stack high register of the present invention;</p><p>FIG. 21 is a block diagram of the top of stack low register of the present invention;</p><p>FIG. 22 illustrates the stack reset operation of the present invention;</p><p>FIG. 23 illustrates the first CALL on an initialized stack of the present invention;</p><p>FIG. 24 illustrates the second consecutive CALL on a stack of the present invention;</p><p>FIG. 25 illustrates a 31<sup>st </sup>and 32<sup>nd </sup>consecutive CALL on a stack of the present invention;</p><p>FIG. 26 illustrates a return POP operation on a stack of the present invention;</p><p>FIG. 27 illustrates a stack return pop causing a stack underflow condition within the present invention;</p><p>FIG. 28 illustrates a PUSH instruction on a stack of the present invention;</p><p>FIG. 29 illustrates a POP instruction on a stack of the present invention;</p><p>FIG. 30 is a block diagram of a program memory map and stack of the present invention;</p><p>FIG. 31 is a block diagram of the memory map of the present invention;</p><p>FIG. 32 is a block diagram of instructions in the memory of the present invention;</p><p>FIG. 33 is a block diagram that illustrates the device memory map of the present invention in different program modes;</p><p>FIG. 34 is a block diagram describing the MEMCON register of the present invention;</p><p>FIG. 35 is a block diagram describing the CONFIG <b>7</b> configuration byte of the present invention;</p><p>FIG. 36 is a schematic block diagram of the 16-bit external memory connection configuration of the present invention;</p><p>FIG. 37 is a block diagram of the 8-bit external memory connection configuration of the present invention;</p><p>FIG. 38 is a listing of the typical port functions of the present invention;</p><p>FIG. 39 is a timing diagram of the external program memory bus in 16-bit mode of the present invention;</p><p>FIG. 40 is a timing diagram of the external program memory bus in 8-bit mode of the present invention;</p><p>FIG. 41 is a listing of the external bus cycle types of the present invention;</p><p>FIG. 42 is a schematic block diagram of the data memory map and the instruction \u201ca\u201d bit of the present invention;</p><p>FIG. 43 is a map of the special function register of the present invention;</p><p>FIG. 44 is a schematic of the core special function register of the present invention;</p><p>FIG. 45 is a continuation of the schematic of the core special function register of FIG. 44;</p><p>FIG. 46 is a schematic block diagram of the direct short addressing mode of the present invention;</p><p>FIG. 47 is a schematic block diagram of the BSR operation of the present invention;</p><p>FIG. 48 is a schematic block diagram of the BSR operation of the present invention during emulation/test modes;</p><p>FIG. 49 is a schematic block diagram of the direct forced addressing mode of the present invention;</p><p>FIG. 50 is a schematic block diagram of the direct forced addressing mode of the present invention;</p><p>FIG. 51 is a schematic block diagram of the direct long addressing mode of the present invention;</p><p>FIG. 52 is a schematic block diagram of the indirect addressing mode of the present invention;</p><p>FIG. 53 is a schematic block diagram of the indirect addressing mode of the present invention;</p><p>FIG. 54 is a descriptive listing opcode fields of the present invention;</p><p>FIG. 55 is a listing of indirect addressing symbols of the present invention;</p><p>FIG. 56 illustrates the general format for the instructions of the present invention;</p><p>FIG. 57 is a partial listing of the instruction set of the present invention;</p><p>FIG. 58 is a partial listing of the instruction set of the present invention;</p><p>FIG. 59 is a partial listing of the instruction set of the present invention;</p><p>FIG. 60 is a flowchart for the byte oriented file register operations of the present invention;</p><p>FIG. 61 is a flowchart for the byte oriented file register operations (execute) of the present invention;</p><p>FIG. 62 is a flowchart for the CLRF, NEGF, SETF (Fetch) instructions of the present invention;</p><p>FIG. 63 is a flowchart for the CLRF, NEGF, SETF (Execute) instructions of the present invention;</p><p>FIG. 64 is a flowchart for the DECFSZ, DCFSNZ, INCFSZ, ICFSNZ (Fetch) instructions of the present invention;</p><p>FIG. 65 is a flowchart for the DECFSZ, DCFSNZ, INCFSZ, ICFSNZ (Fetch) instructions of the present invention;</p><p>FIG. 66 is a flowchart for the CPFSEQ, CPFSQT, CPFSLT, and TSTFSZ (Fetch) instructions of the present invention;</p><p>FIG. 67 is a flowchart for the CPFSEQ, CPFSQT, CPFSLT, and TSTFSZ (Execute) instructions of the present invention;</p><p>FIG. 68 is a flowchart for the MULWF (Fetch) instruction of the present invention;</p><p>FIG. 69 is a flowchart for the MULWF (Execute) instruction of the present invention;</p><p>FIG. 70 is a flowchart for the MULFF (Fetch) instruction of the present invention;</p><p>FIG. 71 is a flowchart for the MULFF (Execute<b>1</b>) instruction of the present invention;</p><p>FIG. 72 is a flowchart for the MULFF (Execute<b>2</b>) instruction of the present invention;</p><p>FIG. 73 is a flowchart for the BCF, BSF, BTG (Fetch) instructions of the present invention;</p><p>FIG. 74 is a flowchart for the BCF, BSF, BTG (Fetch) instructions of the present invention;</p><p>FIG. 75 is a flowchart for the BTFSC and BTFSS (Fetch) instructions of the present invention;</p><p>FIG. 76 is a flowchart for the BTFSC and BTFSS (Execute) instructions of the present invention;</p><p>FIG. 77 is a flowchart for the Literal Operations (Fetch) of the present invention;</p><p>FIG. 78 is a flowchart for the Literal Operations (Execute) of the present invention;</p><p>FIG. 79 is a flowchart for the LFSR (Fetch) instruction of the present invention;</p><p>FIG. 80 is a flowchart for the LFSR (Execute1) instruction of the present invention;</p><p>FIG. 81 is a flowchart for the LFSR (Execute2) instruction of the present invention;</p><p>FIG. 82 is a flowchart for the DAW (Fetch) instruction of the present invention;</p><p>FIG. 83 is a flowchart for the DAW (Execute) instruction of the present invention;</p><p>FIG. 84 is a flowchart for the MULLW (Fetch) instruction of the present invention;</p><p>FIG. 85 is a flowchart for the MULLW (Execute) instruction of the present invention;</p><p>FIG. 86 is a flowchart for the CLRWDT, HALT, RESET, and SLEEP (Fetch) instructions of the present invention;</p><p>FIG. 87 is a flowchart for the CLRWDT, HALT, RESET, and SLEEP (Execute) instructions of the present invention;</p><p>FIG. 88 is a flowchart for the MOVELB (Fetch) instruction of the present invention;</p><p>FIG. 89 is a flow chart for the MOVLB (Execute) instruction of the present invention;</p><p>FIG. 90 is a flow chart for the Branch Operations (Fetch) of the present invention;</p><p>FIG. 91 is a flow chart for the Branch Operations (Execute) of the present invention;</p><p>FIG. 92 is a flow chart for BRA and RCALL (Fetch) instructions of the present invention;</p><p>FIG. 93 is a flow chart for BRA and RCALL (Execute) instructions of the present invention;</p><p>FIG. 94 is a flow chart for PUSH (Fetch) instruction of the present invention;</p><p>FIG. 95 is a flow chart for PUSH (Execute) instruction of the present invention;</p><p>FIG. 96 is a flow chart for POP (Fetch) instruction of the present invention;</p><p>FIG. 97 is a flow chart for POP (Execute) instruction of the present invention;</p><p>FIG. 98 is a flow chart for RETURN and RETFIE (Fetch) instructions of the present invention;</p><p>FIG. 99 is a flow chart for RETURN and RETFIE (Execute) instructions of the present invention;</p><p>FIG. 100 is a flow chart for RETLW (Fetch) instruction of the present invention;</p><p>FIG. 101 is a flow chart for RETLW (Execute) instruction of the present invention;</p><p>FIG. 102 is a flow chart for GOTO (Fetch) instruction of the present invention;</p><p>FIG. 103 is a flow chart for GOTO (Execute1) instruction of the present invention;</p><p>FIG. 104 is a flow chart for GOTO (Execute2) instruction of the present invention;</p><p>FIG. 105 is a flow chart for CALL (Fetch) instruction of the present invention;</p><p>FIG. 106 is a flow chart for CALL (Execute1) instruction of the present invention;</p><p>FIG. 107 is a flow chart for CALL (Execute2) instruction of the present invention;</p><p>FIG. 108 is a flow chart for TBLRD*, TBLRD*+, TBLRD*\u2212, and TBLRD+* (Fetch) instructions of the present invention;</p><p>FIG. 109 is a flow chart for TBLRD*, TBLRD*+, TBLRD*\u2212, and TBLRD+* (Execute1) instructions of the present invention;</p><p>FIG. 110 is a flow chart for TBLRD*, TBLRD*+, TBLRD*\u2212, and TBLRD+* (Execute2) instructions of the present invention;</p><p>FIG. 111 is a flow chart for TBLWT*, TBLWT*+, TBLWT*\u2212, and TBLWT+* (Fetch) instructions of the present invention;</p><p>FIG. 112 is a flow chart for TBLWT*, TBLWT*+, TBLWT*\u2212, and TBLWT+* (Execute) instructions of the present invention;</p><p>FIG. 113 is a flow chart for TBLWT*, TBLWT*+, TBLWT*\u2212, and TBLWT+* (Execute2) instructions of the present invention; and</p><p>FIG. 114 is an instruction decode map of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</h4><p>The present invention is an apparatus, method and system for providing, in several embodiments, a microcontroller instruction set and microcontroller architecture that includes a linearized address space that enables modular emulation.</p><p>The architecture of the apparatus of the preferred embodiment of the present invention modifies the prior art Harvard architecture in that the data path is 8-bit and the instruction length is 16-bit with a four-phase internal clocking scheme. Moreover, the preferred embodiment has a linearized memory addressing scheme that eliminates the need for paging and banking. The memory addressing scheme of the present invention allows for program memory addressability up to 2M bytes. Emulation of modules is also supported by the present invention.</p><p>The present invention overcomes the above-identified problems as well as other shortcomings and deficiencies of existing technologies by providing a microcontroller instruction set that eliminates many of the compiler errors experienced in the prior art. Moreover, an apparatus and system is provided that enables a linearized address space that makes modular emulation possible.</p><p>The present invention can directly or indirectly address its register files or data memory. All special function registers, including the Program Counter (PC) and Working Register (W), are mapped in the data memory. The present invention has an orthogonal (symmetrical) instruction set that makes it possible to carry out any operation on any register using any addressing mode. This symmetrical nature and lack of 'special optimal situations' make programming with the present invention simple yet efficient. In addition, the leaming curve is reduced significantly. One of the present invention family architectural enhancements from the prior art allows two file registers to be used in some two operand instructions. This allows data to be moved directly between two registers without going through the W register. Thus increasing performance and decreasing program memory usage. FIG. 6 shows a block diagram for the microcontroller core of the present invention.</p><p>The microcontroller core <b>100</b> of the present invention is illustrated in FIG. <b>6</b>. By convention, connecting signal lines in FIG. 6 can contain a slash with an adjacent number indicating the bandwidth (in bits) of the signal line. Referring to the upper right corner of FIG. 6, we find a data memory <b>104</b> that is used for storing and transferring data to and from a central processing unit (described below). The data memory <b>104</b> is composed of a plurality of address locations. In the preferred embodiment of the present invention, the data memory <b>104</b> is a linearized 4K memory which is divided into a plurality of sixteen pages or banks. Typically, each bank has 256 address locations. In the preferred embodiment, one of the plurality of banks is a dedicated to general and specific purpose registers, in this case the topmost bank, bank <b>0</b>.</p><p>A selection circuit <b>108</b> is coupled to the data memory <b>104</b> through an address latch <b>102</b>. The selection circuit <b>108</b> is used for selecting one of the plurality of sources that supply the bank address values in the data memory <b>104</b>.</p><p>The preferred embodiment of the present invention includes an ALU <b>140</b> with working (W) register <b>136</b>, a PLA, an 8-bit multiplier, a program counter (PC) <b>168</b> with stack <b>170</b>, a table latch <b>124</b>, table pointer <b>148</b>, a ROM latch <b>152</b> with IR latch <b>126</b>, FSRs <b>120</b>, <b>121</b>, <b>122</b>, interrupt vectoring circuitry, and most common status registers. Unlike the prior art, the design of the present invention obviates the need for a timer in a separate module, all reset generation circuitry (WDT, POR, BOR, etc.), interrupt flags, enable flags, INTCON registers, RCON registers, configuration bits, device ID word, ID locations, and clock drivers.</p><p>I/O List:</p><p>A generous list of input/output (I/O) commands are available with the present invention, the I/O list is shown in Table 1.</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" pgwide=\"1\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"287pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 1</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>I/O List</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"6\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"28pt\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"84pt\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"49pt\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"35pt\"></colspec><colspec align=\"left\" colname=\"6\" colwidth=\"49pt\"></colspec><tbody valign=\"top\"><row><entry></entry><entry>Count</entry><entry></entry><entry>Operation Test</entry><entry>Program</entry><entry>Emulation</entry></row><row><entry>Name</entry><entry>I/O</entry><entry>Normal Operation</entry><entry>Module</entry><entry>Module</entry><entry>Module</entry></row><row><entry align=\"center\" nameend=\"6\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>addr&lt;21:0&gt;</entry><entry>22/O</entry><entry>Program Memory</entry><entry></entry><entry></entry><entry></entry></row><row><entry></entry><entry></entry><entry>address</entry></row><row><entry>nqbank&lt;3:0&gt;</entry><entry>4/O</entry><entry>Active low RAM bank</entry></row><row><entry></entry><entry></entry><entry>selection</entry></row><row><entry>d&lt;15:0&gt;</entry><entry>16/I</entry><entry>Program memory data</entry></row><row><entry>db&lt;7:0&gt;</entry><entry>8/I/O</entry><entry>Data bus</entry></row><row><entry>forcext</entry><entry>1/I</entry><entry></entry><entry>Force external</entry></row><row><entry></entry><entry></entry><entry></entry><entry>instruction test</entry></row><row><entry></entry><entry></entry><entry></entry><entry>mode</entry></row><row><entry>irp&lt;7:0&gt;</entry><entry>8/O</entry><entry>Peripheral Address</entry></row><row><entry>irp9</entry><entry>1/O</entry><entry>Instruction register bit 9</entry></row><row><entry>ncodeprt</entry><entry>1/I</entry><entry>Active low code protect</entry></row><row><entry>neprtim</entry><entry>1/I</entry><entry>Active low end of EPROM</entry></row><row><entry></entry><entry></entry><entry>write</entry></row><row><entry>nhalt</entry><entry>1/I</entry><entry></entry><entry></entry><entry></entry><entry>Active low halt</entry></row><row><entry>nintake</entry><entry>1/I</entry><entry>Active low interrupt</entry></row><row><entry></entry><entry></entry><entry>acknowledge early and</entry></row><row><entry></entry><entry></entry><entry>wake up from sleep</entry></row><row><entry>np&lt;7:0&gt;</entry><entry>8/O</entry><entry>Table latch data</entry></row><row><entry>npcmux</entry><entry>1/O</entry><entry>Active low PC mulitplex</entry></row><row><entry>npchold</entry><entry>1/O</entry><entry>Active low PC hold</entry></row><row><entry>nprtchg</entry><entry>1/I</entry><entry>Active low port change</entry></row><row><entry></entry><entry></entry><entry>interrupt</entry></row><row><entry>nq4clrwdt</entry><entry>1/O</entry><entry>Active low clear wdt</entry></row><row><entry>nq4sleep</entry><entry>1/O</entry><entry>Active low sleep</entry></row><row><entry>nqrd</entry><entry>1/O</entry><entry>Active low read file</entry></row><row><entry>nreset</entry><entry>1/I</entry><entry>Active low reset</entry></row><row><entry>nwrf</entry><entry>1/O</entry><entry>Active low write file</entry></row><row><entry>q1:q4</entry><entry>4/I</entry><entry>4-phase Q clocks</entry></row><row><entry>q13</entry><entry>1/I</entry><entry>Combination of Q clocks</entry></row><row><entry>q23</entry><entry>1/I</entry><entry>Combination of Q clocks</entry></row><row><entry>q41</entry><entry>1/I</entry><entry>Combination of Q clocks</entry></row><row><entry>test0</entry><entry>1/I</entry><entry></entry><entry>Test mode 0</entry></row><row><entry>tsthvdet</entry><entry>1/I</entry><entry>High voltage detect</entry></row><row><entry>wreprom</entry><entry>1/O</entry><entry>Write eprom</entry></row><row><entry>writem</entry><entry>1/O</entry><entry>Write memory</entry></row><row><entry>wrtbl</entry><entry>1/O</entry><entry>Table write instruction</entry></row><row><entry>nintakd</entry><entry>1/I</entry><entry>Interrupt acknowledge</entry></row><row><entry></entry><entry></entry><entry>delayed</entry></row><row><entry>intak</entry><entry>1/I</entry><entry>Interrupt acknowledge</entry></row><row><entry align=\"center\" nameend=\"6\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>Clocking Scheme/Instruction Cycle</p><p>The clock input (from OSC1) is internally divided by four to generate four non-overlapping quadrature clocks, namely Q<b>1</b>, Q<b>2</b>, Q<b>3</b>, and Q<b>4</b> as shown in FIG. <b>7</b>. Internally, the program counter (PC) is incremented every Q<b>1</b>, and the instruction is fetched from the program memory and latched into the instruction register using Q<b>4</b>. The instruction is decoded and executed during the following Q<b>1</b> through Q<b>4</b>. The PLA decoding is done during Q<b>1</b>. During the Q<b>2</b> and Q<b>3</b> cycle, the operand is read from memory or peripherals and the ALU performs the computation. During Q<b>4</b> the results are written to the destination location. The clocks and instruction execution flow are shown in FIG. <b>8</b>.</p><h4>Q Cycle Activity</h4><p>Each instruction cycle (TCY) is comprised of four Q cycles (Q<b>1</b>-Q<b>4</b>) as shown in FIG. <b>7</b>. The Q cycle is the same as the device oscillator cycle (TOSC). The Q cycles provide the timing/designation for the Decode, Read, Process Data, Write etc., of each instruction cycle. The following diagram (FIG. 7) shows the relationship of the Q cycles to the instruction cycle. The four Q cycles that make up an execution instruction cycle (TCY) can be generalized as:</p><p>Q<b>1</b>: Instruction Decode Cycle or forced NOP</p><p>Q<b>2</b>: Instruction Read Cycle or NOP</p><p>Q<b>3</b>: Process the Data</p><p>Q<b>4</b>: Instruction Write Cycle or NOP</p><p>Each instruction will show the detailed Q cycle operation for the instruction.</p><h4>Instruction Flow/Pipelining</h4><p>An \u201cInstruction Cycle\u201d consists of four Q cycles (Q<b>1</b>, Q<b>2</b>, Q<b>3</b>, and Q<b>4</b>). The instruction fetch and execute are pipelined such that fetch takes one instruction cycle while decode and execute takes another instruction cycle. However, due to the pipelining, each instruction effectively executes in one cycle. There are 4 types of instruction flows. First is a normal 1-word 1 cycle pipelined instruction. These instructions will take one effective cycle to execute as shown in FIG. <b>9</b>. Second is a 1 word 2 cycle pipeline flush instruction. These instructions include the relative branches, relative call, skips and returns. When an instruction changes the PC, the pipelined fetch is discarded. This makes the instruction take two effective cycles to execute as shown in FIG. <b>10</b>. Third are the table operation instructions. These instructions will suspend the fetching to insert and read or write cycle to the program memory. The instruction fetched while executing the table operation is saved for 1 cycle and executed in the cycle immediately after the table operation as shown in FIG. <b>11</b>. Fourth are new two word instructions. These instructions include MOVFF and MOVLF. In these instructions, the fetch after the instruction contains the remainder of the addresses. For a MOVFF instruction during execution of the first word, the machine will execute a read of the source register. During execution of the second word, the source address is obtained, and then the instruction will complete the move as shown in FIG. <b>12</b>. The MOVLF is similar although it moves 2 literal values into FSRnH and FSRnL in 2 cycles as shown in FIG. <b>13</b>. Fifth, is the two word instructions for CALL and GOTO. In these instructions, the fetch after the instruction contains the remainder of the jump or call destination addresses. Normally, these instructions would require 3 cycles to execute, 2 for fetching the 2 instruction words and 1 for the subsequent pipeline flush. However, by providing a high-speed path on the second fetch, the PC can be updated with the complete value in the first cycle of instruction execution, resulting in a 2 cycle instruction as shown in FIG. <b>14</b>. Sixth, is the interrupt recognition execution. Instruction cycles during interrupts are discussed in the interrupts section below.</p><h4>The ALU</h4><p>The present invention contains an 8-bit Arithmetic and Logic Unit (ALU)<b>142</b> and working register <b>136</b> as shown in FIG. <b>6</b>. The ALU <b>142</b> is a general purpose arithmetic unit. It performs arithmetic and Boolean functions between data in the working register and any register file. The ALU <b>142</b> is 8-bits wide and capable of addition, subtraction, shift, and logical operations. Unless otherwise mentioned, arithmetic operations are two's complement in nature. The working (W) register <b>136</b> is an 8-bit working register used for ALU <b>140</b> operations. The W register <b>136</b> is addressable and can be directly written or read. The ALU <b>140</b> is capable of carrying out arithmetic or logical operations on two operands or a single operand. All single operand instructions operate either on the W register <b>136</b> or the given file register. For two operand instructions, one of the operands is the W register <b>136</b> and the other one is either a file register or an 8-bit immediate constant, or an equivalent storage medium.</p><p>Depending on the instruction executed, the ALU <b>140</b> may affect the values of the Carry (C), Digit Carry (DC), Zero (Z), Overflow (OV), and Negative (N) bits in the STATUS register (discussed below). The C and DC bits operate as a borrow and digit borrow out bit, respectively, in subtraction.</p><p>The preferred embodiment of the present invention includes an 8\u00d78 hardware multiplier <b>134</b> included in the ALU <b>142</b> of the device as shown in FIG. <b>6</b>. By making the multiply a hardware operation, the operation completes in a single instruction cycle. This hardware operation is an unsigned multiply that gives a 16-bit result. The result is stored into the 16-bit product register (PRODH:PRODL). The multiplier does not affect any flags in the STATUS register.</p><h4>Status Registers</h4><p>The STATUS register contains the status bits of the ALU <b>140</b>. The status register is shown in FIG. <b>15</b>. In the preferred embodiment of the present invention, bit <b>7</b>-<b>5</b> are unimplemented and are read as \u20180\u2019.</p><p>bit <b>4</b> is \u201cN\u201d, the Negative bit. This bit is used for signed arithmetic (2's complement). It indicates whether the result was negative, (ALU MSb=1), 1=Result was negative, 0=Result was positive.</p><p>bit <b>3</b> is the \u201cOV\u201d Overflow bit. This bit is used for signed arithmetic (2's complement). It indicates an overflow of the 7-bit magnitude, which causes the sign bit (bit<b>7</b>) to change state. For this bit, 1=Overflow occurred for signed arithmetic, (in this arithmetic operation), and 0=No overflow occurred.</p><p>bit <b>2</b> is the \u201cZ\u201d Zero bit. For this bit, 1=The result of an arithmetic or logic operation is zero, and 0=The results of an arithmetic or logic operation is non-zero.</p><p>bit <b>1</b> is the \u201cDC\u201d Digit carry/borrow bit. For this bit, 1=A carry-out from the 4th low order bit of the result occurred, and 0=No carry-out from the 4th low order bit of the result It should be noted that, for borrow, the polarity is reversed.</p><p>bit <b>0</b> is the \u201cC\u201d carry/borrow bit. For this bit, 1=A carry-out from the most significant bit of the result occurred, and 0=No carry-out from the most significant bit of the result. As with bit <b>1</b>, for borrow the polarity is reversed.</p><p>The C and DC bits operate as a borrow and digit borrow bit, respectively, in subtraction. Carry is ALU bit <b>7</b> carry out. Digit Carry is ALU bit <b>3</b> carry out. Zero is true if ALU result bit &lt;<b>7</b>:<b>0</b>&gt; is \u20180\u2019. N is ALU result bit <b>7</b>. The overflow bit will be set if the 2's complement result exceeds +127 or is less than \u2212128. Overflow is ALU bit <b>6</b> carry out XOR ALU bit <b>7</b> carry out. As with all the other registers, the STATUS register can be the destination for any instruction. If the STATUS register is the write destination for an instruction that affects any of the status bits, then the write to the status bits is disabled. The bits are set or cleared according to the ALU results and the instruction specification. Therefore, the result of an instruction with the STATUS register as destination may be different than intended.</p><p>For example, the CLRF REG instruction normally writes the register to 0 and sets the Z bit. The CLRF STATUS instruction will disable the write to the N, OV, DC and C bits and set the Z bit. This leaves the STATUS register as 000u uluu. It is recommended, therefore, that only the BCF, BSF, SWAPF and MOVWF instructions be used to alter the STATUS register because these instructions do not affect any status bit. To see how other instructions affect the status bits, see the \u201cInstruction Set Summary.\u201d</p><h4>Program Counter Module</h4><p>The program counter (PC)<b>168</b> (see FIG. 6) is modified to allow expansion up to a maximum of 21 bits. This is done by adding a 5-bit wide PCLATU register that operates similarly to the PCLATH register. The PC <b>168</b> is also modified to address bytes rather than words in the program memory. To implement this, there is a byte addressing bit at the LSb of the PC <b>168</b> that is always 0. The LSb bit of the PCL is readable but not writeable. Should the user attempt to write a \u20181\u2019 into the LSb, the result will be a \u20180\u2019. To allow hidden test EPROM, there is a hidden 22nd bit (bit<b>21</b>) of PC <b>168</b> (see FIG. <b>16</b>). This PC bit is normally 0. When entering test mode or programming mode, this bit is set and the instructions will be fetched from the test area. Once this bit is set, it cannot be cleared by program execution, the device must be reset.</p><p>The Program Counter (PC) <b>168</b> is up to a 21-bit register as shown in FIG. <b>16</b>. PCL <b>184</b>, the low byte of the PC <b>168</b>, is mapped in the data memory <b>104</b> (see FIG. <b>6</b>). PCL <b>184</b> is readable and writable just as is any other register. PCH <b>182</b> and PCU <b>180</b> are the high bytes of the PC and are not directly addressable. Since PCH <b>182</b> and PCU <b>184</b> are not mapped in data or program memory <b>160</b>, registers PCLATH <b>178</b> (PC high latch) and PCLATU <b>176</b> (PC upper latch) are used as holding latches for the high bytes of the PC <b>168</b>.</p><p>PCLATH <b>178</b> and PCLATU <b>176</b> are mapped into data memory <b>104</b>. The user can read and write PCH <b>182</b> through PCLATH <b>178</b> and PCU <b>180</b> through PCLATU <b>176</b>. The PC <b>168</b> is word incremented by 2 after each instruction fetch during Q<b>1</b> unless:</p><p>Modified by a GOTO, CALL, RETURN, RETLW, RETFIE, or Branch instruction.</p><p>Modified by an interrupt response.</p><p>Due to destination write to PCL <b>168</b> by an instruction.</p><p>\u201cSkips\u201d are equivalent to a forced NOP cycle at the skipped address. FIGS. 16 and 17 show the operation of the program counter for various situations.</p><p>Referring to FIG. 16, the operations of the PC <b>168</b>, PCLATH <b>178</b>, and PCLATU <b>176</b> for different instructions are as follows:</p><p>a. Read instructions on PCL:</p><p>For any instruction that reads PCL <b>184</b>. All byte instructions with d=0; MOVFF PCL, X; CPFSEQ; CPFSGT; CPFSLT; MULWF; TSTFSZ then PCL to data bus then to ALU or to the destination. Finally, PCH to PCLATH and PCU to PCLATU.</p><p>b. Write instructions on PCL:</p><p>Any instruction that writes to PCL <b>184</b>. For example, MOVWF; CLRF; SETF, then write 8-bit data to the data bus <b>174</b> and then to PCL <b>184</b>. Also, PCLATH to PCH, and PCLATU to PCU.</p><p>c. Read-Modify-Write instructions on PCL:</p><p>Any instruction that does a read-write-modify operation on PCL. All byte instructions with d=1; Bit Instructions; NEGF. Read: PCL to data bus to ALU. Write: write the 8-bit result to data bus and to PCL; then PCLATH to PCH; and finally PCLATU to PCU.</p><p>The read-modify-write only affects the PCL <b>184</b> with the result. PCH <b>182</b> and PCU <b>180</b> are loaded with the value in the PCLATH <b>178</b> and PCLATU <b>176</b> respectively. For example, for the instruction \u201cADDWF\u201d, PCL <b>184</b> will result in the following jump. If PC=0003F0h, W=30h, PCLATH=05h and PCLATU=1h before the instruction, PC=010520h after the instruction. To accomplish a true 20-bit computed jump, the user needs to compute the 20-bit destination address, write to PCLATH <b>178</b> and PCLATU <b>176</b>, and then write the low value to PCL <b>168</b>.</p><p>d. RETURN instruction:</p><p>Stack&lt;MRU&gt; to PC&lt;<b>20</b>:<b>0</b>&gt; Using FIG. 17, the operation of the PC <b>168</b> , PCLATH <b>178</b>, and PCLATU <b>176</b> for the GOTO and the CALL instructions is as follows:</p><p>e. CALL, GOTO instructions:</p><p>A destination address is provided in the 2-word instruction (opcode). The first Word Opcode&lt;<b>6</b>:<b>0</b>&gt; to PCL&lt;<b>7</b>:<b>1</b>&gt;. The first Word Opcode&lt;<b>7</b>&gt; to PCLATH&lt;<b>0</b>&gt;and to PCH&lt;<b>0</b>&gt;. The second Word Opcode&lt;<b>6</b>:<b>0</b>&gt; to PCLATH&lt;<b>7</b>:<b>1</b>&gt; and PCH&lt;<b>7</b>:<b>1</b>&gt;. The second Word Opcode&lt;<b>11</b>:<b>7</b>&gt; to PCLATU&lt;<b>4</b>:<b>0</b>&gt; and PCU&lt;<b>4</b>:<b>0</b>&gt;.</p><p>It should be noted that the following PC <b>168</b> related operations do not change PCLATH <b>178</b> and PCLATU <b>176</b>:</p><p>a. RETLW, RETURN, and RETFIE instructions.</p><p>b. Interrupt vector is forced onto the PC.</p><p>c. Read-modify-write instructions on PCL (e.g. BSF PCL, 2).</p><h4>Return Stack Operation</h4><p>The present invention has a 31 level deep return (or hardware) stack. The depth of the stack was increased over the prior art in order to allow more complex programs. The stack is not part of either the program or data memory space.</p><p>The PC <b>168</b> is pushed onto the stack when a CALL or RCALL instruction is executed or an interrupt is acknowledged. The PC <b>168</b> value is pulled off the stack on a RETURN, RETLW, or a RETFIE instruction. PCLATU <b>176</b> and PCLATH <b>178</b> are not affected by any of the return instructions.</p><p>The stack operates as a 31 word by 21 bit RAM and a 5-bit stack pointer, with the stack pointer initialized to 00000b after all resets. There is no RAM word associated with stack pointer 000h. This is only a reset value. During a CALL type instruction causing a push onto the stack, the stack pointer is first incremented and the RAM location pointed to by the stack pointer is written with the contents of the PC. During a RETURN type instruction causing a pop from the stack, the contents of the RAM location pointed to by the STKPTR is transferred to the PC and then the stack pointer is decremented.</p><h4>Top Of Stack Access</h4><p>The top of the stack is readable and writeable. Three register locations, TOSU, TOSH and TOSL address the stack RAM location pointed to by the STKPTR. This allows users to implement a software stack if necessary. After a CALL or RCALL instruction or an interrupt, the software can read the pushed value by reading the TOSU, TOSH and TOSL registers. These values can be placed on a user defined software stack. At return time, the software can replace the TOSU, TOSH and TOSL and do a return. It should be noted that the user must disable the global interrupt enable bits during this time to prevent inadvertent stack operations.</p><h4>PUSH and POP instructions</h4><p>Since the Top-of-stack (TOS) is readable and writable, the ability to push values onto the stack and pull values off the stack without disturbing normal program execution is a desirable option. To push the current PC value onto the stack, a PUSH instruction can be executed. This will push the current PC value onto the stack; setting the TOS=PC and PC=PC+2. The ability to pull the TOS value off of the stack and replace it with the value that was previously pushed onto the stack, without disturbing normal execution, is achieved by using the POP instruction. The POP instruction pulls the TOS value off the stack, but this value is not written to the PC; the previous value pushed onto the stack then becomes the TOS value.</p><h4>Return Stack Pointer (STKPTR)</h4><p>The STKPTR register contains the return stack pointer value and the overflow and underflow bits. The stack overflow bit (STKOVF) and underflow bit (STKUNF) allow software verification of a stack condition. The STKOVF and STKUNF bits are cleared after a POR reset only.</p><p>After the PC is pushed onto the stack 31 times (without popping any values off the stack), the 32nd push over-writes the value from the 31st push and sets the STK-OVF bit while the STKPTR remains at 11111b. The 33<sup>rd </sup>push overwrites the 32nd push (and so on) while STKPTR remains 11111b.</p><p>After the stack is popped enough times to unload the stack, the next pop will return a value of zero to the PC and sets the STKUNF bit while the STKPTR remains at 00000b. The next pop returns zero again (and so on) while STKPTR remains 00000b. Note that returning a zero to the PC on an underflow has the effect of vectoring the program to the reset vector where the stack conditions can be verified and appropriate actions can be taken.</p><p>The stack pointer can be accessed through the STKPTR register. The user may read and write the stack pointer values. This can be used by RTOS for return stack maintenance. FIG. 18 shows the STKPTR register. The value of the stack pointer will be 0 through 31. At reset the stack pointer value will be 0. The stack pointer when pushing will increment and when popping will decrement.</p><h4>Stack Overflow/Underflow Resets</h4><p>At the user's option, the overflow and underflow can cause a device reset to interrupt the program code. The reset is enabled with a configuration bit, STVRE. When the STVRE bit is disabled, an overflow or underflow will set the appropriate STKOVF or STKUNF bit and not cause a reset. When the STVRE bit is enabled, a over-flow or underflow will set the appropriate STKOVF or STKUNF bit and then cause a device reset very similar in nature to the WDT reset. In either case, the STKOVF or STKUNF bits are not cleared unless the user software clears them or a POR reset clears them. FIGS. 18-21 illustrate stack registers. FIGS. 22-29 illustrate stack operations.</p><h4>Program Memory</h4><p>The preferred embodiment of the present invention has up to a 2Megabyte (2M)\u00d78 user program memory space. The program memory space is primarily to contain instructions for execution, however, data tables may be stored and accessed using the table read and write instructions. Another 2M\u00d78 test program memory space is available for test ROM, configuration bits, and identification words.</p><p>The devices have up to a 21-bit program counter capable of addressing the 2M\u00d78 program memory space. There is also a 22nd PC bit that is hidden during normal operation, and when it is set, it is possible to access configuration bits, device ID and test ROM. This bit can be set in test mode or programming mode, and the device must be reset to clear this bit. User program memory space cannot be accessed with this bit set. Because the PC must access the instructions in program memory on an even byte boundary, the LSb of the PC is an implied \u20180\u2019 and the PC increments by two for each instruction.</p><p>The reset vector is at 000000h and the high priority interrupt vector is at 000008h and the low priority interrupt vector is at 000018h (see FIG. <b>30</b>).</p><h4>Program Memory Organization</h4><p>Each location in the program memory has a byte address. In addition, each 2 adjacent bytes have a word address. FIG. 31 shows the map of the program memory with byte and word addresses shown. Within the program memory, the instructions must be word aligned. FIG. 32 shows the map of the program memory with several example instructions and the hex codes for those instructions placed into the map. Table operations will work with byte entities. A table block is not required to be word aligned, so a table block can start and end at any byte address. The exception to this is if a table write is being used to program the internal program memory or an external word wide flash memory. When programming, the write data may need to be aligned to the word width used by the programming method.</p><h4>Program Memory Modes</h4><p>The present invention can operate in one of five possible program memory configurations. The configuration is selected by configuration bits. The possible modes are:</p><p>MP\u2014Microprocessor</p><p>EMC\u2014Extended Microcontroller</p><p>PEMC\u2014Protected Extended Microcontroller</p><p>MC\u2014Microcontroller</p><p>PMC\u2014Protected Microcontroller</p><p>The microcontroller and protected microcontroller modes only allow internal execution. Any access beyond the program memory reads all zeros. The protected micro-controller mode also enables the code protection feature. Microcontroller is the default mode of an un-programmed device.</p><p>The extended microcontroller mode accesses both the internal program memory as well as external program memory. Execution automatically switches between internal and external memory. The 21-bits of address allow a program memory range of 2M-bytes. The protected extended microcontroller mode will code protect the internal program memory by preventing table reads/writes to the internal memory while still allowing execution and table reads/writes of the external program memory.</p><p>The microprocessor mode only accesses the external program memory. The on-chip program memory is ignored. The 21-bits of address allow a program memory range of 2M-bytes.</p><p>Test memory and configuration bits are readable during normal operation of the device by using the TBLRD instruction. These areas are only modifiable using the TBLWT instruction if the LWRT bit in the RCON register is set or the device is in test and programming mode. These areas can only be executed from in test and programming mode.</p><p>The extended microcontroller mode and microprocessor modes are available only on devices which have the external memory bus defined as part of the I/O pins. Table 2 lists which modes can access internal and external memory. FIG. 33 illustrates the device memory map in the different program modes.</p><p><tables id=\"TABLE-US-00002\"><table colsep=\"0\" frame=\"none\" pgwide=\"1\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"308pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 2</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Device Mode Memory Access</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"112pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98pt\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"98pt\"></colspec><tbody valign=\"top\"><row><entry>Operating Mode</entry><entry>Internal Program Memory</entry><entry>External Program Memory</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Microprocessor</entry><entry>No Access</entry><entry>Execution / TBLRD / TBLWT</entry></row><row><entry>Extended Microcontroller</entry><entry>Execution / TBLRD / TBLWT</entry><entry>Execution / TBLRD / TBLWT</entry></row><row><entry>Protected Extended Microcontroller</entry><entry>Execution</entry><entry>Execution / TBLRD / TBLWT</entry></row><row><entry>Microcontroller</entry><entry>Execution / TBLRD / TBLWT</entry><entry>No Access</entry></row><row><entry>Protected Microcontroller</entry><entry>Execution / TBLRD</entry><entry>No Access</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><h4>External Program Memory Interface</h4><p>When either microprocessor or extended microcontroller mode is selected, up to four ports are configured as the system bus. Two ports and part of a third are the multiplexed address/data bus and part of one other port is used for the control signals. External components are needed to demultiplex the address and data. The external memory interface can run in 8-bit data mode or 16-bit data mode. Addresses on the external memory interface are byte addresses always.</p><p>FIGS. 36 and 37 describe the external memory connections for 16-bit and 8-bit data respectively. The external program memory bus shares I/O port functions on the pins. FIG. 38 lists a typical mapping of external bus functions on I/O pin functions. In extended microcontroller mode, when the device is executing out of internal memory, the control signals will NOT be active. They will go to a state where the AD&lt;<b>15</b>:<b>0</b>&gt;, A&lt;<b>19</b>:<b>0</b>&gt; are tri-state; the OE, WRH, WRL, UB and LB signals are \u20181\u2019; UBA<b>0</b> and ALE is \u20180\u2019.</p><h4>16-Bit External Interface</h4><p>If the external interface is 16-bit, the instructions will be fetched as 16-bit words. The OE output enable signal will enable both bytes of program memory at once to output a 16-bit word. The least significant bit of the address, BA<b>0</b>, need not be connected to the memory devices.</p><p>An external table read is logically performed one byte at a time, although the memory will read a 16-bit word externally. The least significant bit of the address will internally select between high and low bytes (LSb=0 to lower byte, LSb=1 to upper byte). The external address in microprocessor and extended microcontroller modes is 21-bits wide; this allows addressing of up to 2M-bytes.</p><p>An external table write on a 16-bit bus is logically performed one byte at a time. The actual write will depend on the type of external device connected and the WM&lt;<b>1</b>:<b>0</b>&gt; bits in the MEMCON register, shown in FIG. <b>34</b>. The Table Operations section details the actual write cycles.</p><h4>8-Bit External Interface</h4><p>If the external interface is 8-bit, the instructions will be fetched as 2 8-bit bytes. The two bytes are fetched within one instruction cycle. The least significant bit of the address must be connected to the memory devices. The OE output enable signal and BA0=1 will enable the most significant byte of the instruction to read from program memory for the Q<b>3</b> portion of the cycle, then BA<b>0</b> will change to 0 and the least significant byte will be read for the Q<b>4</b> portion of the cycle; to form the 16-bit instruction word.</p><p>An external table read is also performed one byte at a time. An external table write is performed one byte at a time. The WRL is active on every external write.</p><p>When 8-bit interface is selected, the WRH, UB and UL lines are not used and the pins revert to I/O port functions. A configuration bit selects the 8-bit mode of the external interface.</p><h4>External Wait Cycles</h4><p>The external memory interface supports wait cycles. The external memory wait cycles only apply to the table read and table write operations over the external bus. Since the device execution is tied to instruction fetches, there is no sense to execute faster than the fetch rate. So if the program fetches need to be slowed, the processor speed must be slowed with a different Tcy time.</p><p>The WAIT &lt;<b>1</b>:<b>0</b>&gt; bits in the MEMCON register will select 0,1,2 or 3 extra TCY cycles per memory fetch cycle. The wait cycles will be effective for table reads and writes on a 16-bit interface. On an 8-bit interface, for table reads and writes, the wait will only occur on the Q<b>4</b>.</p><p>The default setting of the wait on power up is to assert a wait of the maximum of the 3 TCY cycles. This insures that slow memories will work in microprocessor mode immediately after reset. A configuration bit, called WAIT, will enable or disable the wait states. FIG. 39 illustrates the 16-bit interface and FIG. 40 illustrates the 8-bit, in both cases showing program memory instruction fetches with no waits and table reads with wait states.</p><h4>External Bus Signal Disables</h4><p>To allow flexibility in the utilization of the pins committed to the external bus, several disables are provided in configuration bits. Also, to disable the entire external bus, as might be done while in extended microcontroller mode and allowing a DMA function, the EBDIS bit in the MEM-CON, shown in FIG. 35, register. This disable will allow the user to tri-state the entire external bus inter-face. This will allow DMA operations as well as direct control of external devices by program control through the I/O pin functions.</p><p>In emulator systems, the -ME devices must have inputs to represent the bus disable configuration bits to allow the I/O port functions to detect the status of the pins as external interface. The -ME device also has a special input pin that indicates if the emulator system is in the microprocessor or extended microcontroller mode.</p><h4>Data Memory</h4><p>The data memory and general purpose RAM size can be extended to 4096 bytes in the present invention. The data memory address is 12-bits wide. The data memory is partitioned into 16 banks of 256 bytes which contain the General Purpose Registers (GPRs) and Special Function Registers (SFRs).</p><p>The GPR's are mechanized into a byte wide RAM array of the size of the combined GPR registers. The SFR's are typically distributed among the peripherals whose functions they control.</p><p>The bank is selected by the bank select register (BSR&lt;<b>3</b>:<b>0</b>&gt;). The BSR register can potentially access more than 16 banks, however the direct long addressing mode is limited to 12-bit addresses or 16 banks. The BSR is limited accordingly.</p><p>Device instructions can read, modify and write a particular location in one instruction cycle. There is only one address generation per cycle, so it is not possible to read one location and modify/write another in a single cycle. FIG. 42 shows an example data memory map.</p><h4>General Purpose Registers</h4><p>In all PIC devices, all data RAM is available for use as registers by all instructions. Most banks of data memory only contain GPR memory. There must be GPR memory included in bank <b>0</b> on all devices.</p><p>The absolute minimum for the number of GPRs in bank <b>0</b> is 128. This GPR area, called the Access RAM, is essential for allowing programmers to have a data structure that is accessible regardless of the setting of the BSR.</p><h4>Special Function Registers</h4><p>SFR are special registers, typically used for device and peripheral control and status functions. They are accessible by all instructions. All SFRs should be contained in the upper 128 bytes of bank <b>15</b>, if possible. If the SFRs do not use all the available locations on a particular device, the unused locations will be unimplemented and read as \u20180\u2019s. Certain devices, such as LCD controllers may have SFR areas in other banks than bank <b>15</b>.</p><p>The boundary of the SFR's in bank <b>15</b> can be modified from device to device. At least 16 GPR's must be included in the Access Bank. FIG. 43 displays a possible Special Function Register map. FIGS. 44 and 45 displays a summary of the core Special Function Registers.</p><h4>Addressing Modes</h4><p>There are 7 data addressing modes supported by the present invention:</p><p>inherent</p><p>literal</p><p>direct short</p><p>direct forced</p><p>direct long</p><p>indirect</p><p>indexed indirect offset</p><p>Three of the modes, direct forced, direct long and indirect indexed, are new to the PIC architecture.</p><h4>Inherent</h4><p>Some instructions such as DAW do not require addressing other than that explicitly defined in the opcode.</p><h4>Literal</h4><p>Literal instructions contain a literal constant field, typically used in a mathematical operation such as ADDLW. Literal addressing is also used for GOTO, CALL, and branch opcodes.</p><h4>Direct Short</h4><p>Most mathematical and move instructions operate in the direct short addressing mode. In this addressing mode, the instruction contains eight bits of least significant address for the data. The remaining four bits of address are from the Bank Select Register or BSR. The BSR is used to switch between banks in the data memory area (see FIG. <b>47</b>).</p><p>The need for a large general purpose memory space dictated a general purpose RAM banking scheme. The lower nibble of the BSR selects the currently active general purpose RAM bank. To assist this, a MOVLB bank instruction has been provided in the instruction set.</p><p>If the currently selected bank is not implemented (such as Bank <b>13</b>), any read will read all \u20180\u2019s. Any write is completed to the bit bucket and the STATUS register bits will be set/cleared as appropriate.</p><h4>Direct Forced</h4><p>All the Special Function Registers (SFRS) are mapped into the data memory space. In order to allow easy access to the SFR's, they are all, generally, mapped in Bank <b>15</b>. To simplify access, there is a 1 bit field in the instruction that points the address to the lower half of bank <b>0</b> for common RAM and the upper half of bank <b>15</b> for the SFR's regardless of the contents of the BSR. With the BSR set to BSR=n then, it is possible to address 3 banks with any instruction; Bank <b>0</b> and <b>15</b> in direct forced mode and Bank \u201cn\u201d in direct short mode.</p><h4>Direct Long</h4><p>The direct long addressing codes all twelve bits of the data address into the instruction. Only the MOVFF instruction uses this mode.</p><h4>Indirect Addressing</h4><p>Indirect addressing is a mode of addressing data memory where the data memory address in the instruction is determined by another register. This can be useful for data tables or stacks in the data memory. FIG. 53 shows the operation of indirect addressing. The value of the FSR register is used as the data memory address.</p><h4>Indirect Addressing Registers</h4><p>The present invention has three 12-bit registers for indirect addressing. These registers are:</p><p>FSR<b>0</b>H and FSR<b>0</b>L</p><p>FSR<b>1</b>H and FSR<b>1</b>L</p><p>FSR<b>2</b>H and FSR<b>2</b>L</p><p>The FSR's are 12-bit registers and allow addressing anywhere in the 4096-byte data memory address range.</p><p>In addition, there are registers INDF<b>0</b>, INDF<b>1</b> and INDF<b>2</b> which are not physically implemented. Reading or writing to these registers activates indirect addressing, with the value in the corresponding FSR register being the address of the data. If file INDF<b>0</b> (or INDF<b>1</b>,2) itself is read indirectly via an FSR, all \u20180\u2019s are read (Zero bit is set). Similarly, if INDF<b>0</b> (or INDF<b>1</b>,2) is written to indirectly, the operation will be equivalent to a NOP, and the STATUS bits are not affected.</p><h4>Indirect Addressing Operation</h4><p>Each INDF register has four addresses associated with it. When a data access is done to the one of the four INDF locations, the address selected will configure the FSR register to:</p><p>Auto-decrement the value (address) in the FSR after an indirect access (post-decrement)</p><p>Auto-increment the value (address) in the FSR after an indirect access (post-increment)</p><p>Auto-increment the value (address) in the FSR before an indirect access (pre-increment)</p><p>No change to the value (address) in the FSR after an indirect access (no change)</p><p>When using the auto-increment or auto-decrement features, the effect on the FSR is not reflected in the STATUS register. For example, if the indirect address causes the FSR to equal \u20180\u2019, the Z bit will not be set. Adding these features allows the FSR to be used as a stack pointer in addition to its uses for data table operations.</p><h4>Indexed Indirect Addressing</h4><p>Each INDF has an address associated with it that performs an indexed indirect access. When a data access to this INDF location occurs, the FSR is configured to:</p><p>Add the signed value in the W register and the value in FSR to form the address before an indirect access.</p><p>The FSR value is not changed.</p><h4>Indirect Writing of Indirect Addressing (INDF) Registers</h4><p>If an FSR register contains a value that points to one of the indirecting registers (FEFh-FEBh, FE7h-FE3h, FDFh-FDBh), an indirect read will read 00h (Zero bit is set) while an indirect write will be equivalent to a NOP (STATUS bits are not affected).</p><h4>Indirect Writing of Pointer (FSR) Registers</h4><p>If an indirect addressing operation is done where the target address is an FSRnH or FSRnL register, the write operation will dominate over the pre or post increment/decrement functions. For example:</p><p>FSR<b>0</b>=FE8h (one less than the location of FSR<b>0</b>L)</p><p>W=50h</p><p>MOVWF *(++FSR<b>0</b>);(PREINC<b>0</b>)</p><p>will increment FSR<b>0</b> by one to FE9h, pointing to FSR<b>0</b>L. Then write of W into FSR<b>0</b>L will change FSR<b>0</b>L to 50h. However,</p><p>FSR<b>0</b>=FE9h (the location of FSR<b>0</b>L)</p><p>W=50h</p><p>MOVWF *FSR<b>0</b>++;(POSTINC<b>0</b>)</p><p>will attempt to write W into the FSR<b>0</b>L at the same time the increment of FSR<b>0</b> is to occur. The write of W will prevail over the post increment and FSR<b>0</b>L will be 50h.</p><h4>Instruction Set Summary</h4><p>The instruction set of the present invention consists of 77 instructions. Due to excessive page and bank switching in prior art architectures, the Program and Data memory maps needed to be linearized, and the instruction set was modified to facilitate this linearization. The Data Memory space of the preferred embodiment of the present invention has a maximum of 4K bytes, which is made up of 16 banks of 256 bytes each. In the preferred embodiment of the present invention, with all Special Function Registers located in one bank, it is preferred to designate a bit in the opcode of all the instructions that perform file manipulation that could force a virtual bank. Therefore, it is not necessary to switch banks in order to access Special Function Registers.</p><p>The Program Memory space was modified over the prior art systems to be a maximum of 2M bytes in the preferred embodiment. The PC was increased from 13 bits to up to 21 bits, and some instructions that cause a jump (CALL, GOTO) were changed to two-word instructions to load the 21-bit value for the PC. Another improvement over the prior art was the inclusion of a modular emulator. This requires communication between two chips for emulation, and to achieve the desired speeds, it is not possible to have different source and destination registers within the same instruction cycle. Therefore, the MOVPF and MOVFP instructions in the prior art were eliminated. To keep this functionality, a two-word instruction, MOVFF, was added.</p><p>The instruction set of the present invention can be grouped into three types:</p><p>byte-oriented</p><p>bit-oriented</p><p>literal and control operations.</p><p>These formats are shown in FIG. <b>56</b>. FIG. 54 shows the field descriptions for the opcodes. These descriptions are useful for understanding the opcodes in FIGS. 57-59 and in each specific instruction description found in Appendix A. FIG. 114 shows the instruction decode map.</p><p>For byte-oriented instructions, \u2018f\u2019 represents a file register designator and \u2018d\u2019 represents a destination designator. The file register designator specifies which file register is to be used by the instruction. The destination designator specifies where the result of the operation is to be placed. If \u2018d\u2019=\u20180\u2019, the result is placed in the W register. If \u2018d\u2019=\u20181\u2019, the result is placed in the file register specified by the instruction.</p><p>Again, for byte-oriented instructions, \u2018a\u2019 represents the virtual bank select bit. If \u2018a\u2019=\u20180\u2019, the BSR is overridden and virtual bank is selected. If \u2018a\u2019=\u20181\u2019, the bank select register (BSR) is not overridden.</p><p>For bit-oriented instructions, \u2018b\u2019 represents a bit field designator which selects the number of the bit affected by the operation, while \u2018f\u2019 represents the address of the file in which the bit is located.</p><p>For literal and control operations, \u2018k\u2019 represents an 8-, 12-, 16- or 20-bit constant or literal value. Moreover, \u2018s\u2019 represents the fast call/return select bit. If \u2018s\u2019=\u20180\u2019, the shadow registers are unused. If \u2018s\u2019=\u20181\u2019, the W, BSR and STATUS registers are updated from shadow registers on a is RETURN or RETFIE instruction, or the shadow registers are loaded from their corresponding register on a CALL instruction. Finally, \u2018n\u2019 is a 2's complement number that determines the direction and magnitude of the jump for relative branch instructions.</p><p>The instruction set is highly orthogonal and is grouped into:</p><p>byte-oriented operations</p><p>bit-oriented operations</p><p>literal and control operations</p><p>All instructions are executed within one single instruction cycle, unless:</p><p>a conditional test is true</p><p>the program counter is changed as a result of an instruction</p><p>a file to file transfer is executed</p><p>a table read or a table write instruction is executed</p><p>which in that case, the execution takes two instruction cycles with the second cycle executed as a NOP.</p><h4>Special Function Registers as Source/Destination</h4><p>The orthogonal instruction set of the present invention allows read and write of all file registers, including special function registers. There are some special situations the user should be aware of:</p><h4>STATUS as destination</h4><p>If an instruction writes to the STATUS register, the Z, C, DC, OV and N bits may be set or cleared as a result of the instruction and overwrite the original data bits written.</p><h4>PCL as Source or Destination</h4><p>Read, write or read-modify-write on PCL may have the following results:</p><p>For a Read PCL, first PCU to PCLATU; then PCH to PCLATH; and then PCL to dest.</p><p>For a Write PCL, first PCLATU to PCU; then PCLATH to PCH; and then 8-bit result value to PCL.</p><p>For a Read-Modify-Write: first PCL to ALU operand, then PCLATH to PCH, then PCLATU to PCU, and then 8-bit result to the PCL.</p><p>Where:</p><p>PCL=program counter low byte</p><p>PCH=program counter high byte</p><p>PCLATH=program counter high holding latch</p><p>PCU=program counter upper byte</p><p>PCLATU=program counter upper holding latch</p><p>dest=destination, W or f.</p><h4>Bit Manipulation</h4><p>All bit manipulation instructions are done by first reading the entire register, operating on the selected bit and writing the result back (read-modify-write (R-M-W)). The user should keep this in mind when operating on some special function registers, such as ports. It should be noted that the Status bits that are manipulated by the device (including the Interrupt flag bits) are set or cleared in the Q<b>1</b> cycle. So there is no issue on doing R-M-W instructions on registers which contain these bits.</p><p>FIGS. 60-113 contain flowcharts for the general operation of each of the instructions within the instruction set of the present invention. The various Figures show generalized as well as specific steps for the fetching and the execution of the instructions within the instruction set of the present invention. For example, FIG. 60 shows the steps for the fetching of byte oriented file register operations, which includes the instructions ADDWF, ADDWFC, ANDWF, COMF, DECF, INCF, IORWF, MOVF, RLCF, RLNCF, RRCF, RRNCF, SUBFWB, SUBWF, SUBWFB, SWAPF, XORWF, MOVWF, and NOP. Similarly, FIG. 61 shows the steps for the execution of the byte oriented file register operations, which includes the instructions ADDWF, ADDWFC, ANDWF, COMF, DECF, INCF, IORWF, MOVF, RLCF, RLNCF, RRCF, RRNCF, SUBFWB, SUBWF, SUBWFB, SWAPF, and XORWF (but MOVWF does only a dummy read and NOP does a dummy read and a dummy write).</p><p>FIG. 77 shows the fetch steps for the Literal Operations, which includes the instructions: ADDLW, ANDLW, IORLW, MOVLW, SUBLW, and XORLW. As before, FIG. 78 shows the execution steps for the Literal Operations, which includes the instructions: ADDLW, ANDLW, IORLW, MOVLW, SUBLW, and XORLW.</p><p>FIG. 90 shows a flow chart for the fetching of the Branch Operations, which includes the instructions: BC, BN, BNC, BNN, BNV, BNZ, BV, and BZ. Similarly, FIG. 90 shows a flow chart for the execution of the Branch Operations, which includes the instructions: BC, BN, BNC, BNN, BNV, BNZ, BV, and BZ. The remaining figures show the steps of fetching and execution of the other instructions within the instruction set.</p><p>For those multi-Word instructions that require two fetches to obtain the complete instruction, three flowcharts are used to describe the entire fetch and execute process. For example, the MOVFF instruction is described in FIGS. 70-72. FIG. 70 shows a relatively standard fetch operation. However, FIG. 71 shows the execution of the first portion of the MOVFF in the left side of the operation boxes while the right portion of the operation boxes show the fetching of the second Word of the instruction. Correspondingly, FIG. 72 shows simply the execution steps of the second Word of the MOVFF instruction. Similar flow charts are provided for the other multi-Word instructions: LFSR (FIGS. <b>79</b>-<b>81</b>); GOTO (FIGS. 102-104); CALL (FIGS. <b>105</b>-<b>107</b>), TBLRD*, TBLRD*+, TBLRD*\u2212, and TBLRD+* (FIGS. <b>108</b>-<b>110</b>); TBLWT*, TBLWT*+, TBLWT*\u2212, and TBLWT+* (FIGS. <b>111</b>-<b>113</b>).</p><p>Appendix A contains a detailed listing of the opcodes and instructions of the instruction set of the present invention. The material in Appendix A is incorporated herein by reference for all purposes.</p><p>The present invention, therefore, is well adapted to carry out the objects and attain the ends and advantages mentioned, as well as others inherent therein. While the present invention has been depicted, described, and is defined by reference to particular preferred embodiments of the invention, such references do not imply a limitation on the invention, and no such limitation is to be inferred. The invention is capable of considerable modification, alternation, and equivalents in form and function, as will occur to those ordinarily skilled in the pertinent arts. The depicted and described preferred embodiments of the invention are exemplary only, and are not exhaustive of the scope of the invention. Consequently, the invention is intended to be limited only by the spirit and scope of the appended claims, giving full cognizance to equivalents in all respects.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Edward Brian", "last_name": "Boles", "name": ""}, {"first_name": "Rodney", "last_name": "Drake", "name": ""}, {"first_name": "Darrel", "last_name": "Johansen", "name": ""}, {"first_name": "Sumit", "last_name": "Mitra", "name": ""}, {"first_name": "Joseph", "last_name": "Triece", "name": ""}, {"first_name": "Randy", "last_name": "Yach", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "MICROCHIP TECHNOLOGY INCORPORATED"}, {"first_name": "", "last_name": "MICROSEMI STORAGE SOLUTIONS, INC.", "name": ""}, {"first_name": "", "last_name": "ATMEL CORPORATION", "name": ""}, {"first_name": "", "last_name": "MICROCHIP TECHNOLOGY INCORPORATED", "name": ""}, {"first_name": "", "last_name": "SILICON STORAGE TECHNOLOGY, INC.", "name": ""}, {"first_name": "", "last_name": "MICROSEMI CORPORATION", "name": ""}, {"first_name": "", "last_name": "MICROSEMI STORAGE SOLUTIONS, INC.", "name": ""}, {"first_name": "", "last_name": "MICROCHIP TECHNOLOGY INCORPORATED", "name": ""}, {"first_name": "", "last_name": "MICROSEMI CORPORATION", "name": ""}, {"first_name": "", "last_name": "ATMEL CORPORATION", "name": ""}, {"first_name": "", "last_name": "SILICON STORAGE TECHNOLOGY, INC.", "name": ""}, {"first_name": "", "last_name": "MICROSEMI STORAGE SOLUTIONS, INC.", "name": ""}, {"first_name": "", "last_name": "ATMEL CORPORATION", "name": ""}, {"first_name": "", "last_name": "MICROSEMI CORPORATION", "name": ""}, {"first_name": "", "last_name": "SILICON STORAGE TECHNOLOGY, INC.", "name": ""}, {"first_name": "", "last_name": "MICROCHIP TECHNOLOGY INCORPORATED", "name": ""}, {"first_name": "", "last_name": "ATMEL CORPORATION", "name": ""}, {"first_name": "", "last_name": "MICROSEMI CORPORATION", "name": ""}, {"first_name": "", "last_name": "MICROCHIP TECHNOLOGY INCORPORATED", "name": ""}, {"first_name": "", "last_name": "MICROSEMI STORAGE SOLUTIONS, INC.", "name": ""}, {"first_name": "", "last_name": "SILICON STORAGE TECHNOLOGY, INC.", "name": ""}, {"first_name": "", "last_name": "MICROCHIP TECHNOLOGY INCORPORATED", "name": ""}, {"first_name": "", "last_name": "MICROCHIP TECHNOLOGY INCORPORATED", "name": ""}, {"first_name": "", "last_name": "SILICON STORAGE TECHNOLOGY, INC.", "name": ""}, {"first_name": "", "last_name": "MICROSEMI CORPORATION", "name": ""}, {"first_name": "", "last_name": "MICROSEMI STORAGE SOLUTIONS, INC.", "name": ""}, {"first_name": "", "last_name": "ATMEL CORPORATION", "name": ""}, {"first_name": "", "last_name": "WELLS FARGO BANK, NATIONAL ASSOCIATION, AS COLLATERAL AGENT", "name": ""}, {"first_name": "", "last_name": "WELLS FARGO BANK, NATIONAL ASSOCIATION", "name": ""}, {"first_name": "", "last_name": "MICROCHIP TECHNOLOGY INC.", "name": ""}, {"first_name": "", "last_name": "MICROSEMI CORPORATION", "name": ""}, {"first_name": "", "last_name": "ATMEL CORPORATION", "name": ""}, {"first_name": "", "last_name": "MICROSEMI STORAGE SOLUTIONS, INC.", "name": ""}, {"first_name": "", "last_name": "SILICON STORAGE TECHNOLOGY, INC.", "name": ""}, {"first_name": "", "last_name": "JPMORGAN CHASE BANK, N.A., AS ADMINISTRATIVE AGENT", "name": ""}, {"first_name": "", "last_name": "WELLS FARGO BANK, NATIONAL ASSOCIATION, AS NOTES COLLATERAL AGENT", "name": ""}, {"first_name": "", "last_name": "JPMORGAN CHASE BANK, N.A., AS ADMINISTRATIVE AGENT", "name": ""}, {"first_name": "", "last_name": "JPMORGAN CHASE BANK, N.A., AS ADMINISTRATIVE AGENT", "name": ""}, {"first_name": "", "last_name": "MICROCHIP TECNOLOGY INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/08"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/318       20060101A I20051008RMEP"}, {"label": "G06F   9/32        20060101A I20051008RMEP"}, {"label": "G06F   9/315       20060101A I20051008RMEP"}, {"label": "G06F   9/35        20060101ALI20060310RMJP"}, {"label": "G06F   9/30        20060101A I20051008RMEP"}, {"label": "G06F   9/34        20060101ALI20060310RMJP"}, {"label": "G06F  12/00        20060101ALI20060310RMJP"}, {"label": "G06F   9/312       20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712220"}, {"primary": false, "label": "712E09028"}, {"primary": false, "label": "712E09036"}, {"primary": false, "label": "712E09024"}, {"primary": false, "label": "712E09078"}, {"primary": false, "label": "712E09074"}, {"primary": false, "label": "712E09027"}, {"primary": false, "label": "712E09033"}, {"primary": false, "label": "712E09034"}], "ecla_classes": [{"label": "G06F   9/30X6"}, {"label": "G06F   9/30A1M"}, {"label": "G06F   9/30R5"}, {"label": "G06F   9/30A2"}, {"label": "G06F   9/30R5D"}, {"label": "G06F   9/30T4T"}, {"label": "G06F   9/30R2"}, {"label": "G06F   9/32A"}, {"label": "G06F   9/32B6"}, {"label": "G06F   9/30T"}], "cpc_classes": [{"label": "G06F   9/3013"}, {"label": "G06F   9/321"}, {"label": "G06F   9/30101"}, {"label": "G06F   9/3012"}, {"label": "G06F   9/30145"}, {"label": "G06F   9/30192"}, {"label": "G06F   9/30149"}, {"label": "G06F   9/30032"}, {"label": "G06F   9/30167"}, {"label": "G06F   9/3004"}, {"label": "G06F   9/325"}, {"label": "G06F   9/30167"}, {"label": "G06F   9/30149"}, {"label": "G06F   9/321"}, {"label": "G06F   9/325"}, {"label": "G06F   9/30032"}, {"label": "G06F   9/30145"}, {"label": "G06F   9/3013"}, {"label": "G06F   9/3004"}, {"label": "G06F   9/3012"}, {"label": "G06F   9/30192"}, {"label": "G06F   9/30101"}, {"label": "G06F   9/30"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1999-03-26", "application_date": "1999-03-26", "family_members": [{"ucid": "EP-1080406-A1", "titles": [{"lang": "DE", "text": "MIKROKONTROLLBEFEHLSSATZ"}, {"lang": "EN", "text": "MICROCONTROLLER INSTRUCTION SET"}, {"lang": "FR", "text": "SEGMENT D'INSTRUCTION POUR MICROCONTROLEUR"}]}, {"ucid": "EP-2296087-A1", "titles": [{"lang": "DE", "text": "Mikrokontrollbefehlssatz"}, {"lang": "EN", "text": "Microcontroller instruction set"}, {"lang": "FR", "text": "Ensemble d'instructions de microcontr\u00f4leur"}]}, {"ucid": "CN-1186718-C", "titles": [{"lang": "EN", "text": "Microcontroller instruction set"}, {"lang": "ZH", "text": "\u5fae\u63a7\u5236\u5668\u6307\u4ee4\u96c6"}]}, {"ucid": "WO-2000058828-A1", "titles": [{"lang": "EN", "text": "MICROCONTROLLER INSTRUCTION SET"}, {"lang": "FR", "text": "SEGMENT D'INSTRUCTION POUR MICROCONTROLEUR"}]}, {"ucid": "JP-2002540523-U", "titles": []}, {"ucid": "EP-2296087-B1", "titles": [{"lang": "FR", "text": "Ensemble d'instructions de microcontr\u00f4leur"}, {"lang": "EN", "text": "Microcontroller instruction set"}, {"lang": "DE", "text": "Mikrokontrollbefehlssatz"}]}, {"ucid": "AT-522860-T", "titles": [{"lang": "EN", "text": "MICRO CONTROL COMMAND SET"}, {"lang": "DE", "text": "MIKROKONTROLLBEFEHLSSATZ"}]}, {"ucid": "US-6708268-B1", "titles": [{"lang": "EN", "text": "Microcontroller instruction set"}]}, {"ucid": "US-7203818-B2", "titles": [{"lang": "EN", "text": "Microcontroller instruction set"}]}, {"ucid": "US-20040177211-A1", "titles": [{"lang": "EN", "text": "Microcontroller instruction set"}]}, {"ucid": "CN-1306640-A", "titles": [{"lang": "EN", "text": "Microcontroller instruction set"}, {"lang": "ZH", "text": "\u5fae\u63a7\u5236\u5668\u6307\u4ee4\u96c6"}]}, {"ucid": "EP-1080406-B1", "titles": [{"lang": "FR", "text": "SEGMENT D'INSTRUCTION POUR MICROCONTROLEUR"}, {"lang": "EN", "text": "MICROCONTROLLER INSTRUCTION SET"}, {"lang": "DE", "text": "MIKROKONTROLLBEFEHLSSATZ"}]}, {"ucid": "KR-20010043826-A", "titles": [{"lang": "KO", "text": "\ub9c8\uc774\ud06c\ub85c \ucee8\ud2b8\ub864\ub7ec \uba85\ub839\uc5b4 \uc9d1\ud569"}, {"lang": "EN", "text": "MICROCONTROLLER INSTRUCTION SET"}]}, {"ucid": "TW-527565-B", "titles": [{"lang": "EN", "text": "Microcontroller instruction set"}]}, {"ucid": "US-7206924-B2", "titles": [{"lang": "EN", "text": "Microcontroller instruction set"}]}, {"ucid": "JP-2002540523-A", "titles": [{"lang": "JA", "text": "\u30de\u30a4\u30af\u30ed\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u547d\u4ee4\u30bb\u30c3\u30c8"}, {"lang": "EN", "text": "Microcontroller instruction set"}]}, {"ucid": "US-20040158692-A1", "titles": [{"lang": "EN", "text": "Microcontroller instruction set"}]}]}