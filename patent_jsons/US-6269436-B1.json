{"patent_number": "US-6269436-B1", "publication_id": 72748864, "family_id": 24278833, "publication_date": "2001-07-31", "titles": [{"lang": "EN", "text": "Superscalar microprocessor configured to predict return addresses from a return stack storage"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11221906\" source=\"national office\"><p>A microprocessor is provided which is configured to predict return addresses for return instructions according to a return stack storage included therein. The return stack storage is a stack structure configured to store return addresses associated with previously detected call instructions. Return addresses may be predicted for return instructions early in the instruction processing pipeline of the microprocessor. In one embodiment, the return stack storage additionally stores a call tag and a return tag with each return address. The call tag and return tag respectively identify call and return instructions associated with the return address. These tags may be compared to a branch tag conveyed to the return prediction unit upon detection of a branch misprediction. The results of the comparisons may be used to adjust the contents of the return stack storage with respect to the misprediction. The microprocessor may continue to predict return addresses correctly following a mispredicted branch instruction.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72592155\"><p>A microprocessor is provided which is configured to predict return addresses for return instructions according to a return stack storage included therein. The return stack storage is a stack structure configured to store return addresses associated with previously detected call instructions. Return addresses may be predicted for return instructions early in the instruction processing pipeline of the microprocessor. In one embodiment, the return stack storage additionally stores a call tag and a return tag with each return address. The call tag and return tag respectively identify call and return instructions associated with the return address. These tags may be compared to a branch tag conveyed to the return prediction unit upon detection of a branch misprediction. The results of the comparisons may be used to adjust the contents of the return stack storage with respect to the misprediction. The microprocessor may continue to predict return addresses correctly following a mispredicted branch instruction.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00001\" num=\"1\"><claim-text>1. A method comprising:</claim-text><claim-text>storing a first return address corresponding to a first call instruction in a return stack; </claim-text><claim-text>predicting said first return address for a first return instruction, said first return instruction subsequent to said first call instruction in program order; and </claim-text><claim-text>storing a second return address in said return stack, said second return address corresponding to a second call instruction subsequent to said first return instruction in program order, said storing said second return address including retaining said first return address in said return stack. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00002\" num=\"2\"><claim-text>2. The method as recited in claim <b>1</b> further comprising predicting said second return address for a second return instruction subsequent to said second call instruction in program order.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00003\" num=\"3\"><claim-text>3. The method as recited in claim <b>2</b> further comprising storing a third return address in said return stack, said third return address corresponding to a third call instruction prior to said first call instruction in program order.</claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00004\" num=\"4\"><claim-text>4. The method as recited in claim <b>3</b> further comprising predicting said third return address for a third return instruction, said third return instruction subsequent to said second return instruction in program order.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00005\" num=\"5\"><claim-text>5. The method as recited in claim <b>1</b> wherein said storing said first return address comprises pushing said first return address onto a top of said return stack.</claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00006\" num=\"6\"><claim-text>6. The method as recited in claim <b>5</b> wherein said storing said second return address comprises pushing said second return address onto said top of said return stack.</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00007\" num=\"7\"><claim-text>7. The method as recited in claim <b>6</b> wherein said storing said second return address further comprises said first return address becoming second to said top of said return stack.</claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00008\" num=\"8\"><claim-text>8. The method as recited in claim <b>1</b> further comprising:</claim-text><claim-text>retiring said first return instruction; and </claim-text><claim-text>deleting said first return address from said return stack responsive to said retiring. </claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00009\" num=\"9\"><claim-text>9. The method as recited in claim <b>8</b> wherein said retiring occurs subsequent to said storing said second return address.</claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00010\" num=\"10\"><claim-text>10. A microprocessor comprising:</claim-text><claim-text>a branch prediction unit configured to identify call and return instructions; and </claim-text><claim-text>a return prediction unit coupled to receive an indication of said call and return instructions from said branch prediction unit, said return prediction unit including a return stack, wherein said return prediction unit is configured to store a first return address in a first entry of said return stack in response to a first indication of a first call instruction corresponding to said first return address, and wherein said return prediction unit is configured to predict said first return address for a first return instruction in response to a second indication of said first return instruction, said first return instruction subsequent to said first call instruction in program order, and wherein said return prediction unit is configured to store a second return address in a second entry of said return stack in response to a third indication of a second call instruction corresponding to said second return address, said second call instruction subsequent to said first return instruction in program order, and wherein said return prediction unit is configured to retain said first return address in said first entry by storing said second return address in said second entry. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00011\" num=\"11\"><claim-text>11. The microprocessor as recited in claim <b>10</b> wherein said return prediction unit is configured to predict said second return address for a second return instruction in response to a fourth indication of said second return instruction, said second return instruction subsequent to said second call instruction in program order.</claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00012\" num=\"12\"><claim-text>12. The microprocessor as recited in claim <b>11</b> wherein said return prediction unit is configured to store a third return address in a third entry of said return stack in response to a fifth indication of said third return instruction, said third return address corresponding to a third call instruction prior to said first call instruction in program order.</claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00013\" num=\"13\"><claim-text>13. The microprocessor as recited in claim <b>12</b> wherein said return prediction unit is configured to predict said third return address for a third return instruction in response to a sixth indication of said third return instruction, said third return instruction subsequent to said second return instruction in program order.</claim-text></claim>"}, {"num": 14, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00014\" num=\"14\"><claim-text>14. The microprocessor as recited in claim <b>10</b> further comprising a reorder buffer coupled to said return prediction unit, said reorder buffer configured to transmit a retire indication indicating that said first return instruction is retired, and wherein said return prediction unit is configured to delete said first return address from said first entry of said return stack responsive to said retire indication.</claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00015\" num=\"15\"><claim-text>15. The microprocessor as recited in claim <b>14</b> wherein said retire indication is received subsequent to storing said second return address in said second entry of said return stack.</claim-text></claim>"}, {"num": 16, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00016\" num=\"16\"><claim-text>16. A microprocessor comprising:</claim-text><claim-text>a branch prediction unit configured to identify call and return instructions; and </claim-text><claim-text>a return prediction unit including a return stack, said return prediction unit coupled to receive an indication of each of said call and return instructions from said branch prediction unit, and wherein said return prediction unit is configured to push a return address onto said return stack in response to each call instruction, said return stack retaining other return addresses even if said other return addresses have been used as return address predictions for return instructions. </claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00017\" num=\"17\"><claim-text>17. The microprocessor as recited in claim <b>16</b> wherein said return prediction unit is configured to predict a return address from said return stack in response to each return instruction.</claim-text></claim>"}, {"num": 18, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00018\" num=\"18\"><claim-text>18. The microprocessor as recited in claim <b>16</b> further comprising a reorder buffer coupled to said return prediction unit, said reorder buffer configured to transmit a retire indication indicating that a return instruction is retired, and wherein said return prediction unit is configured to delete a corresponding return address from return stack responsive to said retire indication.</claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00019\" num=\"19\"><claim-text>19. The microprocessor as recited in claim <b>18</b> wherein said retire indication comprises a return tag identifying said return instruction being retired, and wherein said return prediction unit is configured to store said return tag in said return stack in response to predicting said corresponding return address for said return instruction being retired.</claim-text></claim>"}, {"num": 20, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00020\" num=\"20\"><claim-text>20. The microprocessor as recited in claim <b>14</b> wherein said retire indication comprises a return tag identifying said first return instruction, and wherein said return prediction unit is configured to store said return tag in said return stack in response to predicting said first return address for said first return instruction.</claim-text></claim>"}, {"num": 21, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00021\" num=\"21\"><claim-text>21. The method as recited in claim <b>8</b> wherein said predicting further comprises storing a return tag identifying said first return instruction in said return stack, and wherein said retiring said first return instruction comprises transmitting said return tag to said return stack.</claim-text></claim>"}, {"num": 22, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00022\" num=\"22\"><claim-text>22. A computer system comprising:</claim-text><claim-text>a microprocessor comprising: </claim-text><claim-text>a branch prediction unit configured to identify call and return instructions; and </claim-text><claim-text>a return prediction unit including a return stack, said return prediction unit coupled to receive an indication of each of said call and return instructions from said branch prediction unit, and wherein said return prediction unit is configured to push a return address onto said return stack in response to each call instruction, said return stack retaining other return addresses even if said other return addresses have been used as return address predictions for return instructions; and </claim-text><claim-text>an input/output device for communicating between said computer system and another computer system. </claim-text></claim>"}, {"num": 23, "parent": 22, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00023\" num=\"23\"><claim-text>23. The computer system as recited in claim <b>22</b> wherein said input/output device is a modem.</claim-text></claim>"}, {"num": 24, "parent": 22, "type": "dependent", "paragraph_markup": "<claim id=\"US-6269436-B1-CLM-00024\" num=\"24\"><claim-text>24. The computer system as recited in claim <b>22</b> further comprising a second processor including:</claim-text><claim-text>a branch prediction unit configured to identify call and return instructions; and </claim-text><claim-text>a return prediction unit including a return stack, said return prediction unit coupled to receive an indication of each of said call and return instructions from said branch prediction unit, and wherein said return prediction unit is configured to push a return address onto said return stack in response to each call instruction, said return stack retaining other return addresses even if said other return addresses have been used as return address predictions for return instructions.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54609621\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This application is a continuation of U.S. patent application Ser. No. 09/153,770, filed on Sep. 15, 1998, which is a continuation of U.S. patent application Ser. No. 08/570,242, filed on Dec. 11, 1995 now U.S. Pat. No. 5,864,707.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention is related to the field of microprocessors and, more particularly, to speculative return address prediction mechanisms for predicting the address of a return instruction within microprocessors.</p><p>2. Description of the Relevant Art</p><p>Superscalar microprocessors achieve high performance by executing multiple instructions concurrently and by choosing the shortest possible clock cycle consistent with the design. As used herein, the term \u201cclock cycle\u201d refers to an interval of time in which the various stages of the instruction processing pipelines complete their tasks. Instructions and computed values are captured by memory elements (such as registers or arrays) according to a clock signal defining the clock cycle. For example, a memory element may capture a value according to the rising or falling edge of the clock signal.</p><p>Many superscalar microprocessor manufacturers design their microprocessors in accordance with the x86 microprocessor architecture. The x86 microprocessor architecture is widely accepted in the computer industry, and therefore a large body of software exists which runs only on microprocessors embodying this architecture. Microprocessors designed in accordance with the x86 architecture advantageously retain compatibility with this body of software. As will be appreciated by those skilled in the art, the x86 architecture includes a \u201cstack\u201d area in memory. The stack is useful for passing information between a program and a subroutine called by that program, among other things. A subroutine performs a function that a program requires, and then returns to the instruction following the call to the subroutine. Therefore, a subroutine may be called from multiple places within a program to perform its function. A \u201csubroutine call instruction\u201d or, more briefly, a \u201ccall instruction\u201d is an instruction used to call a subroutine. The address of the instruction subsequent to the call instruction is saved in a storage location. The address of the instruction subsequent to the call instruction is referred to as the \u201creturn address\u201d. The instruction which causes program execution to resume at the return address is a \u201creturn instruction\u201d.</p><p>In the x86 architecture, the ESP register points to the address in memory which currently forms the top of the stack. A stack structure is a Last-In, First-Out (LIFO) structure in which values are placed on the stack in a certain order and are removed from the stack in the reverse order. Therefore, the top of the stack contains the last item placed on the stack. The action of placing a value on the stack is known as a \u201cpush\u201d, and requesting that a push be performed is a \u201cpush command\u201d. The action of removing a value from the stack is referred to as a \u201cpop\u201d, and requesting that a pop be performed is a \u201cpop command\u201d. When a push command is performed, the ESP register is decremented by the size (in bytes) of the value specified by the push command. The value is then stored at the address pointed to by the decremented ESP register value. When a pop command is performed, a number of bytes specified by the pop command are copied from the top of the stack to a destination specified by the pop command, and then the ESP register is incremented by the number of bytes.</p><p>An example of the use of push and pop commands in the x86 microprocessor architecture are the subroutine call and return instructions, as mentioned above. In the x86 microprocessor architecture, a typical subroutine call involves pushing the operands for the subroutine onto the stack, then pushing the return address onto the stack. The subroutine is called and executes, accessing any operands it may need by indexing into the stack. After completing execution, the subroutine pops the next instruction address from the top of the stack and causes that address to be fetched by the microprocessor.</p><p>The x86 microprocessor architecture, similar to other microprocessor architectures, contains branch instructions. A branch instruction is an instruction which causes the next instruction to be fetched from one of at least two possible addresses. One address is the address immediately following the branch instruction. This address is referred to as the \u201cnext sequential address\u201d. The second address is specified by the branch instruction, and is referred to as the \u201cbranch target address\u201d or simply the \u201ctarget address\u201d. Branch instructions typically select between the target address and the next sequential address based on a particular condition flag which is set by a previously executed instruction.</p><p>Since the next instruction to be executed after the branch instruction is not known until the branch instruction executes, superscalar microprocessors either stall instruction fetching until the branch instruction executes (reducing performance) or predict which address the branch instruction will select when executed. When the prediction method is chosen, the resulting superscalar microprocessor may speculatively fetch and execute instructions residing at the predicted address. If the prediction is incorrect, or \u201cmispredicted\u201d (as determined when the branch instruction executes), then the instructions following the branch instruction are discarded from the instruction processing pipeline and the correct instructions are fetched. Branch instructions are typically predicted when that branch instruction is decoded or when instructions are fetched, depending on the branch prediction scheme and the configuration of the microprocessor. Subroutine call and return instructions may be considered to be branches which always select the target address.</p><p>A particularly difficult type of branch instruction to predict in the x86 microprocessor architecture is the RET instruction (the return instruction defined for the x86 microprocessor architecture). The return instruction is a pop command, as described above. This type of branch instruction is difficult to predict because the target address (or return address) is not readily available when the instruction is decoded, unlike some other branch instructions. Instead, the return address is stored on the stack in a location that will be indicated by the value in the ESP register when the return instruction is executed. The value of the ESP register at the time the return instruction is decoded and the value of the ESP register at the time the return instruction is executed may differ. For similar reasons, the return address may be difficult to predict in other microprocessor architectures as well.</p><p>Return address prediction is further complicated by the use of \u201cfake return\u201d instructions. Return instructions are normally used in conjunction with the CALL instruction. The CALL instruction is another special type of branch instruction which causes the address of the instruction immediately following the call to be pushed onto the stack, and then instructions are fetched from an address specified by the CALL instruction (i.e. the CALL instruction is the subroutine call instruction defined for the x86 microprocessor architecture). The CALL instruction is therefore a push command, as described above, as well as a branch instruction. The instruction address placed on the stack by the CALL instruction is the address intended to be used by the return instruction as the return address. The CALL instruction can therefore be used to call a subroutine in a program, and the subroutine typically ends with a return instruction which causes instruction execution to resume at the instruction immediately following the CALL instruction.</p><p>\u201cFake return\u201d instructions are return instructions which are executed when a return address other than a return address provided by a CALL instruction is at the top of the stack. This address may be placed on the stack by executing a PUSH instruction, for example. A mechanism for predicting the target address of a return instruction is desired.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by a microprocessor in accordance with the present invention. The present microprocessor employs a return prediction unit configured to predict return addresses for return instructions according to a return stack storage included therein. The return stack storage is a stack structure configured to store return addresses associated with previously detected call instructions. Advantageously, return addresses may be predicted for return instructions early in the instruction processing pipeline of the microprocessor. Instructions residing at the target of the return instruction may be fetched more quickly than was previously achievable using conventional superscalar microprocessors. Performance may be increased according to the decreased time between execution of the return instruction and execution of the instructions stored at the return address.</p><p>In one embodiment, the return stack storage additionally stores a call tag and a return tag with each return address. The call tag and return tag respectively identify call and return instructions associated with the return address. These tags may be compared to a branch tag conveyed to the return prediction unit upon detection of a branch misprediction. The results of the comparisons may be used to adjust the contents of the return stack storage with respect to the misprediction. Advantageously, the return prediction unit recovers from mispredicted branches. In other words, the return prediction unit may continue to predict return addresses correctly following a mispredicted branch instruction. Because mispredicted branch recovery is often an important feature of superscalar microprocessors, performance may be increased by recovering the return prediction unit.</p><p>Broadly speaking, the present invention contemplates a superscalar microprocessor comprising a branch prediction unit and a return prediction unit. The branch prediction unit is configured to predict branch instructions taken or not taken, wherein branch instructions include call instructions and return instructions. Coupled to recieve an indication of the call instructions and the return instructions from the branch prediction unit, the return prediction unit is configured to store return addresses corresponding to the call instructions in a return stack structure. Furthermore, the return prediction unit is configured to predict a return address corresponding to one of the return instructions from the stored return addresses.</p><p>The present invention further contemplates a computer system, comprising a microprocessor coupled to a main memory. The microprocessor includes a return prediction structure configured to predict a return address of a return instruction from a plurality of stored return addresses. The stored return addresses comprise return addresses corresponding to previously fetched call instructions. The main memory is configured to store instructions for execution by the microprocessor and further configured to store data for manipulation by the microprocessor.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of one embodiment of a superscalar microprocessor including an instruction cache and a branch prediction unit.</p><p>FIG. 2 is a block diagram of one embodiment of a return prediction unit which may be included within the instruction cache or the branch prediction unit shown in FIG. 1</p><p>FIG. 2A is a diagram of another embodiment of a return stack storage which may be included in the return prediction unit shown in FIG. <b>2</b>.</p><p>FIG. 3 is a diagram of instructions, including call and return instructions, illustrating instruction flow according to call and return instructions.</p><p>FIG. 4A is an exemplary instruction stream used to illustrate the function of the present return prediction unit.</p><p>FIG. 4B shows the contents of the return address storage shown in FIG. 2 prior to executing the instruction stream shown in FIG. <b>4</b>A.</p><p>FIG. 4C shows the contents of the return address storage shown in FIG. 2 after the execution of several instructions from the exemplary instruction stream shown in FIG. <b>4</b>A.</p><p>FIG. 4D shows the contents of the return address storage shown in FIG. 2 after the execution of several more instructions from the exemplary instruction stream shown in FIG. <b>4</b>A.</p><p>FIG. 4E shows the contents of the return address storage shown in FIG. 2 after completing execution of the exemplary instruction stream shown in FIG. <b>4</b>A.</p><p>FIGS. 5-67 depict a superscalar microprocessor.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>Turning now to FIG. 1, a block diagram of one embodiment of a superscalar microprocessor <b>200</b> in accordance with the present invention is shown. As illustrated in the embodiment of FIG. 1, superscalar microprocessor <b>200</b> includes a prefetch/predecode unit <b>202</b> and a branch prediction unit <b>220</b> coupled to an instruction cache <b>204</b>. An instruction alignment unit <b>206</b> is coupled between instruction cache <b>204</b> and a plurality of decode units <b>208</b>A-<b>208</b>D (referred to collectively as decode units <b>208</b>). Each decode unit <b>208</b>A-<b>208</b>D is coupled to respective reservation station units <b>210</b>A-<b>210</b>D (referred to collectively as reservation stations <b>210</b>), and each reservation station <b>210</b>A-<b>210</b>D is coupled to a respective functional unit <b>212</b>A-<b>212</b>D (referred to collectively as functional units <b>212</b>). Decode units <b>208</b>, reservation stations <b>210</b>, and functional units <b>212</b> are further coupled to a reorder buffer <b>216</b>, a register file <b>218</b> and a load/store unit <b>222</b>. A data cache <b>224</b> is finally shown coupled to load/store unit <b>222</b>, and an MROM unit <b>209</b> is shown coupled to instruction alignment unit <b>206</b>.</p><p>Generally speaking, instruction cache <b>204</b> is a high speed cache memory provided to temporarily store instructions prior to their dispatch to decode units <b>208</b>. In one embodiment, instruction cache <b>204</b> is configured to cache up to 32 kilobytes of instruction code organized in lines of 16 bytes each (where each byte consists of 8 bits). During operation, instruction code is provided to instruction cache <b>204</b> by prefetching code from a main memory (not shown) through prefetch/predecode unit <b>202</b>. It is noted that instruction cache <b>204</b> could be implemented in a set-associative, a fully-associative, or a direct-mapped configuration.</p><p>Prefetch/predecode unit <b>202</b> is provided to prefetch instruction code from the main memory for storage within instruction cache <b>204</b>. In one embodiment, prefetch/predecode unit <b>202</b> is configured to burst 64-bit wide code from the main memory into instruction cache <b>204</b>. It is understood that a variety of specific code prefetching techniques and algorithms may be employed by prefetch/predecode unit <b>202</b>.</p><p>As prefetch/predecode unit <b>202</b> fetches instructions from the main memory, it generates three predecode bits associated with each byte of instruction code: a start bit, an end bit, and a \u201cfunctional\u201d bit. The predecode bits form tags indicative of the boundaries of each instruction. The predecode tags may also convey additional information such as whether a given instruction can be decoded directly by decode units <b>208</b> or whether the instruction must be executed by invoking a microcode procedure controlled by MROM unit <b>209</b>, as will be described in greater detail below.</p><p>Table 1 indicates one encoding of the predecode tags. As indicated within the table, if a given byte is the first byte of an instruction, the start bit for that byte is set. If the byte is the last byte of an instruction, the end bit for that byte is set. If a particular instruction cannot be directly decoded by the decode units <b>208</b>, the functional bit associated with the first byte of the instruction is set. On the other hand, if the instruction can be directly decoded by the decode units <b>208</b>, the functional bit associated with the first byte of the instruction is cleared. The functional bit for the second byte of a particular instruction is cleared if the opcode is the first byte, and is set if the opcode is the second byte. It is noted that in situations where the opcode is the second byte, the first byte is a prefix byte. The functional bit values for instruction byte numbers <b>3</b>-<b>8</b> indicate whether the byte is a MODRM or an SIB byte, or whether the byte contains displacement or immediate data.</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE 1</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Encoding of Start, End and Functional Bits</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"6\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"4\" colwidth=\"49PT\"></colspec><colspec align=\"center\" colname=\"5\" colwidth=\"70PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Instr.</entry><entry morerows=\"0\" valign=\"top\">Start</entry><entry morerows=\"0\" valign=\"top\">End</entry><entry morerows=\"0\" valign=\"top\">Functional</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Byte</entry><entry morerows=\"0\" valign=\"top\">Bit</entry><entry morerows=\"0\" valign=\"top\">Bit</entry><entry morerows=\"0\" valign=\"top\">Bit</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Number</entry><entry morerows=\"0\" valign=\"top\">Value</entry><entry morerows=\"0\" valign=\"top\">Value</entry><entry morerows=\"0\" valign=\"top\">Value</entry><entry morerows=\"0\" valign=\"top\">Meaning</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"5\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"6\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"4\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"70PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">X</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">Fast decode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">X</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">MROM instr.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">X</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">Opcode is first</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">byte</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">X</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">Opcode is this</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">byte, first</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">byte is prefix</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">3-8</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">X</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">Mod R/M or</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SIB byte</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">3-8</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">X</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">Displacement or</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">immediate data;</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">the second</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">functional bit</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">set in bytes</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">3-8 indicates</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">immediate data</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1-8</entry><entry morerows=\"0\" valign=\"top\">X</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">X</entry><entry morerows=\"0\" valign=\"top\">Not last byte</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">of instruction</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1-8</entry><entry morerows=\"0\" valign=\"top\">X</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">X</entry><entry morerows=\"0\" valign=\"top\">Last byte of</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">instruction</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"5\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>As stated previously, in one embodiment certain instructions within the x86 instruction set may be directly decoded by decode unit <b>208</b>. These instructions are referred to as \u201cfast path\u201d instructions. The remaining instructions of the x86 instruction set are referred to as \u201cMROM instructions\u201d. MROM instructions are executed by invoking MROM unit <b>209</b>. More specifically, when an MROM instruction is encountered, MROM unit <b>209</b> parses and serializes the instruction into a subset of defined fast path instructions to effectuate a desired operation. A listing of exemplary x86 instructions categorized as fast path instructions as well as a description of the manner of handling both fast path and MROM instructions will be provided further below.</p><p>Instruction alignment unit <b>206</b> is provided to channel variable byte length instructions from instruction cache <b>204</b> to fixed issue positions formed by decode units <b>208</b>A-<b>208</b>D. In one embodiment, instruction alignment unit <b>206</b> independently and in parallel selects instructions from three groups of instruction bytes provided by instruction cache <b>204</b> and arranges these bytes into three groups of preliminary issue positions. Each group of issue positions is associated with one of the three groups of instruction bytes. The preliminary issue positions are then merged together to form the final issue positions, each of which is coupled to one of decode units <b>208</b>.</p><p>Before proceeding with a detailed description of the return address prediction mechanism employed within microprocessor <b>200</b>, general aspects regarding other subsystems employed within the exemplary superscalar microprocessor <b>200</b> of FIG. 1 will be described. For the embodiment of FIG. 1, each of the decode units <b>208</b> includes decoding circuitry for decoding the predetermined fast path instructions referred to above. In addition, each decode unit <b>208</b>A-<b>208</b>D routes displacement and immediate data to a corresponding reservation station unit <b>210</b>A-<b>210</b>D. Output signals from the decode units <b>208</b> include bit-encoded execution instructions for the functional units <b>212</b> as well as operand address information, immediate data and/or displacement data.</p><p>The superscalar microprocessor of FIG. 1 supports out of order execution, and thus employs reorder buffer <b>216</b> to keep track of the original program sequence for register read and write operations, to implement register renaming, to allow for speculative instruction execution and branch misprediction recovery, and to facilitate precise exceptions. As will be appreciated by those of skill in the art, a temporary storage location within reorder buffer <b>216</b> is reserved upon decode of an instruction that involves the update of a register to thereby store speculative register states. Reorder buffer <b>216</b> may be implemented in a first-in-first-out configuration wherein speculative results move to the \u201cbottom\u201d of the buffer as they are validated and written to the register file, thus making room for new entries at the \u201ctop\u201d of the buffer. Other specific configurations of reorder buffer <b>216</b> are also possible, as will be described further below. If a branch prediction is incorrect, the results of speculatively-executed instructions along the mispredicted path can be invalidated in the buffer before they are written to register file <b>218</b>.</p><p>The bit-encoded execution instructions and immediate data provided at the outputs of decode units <b>208</b>A-<b>208</b>D are routed directly to respective reservation station units <b>210</b>A-<b>210</b>D. In one embodiment, each reservation station unit <b>210</b>A-<b>210</b>D is capable of holding instruction information (i.e., bit encoded execution bits as well as operand values, operand tags and/or immediate data) for up to three pending instructions awaiting issue to the corresponding functional unit. It is noted that for the embodiment of FIG. 1, each decode unit <b>208</b>A-<b>208</b>D is associated with a dedicated reservation station unit <b>210</b>A-<b>210</b>D, and that each reservation station unit <b>210</b>A-<b>210</b>D is similarly associated with a dedicated functional unit <b>212</b>A-<b>212</b>D. Accordingly, four dedicated \u201cissue positions\u201d are formed by decode units <b>208</b>, reservation station units <b>210</b> and functional units <b>212</b>. Instructions aligned and dispatched to issue position <b>0</b> through decode unit <b>208</b>A are passed to reservation station unit <b>210</b>A and subsequently to functional unit <b>212</b>A for execution. Similarly, instructions aligned and dispatched to decode unit <b>208</b>B are passed to reservation station unit <b>210</b>B and into functional unit <b>212</b>B, and so on.</p><p>Upon decode of a particular instruction, if a required operand is a register location, register address information is routed to reorder buffer <b>216</b> and register file <b>218</b> simultaneously. Those of skill in the art will appreciate that the x86 register file includes eight 32 bit real registers (i.e., typically referred to as EAX, EBX, ECX, EDX, EBP, ESI, EDI and ESP). Reorder buffer <b>216</b> contains temporary storage locations for results which change the contents of these registers to thereby allow out of order execution. A temporary storage location of reorder buffer <b>216</b> is reserved for each instruction which, upon decode, is determined to modify the contents of one of the real registers. Therefore, at various points during execution of a particular program, reorder buffer <b>216</b> may have one or more locations which contain the speculatively executed contents of a given register. If following decode of a given instruction it is determined that reorder buffer <b>216</b> has a previous location or locations assigned to a register used as an operand in the given instruction, the reorder buffer <b>216</b> forwards to the corresponding reservation station either: 1) the value in the most recently assigned location, or 2) a tag for the most recently assigned location if the value has not yet been produced by the functional unit that will eventually execute the previous instruction. If the reorder buffer has a location reserved for a given register, the operand value (or tag) is provided from reorder buffer <b>216</b> rather than from register file <b>218</b>. If there is no location reserved for a required register in reorder buffer <b>216</b>, the value is taken directly from register file <b>218</b>. If the operand corresponds to a memory location, the operand value is provided to the reservation station unit through load/store unit <b>222</b>.</p><p>Details regarding suitable reorder buffer implementations may be found within the Publication \u201cSuperscalar Microprocessor Design\u201d by Mike Johnson, Prentice-Hall, Englewood Cliffs, N.J., 1991, and within the co-pending, commonly assigned patent application entitled \u201cHigh Performance Superscalar Microprocessor\u201d, Ser. No. 08/146,382, filed Oct. 29, 1993 by Witt, et al., abandoned and continued in application Ser. No. 501,243 filed Jul. 10, 1995, now U.S. Pat. No. 5,651,125. These documents are incorporated herein by reference in their entirety.</p><p>Reservation station units <b>210</b>A-<b>210</b>D are provided to temporarily store instruction information to be speculatively executed by the corresponding functional units <b>212</b>A-<b>212</b>D. As stated previously, each reservation station unit <b>210</b>A-<b>210</b>D may store instruction information for up to three pending instructions. Each of the four reservation stations <b>210</b>A-<b>210</b>D contain locations to store bit-encoded execution instructions to be speculatively executed by the corresponding functional unit and the values of operands. If a particular operand is not available, a tag for that operand is provided from reorder buffer <b>216</b> and is stored within the corresponding reservation station until the result has been generated (i.e., by completion of the execution of a previous instruction). It is noted that when an instruction is executed by one of the functional units <b>212</b>A-<b>212</b>D, the result of that instruction is passed directly to any reservation station units <b>210</b>A-<b>210</b>D that are waiting for that result at the same time the result is passed to update reorder buffer <b>216</b> (this technique is commonly referred to as \u201cresult forwarding\u201d). Instructions are issued to functional units for execution after the values of any required operand(s) are made available. That is, if an operand associated with a pending instruction within one of the reservation station units <b>210</b>A-<b>210</b>D has been tagged with a location of a previous result value within reorder buffer <b>216</b> which corresponds to an instruction which modifies the required operand, the instruction is not issued to the corresponding functional unit <b>212</b> until the operand result for the previous instruction has been obtained. Accordingly, the order in which instructions are executed may not be the same as the order of the original program instruction sequence. Reorder buffer <b>216</b> ensures that data coherency is maintained in situations where read-after-write dependencies occur.</p><p>In one embodiment, each of the functional units <b>212</b> is configured to perform integer arithmetic operations of addition and subtraction, as well as shifts, rotates, logical operations, and branch operations. It is noted that a floating point unit (not shown) may also be employed to accommodate floating point operations.</p><p>Each of the functional units <b>212</b> also provides information regarding the execution of conditional branch instructions to the branch prediction unit <b>220</b>. If a branch prediction was incorrect, branch prediction unit <b>220</b> flushes instructions subsequent to the mispredicted branch that have entered the instruction processing pipeline, and causes prefetch/predecode unit <b>202</b> to fetch the required instructions from instruction cache <b>204</b> or main memory. It is noted that in such situations, results of instructions in the original program sequence which occur after the mispredicted branch instruction are discarded, including those which were speculatively executed and temporarily stored in load/store unit <b>222</b> and reorder buffer <b>216</b>. Exemplary configurations of suitable branch prediction mechanisms are well known.</p><p>Results produced by functional units <b>212</b> are sent to the reorder buffer <b>216</b> if a register value is being updated, and to the load/store unit <b>222</b> if the contents of a memory location is changed. If the result is to be stored in a register, the reorder buffer <b>216</b> stores the result in the location reserved for the value of the register when the instruction was decoded. As stated previously, results are also broadcast to reservation station units <b>210</b>A-<b>210</b>D where pending instructions may be waiting for the results of previous instruction executions to obtain the required operand values.</p><p>Generally speaking, load/store unit <b>222</b> provides an interface between functional units <b>212</b>A-<b>212</b>D and data cache <b>224</b>. In one embodiment, load/store unit <b>222</b> is configured with a load/store buffer with eight storage locations for data and address information for pending loads or stores. Decode units <b>208</b> arbitrate for access to the load/store unit <b>222</b>. When the buffer is full, a decode unit must wait until the load/store unit <b>222</b> has room for the pending load or store request information. The load/store unit <b>222</b> also performs dependency checking for load instructions against pending store instructions to ensure that data coherency is maintained.</p><p>Data cache <b>224</b> is a high speed cache memory provided to temporarily store data being transferred between load/store unit <b>222</b> and the main memory subsystem. In one embodiment, data cache <b>224</b> has a capacity of storing up to sixteen kilobytes of data. It is understood that data cache <b>224</b> may be implemented in a variety of specific memory configurations, including a set associative configuration.</p><p>Turning now to FIG. 2, one embodiment of a return prediction unit <b>250</b> is shown. In one embodiment of microprocessor <b>200</b>, return prediction unit <b>250</b> is included within instruction cache <b>204</b>. In another embodiment of microprocessor <b>200</b>, return prediction unit <b>250</b> is included within branch prediction unit <b>220</b>. Generally speaking, return prediction unit <b>250</b> is configured to provide return address predictions for return instructions. In embodiments of microprocessor <b>200</b> employing the x86 microprocessor architecture, return instructions include the RET instruction and the IRET instruction. Return prediction unit <b>250</b> stacks return addresses associated with call instructions within a return stack storage <b>252</b>, and predicts the return address associated with a return instructions based on the recorded return addresses. Additionally, return prediction unit <b>250</b> is configured to recover from mispredicted branches and call instructions for which the target is mispredicted. Following detection of the mispredicted instruction, return stack storage <b>252</b> accurately reflects call and return instructions detected prior to the mispredicted instruction and has discarded call and return instructions subsequent to the mispredicted instruction. When a return instruction is mispredicted by return prediction unit <b>250</b> (e.g. a fake return has been encountered), entries within return stack storage <b>252</b> are invalidated. Advantageously, return addresses may be predicted early in the instruction processing pipeline of microprocessor <b>200</b>. It is noted that in embodiments of microprocessor <b>200</b> employing the x86 microprocessor architecture, call instructions include the CALL instruction and the INT instruction.</p><p>In one embodiment, return stack storage <b>252</b> includes several fields within each entry (or storage location). It is noted that return stack storage <b>252</b> may employ multiple registers as its storage locations, or the storage locations may be rows of a storage array. In one embodiment, return stack storage <b>252</b> includes eight entries. Each entry includes a return program counter (or return PC), a call tag, a return tag, and several valid bits. The return PC is the return address associated with the call instruction represented by the return stack entry. The CV valid bit indicates, when set, that a call instruction has been detected. The CV valid bit serves to indicate that the entry includes valid information. For example, if the CV bit is set, then the return PC and call tag are valid. The RV valid bit indicates, when set, that the entry has been used as a prediction for a return instruction. The RV valid bit further indicates that the return tag is valid. The CRV valid bit indicates, when set, that the call instruction associated with this entry has been retired by reorder buffer <b>216</b>.</p><p>The call and return tags are branch tags associated with the respective call and return instruction represented by a particular entry. It is noted that branch prediction unit <b>220</b> assigns a branch tag to each branch, call, and return instruction. A branch tag is a number indicative of the order of a particular predicted branch instruction with respect to other predicted branch instructions. The branch tags associated with two such instructions may be compared to determine which of the two instructions is first in program order. In one embodiment, the branch tag associated with a particular instruction is conveyed with each instruction through the instruction processing pipelines of microprocessor <b>200</b>.</p><p>Each non-branch instruction receives the branch tag associated with the most recently predicted branch when that instruction is dispatched. In one specific embodiment, the branch tag comprises four bits. If all branch tags are assigned to outstanding branch instructions, and another branch instruction is detected, then the instruction processing pipeline of microprocessor <b>200</b> is stalled until a branch tag becomes available.</p><p>A branch tag becomes available in a number of ways. If a branch instruction is detected as mispredicted, the branch tag associated with that instruction and subsequent branch tags become available. Subsequent branch tags become available because instructions subsequent to a mispredicted branch are flushed (or deleted) from the instruction processing pipeline. If a branch instruction is retired by reorder buffer <b>216</b>, then the branch tag associated with that instruction becomes available. As used herein, the term \u201cmispredicted branch\u201d refers to a branch, call, or return instruction for which the target address has been mispredicted. A branch may be mispredicted because the speculatively generated target address is incorrect. Additionally, a branch may be mispredicted because it was predicted to be taken (i.e. the next instruction to be executed resides at the target address) and the branch is found to be not taken. Alternatively, a branch may be mispredicted because it was predicted to be not taken (i.e. the next instruction to be executed resides in memory contiguous to the branch instruction) and the branch is found to be taken.</p><p>Return prediction unit <b>250</b> further includes a return stack control unit <b>254</b>, an adder circuit <b>256</b>, a multiplexor <b>258</b>, and a comparator block <b>260</b>. Return stack control unit <b>254</b> is configured to control the storage of data within return stack storage <b>252</b>. Adder circuit <b>256</b> and multiplexor <b>258</b> are configured to generate a return PC for a particular entry during a clock cycle in which the entry is being allocated to a particular call instruction. Comparator block <b>260</b> is used to recover from mispredicted branch instructions.</p><p>Return stack control unit <b>254</b> is coupled to return stack storage <b>252</b> via a data bus <b>262</b> and a pointer bus <b>264</b>. Data bus <b>262</b> allows the reading and writing of data into each of the storage locations (or entries) within return stack storage <b>252</b>. Control signals conveyed along with the data upon data bus <b>262</b> indicate a read or write operation as well as which entry or entries is selected. Pointer bus <b>264</b> conveys a pointer indicative of the \u201ctop\u201d of return stack storage <b>252</b>. The top of return stack storage <b>252</b> is the entry within return stack storage <b>252</b> which contains the most recently allocated call instruction data. The entry above the entry indicated by return pointer <b>264</b> does not contain valid data.</p><p>Additionally, return stack control unit <b>254</b> receives a plurality of buses from other units within microprocessor <b>200</b>. A call bus <b>266</b> and a return bus <b>268</b> convey call and return signals from branch prediction unit <b>220</b>. The call and return signals are indicative, when asserted, of a call and return instruction (respectively) detected by branch prediction unit <b>220</b>. In one embodiment, branch prediction unit <b>220</b> employs a branch prediction structure similar to that described within the commonly assigned, co-pending patent application entitled: \u201cA Way Prediction Unit and Method for Operating Same\u201d, Ser. No. 08/420,666, filed Apr. 12, 1995 by Tran, et al., abandoned and continued in application Ser. No. 08/838,680 filed Apr. 9, 1997, now U.S. Pat. No. 5,848,433. This patent application is incorporated herein by reference in its entirety. Call and return instructions are stored as predicted branches within the branch prediction structure, along with an indication that the instruction is a call or return instruction. The branch prediction structure includes a plurality of storage locations indexed by the instruction fetch address. Branches and call instructions are detected according to information stored in each entry and predicted according to that information. If a call instruction is detected within a set of instructions fetched by instruction cache <b>204</b>, then the call signal is asserted to return prediction unit <b>250</b>. Similarly, if a return instruction is detected within a set of instructions fetched by instruction cache <b>204</b>, then the return signal is asserted to return prediction unit <b>250</b>.</p><p>Upon receipt of the asserted call signal from branch prediction unit <b>220</b>, return stack control unit <b>254</b> allocates an entry to the call instruction. The allocated entry is determined according to the pointer on pointer bus <b>264</b>, and the entry becomes the top of the stack (i.e. the pointer indicates that the allocated entry is the top of the stack). The return PC is calculated by adder circuit <b>256</b> from the offset of the call instruction within the fetched line (the offset is transferred to return stack control unit <b>254</b> from branch prediction unit <b>220</b> upon call bus <b>266</b>) and from the address being fetched (transferred to multiplexor <b>258</b> from instruction cache <b>204</b>). Multiplexor <b>258</b> is controlled by return stack control unit <b>254</b>, and selects the address conveyed by instruction cache <b>204</b> in this case. The return PC is stored into the allocated entry within return stack storage <b>252</b>, along with the call tag assigned by branch prediction unit <b>220</b> (conveyed upon call bus <b>266</b>). Additionally, the CV bit is set.</p><p>Upon receipt of the asserted return signal from branch prediction unit <b>220</b> (along with an associated return tag), return stack control unit <b>254</b> predicts a return address for the return instruction. The return address is predicted to be the return PC stored within the entry nearest to the top of the return stack (as indicated by the pointer upon pointer bus <b>264</b>) for which the RV bit is not yet set. The RV bit is indicative that the associated return PC has been used as a return address prediction during a previous clock cycle. Therefore, the return PC is already associated with a previous return instruction if the RV bit is set. The selected return PC is conveyed upon return PC prediction bus <b>270</b> to instruction cache <b>204</b> for use in fetching subsequent instructions. It is noted that if no storage locations within return stack storage <b>252</b> meet the above mentioned criteria, then no prediction is made for that return instruction. It is further noted that, in one embodiment, either a call or a return instruction is indicated by branch prediction unit <b>220</b> upon call bus <b>266</b> and return bus <b>268</b> during a given clock cycle.</p><p>It is noted that the branch prediction structure within branch prediction unit <b>220</b> is a speculative structure which may not store an indication of a particular call or return instruction. An indication of whether or not a particular call or return instruction was detected by branch prediction unit <b>220</b> is conveyed with each call and return instruction through the instruction processing pipeline of microprocessor <b>200</b>. When a decode unit <b>208</b> decodes a call or return instruction and the associated indication signifies that the instruction was not detected by branch prediction unit <b>220</b>, then the decode unit asserts a call signal upon a decode call bus <b>272</b> or a decode return bus <b>274</b> to return prediction unit <b>250</b>. During a clock cycle in which these signals are asserted, the instruction fetching portion of the instruction processing pipeline within instruction cache <b>204</b> and instruction alignment unit <b>206</b> is stalled.</p><p>When decode units <b>208</b> decode a call or return instruction not detected by branch prediction unit <b>220</b>, return stack control unit <b>254</b> performs two actions concurrently. First, the call or return instruction is treated similar to a mispredicted branch (described below) having a branch tag equal to the branch tag carried by the instruction. It is noted that this branch tag is actually associated with a predicted branch instruction prior to the instruction in this case, since the call or return instruction was not detected during the fetch stage of the instruction processing pipeline. The branch tag is conveyed to comparator block <b>260</b> upon a decode branch tag bus <b>276</b>. Additionally, the call or return instruction is allocated a storage location similar to the above discussion for call and return instructions detected by branch prediction unit <b>220</b>. The call or return tag in this case is one greater than the branch tag conveyed by decode units <b>208</b>. Additionally, multiplexor <b>258</b> is directed to accept the PC address from decode units <b>208</b> in the case of a call instruction. The instruction offset is calculated according to the particular decode unit <b>208</b> which decodes the call or return instruction. The offset is conveyed by that decode unit to return stack control unit <b>254</b>.</p><p>During a clock cycle in which reorder buffer <b>216</b> retires a call or return instruction, the associated call or return tag is transferred to return stack control unit <b>254</b> upon retire bus <b>278</b>. Upon receipt of a retired call instruction indication, the CRV bit is set in the associated storage location (identified by a call tag equal to the tag sent by reorder buffer <b>216</b>). Upon receipt of a retired return instruction indication, the associated storage location (identified by a return tag equal to the tag sent by reorder buffer <b>216</b>) is deleted from return stack storage <b>252</b>. In one embodiment, the contents of storage locations within return stack <b>252</b> between the storage location indicated by pointer bus <b>264</b> and the storage location identified by the return tag are copied to the next lower storage location. In other words, storage locations between the storage location indicated by pointer bus and the storage location identified by the return tag are shifted down by one location. The storage location identified by the return tag is thereby overwritten by another entry and therefore is deleted from return stack storage <b>252</b>.</p><p>Because microprocessor <b>200</b> is configured to speculatively execute instructions out-of-order, branch mispredictions may indicate that portions of return stack <b>252</b> are storing incorrect information. When a branch instruction is mispredicted, then information associated with instructions within the instruction processing pipeline which are subsequent to the mispredicted branch may be incorrect. As noted above, the instructions subsequent to the mispredicted branch are flushed from the pipeline. Return stack storage <b>252</b> is purged of information related to the flushed instructions.</p><p>In order to recover the contents of return stack storage <b>252</b> upon detection of a mispredicted branch, comparator block <b>260</b> is included within return prediction unit <b>250</b>. A misprediction signal upon branch misprediction conductor <b>278</b> indicates that a mispredicted branch has been detected. In one embodiment, branch prediction unit <b>220</b> conveys the misprediction signal. In another embodiment, reorder buffer <b>216</b> conveys the misprediction signal. In still another embodiment, the functional unit <b>212</b> which detects the branch misprediction conveys the misprediction signal. Upon receipt of the branch misprediction signal, comparator block <b>260</b> compares the call and return tags stored within return stack storage <b>252</b> to the branch tag conveyed upon branch tag bus <b>280</b>. If a particular call or return tag is found to be subsequent to the branch tag in program order, then an associated invalidate signal is asserted upon invalidate bus <b>282</b> to return stack control unit <b>254</b>. Invalidate bus <b>282</b> includes an invalidate signal for each call tag and return tag within return stack storage <b>252</b>, and the signal may be asserted according to a matching comparison between the associated call or return tag and a branch tag from branch tag bus <b>280</b> or <b>276</b>. It is noted that call tags and return tags stored within return stack storage <b>252</b> are conveyed to comparator block <b>260</b> upon call tag bus <b>284</b> and return tag bus <b>286</b>, respectively.</p><p>Upon receipt of an asserted invalidate signal, the associated CV or RV bit within return stack storage <b>252</b> is reset. In this manner, call and return instructions subsequent to the mispredicted branch are removed from return stack storage <b>252</b>. Once a call instruction is retired by reorder buffer <b>216</b>, the associated call tag is invalid. Therefore, if an invalidate signal is asserted for a call instruction for which the CRV bit is set, then the CV bit is left unmodified. Additionally, storage entries for which the call instruction have been invalidated no longer store valid information. Similar to removing entries for which the return instruction has been retired, the storage locations are shifted and the pointer value adjusted to delete the invalid entries from return stack storage <b>252</b>.</p><p>It is noted that call and return instructions for which the target address is mispredicted are treated as mispredicted branch instructions for purposes of this discussion. It is further noted that a mispredicted address for a return instruction may be indicative of a fake return instruction. Although conditions other than the existence of a fake return instruction may be the cause of the misprediction, it is difficult to distinguish the various conditions within return prediction unit <b>250</b>. Therefore, the entire return stack is invalidated when a mispredicted return instruction is detected. Additionally, if the contents of instruction cache <b>204</b> are invalidated, then the return stack is invalidated. Instruction cache <b>204</b> may be invalidated due to a task switch, for example. The contents of return stack storage <b>252</b> may be invalid for the new task, and therefore the return stack is invalidated.</p><p>Return stack storage <b>252</b> includes a finite number of entries, and may therefore become full before any entries are deleted. When a call instruction is detected and return stack storage <b>252</b> is full of valid entries, then the entry stored at the \u201cbottom\u201d of the stack (i.e. the entry allocated prior to other entries within the stack) is deleted. In one embodiment, the pointer upon pointer bus <b>254</b> wraps around to the bottom storage location within return stack storage <b>252</b> and allocates that location to the newly detected call instruction. In another embodiment, all storage locations within return stack storage <b>252</b> are shifted down one location (similar to when an entry is deleted due to return instruction retirement) and the top storage location is allocated to the new return instruction. The pointer upon pointer bus <b>264</b> is unmodified for this embodiment.</p><p>It is noted that certain instruction within various microprocessor architectures may generate an \u201cexception\u201d. An exception causes program execution to jump to an exception handling routine, similar to an interrupt. If an instruction generates an exception, the branch tag conveyed with the instruction is used as a mispredicted branch tag, and the return stack is recovered according to the mispredicted branch recovery sequence noted above. It is further noted that, when multiple call and/or return instructions are detected simultaneously by decode units <b>208</b>, return stack control unit <b>254</b> is configured to select the first instruction detected in program order. The other call and/or return instructions will be purged from the instruction processing pipeline due to the first instructions being detected. It is still further noted that the above discussion describes signals as being \u201casserted\u201d. A signal may be defined as being asserted when it conveys a value indicative of a particular piece of information. A particular signal may be defined to be asserted when it conveys a binary one value or, alternatively, when it conveys a binary zero value. A second embodiment of return prediction unit <b>250</b> is contemplated in which call and return instructions are detected in decode units <b>208</b> but not in branch prediction unit <b>220</b>. For this embodiment, functionality is similar to the above description with the exception of detection of call and return instructions in branch prediction unit <b>220</b>. Additionally, an embodiment is contemplated in which call, return and branch tags may be tags from reorder buffer <b>216</b> indicative of the position within reorder buffer <b>216</b> storing the associated instruction.</p><p>Turning now to FIG. 2A, another embodiment of return stack storage <b>252</b> (return stack storage <b>252</b>A) is shown. The return PC, call tag, and return tag are included, as well as the CV, RV, and CRV bits similar to return stack storage <b>252</b> shown in FIG. <b>2</b>. Additionally, return stack storage <b>252</b>A includes an IXC bit and a ISTART bit. The IXC bit is set if the call tag is associated with an INT instruction, and is cleared if the call tag is associated with a CALL instruction. When a prediction is made by return prediction unit <b>250</b> for an IRET instruction, the storage location nearest the top of return stack storage <b>252</b>A in which the RV bit is clear and the IXC bit is set is used as the prediction. Similarly, when a prediction is made by return prediction unit <b>250</b> for a RET instruction, the storage location nearest the top of return stack storage <b>252</b>A in which both the RV and IXC bits are clear is used as the prediction. In this manner, CALL-RET pairs may be separated from INT-IRET pairs.</p><p>It is noted that the IRET instruction is not only used in conjunction with the interrupt instruction. Additionally, the IRET instruction is used to return from asynchronous interrupts. For example, microprocessor <b>200</b> may include an interrupt pin which may be asserted by external hardware to interrupt microprocessor <b>200</b>. An interrupt service routine is executed by microprocessor <b>200</b> in response to the interrupt, often ending in an IRET instruction to cause microprocessor <b>200</b> to return to the interrupted instruction sequence. Because of this alternative usage of the IRET instruction, IRET has a higher probability of being mispredicted than the RET instruction. It may be performance limiting to invalidate the entire return stack upon a mispredicted IRET instruction. The ISTART bit is set when microprocessor <b>200</b> enters an interrupt service routine. If the interrupt service routine is entered due to an asynchronous interrupt, then an entry is allocated with the program count value of the instruction interrupted as the return PC and the ISTART bit is set. If the interrupt service routine is entered due to an INT instruction, the ISTART bit is set when the INT instruction allocates an entry. If an IRET instruction is mispredicted, the entries within return stack storage <b>252</b>A between the top entry and the entry nearest the top for which the ISTART bit is set are invalidated. In this manner, only the portion of return stack storage <b>252</b>A which is associated with the interrupt service routine may be invalidated.</p><p>Turning now to FIG. 3, an exemplary instruction sequence is shown to further highlight the operation of return prediction unit <b>250</b> in predicting addresses. In the following discussion, for brevity, it is assumed that no fake return instructions are used. It is noted that instructions labeled INS<b>0</b> through INS<b>8</b> represent instructions which are not branch, Call, or Ret instructions. Beginning at arrow <b>300</b>, an instruction stream of contiguous instructions labeled INS<b>0</b> through INS<b>2</b> are executed, and then a call instruction Call A is encountered. Instruction execution transfers to an address specified by Call A (arrow <b>302</b>), and a set of contiguous instructions labeled INS<b>3</b> through INS<b>4</b> are executed. A second call instruction Call B is encountered, causing instruction execution to transfer to yet another address specified by the Call B instruction (arrow <b>304</b>). A third set of contiguous instructions labeled INS<b>5</b> through INS<b>6</b> are executed, and a return instruction Ret B is encountered.</p><p>Ret B is the first return instruction encountered, and so is defined to return to the instruction in memory immediately following the most recently executed call instruction (Call B, arrow <b>306</b>). In other words, Ret B fetches an instruction stored in memory locations contiguous to the memory locations storing the Call B instruction. The instruction Ret A is immediately following Call B in this example, and is the second return instruction encountered in the example. Therefore, Ret A is defined to return to the second most recently executed call instruction (Call A, arrow <b>308</b>). Immediately following the Call A instruction in memory is the instruction INS<b>7</b>, and instructions continue to be executed from that point forward. Return instructions are paired with call instructions in a last-in, first-out (LIFO) manner. The last call instruction to be executed is the first to be paired with a return instruction, etc. It is noted that return stack storage <b>252</b> is well suited to the LIFO manner in which call and return instructions are associated.</p><p>If the exemplary instruction sequence shown in FIG. 3 is executed by a superscalar microprocessor, then performance may be gained by predicting the return address of the Ret B and Ret A instructions. During a clock cycle, Call A is fetched and the return address is placed within return prediction unit <b>250</b>. During a later clock cycle, Call B is fetched and the return address is placed within return prediction unit <b>250</b> as well. The Call B entry is at the top of the return stack storage <b>252</b> (as defined by the pointer upon pointer bus <b>264</b>), and the Call A entry is second from the top. When Ret B is fetched, the entry nearest the top of return stack storage <b>252</b> which has not been used as a return address prediction is used as the prediction address (as noted above). In this example, the entry chosen is the top entry, since no return address predictions have yet been made. Therefore, the return address for Ret B is predicted to be the address following Call B.</p><p>During a subsequent clock cycle, prior to the Ret B instruction retiring, the Ret A instruction is fetched. The return address prediction is again made according to the top entry which has not been used as a prediction. Although Call B is still the top entry of the return stack storage (since Ret B has yet to be retired), that entry has been used as a return address prediction. Therefore, the second from the top entry is used. The address of the instruction immediately following Call A is used as the return address prediction for Ret A. In both cases, the correct return address is predicted.</p><p>Turning now to FIG. 4A, a second exemplary instruction sequence is shown. This instruction sequence is used to illustrate the dynamics of the present return stack structure in more detail. Beginning at arrow <b>400</b>, an instruction stream including instructions INS<b>0</b> through INS<b>1</b> are executed. Instructions INS<b>0</b> through INS<b>9</b>, similar to FIG. 3, represent instructions which are not branch, Call, or Ret instructions. Following INS<b>1</b> is a branch instruction Jmp, with a branch tag of one. In this example, decimal numbers are used for branch tags. However, many other numbering schemes may be used for branch tags. The Jmp instruction is predicted taken, and so instruction execution begins at the target of the Jmp instruction (arrow <b>402</b>).</p><p>At the target of the Jmp instruction is an instruction INS<b>2</b> followed by a Ret instruction. The Ret instruction is assigned the next available branch tag, which in the exemplary numbering scheme shown is a branch tag value of two. Instruction execution then begins at the predicted target of the Ret instruction (arrow <b>404</b>). The remainder of the instruction stream is similar, following consecutively through arrows <b>406</b>, <b>408</b>, <b>410</b>, <b>414</b>, <b>416</b>, <b>418</b>, <b>422</b>, <b>426</b>, and <b>428</b>. Branch, Call, and Ret instructions are assigned consecutive branch tags as shown in FIG. <b>4</b>A. Each instruction is numbered for reference in FIGS. 4B through 4E below. It is noted that Ret instruction <b>409</b> returns to the instruction subsequent to Call instruction <b>405</b>. This relationship is shown by dotted line <b>412</b>. Similarly, Ret instruction <b>415</b> returns to the instruction subsequent to Call instruction <b>413</b> (line <b>420</b>) and Ret instruction <b>417</b> returns to the instruction subsequent to Call instruction <b>411</b> (line <b>424</b>).</p><p>Turning now to FIG. 4B, the state of return stack storage <b>252</b> prior to the execution of INS<b>0</b> is shown (i.e. the state of the return stack storage at arrow <b>400</b> shown in FIG. <b>4</b>A). Three valid entries are shown (reference numbers <b>440</b>, <b>442</b>, and <b>444</b>), with return addresses A, B, and C (respectively). In this example, letters are used as exemplary return addresses for brevity. A return address is in fact a multi-bit number. In one embodiment, a return address comprises 32 bits. A call tag of zero is stored in each entry, although the entries storing return addresses A and B have their respective CRV bits set, and so the respective call tags are no longer valid for those instructions. Each entry has its CV bit set, indicating that the entries are valid. None of the RV bits are set, and so entries <b>440</b>, <b>442</b>, and <b>444</b> have not yet been used as return address predictions. Each entry includes a dash in the return tag field to indicate that the return tags are not valid. The pointer upon pointer bus <b>362</b> is shown pointing to the third entry of return stack storage <b>252</b>. Third entry <b>444</b> is the current top of the valid entries within return stack storage <b>252</b>.</p><p>Turning now to FIG. 4C, the contents of return stack storage <b>252</b> are shown at the time of fetching Jmp instruction <b>407</b> (i.e. at arrow <b>406</b> in FIG. <b>4</b>A). A fourth entry has been added from the state shown in FIG. 4B (return address D, call tag of three, reference number <b>446</b>). Additionally, entry <b>444</b> includes a valid return tag value of two, and the RV bit is set. The contents of return stack storage <b>252</b> may be explained by considering that the first call or return encountered is Ret instruction <b>403</b>. At the time the Ret instruction is fetched, the top entry in return stack storage <b>252</b> is entry <b>444</b>. Since the RV bit of entry <b>444</b> is clear, return address C is predicted for Ret instruction <b>403</b>. The RV bit is then set, and the return tag of Ret instruction <b>403</b> (i.e. the value two) is stored into the return tag field of entry <b>444</b>. The next Call or Ret instruction encountered is Call instruction <b>405</b>. Fourth entry <b>446</b> is allocated at the fetch of Call instruction <b>405</b>, and the call tag is set to the call tag of Call instruction <b>405</b> (i.e. the value of three). The pointer is now shown pointing to fourth entry <b>446</b>.</p><p>Turning next to FIG. 4D, the state of return stack storage <b>252</b> is shown after fetching Call instruction <b>413</b> (i.e. at arrow <b>416</b> shown in FIG. <b>4</b>A). Two additional entries (reference numbers <b>448</b> and <b>450</b>) have been added with respect to the state shown in FIG. 4C, and entry <b>446</b> has been updated. Entry <b>446</b> is updated at the fetching of Ret instruction <b>409</b>, which includes a return tag value of five. Entry <b>446</b> is the top of return stack storage <b>252</b> at the time Ret instruction <b>409</b> is fetched, and the RV bit of entry <b>446</b> is clear. Therefore, return address D is used as the return address prediction and the RV bit of entry <b>446</b> is set. Call instructions <b>411</b> and <b>413</b>, respectively, cause the allocation of entries <b>448</b> and <b>450</b>. Therefore, entry <b>448</b> includes a call tag value of six and entry <b>450</b> includes a call tag value of seven.</p><p>Turning now to FIG. 4E, the state of return stack storage <b>252</b> at the end of the exemplary instruction stream shown in FIG. 4A (i.e. at arrow <b>418</b> as shown in FIG. <b>4</b>A). Yet another entry <b>452</b> has been added, and entries <b>448</b>, <b>450</b>, and <b>442</b> have been updated. Entry <b>450</b> is updated at the fetch of Ret instruction <b>415</b>, because entry <b>450</b> is at the top of stack storage <b>252</b> at the time Ret instruction <b>415</b> is fetched. As shown in FIG. 4E, return address F is used as a prediction for Ret instruction <b>415</b> and the return tag associated with Ret instruction <b>415</b> is stored into entry <b>450</b>. Similarly, Ret instruction <b>417</b> causes the update of entry <b>448</b>. Entry <b>448</b> is not at the top of return stack storage <b>252</b>, but the entry which is at the top (entry <b>450</b>) has already been used as a return address prediction for Ret instruction <b>415</b>. Therefore, entry <b>448</b> is used as the return address prediction for Ret instruction <b>417</b>.</p><p>Additionally, Ret instruction <b>419</b> is fetched and a return address prediction is formulated. At the time Ret instruction <b>419</b> is fetched, entries <b>450</b>, <b>448</b>, <b>446</b>, and <b>444</b> have previously been used as return address predictions. Therefore, entry <b>442</b> is the entry of return stack storage <b>252</b> nearest the top of the stack which has not yet been used as a return address prediction. Return address B is prediction, and entry <b>442</b> is updated with the return tag associated with Ret instruction <b>419</b> (i.e. a return tag value of ten). Call instruction <b>421</b> is then decoded and causes entry <b>452</b> to be added to the top of return stack storage <b>252</b>.</p><p>The exemplary code sequence shown in FIG. 4A may be used to illustrate the recovery of return prediction unit <b>250</b> from mispredicted branches. As an example, consider Jmp instruction <b>407</b> being mispredicted and the misprediction being detected at arrow <b>416</b>, such that FIG. 4D shows the state of return stack storage <b>252</b>. Jmp instruction <b>407</b> includes a branch tag of four, and therefore any instructions having call and return tags subsequent to a branch tag value of four within return stack storage <b>252</b> are invalidated. It is noted that call tags which are associated with retired call instructions are not invalidated. As shown in FIG. 4D, the return tag of entry <b>446</b> and the call tags of entries <b>450</b> and <b>448</b> are invalidated. As a second example, consider Jmp instruction <b>407</b> not being determined to be mispredicted until return stack storage <b>252</b> achieves the state shown in FIG. <b>4</b>E. In this example, the return tags of entries <b>450</b>, <b>448</b>, <b>446</b>, and <b>442</b> and the call tags of entries <b>452</b>, <b>450</b>, and <b>448</b> are invalidated. It is noted that call instructions whose target addresses are incorrectly predicted operate similarly with respect to return stack storage <b>252</b>.</p><p>Turning next to FIGS. 5-66, details regarding various aspects of another embodiment of a superscalar microprocessor are next considered. FIG. 5 is a block diagram of a processor <b>500</b> including an instruction cache <b>502</b> coupled to a prefetch/predecode unit <b>504</b>, to a branch prediction unit <b>506</b>, and to an instruction alignment unit <b>508</b>. A set <b>510</b> of decode units is further coupled to instruction alignment unit <b>508</b>, and a set <b>512</b> of reservation station/functional units is coupled to a load/store unit <b>514</b> and to a reorder buffer <b>516</b>. A register file unit <b>518</b> is finally shown coupled to reorder buffer <b>516</b>, and a data <b>522</b> is shown coupled to load/store unit <b>514</b>.</p><p>Processor <b>500</b> limits the addressing mechanism used in the x86 to achieve both regular simple form of addressing as well as high clock frequency execution. It also targets 32-bit O/S and applications. Specifically, 32-bit flat addressing is employed where all the segment registers are mapped to all 4 GB of physical memory, the starting address being <b>0000-0000 </b>hex and their limit address being FFFF hex. The setting of this condition will be detected within processor <b>500</b> as one of the conditions to allow the collection of accelerated data paths and instructions to be enabled. The absence of this condition of 32-bit flat addressing will cause a serialization condition on instruction issue and a trapping to MROM space.</p><p>Another method to ensure that a relatively high clock frequency may be accommodated is to limit the number of memory address calculation schemes to those that are simple to decode and can be decoded within a few bytes. We are also interested in supporting addressing that fits into our other goals, i.e., regular instruction decoding.</p><p>As a result, the x86 instruction types that are supported for load/store operations are:</p><p>push [implied ESP\u22124]</p><p>pop [implied ESP+4]</p><p>call [implied ESP+8]</p><p>ret (implied ESP\u22128]</p><p>load [base+8-bit displacement]</p><p>store [base+8-bit displacement]</p><p>oper. [EBP+8-bit displacement]</p><p>oper. (EAX+8-bit displacement]</p><p>The block diagram of FIG. 6 shows the pipeline for calculating addressing within processor <b>500</b>. It is noted that base+8/32 bit displacement takes 1 cycle, where using an index register takes 1 more cycle of delay in calculating the address. More complicated addressing than these requires invoking an MROM routine to execute.</p><p>An exemplary listing of the instruction sub-set supported by processor <b>500</b> as fast path instructions is provided below. All other x86 instructions will be executed as micro-ROM sequences of fast path instructions or extensions to fast path instructions.</p><p>The standard x86 instruction set is very limited in the number of registers it provides. Most RISC processors have 32 or greater general purpose registers, and many important variables can be held during and across procedures or processes during normal execution of routines. Because there are so few registers in the x86 architecture and most are not general purpose, a large percentage of operations are moves to and from memory. RISC architectures also incorporate 3 operand addressing to prevent moves from occurring of register values that are desired to be saved instead of overwritten.</p><p>The x86 instruction set uses a set of registers that can trace its history back to the 8080. Consequently there are few registers, many side effects, and sub-registers within registers. This is because when moving to 16-bit, or 32-bit operands, mode bits were added and the lengths of the registers were extended instead of expanding the size of the register file. Modern compiler technology can make use of large register sets and have a much smaller percentage of loads and stores. The effect of these same compilers is to have a much larger percentage of loads and stores when compiling to the x86. The actual x86 registers are often relegated to temporary registers for a few clock cycles while the real operation destinations are in memory.</p><p>FIG. 7 shows a programmer's view of the x86 register file. One notes from this organization that there are only 8 registers, and few are general purpose. The first four registers, EAX, EDX, ECX, and EBX, have operand sizes of 8, 16, or 32-bits depending on the mode of the processor or instruction. The final 4 registers were added with the 8086 and extended with the 386. Because there are so few real registers, they tend to act as holding positions for the passing of variables to and from memory.</p><p>The important thing to note is that when executing x86 instructions, one must be able to efficiently handle 8, 16, and 32-bit operands. If one is trying to execute multiple x86 instructions in parallel, it is not enough to simply multi-port the register file. This is because there are too few registers and all important program variables must be held in memory on the stack or in a fixed location.</p><p>RISC designs employ regular instruction decoding along natural boundaries to achieve very high clock frequencies and also with a small number of pipeline stages even for very wide issue processors. This is possible because finding a large number of instructions and their opcodes is relatively straightforward, since they are always at fixed boundaries.</p><p>As stated previously, this is much more difficult in an x86 processor where there are variable byte instruction formats, as well as prefix bytes and SIB bytes that can effect the length and addressing/data types of the original opcode.</p><p>Processor <b>500</b> employs hardware to detect and send simple instructions to fixed issue positions, where the range of bytes that a particular issue position can use is limited. This may be compensated for by adding many issue positions that each instruction cache line can assume in parallel.</p><p>Once the instructions are aligned to a particular issue position, the net amount of hardware required to decode common instructions is not significantly greater than that of a RISC processor, allowing equivalent clock frequencies to be achieved. Processor <b>500</b> achieves high frequency, wide issue, and limited pipeline depth by limiting the instructions executed at high frequency to a sub-set of the x86 instructions under the conditions of 32-bit flat addressing.</p><p>The results of executing instructions are returned to the corresponding entry in the reorder buffer. If a store, the store is held in speculative state in front of the data cache in a store buffer, from which point it can be speculatively forwarded from. The reorder buffer then can either cancel this store or allow it to writeback to the data cache when the line is retired.</p><p>The following set of instructions probably comprise 90% of the dynamically executed code for 32-bit applications:</p><p>8/32-bit operations</p><p>move reg/reg reg/mem</p><p>arithmetic operations reg/mem reg/reg logical operations reg/reg reg/mem push</p><p>logical operations reg/reg reg/mem</p><p>push</p><p>pop</p><p>call/return</p><p>load effective address</p><p>jump cc</p><p>jump unconditional</p><p>16-bit operations</p><p>prefix/move reg/reg</p><p>prefix/move reg/mem</p><p>prefix/arithmetic operations reg/reg, reg/mem</p><p>prefix/logical operations reg/reg reg/mem</p><p>prefix/push</p><p>prefix/pop</p><p>When executing 32-bit code under flat addressing, these instructions almost always fall within 1-8 bytes in length, which is in the same rough range of the aligned, accelerated fast path instructions.</p><p>Accelerated instructions are defined as fast-path instructions between 1 and 8 bytes in length. It noted that it is possible that the start/end positions predecoded reflect multiple x86 instructions, for instance 2 or 3 pushes that are predecoded in a row may be treated as one accelerated instruction that consumes 3 bytes.</p><p>When a cache line is fetched from the instruction cache, it moves into an instruction alignment unit which looks for start bytes within narrow ranges. The instruction alignment unit uses the positions of the start bytes of the instructions to dispatch the instructions to four issue positions. Instructions are dispatched such that each issue position accepts the first valid start byte within its range along with subsequent bytes.</p><p>A multiplexer in each decoder looks for the end byte associated with each start byte, where an end byte can be no more than seven bytes away from a start byte. The mechanism to scan for a constant value in an instruction over four bytes in length may be given an extra pipeline stage due to the amount of time potentially required.</p><p>Note that instructions included in the subset of accelerated instructions, and which are over four bytes in length, always have a constant as the last 1/2/4 bytes. This constant is usually not needed until the instruction is issued to a functional unit, and therefore the determination of the constant value can be delayed in the pipeline. The exception is an instruction requiring an eight-bit displacement for an address calculation. The eight-bit displacement for stack-relative operations is always the third byte after the start byte, so this field will always be located within the same decoder as the rest of the instruction.</p><p>It is possible that a given cache line can have more instructions to issue than can be accommodated by the four entry positions contained in each line of the four issue reorder buffer. If this occurs, the four issue reorder buffer allocates a second line in the buffer as the remaining instructions are dispatched. Typically, in 32-bit application and O/S code, the average instruction length is about three bytes. The opcode is almost always the first two bytes, with the third byte being a sib byte specifying a memory address (if included), and the fourth byte being a 16-bit data prefix.</p><p>The assumption in the processor <b>500</b> alignment hardware is that if the average instruction length is three, then four dedicated issue positions and decoders assigned limited byte ranges should accommodate most instructions found within 16-byte instruction cache lines. If very dense decoding occurs (i.e., lots of one and two byte instructions), several lines are allocated in the four issue reorder buffer for the results of instructions contained in a few lines of the instruction cache. The fact that these more compact instructions are still issued in parallel and at a high clock frequency more than compensates for having some decoder positions potentially idle.</p><p>Overview of the Processor <b>500</b> Instruction Cache (Icache)</p><p>This section describes the instruction cache organization, fetching mechanism, and pre-decode information. The Processor <b>500</b> instruction cache has basic features including the ICSTORE, ICTAGV, ICNXTBLK, ICCNTL, ICALIGN, ICFPC, and ICPRED. Highlights are: the pre-decode bits per byte of instructions are 3 bits, the branch prediction increases to 2 targets, 2 different types of branch prediction techniques (bimodal and global) are implemented, the X86 instructions align to 4 fixed length RISC-type instructions, and the pre-decode logic eliminates many serializtion conditions. Processor <b>500</b> executes the X86 instructions directly with a few instructions requiring two Rops, the BYTEQ is configured for fast scanning of instructions, and instructions are aligned to 4 decode units. The pre-decode data is separate in a block called ICPDAT, instead of inside the ICSTORE. The pre-fetch buffers are added to the ICSTORE to write instructions directly into the array, and the prefixes are not modified. All branches are detected during pre-decoding. Unconditional branches are taken during pre-decoding and aligning of instructions to the decode units. A return stack is implemented for CALL/RETURN instructions. Way prediction is implemented to read the current block and fetch the next block because the tag comparison and branch prediction do not resolve until the second cycle. The scanning for 4 instructions is done from ICPDAT before selected by tag comparison. Since the pre-decode data does not include the information for the 2-Rop instructions, the instructions must be partially decoded for the 2-rop during prioritizing and aligning of instructions to decode units. The early decoding includes decoding for unconditional branches, operand addresses, flags, displacement and immediate fields of the instruction. The CMASTER takes care of the replacement algorithm for the Icache and sends the way associative along with the data to the pre-fetch buffer. This section includes signal lists, timings and implementation issues for the Icache and all sub-blocks.</p><p>The Icache size is 32K bytes with 8-way set associative. The Icache is linearly addressed. The number of pipeline stages is 9. Icache will have more than one clock cycle to read and align the instructions to the decode units. The row decoding of index address is calculated in first half of ICLK, the data, tag, pre-decode, and predicting information are read in by the end of ICLK. In the next cycle, the data are selected by the TAGHITs and latched. The pre-decode data are scanned to generate the controls to the multiplexers for aligning and sending the instructions to the decode units and MROM units. A part of the scanning logic is done in parallel with the tag comparison. The scanning and alignment of instructions takes two clock cycles. The decode units can start decoding in the second half of the third clock. The Icache includes a way-prediction which can be done in a single clock using the ICNXTBLK target. The branch prediction includes bimodal and global branch prediction which takes two clock cycles. The timing from fetching, scanning, aligning, decoding, and muxing of instructions to decode units are shown in FIG. <b>8</b>.</p><p>Throughout this documentation, a discussion of the layout organization is included in each section. The array is organized into many sets, and each set has its own decoder. The decoder is in the center of the set.</p><p>Signal List</p><p>SRBB(<b>31</b>:<b>0</b>)\u2014I/O from SRB indicates the special register address for the array or data transferring to/from the SRB.</p><p>SRB_VAL\u2014Input from SRB indicates a special register instruction is on the SRBB.</p><p>ICTAR_VAL\u2014Output to SRB indicates completion of the special register instruction, for read the data is on the SRBB.</p><p>IRESET\u2014Global signal used to reset ICACHE block. Clears all state machines to Idle/Reset.</p><p>IDECJAMIC\u2014Global signal from FIROB. Used to indicate that an interrupt or trap is being taken. Effect on Icache is to clear all pre-fetch or access in progress, and set all state machines to Idle/Reset.</p><p>EXCEPTION\u2014Global input from FIROB indicates that an interrupt or trap is being taken including re-synchronization. Effect on Idecode and FUs is to clear all instructions in progress.</p><p>REQTRAP\u2014Global input from FIROB, one cycle after EXCEPTION, indicates that the trap is initiated with new entry point or new PC is driven.</p><p>INVBHREG\u2014Input from FIROB to invalidate the branch holding register. The branch mis-prediction is speculative, an early branch can be mis-predicted at a later time.</p><p>CS32\u00d716\u2014Input from LSSEC indicates operand and address size from the D bit of the segment descriptor of the code segment register. If set, 32-bit, if clear, 16-bit.</p><p>SUPERV\u2014Input from LSSEC indicates the supervisor mode or user mode of the current accessed instruction.</p><p>TR<b>12</b>DIC\u2014Input from SRB indicates that all un-cached instructions must be fetched from the external memory.</p><p>SRBINVILV\u2014Input from SRB to invalidate the Icache by clear all valid bits.</p><p>INSTRDY\u2014Input from BIU to indicates the valid external fetched instruction is on the INSB(<b>63</b>:<b>0</b>) bus.</p><p>INSTFLT\u2014Input from BIU to indicates the valid but faulted external fetched instruction is on the INSB(<b>63</b>:<b>0</b>) bus.</p><p>INSB(<b>63</b>:<b>0</b>)\u2014Input from external buses for fetched instruction to the Icache.</p><p>L<b>2</b>_IC_ALIAS\u2014Input from CMASTER indicates the instruction is in the Icache with different mapping. The CMASTER provides the way associative and new supervisor bit. The LV will be set in this case.</p><p>PFREPLCOL(<b>2</b>:<b>0</b>)\u2014Input from CMASTER indicates the way associative for writing of the ICTAGV.</p><p>UPDFPC\u2014Input from FIROB indicate that a new Fetch PC has been detected. This signal accompanies the FPC for the Icache to begin access the cache arrays.</p><p>FPC(<b>31</b>:<b>0</b>)\u2014Input from FIROB as the new PC for branch correction path.</p><p>BPC(<b>11</b>:<b>0</b>)\u2014Input from FIROB indicates the PC index and byte-pointer of the branch instruction which has been mis-predicted for updating the ICNXTBLK. This index must be compared to the array index for exact recovery of the global shift register.</p><p>BRNMISP\u2014Input from the Branch execution of the FU indicates a branch mis-prediction. The Icache changes its state machine to access a new PC and clears all pending instructions.</p><p>BRNTAKEN\u2014Input from FIROB indicate the status of the mis-prediction. This signal must be gated with UPDFPC.</p><p>BRNTAG(<b>3</b>:<b>0</b>)\u2014Input from FIROB indicates the instruction byte for updating the branch prediction in the ICNXTBLK.</p><p>FPCTYP\u2014Input for FIROB indicates the type of address that is being passed to the Icache.</p><p>HLDISP(<b>1</b>:<b>0</b>)\u2014Output to Idecode indicates all instructions of the first (bit <b>0</b>) and/or the second (bit <b>1</b>) 8-byte of the current line has been dispatched to decode units.</p><p>REFRESH<b>2</b>\u2014Input from Idecode indicates current line of instructions will be refreshed and not accept new instructions from Icache.</p><p>MROMEND\u2014Input from MENG indicates completion of the MROM.</p><p>D<b>0</b>USEFL(<b>4</b>:<b>0</b>)</p><p>D<b>0</b>WRFL(<b>4</b>:<b>0</b>)\u2014Output to FIROB indicates the type of flag uses/writes for this instruction of decode unit <b>0</b>:</p><p>xx<b>1</b> CF\u2014carry flag,</p><p>x<b>1</b>x OF\u2014overflow flag,</p><p><b>1</b>xx SF\u2014sign, ZF\u2014zero, PF\u2014parity, and AF\u2014auxiliary carry</p><p>D<b>1</b>USEFL(<b>4</b>:<b>0</b>)</p><p>D<b>1</b>WRFL(<b>4</b>:<b>0</b>)\u2014Output to FIROB indicates the type of flag uses/writes for this instruction of decode unit <b>1</b>.</p><p>D<b>2</b>USEFL(<b>4</b>:<b>0</b>)</p><p>D<b>2</b>WRFL(<b>4</b>:<b>0</b>)\u2014Output to FIROB indicates the type of flag uses/writes for this instruction of decode unit <b>2</b>.</p><p>D<b>3</b>USEFL(<b>4</b>:<b>0</b>)</p><p>D<b>3</b>WRFL(<b>4</b>:<b>0</b>)\u2014Output to FIROB indicates the type of flag uses/writes for this instruction of decode unit <b>3</b>.</p><p>RD<b>0</b>PTR<b>1</b>(<b>5</b>:<b>0</b>)\u2014Indicates the register address for operand <b>1</b> of decode unit <b>0</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>1</b>PTR<b>1</b> (<b>5</b>:<b>0</b>)\u2014Indicates the register address for operand <b>1</b> of decode unit <b>1</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>2</b>PTR<b>1</b>(<b>5</b>:<b>0</b>)\u2014Indicates the register address for operand <b>1</b> of decode unit <b>2</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>3</b>PTR<b>1</b>(<b>5</b>:<b>0</b>)\u2014Indicates the register address for operand <b>1</b> of decode unit <b>3</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>0</b>PTR<b>2</b>(<b>5</b>:<b>0</b>)\u2014Indicates register address for operand <b>2</b> of decode unit <b>0</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>1</b>PTR<b>2</b>(<b>5</b>:<b>0</b>)\u2014Indicates register address for operand <b>2</b> of decode unit <b>1</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>2</b>PTR<b>2</b>(<b>5</b>:<b>0</b>)\u2014Indicates register address for operand <b>2</b> of decode unit <b>2</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>3</b>PTR<b>2</b>(<b>5</b>:<b>0</b>)\u2014Indicates register address for operand <b>2</b> of decode unit <b>3</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>IDxDAT(<b>1</b>:<b>0</b>)\u2014Output to indicates the data size information. 01-byte, 10-half word, 11-word, 00-not used.</p><p>ICBTAG<b>1</b>(<b>3</b>:<b>0</b>)\u2014Output to Idecode indicates the position of the first target branch instruction with respect to the global shift register in case of branch mis-prediction. The branch can be taken or non-taken, branch tag must be sent with all branch instruction.</p><p>ICBTAG<b>2</b>(<b>3</b>:<b>0</b>)\u2014Output to Idecode indicates the position of the second target branch instruction with respect to the global shift register in case of branch mis-prediction. The branch can be taken or non-taken, branch tag must be sent with all branch instruction.</p><p>UNJMP(<b>3</b>:<b>0</b>)\u2014Output indicates the unconditional branch instruction needs to calculate target address.</p><p>BRNTKN(<b>3</b>:<b>0</b>)\u2014Output indicates which decode unit has a predicted taken branch. The operand steering uses this signal to latch and send BTADDR (<b>31</b>:<b>0</b>) to the functional unit.</p><p>BRNINST(<b>3</b>:<b>0</b>)\u2014Output indicates which decode unit has a global branch prediction. The operand steering uses this signal to latch and send ICBTAG<b>1</b> (<b>3</b>:<b>0</b>) and ICBTAG<b>2</b> (<b>3</b>:<b>0</b>) to the functional units.</p><p>CALLDEC(<b>3</b>:<b>0</b>)\u2014Output to FIROB indicates the CALL instruction is detected, the return stack should be updated with the PC address of instruction after CALL. The information. is latched for mis-predicted CALL branch.</p><p>RETDEC(<b>3</b>:<b>0</b>)\u2014Output to FIROB indicates a RETURN instruction is detected. The information is latched for mis-predicted RETURN branch.</p><p>ICPREF(<b>9</b>:<b>0</b>)\u2014Output to Idecode and MROM indicates the encoded prefix byte. The two most significant bits are repeat prefixes for MROM.</p><p>IC<b>2</b>ROP<b>0</b>(<b>3</b>:<b>0</b>)\u2014Output to decode unit <b>0</b> indicates 2-rop instruction. Bit <b>3</b> indicates the first rop or second rop of the 2-rop instruction, bit <b>2</b> indicates POP instruction, bit <b>1</b> indicates the MUL instruction, and bit <b>0</b> indicates the SIB-byte instruction.</p><p>NODEST(<b>3</b>:<b>0</b>)\u2014Output to FIROB indicates no destination for the first rop of the SIB-byte instruction.</p><p>DEPTAG(<b>3</b>:<b>1</b>)\u2014Output to FIROB indicates forced dependency tag on the first instruction; the second rop of the SIB-byte instruction.</p><p>REFRESH<b>2</b>\u2014Input from Idecode indicates current line of instructions will be refreshed and not accept new instructions from Icache.</p><p>IB<b>1</b>(<b>191</b>:<b>0</b>)\u2014Output indicates the combined instruction line for dispatching to decode units.</p><p>MROMEN\u2014Input from MENG indicates the micro-instructions is sent to Idecode instead of the Icache.</p><p>M<b>0</b>USEFL(<b>4</b>:<b>0</b>)</p><p>M<b>0</b>WRFL(<b>4</b>:<b>0</b>)\u2014Input from MENG indicates the type of flag used/written for this micro-instruction of decode unit <b>0</b>:</p><p>xx<b>1</b> CF\u2014carry flag,</p><p>x<b>1</b>x OF\u2014overflow flag,</p><p><b>1</b>xx SF\u2014sign, ZF\u2014zero, PF\u2014parity, and AF\u2014auxiliary carry</p><p>M<b>1</b>USEFL(<b>4</b>:<b>0</b>)</p><p>M<b>1</b>WRFL(<b>4</b>:<b>0</b>)\u2014Input from MENG indicates the type of flag used/written for this micro-instruction of decode unit <b>1</b>.</p><p>M<b>2</b>USEFL(<b>4</b>:<b>0</b>)</p><p>M<b>2</b>WRFL(<b>4</b>:<b>0</b>)\u2014Input from MENG indicates the type of flag used/written for this micro-instruction of decode unit <b>2</b>.</p><p>M<b>3</b>USEFL(<b>4</b>:<b>0</b>)</p><p>M<b>3</b>WRFL(<b>4</b>:<b>0</b>)\u2014Input from MENG indicates the type of flag used/written for this micro-instruction of decode unit <b>3</b>.</p><p>MINS<b>0</b>(<b>63</b>:<b>0</b>)\u2014Input from MENG indicates the displacement and immediate field of micro-instruction being sent to decode <b>0</b>.</p><p>MINS<b>1</b>(<b>63</b>:<b>0</b>)\u2014Input from MENG indicates the displacement and immediate field of micro-instruction being sent to decode <b>1</b>.</p><p>MINS<b>2</b>(<b>63</b>:<b>0</b>)\u2014Input from MENG indicates the displacement and immediate field of micro-instruction being sent to decode <b>2</b>.</p><p>MINS<b>3</b>(<b>63</b>:<b>0</b>)\u2014Input from MENG indicates the displacement and immediate field of micro-instruction being sent to decode <b>3</b>.</p><p>MR<b>0</b>OPC(<b>7</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>0</b> indicates the opcode byte.</p><p>MR<b>1</b>OPC(<b>7</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>1</b> indicates the opcode byte.</p><p>MR<b>2</b>OPC(<b>7</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>2</b> indicates the opcode byte.</p><p>MR<b>3</b>OPC(<b>7</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>3</b> indicates the opcode byte.</p><p>MR<b>0</b>EOP(<b>2</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>0</b> indicates the extended opcode field.</p><p>MR<b>1</b>EOP(<b>2</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>1</b> indicates the extended opcode field.</p><p>MR<b>2</b>EOP(<b>2</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>2</b> indicates the extended opcode field.</p><p>MR<b>3</b>EOP(<b>2</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>3</b> indicates the extended opcode field.</p><p>MR<b>0</b>SS(<b>1</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>0</b> indicates the scale factor of the SIB byte.</p><p>MR<b>1</b>SS(<b>1</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>1</b> indicates the scale factor of the SIB byte.</p><p>MR<b>2</b>SS(<b>1</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>2</b> indicates the scale factor of the SIB byte.</p><p>MR<b>3</b>SS(<b>1</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>3</b> indicates the scale factor of the SIB byte.</p><p>ICMROM\u2014Output to MENG indicates the current instruction is MROM. The MROM instruction may take two cycles to read the IB, ICEND, and ICFUNC.</p><p>ENDINST\u2014Input from ICPRED indicates that pre-decoding is completed for the current instruction. The byte position of the branch instruction is from STARTPTR. The selected instruction from IB should be sent to decode unit <b>0</b>.</p><p>ICVALI(<b>3</b>:<b>0</b>)\u2014Output to Idecode indicates valid instructions. NOOP is generated for invalid instruction.</p><p>IC<b>0</b>OPC(<b>7</b>:O)\u2014Output to decode unit <b>0</b> indicates the opcode byte.</p><p>IC<b>1</b>OPC(<b>7</b>:<b>0</b>)\u2014Output to decode unit <b>1</b> indicates the opcode byte.</p><p>IC<b>2</b>OPC(<b>7</b>:<b>0</b>)\u2014Output to decode unit <b>2</b> indicates the opcode byte.</p><p>IC<b>3</b>OPC(<b>7</b>:<b>0</b>)\u2014Output to decode unit <b>3</b> indicates the opcode byte.</p><p>IC<b>0</b>EOP(<b>2</b>:<b>0</b>)\u2014Output to decode unit <b>0</b> indicates the extended opcode field.</p><p>IC<b>1</b>EOP(<b>2</b>:<b>0</b>)\u2014Output to decode unit <b>1</b> indicates the extended opcode field.</p><p>IC<b>2</b>EOP(<b>2</b>:<b>0</b>)\u2014Output to decode unit <b>2</b> indicates the extended opcode field.</p><p>IC<b>3</b>EOP(<b>2</b>:<b>0</b>)\u2014Output to decode unit <b>3</b> indicates the extended opcode field.</p><p>IC<b>0</b>SS(<b>1</b>:<b>0</b>)\u2014Output to decode unit <b>0</b> indicates the scale factor of the SIB byte.</p><p>IC<b>1</b>SS(<b>1</b>:<b>0</b>)\u2014Output to decode unit <b>1</b> indicates the scale factor of the SIB byte.</p><p>IC<b>2</b>SS(<b>1</b>:<b>0</b>)\u2014Output to decode unit <b>2</b> indicates the scale factor of the SIB byte.</p><p>IC<b>3</b>SS(<b>1</b>:<b>0</b>)\u2014Output to decode unit <b>3</b> indicates the scale factor of the SIB byte.</p><p>DISPTR<b>0</b>(<b>6</b>:<b>0</b>)\u2014Output to decode unit <b>0</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, bit <b>6</b>:<b>5</b> is the size, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Bit <b>6</b>:<b>5</b>=00 indicates no displacement.</p><p>DISPTR<b>1</b>(<b>6</b>:<b>0</b>)\u2014Output to decode unit <b>1</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, bit <b>6</b>:<b>5</b> is the size, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Bit <b>6</b>:<b>5</b>=00 indicates no displacement.</p><p>DISPTR<b>2</b>(<b>6</b>:<b>0</b>)\u2014Output to decode unit <b>2</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, bit <b>6</b>:<b>5</b> is the size, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Bit <b>6</b>:<b>5</b>=00 indicates no displacement.</p><p>DISPTR<b>3</b>(<b>6</b>:<b>0</b>)\u2014Output to decode unit <b>3</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, bit <b>6</b>:<b>5</b> is the size, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Bit <b>6</b>:<b>5</b>=00 indicates no displacement.</p><p>IMMPTR<b>0</b>(<b>4</b>:<b>0</b>)\u2014Output to decode unit <b>0</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Decoding of all opcodes is needed to detect immediate field.</p><p>IMMPTR<b>1</b>(<b>4</b>:<b>0</b>)\u2014Output to decode unit <b>1</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Decoding of all opcodes is needed to detect immediate field.</p><p>IMMPTR<b>2</b>(<b>4</b>:<b>0</b>)\u2014Output to decode unit <b>2</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Decoding of all opcodes is needed to detect immediate field.</p><p>IMMPTR<b>3</b>(<b>4</b>:<b>0</b>)\u2014Output to decode unit <b>3</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Decoding of all opcodes is needed to detect immediate field.</p><p>CONSTn(<b>2</b>:<b>0</b>)\u2014Output to decode unit n indicates the constant for add/substract to ESP of the two-dispatch position instruction.</p><p>MROMEN\u2014Input from MENG indicates the micro-instructions is sent to Idecode instead of the Icache.</p><p>IB<b>2</b>(<b>191</b>:<b>0</b>)\u2014Output to decode units indicates the current line of instructions.</p><p>ICMROM\u2014Output to MENG indicates the current instruction is MROM. The MROM instruction may take two cycles to read the IB, ICEND, and ICFUNC.</p><p>ICPC<b>1</b>TAR\u2014Output to Idecode indicates is ICPC<b>1</b> a branch target of a previous instruction which is a predicted taken branch instruction.</p><p>ICPC<b>2</b>TAR\u2014Output to Idecode indicates is ICPC<b>2</b> a branch target of a previous instruction which is a predicted taken branch instruction.</p><p>ICPC<b>1</b>(<b>31</b>:<b>0</b>)\u2014Output to Idecode indicates the current line PC of the first instruction in the 4 issued instructions to pass along with the instruction to FIROB.</p><p>ICPC<b>2</b>(<b>31</b>:<b>0</b>)\u2014Output to Idecode indicates the current line PC of a second instruction which cross the 16-byte boundary or branch target in the 4 issued instructions to pass along with the instruction to FIROB.</p><p>ICPOS<b>0</b>(<b>4</b>:<b>0</b>)\u2014Output to decode unit <b>0</b> indicates the PC's byte position of the next instruction. Bit <b>4</b> indicates the next instruction is on the next line.</p><p>ICPOS<b>1</b>(<b>4</b>:<b>0</b>)\u2014Output to decode unit <b>1</b> indicates the PC's byte position of the next instruction. Bit <b>4</b> indicates the next instruction is on the next line.</p><p>ICPOS<b>2</b>(<b>4</b>:<b>0</b>)\u2014Output to decode unit <b>2</b> indicates the PC's byte position of the next instruction. Bit <b>4</b> indicates the next instruction is on the next line.</p><p>ICPOS<b>3</b>(<b>4</b>:<b>0</b>)\u2014Output to decode unit <b>3</b> indicates the PC's byte position of the next instruction. Bit <b>4</b> indicates the next instruction is on the next line.</p><p>BTAG<b>1</b>N(<b>3</b>:<b>0</b>)\u2014Output indicates the position of the first target branch instruction for a new line with respect to the global shift register in case of branch mis-prediction.</p><p>BTAG<b>2</b>N(<b>3</b>:<b>0</b>)\u2014Output indicates the position of the second target branch instruction for a new line with respect to the global shift register in case of branch mis-prediction.</p><p>BTAKEN<b>1</b>(<b>1</b>:<b>0</b>)\u2014Output to decode units and ICFPC indicates a predicted taken branch instruction from PTAKEN, BVAL<b>1</b>. Bit <b>0</b> is the last line and bit <b>1</b> is new line.</p><p>BTAKEN<b>2</b>(<b>1</b>:<b>0</b>)\u2014Output to decode units and ICFPC indicates a predicted taken branch instruction from PTAKEN, BVAL<b>2</b>. Bit <b>0</b> is the last line and bit <b>1</b> is new line.</p><p>ICERROR\u2014Output, indicates an exception has occurred on an instruction pre-fetched, the type of exception (TLB-miss, page-fault, illegal opcode, external bus error) will also be asserted.</p><p>INSPFET\u2014Output to BIU and CMASTER requests instruction fetching from the previous incremented address, the pre-fetch buffer in the Icache has space for a new line from external memory.</p><p>ICAD(<b>31</b>:<b>0</b>)\u2014Output to MMU indicates a new fetch PC request to external memory.</p><p>RETPRED\u2014Output to Idecode indicates the current prediction of the return instruction of the fetched line. The return instruction must be detected in the current line of instruction or the Icache must be re-fetched from a new line.</p><p>IC_EXT_RD\u2014Output to CMASTER indicates the next line of instruction should be fetched from external regardless of aliasing. This is for pre-fetching of instruction which crosses the line boundary.</p><p>MMUPFPGFLT\u2014Input from MMU indicates page fault for the current instruction address.</p><p>TLB_MISS_PF\u2014Input from MMU indicates TLB miss for the current instruction address.</p><p>PF_IC_XFER\u2014Output to CMASTER indicates the address for the current line is written into the cache, the L<b>2</b> should be updated with the physical address. This is when the ICPDAT and the valid bit is written.</p><p>BIU_NC\u2014Input from BIU indicates the current line should not be cached.</p><p>LS<b>2</b>ICNOIC\u2014Input from LSSEC indicates no caching, pre-fetch only.</p><p>LS_CS_WR\u2014Input from LSSEC indicates the CS is being updated.</p><p>L<b>2</b>_IC_INV(<b>1</b>:<b>0</b>)\u2014Input from CMASTER to invalidate up to 2 lines in the Icache.</p><p>PF_IDX(<b>6</b>:<b>0</b>)\u2014Input from CMASTER indicates the array index for invalidating up to 2 lines in the Icache or for aliasing.</p><p>PF_SNP_COL(<b>2</b>:<b>0</b>)\u2014Input from CMASTER indicates the way associative for invalidating up to 2 lines in the Icache or aliasing. This signal may be redundant with PFREPLCOL(<b>2</b>:<b>0</b>).</p><p>BIT<b>20</b>MASK\u2014Input from CMASTER indicates masking of bit <b>20</b> for backward compatible with 8086. The line should not be cache if outside of the page.</p><p>BSTRUN\u2014Input from TAP indicates to start the BIST.</p><p>BSTRD\u2014Input from TAP indicates to read the array and compare to set the result.</p><p>BSTWR\u2014Input from TAP indicates to write the array from input registers.</p><p>BSTRST\u2014Input from TAP indicates to reset the counter.</p><p>BSTINCR\u2014Input from TAP indicates to increment the counter.</p><p>BSTDIN\u2014Input from TAP indicates the test pattern to the input registers. The input can be from the TDI pin or normal burn-in patterns.</p><p>FLUSHON\u2014Input from TAP indicates flushing register mode, the result latch should use BSTDIN instead of the compare input for flushing the result registers.</p><p>UPDOWN\u2014Input from TAP indicates counting up or down.</p><p>BSTSHF<b>1</b>\u2014Input from TAP indicates shifting of the master latch of registers.</p><p>BSTSHF<b>2</b>\u2014Input from TAP indicates shifting of the slave latch of registers.</p><p>BSTFALSE\u2014Input from TAP indicates to invert the test pattern.</p><p>PORTSEL\u2014Input from TAP indicates to select the second dual port.</p><p>BSTIDOUT\u2014Output to TAP indicates the result of the data chain from the ICSTORE and ICPDAT arrays.</p><p>BSTITOUT\u2014Output to TAP indicates the result of the data chain from the ICNXTBLK and ICTAGV arrays.</p><p>BSTAMSB\u2014Output to TAP indicates maximum count for dual port arrays.</p><p>MAXADDR\u2014Output to TAP indicates maximum index counter.</p><p>ATPGIN(<b>15</b>:<b>14</b>)\u2014Input from dedicated pins for ATPG.</p><p>ATPGOUT(<b>15</b>:<b>14</b>)\u2014Output to dedicated pins for ATPG.</p><p>ICSTORE</p><p>Processor <b>500</b> executes fast X86 instructions directly, no ROPs are needed. The pre-decode bits with each byte of instruction are 3 bits; start bit, end bit, and functional bit. All the externally fetched instructions will be latched into the Icache. This should not be a problem since the Icache is idle and waits for external instructions. Only single byte prefix of 0x66 and 0x0F is allowed for Processor <b>500</b>'s fast path, multiple prefixes including 0x67 is allowed for multi-prefix, all other prefixes will take an extra cycle in decoding or go to MROM. With these simple prefixes, the instruction bytes need not be modified. The linear valid bit is used for the whole cache-line of instructions, 16-byte. The replacement procedure is done by the CMASTER. Along with each line of instruction, the CMASTER tells the Icache which way to put in the data and tag. The start and end bits are sufficient to validate the instruction. If branching to the middle of the line or instructions wrapping to the next line, the start and end bits must be detected for each instruction or else the instruction must be pre-decoded again. The possible cases are branching to the opcode and skipping the prefix (punning of instruction) and part of the wrapping instruction is replaced in the Icache. The instructions must first pass through the pre-fetch buffers before sending to the ICPRED. The ICPRED has only one input from the IB(<b>127</b>:<b>0</b>) for both the pre-fetched or cached instructions. The pre-decode information is written into the ICPDAT as the whole line is decoded. The output IB(<b>127</b>:<b>0</b>) is merged with the previous 8-byte to form a 24-byte line for the alignment unit to select and send to 4 decode units.</p><p>Since the instruction fetching from external memory will be written directly into the Icache, the pre-fetch buffer should be built into the ICSTORE; the input/output path of the array. In this way, the data will be written into the Icache regardless of the pre-decode information or the taken branch instruction and the instructions is available to the Icache as soon as they are valid on the bus. The number of pre-fetch buffers is two, and request will be made to BIU as soon as there is space in the pre-fetch buffer for another line of instructions. The pre-fetch buffer consists of a counter and a valid bit for instructions written into the cache and a valid bit for instructions sent to the decode unit. As long as the address pointer is still in the same block, the data will be written to the array. With the pre-fetch buffer in the Icache, a dedicated bus should be used to transfer instructions directly from the pads to the Icache; this is a step to keep Processor <b>500</b> from using dynamic pre-charged buses.</p><p>ICSTORE Organization</p><p>The ICSTORE on Processor <b>500</b> does not store the pre-decode data, as shown in FIG. <b>9</b>. The ICSTORE consists of 32K bytes of instructions organized as 8 sets of 128 rows by 256 columns. The array set in this documentation has its own decoder. The decoder is in the center of the set. Each of the sets consist of 2-byte of instructions. The 8-way associative muxing from the 8 TAG-HITs is performed before the data is routed to the ICALIGN block. With this arrangement, the input/output to each set is 16-bit buses. The muxing information relating to which byte is going to which decode unit should also be decoded; this topic will be discussed in detail below in the ICALIGN block section. For optimal performance the layout of the column should be 64 RAM cells, pre-charge, 64 RAM cells, write buffer and senamp. The row decoder should be in the middle of the array to drive 128 column each way. Basically, the pre-charge and the row decoder should be crossed in the middle of the array. The self-time column is used to generate internal clock for each set of the array. Pre-charge is gated by ICLK. The instruction is valid by the end of ICLK, the data muxes by the TAG-HIT should be gated by ICLK to be valid for the second ICLK. The two-entry pre-fetch buffers are implemented inside the array with data can be written from either entry. The output IB bus is taken from either the array or the pre-fetch buffer.</p><p>The BIST for the ICSTORE array uses 128 TAEC cells for reading and writing the arrays, as discussed further below.</p><p>Signal List</p><p>ISADD(<b>11</b>:<b>2</b>)-<b>2</b>\u2014Input from ICFPC indicates the address of instruction to access the array. Bits <b>11</b>:<b>5</b> are for the row decoder, bits <b>4</b>:<b>2</b> are for column select. For normal operation, bits <b>11</b>:<b>4</b> is used to read/write 16-byte only. For special register operation, bits <b>11</b>:<b>2</b> is used to read/write 4-byte.</p><p>TAGHIT(<b>7</b>:<b>0</b>)-<b>2</b>\u2014Input from ICTAGV indicates which set is selected to read instructions.</p><p>ICSRD-<b>2</b>\u2014Input from ICCNTL to read instruction.</p><p>ICSWR-<b>2</b>\u2014Input from ICCNTL to write instructions from pre-fetch buffers into the array. This signal is asserted at starting of the pre-fetch enable and de-asserted when a pre-fetch buffer entry is valid, the instruction is written into the array and the valid bit is reset.</p><p>GETNEWL-<b>2</b>\u2014Input from ICPRED indicates that pre-decoding has reached the end of the line or encountered a taken branch instruction, a new line of instructions is needed in the next cycle. The ICSTORE should send a new line onto IB bus and write into the array.</p><p>SRSRD-<b>2</b>\u2014Input from ICCNTL to read instruction from the array in the next cycle.</p><p>SRSWR-<b>2</b>\u2014Input from ICCNTL to write instruction to the array in the next cycle.</p><p>ICSRBB(<b>31</b>:<b>0</b>)-<b>14</b>\u2014I/O from SRB indicates the special register address for the array or data transferring to/from the SRB.</p><p>SETSEL(<b>7</b>:<b>0</b>)-<b>14</b>\u2014Input from ICFPC indicates which set to read, no tag compare is needed.</p><p>TAGCHK-<b>14</b>\u2014Input from ICCNTL to indicates the valid set is from TAGHIT or SETSEL.</p><p>PBENAB-<b>14</b>\u2014Input from ICCNTL to enable the pre-fetch buffer to latch the INSB(<b>31</b>:<b>0</b>) bus and write into the array.</p><p>INSTRDY-<b>13</b>\u2014Input from BIU to indicates the valid external fetched instruction is on the INSB(<b>63</b>:<b>0</b>) bus.</p><p>INSTFLT-<b>13</b>\u2014Input from BIU to indicates the valid but faulted external fetched instruction is on the INSB(<b>63</b>:<b>0</b>) bus.</p><p>INSB(<b>63</b>:<b>0</b>)-<b>3</b>\u2014Input from external buses for fetched instruction to the Icache.</p><p>IB(<b>127</b>:<b>0</b>)-<b>1</b>\u2014Output to ICALIGN after the set select to align instructions to decode units.</p><p>PBFLT-<b>15</b>\u2014Output to ICCNTL indicates a valid faulted line of instruction from external fetch.</p><p>PBVAL-<b>15</b>\u2014Output to ICCNTL indicates a valid line of instruction from external fetch.</p><p>PBEMPTY-<b>15</b>\u2014Output to ICCNTL indicates the pre-fetch buffer is empty.</p><p>PBONE-<b>15</b>\u2014Output to ICCNTL indicates the pre-fetch buffer has one available entry.</p><p>PBFULL-<b>15</b>\u2014Output to ICCNTL indicates the pre-fetch buffer is full.</p><p>BSTRD\u2014Input from TAP indicates to read the array and compare to set the result.</p><p>BSTWR\u2014Input from TAP indicates to write the array from input registers.</p><p>BSTDIN\u2014Input from TAP indicates the test pattern to the input registers. The input can be from the TDI pin or normal burn-in patterns.</p><p>FLUSHON\u2014Input from TAP indicates flushing register mode, the result latch should use BSTDIN instead of the compare input for flushing the result registers.</p><p>BSTSHF<b>1</b>\u2014Input from TAP indicates shifting of the master latch of registers.</p><p>BSTSHF<b>2</b>\u2014Input from TAP indicates shifting of the slave latch of registers.</p><p>BSTFALSE\u2014Input from TAP indicates to invert the test pattern.</p><p>BSTSTOUT\u2014Output to ICPDAT indicates the result of the data.</p><p>ICPDAT</p><p>In Processor <b>500</b>, the pre-decode data is in a separate block than the ICSTORE, and is updated with a different timing than that of instructions. The ICPDAT is updated as the whole instruction line is completed decoding in the ICPRED. To prevent erroneous setting of the pre-decode bits, the valid bit in the ICTAGV is not set until the pre-decode data is written into the array. The pointer to ICSTORE can advance before the whole line of instruction is completed in pre-decode for split-line instruction. The pre-decode data includes three bits: start-byte, end-byte, and functional-byte. During pre-decoding, the ICPDAT uses 2 sets of latches to keep the pre-decode information for each line of instructions. The first set is for the current line and the second set is used for split-line instructions. As each instruction is completed in pre-decoding, the start and end pointers set the latches. The functional bits are kept in the ICPRED and write into the array at the completion of pre-decoding for the line. If a taken branch instruction is detected in ICPRED, the control should allow one clock cycle to write the current pre-decode data into the ICPDAT array. A special case of split-line taken branch instruction, the control allows 2 clock cycles to write the two pre-decode lines into the array.</p><p>The start-byte and the end-byte are scanned to align the instructions from ICSTORE to the decode units. A valid instruction should start with a start byte and end with an end byte before another start byte can be detected. Any invalid instruction should be detected in the scanning logic before sending the instruction to early decoding. The invalid instruction must be pre-decoded again by the ICPRED block. ICPDAT should keep all pre-decode data for the line of the confused instruction from the array which will be ORed with the functional bits from pre-decoding for writing back into the array. The pre-decoding stops on two conditions: a taken branch is detected or valid start byte (or valid instruction) is detected after the end byte from pre-decoding; this condition should be detected in the ICPDAT.</p><p>The start bits are decoded into byte-shifting information for up to 4 instructions per 8-byte block which will be used by the ICALIGN block. The start-byte pointer for the current fetching instruction is used to reset all the start and end bits before the current pointer, and the taken branch pointer from the way prediction is used to reset all the start and end bits after the branch pointer. All 8-way data should be latched in case of way mis-prediction, the corrected way should be read again from the latches for scanning. An 8-byte or 16-byte block can be read from the array to merge with the previous data to form a 16-byte line for scanning and sending to early decoding. The scanning of the start bits is sectioned into two 8-byte blocks, the maximum scanned path is 8-byte long. The scanning outputs control the muxing of up to 7 bytes for each instruction to early decoding unit. In addition, the scanning of the 8-start-byte generates the look-ahead controls of next 8-byte blocks.</p><p>ICPDAT Organization</p><p>For each 8-byte, the ICPDAT (as shown in FIG. 10) generates 4 sets of valid bits based on the start and end bits. The valid bits are muxed to the ICALIGN the same way as the instruction bytes. The valid bits are used to qualify the functional bits. Example of the valid bits for 8-byte instruction:</p><p><tables id=\"TABLE-US-00002\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Start bits</entry><entry morerows=\"0\" valign=\"top\">10100100 01110101</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">End bits</entry><entry morerows=\"0\" valign=\"top\">01001000 11101010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Valid bits 1</entry><entry morerows=\"0\" valign=\"top\">11000000 01000000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Valid bits 2</entry><entry morerows=\"0\" valign=\"top\">00111000 00100000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Valid bits 3</entry><entry morerows=\"0\" valign=\"top\">00000111 10011000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Valid bits 4</entry><entry morerows=\"0\" valign=\"top\">00000000 00000110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>In setting up the valid bits for the instructions, ICPDAT needs to validate the instruction with proper the start and end bits. Only instructions with valid start and end bits can be in ICALIGN. If the line is hit in the cache, the pre-decode data should be latched into the buffer for future reference. ICPDAT notifies ICCNTL to pre-decode the invalid instruction. The functional bits from ICPRED are ORed with the local buffer of functional bits for writing back into the array. During pre-decoding if a valid start byte is detected after an end byte, ICPDAT should notify ICCNTL to stop pre-decoding, writing the current pre-decode data into the array, and re-fetching the line for scanning. The scanning logic should use only the pre-decode data from the array. The MROM instruction should also be detected in ICPDAT with a pointer to the ICALIGN and the MROM. The MROM instruction is read directly from the IB(<b>127</b>:<b>0</b>). MROM is responsible to detect and decode the prefixes and opcode as with ICALIGN. Exemplary hardware is shown in FIG. <b>11</b>.</p><p>The Icache line sets up as two 8-byte sections, the scanned logic and fetching of next line should be independent of each other. While scanning, the end-byte should also be detected to indicate that all 8-byte can be dispatched in one clock cycle and to fetch a new line. Conditions to fetch the next 8-byte are:</p><p>Three start bits or less.</p><p>Four start bits with no more than 3 end bits.</p><p>Four start bits with 4 end bits, the last end bit is on the last byte.</p><p>Hold indication from early decoding.</p><p>Hold for more than one MROM instruction in the current 16 bytes.</p><p>Since the instruction can have up to 15 bytes which can span more than two 8-byte blocks, the ICPDAT can send the instruction to the next stage with assumed valid bits. The split-line instruction has indication to read the rest of the instruction in the next clock cycle. In the next cycle if the end bit is not detected within 15 bytes, the instruction must be sent to ICPRED for pre-decoding. The output from the ICSTORE is IB(<b>127</b>:<b>0</b>), ICPDAT provides the controls for muxing of this bus to the IB<b>1</b>(<b>191</b>:<b>0</b>) which is in the ICALIGN block. The muxing is for any of the 8-byte block on IB(<b>127</b>:<b>0</b>) to any of the 8-byte block on IB<b>1</b>(<b>191</b>:<b>0</b>). ICPRED also provides similar controls for the muxes.</p><p>If there are more than 4 instructions in the 8-byte block, the ICPDAT muxes the 8-byte block from IB(<b>127</b>:<b>0</b>) to IB<b>1</b>(<b>191</b>:<b>0</b>) and stalls the next 8-byte block. In the next clock cycle, the first 4 instructions clear the pre-decode data and the 8-byte block starts scanning with the fifth instruction. The same 8-byte block should be muxed from IB(<b>127</b>:<b>0</b>) to IB<b>1</b>(<b>191</b>:<b>0</b>) again. This mechanism keeps the ICALIGN from feeding back information on dispatching of the first 4 instructions. With this method the scanning of instructions in ICPDAT is independent of the next stage and is more flexible; either 3 or 4 instructions can be scanned.</p><p>The scanning logic for each 8-byte segment of instructions is done in parallel with the TAGHITs in the ICTAGV block. More details regarding the scanning logic may be found in the commonly assigned, co-pending patent application entitled \u201cA Parallel and Scalable Instruction Scanning Unit\u201d, Ser. No. 08/475,400 filed Jun. 7, 1995 by Narayan now abandoned and continued in U.S. patent application Ser. No. 08/915,092, now U.S. Pat. No. 5,875,315. The disclosure of this patent application is incorporated herein by reference in its entirety. It is possible to implement the fetching, scanning, early decoding, and shifting of instructions to the decode units in 4 clock cycles.</p><p>MROM Interfacing</p><p>The ICPDAT sends the MROM instruction directly to the MENG. Only one MROM instruction can be sent to the MENG per clock cycle. The MENG pipelines the MROM instructions and provides latches to keep up to 3 MROM instructions including the last MROM on IB(<b>127</b>:<b>0</b>). MROMFULL indicates that the next MROM instruction should be stalled in ICPDAT until the previous MROM instruction is dispatched to a decode unit. ICPDAT provides the byte pointer for the MENG to read the instruction from the IB(<b>127</b>:<b>0</b>) along with the functional and valid bits for decoding the instruction. ICPDAT should indicate MROM instruction to MENG only if the associated 8-bytes can be shifted to the next stage. If the instruction continues to the next line, MENG can expect to read the rest of the instruction on IB(<b>127</b>:<b>0</b>) in the next cycle (similar to sending split-line instruction to ICALIGN). The signal MROMFULL is used to stop ICPDAT to keep the data on IB(<b>127</b>:<b>0</b>) for MENG to process prefixes of the instruction. The micro-instructions rejoin the instruction pipeline in the muxing stage to the decode units. With early detection of MROM instruction to MENG, the penalty for MROM instruction is one clock cycle. MENG is responsible to decode prefixes and all fields of instructions. The same decoding logic is used in the ICPRED and ICALIGN.</p><p>In ICALIGN, as the MROM instruction is detected, it moves to dispatched position <b>0</b> and waits for micro-instructions from MENG. The following instructions fill the pipeline and dispatch as soon as the last micro-instruction is sent to decode unit. In dispatch position <b>0</b>, the MROM instruction should start in the first 8-byte block of the IB<b>2</b>(<b>191</b>:<b>0</b>) bus. The MENG can provide pointers to read the displacement and immediate fields of the MROM instruction directly from the IB<b>2</b>(<b>191</b>:<b>0</b>).</p><p>ICPDAT Organization</p><p>The ICPDAT includes of 32K of 3-bit pre-decode data organized as 8 sets of 64 rows by 192 columns. Each of the sets consists of two 3-bit pre-decode data. The pre-decode data is decoded into byte-shifting information which ise used by the ICALIGN block. The 8-way associative muxing from the 8 TAGHITs is performed before the byte-shifting data is routed to the ICALIGN block. In order for the instructions to get to the Idecode in middle of the second ICLK, the decode logic for the byte-shifting should be less than 7 gates. The byte-shifting logic has been done. Because of this byte-shifting logic, the array for ICPDAT is 64 rows instead of 128 rows for the ICSTORE array. For optimal performance the layout of the column should be 32 RAM cells, pre-charge, 32 RAM cells, write buffer and senseamp. The row decoder should be in the middle of the array to drive 96 column each way. Basically, the pre-charge and the row decoder should be crossed in the middle of the array. The self-time column is used to generate internal clock for each set of the array. Pre-charge is gated by ICLK. The byte-shifting data muxed by the TAGHIT should be gated by ICLK to be valid for the second ICLK. The output of the array should include logic to feedback the previous pre-decode data for breaking up of the line for second cycle access.</p><p>The BIST for the ICDAT array uses 48 TAEC cells for reading and writing the arrays as explained further below.</p><p>Signal List</p><p>IPADD(<b>11</b>:<b>2</b>)\u2014Input from ICFPC indicates the address of instruction to access the array. Bits <b>11</b>:<b>6</b> are for the row decoder, bits <b>5</b>:<b>2</b> are for column select. For normal operation, bits <b>11</b>:<b>4</b> is used to read/write 16-byte only. For special register operation, bits <b>11</b>:<b>2</b> is used to read/write 4-byte.</p><p>TAGHIT(<b>7</b>:<b>0</b>)\u2014Input from ICTAGV indicates which set is selected to read instructions.</p><p>ICSRD\u2014Input from ICCNTL to read instruction.</p><p>ICPWR\u2014Input from ICCNTL to write pre-decoded data from ICPRED into the array. This signal is asserted at starting of the pre-fetch enable and when ENDLINE is asserted, the pre-decode data is written into the array.</p><p>GETNEWL\u2014Input from ICPRED indicates that pre-decoding has reached the end of the line or encountered a taken branch instruction, a new line of instructions is needed in the next cycle. Used to clear the pre-decode latch.</p><p>ENDLINE\u2014Input from ICPRED indicates that pre-decoding has reached the end of the line or encountered a taken branch instruction, the pre-decode data should be written into the array.</p><p>SRPRD\u2014Input from ICCNTL to read pre-decode data for special register.</p><p>SRPWR\u2014Input from ICCNTL to write pre-decode data for special register.</p><p>ICSRBB(<b>23</b>:<b>0</b>)\u2014I/O from SRB indicates the special register address for the array or data transferring to/from the SRB. 8-byte of pre-decode data is transferred at one time. The order is Start, Functional, End bits for each byte of instruction.</p><p>SETSEL(<b>7</b>:<b>0</b>)\u2014Input from ICFPC indicates which set to read, no tag compare is needed. This signal is from SRB or branch prediction.</p><p>TAGCHK\u2014Input from ICCNTL to indicates the valid set is from TAGHIT or SETSEL.</p><p>NEWWAY\u2014Input from ICCNTL to indicates way mis-prediction to select the correct way from the latches using TAGHIT.</p><p>ENDINST\u2014Input from ICPRED indicates that pre-decoding is completed for the current instruction. The pre-decode bits should be set at this time. This signal should also be sent along with ENDLINE for partially decode instruction.</p><p>PENDIB(<b>4</b>:<b>0</b>)\u2014Input from ICPRED indicates the end byte position of the current instruction. The end bit is set and latched until pre-decoding of the whole line is completed. Bit <b>4</b> indicates if the end bit is on the next line.</p><p>PFUNCB(<b>15</b>:<b>0</b>)\u2014Input from ICPRED indicates the functional bits of current line of instructions. ICPDAT uses ENDLINE to OR these bits previous pre-decode data and write into the array. As a new line is read from the array the pre-decode data is latch in the buffer. The ICPRED must keep all the functional bits for all the pre-decoded instruction in the line.</p><p>STARTPTR(<b>3</b>:<b>0</b>)\u2014Input from ICFPC indicates the byte position of the pre-decoded bytes for current instruction. The start byte should be set at this pointer for writing. For reading, this pointer is decoded into 16 bits to zero-out all bytes before the pointer for scanning logic.</p><p>WAYBPTR(<b>3</b>:<b>0</b>)\u2014Input from ICNXTBLK indicates the byte position of the branch taken pointer of way prediciton. For reading, this pointer is decoded into 16 bits to zero-out all bytes after the pointer for scanning logic.</p><p>NEXTB(<b>1</b>:<b>0</b>)\u2014Input from ICALIGN indicates that ICALIGN can accept any 8-byte block. This signal includes other hold inputs from MROM and Idecode.</p><p>NEWLINE(<b>1</b>:<b>0</b>)\u2014Output to ICALIGN and ICFPC indicates the first (bit <b>0</b>) or the second (bit <b>1</b>) 8-byte is the starting of a new line. The current line can start at the second 8-byte. The PC and offset of instructions sending to the decode units should be adjusted accordingly.</p><p>VALSTART\u2014Output to ICCNTL indicates a valid start-byte after the end pointer from ICPRED for the current lines of instructions. The pre-decoding stops and instructions is fetched from the array.</p><p>IC<b>0</b>POS<b>1</b>(<b>3</b>:<b>0</b>)\u2014Output to ICALIGN indicates the PC's byte position of the next instruction using the end bit for instruction <b>0</b> of the first 8-byte.</p><p>IC<b>1</b>POS<b>1</b>(<b>3</b>:<b>0</b>)\u2014Output to ICALIGN indicates the PC's byte position of the next instruction using the end bit for instruction <b>1</b> of the first 8-byte.</p><p>IC<b>2</b>POS<b>1</b>(<b>3</b>:<b>0</b>)\u2014Output to ICALIGN indicates the PC's byte position of the next instruction using the end bit for instruction <b>2</b> of the first 8-byte.</p><p>IC<b>3</b>POS<b>1</b>(<b>3</b>:<b>0</b>)\u2014Output to ICALIGN indicates the PC's byte position of the next instruction using the end bit for instruction <b>3</b> of the first 8-byte.</p><p>IC<b>0</b>POS<b>2</b>(<b>3</b>:<b>0</b>)\u2014Output to ICALIGN indicates the PC's byte position of the next instruction using the end bit for instruction <b>0</b> of the second 8-byte.</p><p>IC<b>1</b>POS<b>2</b>(<b>3</b>:<b>0</b>)\u2014Output to ICALIGN indicates the PC's byte position of the next instruction using the end bit for instruction <b>1</b> of the second 8-byte.</p><p>IC<b>2</b>POS<b>2</b>(<b>3</b>:<b>0</b>)\u2014Output to ICALIGN indicates the PC's byte position of the next instruction using the end bit for instruction <b>2</b> of the second 8-byte.</p><p>IC<b>3</b>POS<b>2</b>(<b>3</b>:<b>0</b>)\u2014Output to ICALIGN indicates the PC's byte position of the next instruction using the end bit for instruction <b>3</b> of the second 8-byte.</p><p>IC<b>0</b>VAL<b>1</b>(<b>7</b>:<b>0</b>)\u2014Output to ICALIGN indicates valid bytes for instruction <b>0</b> of the first 8-byte. The valid bytes are used for muxing of the bytes to early decoding. The valid bytes can continue to next 8-byte blocks until the end bit is detected.</p><p>IC<b>1</b>VAL<b>1</b>(<b>7</b>:<b>0</b>)\u2014Output to ICALIGN indicates valid bytes for instruction <b>1</b> of the first 8-byte. The valid bytes are used for muxing of the bytes to early decoding. The valid bytes can continue to next 8-byte blocks until the end bit is detected.</p><p>IC<b>2</b>VAL<b>1</b>(<b>7</b>:<b>0</b>)\u2014Output to ICALIGN indicates valid bytes for instruction <b>2</b> of the first 8-byte. The valid bytes are used for muxing of the bytes to early decoding. The valid bytes can continue to next 8-byte blocks until the end bit is detected.</p><p>IC<b>3</b>VAL<b>1</b>(<b>7</b>:<b>0</b>)\u2014Output to ICALIGN indicates valid bytes for instruction <b>3</b> of the first 8-byte. The valid bytes are used for muxing of the bytes to early decoding. The valid bytes can continue to next 8-byte blocks until the end bit is detected.</p><p>IC<b>0</b>VAL<b>2</b>(<b>7</b>:<b>0</b>)\u2014Output to ICALIGN indicates valid bytes for instruction <b>0</b> of the second 8-byte. The valid bytes are used for muxing of the bytes to early decoding. The valid bytes can continue to next 8-byte blocks until the end bit is detected.</p><p>IC<b>1</b>VAL<b>2</b>(<b>7</b>:<b>0</b>)\u2014Output to ICALIGN indicates valid bytes for instruction <b>1</b> of the second 8-byte. The valid bytes are used for muxing of the bytes to early decoding. The valid bytes can continue to next 8-byte blocks until the end bit is detected.</p><p>IC<b>2</b>VAL<b>2</b>(<b>7</b>:<b>0</b>)\u2014Output to ICALIGN indicates valid bytes for instruction <b>2</b> of the second 8-byte. The valid bytes are used for muxing of the bytes to early decoding. The valid bytes can continue to next 8-byte blocks until the end bit is detected.</p><p>IC<b>3</b>VAL<b>2</b>(<b>7</b>:<b>0</b>)\u2014Output to ICALIGN indicates valid bytes for instruction <b>3</b> of the second 8-byte. The valid bytes are used for muxing of the bytes to early decoding. The valid bytes can continue to next 8-byte blocks until the end bit is detected.</p><p>ICENDB<b>1</b>(<b>3</b>:<b>0</b>)\u2014Output to ICALIGN indicates if end-bits for 4 instructions are detected in the first 8-byte block. If the end-bit is not set, the instruction continue to the next 8-byte blocks.</p><p>ICENDB<b>2</b>(<b>3</b>:<b>0</b>)\u2014Output to ICALIGN indicates if end-bits for 4 instructions are detected in the second 8-byte block. If the end-bit is not set, the instruction continue to the next 8-byte blocks.</p><p>ICFUNC(<b>15</b>:<b>0</b>)\u2014Output to ICALIGN and MENG indicates functional-bits, bits <b>7</b>:<b>0</b> are for the first 8-byte block and bits <b>15</b>:<b>8</b> are for the second 8-byte block.</p><p>INVPTR(<b>3</b>:<b>0</b>)\u2014Output to ICFPC indicates the start pointer of the invalid instruction which needs to be pre-decoded.</p><p>INVINST\u2014Output to ICFPC and ICCNTL indicates the invalid instruction which needs to be pre-decoded. No valid byte should be sent to the ICALIGN.</p><p>MROMPTR(<b>3</b>:<b>0</b>)\u2014Output to ICFPC and MROM indicates the start pointer of the MROM instruction</p><p>ICMROM(<b>1</b>:<b>0</b>)\u2014Output to MENG, bit <b>0</b> indicates the current instruction is MROM, bit <b>1</b> indicates the MROM instruction continue to the next line (end-bit is not detected in the current line).</p><p>MROMFUL\u2014Input from MENG indicates MENG cannot accept any more instruction.</p><p>IC<b>8</b>BSEL(<b>5</b>:<b>0</b>)\u2014Output to ICALIGN controls the muxes from IB(<b>127</b>:<b>0</b>) to IB<b>1</b>(<b>191</b>:<b>0</b>). Bit <b>5</b>:<b>3</b> is for the upper 8-byte IB(<b>127</b>:<b>64</b>) and bit <b>2</b>:<b>0</b> is for the lower 8-byte IB(<b>63</b>:<b>0</b>). <b>001</b> is for muxing to IB<b>1</b>(<b>63</b>:<b>0</b>), the first 8-byte, <b>010</b> is for muxing to the second 8-byte, and <b>100</b> is for muxing to the third 8-byte.</p><p>INVAL<b>2</b>\u2014Output to ICALIGN to invalidate the second 8-byte block which has been muxed to IB<b>1</b>(<b>191</b>:<b>0</b>) because the first 8-byte has more than 4 instructions or the taken branch invalidates the second 8-byte block.</p><p>BSTRD\u2014Input from TAP indicates to read the array and compare to set the result.</p><p>BSTWR\u2014Input from TAP indicates to write the array from input registers.</p><p>BSTSTOUT\u2014Input from ICSTORE connects the BIST chain.</p><p>FLUSHON\u2014Input from TAP indicates flushing register mode, the result latch should use BSTDIN instead of the compare input for flushing the result registers.</p><p>BSTSHF<b>1</b>\u2014Input from TAP indicates shifting of the master latch of registers.</p><p>BSTSHF<b>2</b>\u2014Input from TAP indicates shifting of the slave latch of registers.</p><p>BSTFALSE\u2014Input from TAP indicates to invert the test pattern.</p><p>BSTIDOUT\u2014Output to TAP indicates the result of the data chain from the ICSTORE and ICPDAT arrays.</p><p>ICTAGV</p><p>Processor <b>500</b> executes the fast X86 instructions directly and the instructions are written into the Icache regardless of the pre-decode information. The linear valid bit is used for the whole line of instructions, assuming that the BIU always fetches 16-bytes of data. The CMASTER indicates which way to put in the pre-fetch data and tag. Writing of the tag is done at the same time as writing the data into the ICSTORE, and writing of the linear valid bit is done at the same time as writing the pre-decode bits into the ICPDAT. The start and end bits are sufficient to validate the instruction. If branching to the middle of the line or instructions wrapping to the next line, the start and end bytes must be detected for each instruction or else the instruction must be pre-decoded again. The possible cases for invalid instructions are (1) branching to the opcode and skipping the prefix, (2) part of the wrapping instruction are replaced in the Icache, (3) part of the line was not pre-decoded because of branch instruction and branch target. Whenever the MMU is re-mapped or the CMASTER execute a certain instruction, all the LV bits can be cleared. The next access to the Icache would results into LV miss, the CMASTER may send new mapping information to the Icache regarding the way associative, the SU, and the new tag. In this case the Icache needs to write the ICTAGV with new information (including setting the LV bit) and read the other arrays.</p><p>From the branch prediction, tag address must be read from the ICTAGV in the next cycle to merge with the successor index for the predicted target address. The predicted target address must be sent to the decode units and to the functional units for comparison.</p><p>ICTAGV Organization</p><p>The ICTAGV includes 2048 lines of:</p><p>20-bit Tag address.</p><p>2 Status bits (SU, LV).</p><p>The status bits need to be dual-port to read and write in the same clock cycle. The ICTAGV is organized as two sets of 64 rows by 224 columns and two sets of 64 rows by 128 columns. Each of the first two sets consists of 7-bit tag address, and each of the last two sets consists of 3-bit tag address and the SU or LV bit. The two status bits are dual port RAM cells. The SU uses the delayed PC to write, and the LV bit has the snooping index from CMASTER. The ICTAGV uses 64 rows for dual-port RAM and quick reading of tag address. For optimal performance the layout of the column should be 32 RAM cells, pre-charge, 32 RAM cells, write buffer and senamp. The row decoder should be in the middle of the array to drive 112 or 96 columns each way. Basically, the pre-charge and the row decoder should be crossed in the middle of the array. The row decoder for the dual port RAM should be build at one end of the array. The self-time column is used to generate internal clock for each set of the array. Pre-charge is gated by ICLK. The status bits muxed by the TAGHIT should be gated by ICLK to be valid for the second ICLK. The above layout is to ensure the minimum routing for the TAGHIT, and is shown in FIG. <b>12</b>.</p><p>The BIST for the ICTAGV array uses 22 TAEC cells for reading and writing the arrays, as explained further below.</p><p>Signal List</p><p>ITADD(<b>11</b>:<b>4</b>)\u2014Input from ICFPC indicates the address of instruction to access the array. Bits <b>11</b>:<b>5</b> are for the row decoder, bit <b>4</b> is for column select. Writing into the SU array is a delay of the index to next ICLK.</p><p>IVADD(<b>11</b>:<b>4</b>)\u2014Input from ICFPC indicates the address of instruction to write the LV bit. Bits <b>11</b>:<b>5</b> are for the row decoder, bit <b>4</b> is for column select.</p><p>ICTAG(<b>31</b>:<b>12</b>)\u2014Input from ICFPC indicates the address of instruction to compare with the tag arrays.</p><p>ICTVRD\u2014Input from ICCNTL to read tag array.</p><p>ICTWR\u2014Input from ICCNTL to write new tag.</p><p>ICCLRA\u2014Input from ICCNTL to clear all valid bits.</p><p>ICSUWR\u2014Input from ICCNTL to write the SU bit.</p><p>ICLVWR\u2014Input from ICCNTL to write the LV bit.</p><p>SRTVRD\u2014Input from ICCNTL to read tag for special register.</p><p>SRTVWR\u2014Input from ICCNTL to write tag for special register.</p><p>ICSRBB(<b>31</b>:<b>10</b>)\u2014I/O from SRB indicates the special register address for the array or data transferring to/from the SRB. Bits <b>31</b>:<b>12</b> are the address, bit <b>11</b> is the supervisor/user, and bit <b>10</b> is the valid bit.</p><p>SETSEL(<b>7</b>:<b>0</b>)\u2014Input from ICFPC indicates which set to read, no tag compare is needed.</p><p>TAGCHK\u2014Input from ICCNTL to indicates the valid set is from TAGHIT or SETSEL.</p><p>TAGHIT(<b>7</b>:<b>0</b>)\u2014Output indicates which set is selected to read instructions.</p><p>VALBIT(<b>7</b>:<b>0</b>)\u2014Output indicates the valid bits of 8 sets, uses for way-prediction.</p><p>TVSU\u2014Output indicates the supervisor/user mode of current block.</p><p>IBTARGET(<b>31</b>:<b>12</b>)\u2014Output to decode unit indicates the predicted taken branch target for the line on instruction in the previous cycle. The predicted taken branch from ICNXTBLK provides only the index, the upper bits are read from ICTAGV in the next cycle.</p><p>BSTRD\u2014Input from TAP indicates to read the array and compare to set the result.</p><p>BSTWR\u2014Input from TAP indicates to write the array from input registers.</p><p>BSTNBOUT\u2014Input from ICNXTBLK connects the BIST chain.</p><p>FLUSHON\u2014Input from TAP indicates flushing register mode, the result latch should use BSTDIN instead of the compare input for flushing the result registers.</p><p>BSTSHF<b>1</b>\u2014Input from TAP indicates shifting of the master latch of registers.</p><p>BSTSHF<b>2</b>\u2014Input from TAP indicates shifting of the slave latch of registers.</p><p>BSTFALSE\u2014Input from TAP indicates to invert the test pattern.</p><p>PORTSEL\u2014Input from TAP indicates to select the second dual port.</p><p>BSTITOUT\u2014Output to TAP indicates the result of the data chain from the ICNXTBLK and ICTAGV arrays.</p><p>ICNXTBLK</p><p>This block contains the branch prediction information for the Icache. An important feature for performance of superscalar/superpipelined microprocessors is branch prediction. As the number of pipeline stages and the number of functional units increase the cost of mis-prediction is high. The tag comparison and selection of the 8-way associative in ICTAGV takes more than one clock cycle to resolve. Processor <b>500</b> implements another prediction technique to pick one out of the 8 ways and to use the predicted way for fetching of next line to remove the bubble in the pipeline. Three bits are needed for this way prediction. Another two bits are needed to select one of the two branch targets for fetching the next predicted line. Without the two bits to select the branch targets, comparison of the start-byte position with the positions of the branch targets will cause the way-prediction to be more than one clock cycle. This speculatively selected line of instructions can be corrected in the next cycle from the proper TAGHIT and the branch prediction. The following rules are used to set up the ICNXTBLK:</p><p>During pre-decode, if there is an unconditional branch instruction, the fetching is stalled until the new target PC can be calculated. If the branch is direct, the target PC can be calculated in the next cycle in the ICFPC.</p><p>The backward taken conditional branch which the new target PC can be calculated in the ICPFC should also predict taken.</p><p>If the branch is indirect, the target PC is from the functional unit. The speculative way-prediction is updated with the successor index in the cycle following the target address access. If there is no pre-decoded taken branch, the speculative way-prediction is updated after fetching of the next sequential block. The index after accessing the array should be kept for 3 clock cycles before the way-prediction is known for updating.</p><p>From mis-prediction, the new target PC will be fetched and the selected set and successor index will be kept in a branch holding registers which will be discussed in next section.</p><p>For better branch prediction hit ratio, the ICNXTBLK will increase to 2 branch targets for both taken and non-taken branches, and pre-decode for the unconditional branches and taken branches. The pre-decoding also calculate the branch target address for the branch instructions if available. If there is a hit in the ICNXTBLK, the new target will be used for the new fetch PC. The taken branch will have higher priority to occupy the two targets in ICNXTBLK.</p><p>Processor <b>500</b> will implement two different branch predictors to maximize the performance. The next few sections discuss the Bimodal and Global predictors and the implementation of the combined branch predictor on Processor <b>500</b>.</p><p>Bimodal Branch Prediction</p><p>This branch prediction uses a saturated counter for prediction. A 2-bit counter is used for taken/non-taken prediction. The most significant bit is used for taken/non-taken prediction. Since branch instructions are more likely to be taken than non-taken, the counter should initialize to 10 if the branch target address can be calculated. As the branch is taken, the counter increases by 1 and is saturated at 11. As the branch is not taken, the counter decreases by 1 and is saturated at 00. The bimodal branch prediction is better than a single bit prediction as the branch correct prediction is 88.09% instead of 82.29% for two targets prediction. The bimodal branch prediction behaves well for mostly taken or non-taken branch instruction and is worst as the conditional branches flip-flop between taken and non-taken. The cost is one extra bit per branch target in the ICNXTBLK, and extra logic for the counter.</p><p>Global Branch Prediction</p><p>This branch prediction is an independent branch predictor, not a part of the Icache. There are many different types of global branch prediction; Processor <b>500</b> uses the global branch prediction which has the highest branch correct prediction ratio. The prediction entries are indexed by an exclusive OR of the PC and the branch shift register, which is referred to as global sharing branch prediction. This global branch prediction has the branch correct prediction at 89.24%; the prediction improves as more branch history bits are used in the prediction. A single shift register records the direction taken/non-taken by the most recent n conditional branches. Since the branch history is global to all branches, global branch prediction takes advantage of two types of patterns, the direction taken by the current branch may depend strongly on the other recent branches, and the duplicating the behavior of local branch prediction (patterns of branches in loops). For Processor <b>500</b>, since the highest priority of the two branch targets is taken branch, the global shift register includes both the conditional and unconditional branches. In a few cases, the non-taken conditional branches may not include in the global shift register. To match the number of entries in the Icache, the global branch prediction needs to have 2048 entries with 2 targets per entry. It is organized with 256 rows of 8-way associative. Eight bits are used to index the branch prediction table. The PC uses bit <b>11</b>:<b>4</b> for indexing the branch prediction table.</p><p>Processor <b>500</b>'s Combined Branch Prediction</p><p>Combining the Bimodal and Global branch predictions should give a better correct prediction ratio. A predictor counter is used to select which branch predictor is better for each individual branch instruction. This technique should give a higher correct prediction ratio than the above two prediction techniques; the prediction ratio can be shown to be 89.93%. The same saturated counter is used for the predictor counter: if the bimodal predictor is correct and the global predictor is incorrect then increase the counter until saturated; if the global predictor is correct and the bimodal predictor is incorrect then decrease the counter until saturated; else no change in the predictor counter. The most significant bit of the predictor counter is used for selecting the branch predictor. ICNXTBLK is implemented with the bimodal counter and the predictor counter. ICNXTBLK has 2 targets per instruction line, where each target consists of the following:</p><p>12 bits\u2014successor index, need <b>11</b>:<b>4</b> for global table index, <b>11</b>:<b>0</b> for icache.</p><p>3 bits\u2014for 8-way associative.</p><p>4 bits\u2014byte position of the branch instruction within the current line.</p><p>2 bits\u2014bimodal counter</p><p>2 bits\u2014predictor counter</p><p>1 bit\u2014valid target</p><p>The table for global branch predictor also has 2 targets per entry, where each entry consists of a 2-bit global counter. The bimodal and predictor counters must be able to update the count on every cycle. The least significant bit of the counters is dual ported. If the count is 10, predicted taken, the new count is 11. If the count is 01, predicted non-taken, the new count is 00. Only on branch mis-prediction does the most significant bit of the counters change state.</p><p>The successor index, way, and byte position are shared between the bimodal and global counters. The predictor counter selects between the bimodal and global counters. The combination of the counters is to predict branch instructions as taken/non-taken. In most cases, the shared target is sufficient for the two branch predictors. The branch may have two different targets depended on two different patterns of branch instructions. In this case, the global predictor may desire to have its own target. It would be very expensive in layout area to have 4 targets per 16 bytes of instruction. A diagram of ICNXTBLK is shown as FIG. <b>13</b>.</p><p>Implementation of Global Branch Tag for Recovery</p><p>As discussed above, the global branch predictor needs a table with 256 rows, 8-way associative, and 2 targets per line. A shift register of 8 bits is needed for indexing. The global branch predictor shift register must be able to back track to the previous conditional branch which is mis-predicted. As each conditional branch is predicted, the direction of the branch is shifted into the shift register from right to left, 1 for taken and 0 for non-taken. The shift register needs a total of 24 bits and each of the bit beyond the 8 indexing bits needs to have a tag. The tag has 4 bits to indicate the conditional branch position in the shift register. FIROB has 6 lines of 4 instructions and the pipeline from fetch to dispatch can hold another 3 lines of 4 instructions for a total of 36 instructions. The average length of X86 instruction is 3 bytes, thus (36 instruction\u00d73 bytes) 108 bytes are equivalent to 6.75 lines from the Icache. Each Icache line of instructions can have up to 2 branch targets, which is 14 branch instructions in the pipeline. The extra 16 bits in the shift register is sufficient to handle all branches in the pipeline. The shift register needs to keep track of all branch instructions. All the branch tags and the taken/non-taken bits are shifted in the shift register. The shift register tag (branch tag) is routed with the branch instruction to the functional units and FIROB. As the branch instruction is mis-predicted the branch tag is used to retreat the old 8 bits in the shift register to restore the shift register with new direction for the mis-predicted branch instruction.</p><p>Even though it is unlikely that the number of branch instructions in the pipeline exceeds 16, a mechanism is needed to detect the overflow of the global shift register. An extra valid bit is set for each branch in the global shift register. As the branch instruction is retired, the branch tag is returned to the global shift register to clear all the tail valid bits from the branch tag. As the global shift register is shifted, if the valid bit at the tail of the shift register is set, then the pipeline must stall for the branch instruction to retire from the FIROB.</p><p>In the global shift register, beside the taken/non-taken bits, the branch predictor count, the bimodal count, the global count, the valid bit, and the branch target number should be kept in the same global shift register which will be restored for updating of the counters and the branch target number in case of branch mis-prediction. The counters are 6 bits, the valid is 1 bit, the branch target number is 1 bit, the taken/non-taken is 1 bit, and the branch tag is 4 bits; the total bits in the shift register is 13. The branch target number is to update one of the two branch targets in the ICNXTBLK. Since the ICNXTBLK can keep only two branch targets, some of the branch instructions may not be detected and may not get a branch tag from the global shift register. If the mis-prediction was not in the branch prediction, a new entry should be setup. The counters will be restored and incremented/decremented before sending to the holding register for updating the mis-predicted block. The return stack in the ICFPC should also restore from mis-prediction.</p><p>The global shift register is set and shifted in the second ICLK as the branch prediction is determined. In later pipeline stages, the unconditional jump, call, and return instructions can be detected and change the direction of the fetched instruction. In this case, the global shift register must be restored. A new branch tag is setup for the unconditional jump, call, and return instructions. The only branch instructions without branch tags are the conditional branch instruction which are not recorded in the ICNXTBLK. The ICFPC must keep track of the branch instructions in the first 4 pipeline stages for recovery of the global shift register.</p><p>All the branches must be detected in pre-decoding and kept in the ICNXTBLK unless there are more than two branches. If the branch is mis-predicted and not detected in the prediction then there are more than two branches in the same line with the mis-predicted branch. On Processor <b>500</b>, there are two branch targets, if the branch mis-prediction matches one of the target, then the mis-prediction will update the same target. If the branch mis-prediction was not in the ICNXTBLK, then one of the two branch targets must be selected to be replaced. Information is needed with each of the line PC, the associated branch information from dispatching is:</p><p>Taken/non-taken (<b>1</b>/<b>0</b>) for the two branch targets of the current line PC.</p><p>Current way selection of the line PC.</p><p>Taken/non-taken prediction with each branch instruction.</p><p>Global shift register branch tag with each branch instruction.</p><p>Valid branch tag indication with each instruction.</p><p>Non-taken is assumed for the invalid branch targets in the ICNXTBLK. Branch target bits and way select are sent with the PC to the FIROB. The FIROB returns the two branch target bits upon mis-prediction for replacement algorithm of the branch targets in the ICNXTBLK. The first priority for replacing the branch targets is non-taken. If both bits are set for the line of the mis-predicted branch, then random replacement based on the least significant bit of the address is used. For branch mis-prediction, the following information are returned from the FIROB:</p><p>Current branch way select.</p><p>Valid branch tag indication.</p><p>Branch tag.</p><p>Current branch index.</p><p>Taken/non-taken branch target bits of the line PC.</p><p>New branch target address.</p><p>A diagram of the global branch predictor is shown as FIG. <b>14</b>.</p><p>Branch-Holding Register for Updating Branch Targets</p><p>Some processors use the successor index instead of the full address to limit the size of the array, the selected way for the successor index is known after the branch target is fetched from the Icache. Updating the ICNXTBLK with successor index and selected way required dual-port RAM. With two targets per line of instructions, the current dual-port RAM cells implementation of the ICNXTBLK would make the ICNXTBLK array larger than the ICSTORE array. There are two cases of updating the branch targets: during pre-decoding of taken branch instruction and branch mis-prediction. On Processor <b>500</b>, an extra branch holding register for branch mis-prediction and pre-decoding branch instruction will be implemented. The branch holding register should always be compared to the PC address and forward the data instead of reading from the ICNXTBLK. When the next branch mis-prediction occurs, the FIROB sends the logical address PC. The successor index, the way select, and branch predictor counts are latched inside the ICNXTBLK to write into the array at a later convenient time. Since the way prediction array is dual-ported, it should be updated immediately instead of keeping in the branch holding register. The branch holding register will update the last mis-predicted branch target to the ICNXTBLK as the ICFPC takes one cycle to calculate the new linear address from the logical address. Another condition to write the branch holding register into the ICNXTBLK array is when external fetch is started. With the branch holding register, the ICNXTBLK array can be single-ported which is less than half the size of the dual-ported array. The branch holding register includes the branch address which is used for comparison and forwarding of data, the successor index, the update branch predictor count after reading of the new target line. The branch address register resides in the ICFPC for comparison to the current fetch PC. If the mis-prediction is a RETURN instruction, only the target selection of the way prediction should be updated.</p><p>The branch predictor counters are kept in the global shift register. If the mis-prediction returns a valid branch tag, then the counters increase or decrease before latching in the branch holding register. If the mis-prediction does not have a valid branch tag, then the bimodal counter is used with <b>10</b>. The global shift register should restore the proper branch pattern and the return stack should remove the cancelled CALL/RETURN instructions.</p><p>Way Prediction</p><p>Since the evaluation of the branch prediction takes two cycles which would create a bubble in the pipeline, the way-prediction is implemented for faster prediction. The way prediction predicts one of the 8-way associative will be hit, and uses the ICNXTBLK for the next fetch PC. The way-prediction is validated in the next cycle with the TAGHIT and the actual branch prediction. If the way is mis-predicted, a correct way will be selected for the 8-way latches in the ICPDAT and a new line will be fetched creating a bubble in the pipeline. Since the tag compare is not completed until the next clock cycle, the scanning logic should be done in parallel with the tag compare for optimal timing of fetching instruction. The scanning logic is implemented on all 8 ways pre-decode data and the outputs are selected by TAGHIT. With the way prediction, a single pre-decode data can be selected for scanning logic thus reducing the logic to one-eighth. The ICPDAT must implement a set of latches to keep the output data; in case of way mis-prediction, the correct data will be used for scanning logic in the next cycle. The branch prediction in the ICNXTBLK should be resolved in parallel with TAGHIT for the correct next line fetch in the third cycle. The instructions from the ICSTORE are not needed for aligning until the next clock cycle which will be selected by TAGHIT. The way select from branch prediction should be used to select the way instead of the way prediction. From branch prediction, there is no tag comparator for the upper address bits.</p><p>The way-predicting has 3 bits to mux the successor index and branch prediction from ICNXTBLK for accessing the Icache in the next cycle. Depending the current fetch PC's position, the way prediction can use one of the two branch targets or none for sequential. In order to access the next PC within a cycle, a target selection of 2 bits is needed. The target selection can also include the return stack option. The program for the target selection is:</p><p>00\u2014sequential,</p><p>01\u2014first branch target,</p><p>10\u2014second branch target,</p><p>11\u2014return stack.</p><p>The way prediction should provide the byte position of the return instruction so that the ICPDAT can invalidate all followed instructions. For speed, another 4 bits are needed to indicate the byte position pointer for the instruction after the taken branch instruction for ICPDAT. The ICPDAT can decode and invalidate the pre-decode data directly from this 4-bit branch pointer. If the 4-bit branch pointer-is all zeros, no invalidation of the pre-decode data is needed.</p><p>The way prediction includes dual ported RAM cells because the information must be updated while reading data, the initial value for the way prediction should be the same as the current PC's set. The way prediction is not known for updating until the next clock cycles or until the early decoding of the return instruction. For convenience, a holding way register is used for updating of the way prediction in the fifth ICLK.</p><p><tables id=\"TABLE-US-00003\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"6\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">Clock</entry><entry morerows=\"0\" valign=\"top\">Latch 1</entry><entry morerows=\"0\" valign=\"top\">Latch 2</entry><entry morerows=\"0\" valign=\"top\">Latch 3</entry><entry morerows=\"0\" valign=\"top\">Latch 4</entry><entry morerows=\"0\" valign=\"top\">Latch 5</entry><entry morerows=\"0\" valign=\"top\">PC0</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">read</entry></row><row><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">PC1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">branch pred</entry></row><row><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">PC2</entry><entry morerows=\"0\" valign=\"top\">PC1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">return inst.</entry></row><row><entry morerows=\"0\" valign=\"top\">4</entry><entry morerows=\"0\" valign=\"top\">PC3</entry><entry morerows=\"0\" valign=\"top\">PC2</entry><entry morerows=\"0\" valign=\"top\">PC1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">decoding</entry></row><row><entry morerows=\"0\" valign=\"top\">5</entry><entry morerows=\"0\" valign=\"top\">PC4</entry><entry morerows=\"0\" valign=\"top\">PC3</entry><entry morerows=\"0\" valign=\"top\">PC2</entry><entry morerows=\"0\" valign=\"top\">PC1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">update way</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">pred</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Clock</entry><entry morerows=\"0\" valign=\"top\">Latch 1</entry><entry morerows=\"0\" valign=\"top\">Latch 2</entry><entry morerows=\"0\" valign=\"top\">Latch 3</entry><entry morerows=\"0\" valign=\"top\">Latch 4</entry><entry morerows=\"0\" valign=\"top\">Latch 5</entry><entry morerows=\"0\" valign=\"top\">PC0</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">read</entry></row><row><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">PC1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">way mis-pred</entry></row><row><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">PC2</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">return inst.</entry></row><row><entry morerows=\"0\" valign=\"top\">4</entry><entry morerows=\"0\" valign=\"top\">PC3</entry><entry morerows=\"0\" valign=\"top\">PC2</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">decoding</entry></row><row><entry morerows=\"0\" valign=\"top\">5</entry><entry morerows=\"0\" valign=\"top\">PC4</entry><entry morerows=\"0\" valign=\"top\">PC3</entry><entry morerows=\"0\" valign=\"top\">PC2</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">update way</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">pred</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The way mis-prediction can be at two levels, the first level is the wrong predicted way and the second level is the wrong selected target. Way mis-prediction is from comparing the predicted way to the tag compares, a mis-prediction would have re-fetched the correct instruction line and a new fetch address as shown in case <b>1</b> of FIG. <b>15</b>. If the way prediction is correct, the next level is the target selection mis-prediction, the recovery mechanism is shown in case <b>2</b> of FIG. <b>15</b>. The return stack prediction is not known until ICLK<b>4</b> to correct the fetch done in ICLK<b>2</b>, other target predictions are compared to the branch prediction in ICLK<b>2</b> and re-fetch the next address in ICLK<b>3</b> as shown in case <b>3</b> of FIG. <b>15</b>.</p><p>ICNXTBLK Organization</p><p>The ICNXTBLK consists of 2048 lines of 2 branch targets, each target consist of 24 bits:</p><p>12 bits\u2014successor index, need <b>11</b>:<b>4</b> for global table index, <b>11</b>:<b>0</b> for icache.</p><p>3 bits\u2014for 8-way associative.</p><p>4 bits\u2014byte position.</p><p>2 bits\u2014bimodal counter.</p><p>2 bits\u2014predictor counter.</p><p>1 bit\u2014valid target.</p><p>The least significant bits of the bimodal and predictor counters are dual ported for writing back the increment count after reading. For speculative prediction, the most significant bit of the counter should not change. The new value of the bimodal and predictor counters are speculative; if there is a branch mis-prediction, the corrected counters will be written from the branch holding register.</p><p>The ICNXTBLK also includes 2048 lines for way prediction which are dual ported:</p><p>3 Way-prediction bits.</p><p>2 Target-selection bits.</p><p>4 Taken branch byte-position bits.</p><p>The global branch prediction includes 2048 lines of 2 global counters which is organized as 256 rows for 8-way associative. The least significant bit of the global counter is dual ported for reading and writing the speculative prediction in the next cycle.</p><p>The ICNXTBLK is organized as 4 sets of 64 rows by 256 columns, 2 sets of 64 rows by 196 columns including some dual-ported columns, 1 set of 64 rows by 128 dual-ported column, 1 set of 64 rows by 96 dual-ported columns, 1 set of 64 rows by 64 dual-ported columns, and 1 set of global counter array. Each of the first two sets consist of 2\u00d74 bits of successor index. The next two sets consists of 2\u00d74 bits of successor index and 2\u00d74 bits of the byte position. The next two sets consists of 2\u00d72 bits bimodal counter, 2\u00d72 bits predictor counter, and 2\u00d73 bits 8-way associative, the least significant bits of the counters are dual-port. The next set consists of 4 bits of way branch byte pointer. The last two sets consist of the 3 bits way-prediction and 2 bits target selection which are dual-ported RAM cells. The least significant bits of the counters are dual ported to be updated on every cycle. To minimize routing and implementation of the branch holding register, the same associated bits of the two branch targets should be laid out in two sets opposite each other. The branch successor index is selected by the way and target prediction to access the ICACHE in next clock cycle. Because of this speed-path in way prediction for reading the Icache in the next cycle, the array for ICNXTBLK is 64 rows instead of 128 rows as for the ICSTORE array. For optimal performance the layout of the column should be 32 RAM cells, pre-charge, 32 RAM cells, write buffer and senamp. The row decoder should be in the middle of the array to drive 96 or 112 column each way. Basically, the pre-charge and the row decoder should be crossed in the middle of the array. The self-time column is used to generate internal clock for each set of the array. Pre-charge is gated by ICLK. The ICNXTBLK has two different outputs; the first output in the first cycle is based on the way-prediction, and the second output in the second cycle is based on TAGHIT. If the two outputs do not select the same set or are not both non-taken, the reading of instruction in the second cycle will be invalidated, creating a bubble in the pipeline. The second output should be gated with TAGHIT and ICLK to be valid in the second cycle.</p><p>The branch holding register may be built into the ICNXTBLK array. This means that the bits of the two targets must be alternated in the array to access the branch holding register. The array may be skewed to accommodate the bits into a single array. The global branch counter is also implemented as the array in ICNXTBLK. The shift register and the branch tag for mis-prediction recovery are also implemented next to the array.</p><p>The BIST uses 55 TAEC cells for reading and writing the arrays. See the section on BIST and ATPG. A diagram of ICNXTBLK layout is shown as FIG. <b>16</b>.</p><p>Signal List</p><p>INADD(<b>11</b>:<b>3</b>)\u2014Input from ICFPC indicates the address of instruction to access the array. Bits <b>11</b>:<b>5</b> are for the row decoder, bit <b>4</b> is for column select, bit <b>3</b> is for special register read/write to each target. This index should be delayed by 3 cycles to write data for the way prediction bits. This index should be latched into the branch holding register.</p><p>ICNVRD\u2014Input from ICCNTL to read branch prediction array.</p><p>ICNWR\u2014Input from ICCNTL to write branch prediction. This signal is asserted during pre-decoding, the ENDLINE and not PDTAKEN cause the branch holding register to be written into the array.</p><p>ICBCWR\u2014Input from ICCNTL to write bimodal counter bits. The index is 2 cycle delay from INADD.</p><p>ICPSWR\u2014Input from ICCNTL to write predictor counter bits. The index is 2 cycle delay from INADD.</p><p>ICGCWR\u2014Input from ICCNTL to write global counter bits. The index is 2 cycle delay from INADD.</p><p>ICWWR\u2014Input from ICCNTL to write way prediction bits. The index is 3 cycle delay from INADD.</p><p>INVBHREG\u2014Input from FIROB to invalidate the branch holding register. The branch mis-prediction is speculative, an early branch can be mis-predicted at a later time.</p><p>WRBHREG\u2014Input from ICCNTL to write the branch holding register with information from the global shift register or from ICPRED.</p><p>WRBHREG<b>1</b>\u2014Input from ICCNTL to write the branch holding register with the way and successor index from accessing the array with information from the global shift register or from ICPRED. This signal is 1 cycle later than WRBHREG.</p><p>SRNRD\u2014Input from ICCNTL to read branch prediction for special register.</p><p>SRNWR\u2014Input from ICCNTL to write branch prediction for special register.</p><p>ICSRBB(<b>28</b>:<b>0</b>)\u2014I/O from SRB indicates the special register address for the array or data transferring to/from the SRB. Bits <b>23</b>:<b>0</b> are the branch target, bit <b>28</b>:<b>26</b> is the way-selected prediction, and bit <b>26</b>:<b>24</b> is way-target prediction. The array requires bit <b>3</b> of the address to read the whole line.</p><p>SETSEL(<b>7</b>:<b>0</b>)\u2014Input from ICFPC indicates which set to read, no tag compare is needed.</p><p>TAGCHK\u2014Input from ICCNTL to indicates the valid set is from TAGHIT or SETSEL.</p><p>TAGHIT(<b>7</b>:<b>0</b>)\u2014Input from ICTAGV indicates which set is selected to read branch array.</p><p>GETNEWL\u2014Input from ICPRED indicates that pre-decoding has reached the end of the line or encountered a taken branch instruction, a new line of instructions is needed in the next cycle. Use to start with the first target and increase to second target as a branch instruction is detected.</p><p>ENDLINE\u2014Input from ICPRED indicates that pre-decoding has reached the end of the line or encountered a taken branch instruction, the pre-decode data should be written into the array.</p><p>ENDINST\u2014Input from ICPRED indicates that pre-decoding is completed-for the current instruction. The pre-decode bits should be set at this time. This signal should also be sent along with ENDLINE for partially decode instruction. The byte position of the branch instruction is from STARTPTR.</p><p>PDJMP\u2014Input from ICPRED indicates the current instruction is a branch instruction. The branch holding register should be setup until pre-decoding of the whole line is completed. If there is a taken branch instruction, the new branch holding register must wait for BWAY and not update the ICNXTBLK until the next opportunity. The ICNXTBLK should send BTAG<b>1</b> to the decode unit.</p><p>PDTAKEN\u2014Input from ICPRED indicates the current instruction is taken branch (the taken branch target can be calculated). The predictor counter in the branch holding register should be setup until pre-decoding of the whole line is completed. The successor index and way associative will be sent to the ICPRED by ICFPC. The ICNXTBLK should send BTAKEN<b>1</b>(<b>0</b>) to decode unit.</p><p>GSRSHIFT(<b>3</b>:<b>0</b>)\u2014Input from ICFPC indicates restoring the global shift register from mis-prediction of the RETURN instruction in decode.</p><p>MINDEX(<b>14</b>:<b>0</b>)\u2014Input from ICFPC indicates new successor index from branch mis-prediction or new pre-decode taken branch instruction to latch into branch holding register.</p><p>MBTAG(<b>3</b>:<b>0</b>)\u2014Input from ICFPC indicates the branch tag from branch mis-prediction to restore the global shift register, counters, byte position, and target number for updating the ICNXTBLK. The target number indicates which branch target to update. The byte position should not change for branch mis-prediction.</p><p>BWAY(<b>2</b>:<b>0</b>)\u2014Input from ICFPC indicates new way associative from taken branch mis-prediction or new pre-decode taken branch instruction to latch into branch holding register and for way prediction. This signal is one cycle later than PDINDEX, MINDEX, or MBTAG. BWAY is accessing the next line.</p><p>BTAR(<b>1</b>:<b>0</b>)\u2014Output to ICNXTBLK indicates the target of the current line for way prediction. This signal is three cycle after the current line access.</p><p>WAYBPTR(<b>3</b>:<b>0</b>)\u2014Output to ICPDAT indicates the byte position of the branch taken pointer of way prediction. For reading, this pointer is decoded into 16 bits to zero-out all bytes after the pointer for scanning logic.</p><p>All the branch prediction signals to the decode units need to mux in the pre-decode branch information and STARTPTR as the first branch target. The branch target address is from the ICFPC as ICPC<b>1</b> or ICPC<b>2</b>.</p><p>BPMSB(<b>1</b>:<b>0</b>)\u2014Internal, indicates taken branch from the msb of the bimodal count of the two targets.</p><p>GPMSB(<b>1</b>:<b>0</b>)\u2014Internal, indicates branch taken from the msb of the global count of the two targets.</p><p>PSMSB(<b>1</b>:<b>0</b>)\u2014Internal, from the msb of the predictor count of the two targets, <b>1</b> indicates using the bimodal predictor, 0 indicates using the global predictor.</p><p>PTAKEN(<b>1</b>:<b>0</b>)\u2014Internal, indicates if the branch targets are predicted taken. This signal is the multiplex of the above three signals.</p><p>STARTPTR(<b>3</b>:<b>0</b>)\u2014Input from ICFPC indicates the start byte position of the instruction, the position of the branch target must be greater than the start byte. This byte pointer is latched into the branch holding register for pre-decode taken branch instruction and written into the array for pre-decode non-taken branch instruction.</p><p>ICBCOL<b>1</b>(<b>3</b>:<b>0</b>)\u2014Internal and output to decode units, indicates the column of the first branch target in the ICNXTBLK for the lines of instructions being fetched. This signal must be greater or equal to STARTPTR. This signal qualifies the BTAG<b>1</b> in the decode units.</p><p>ICBCOL<b>2</b>(<b>3</b>:<b>0</b>)\u2014Internal and output to decode units, indicates the column of the second branch target in the ICNXTBLK for the lines of instructions being fetched. This signal must be greater or equal to STARTPTR. This signal qualifies the BTAG<b>2</b> in the decode units.</p><p>BVAL<b>1</b>\u2014Internal and output to decode units to qualify BTAG<b>1</b>, indicates the first branch target is greater or equal to STARTPTR.</p><p>BVAL<b>2</b>\u2014Internal and output to decode units to qualify BTAG<b>2</b>, indicates the second branch target is greater or equal to STARTPTR.</p><p>BTAKEN<b>1</b>(<b>1</b>:<b>0</b>)\u2014Output to decode units and ICFPC indicates a predicted taken branch instruction from PTAKEN, BVAL<b>1</b>. Bit <b>0</b> is the last line and bit <b>1</b> is new line.</p><p>BTAKEN<b>2</b>(<b>1</b>:<b>0</b>)\u2014Output to decode units and ICFPC indicates a predicted taken branch instruction from PTAKEN, BVAL<b>2</b>. Bit <b>0</b> is the last line and bit <b>1</b> is new line.</p><p>SINDEX(<b>14</b>:<b>0</b>)\u2014Output indicates the successor index from branch prediction, selected by PTAKEN, BVAL<b>1</b>, and BVAL<b>2</b>.</p><p>BTAG<b>1</b>(<b>3</b>:<b>0</b>)\u2014Output indicates the position of the first target branch instruction with respect to the global shift register in case of branch mis-prediction.</p><p>BTAG<b>2</b>(<b>3</b>:<b>0</b>)\u2014Output indicates the position of the second target branch instruction with respect to the global shift register in case of branch mis-prediction.</p><p>BTAG<b>1</b>N(<b>3</b>:<b>0</b>)\u2014Output indicates the position of the first target branch instruction for a new line with respect to the global shift register in case of branch mis-prediction.</p><p>BTAG<b>2</b>N(<b>3</b>:<b>0</b>)\u2014Output indicates the position of the second target branch instruction for a new line with respect to the global shift register in case of branch mis-prediction.</p><p>ICPWAY(<b>2</b>:<b>0</b>)\u2014Internal to select the index from way prediction. The branch prediction and targets are used in the ICNXTBLK to access the next line. This signal selects one of the eight way of successor indexes to ICFPC. The ICFPC needs to compare this signal against TAGHIT to validate the way prediction.</p><p>ICPTAR(<b>1</b>:<b>0</b>)\u2014Output to ICFPC indicates which branch target to use to access the cache in the next cycle. 00\u2014sequential, 01\u2014return stack, 10\u2014first branch target, and 11\u2014second branch target. Bit <b>0</b> selects one of the two successor indexes before the way prediction. The ICFPC needs to compare this signal against the actual taken/non-taken branch prediction. For return stack, the decode unit should detect the return instruction.</p><p>WINDEX(<b>14</b>:<b>0</b>)\u2014Output to ICFPC indicates the successor index from way prediction.</p><p>DISPBRN<b>1</b>(<b>1</b>:<b>0</b>)\u2014Input from ICALIGN indicates the first predicted branch instruction dispatched to a decode unit. This signal is the OR of ICxBRNB<b>1</b>. Bit <b>0</b> is for the first 8-byte and bit <b>1</b> is for the second 8-byte of the line if NEWLINE(<b>1</b>) is set for the second 8-byte.</p><p>DISPBRN<b>2</b>(<b>1</b>:<b>0</b>)\u2014Input from ICALIGN indicates the second predicted branch instruction dispatched to decode unit. This signal is the OR of ICxBRNB<b>2</b>. Bit <b>0</b> is for the first 8-byte and bit <b>1</b> is for the second 8-byte of the line if NEWLINE(<b>1</b>) is set for the second 8-byte.</p><p>BSTRD\u2014Input from TAP indicates to read the array and compare to set the result.</p><p>BSTWR\u2014Input from TAP indicates to write the array from input registers.</p><p>BSTDIN\u2014Input from TAP indicates the test pattern to the input registers. The input can be from the TDI pin or normal burn-in patterns.</p><p>FLUSHON\u2014Input from TAP indicates flushing register mode, the result latch should use BSTDIN instead of the compare input for flushing the result registers.</p><p>BSTSHF<b>1</b>\u2014Input from TAP indicates shifting of the master latch of registers.</p><p>BSTSHF<b>2</b>\u2014Input from TAP indicates shifting of the slave latch of registers.</p><p>BSTFALSE\u2014Input from TAP indicates to invert the test pattern.</p><p>PORTSEL\u2014Input from TAP indicates to select the second dual port.</p><p>BSTNBOUT\u2014Output to ICTAGV indicates the result of the data chain.</p><p>ICFPC</p><p>For continuous instruction addresses, the Icache would be required to request for that IAD bus send the address to the MMU for re-translation before going external. Moving the instruction address latch and incrementor to the ABI block, the instruction address by default can be on the external address bus which can increase the performance of the DRAM access in burst mode. With this change, continuous instruction address request would be relatively simple since the Icache can make a request directly to the BIU without any handshaking for address. With a taken branch, the instruction address latch in ABI will be invalidated, and a new address must be sent to the MMU. The instruction address latch must have a detection for the page-boundary overflow (NAND gates for the lower bits of the address).</p><p>This block contains the current fetch PCs to each array, the PC incrementor for sequential access, and the branch holding address register of mis-predicted block for updating of the ICNXTBLK. The branch holding address register is always be compared to the PC to forward the branch data instead of reading from the ICNXTBLK. The ICFPC should keep track of the PCs for all instructions from fetching until all the instructions are valid and all the possible branch instructions are resolved and issued to the decode units. Status bits are needed to indicate the branch targets and return instruction prediction. The ICPDAT provides the information of each valid 8-byte sending to ICALIGN and the ICALIGN provides the information as an instruction starting on a new 8-byte block is dispatched to the decode unit. The instruction must be validated by proper start and end bits, and the RETURN and unconditional jump instructions are detected. These are the possible cases:</p><p>1. Invalid instruction must be pre-decoded again:</p><p><tables id=\"TABLE-US-00004\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"77PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Clock</entry><entry morerows=\"0\" valign=\"top\">Latch 1</entry><entry morerows=\"0\" valign=\"top\">Latch 2</entry><entry morerows=\"0\" valign=\"top\">Operation of PC0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">read</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">PC1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">invalid instruction</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">PC2</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">restart</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>2. Branch prediction is not the same as way prediction:</p><p><tables id=\"TABLE-US-00005\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"77PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Clock</entry><entry morerows=\"0\" valign=\"top\">Latch 1</entry><entry morerows=\"0\" valign=\"top\">Latch 2</entry><entry morerows=\"0\" valign=\"top\">Operation of PC0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">read</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">PC1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">mis-predict</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">PC2</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">restart</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>3. Invalid long instruction (more than two 8-byte blocks) must be pre-decoded again:</p><p><tables id=\"TABLE-US-00006\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"6\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"70PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"5\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Clock</entry><entry morerows=\"0\" valign=\"top\">Latch 1</entry><entry morerows=\"0\" valign=\"top\">Latch 2</entry><entry morerows=\"0\" valign=\"top\">Latch 3</entry><entry morerows=\"0\" valign=\"top\">Operation of PC0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"5\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">read</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">PC1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">long instruction</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">PC2</entry><entry morerows=\"0\" valign=\"top\">PC1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">invalid instruction</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">4</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">restart</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"5\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>4. RETURN branch is mis-predicted in early decoding (compare to way prediction):</p><p><tables id=\"TABLE-US-00007\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"6\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"6\" colwidth=\"63PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"6\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Clock</entry><entry morerows=\"0\" valign=\"top\">Latch 1</entry><entry morerows=\"0\" valign=\"top\">Latch 2</entry><entry morerows=\"0\" valign=\"top\">Latch 3</entry><entry morerows=\"0\" valign=\"top\">Latch 4</entry><entry morerows=\"0\" valign=\"top\">Operation of PC0</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"6\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">read</entry></row><row><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">PC1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">scan &amp; mux</entry></row><row><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">PC2</entry><entry morerows=\"0\" valign=\"top\">FC1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">early decode</entry></row><row><entry morerows=\"0\" valign=\"top\">4</entry><entry morerows=\"0\" valign=\"top\">PC3</entry><entry morerows=\"0\" valign=\"top\">PC2</entry><entry morerows=\"0\" valign=\"top\">PC1</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">RET mis</entry></row><row><entry morerows=\"0\" valign=\"top\">5</entry><entry morerows=\"0\" valign=\"top\">PC0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">restart</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"6\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>A timing diagram for updating of ICNXTBLK from way mis-prediction is shown as FIG. <b>17</b>.</p><p>Linear/Logic Address Calculation</p><p>The ICACHE uses linear address while the decode units use logical addresses. The code segment register is included in the ICFPC. The translation is either for 16-bit addressing or 32-bit addressing, and either real or protected mode. The code segment register includes:</p><p>Segment selector (<b>15</b>:<b>00</b>)</p><p>Base Address <b>15</b>:<b>00</b>, Segment Limit <b>15</b>:<b>00</b></p><p>Base Address <b>31</b>:<b>24</b>, Control, Limit <b>19</b>:<b>16</b>, Control, Type, Base Address <b>23</b>:<b>16</b></p><p>The Icache is accessed by using linear address while execution of branch instruction uses logical address. On Processor <b>500</b>, these functions should be done in the ICFPC: calculating the linear address for a new fetch PC, checking for code segment limits, and calculating the logical PC address for dispatching new instructions to IDECODE.</p><p>For a mis-predicted branch, the Icache needs to write the branch holding register into the ICNXTBLK before accessing the cache with a new fetch PC. The linear address can be calculated in the Icache without any penalty in performance. The functional unit should send new logical address PC to the Icache directly.</p><p>Since Processor <b>500</b> does not have a BYTEQ, 4 X86 instructions are scanned and dispatched directly to decode units; the PC of dispatched instructions is known for each clock cycle. The code segment limits checking should be done in the ICFPC and a violation status can be sent with the instruction to the decode unit. The ICFPC should keep both the logical and linear PC addresses for the 4 pipeline stages from fetching to muxing of instructions to decode units, the logical address is sent to the decode unit without any calculation.</p><p>Return Stack</p><p>The RETURN instruction should be detected in early decoding and fetch the next PC from return stack (the RETURN instruction will not be in the ICNXTBLK). It should be individually decoded in the early decode units. Similarly, the CALL instruction should also be detected in the early decode units to update the return stack. The CALL instruction pushes PC of the next instruction onto the stack which is the concatenation of the line PC and the ICPOSx(<b>3</b>:<b>0</b>). The return stack is a last-in-first-out (LIFO) stack. The return stack is implemented with a pointer to the top of the stack, and the pointer increases as a new entry is allocated-for the CALL instruction. When the return stack is full, the stack is shifted down by one for the new CALL instruction, and the pointer should be at top of the stack. In another case, when both the call and return instructions of the same entry in the return stack are retired, the entry can be removed by shifting all entries down by one and the pointer decreases by one. The return stack must be recovered from branch mis-prediction. The mis-predicted RETURN instruction is difficult to handle, there are three possible cases. In the application program, the RETURN instruction can be fake which causes the return stack to be forever mis-predicted, the subroutine changes the return target in the stack pointer before executing the RETURN instruction, and the subroutine uses JMP instruction instead of RETURN instruction. For simplicity, the mis-predicted RETURN instruction will cause the return stack to be invalidated. Another condition for invalidating the return stack is from the CMASTER invalidating the Icache. For RETURN instruction after the mis-predicted branch instruction, the return stack should be able to recover. The current return stack is eight buffers, each buffer contains the call branch tag from the global shift register when the CALL instruction is dispatched, the return PC, the return branch tag, the call valid bit, the return valid bit, and the retired call valid bit. The best way to understand the recovery procedure is by the example of this sequence of instructions:</p><p>Jump<b>1</b>, Ret<b>2</b> C, Call<b>3</b> D, Jump<b>4</b>,</p><p>Ret<b>5</b> D, Call<b>6</b> E, Call<b>7</b> F, Ret<b>8</b> F,</p><p>Ret<b>9</b> E, Ret<b>10</b> B, Call<b>11</b> G.</p><p>Beginning return PCs in the return stack: C, B, A.</p><p><tables id=\"TABLE-US-00008\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"8\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"right\" colname=\"5\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"6\" colwidth=\"7PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Return PC</entry><entry morerows=\"0\" valign=\"top\">Call Tag</entry><entry morerows=\"0\" valign=\"top\">Return Tag</entry><entry morerows=\"0\" valign=\"top\">CV</entry><entry morerows=\"0\" valign=\"top\">RV</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCV</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">C</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The return stack at Jump<b>4</b> instruction:</p><p><tables id=\"TABLE-US-00009\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"8\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"right\" colname=\"5\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"6\" colwidth=\"7PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Return PC</entry><entry morerows=\"0\" valign=\"top\">Call Tag</entry><entry morerows=\"0\" valign=\"top\">Return Tag</entry><entry morerows=\"0\" valign=\"top\">CV</entry><entry morerows=\"0\" valign=\"top\">RV</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCV</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">D</entry><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">C</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The return stack at Call<b>7</b> F instruction:</p><p><tables id=\"TABLE-US-00010\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"8\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"right\" colname=\"5\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"6\" colwidth=\"7PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Return PC</entry><entry morerows=\"0\" valign=\"top\">Call Tag</entry><entry morerows=\"0\" valign=\"top\">Return Tag</entry><entry morerows=\"0\" valign=\"top\">CV</entry><entry morerows=\"0\" valign=\"top\">RV</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCV</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">F</entry><entry morerows=\"0\" valign=\"top\">7</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">E</entry><entry morerows=\"0\" valign=\"top\">6</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">D</entry><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">5</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">C</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The return stack at the end of the sequence:</p><p><tables id=\"TABLE-US-00011\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"8\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"right\" colname=\"5\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"6\" colwidth=\"7PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Return PC</entry><entry morerows=\"0\" valign=\"top\">Call Tag</entry><entry morerows=\"0\" valign=\"top\">Return Tag</entry><entry morerows=\"0\" valign=\"top\">CV</entry><entry morerows=\"0\" valign=\"top\">RV</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCV</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">G</entry><entry morerows=\"0\" valign=\"top\">11</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">F</entry><entry morerows=\"0\" valign=\"top\">7</entry><entry morerows=\"0\" valign=\"top\">8</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">E</entry><entry morerows=\"0\" valign=\"top\">6</entry><entry morerows=\"0\" valign=\"top\">9</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">D</entry><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">5</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">C</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">10</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">\u2014</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>If Jump <b>1</b> is mis-predicted, then Tag <b>1</b> is used for recovery. The Call Tag in the recovery stack should be less than Tag <b>1</b> and Return Tag should be greater than Tag <b>1</b> for valid in the return stack. Entries G, F, E, and D should invalidate all valid bits. Entries C and B should reset the return valid bits.</p><p>If Jump <b>4</b> is mis-predicted, then Tag <b>4</b> is used for recovery. Entries G, F, and E should invalidate all valid bits. Entries B and D should reset the return valid bits. There is no change for entry C.</p><p>If Call<b>3</b> D is mis-predicted, then Tag <b>3</b> is used for recovery. Entries G, F, and E should invalidate all valid bits. Entries D, C, and B should reset the return valid bits. A new return PC is latched for entry D.</p><p>If Call<b>7</b> F is mis-predicted, then Tag <b>7</b> is used for recovery. Entry G should invalidate all valid bits. Entries E and F should reset the return valid bits. A new return PC is latched for entry F.</p><p>If Call <b>11</b> G is mis-predicted, then Tag <b>11</b> is used for recovery. A new return PC is latched for entry G.</p><p>Any mis-predicted return instruction invalidates all valid bits in the return stack. The call instruction should retire before the return instruction in the same entry. As the return instruction is retired the entry can be eliminated from the return stack and all the entries can be shifted down by one.</p><p>The INT and IRET are similar to the CALL and RETURN instructions. The return stack needs to keep the PC and statuses for the INT and IRET. It is more often that the interrupt routine is from asynchronous interrupt and trap. The IRET executes without the previous INT. To avoid invalidating the entire return stack on mis-predicted IRET, two more status bits are needed. The IXC bit indicates that the entry is from INT or CALL instruction. The IRET pops only the top entry with IXC bit set, and the RETURN pops only the top entry with IXC bit reset. The ISTART bit indicates the starting point for INT routine. In the case of a mis-prediction on the IRET instruction, entries with ISTART bit set will be purged. The entries before the INT should not be affected by the mis-prediction from the interrupt routine. A diagram of the return stack set up is shown as FIG. <b>18</b>.</p><p>ICFPC Organization</p><p>The possible sources for index of ICSTORE are:</p><p>Incrementor of sequential address.</p><p>Refresh of current index.</p><p>Refresh the previous index because of confused instruction in decode.</p><p>Successor index of taken branch from way predictor of ICNXTBLK.</p><p>Return instruction target from way predictor of ICNXTBLK.</p><p>Corrected index of taken branch from branch prediction of ICNXTBLK.</p><p>Predicted taken branch from ICPRED.</p><p>Branch mis-prediction or Read-after-Write dependency flush from FIROB.</p><p>Special register reading/writing.</p><p>Build-In Self-Test counter.</p><p>The possible sources for index of ICTAGV are:</p><p>Incrementor of sequential address.</p><p>Refresh of current index.</p><p>Refresh the previous index because of confused instruction in decode.</p><p>Next block address to check the cache during pre-fetching.</p><p>Successor index of taken branch from way predictor of ICNXTBLK.</p><p>Return instruction target from way predictor of ICNXTBLK.</p><p>Corrected index of taken branch from branch prediction of ICNXTBLK.</p><p>Branch mis-prediction or Read-after-Write dependency flush from FIROB.</p><p>Predicted taken branch from ICPRED.</p><p>CMASTER new mapping for current tag miss.</p><p>Special register reading/writing.</p><p>Build-In Self-Test counter.</p><p>The possible sources for index of ICPDAT are:</p><p>Incrementor of sequential address for reading (same as ICSTORE).</p><p>Refresh of current index.</p><p>Refresh the previous index because of confused instruction in decode.</p><p>Delay of sequential address for writing of pre-decode data.</p><p>Successor index of taken branch from way predictor of ICNXTBLK.</p><p>Return instruction target from way predictor of ICNXTBLK.</p><p>Corrected index of taken branch from branch prediction of ICNXTBLK.</p><p>Branch mis-prediction or Read-after-Write dependency flush from FIROB.</p><p>Predicted taken branch from ICPRED.</p><p>Special register reading/writing.</p><p>Build-In Self-Test counter.</p><p>The possible sources for index of ICNXTBLK are:</p><p>Incrementor of sequential address.</p><p>Refresh of current index.</p><p>Refresh the previous index because of confused instruction in decode.</p><p>Delay of sequential address for writing of pre-decode data.</p><p>Successor index of taken branch from way predictor of ICNXTBLK.</p><p>Return instruction target from way predictor of ICNXTBLK.</p><p>Corrected index of taken branch from branch prediction of ICNXTBLK.</p><p>Branch mis-prediction or Read-after-Write dependency flush from FIROB.</p><p>Predicted taken branch from ICPRED.</p><p>Branch holding address register.</p><p>Special register reading/writing.</p><p>Build-In Self-Test counter.</p><p>The ICFPC block also includes the code segment register, the PC incrementor address, the branch holding address register and comparator, and the subtractor for calculation of logical address. The code segment register includes the base for logical address calculation and the limit for segment violation. The PC incrementor has two parts: the index incrementor and the tag-address incrementor; the tag-address incrementor is used only when the index incrementor is overflowed. It is much faster to break up the PC incrementor into two parts.</p><p>ICFPC should keep track of all the way selection in all the arrays. From reading the array, the predicted way and the TAGHITs should match, and the HIT way should be kept with the PC and branch tags. For writing the array, the selected way is from the CMASTER's pseudo random way replacement algorithm or from the branch mis-prediction. For the special register read/write, the selected way is from the SRB.</p><p>An 11-bit counter is implemented in this block for BIST, the counter fakes counting down by exclusive-or the output. See the section on BIST and ATPG.</p><p>Signal List</p><p>REFRESH<b>2</b>\u2014Input from Idecode indicates current line of instructions will be refreshed and not accept new instructions from Icache.</p><p>NEWLINE(<b>1</b>:<b>0</b>)\u2014Input from ICPDAT indicates the first (bit <b>0</b>) or the second (bit <b>1</b>) 8-byte is the starting of a new line. The byte positions of instructions sending to the decode units should be adjusted accordingly.</p><p>HLDISP(<b>1</b>:<b>0</b>)\u2014Input from ICALIGN indicates the first (bit <b>0</b>) and/or the second (bit <b>1</b>) 8-byte of the current line has been dispatched to decode units.</p><p>NEWBLK\u2014Input from ICCNTL to read new sequential block.</p><p>NXTBLK\u2014Input from ICCNTL to check next sequential block during pre-fetching.</p><p>INVPTR(<b>3</b>:<b>0</b>)\u2014Input from ICPDAT indicates the start pointer of the invalid instruction which needs to be pre-decoded.</p><p>INVINST\u2014Input from ICPDAT indicates the invalid instruction which needs to be pre-decoded.</p><p>ICPTAR(<b>1</b>:<b>0</b>)\u2014Input from ICNXTBLK indicates which branch target to use to access the cache in the next cycle. 00\u2014sequential, 01\u2014return stack, 10\u2014first branch target, and 11\u2014second branch target. Bit <b>0</b> selects one of the two successor indexes before the way prediction. The ICFPC needs to compare this signal against the actual taken/non-taken branch prediction.</p><p>WINDEX(<b>14</b>:<b>0</b>)\u2014Input from ICNXTBLK indicates the successor index from way prediction.</p><p>RETPC(<b>31</b>:<b>0</b>)\u2014Internal indicates the PC address from the top of the return stack for fast way prediction.</p><p>CALLDEC(<b>3</b>:<b>0</b>)\u2014Input from ICALIGN indicates the CALL instruction is detected, the return stack should be updated with the PC address of instruction after CALL. The line must be taken.</p><p>NORETB\u2014Input from ICALIGN indicates no RETURN instruction is detected for the current line. This signal responds to RETPRED. The ICFPC should use the branch prediction of BTAKEN to fetch the next line.</p><p>RETDEC(<b>3</b>:<b>0</b>)\u2014Input from ICALIGN indicates a RETURN instruction is detected for the way prediction to update if no RETURN was predicted. The ICFPC needs to keep track of the branch instructions for 4 lines and restores the global shift register in case of mis-predicting the RETURN instruction in Idecode.</p><p>BTAKEN<b>1</b>(<b>1</b>:<b>0</b>)\u2014Input from ICNXTBLK indicates a predicted taken branch instruction from PTAKEN, BVAL<b>1</b>. Bit <b>0</b> is the last line and bit <b>1</b> is new line. SINDEX should be used for accessing the arrays.</p><p>BTAKEN<b>2</b>(<b>1</b>:<b>0</b>)\u2014Input from ICNXTBLK indicates a predicted taken branch instruction from PTAKEN, BVAL<b>2</b>. Bit <b>0</b> is the last line and bit <b>1</b> is new line. SINDEX should be used for accessing the arrays.</p><p>SINDEX(<b>11</b>:<b>0</b>)\u2014Input from ICNXTBLK indicates the correct successor index from branch prediction, selected by PTAKEN, BVAL<b>1</b>, and BVAL<b>2</b>.</p><p>PDJMP\u2014Input from ICPRED indicates the current instruction is a branch instruction. The branch holding register should be setup until pre-decoding of the whole line is completed. If there is a taken branch instruction, the new branch holding register must wait for MWAY and not update the ICNXTBLK until the next opportunity.</p><p>PDTAKEN\u2014Input from ICPRED indicates the current instruction is taken branch (the taken branch target can be calculated). The predictor counter in the branch holding register should be setup until pre-decoding of the whole line is completed. The successor index and way associative will be sent to the ICNXTBLK by ICFPC. The next index for the array is from PTARGET.</p><p>PDRETB\u2014Input from ICPRED indicates the current instruction is RETURN instruction. The ICFPC should use the return branch address for fetching the next line.</p><p>PTARGET(<b>31</b>:<b>0</b>)\u2014Input from ICPRED indicates the branch target for current branch instruction. The successor index is latched until pre-decoding of the whole line is completed. If the branch is taken, the way calculation is done in ICFPC and latched until branch mis-predictions or external fetch is started.</p><p>ICMBWR\u2014Input from ICCNTL indicates starting of external fetch, the branch holding register should be written into the ICNXTBLK in the next cycle. The array index is from BINDEX.</p><p>BRNMISP\u2014Input from FIROB indicates a branch mis-prediction. The Icache changes its state machine to access a new PC and clears all pending instructions. This signal is one cycle ahead of the transferring of the new target. The branch holding register should be written into the ICNXTBLK array in next cycle. The array index is from BINDEX.</p><p>LINDEX(<b>11</b>:<b>0</b>)\u2014Internal from branch holding register indicates the previous branch to be written into ICNXTBLK.</p><p>UPDFPC\u2014Input from FIROB indicate that a new Fetch PC has been detected. This signal accompanies the FPC for the Icache to begin access the cache arrays.</p><p>FPC(<b>31</b>:<b>0</b>)\u2014Input from FIROB as the new PC for branch correction path.</p><p>BPC(<b>11</b>:<b>0</b>)\u2014Input from FIROB indicates the PC index and byte-pointer of the branch instruction which has been mis-predicted for updating the ICNXTBLK. This index must be compared to the array index for exact recovery of the global shift register.</p><p>BRNTAKEN\u2014Input from FIROB indicate the mis-predicted branch status. This signal must be gated with UPDFPC.</p><p>BRNTAG(<b>3</b>:<b>0</b>)\u2014Input from FIROB indicates the branch tag in the global shift register to restore the previous branch prediction information and the branch index address. The mis-predicted will be latched into the branch holding register. The branch index of the branch holding register is implemented in the ICFPC.</p><p>BINDEX(<b>11</b>:<b>0</b>)\u2014Internal, indicates the previous branch index, the branch indexes are address by the branch tag with similar implementation as the global shift register in the ICNXTBLK.</p><p>FPCTYP\u2014Input for FIROB indicates the type of address that is being passed to the Icache.</p><p>L<b>2</b>_IC_INV(<b>1</b>:<b>0</b>)\u2014Input from CMASTER to clear the LV bits.</p><p>LS_CS_WR\u2014Input from LSSEC to write the new code segment from SRBB. Two cycles are needed.</p><p>MVICAR\u2014Output to ICCNTL indicates move to/from special register instruction is for Icache array. The ICCNTL steals one cycle from normal operation.</p><p>SRRDXWR\u2014Output to ICCNTL indicates move to/from special register instruction is read or write.</p><p>SRB_VAL\u2014Input from SRB indicates a special register instruction is on the SRBB.</p><p>ICTAR_VAL\u2014Output to SRB indicates completion of the special register instruction, for read the data is on the SRBB.</p><p>SRBB(<b>31</b>:<b>0</b>)\u2014I/O from SRB indicates the special register address for the indexing the arrays, passing to ICSRBB, and to access the code segment register.</p><p>ICSRBB(<b>31</b>:<b>0</b>)\u2014I/O passing from SRBB for internal access to the arrays. A number of bits will pass to the ICCNTL for decoding which array.</p><p>L<b>2</b>_IC_ALIAS\u2014Input from CMASTER indicates the instruction is in the Icache with different mapping. The CMASTER provides the way associative, new supervisor bit, and new tag address. The LV will be set in this case. All arrays will be read from MCOL except for ICTAGV which will write in the new tag.</p><p>PFREPLCOL(<b>2</b>:<b>0</b>)\u2014Input from CMASTER indicates the way associative for writing of the ICTAGV.</p><p>PREDEN\u2014Input from ICCNTL to enable the pre-decoding of instruction.</p><p>GETNEWL\u2014Input from ICPRED indicates that pre-decoding has reached the end of the line or encountered a taken branch instruction, a new line of instructions is needed in the next cycle. This signal controls the index for ICSTORE and ICTAGV.</p><p>ENDLINE\u2014Input from ICPRED indicates that pre-decoding has completed for the last instruction of the line (if the instruction crosses over to the next line, this instruction should complete in pre-decoding) or encountered a taken branch instruction, the pre-decode data should be written into the array. This signal controls the index for ICPDAT and ICNXTBLK.</p><p>ENDINST\u2014Input from ICPRED indicates that pre-decoding is completed for the current instruction. The pre-decode bits should be set at this time. The ICFPC uses this signal and PENDB to generate a new STARTPTR.</p><p>PDJMP\u2014Input from ICPRED indicates the current instruction is a branch instruction. The branch holding register should be setup until pre-decoding of the whole line is completed. If there is a taken branch instruction, the new branch holding register must wait for BWAY and not update the ICNXTBLK until the next opportunity.</p><p>PDTAKEN\u2014Input from ICPRED indicates the current instruction is taken branch (the taken branch target can be calculated). The predictor counter in the branch holding register should be setup until pre-decoding of the whole line is completed. The successor index and way associative will be sent to the ICPRED by ICFPC.</p><p>DISPBRN<b>1</b>(<b>1</b>:<b>0</b>)\u2014Input from ICFPC indicates the first predicted branch instruction dispatched to decode unit. This signal is the OR of ICxBRNBl. Bit <b>0</b> is for the first 8-byte and bit <b>1</b> is for the second 8-byte of the line if NEWLINE(<b>1</b>) is set for the second 8-byte.</p><p>DISPBRN<b>2</b>(<b>1</b>:<b>0</b>)\u2014Input from ICFPC indicates the second predicted branch instruction dispatched to decode unit. This signal is the OR of ICxBRNB<b>2</b>. Bit <b>0</b> is for the first 8-byte and bit <b>1</b> is for the second 8-byte of the line if NEWLINE(<b>1</b>) is set for the second 8-byte.</p><p>STARTPTR(<b>3</b>:<b>0</b>)\u2014Output indicates the starting byte position for pre-decoding of the instruction in the IB(<b>127</b>:<b>0</b>).</p><p>ISADD(<b>11</b>:<b>2</b>)\u2014Output to ICSTORE indicates the address of instruction to access the array. Bits <b>11</b>:<b>5</b> are for the row decoder, bits <b>4</b>:<b>2</b> are for column select. For normal operation, bits <b>11</b>:<b>4</b> is used to read/write 16-byte only. For special register operation, bits <b>11</b>:<b>2</b> is used to read/write 4-byte.</p><p>IPADD(<b>11</b>:<b>2</b>)\u2014Input from ICFPC indicates the address of instruction to access the array. Bits <b>11</b>:<b>6</b> are for the row decoder, bits <b>5</b>:<b>2</b> are for column select. For normal operation, bits <b>11</b>:<b>4</b> is used to read/write 16-byte only. For special register operation, bits <b>11</b>:<b>2</b> is used to read/write 4-byte.</p><p>ITADD(<b>11</b>:<b>4</b>)\u2014Output to ICTAGV indicates the address of instruction to access the array. Bits <b>11</b>:<b>5</b> are for the row decoder, bit <b>4</b> is for column select.</p><p>IVADD(<b>11</b>:<b>4</b>)\u2014Output to ICTAGV indicates the address of instruction to access the LV array. Bits <b>11</b>:<b>5</b> are for the row decoder, bit <b>4</b> is for column select.</p><p>INADD(<b>11</b>:<b>3</b>)\u2014Input from ICFPC indicates the address of instruction to access the array. Bits <b>11</b>:<b>5</b> are for the row decoder, bit <b>4</b> is for column select. This index should be delayed by 3 cycles to write data for the way prediction bits.</p><p>SETSEL(<b>7</b>:<b>0</b>)\u2014Output to arrays indicates which set to read, no tag compare is needed.</p><p>BWAY(<b>2</b>:<b>0</b>)\u2014Output to ICNXTBLK indicates the way associative for the current taken branch instruction for the branch holding register and way prediction.</p><p>BTAR(<b>1</b>:<b>0</b>)\u2014Output to ICNXTBLK indicates the target of the current line for way prediction. This signal is three cycles after the current line access.</p><p>ICLIMIT(<b>19</b>:<b>0</b>)\u2014Output to decode units indicates the limit of the code segment register for segment violation.</p><p>ICPC<b>1</b>TAR\u2014Output to Idecode indicates is ICPC<b>1</b> a branch target of a previous instruction which is a predicted taken branch instruction.</p><p>ICPC<b>2</b>TAR\u2014Output to Idecode indicates is ICPC<b>2</b> a branch target of a previous instruction which is a predicted taken branch instruction.</p><p>ICPC<b>1</b>(<b>31</b>:<b>0</b>)\u2014Output to Idecode Output to Idecode indicates the current line PC of the first instruction in the 4 issued instructions to pass along with the instruction to FIROB.</p><p>ICPC<b>2</b>(<b>31</b>:<b>0</b>)\u2014Output to Idecode indicates the current line PC of a second instruction which cross the 16-byte boundary or branch target in the 4 issued instructions to pass along with the instruction to FIROB.</p><p>RETPRED\u2014Output to Idecode indicates the current prediction of the return instruction of the fetched line. The return instruction must be detected in the current line of instruction or the Icache must be re-fetched from a new line.</p><p>BSTRUN\u2014Input from TAP indicates to start the BIST.</p><p>BSTRD\u2014Input from TAP indicates to read the array and compare to set the result.</p><p>BSTWR\u2014Input from TAP indicates to write the array from input registers.</p><p>BSTRST\u2014Input from TAP indicates to reset the counter.</p><p>BSTINCR\u2014Input from TAP indicates to increment the counter.</p><p>UPDOWN\u2014Input from TAP indicates counting up or down.</p><p>BSTAMSB\u2014Output to TAP indicates maximum count for dual port arrays.</p><p>MAXADDR\u2014Output to TAP indicates maximum index counter.</p><p>ICPRED</p><p>This block pre-decodes the instructions as they come in from the external memory or from the Icache if the start/end bits are confused. On Processor <b>500</b>, the ICPRED is connected to the IB(<b>127</b>:<b>0</b>) to read the instructions from either pre-fetch buffer or Icache. For externally fetched instruction, the ICPRED starts from the fetched byte position. The ICPRED latches the instructions in the second ICLK as they are sent to the decode units. If the start/end bits are confused, then the ICPDAT sends the byte position of the invalid instruction to the ICPRED for pre-decoding. All pre-decode data before the confused instruction should remain in the ICPDAT array. The pre-decoding stops on two conditions: a taken branch is detected or valid start byte is detected after the end byte from pre-decoding; this condition should be detected in the ICPDAT. The ICPRED pre-decodes one instruction per two clock cycles plus an extra clock cycle for prefix. The pre-decode information includes the start-byte, end-byte, function-byte, and the branch prediction information. The difference in pre-decode of instructions are:</p><p>Fast-path instructions should have any number of prefix except for string prefixes which is an MROM instruction. One extra clock cycle in the pipeline is needed for instructions with more than four prefixes.</p><p>A few instructions use two dispatched positions. The SIB instruction also needs two dispatched positions. Any double-dispatched instructions with SIB will go to MROM.</p><p>The first functional bit, if set, indicates fast-path instruction, else it is MROM instruction. The Processor <b>500</b> instruction set includes:</p><p>PUSH</p><p>POP</p><p>CALL/RETURN near</p><p>LEA</p><p>JUMP cc/unconditional</p><p>8/32-bit operations</p><p>MOVE reg/reg reg/mem</p><p>ALU operations reg/mem reg/reg (excluding the RCR and RCL instructions).</p><p>Decode for CALL, INT, and Unconditional JUMP to set the predictor and the bimodal counters to the saturated value in the ICNXTBLK. The branch target information is kept in the branch holding register for future updating. The ICPRED calculates the target address for the Unconditional Jump if possible. Otherwise, fetching is stalled until the target address is calculated in decoding or executing. ICFPC must have an adder and ICPRED must send the offset to calculate the target address.</p><p>The RETURN and IRET instructions are pre-decoded to access the return stack and set the way prediction array.</p><p>Decode for Conditional JUMP is needed to keep it in the ICNXTBLK and for global branch prediction. If the target address of the conditional JUMP (and LOOP) can be calculated and the branch jumps backward, then it is predicted taken. Since backward branch is mostly taken and the adder is available to calculate the target address, the conditional branch should be predicted taken. The taken branches have the higher priority to occupy the branch targets. Conditional branch has higher priority to occupy two branch targets in the ICNXTBLK than CALL or Unconditional JUMP with 8-bit displacement linear address. The decoding for all branches are needed to set the global shift register. If the target address is a simple calculation, the decode units should calculate the target address and jump to new block.</p><p>The encoding of the functional bits for fast-path instruction are as follows:</p><p><tables id=\"TABLE-US-00012\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"196PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Byte number 01234 Type</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"98PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Start bit</entry><entry morerows=\"0\" valign=\"top\">1000</entry><entry morerows=\"0\" valign=\"top\">MROM, no prefix</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Func bit</entry><entry morerows=\"0\" valign=\"top\">0111</entry><entry morerows=\"0\" valign=\"top\">opcode is at first byte.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Start bit</entry><entry morerows=\"0\" valign=\"top\">1000</entry><entry morerows=\"0\" valign=\"top\">MROM, one prefix</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Func bit</entry><entry morerows=\"0\" valign=\"top\">0011</entry><entry morerows=\"0\" valign=\"top\">opcode is at second byte</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Start bit</entry><entry morerows=\"0\" valign=\"top\">10000</entry><entry morerows=\"0\" valign=\"top\">MROM, three prefixes</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Func bit</entry><entry morerows=\"0\" valign=\"top\">00001</entry><entry morerows=\"0\" valign=\"top\">opcode is at fourth byte</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Start bit</entry><entry morerows=\"0\" valign=\"top\">1000</entry><entry morerows=\"0\" valign=\"top\">Fast path, no prefix</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Func bit</entry><entry morerows=\"0\" valign=\"top\">1000</entry><entry morerows=\"0\" valign=\"top\">opcode is at first byte</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Start bit</entry><entry morerows=\"0\" valign=\"top\">1000</entry><entry morerows=\"0\" valign=\"top\">Fast path, one prefix</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Func bit</entry><entry morerows=\"0\" valign=\"top\">1100</entry><entry morerows=\"0\" valign=\"top\">opcode is at second byte</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Start bit</entry><entry morerows=\"0\" valign=\"top\">10000</entry><entry morerows=\"0\" valign=\"top\">Fast path, three prefix</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Func bit</entry><entry morerows=\"0\" valign=\"top\">11110</entry><entry morerows=\"0\" valign=\"top\">opcode is at fourth byte</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Along with the start bit, if the functional bit is 0, the instruction is MROM, if the functional bit is 1, the instruction is fast path. The encoding for the functional bits of MROM instruction is inverted that of the fast path instruction. If the first functional bit is 0, all functional bits is inverted before qualifying with the valid bits for prefix and opcode decoding. In addition, the functional bits should also be set for SIB-byte and for the immediate field. The detection of the SIB-byte instruction is necessary to generate 2-dispatch positions instruction.</p><p>The ICPRED controls the reading of the next sequential line from ICSTORE to IB(<b>127</b>:<b>0</b>) and writing of the pre-decode data into the ICPDAT and ICNXTBLK. GETNEWL is used to read the next sequential block from ICSTORE, and ENDLINE and ENDINST are used to write pre-decode data into the ICPDAT and ICNXTBLK. If the split-line instruction (instruction started at the end of the first line and end in the next line) is also a predicted taken branch, then ICCNTL and ICPRED should provide control to write predecode data into the ICPDAT array in an extra cycle. ICPRED provides the start and end pointers as completion of pre-decoding of each instruction along with ENDINST. The functional bits are kept in ICPRED until completion of the line. ICPRED must continuously latch the new line from IB(<b>127</b>:<b>0</b>) in case of confused instruction, all functional bits should be cleared before pre-decoding.</p><p>The pre-decode instruction should be sent directly to decode unit <b>0</b>. The instruction has to go through early decoding before dispatching to the decode unit. During pre-decoding all the controls of sending the correct instruction from IB(<b>127</b>:<b>0</b>) to IB<b>1</b>(<b>191</b>:<b>0</b>) should be directly from ICPRED. The ICPRED controls the muxing between the 2 buses and the ICALIGN uses PDSHF(<b>4</b>:<b>0</b>) to read the instruction from the 8-byte of IB<b>1</b> for the valid opcode, MODRM, and SIB bytes.</p><p>Upon detection of MROM instruction, the ICPDAT muxes the STARTPTR(<b>3</b>:<b>0</b>) to the MROM for reading of instruction from IB(<b>127</b>:<b>0</b>). The ICPRED must continue to decode instructions and fill up the bus IB<b>1</b>(<b>191</b>:<b>0</b>) of up to 4 instructions per 8-byte block. The ICALIGN keeps PDSHF(<b>4</b>:<b>0</b>) in ICnVAL(<b>7</b>:<b>0</b>) of each 8-byte block. Similar to ICPDAT, the information from the next stage in ICALIGN and MROM pipeline should be conveyed to this block. The pre-decoding is stalled if ICALIGN or MROM is full.</p><p>ICPRED Organization</p><p>The ICPRED includes three blocks: one block (ICPREFIX) decodes the prefix, one block (ICDECINS) decodes the instruction, and one block (ICPREINS) sets up the pre-decode data. The ICPREFIX decodes up to 4 prefix bytes per clock cycle. The ICPREFIX is similar to the prefix decoding in the ICALIGN, and the same logic should be used. The ICPREFIX should combined the prefixes for dispatching to decode unit; this is to avoid an extra cycle if there are more than 4 prefixes. The ICDECINS accepts prefix status and 3 instruction bytes, the opcode, the MODRM, and the SIB. In the first cycle, no prefix is assumed. If prefix is detected in the ICPREFIX, the ICDECINS will restart the decoding of instruction with new prefix status and 3 new instruction bytes. If more prefixes are detected in subsequent cycle, the ICDECINS will restart with new information. After the decoding, the pre-decode information will be sent to the decode unit <b>0</b> and the latch in the ICPDAT, the ICALIGN will dispatch the instruction and pre-decode data to the first decode unit. The byte pointer moves to the next instruction and the procedure continues until the whole line is completed. The writing of the ICPDAT will be done when the whole line is decoded. The ICDECINS also decodes for branch instructions and sets up the two targets in the ICNXTBLK. The ICDECINS sends control to ICFPC for calculating the simple taken branch addresses: PC+displacement. The ICPRED includes local latches of 8 bytes for instruction which can wrap around to the next line. For instructions which are longer than 15 bytes, an exception is asserted to ICCNTL and decode units. The list of Processor <b>500</b> fast path instructions can be found below. The outputs of the ICPREFIX and ICDECINS are fed to ICPREINS for analyzing and setting up the pre-decode data. A diagram showing the ICPRED set up is shown as FIG. <b>19</b>.</p><p>Signal List</p><p>IB(<b>127</b>:<b>0</b>)\u2014Input from ICSTORE indicates the line of instructions from the array or pre-fetch buffer for pre-decoding. A latch should be implemented for unaligned instructions. Data only changes on valid GETNEWL and PBVAL.</p><p>STARTPTR(<b>3</b>:<b>0</b>)\u2014Input from ICFPC indicates the starting byte position for pre-decoding of the instruction in the IB(<b>127</b>:<b>0</b>).</p><p>CS32\u00d716\u2014Input from LSSEC indicates operand and address size from the D bit of the segment descriptor of the code segment register. If set, 32-bit, if clear, 16-bit.</p><p>PREDEN\u2014Input from ICCNTL to enable the pre-decoding of instruction.</p><p>PBVAL\u2014Input from ICSTORE indicates a valid line of instruction from external fetch. If GETNEWL is high, the pre-fetch buffer will put a valid line of instruction on the IB(<b>127</b>:<b>0</b>) in early next cycle. ICPRED should use both PBVAL and GETNEWL to read valid instruction byte on IB.</p><p>GETNEWL\u2014Output indicates that pre-decoding has reached the end of the line or encountered a taken branch instruction, a new line of instructions is needed in the next cycle. This signal is also asserted at the beginning of PREDEN.</p><p>ENDLINE\u2014Output indicates that pre-decoding has completed for the last instruction of the line (if the instruction crosses over to the next line, this instruction should complete in pre-decoding) or encountered a taken branch instruction, the pre-decode data should be written into the array.</p><p>ENDINST\u2014Output indicates that pre-decoding is completed for the current instruction. The pre-decode bits would be set at this time. This signal should also be sent along with ENDLINE for partially decode instruction.</p><p>PENDIB(<b>4</b>:<b>0</b>)\u2014Output to ICPDAT indicates the end byte position of the current instruction. The end bit is set and latched until pre-decoding of the whole line is completed. Bit <b>4</b> indicates if the end bit is on the next line.</p><p>PLFUNCB(<b>15</b>:<b>0</b>)\u2014Output to ICPDAT indicates the functional bits of current line of instructions. ICPDAT uses ENDLINE to OR these bits previous pre-decode data and write into the array. The ICPRED must keep all the functional bits for all the pre-decoded instruction in the line.</p><p>PDMROM\u2014Output to ICDPAT and ICALIGN indicates the current instruction is MROM. The MROM instruction may take two cycles to read the PENDB and PFUNCB.</p><p>PIFUNCB(<b>2</b>:<b>0</b>)\u2014Output to ICALIGN indicates the functional bits for current instruction. Only three bytes (opcode, MODRM, and SIB) are needed for early decode of the instruction. The prefixes are encoded into one single byte to the decode unit <b>0</b>.</p><p>PDVAL(<b>10</b>:<b>0</b>)\u2014Output to ICALIGN indicates the valid bytes for pre-decode instruction to decode unit <b>0</b>. This signal is to validate the bytes in decode. The maximum length of the instruction is 11 bytes.</p><p>PDSHF(<b>5</b>:<b>0</b>)\u2014Output to ICALIGN indicates which bytes to mux to early decoding. The opcode byte must always be in the first 8-byte of IB<b>1</b>(<b>191</b>:<b>0</b>). The ICPRED must put the current line into the IB<b>1</b>(<b>191</b>:<b>0</b>) for muxing. The upper 2 bits to select which 8-byte block, the ICALIGN can accumulate the pre-decode instructions while waiting for the MROM instructions.</p><p>PD<b>8</b>BSEL(<b>5</b>:<b>0</b>)\u2014Output to ICALIGN controls the muxes from IB(<b>127</b>:<b>0</b>) to IB<b>1</b> (<b>191</b>:<b>0</b>). Bit <b>5</b>:<b>3</b> is for the upper 8-byte IB(<b>127</b>:<b>64</b>) and bit <b>2</b>:<b>0</b> is for the lower 8-byte IB(<b>63</b>:<b>0</b>). 001 is for muxing to the first 8-byte IB<b>1</b>(<b>63</b>:<b>0</b>), 010 is for muxing to the second 8-byte, and 100 is for muxing to the third 8-byte.</p><p>PDPREF(<b>7</b>:<b>0</b>)\u2014Output to ICALIGN and then to decode unit <b>0</b> or MROM indicates the encoded prefix byte.</p><p>PDJMP\u2014Output indicates the current instruction is a branch instruction. The branch holding register should be setup until pre-decoding of the whole line is completed. If there is a taken branch instruction, the new branch holding register must wait for MWAY and not update the ICNXTBLK until the next opportunity.</p><p>PDTAKEN\u2014Output indicates the current instruction is taken branch (the taken branch target can be calculated). The predictor counter in the branch holding register should be setup until pre-decoding of the whole line is completed. The successor index and way associative will be sent to the ICNXTBLK by ICFPC.</p><p>PDRETB\u2014Output to ICFPC indicates the current instruction is RETURN instruction. The ICFPC should use the return branch address for fetching the next line.</p><p>INST_LEGAL\u2014Output to ICCNTL indicates the current instruction is a legal X86 instruction, this signal should be qualified with ENDINST to indicate illegal instruction to the decode unit.</p><p>INST_<b>2</b>_LONG\u2014Output to ICCNTL indicates the current instruction is more than 15 bytes, this signal should be qualified with ENDINST to indicate long instruction to the decode unit.</p><p>PTARGET(<b>31</b>:<b>0</b>)\u2014Output to ICFPC indicates the branch target for current branch instruction. The successor index is latched until pre-decoding of the whole line is completed. If the branch is taken, the way calculation is done in ICFPC and latched until branch mis-predictions or external fetch is started.</p><p>ICALIGN</p><p>An extra pipeline stage is added on Processor <b>500</b> for early decoding of prefixes and generating two dispatched positions for a few instructions. To gain another half clock cycle for early decoding and dispatching of instructions to the decode units, the operand, flag, and un-conditional jump instruction (including CALL and RETURN) decoding can be done in early decoding. The unconditional branch instruction should be the last instruction in the line which should be compared to the branch information in the ICFPC. If the unconditional branch instruction was not recorded in the branch global shift register, then the ICFPC re-fetches from the target of the unconditional branch and corrects the branch tags in the branch global shift register. The CALL and RETURN instructions are necessary for setting the return stack. The operands and flags are sent directly to the register file and FIROB for accessing the data. The operation of this block takes 2.5 clock cycles which includes prioritizing, aligning, decoding, and muxing of instructions to decode units.</p><p>Alignment of Instructions to Dispatched Positions</p><p>Instructions are sent as 8-byte blocks from the ICPDAT to the ICALIGN, and they are prioritized to 4 dispatched positions for early decoding and muxing to the 4 decode units. FIG. 20 of the 4 pipeline stages is shown for reference. Timing of fetching instructions to the decode units is as followed:</p><p>Cycle 1\u2014Fetch from the array, the ICPDAT starts the scanning, and the ICTAGV starts the tag comparison. IB(<b>127</b>:<b>0</b>) is muxed to IB<b>1</b>(<b>191</b>:<b>0</b>) for aligning to 4 dispatched positions.</p><p>Cycle 2\u2014Complete the scanning of each individual 8-byte and align 7 bytes for each instruction to the early decoding.</p><p>Cycle 3\u2014Multiplex the instructions to 4 early-decoding units (the scanning logic can send up to 8 instructions) and decode up to 5 prefixes and opcode for 2-dispatch positions instruction, and decode for the register operands, flags, CALL/RETURN instructions.</p><p>Cycle 4\u2014Multiplex the instructions to 4 decoding units, the prefix is the combined prefix and the instructions from IB<b>2</b> (<b>191</b>:<b>0</b>). The decode unit start the operand and flag decoding.</p><p>The operation in the scanning cycle:</p><p>If the scanning logic can dispatch all of first and second 8-bytes, it fetches another 16-bytes from the array.</p><p>If the first 8-bytes cannot be dispatched, the dispatched instructions of the second 8-bytes in the ICALIGN are invalidated. The pre-decode bits of the first 8-byte is updated. The reading from the array is voided.</p><p>If the first 8-bytes can be dispatched, and the second 8-bytes cannot be dispatched, then the pre-decode bits of the second 8-bytes are updated. The second 8-bytes are shifted to the first 8-bytes, and a new 8-bytes are fetched into the second 8-bytes.</p><p>Signals from the next stages can indicate the number of 8-bytes to send.</p><p>Each 8-byte block consists of the following information:</p><p>Number of valid instructions.</p><p>The valid bits for each instruction, the valid bits can continue to the next 8-byte blocks.</p><p>The functional bits for each instruction, the functional bits can continue to the next 8-byte blocks.</p><p>The operation in prioritizing and aligning:</p><p>Four instructions are selected from IB<b>1</b>(<b>191</b>:<b>0</b>) to send to early decoding. Each instructions can have up to 7 bytes for decoding, 4 prefix bytes, 1 opcode, 1 MODRM, and 1 SIB.</p><p>In the 8-byte block where the third instruction is started, this 8-byte block should be kept until the next clock cycle. The appropriate HOLD signals are generated to ICPDAT for accepting the next 8-byte blocks. If the first two instructions require 2 dispatched positions each, then the third instruction must wait until the next clock cycle. The decode information is not available until the fourth ICLK. The third instruction must remain in the IB<b>1</b> latch until the first two instructions are decoded. Except for the SIB-byte instruction with early indication by the functional bit, the opcode must be decoded for few other instructions. The information from decoding is too late to stop the scanning cycle from sending the next 8-bytes. MROM instruction should move to dispatch position <b>0</b> and wait for the micro-instructions from MENG. MROM instruction remains in the first 8-byte block of IB<b>2</b> until completion of MROM instruction.</p><p>If the prefixes count for any instruction in the first 8-byte is greater than 4, ICALIGN can only accept another 8-byte. The detection logic is an AND gate of 6 valid functional bits.</p><p>Invalidate the dispatched instructions in ICALIGN.</p><p>FIG. 21 shows exemplary hardware in a block diagram format for aligning of instructions from Icache to Idecode.</p><p>Early Decoding</p><p>The early decoding functions of this block includes:</p><p>Combine all prefixes into one byte.</p><p>Detect a few special instructions and send into two dispatched positions in the same line which will be dispatched to decode units.</p><p>Decode the unconditional jump instruction to generate taken branch address for the next fetch PC which should be from way and branch prediction. The CALL and RETURN are used to update the return stack.</p><p>Verify the predicted taken branch instruction.</p><p>Speculatively decode for register operands and flags, and generate the operand size information.</p><p>Generate displacement size to read the displacement and immediate fields from the bus to the decode units.</p><p>A diagram showing exemplary hardware for early decoding of prefixes and opcodes is shown as FIG. <b>22</b>.</p><p>The dispatched instructions from the ICPDAT are in two 8-byte blocks and arrange into three 8-byte blocks for aligning. The ICALIGN must select the first 4 instructions to mux the instruction bytes to early decoding units. Each early decoding unit receives 7 bytes of instructions for the possibility of 4 prefix bytes, 1 opcode byte, 1 MODRM byte, and 1 SIB byte. Two conditions that can be detected early and fed back to the ICPDAT for accepting the next blocks of instructions are: the SIB-byte instruction, and the instruction with more than 4 prefixes. The other conditions for instructions with 2 dispatched positions take longer to detect. The pre-decoded functional bits provide useful information. In early decoding, the valid bits for the instruction should be used to qualify the valid bytes of the instructions. Refer to a previous section for encoding of the functional bit. For the first byte, indicated by the start bit, if the functional bit is 0, the instruction is MROM, if the functional bit is 1, the instruction is fast path. The encoding for the functional bits of MROM instruction is inverted that of the fast path instruction. If the first functional bit is 0, all functional bits are inverted before qualifying with the valid bits for prefix and opcode decoding. MROM instructions are handled in the MROM block. Detection of MROM is passed through the early decode unit and hold for micro-instructions from MROM. In addition, the functional bits should also be set for SIB-byte. The SIB-byte instruction takes two dispatched positions. ICALIGN needs to look at 2 bytes after the opcode byte for SIB-byte setting of the functional bit. The opcode byte can be detected the setting of the functional bits from the start bit. The logic can be as shown in FIG. <b>23</b>.</p><p>Prefix Decoding</p><p>In early decode, 4 prefix decoding units are used for each prefix byte. All the prefixes are combined into a single encoded prefix for decode units. For each start bit, the ICALIGN logic looks at up to 7 functional bits at a time. The start and end bits are used to validate and qualify the functional bits for shifting and decoding of the instruction bytes. Decoding for the prefixes are as followed:</p><p><tables id=\"TABLE-US-00013\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"168PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Prefix</entry><entry morerows=\"0\" valign=\"top\">Encoded Prefix</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"126PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0000 0000</entry><entry morerows=\"0\" valign=\"top\">No prefix</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x0F</entry><entry morerows=\"0\" valign=\"top\">1xxx xxxx</entry><entry morerows=\"0\" valign=\"top\">2-byte escape</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x66</entry><entry morerows=\"0\" valign=\"top\">x1xx xxxx</entry><entry morerows=\"0\" valign=\"top\">operand size override, 16 or 32-bit data</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x67</entry><entry morerows=\"0\" valign=\"top\">xx1x xxxx</entry><entry morerows=\"0\" valign=\"top\">address size override, 16 or 32-bit addr</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0xF0</entry><entry morerows=\"0\" valign=\"top\">xxx1 xxxx</entry><entry morerows=\"0\" valign=\"top\">LOCK prefix</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x2E</entry><entry morerows=\"0\" valign=\"top\">xxxx 1000</entry><entry morerows=\"0\" valign=\"top\">CS segment override</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x36</entry><entry morerows=\"0\" valign=\"top\">xxxx 1001</entry><entry morerows=\"0\" valign=\"top\">SS segment override</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x3E</entry><entry morerows=\"0\" valign=\"top\">xxxx 1010</entry><entry morerows=\"0\" valign=\"top\">DS segment override</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x26</entry><entry morerows=\"0\" valign=\"top\">xxxx 1100</entry><entry morerows=\"0\" valign=\"top\">ES segment override</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x64</entry><entry morerows=\"0\" valign=\"top\">xxxx 1101</entry><entry morerows=\"0\" valign=\"top\">FS segment override</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x65</entry><entry morerows=\"0\" valign=\"top\">xxxx 1110</entry><entry morerows=\"0\" valign=\"top\">GS segment override</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Another function of early decoding is to detect instructions which have more than 4 prefix bytes. The instruction will not be dispatched in the next cycle. For more than 4 prefix bytes, an extra clock cycle is needed, after decoding the first 4 prefixes the instruction is shifted by 4 bytes and to decode the prefixes and opcode again. The extra prefixes will override the previous encoding of the same prefix. The percentage of 5 or more prefixes is less than 0.01% for one bench mark and less than 0.00% in all other bench marks.</p><p>Some notes on the prefix assumptions:</p><p>2-byte escape must be before the opcode. Multiple 2-byte escape prefixes cause illegal opcode exception. Segment override changes the default segment used for an instruction. Last prefix is used when multiple segment prefixes are present. Instruction that does not reference a segment ignores segment prefixes.</p><p>Operand size toggles the operand size between 16 and 32. When the operand size is 8, the operand size prefix is ignored. Multiple operand size prefixes do the same as single operand size prefix.</p><p>Address size toggles the address size between 16 and 32. Stack access of some instructions and instruction without address calculation are not affected by address size prefix. Multiple address size prefixes do the same as single address size prefix.</p><p>A lock prefix is only allowed on certain instructions. When not applicable, lock prefixes cause an illegal opcode exception. Some instructions (i.e. EXCH) cause locked accesses by default without the lock prefix. Multiple lock prefixes do the same as single lock prefix.</p><p>Repeat for string instructions, repeat prefixes are ignored when not applicable.</p><p>Double-Dispatch Decoding</p><p>Besides the SIB instruction which requires two dispatch positions, few other instructions must go through decoding. The same opcode are sent to two decode units with an encoded field for indication of the first or second dispatch position. The list of 2-dispatch position instructions are: PUSH, POP, RETURN, CALL, MUL, IMUL, LOOP, JCXZ, JECXZ, and LEAVE. The above instructions have either two destination registers, or two load/store operations, or more than two input operands (not counting the immediate and displacement). The above instructions with SIB should go to MROM. PUSH from memory and POP to memory instructions can become register if the MOD field is 11. In this case, the PUSH from memory should take only one dispatch position, and the POP to memory should take 2 dispatch positions instead of going to MROM.</p><p><tables id=\"TABLE-US-00014\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"161PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">Opcode</entry><entry morerows=\"0\" valign=\"top\">2-dispatch positions</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"112PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0000000000</entry><entry morerows=\"0\" valign=\"top\">Single instruction</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0xxxxxxxxx</entry><entry morerows=\"0\" valign=\"top\">First rop of the 2-dispatch</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"133PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">positions instruction</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"112PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1xxxxxxxxx</entry><entry morerows=\"0\" valign=\"top\">Second rop of the 2-dispatch</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"133PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">positions instruction</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"112PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">0xFF /6</entry><entry morerows=\"0\" valign=\"top\">x1xxxxxxxx</entry><entry morerows=\"0\" valign=\"top\">PUSH from memory</entry></row><row><entry morerows=\"0\" valign=\"top\">0x58</entry><entry morerows=\"0\" valign=\"top\">xx1xxxxxxx</entry><entry morerows=\"0\" valign=\"top\">POP into register</entry></row><row><entry morerows=\"0\" valign=\"top\">0x1F</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POP into DS</entry></row><row><entry morerows=\"0\" valign=\"top\">0x07</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POP into ES</entry></row><row><entry morerows=\"0\" valign=\"top\">0x17</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POP into SS</entry></row><row><entry morerows=\"0\" valign=\"top\">0x0F A1</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POP into FS</entry></row><row><entry morerows=\"0\" valign=\"top\">0x0F A9</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POP into GS</entry></row><row><entry morerows=\"0\" valign=\"top\">0xF7 /4</entry><entry morerows=\"0\" valign=\"top\">xxx1xxxxxx</entry><entry morerows=\"0\" valign=\"top\">MUL instruction - word/dword</entry></row><row><entry morerows=\"0\" valign=\"top\">0xF7 /5</entry><entry morerows=\"0\" valign=\"top\">xxx1xxxxxx</entry><entry morerows=\"0\" valign=\"top\">IMUL instruction - word/dword</entry></row><row><entry morerows=\"0\" valign=\"top\">0xC9</entry><entry morerows=\"0\" valign=\"top\">xxxx1xxxxx</entry><entry morerows=\"0\" valign=\"top\">LEAVE</entry></row><row><entry morerows=\"0\" valign=\"top\">0xE0</entry><entry morerows=\"0\" valign=\"top\">xxxxx1xxxx</entry><entry morerows=\"0\" valign=\"top\">LOOP with ZF=0</entry></row><row><entry morerows=\"0\" valign=\"top\">0xE1</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LOOP with ZF=1</entry></row><row><entry morerows=\"0\" valign=\"top\">0xE2</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LOOP</entry></row><row><entry morerows=\"0\" valign=\"top\">0xE3</entry><entry morerows=\"0\" valign=\"top\">xxxxxx1xxx</entry><entry morerows=\"0\" valign=\"top\">JCXZ &amp; JECXZ</entry></row><row><entry morerows=\"0\" valign=\"top\">0xE8</entry><entry morerows=\"0\" valign=\"top\">xxxxxxx1xx</entry><entry morerows=\"0\" valign=\"top\">CALL near, displacement relative</entry></row><row><entry morerows=\"0\" valign=\"top\">0xFF /2</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CALL near, register indirect</entry></row><row><entry morerows=\"0\" valign=\"top\">relative</entry></row><row><entry morerows=\"0\" valign=\"top\">0xC3</entry><entry morerows=\"0\" valign=\"top\">xxxxxxxx1x</entry><entry morerows=\"0\" valign=\"top\">RETURN near</entry></row><row><entry morerows=\"0\" valign=\"top\">0xC2</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RETURN near, immediate</entry></row><row><entry morerows=\"0\" valign=\"top\">FUNC bit set</entry><entry morerows=\"0\" valign=\"top\">xxxxxxxxx1</entry><entry morerows=\"0\" valign=\"top\">SIB-byte instruction</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Handling of Branch Instructions</p><p>For unconditional branch instructions, the branch is always taken, and the fetching should stall until the target address is known. There are three types of unconditional branch instructions, CALL/INT, RETURN/IRET, and unconditional jump. These branch instructions should be predicted taken. Processor <b>500</b> should implement a return stack, and as the CALL and INT instructions are in decode, the next instruction PC will be written into the return stack for future reference. The RETURN and IRET instructions will get the target address from the return stack, it is not necessary to keep the RETURN and IRET instructions in the ICNXTBLK. The target address calculation for non-conditional jump requires an adder to speculatively add the PC to displacement which is done in the ICFPC. The important features of the return stack are discussed in detail in ICFPC.</p><p><tables id=\"TABLE-US-00015\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"84PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">JUMP</entry><entry morerows=\"0\" valign=\"top\">1110 10x1</entry><entry morerows=\"0\" valign=\"top\">PC = PC + imm</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">JUMP</entry><entry morerows=\"0\" valign=\"top\">EA</entry><entry morerows=\"0\" valign=\"top\">PC = CS:imm</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">JUMP</entry><entry morerows=\"0\" valign=\"top\">FF xx100xxx</entry><entry morerows=\"0\" valign=\"top\">PC = r/m32</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">JUMP</entry><entry morerows=\"0\" valign=\"top\">FF xx101xxx</entry><entry morerows=\"0\" valign=\"top\">PC = CS:[m16:32]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CALL</entry><entry morerows=\"0\" valign=\"top\">E8</entry><entry morerows=\"0\" valign=\"top\">PC = PC + imm</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CALL</entry><entry morerows=\"0\" valign=\"top\">FF xx010xxx</entry><entry morerows=\"0\" valign=\"top\">PC = r/m32</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CALL</entry><entry morerows=\"0\" valign=\"top\">FF xx011xxx</entry><entry morerows=\"0\" valign=\"top\">PC = CS:[m16:32]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CALL</entry><entry morerows=\"0\" valign=\"top\">98</entry><entry morerows=\"0\" valign=\"top\">PC = CS:imm</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RETURN</entry><entry morerows=\"0\" valign=\"top\">C2, C3, CA, CB</entry><entry morerows=\"0\" valign=\"top\">PC = [return stack]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INT</entry><entry morerows=\"0\" valign=\"top\">CC, CD, CE</entry><entry morerows=\"0\" valign=\"top\">PC is from MENG</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IRET</entry><entry morerows=\"0\" valign=\"top\">CF</entry><entry morerows=\"0\" valign=\"top\">PC = [return stack]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>If the above instructions are not detected in the way and branch prediction, Icache should re-fetch from the new branch target. INT instruction is not in the ICNXTBLK, detection of the INT will stall until the MENG or FIROB request a new PC. The CALL instruction has the offset matched with the branch taken offset in the ICFPC. The RETURN and IRET are predicted by the way prediction. The ICFPC keeps status bits for each line of instruction to control the proper flow of instructions.</p><p>For conditional branch instructions, the ICNXTBLK is in total control of the prediction. Only the taken branch is recognized in the ICALIGN. Only one taken branch is possible per instruction line. The ICALIGN notifies the ICFPC to send the PC's for each line dispatched to the decode units. Only one taken branch is allowed per 4 instructions sent to the decode units. The branch target address and the branch tag from the global shift register should be routed along with any branch instruction (include unconditional jump) to the FIROB in case of mis-prediction.</p><p>The ICFPC always sends the current PC to FIROB and decode units. If there is an indication of the dispatching of instruction from a new 8-byte block, the next PC is sent. If the instruction of a new 8-byte block is to decode unit <b>0</b>, then the next PC is sent as first PC, else the next PC is sent as second PC. The PC is 32-bits which indicates the full address of the instruction. The offset of the instruction is for the next instruction.</p><p>MODRM and SIB Decoding</p><p>With up to four instructions dispatched per clock cycle, eight possible read operands must be checked for data dependency. The FIROB checks for dependency against all previously dispatched instructions (up to 5 lines or 20 instructions) and within the current line. In the FIROB, the number of comparators are 20 by 8 for the 6-bit register operands. It is important to decode the register operands as soon as possible. Flags are in the same category with the operands which need early indication. Some of the X86 opcodes have implied references to registers and flags. The register operands are from MODRM byte. In early decoding, the registers are speculatively decoded and sent to dependency checking. In decode units, the direction and validation of the registers are decoded to set the statuses in the FIROB and control the issuing of operands to functional units.</p><p>The MODRM has 3 fields: REG, MOD, and R/M. The REG field is sent to the first operand and the R/M field is sent to the second operand. The R/M is not a valid register operand for the following MOD field:</p><p><tables id=\"TABLE-US-00016\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"56PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">16-bit addressing</entry><entry morerows=\"0\" valign=\"top\">MOD = 00 and R/M = 110,</entry><entry morerows=\"0\" valign=\"top\">16-bit</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">displacement</entry></row><row><entry morerows=\"0\" valign=\"top\">32-bit addressing</entry><entry morerows=\"0\" valign=\"top\">MOD = 00 and R/M = 100,</entry><entry morerows=\"0\" valign=\"top\">SIB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOD = 00 and R/M = 101,</entry><entry morerows=\"0\" valign=\"top\">32-bit</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">displacement</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOD = 01 and R/M = 100,</entry><entry morerows=\"0\" valign=\"top\">SIB, 8-bit disp</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOD = 10 and R/M = 100,</entry><entry morerows=\"0\" valign=\"top\">SIB, 32-bit</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">displacement</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>For 32-bit address mode, the SIB byte is specified as above. The instruction is dispatched in two issue positions. The first Rop is an add of the Base to Index with indication to the FIROB of invalid result. The second Rop is the actual instruction without the SIB byte, the second Rop generates a dependency tag related to the first Rop. For the 16-bit addressing mode, the MODRM also indicates the base and index which are equivalent to the SIB byte for 32-bit addressing mode. The coding of MODRM is as follows:</p><p><tables id=\"TABLE-US-00017\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"126PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOD = 0x, 10</entry><entry morerows=\"0\" valign=\"top\">R/M = 000 Base = BX Index = SI</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOD = 0x, 10</entry><entry morerows=\"0\" valign=\"top\">R/M = 001 Base = BX Index = DI</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOD = 0x, 10</entry><entry morerows=\"0\" valign=\"top\">R/M = 010 Base = BP Index = SI</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOD = 0x, 10</entry><entry morerows=\"0\" valign=\"top\">R/M = 011 Base = BP Index = DI</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>For MOD=11, the R/M field specifies the register based on the width field and the data sizes. The width field is the least significant bit of the opcode, if w=0, the data size is 8 bit, if w=1, the data size is 16 or 32 bits. The data size is from Code Segment register with possible override from prefix.</p><p><tables id=\"TABLE-US-00018\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOD R/M</entry><entry morerows=\"0\" valign=\"top\">8-bit</entry><entry morerows=\"0\" valign=\"top\">16-bit</entry><entry morerows=\"0\" valign=\"top\">32-bit</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11 000</entry><entry morerows=\"0\" valign=\"top\">AL</entry><entry morerows=\"0\" valign=\"top\">AX</entry><entry morerows=\"0\" valign=\"top\">EAX</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11 001</entry><entry morerows=\"0\" valign=\"top\">CL</entry><entry morerows=\"0\" valign=\"top\">CX</entry><entry morerows=\"0\" valign=\"top\">ECX</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11 010</entry><entry morerows=\"0\" valign=\"top\">DL</entry><entry morerows=\"0\" valign=\"top\">DX</entry><entry morerows=\"0\" valign=\"top\">EDX</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11 011</entry><entry morerows=\"0\" valign=\"top\">BL</entry><entry morerows=\"0\" valign=\"top\">BX</entry><entry morerows=\"0\" valign=\"top\">EBX</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11 100</entry><entry morerows=\"0\" valign=\"top\">AH</entry><entry morerows=\"0\" valign=\"top\">SP</entry><entry morerows=\"0\" valign=\"top\">ESP</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11 101</entry><entry morerows=\"0\" valign=\"top\">CH</entry><entry morerows=\"0\" valign=\"top\">BP</entry><entry morerows=\"0\" valign=\"top\">EBP</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11 110</entry><entry morerows=\"0\" valign=\"top\">DH</entry><entry morerows=\"0\" valign=\"top\">SI</entry><entry morerows=\"0\" valign=\"top\">ESI</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11 111</entry><entry morerows=\"0\" valign=\"top\">BH</entry><entry morerows=\"0\" valign=\"top\">DI</entry><entry morerows=\"0\" valign=\"top\">EDI</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The displacement field is also decoded from the MODRM:</p><p><tables id=\"TABLE-US-00019\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"77PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOD R/M</entry><entry morerows=\"0\" valign=\"top\">displacement size</entry><entry morerows=\"0\" valign=\"top\">displacement size</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">16-bit addressing</entry><entry morerows=\"0\" valign=\"top\">32-bit addressing</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">00 110</entry><entry morerows=\"0\" valign=\"top\">16-bit</entry><entry morerows=\"0\" valign=\"top\">no displacement</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">00 101</entry><entry morerows=\"0\" valign=\"top\">no displacement</entry><entry morerows=\"0\" valign=\"top\">32-bit</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01 xxx</entry><entry morerows=\"0\" valign=\"top\">8-bit</entry><entry morerows=\"0\" valign=\"top\">8-bit</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">10 xxx</entry><entry morerows=\"0\" valign=\"top\">16-bit</entry><entry morerows=\"0\" valign=\"top\">32-bit</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Opcode Decoding for Operands and Flags</p><p>Besides register addresses from the MODRM byte the instructions with implied register in the opcode should also be decoded:</p><p><tables id=\"TABLE-US-00020\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">PUSH</entry><entry morerows=\"0\" valign=\"top\">0101 0nnn\u2003A, C, D, B, SP, BP, SI, DI</entry><entry morerows=\"0\" valign=\"top\">R</entry></row><row><entry morerows=\"0\" valign=\"top\">POP</entry><entry morerows=\"0\" valign=\"top\">0101 1nnn\u2003A, C, D, B, SP, BP, SI, DI</entry><entry morerows=\"0\" valign=\"top\">W</entry></row><row><entry morerows=\"0\" valign=\"top\">LEAVE</entry><entry morerows=\"0\" valign=\"top\">1100 1001\u2003EBP, ESP</entry><entry morerows=\"0\" valign=\"top\">RW</entry></row><row><entry morerows=\"0\" valign=\"top\">ALU OP</entry><entry morerows=\"0\" valign=\"top\">00xx x100\u2003AL</entry><entry morerows=\"0\" valign=\"top\">RW</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1000 0000</entry></row><row><entry morerows=\"0\" valign=\"top\">ALU OP</entry><entry morerows=\"0\" valign=\"top\">00xx x101\u2003AX, EAX</entry><entry morerows=\"0\" valign=\"top\">RW</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1000 00x1</entry></row><row><entry morerows=\"0\" valign=\"top\">MUL -byte</entry><entry morerows=\"0\" valign=\"top\">1111 0110\u2003AX</entry><entry morerows=\"0\" valign=\"top\">W</entry></row><row><entry morerows=\"0\" valign=\"top\">SHIFTD</entry><entry morerows=\"0\" valign=\"top\">0F 1010 x101\u2003CL</entry><entry morerows=\"0\" valign=\"top\">R</entry></row><row><entry morerows=\"0\" valign=\"top\">ROT/SHF</entry><entry morerows=\"0\" valign=\"top\">1101 001x\u2003CL</entry><entry morerows=\"0\" valign=\"top\">R</entry></row><row><entry morerows=\"0\" valign=\"top\">INC</entry><entry morerows=\"0\" valign=\"top\">0100 0nnn\u2003A, C, D, B, SP, BP, SI, DI</entry><entry morerows=\"0\" valign=\"top\">RW</entry></row><row><entry morerows=\"0\" valign=\"top\">DEC</entry><entry morerows=\"0\" valign=\"top\">0100 1nnn\u2003A, C, D, B, SP, BP, SI, DI</entry><entry morerows=\"0\" valign=\"top\">RW</entry></row><row><entry morerows=\"0\" valign=\"top\">BSWAP</entry><entry morerows=\"0\" valign=\"top\">0F 1100 1nnn A, C, D, B, SP, BP, SI, DI</entry><entry morerows=\"0\" valign=\"top\">RW</entry></row><row><entry morerows=\"0\" valign=\"top\">CBW</entry><entry morerows=\"0\" valign=\"top\">1001 1000\u2003A</entry><entry morerows=\"0\" valign=\"top\">RW</entry></row><row><entry morerows=\"0\" valign=\"top\">SAHF</entry><entry morerows=\"0\" valign=\"top\">1001 1110\u2003AH</entry><entry morerows=\"0\" valign=\"top\">W</entry></row><row><entry morerows=\"0\" valign=\"top\">LAHF</entry><entry morerows=\"0\" valign=\"top\">1001 1111\u2003AH</entry><entry morerows=\"0\" valign=\"top\">R</entry></row><row><entry morerows=\"0\" valign=\"top\">MOVE</entry><entry morerows=\"0\" valign=\"top\">1010 000x\u2003A</entry><entry morerows=\"0\" valign=\"top\">W</entry></row><row><entry morerows=\"0\" valign=\"top\">MOVE</entry><entry morerows=\"0\" valign=\"top\">1010 001x\u2003A</entry><entry morerows=\"0\" valign=\"top\">R</entry></row><row><entry morerows=\"0\" valign=\"top\">MOVE</entry><entry morerows=\"0\" valign=\"top\">1011 0nnn\u2003AL, CL, DL, BL, AH, CH, DH, BH</entry><entry morerows=\"0\" valign=\"top\">W</entry></row><row><entry morerows=\"0\" valign=\"top\">MOVE</entry><entry morerows=\"0\" valign=\"top\">1011 1nnn\u2003A, C, D, B, SP, BP, SI, DI</entry><entry morerows=\"0\" valign=\"top\">W</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The MUL and IMUL instructions should have the first issue position with EAX destination and the second issue position with EDX destination. The second Rop is the actual instruction since the first Rop can be the add for index and base of the SIB-byte. For the stack operations, POP/PUSH/CALL/RETURN instructions, the ESP must be read and written. The instruction is an add of ESP to the address size on the immediate bus for the functional unit. The POP and RETURN instruction read the ESP in the first Rop and add to the ESP in the second ROP. The RETURN with immediate for adding to the ESP must be handled as two operations in the functional units. Opcode decoding is needed to generate the ESP pointers for the instructions:</p><p><tables id=\"TABLE-US-00021\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"147PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x8F</entry><entry morerows=\"0\" valign=\"top\">POP into memory</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x58</entry><entry morerows=\"0\" valign=\"top\">POP into register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x1F</entry><entry morerows=\"0\" valign=\"top\">POP into DS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x07</entry><entry morerows=\"0\" valign=\"top\">POP into ES</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x17</entry><entry morerows=\"0\" valign=\"top\">POP into SS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x0F A1</entry><entry morerows=\"0\" valign=\"top\">POP into FS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x0F A9</entry><entry morerows=\"0\" valign=\"top\">POP into GS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x61</entry><entry morerows=\"0\" valign=\"top\">POP into general registers</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x9D</entry><entry morerows=\"0\" valign=\"top\">POP into EFLAGS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0xFF</entry><entry morerows=\"0\" valign=\"top\">PUSH from memory</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x50</entry><entry morerows=\"0\" valign=\"top\">PUSH from register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x6A</entry><entry morerows=\"0\" valign=\"top\">PUSH from immediate byte</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x68</entry><entry morerows=\"0\" valign=\"top\">PUSH from immediate word/dword</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x0E</entry><entry morerows=\"0\" valign=\"top\">PUSH from CS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x16</entry><entry morerows=\"0\" valign=\"top\">PUSH from SS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x1E</entry><entry morerows=\"0\" valign=\"top\">PUSH from DS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x06</entry><entry morerows=\"0\" valign=\"top\">PUSH from ES</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x0F A0</entry><entry morerows=\"0\" valign=\"top\">PUSH from FS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x0F A8</entry><entry morerows=\"0\" valign=\"top\">PUSH from GS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x60</entry><entry morerows=\"0\" valign=\"top\">PUSH from general registers</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0x9C</entry><entry morerows=\"0\" valign=\"top\">PUSH from EFLAGS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0xEB</entry><entry morerows=\"0\" valign=\"top\">CALL near, displacement</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0xFF /2</entry><entry morerows=\"0\" valign=\"top\">CALL near, register/memory indirect</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0xC3</entry><entry morerows=\"0\" valign=\"top\">RETURN near, ESP = ESP + 2/4</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0xC2 /2</entry><entry morerows=\"0\" valign=\"top\">RETURN near, ESP = ESP + 2/4 + imm16</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0xC9</entry><entry morerows=\"0\" valign=\"top\">LEAVE, ESP = EBP + 2/4, EBP = [EBP]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>A constant field is generated for the ESP calculation. Depending on the address size, a constant of 2 or 4 is needed for the above instructions. For JCXZ and JECXZ instructions, a constant of 0 is needed for the zero detection. For LOOP instructions, a constant of 1 is needed for decrementing of the counter.</p><p>The decoding of the flags should be done in early decoding. The status flag information is from the appendix on FLAG CROSS-REFERENCE in the X86 manual. The instructions must provide the reading and writing of the status flags in the same manner as the operands. The flags are set up in three groups:</p><p>CF-carry flag.</p><p>OF-overflow, SF-sig, ZF-zero, PF-parity, AF-auxiliary carry, and DF-direction flags.</p><p>The rest of the control flags in the EFLAG register.</p><p>The first two flag groups have dependency checking in the FIROB and forwarding in the reservation station. The second group is implemented with three sub-groups, OF, DF, and {SF, ZF, AF, and PF} (4F). The dependency checking of the second group is similar to that of the operand, if the dependency is wide-to-narrow then it is okay for forward, if the dependency is narrow-to-wide then the instruction stalls in decode units until the dependency is removed. The last flag group will stall the instruction in decode units if there is any dependency. The decoding of the status flags is as followed:</p><p><tables id=\"TABLE-US-00022\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Instruction</entry><entry morerows=\"0\" valign=\"top\">opcode</entry><entry morerows=\"0\" valign=\"top\">read flags</entry><entry morerows=\"0\" valign=\"top\">write flags</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">ADC, SBB</entry><entry morerows=\"0\" valign=\"top\">0001 x0xx</entry><entry morerows=\"0\" valign=\"top\">CF</entry><entry morerows=\"0\" valign=\"top\">CF, OF, 4F</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0001 xx0x</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">8 000x xx01xxxx</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">8 0011 xx01xxxx</entry></row><row><entry morerows=\"0\" valign=\"top\">ALU OP</entry><entry morerows=\"0\" valign=\"top\">00xx x100</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CF, OF, 4F</entry></row><row><entry morerows=\"0\" valign=\"top\">SHIFTD</entry><entry morerows=\"0\" valign=\"top\">0F 1010 x101</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CF, OF, 4F</entry></row><row><entry morerows=\"0\" valign=\"top\">RCL/RCR</entry><entry morerows=\"0\" valign=\"top\">D 00xx xx01xxxx</entry><entry morerows=\"0\" valign=\"top\">CF</entry><entry morerows=\"0\" valign=\"top\">CF, OF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">C 000x xx01xxxx</entry></row><row><entry morerows=\"0\" valign=\"top\">ROL/ROR</entry><entry morerows=\"0\" valign=\"top\">D 00xx xx00xxxx</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CF, OF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">C 000x xx00xxxx</entry></row><row><entry morerows=\"0\" valign=\"top\">SHF</entry><entry morerows=\"0\" valign=\"top\">D 00xx xx10xxxx</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CF, OF, 4F</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">D 00xx xx111xxx</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">C 000x xx10xxxx</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">C 000x xx111xxx</entry></row><row><entry morerows=\"0\" valign=\"top\">INC</entry><entry morerows=\"0\" valign=\"top\">0100 0xxx</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CF, OF, 4F</entry></row><row><entry morerows=\"0\" valign=\"top\">DEC</entry><entry morerows=\"0\" valign=\"top\">0100 1xxx</entry><entry morerows=\"0\" valign=\"top\">CF, OF, 4F</entry></row><row><entry morerows=\"0\" valign=\"top\">LAHF</entry><entry morerows=\"0\" valign=\"top\">1001 1111</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CF, OF, 4F</entry></row><row><entry morerows=\"0\" valign=\"top\">SAHF</entry><entry morerows=\"0\" valign=\"top\">1001 1110</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CF, OF, 4F</entry></row><row><entry morerows=\"0\" valign=\"top\">CLC, SETC</entry><entry morerows=\"0\" valign=\"top\">1111 100x</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CF</entry></row><row><entry morerows=\"0\" valign=\"top\">CMC</entry><entry morerows=\"0\" valign=\"top\">1111 0101</entry><entry morerows=\"0\" valign=\"top\">CF</entry><entry morerows=\"0\" valign=\"top\">CF</entry></row><row><entry morerows=\"0\" valign=\"top\">CLD, SETD</entry><entry morerows=\"0\" valign=\"top\">1111 110x</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DF</entry></row><row><entry morerows=\"0\" valign=\"top\">CLI, SETI</entry><entry morerows=\"0\" valign=\"top\">1111 101x</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IF</entry></row><row><entry morerows=\"0\" valign=\"top\">SET</entry><entry morerows=\"0\" valign=\"top\">0F 1001 001x</entry><entry morerows=\"0\" valign=\"top\">CF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0F 1001 011x</entry><entry morerows=\"0\" valign=\"top\">CF, ZF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0F 1001 000x</entry><entry morerows=\"0\" valign=\"top\">OF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0F 1001 11xx</entry><entry morerows=\"0\" valign=\"top\">OF, 4F</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0F 1001 010x</entry><entry morerows=\"0\" valign=\"top\">4F</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0F 1001 10xx</entry><entry morerows=\"0\" valign=\"top\">4F</entry></row><row><entry morerows=\"0\" valign=\"top\">JCCB</entry><entry morerows=\"0\" valign=\"top\">0111 001x</entry><entry morerows=\"0\" valign=\"top\">CF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0111 011x</entry><entry morerows=\"0\" valign=\"top\">CF, ZF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0111 000x</entry><entry morerows=\"0\" valign=\"top\">OF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0111 11xx</entry><entry morerows=\"0\" valign=\"top\">OF, 4F</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0111 010x</entry><entry morerows=\"0\" valign=\"top\">4F</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0111 10xx</entry><entry morerows=\"0\" valign=\"top\">4F</entry></row><row><entry morerows=\"0\" valign=\"top\">JCCW</entry><entry morerows=\"0\" valign=\"top\">0F 1000 001x</entry><entry morerows=\"0\" valign=\"top\">CF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0F 1000 011x</entry><entry morerows=\"0\" valign=\"top\">CF, ZF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0F 1000 000x</entry><entry morerows=\"0\" valign=\"top\">OF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0F 1000 11xx</entry><entry morerows=\"0\" valign=\"top\">OF, 4F</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0F 1000 010x</entry><entry morerows=\"0\" valign=\"top\">4F</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0F 1000 10xx</entry><entry morerows=\"0\" valign=\"top\">4F</entry></row><row><entry morerows=\"0\" valign=\"top\">BIT</entry><entry morerows=\"0\" valign=\"top\">0F 1010 x011</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0F 1011 x011</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0F 1011 101x</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>MROM Register Operand Decoding</p><p>To not effect the MODRM decoding for Processor <b>500</b> fast path, the microcode uses the prefix for extending the register field. The extended register field for microcode will be concatenated with the MODRM register field to address the full 64 register file. For Processor <b>500</b> fast path instruction, the extended register field is forced to zero. The MODRM, the displacement, and the immediate field can be read from the global decoding registers. A diagram of the MROM register decoding is shown as FIG. <b>24</b>.</p><p>Multiplexing of Instruction to Decode Units</p><p>The format of instructions dispatched to the decode unit includes one encoded prefix byte, which may not be valid, speculative register operands and flags, 2-dispatch position control bits, 11-bit opcode, 3-bit constant, up to 4 bytes of displacement, and 4 bytes of immediate field. During early decode, the displacement size and field is determined and read directly from the IB<b>2</b>(<b>191</b>:<b>0</b>) to the decode units. The immediate field is speculative of 4 bytes after the displacement field. Two-dispatch position instructions cause shifting of the next instructions to the next issue positions. If the instruction at <b>0</b> takes 2 dispatch positions, then only instruction at <b>1</b> is allowed to take 2 dispatch positions. The controls for reading of the displacement and immediate fields are shifted according to the 2-dispatch position instruction. A diagram showing the multiplexing of 2-dispatch position instructions to the decode units is shown as FIG. <b>25</b>.</p><p>The first four instructions from scanning can go through early decoding. If a 2-dispatch position instruction is detected, the followed instruction must be shifted to the next decode unit or wait until the next cycle. If the 2-dispatch position instruction is at the last decode unit, it also must wait until the next cycle.</p><p>MENG should provide the same format as with fast-path instructions. Detection of MROM instruction should delay until the next cycle and in dispatch position <b>0</b>. The MROM instruction should locate at the first 8-byte block on the IB<b>2</b>(<b>191</b>:<b>0</b>). MENG can provide the pointers to read the displacement and immediate fields to decode units directly from IB<b>2</b> (<b>191</b>:<b>0</b>). The MROM instruction is shifted out of the dispatch position <b>0</b> along with the last line of the micro-code sequence, the next set of instructions will assume normal dispatching.</p><p>Exception Instructions</p><p>The illegal instruction is detected in ICPRED which does not set the valid bit in the ICTAGV. The illegal instruction must be dispatched to decode unit <b>0</b> by itself with ICERROR. Similarly for TLB misses, external bus error, s and greater-than-15-byte instruction, the error conditions are passed to decode unit <b>0</b>. The limit checking of each instruction is done in the ICFPC, the ICFPC will notify the ICALIGN with the limit violated byte position. The illegal instruction is higher priority than limit violation.</p><p>Signal list</p><p>STARTPTR(<b>3</b>:<b>0</b>)\u2014Input from ICFPC indicates the byte position of the pre-decoded bytes for current instruction. The start byte should be set at this pointer.</p><p>HLDISP(<b>1</b>:<b>0</b>)\u2014Output to ICFPC indicates the first (bit <b>0</b>) and/or the second (bit <b>1</b>) 8-byte of the current line has been dispatched to decode units.</p><p>NEWLINE(<b>1</b>:<b>0</b>)\u2014Input from ICFPC indicates the first (bit <b>0</b>) or the second (bit <b>1</b>) 8-byte is the starting of a new line. The byte positions of instructions sending to the decode units should be adjusted accordingly.</p><p>IC<b>0</b>VAL<b>1</b>(<b>7</b>:<b>0</b>)\u2014Input from ICDPAT indicates the valid bytes for instruction <b>0</b> of the first 8-byte.</p><p>IC<b>1</b>VAL<b>1</b>(<b>7</b>:<b>0</b>)\u2014Input from ICDPAT indicates the valid bytes for instruction <b>1</b> of the first 8-byte.</p><p>IC<b>2</b>VAL<b>1</b>(<b>7</b>:<b>0</b>)\u2014Input from ICDPAT indicates the valid bytes for instruction <b>2</b> of the first 8-byte.</p><p>IC<b>3</b>VAL<b>1</b>(<b>7</b>:<b>0</b>)\u2014Input from ICDPAT indicates the valid bytes for instruction <b>3</b> of the first 8-byte.</p><p>IC<b>0</b>VAL<b>2</b>(<b>7</b>:<b>0</b>)\u2014Input from ICDPAT indicates the valid bytes for instruction <b>0</b> of the second 8-byte.</p><p>IC<b>1</b>VAL<b>2</b>(<b>7</b>:<b>0</b>)\u2014Input from ICDPAT indicates the valid bytes for instruction <b>1</b> of the second 8-byte.</p><p>IC<b>2</b>VAL<b>2</b>(<b>7</b>:<b>0</b>)\u2014Input from ICDPAT indicates the valid bytes for instruction <b>2</b> of the second 8-byte.</p><p>IC<b>3</b>VAL<b>2</b>(<b>7</b>:<b>0</b>)\u2014Input from ICDPAT indicates the valid bytes for instruction <b>3</b> of the second 8-byte.</p><p>IC<b>8</b>BSEL(<b>5</b>:<b>0</b>)\u2014Output to ICALIGN controls the muxes from IB(<b>127</b>:<b>0</b>) to IB<b>1</b>(<b>191</b>:<b>0</b>). Bit <b>5</b>:<b>3</b> is for the upper 8-byte IB(<b>127</b>:<b>64</b>) and bit <b>2</b>:<b>0</b> is for the lower 8-byte IB(<b>63</b>:<b>0</b>). 001 is for muxing to the first 8-byte IB<b>1</b>(<b>63</b>:<b>0</b>), 010 is for muxing to the second 8-byte, and 100 is for muxing to the third 8-byte.</p><p>NSHIFT<b>1</b>(<b>4</b>:<b>0</b>)\u2014Output to ICALIGN indicates that for the first 8-byte block, the look-ahead shifting of the next 8-byte instructions to decode units. A shift by 4 means that no instruction from the next eight byte is sent to the decode unit.</p><p>NSHIFT<b>2</b>(<b>4</b>:<b>0</b>)\u2014Output to ICALIGN indicates that for the second 8-byte block, the look-ahead shifting of the next 8-byte instructions to decode units. A shift by 4 means that no instruction from the next eight byte is sent to the decode unit.</p><p>ENDINST\u2014Input from ICPRED indicates that pre-decoding is completed for the current instruction.</p><p>MROMEND\u2014Input from MENG indicates completion of the MROM.</p><p>PDMROM\u2014Input from ICPRED indicates the current instruction is MROM.</p><p>PD<b>8</b>BSEL(<b>5</b>:<b>0</b>)\u2014Output to ICALIGN controls the muxes from IB(<b>127</b>:<b>0</b>) to IB<b>1</b>(<b>191</b>:<b>0</b>). Bit <b>5</b>:<b>3</b> is for the upper 8-byte</p><p>IB(<b>127</b>:<b>64</b>) and bit <b>2</b>:<b>0</b> is for the lower 8-byte IB(<b>63</b>:<b>0</b>). 001 is for muxing to the first 8-byte IB<b>1</b>(<b>63</b>:<b>0</b>), 010 is for muxing to the second 8-byte, and 100 is for muxing to the third 8-byte.</p><p>PFUNCB(<b>2</b>:<b>0</b>)\u2014Input from ICPRED indicates the functional bits for current instruction. Only three bytes (opcode, MODRM, and SIB) are needed for early decode of the instruction. The prefixes are encoded into one single byte.</p><p>PDVAL(<b>10</b>:<b>0</b>)\u2014Input from ICPRED indicates the valid bytes for pre-decode instruction to decode unit <b>0</b>. This signal is to validate the bytes in decode. The maximum length of the instruction is 11 bytes.</p><p>PDSHF(<b>5</b>:<b>0</b>)\u2014Input from ICPRED indicates which bytes to shifting to early decoding. The ICPRED must put the current line into the IB<b>1</b>(<b>191</b>:<b>0</b>) for shifting. This is necessary because the long instruction can span more than three 8-byte blocks. The upper 2 bits to select which 8-byte block, the ICALIGN can accumulate the pre-decode instructions while waiting for the MROM instructions.</p><p>PDPREF(<b>7</b>:<b>0</b>)\u2014Input from ICPRED indicates the encoded prefix byte. This is to avoid the pre-decode instruction taking 2 cycles in early decoding because of more than 4 prefixes.</p><p>PDTAKEN\u2014Input from ICPRED indicates the current instruction is taken branch (the taken branch target can be calculated.</p><p>NEXTB(<b>1</b>:<b>0</b>)\u2014Output to ICPDAT indicates that ICALIGN can accept any 8-byte block. This signal includes other hold inputs from MROM and Idecode.</p><p>DOUSEFL(<b>4</b>:<b>0</b>)</p><p>DOWRFL(<b>4</b>:<b>0</b>)\u2014Output to FIROB indicates the type of flag uses/writes for this instruction of decode unit <b>0</b>:</p><p>xxxx<b>1</b> CF-carry flag,</p><p>xxx<b>1</b>x DF-direction flag,</p><p>xx<b>1</b>xx OF-overflow flag,</p><p>x<b>1</b>xxx SF-sign, ZF-zero, PF-parity, and AF-auxiliary carry</p><p><b>1</b>xxxx control and processor flags,</p><p>D<b>1</b>USEFL(<b>4</b>:<b>0</b>)</p><p>D<b>1</b>WRFL(<b>4</b>:<b>0</b>)\u2014Output to FIROB indicates the type of flag used/written for this instruction of decode unit <b>1</b>.</p><p>D<b>2</b>USEFL(<b>4</b>:<b>0</b>)</p><p>D<b>2</b>WRFL(<b>4</b>:<b>0</b>)\u2014Output to FIROB indicates the type of flag used/written for this instruction of decode unit <b>2</b>.</p><p>D<b>3</b>USEFL(<b>4</b>:<b>0</b>)</p><p>D<b>3</b>WRFL(<b>4</b>:<b>0</b>)\u2014Output to FIROB indicates the type of flag used/written for this instruction of decode unit <b>3</b>.</p><p>RD<b>0</b>PTR<b>1</b>(<b>5</b>:<b>0</b>)\u2014Indicates the register address for operand <b>1</b> of decode unit <b>0</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>1</b>PTR<b>1</b>(<b>5</b>:<b>0</b>)\u2014Indicates the register address for operand <b>1</b> of decode unit <b>1</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>2</b>PTR<b>1</b>(<b>5</b>:<b>0</b>)\u2014Indicates the register address for operand <b>1</b> of decode unit <b>2</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>3</b>PTR<b>1</b>(<b>5</b>:<b>0</b>)\u2014Indicates the register address for operand <b>1</b> of decode unit <b>3</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>0</b>PTR<b>2</b>(<b>5</b>:<b>0</b>)\u2014Indicates register address for operand <b>2</b> of decode unit <b>0</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>1</b>PTR<b>2</b>(<b>5</b>:<b>0</b>)\u2014Indicates register address for operand <b>2</b> of decode unit <b>1</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>2</b>PTR<b>2</b>(<b>5</b>:<b>0</b>)\u2014Indicates register address for operand <b>2</b> of decode unit <b>2</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>RD<b>3</b>PTR<b>2</b>(<b>5</b>:<b>0</b>)\u2014Indicates register address for operand <b>2</b> of decode unit <b>3</b>. The MROM is responsible to send bit <b>5</b>:<b>3</b> for the MROM register.</p><p>IDxDAT(<b>1</b>:<b>0</b>)\u2014Output to indicates the data size information. 01-byte, 10-half word, 11-word, 00-not use.</p><p>IC<b>0</b>POS<b>1</b>(<b>3</b>:<b>0</b>)\u2014Input from ICDPAT indicates the PC's byte position for instruction <b>0</b> of the first 8-byte.</p><p>IC<b>1</b>POS<b>1</b>(<b>3</b>:<b>0</b>)\u2014Input from ICDPAT indicates the PC's byte position for instruction <b>1</b> of the first 8-byte.</p><p>IC<b>2</b>POS<b>1</b>(<b>3</b>:<b>0</b>)\u2014Input from ICDPAT indicates the PC's byte position for instruction <b>2</b> of the first 8-byte.</p><p>IC<b>3</b>POS<b>1</b>(<b>3</b>:<b>0</b>)\u2014Input from ICDPAT indicates the PC's byte position for instruction <b>3</b> of the first 8-byte.</p><p>IC<b>0</b>POS<b>2</b>(<b>3</b>:<b>0</b>)\u2014Input from ICDPAT indicates the PC's byte position for instruction <b>0</b> of the second 8-byte.</p><p>IC<b>1</b>POS<b>2</b>(<b>3</b>:<b>0</b>)\u2014Input from ICDPAT indicates the PC's byte position for instruction <b>1</b> of the second 8-byte.</p><p>IC<b>2</b>POS<b>2</b>(<b>3</b>:<b>0</b>)\u2014Input from ICDPAT indicates the PC's byte position for instruction <b>2</b> of the second 8-byte.</p><p>IC<b>3</b>POS<b>2</b>(<b>3</b>:<b>0</b>)\u2014Input from ICDPAT indicates the PC's byte position for instruction <b>3</b> of the second 8-byte.</p><p>ICPOSx(<b>4</b>:<b>0</b>)\u2014Output to Idecode indicates the PC's byte position of the next instruction. ICALIGN uses the above signal to generate the offset of the next instruction which will be used for branch mis-prediction. The most significant bit indicates the next instruction started at the next line.</p><p>ICBRN(<b>3</b>:<b>0</b>)\u2014Input from ICNXTBLK indicates the branch taken prediction the lines of instructions being fetched.</p><p>ICBTAG<b>1</b>(<b>3</b>:<b>0</b>)\u2014Output to Idecode indicates the position of the first target branch instruction with respect to the global shift register in case of branch mis-prediction. The branch can be taken or non-taken, branch tag must be sent with all branch instruction.</p><p>ICBTAG<b>2</b>(<b>3</b>:<b>0</b>)\u2014Output to Idecode indicates the position of the second target branch instruction with respect to the global shift register in case of branch mis-prediction. The branch can be taken or non-taken, branch tag must be sent with all branch instruction.</p><p>RETPRED\u2014Input from ICNXTBLK indicates the current prediction of the return instruction of the fetched line. The return instruction must be detected in the current line of instruction or the Icache must be re-fetched from a new line.</p><p>UNJMP(<b>3</b>:<b>0</b>)\u2014Output to ICCNTL indicates the unconditional branch instruction needs to calculate target address.</p><p>BRNTKN(<b>3</b>:<b>0</b>)\u2014Output indicates which decode unit has a predicted taken branch. The operand steering uses this signal to latch and send BTADDR(<b>31</b>:<b>0</b>) to the functional unit.</p><p>BRNINST(<b>3</b>:<b>0</b>)\u2014Output indicates which decode unit has a global branch prediction. The operand steering uses this signal to latch and send ICBTAG<b>1</b>(<b>3</b>:<b>0</b>) and ICBTAG<b>2</b>(<b>3</b>:<b>0</b>) to the functional units.</p><p>CALLDEC(<b>3</b>:<b>0</b>)\u2014Output to ICFPC indicates the CALL instruction is detected, the return stack should be updated with the PC address of instruction after CALL. The line must be taken.</p><p>NORETB\u2014Output to ICFPC indicates no RETURN instruction is detected for the current line. This signal responses to RETPRED. The ICFPC should use the branch prediction of BTAKEN to fetch the next line.</p><p>RETDEC(<b>3</b>:<b>0</b>)\u2014Output to ICFPC indicates a RETURN instruction is detected for the way prediction to update if no RETURN was predicted. The ICFPC needs to keep track of the branch instructions for 4 lines and restores the global shift register in case of mis-predicting the RETURN instruction in Idecode.</p><p>ICnPREF(<b>7</b>:<b>0</b>)\u2014Output to decode unit n indicates the encoded prefix byte.</p><p>IC<b>2</b>ROPn(<b>9</b>:<b>0</b>)\u2014Output to decode unit n indicates 2-dispatch positions instruction. Bit <b>9</b> indicates the first rop or second rop of the 2-dispatch positions instruction, bits <b>8</b>:<b>0</b> indicate the type of instructions.</p><p>NODEST(<b>3</b>:<b>0</b>)\u2014Output to FIROB indicates no destination for the first rop of the SIB-byte instruction.</p><p>DEPTAG(<b>3</b>:<b>1</b>)\u2014Output to FIROB indicates forced dependency tag on the first instruction; the second rop of the SIB-byte instruction.</p><p>DISPBRN<b>1</b>(<b>1</b>:<b>0</b>)\u2014Output to ICFPC indicates the first predicted branch instruction dispatched to decode unit. This signal is the OR of ICxBRNB<b>1</b>. Bit <b>0</b> is for the first 8-byte and bit <b>1</b> is for the second 8-byte of the line if NEWLINE(<b>1</b>) is set for the second 8-byte.</p><p>DISPBRN<b>2</b>(<b>1</b>:<b>0</b>)\u2014Output to ICFPC indicates the second predicted branch instruction dispatched to decode unit. This signal is the OR of ICxBRNB<b>2</b>. Bit <b>0</b> is for the first 8-byte and bit <b>1</b> is for the second 8-byte of the line if NEWLINE(<b>1</b>) is set for the second 8-byte.</p><p>BVAL<b>1</b>\u2014Input from ICNXTBLK to qualify BTAG<b>1</b>, indicates the first branch target is greater or equal to STARTPTR.</p><p>BVAL<b>2</b>\u2014Input from ICNXTBLK to qualify BTAG<b>2</b>, indicates the second branch target is greater or equal to STARTPTR.</p><p>REFRESH<b>2</b>\u2014Input from Idecode indicates current line of instructions will be refreshed and not accept new instructions from Icache.</p><p>IB(<b>127</b>:<b>0</b>)\u2014Input from ICSTORE indicates the new line of instructions to be sent to decode units.</p><p>IB<b>1</b>(<b>191</b>:<b>0</b>)\u2014Internal indicates the combined instruction line for aligning from the array.</p><p>IB<b>2</b>(<b>191</b>:<b>0</b>)\u2014Output indicates the combined instruction line for dispatching to decode units, the displacement and immediate fields are read from this bus.</p><p>MROMEN\u2014Input from MENG indicates the micro-instructions is sent to Idecode instead of the Icache.</p><p>MOUSEFL(<b>4</b>:<b>0</b>)</p><p>MOWRFL(<b>4</b>:<b>0</b>)\u2014Input from MENG indicates the type of flag used/written for this micro-instruction of decode unit <b>0</b>:</p><p>xx<b>1</b> CF\u2014carry flag,</p><p>x<b>1</b>x OF\u2014overflow flag,</p><p><b>1</b>xx SF\u2014sign, ZF\u2014zero, PF\u2014parity, and AF\u2014auxiliary carry</p><p>M<b>1</b>USEFL(<b>4</b>:<b>0</b>)</p><p>M<b>1</b>WRFL(<b>4</b>:<b>0</b>)\u2014Input from MENG indicates the type of flag used/written for this micro-instruction of decode unit <b>1</b>.</p><p>M<b>2</b>USEFL(<b>4</b>:<b>0</b>)</p><p>M<b>2</b>WRFL(<b>4</b>:<b>0</b>)\u2014Input from MENG indicates the type of flag used/written for this micro-instruction of decode unit <b>2</b>.</p><p>M<b>3</b>USEFL(<b>4</b>:<b>0</b>)</p><p>M<b>3</b>WRFL(<b>4</b>:<b>0</b>)\u2014Input from MENG indicates the type of flag used/written for this micro-instruction of decode unit <b>3</b>.</p><p>MINS<b>0</b>(<b>63</b>:<b>0</b>)\u2014Input from MENG indicates the displacement and immediate field of micro-instruction sending to decode <b>0</b>.</p><p>MINS<b>1</b>(<b>63</b>:<b>0</b>)\u2014Input from MENG indicates the displacement and immediate field of micro-instruction sending to decode <b>1</b>.</p><p>MINS<b>2</b>(<b>63</b>:<b>0</b>)\u2014Input from MENG indicates the displacement and immediate field of micro-instruction sending to decode <b>2</b>.</p><p>MINS<b>3</b>(<b>63</b>:<b>0</b>)\u2014Input from MENG indicates the displacement and immediate field of micro-instruction sending to decode <b>3</b>.</p><p>MR<b>0</b>OPC(<b>7</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>0</b> indicates the opcode byte.</p><p>MR<b>1</b>OPC(<b>7</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>1</b> indicates the opcode byte.</p><p>MR<b>2</b>OPC(<b>7</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>2</b> indicates the opcode byte.</p><p>MR<b>3</b>OPC(<b>7</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>3</b> indicates the opcode byte.</p><p>MR<b>0</b>EOP(<b>2</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>0</b> indicates the extended opcode field.</p><p>MR<b>1</b>EOP(<b>2</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>1</b> indicates the extended opcode field.</p><p>MR<b>2</b>EOP(<b>2</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>2</b> indicates the extended opcode field.</p><p>MR<b>3</b>EOP(<b>2</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>3</b> indicates the extended opcode field.</p><p>MR<b>0</b>SS(<b>1</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>0</b> indicates the scale factor of the SIB byte.</p><p>MR<b>1</b>SS(<b>1</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>1</b> indicates the scale factor of the SIB byte.</p><p>MR<b>2</b>SS(<b>1</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>2</b> indicates the scale factor of the SIB byte.</p><p>MR<b>3</b>SS(<b>1</b>:<b>0</b>)\u2014Input from MENG to decode unit <b>3</b> indicates the scale factor of the SIB byte.</p><p>MBYTEPTR(<b>3</b>:<b>0</b>)\u2014Output to MENG indicates the byte pointer for the current MROM instruction. MROM uses the pointer to read the instruction on IB(<b>127</b>:<b>0</b>), ICEND(<b>15</b>:<b>0</b>), and ICFUNC(<b>15</b>:<b>0</b>).</p><p>ICMROM\u2014Output to MENG indicates the current instruction is MROM. The MROM instruction may take two cycles to read the IB, ICEND, and ICFUNC.</p><p>ENDINST\u2014Input from ICPRED indicates that pre-decoding is completed for the current instruction. The byte position of the branch instruction is from STARTPTR. The selected instruction from IB should be sent to decode unit <b>0</b>.</p><p>PDJMP\u2014Input from ICPRED indicates the current instruction is a branch instruction. The ICNXTBLK sends BTAG<b>1</b> and the ICALIGN sends IC<b>0</b>BRNBN<b>1</b>(<b>0</b>) to the decode unit.</p><p>ICVALI(<b>3</b>:<b>0</b>)\u2014Output to Idecode indicates valid instructions. NOOP is generated for invalid instruction.</p><p>IC<b>0</b>OPC(<b>7</b>:<b>0</b>)\u2014Output to decode unit <b>0</b> indicates the opcode byte.</p><p>IC<b>1</b>OPC(<b>7</b>:<b>0</b>)\u2014Output to decode unit <b>1</b> indicates the opcode byte.</p><p>IC<b>2</b>OPC(<b>7</b>:<b>0</b>)\u2014Output to decode unit <b>2</b> indicates the opcode byte.</p><p>IC<b>3</b>OPC(<b>7</b>:<b>0</b>)\u2014Output to decode unit <b>3</b> indicates the opcode byte.</p><p>IC<b>0</b>EOP(<b>2</b>:<b>0</b>)\u2014Output to decode unit <b>0</b> indicates the extended opcode field.</p><p>IC<b>1</b>EOP(<b>2</b>:<b>0</b>)\u2014Output to decode unit <b>1</b> indicates the extended opcode field.</p><p>IC<b>2</b>EOP(<b>2</b>:<b>0</b>)\u2014Output to decode unit <b>2</b> indicates the extended opcode field.</p><p>IC<b>3</b>EOP(<b>2</b>:<b>0</b>)\u2014Output to decode unit <b>3</b> indicates the extended opcode field.</p><p>IC<b>0</b>SS(I:<b>0</b>)\u2014Output to decode unit <b>0</b> indicates the scale factor of the SIB byte.</p><p>IC<b>1</b>SS(<b>1</b>:<b>0</b>)\u2014Output to decode unit <b>1</b> indicates the scale factor of the SIB byte.</p><p>IC<b>2</b>SS(<b>1</b>:<b>0</b>)\u2014Output to decode unit <b>2</b> indicates the scale factor of the SIB byte.</p><p>IC<b>3</b>SS(<b>1</b>:<b>0</b>)\u2014Output to decode unit <b>3</b> indicates the scale factor of the SIB byte.</p><p>DISPTR<b>0</b>(<b>6</b>:<b>0</b>)\u2014Output to decode unit <b>0</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, bit <b>6</b>:<b>5</b> is the size, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Bit <b>6</b>:<b>5</b>=00 indicates no displacement.</p><p>DISPTR<b>1</b>(<b>6</b>:<b>0</b>)\u2014Output to decode unit <b>1</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, bit <b>6</b>:<b>5</b> is the size, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Bit <b>6</b>:<b>5</b>=00 indicates no displacement.</p><p>DISPTR<b>2</b>(<b>6</b>:<b>0</b>)\u2014Output to decode unit <b>2</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, bit <b>6</b>:<b>5</b> is the size, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Bit <b>6</b>:<b>5</b>=00 indicates no displacement.</p><p>DISPTR<b>3</b>(<b>6</b>:<b>0</b>)\u2014Output to decode unit <b>3</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, bit <b>6</b>:<b>5</b> is the size, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Bit <b>6</b>:<b>5</b>=00 indicates no displacement.</p><p>IMMPTR<b>0</b>(<b>4</b>:<b>0</b>)\u2014Output to decode unit <b>0</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Decoding of all opcodes is needed to detect immediate field.</p><p>IMMPTR<b>1</b>(<b>4</b>:<b>0</b>)\u2014Output to decode unit <b>1</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Decoding of all opcodes is needed to detect immediate field.</p><p>IMMPTR<b>2</b>(<b>4</b>:<b>0</b>)\u2014Output to decode unit <b>2</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Decoding of all opcodes is needed to detect immediate field.</p><p>IMMPTR<b>3</b>(<b>4</b>:<b>0</b>)\u2014Output to decode unit <b>3</b> indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Decoding of all opcodes is needed to detect immediate field.</p><p>CONSTn(<b>2</b>:<b>0</b>)\u2014Output to decode unit n indicates the constant for add/substract to ESP of the two-dispatch position instruction.</p><p>ICCNTL</p><p>The ICCNTL is the main control in the ICACHE. The state machine controls reading and writing of the arrays in the first two pipeline stages. The next two pipeline stages are controlled by the ICALIGN. The detection of the unconditional branch instruction are treated as mis-prediction to fetching a new instruction stream without updating the ICNXTBLK. It latches the inputs at the beginning of ICLK and generates control signals to the arrays for the next cycle by the end of ICLK. There are a few signals from the arrays, such as TAGHIT, to ICCNTL in early ICLK instead of previous phase. The state machine can be jammed into a certain state with late arriving signals from branch mis-prediction and branch prediction. The IRESET jams the state machine to Idle state, initializes the code segment register, and clears all the status of ICACHE. For external fetch on Processor <b>500</b>, there will be dedicated buses for address to MMU and instructions from the pads, the state machine for external fetch is not needed. The preliminary state machine definition and transitions are from the definition of Processor <b>500</b> and is shown as FIG. <b>26</b>.</p><p>The ICCNTL provides the signals to read and write the cache arrays. For simple operation, the array has the same inputs as the ICCNTL to avoid the speed path through the state machine.</p><p>The Move-To/From-Special-Register instruction can occur at any time and steal one cycle at a convenient time away from the normal operation. The move to/from instruction is for testing purposes and happens with instruction cache disabled. The external fetch can be concurrent with Special Register access. The state machine implements with latches to hold the input and output conditions during the Special Register access. The operation of Special Register takes 5 cycles and is as followed:</p><p>Command and tag on the SRBB is received with indication by SRB_VAL. The tag on SRBB is decoded to recognized the access is for Icache.</p><p>The address of the array is on SRBB. This address should be latched into the ICFPC.</p><p>For reading, the array is read in this cycle. For writing, the data is latched from SRBB.</p><p>The data is driven on ICSRBB.</p><p>For reading, the data is forward from ICSRBB to SRBB. For writing, the data is written into the array. ICTAR_VAL is sent to SRB in this cycle.</p><p>STATE<b>0</b>: Idle State</p><p>The Idle state is forced by IRESET, Branch Mis-prediction, or EXCEPTION, and waits for taken branch target. This is a default state. If the state is forced by branch mis-prediction, it provides Icache control signals to write the Branch Holding Register into the ICNXTBLK. This state transfers to the Cache Access state when the taken branch address is valid, the transfer provides all Icache control signals for reading the array.</p><p>STATE<b>1</b>: Cache Access State</p><p>The Icache is being accessed. The TAGHIT is not know until next clock cycle; the assumption is HIT and accessing the next block, the next block address can either be from the ICNXTBLK or sequential. This state provides Icache control signals for reading the array. When the TAGHIT is known, if there is no holding due to breaking up of the instruction line or invalid pre-decode data, then the state remains in Cache Access state, else the state will transition to Cache Hold state. The transition to Cache Hold state will need to provide Icache control signals for reading the next block of the array. If miss in the Icache, the state is transferred to Cache Miss state. The miss can either be the tag or LV miss. The transfer to Cache Miss state must provides Icache control signals to write the Branch Holding Register into the ICNXTBLK.</p><p>STATE<b>2</b>: Cache Hold State</p><p>The state waits for the whole line of instruction to be sent to decode units. Icache control signals for reading of next block is continuously provided. As soon as the ICALIGN block can accept the next line, the state transfers to the Cache Access state.</p><p>STATE<b>3</b>: Cache Miss State</p><p>The Cache Miss state makes a request to the CMASTER and waits for a response. There are two different responses, the first response is the new mapping of the PC (the instructions, pre-decode data, and branch prediction are still valid), the second response is fetched instructions from external memory. The hew mapping of the PC includes setting of the LV bit and writing of new SU and tag. For the first case, the state is transferred to Recovery state, the Icache control signals are to write the ICTAGV and read the ICSTORE, ICPDAT, and ICNXTBLK. For the second case, the state is transferred to the Pre-fetch state, and the Icache control signals are to write the ICTAGV and ICSTORE.</p><p>STATE<b>4</b>: Recovery State</p><p>The Recovery state is a temporary state before transfers to the Cache Access State. This state provides Icache control signals for reading the array.</p><p>STATE<b>5</b>: Pre-fetch state</p><p>This state sends the instruction from the pre-fetch buffer to the ICPRED for pre-decoding. The pre-fetch buffer accepts instructions until full, and handshakes with the BIU to stop fetching so as not to overfill the buffer. As the current line is written into the ICSTORE array, the pre-fetch buffer can shift in a new line. The writing of the new line waits for the completion of pre-decoding of the current line. This state provides array control signals for writing of the ICSTORE array and reading of the next sequential block in the ICTAGV. If the next sequential block is present, as soon as the current line is completed in pre-decoding, the state transfers to the Pre-decode Write state. The array control signals for this transfer write to the ICPDAT and ICNXTBLK. If the next sequential block is not present, completing pre-decoding of the current line causes the Icache PC to increment and writing of the new line into the ICSTORE, and restarts the pre-decoding of the new line. If there is an instruction which wraps to the new line, writing of the last line into the ICPDAT and ICNXTBLK must wait for completion of pre-decoding of this wrapped instruction. During pre-decoding, a taken branch can be detected and the state transfers to the Pre-decode Write state.</p><p>STATE<b>6</b>: Pre-decode Write State</p><p>This state is a temporary state to write the ICPDAT and the ICNXTBLK before transfering to the Idle state or Cache Access state. If the next block address is present from either sequential block or taken branch address which is calculated by the ICPRED, then the state transfers to the Cache Access state. The transfer provides Icache control signals for reading the array. If the taken branch address cannot be calculated by the ICPRED, then the state transfers to the Idle state and waits for the target address from decoding or executing of the instruction. For split-line taken-branch instruction, the pre-decode data of the previous line and the current line (ending of the taken-branch instruction) must be written into the ICPDAT in two clock cycles. The state machine must remain in this state for two clock cycles.</p><p>Testability</p><p>It is important to implement testability features into Processor <b>500</b> to reduce test time, burn-in time, and increase fault coverage. The Build-In-Self-Test (BIST) for the arrays and Auto-Test-Pattern-Generation for the random logic are included.</p><p>BIST</p><p>The BIST is implemented with a chain of input registers to latch and write various patterns into the arrays and to read and compare the data into a chain of output registers. The test pattern is serially shifted into the input registers, and the results are serially shifted out from output registers. With 11-bit counter, the BIST registers for the Icache arrays are with these sizes:</p><p>ICSTORE\u2014128 bits.</p><p>ICPDAT\u201448 bits.</p><p>ICTAGV\u201422 bits. (2 bits are dual-port)</p><p>ICNXTBLK\u201455 bits. (5 bits are dual-port)</p><p>The ICSTORE and the ICPDAT form one chain of 176 bits, and the ICTAGV and the ICNXTBLK form another chain of 77 bits. The second chain must go through the March C twice to access the second port. There is one output pin for each of the chains of BIST registers. The March C algorithm has 5 steps:</p><p>After the test pattern is shifted into the input registers, for every index from 0 to maximum count, write from input registers into the arrays, stall one cycle, then increment to next index.</p><p>For every index from 0 to maximum count, read the array, compare with the input register, set the result register if no match, invert the test pattern in the input register, write into the array, read the array, compare with the input register, set the result register if no match, stall one cycle, and increment to next index.</p><p>For every index from 0 to maximum count, repeat the above step.</p><p>For every index from maximum count to <b>0</b>, read the array, compare with the input register, set the result register if no match, invert the test pattern in the input register, write into the array, read the array, compare with the input register, set the result register if no match, stall one cycle, and decrement to next index.</p><p>For every index from maximum count to 0, repeat the above step. After completion, the results are shifted out and reset while a new test pattern is shifted in, the 5 steps are repeated until test patterns are tested.</p><p>The BIST for the arrays are used in the following modes:</p><p>Normal BIST\u2014Activate by holding INIT pin high and <b>4</b>FLUSH pin low while the RESET pin is de-asserted. The March C test is run until completion and the result is latched into the EAX register. This is for testing purpose.</p><p>Burn-in BIST\u2014Activate by holding INIT pin high while the RESET pin is de-asserted. The March C test is continuously run concurrently with the ATPG until the RESET pin is asserted. The TDO pin is driven high for each completion of the March C test. This is to have many nodes toggle for burn-in purposes.</p><p>JTAG RUNBIST\u2014Activated by the JTAG pins to load and execute the RUNBIST instruction. The processor must be in reset. When the RESET pin is de-asserted, the March C test is run until completion and the result is shifted out to the TDO pin. A special mode can be activated to shift in the test pattern and shift out the result through other pins. The RESET pin must be asserted to end the operation. This is for testing and detecting faults .</p><p>JTAG BITMAP BIST\u2014Activated by the JTAG pins to load and execute the BITMAP instruction. The processor must be in reset. When the RESET pin is de-asserted, the March C test is ran, and results are shifted out to the OUTPUT pins after every compare operation. This is for detecting faults</p><p>JTAG FLUSH REGISTER BIST\u2014Activate by the JTAG pins to load and execute the FLUSH REGISTER instruction, the processor must be in reset. When the RESET pin is de-asserted, the input pattern from the TDI pin is shifted into the result registers serially out to the OUTPUT pins. The RESET pin must be asserted to end the operation. This is for detecting faults in the result registers.</p><p>The BIST controller generates the following five test patterns:</p><p>0101 0101 0101 0101</p><p>0011 0011 0011 0011</p><p>1001 1001 1001 1001</p><p>0000 1111 0000 1111</p><p>0000 0000 1111 1111</p><p>The Build-In Self-Test (BIST) uses the Test Application and Error Compression (TAEC) cells for reading and writing the arrays. Each TAEC cell includes an input shift register for the test pattern and one output shift register for the result. All TAEC cells are connected to form a serial shift path.</p><p>ATPG</p><p>The ATPG is implemented to test non-array blocks in the Icache. The purpose is to be able to reach any node in the logic. The feedback (loop) paths (state machines) must be broken with scan latches. There is a software algorithm to insert the scan latch into the logic. The control blocks in Icache should include the ATPG inputs and outputs for the software to use.</p><p>Signal List</p><p>BSTRUN\u2014Input from TAP indicates to start the BIST.</p><p>BSTRD\u2014Input from TAP indicates to read the array and compare to set the result.</p><p>BSTWR\u2014Input from TAP indicates to write the array from input registers.</p><p>BSTRST\u2014Input from TAP indicates to reset the counter.</p><p>BSTINCR\u2014Input from TAP indicates to increment the counter.</p><p>BSTDIN\u2014Input from TAP indicates the test pattern to the input registers. The input can be from the TDI pin or normal burn-in patterns.</p><p>FLUSHON\u2014Input from TAP indicates flushing register mode, the result latch should use BSTDIN instead of the compare input for flushing the result registers.</p><p>UPDOWN\u2014Input from TAP indicates counting up or down.</p><p>BSTSHF<b>1</b>\u2014Input from TAP indicates shifting of the master latch of registers.</p><p>BSTSHF<b>2</b>\u2014Input from TAP indicates shifting of the slave latch of registers.</p><p>BSTFALSE\u2014Input from TAP indicates to invert the test pattern.</p><p>PORTSEL\u2014Input from TAP indicates to select the second dual port.</p><p>BSTIDOUT\u2014Output to TAP indicates the result of the data chain from the ICSTORE and ICPDAT arrays.</p><p>BSTITOUT\u2014Output to TAP indicates the result of the data chain from the ICNXTBLK and ICTAGV arrays.</p><p>BSTAMSB\u2014Output to TAP indicates maximum count for dual port arrays.</p><p>MAXADDR\u2014Output to TAP indicates maximum index counter.</p><p>ATPGIN(<b>15</b>:<b>14</b>)\u2014Input from dedicated pins for ATPG.</p><p>ATPGOUT(<b>15</b>:<b>14</b>)\u2014Output to dedicated pins for ATPG.</p><p>Timing</p><p>Since the clock cycle is short, reading of the cache would take the whole clock to get data. The clock is single phase, and the array generates its own self time clock. The self-time clock uses the same cache column self-time line. As the line pre-charges to a high level, the pre-charge is disabled and the array access is enabled. As the line discharges, the row driver and senamp are disabled. In one embodiment, the pre-charge takes 1.7 ns and the current timing for TAGHIT from the self-time clock with 64 rows is 2.8 ns or a total time of 4.5 ns from rising edge of ICLK. The reading data is 2.0 ns from the self-time clock with 64 rows or 0.8 ns before the rising edge of ICLK. The ICSTORE can be built with larger arrays, 128 rows by 256 columns, reading instructions would take all of 4.5 ns ICLK in this case. Other arrays, ICTAGV, ICPRED, and ICNXTBLK, are 64 rows. The align logic in the ICPDAT takes 6-7 gates, and the shifting of X86 instruction bytes to the decode unit can be done by the middle of the second ICLK. The Processor <b>500</b> instructions should allow the decode units at least 2.5 ns in the second ICLK for calculation of the linear address.</p><p>cycle 1: ICFPC, muxing new PC, pre-charge, and access all arrays</p><p>cycle 2: Compare tags, aligning logic's from pre-decode, setup branch prediction, and muxing instructions to decode units on IB buses.</p><p>cycle 2.5: Displacement linear address calculation. Fast decoding for register operands and validating of the linear address, and fast decoding for non-conditional branch.</p><p>If the predicted branch from the ICNXTBLK is taken, the new PC will take two clock cycles to update in the ICFPC. The speculative way-prediction takes 2 gates for set decoding, 3 gates for muxing of success index to ICFPC, and 2 gates in row decoding.</p><p>The timing for instructions from external memory is as follows:</p><p>cycle 1: Latch data from INSB bus to pre-fetch buffer and mux onto IB buses to ICPRED in next clock; the data on IB buses are held until pre-decode is completed. Write data into cache.</p><p>cycle 2: Decode opcode and prefix from the byte pointer. Decoding takes 2 clock cycles. If there is prefix, then restart the decoding of opcode in the next cycle.</p><p>cycle 3: Decode opcode. Send pre-decode data to ICPDAT and allow the align logic to select the instruction on IB buses to decode units</p><p>cycle 4: Send instruction from IB buses to decode units on IBDx buses. The IBDx buses should have the same timing as reading from the array.</p><p>The MROM interface requires a different timing:</p><p>ICLK<b>3</b>: Detect MROM instruction and send the byte position to MROM interface.</p><p>ICLK<b>4</b>: Decode prefixes and generate MROM entry point.</p><p>ICLK<b>5</b>: Decode instruction.</p><p>ICLK<b>6</b>: Decode instruction and latch all field of instructions into global registers.</p><p>ICLK<b>6</b>: MROM reads global registers and sends micro-instruction to decode units by mid cycle.</p><p>Layout</p><p>With a short clock cycle, the size of the arrays are limited to 128 rows by 256 columns for single-port RAM arrays which read or write in different clock cycles and not in speed path. For dual-port RAM arrays or faster read timing, the 64 rows by 256 columns array is preferred. The array sizes are based on the single port RAM cell of 10.25 u\u00d76.75 u, and the dual port RAM cell of 10.25 u\u00d714.5 u. The arrays in the ICACHE are layout as shown in FIG. <b>27</b>:</p><p>ICSTORE\u20142048 lines of 128 bits, 8 sets of 128\u00d7256, 1312 u\u00d71728 u, single.</p><p>ICPREDAT\u20142048 lines of 48 bits, 8 sets of 64\u00d7192, 656 u\u00d71296 u, single.</p><p>ICTAGV\u20142048 lines of 24 bits, 3 sets of 64\u00d7224, 656 u\u00d71512 u, single, and 1 set of 64\u00d796, 656 u\u00d71392 u, dual.</p><p>ICNXTBLK\u20142048 lines of51 bits, 5 sets of 64\u00d7256, 656 u\u00d71728 u, single, 1 set of 64\u00d7192, 656 u\u00d71296 u, single, 1 set of 64\u00d796, 656 u\u00d71392 u, dual, and 1 set of 64\u00d764, 656 u\u00d7928 u, dual.</p><p>ICTAGV includes a of 20-bit tag, a <b>1</b>-bit valid, a 3-bit status, and a 3-bit way-prediction. The tag and valid are single-port RAM, and the status and way-prediction are dual-port RAM. The ICNXTBLK does not include the global branch prediction. A suggested layout for Icache is shown in FIG. <b>27</b>.</p><p>Overview of the Processor <b>500</b> Idecode</p><p>This section describes the instruction decode organization. The instruction decoding is directly for X86 instructions; there will be no ROPs except for a few instructions. The X86 variable-length instructions from the Icache are sent to the fixed-length decode units. Up to 4 instructions can be decoded and dispatched in one clock cycle. The decode units are identical. The operand and flag are decoded in the Icache for the critical speed path. The instruction decoding takes 2 clock cycles, in the first cycle the operand and flag dependency checking is done and multiplexed to the functional units in the second cycle. The operand addresses access the register file and the FIROB. The operand address includes the X86 registers and temporary registers generated by the MROM. The FIROB will have to check for dependencies. The instruction decoding generates direct controls to the operation of the functional unit, thus eliminating decoding in the functional units. The global controls of the decode units include a mechanism to stall the line due to serialization and limitations of the load/store buffers, the FIROB, and the reservation stations. The MROM interfacing is sent directly from the Icache and the MROM instructions go through the muxes in the Icache to decode units. A few exceptions for MROM instructions are special registers, floating point instructions, temporary registers, and serialization.</p><p>Top Level of Idecode</p><p>The Idecode has 4 identical decode units. The instructions from Icache and MROM have the same format. Operands and flags are decoded in the Icache or MROM before the instructions are dispatched to the decode units. The MROM may send the micro-instructions with simpler opcodes to the decode units. Decode units decode the micro-instructions separately and multiplex with fast-path instructions to functional units. Prefixes are pre-decoded and sent on separate buses. The format of instructions dispatched to the decode unit includes one encoded prefix byte, which may not be valid, speculative register operands and flags, 2-dispatch position control bits, 11-bit opcode, 3-bit constant, up to 4 bytes of displacement, and 4 bytes of immediate field. Since the Icache validates and partially decodes the instructions before sending to the decode units, a valid bit is issued by the Icache for valid instructions. If the valid is not set, the instruction is dispatched as NOOP. For 2-dispatch position instructions, the indication from Icache causes the decoding of the same instruction to two issue positions. Idecode has 2 clock cycles, the first cycle is for register file accessing and FIROB dependency checking, and the second cycle is for operand steering of the operands and dependency tags to the functional units. The opcode decoding takes 2 clock cycles to generate detail control signals for the functional units. Since the register operands and the immediate field are speculative, the opcode decoding is needed for validation and indication of the direction for the operands and the size of the immediate field if any. The immediate field should be sign-extended as it is sent to the functional unit.</p><p>To handle the PC properly, the Icache provides 2 PC's for each set of dispatched instructions per clock cycle. The first case is when the instructions cross the page boundary, and the second case is when the branch target instruction is dispatched along with the branch instruction. The limitations for branch in each 4 instructions are one taken branch instruction and two branches per line.</p><p>The Idecode can be divided into 4 blocks:</p><p>Opcode decoding for functional unit which can be done in 2 clock cycles.</p><p>Opcode decoding for registers and immediate field, generating controls for the operands and flags, and selecting the target address for branch instruction to reservation stations which should be done in 1 clock cycles.</p><p>Decoding of other instruction fields such as lock, segment register controls, special register, and floating point unit.</p><p>Global control of the pipeline, serialization, and stalling conditions.</p><p>Signal List</p><p>IRESET\u2014Global signal used to reset all decode units. Clear all states.</p><p>EXCEPTION\u2014Global signal from the FIROB. Used to indicate that an interrupt or trap is being taken. Effect on Idecode is to clear all instructions in progress.</p><p>BRNMISP\u2014Input from the Branch execution of the FU indicates a branch mis-prediction. The Idecode clears all instructions in progress.</p><p>ROBEMPTY\u2014Input from the FIROB indicates the FIROB is empty.</p><p>ROBFULL\u2014Input from the FIROB indicates the FIROB is full.</p><p>CS32\u00d716\u2014Input from the LSSEC indicates the size of the code segment register.</p><p>SS32\u00d716\u2014Input from the LSSEC indicates the size of the stack segment register.</p><p>MVTOSRIAD\u2014Input from SRB, indicates a move to IAD special register, Idecode needs to check its pointer against the pointer driven on IAD.</p><p>MVFRSRIAD\u2014Input from SRB, indicates a move from IAD special register, Idecode needs to check its pointer against the pointer driven on IAD.</p><p>MVTOARIAD\u2014Input from SRB, indicates a move to IAD special register array, Idecode needs to check its pointer against the pointer driven on IAD.</p><p>MVFRARIAD\u2014Input from SRB, indicates a move from IAD special register array, Idecode needs to check its pointer against the pointer driven on IAD.</p><p>RSFULL\u2014Input from the functional units indicates the reservation station is full.</p><p>HLDISP(<b>1</b>:<b>0</b>)\u2014Input from Icache indicates all instructions of the first (bit <b>0</b>) and/or the second (bit <b>1</b>) 8-byte of the current line has been dispatched to decode units.</p><p>ICPC<b>1</b>(<b>31</b>:<b>0</b>)\u2014Input from Icache indicates the current line PC of the first instruction in the 4 issued instructions to pass along with the instruction to the FIROB.</p><p>ICPC<b>2</b>(<b>31</b>:<b>0</b>)\u2014Input from Icache indicates the current line PC of a second instruction which cross the 16-byte boundary or branch target in the 4 issued instructions to pass along with the instruction to the FIROB.</p><p>ICPOSx(<b>3</b>:<b>0</b>)\u2014Input from Icache to decode units indicates the PC's byte position of the instruction.</p><p>ICBTAG<b>1</b>(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates the position of the first target branch instruction with respect to the global shift register in case of branch mis-prediction. The branch can be taken or non-taken, branch tag must be sent with all branch instruction.</p><p>ICBTAG<b>2</b>(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates the position of the second target branch instruction with respect to the global shift register in case of branch mis-prediction. The branch can be taken or non-taken, branch tag must be sent with all branch instruction.</p><p>UNJMP(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates the unconditional branch instruction needs to calculate target address.</p><p>BRNTKN(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates which decode unit has a predicted taken branch. The operand steering uses this signal to latch and send BTADDR(<b>31</b>:<b>0</b>) to the functional unit.</p><p>BRNINST(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates which decode unit has a global branch prediction. The operand steering uses this signal to latch and send ICBTAG<b>1</b>(<b>3</b>:<b>0</b>) and ICBTAG<b>2</b>(<b>3</b>:<b>0</b>) to the functional units.</p><p>ICPREF(<b>7</b>:<b>0</b>)\u2014Input from Icache and MROM indicates the encoded prefix byte. The two most significant bits are repeat prefixes for MROM.</p><p>IC<b>2</b>ROPn(<b>9</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates 2-dispatch positions instruction. Bit <b>3</b> indicates the first rop or second rop of the 2-dispatch positions instruction, bit <b>2</b> indicates POP instruction, bit <b>1</b> indicates the MUL instruction, and bit <b>0</b> indicates the SIB-byte instruction.</p><p>IB<b>2</b>(<b>191</b>:<b>0</b>)\u2014Input from Icache indicates the combined instruction line for reading the displacement and immediate field using pointers.</p><p>ICVALI(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates valid instructions. NOOP is generated for invalid instruction.</p><p>ICnOPC(<b>7</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the opcode byte.</p><p>ICnEOP(<b>2</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the extended opcode field.</p><p>ICnSS(<b>1</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the scale factor of the SIB byte.</p><p>DISPTRn(<b>6</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, bit <b>6</b>:<b>5</b> is the size, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Bit <b>6</b>:<b>5</b>=00 indicates no displacement.</p><p>IMMPTRn(<b>4</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Decoding of all opcodes is needed to detect immediate field.</p><p>MROMEN\u2014Input from MROM indicates the micro-instructions is sent to Idecode instead of the Icache.</p><p>CONSTn(<b>2</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the constant for add/substract to ESP of the two-dispatch position instruction.</p><p>ICMROM\u2014Output to MROM indicates the current instruction is MROM. The MROM instruction may take two cycles to read the IB, ICEND, and ICFUNC.</p><p>ICPC<b>1</b>TAR\u2014Input from Icache indicates is ICPC<b>1</b> a branch target of a previous instruction which is a predicted taken branch instruction.</p><p>ICPC<b>2</b>TAR\u2014Input from Icache indicates is ICPC<b>2</b> a branch target of a previous instruction which is a predicted taken branch instruction.</p><p>ICPC<b>1</b>(<b>31</b>:<b>0</b>)\u2014Input from Icache indicates the current line PC of the first instruction in the 4 issued instructions to pass along with the instruction to FIROB.</p><p>ICPC<b>2</b>(<b>31</b>:<b>0</b>)\u2014Input from Icache indicates the current line PC of a second instruction which cross the 16-byte boundary or branch target in the 4 issued instructions to pass along with the instruction to FIROB.</p><p>ICPOSn(<b>4</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the PC's byte position of the next instruction. Bit <b>4</b> indicates the next instruction is on the next line.</p><p>BTAG<b>1</b>N(<b>3</b>:<b>0</b>)\u2014Output indicates the position of the first target branch instruction for a new line with respect to the global shift register in case of branch mis-prediction.</p><p>BTAG<b>2</b>N(<b>3</b>:<b>0</b>)\u2014Output indicates the position of the second target branch instruction for a new line with respect to the global shift register in case of branch mis-prediction.</p><p>BTAKEN<b>1</b>(<b>1</b>:<b>0</b>)\u2014Input from Icache to decode units and ICFPC indicates a predicted taken branch instruction from PTAKEN, BVAL<b>1</b>. Bit <b>0</b> is the last line and bit <b>1</b> is new line.</p><p>BTAKEN<b>2</b>(<b>1</b>:<b>0</b>)\u2014Input from Icache to decode units and ICFPC indicates a predicted taken branch instruction from PTAKEN, BVAL<b>2</b>. Bit <b>0</b> is the last line and bit <b>1</b> is new line.</p><p>ICERROR\u2014Input from Icache indicates an exception has occurred on an instruction pre-fetched, the type of exception (TLB-miss, page-fault, illegal opcode, external bus error) will also be asserted.</p><p>BTADDR(<b>31</b>:<b>0</b>)\u2014Output to functional units indicates the taken branch targets from either the branch prediction (IBTARGET from Icache) or unconditional branch. The functional units need to compare to the actual branch target.</p><p>BRNTKN(<b>3</b>:<b>0</b>)\u2014Output indicates which decode unit has a predicted taken branch. The operand steering uses this signal to latch and send BTADDR(<b>31</b>:<b>0</b>) to the functional unit.</p><p>BRNINST(<b>3</b>:<b>0</b>)\u2014Output indicates which decode unit has a global branch prediction. The operand steering uses this signal to latch and send BTAG<b>1</b>(<b>3</b>:<b>0</b>) and BTAG<b>2</b>(<b>3</b>:<b>0</b>) to the functional units.</p><p>IDxIMM(<b>2</b>:<b>0</b>)\u2014Output indicates the immediate size information. 01-byte, 10-half word, 11-word, 00-not use. Bit <b>2</b> indicates (0) zero or (1) sign extend.</p><p>IDxDAT(<b>1</b>:<b>0</b>)\u2014Output indicates the data size information. 01- byte, 10-half word, 11-word, 00-not use.</p><p>IDXADDR\u2014Output indicates the address size information. 1-32 bit, 0-16 bit.</p><p>IDxLOCK\u2014Output indicates the lock prefix is set for this instruction for serialization.</p><p>DxUSE<b>1</b>(<b>1</b>:<b>0</b>)\u2014Output to FIROB and register file indicates the type of operand being sent on operand <b>1</b> for decode units. Bit <b>1</b> indicates source operand, and bit <b>0</b> indicates destination operand.</p><p>DxUSE<b>2</b>\u2014Output to FIROB and register file indicates source operand.</p><p>INSDISP(<b>3</b>:<b>0</b>)\u2014Indicates that the instruction in decode unit is valid, if invalid, NOOP is passed to FIROB.</p><p>IMDIWx(<b>31</b>:<b>0</b>)\u2014Output indicates the 32-bit displacement or immediate field of the instruction to pass to the functional units.</p><p>IMDINx(<b>7</b>:<b>0</b>)\u2014Output indicates the 8-bit displacement or immediate field of the instruction to pass to the functional units.</p><p>USEIDW(<b>3</b>:<b>0</b>)\u2014Output indicates the type used in IMDIWx buses.</p><p>USEIDN(<b>3</b>:<b>0</b>)\u2014Output indicates the type used in IMDINx buses.</p><p>INSLSxB(<b>5</b>:<b>0</b>)\u2014Output from decode units indicates the prefix values. bit <b>5</b>\u2014data size, bit <b>4</b>\u2014address size, bit <b>3</b>\u2014lock, bit <b>2</b>:<b>0</b>\u2014segment registers.</p><p>REFRESH<b>2</b>\u2014Output indicates current line of instructions will be refreshed and not accept new instructions from Icache.</p><p>INSOPxB(<b>11</b>:<b>0</b>)\u2014Output indicates the type of instructions being dispatched, this is the decoded information for the functional units to execute.</p><p>Instruction Opcode Decoding</p><p>The instruction decoding has 1.5 clock cycles for decoding, thereby allowing time to route the output to functional units. The output is a wide bus with direct commands for the functional units to execute the instruction. The current listing for functional unit includes 3-bit protocol, 6-bit opcode, 7-bit p/g for alu, 3-bit size, 4-bit segment register select, and 3-bit flag. Except for the p/g for alu, all other control bits for the functional unit must be further decoded into single-bit control. The size and segment register select are decoded in a later section. The listing of the actual binary is done by going through the X86 instruction one-by-one.</p><p>First 6 bits of decoding:</p><p><tables id=\"TABLE-US-00023\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000001</entry><entry morerows=\"0\" valign=\"top\">ADD</entry><entry morerows=\"0\" valign=\"top\">add</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000011</entry><entry morerows=\"0\" valign=\"top\">OR</entry><entry morerows=\"0\" valign=\"top\">or</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000101</entry><entry morerows=\"0\" valign=\"top\">AND</entry><entry morerows=\"0\" valign=\"top\">and</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000111</entry><entry morerows=\"0\" valign=\"top\">SUB</entry><entry morerows=\"0\" valign=\"top\">subtract</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001001</entry><entry morerows=\"0\" valign=\"top\">XOR</entry><entry morerows=\"0\" valign=\"top\">exclusive or</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001011</entry><entry morerows=\"0\" valign=\"top\">ANDN</entry><entry morerows=\"0\" valign=\"top\">nand</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001101</entry><entry morerows=\"0\" valign=\"top\">XNOR</entry><entry morerows=\"0\" valign=\"top\">exclusive nor</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001111</entry><entry morerows=\"0\" valign=\"top\">CONST</entry><entry morerows=\"0\" valign=\"top\">constant</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000000</entry><entry morerows=\"0\" valign=\"top\">ADDC</entry><entry morerows=\"0\" valign=\"top\">add with carry</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000010</entry><entry morerows=\"0\" valign=\"top\">SUBB</entry><entry morerows=\"0\" valign=\"top\">subtract</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000100</entry><entry morerows=\"0\" valign=\"top\">DFADD</entry><entry morerows=\"0\" valign=\"top\">directional add</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000110</entry><entry morerows=\"0\" valign=\"top\">INT</entry><entry morerows=\"0\" valign=\"top\">interrupt</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001000</entry><entry morerows=\"0\" valign=\"top\">INTO</entry><entry morerows=\"0\" valign=\"top\">interrupt on overflow</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001010</entry><entry morerows=\"0\" valign=\"top\">DIVO</entry><entry morerows=\"0\" valign=\"top\">initial divide step</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001100</entry><entry morerows=\"0\" valign=\"top\">DIV</entry><entry morerows=\"0\" valign=\"top\">divide step</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001110</entry><entry morerows=\"0\" valign=\"top\">DIVL</entry><entry morerows=\"0\" valign=\"top\">last divide step</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010000</entry><entry morerows=\"0\" valign=\"top\">DIVREM</entry><entry morerows=\"0\" valign=\"top\">remainder</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010010</entry><entry morerows=\"0\" valign=\"top\">DIVCMP</entry><entry morerows=\"0\" valign=\"top\">divide compare</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010100</entry><entry morerows=\"0\" valign=\"top\">DIVQ</entry><entry morerows=\"0\" valign=\"top\">quotient</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010110</entry><entry morerows=\"0\" valign=\"top\">IDIVSGN</entry><entry morerows=\"0\" valign=\"top\">signed divide signs</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">011000</entry><entry morerows=\"0\" valign=\"top\">IDIVCMP</entry><entry morerows=\"0\" valign=\"top\">signed divide compare</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">011010</entry><entry morerows=\"0\" valign=\"top\">IDIVDEND0</entry><entry morerows=\"0\" valign=\"top\">signed divide dividend LSW</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">011100</entry><entry morerows=\"0\" valign=\"top\">IDIVDEND1</entry><entry morerows=\"0\" valign=\"top\">signed divide dividend MSW</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">011110</entry><entry morerows=\"0\" valign=\"top\">IDIVSOR</entry><entry morerows=\"0\" valign=\"top\">signed divide divisor</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">011111</entry><entry morerows=\"0\" valign=\"top\">IDIVQ</entry><entry morerows=\"0\" valign=\"top\">signed divide quotient</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100000</entry><entry morerows=\"0\" valign=\"top\">ROL</entry><entry morerows=\"0\" valign=\"top\">rotate left</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100001</entry><entry morerows=\"0\" valign=\"top\">ROR</entry><entry morerows=\"0\" valign=\"top\">rotate right</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100010</entry><entry morerows=\"0\" valign=\"top\">SHL</entry><entry morerows=\"0\" valign=\"top\">shift logical left</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100011</entry><entry morerows=\"0\" valign=\"top\">SHR</entry><entry morerows=\"0\" valign=\"top\">shift logical right</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100100</entry><entry morerows=\"0\" valign=\"top\">SAR</entry><entry morerows=\"0\" valign=\"top\">shift arithmetic right</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100101</entry><entry morerows=\"0\" valign=\"top\">SHLD</entry><entry morerows=\"0\" valign=\"top\">shift left double</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100110</entry><entry morerows=\"0\" valign=\"top\">SHRD</entry><entry morerows=\"0\" valign=\"top\">shift right double</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100111</entry><entry morerows=\"0\" valign=\"top\">SETFC</entry><entry morerows=\"0\" valign=\"top\">set funnel count</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101000</entry><entry morerows=\"0\" valign=\"top\">EXTS8</entry><entry morerows=\"0\" valign=\"top\">sign extend 8 bit operand</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101001</entry><entry morerows=\"0\" valign=\"top\">EXTS16</entry><entry morerows=\"0\" valign=\"top\">sign extend 16 bit operand</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101100</entry><entry morerows=\"0\" valign=\"top\">MTFLAGS</entry><entry morerows=\"0\" valign=\"top\">store AH into flags</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101101</entry><entry morerows=\"0\" valign=\"top\">CONSTHZ</entry><entry morerows=\"0\" valign=\"top\">move lower constant into</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">upper, zero lower</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101110</entry><entry morerows=\"0\" valign=\"top\">BTEST</entry><entry morerows=\"0\" valign=\"top\">bit test</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101111</entry><entry morerows=\"0\" valign=\"top\">BTESTS</entry><entry morerows=\"0\" valign=\"top\">bit test and set</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110000</entry><entry morerows=\"0\" valign=\"top\">BTESTR</entry><entry morerows=\"0\" valign=\"top\">bit test and reset</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110001</entry><entry morerows=\"0\" valign=\"top\">BTESTC</entry><entry morerows=\"0\" valign=\"top\">bit test and compliment</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110010</entry><entry morerows=\"0\" valign=\"top\">BSF</entry><entry morerows=\"0\" valign=\"top\">bit scan forward</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110011</entry><entry morerows=\"0\" valign=\"top\">BSR</entry><entry morerows=\"0\" valign=\"top\">bit scan reverse</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110100</entry><entry morerows=\"0\" valign=\"top\">BSWAP</entry><entry morerows=\"0\" valign=\"top\">byte swap</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110101</entry><entry morerows=\"0\" valign=\"top\">SHRDM</entry><entry morerows=\"0\" valign=\"top\">shift right double</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">microcode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110110</entry><entry morerows=\"0\" valign=\"top\">RC0</entry><entry morerows=\"0\" valign=\"top\">initialize rotate carry</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110111</entry><entry morerows=\"0\" valign=\"top\">RCL</entry><entry morerows=\"0\" valign=\"top\">rotate carry left by 1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111000</entry><entry morerows=\"0\" valign=\"top\">RCR</entry><entry morerows=\"0\" valign=\"top\">rotate carry right by 1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111001</entry><entry morerows=\"0\" valign=\"top\">MTSRRES</entry><entry morerows=\"0\" valign=\"top\">move to special register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">over result bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111010</entry><entry morerows=\"0\" valign=\"top\">MESRRES</entry><entry morerows=\"0\" valign=\"top\">move from special register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">over result bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111011</entry><entry morerows=\"0\" valign=\"top\">MTSRSRB</entry><entry morerows=\"0\" valign=\"top\">move to special register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">over SRB bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111100</entry><entry morerows=\"0\" valign=\"top\">MFSRSRB</entry><entry morerows=\"0\" valign=\"top\">move from special register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">over SRB bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111101</entry><entry morerows=\"0\" valign=\"top\">MTARSRB</entry><entry morerows=\"0\" valign=\"top\">move to cache array over</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SRB bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111110</entry><entry morerows=\"0\" valign=\"top\">MFARSRB</entry><entry morerows=\"0\" valign=\"top\">move from cache array over</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SRB bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Second 6 bits of decoding:</p><p><tables id=\"TABLE-US-00024\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000000</entry><entry morerows=\"0\" valign=\"top\">JMPB</entry><entry morerows=\"0\" valign=\"top\">jump if below CF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000001</entry><entry morerows=\"0\" valign=\"top\">JMPNB</entry><entry morerows=\"0\" valign=\"top\">jump if not below CF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000010</entry><entry morerows=\"0\" valign=\"top\">JMPA</entry><entry morerows=\"0\" valign=\"top\">jump if above CF=0 &amp; ZF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000011</entry><entry morerows=\"0\" valign=\"top\">JMPNA</entry><entry morerows=\"0\" valign=\"top\">jump if not above CF=1 or</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ZF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000100</entry><entry morerows=\"0\" valign=\"top\">JMPO</entry><entry morerows=\"0\" valign=\"top\">jump if overflow OF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000101</entry><entry morerows=\"0\" valign=\"top\">JMPNO</entry><entry morerows=\"0\" valign=\"top\">jump if not overflow OF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000110</entry><entry morerows=\"0\" valign=\"top\">JMPZ</entry><entry morerows=\"0\" valign=\"top\">jump if zero ZF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000111</entry><entry morerows=\"0\" valign=\"top\">JMPNZ</entry><entry morerows=\"0\" valign=\"top\">jump if not zero ZF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001000</entry><entry morerows=\"0\" valign=\"top\">JMPS</entry><entry morerows=\"0\" valign=\"top\">jump if sign SF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001001</entry><entry morerows=\"0\" valign=\"top\">JMPNS</entry><entry morerows=\"0\" valign=\"top\">jump if not sign SF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001010</entry><entry morerows=\"0\" valign=\"top\">JMPP</entry><entry morerows=\"0\" valign=\"top\">jump if parity PF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001011</entry><entry morerows=\"0\" valign=\"top\">JMPNP</entry><entry morerows=\"0\" valign=\"top\">jump if not parity PF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001100</entry><entry morerows=\"0\" valign=\"top\">JMPL</entry><entry morerows=\"0\" valign=\"top\">jump if less SF&lt;&gt;OF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001101</entry><entry morerows=\"0\" valign=\"top\">JMPGE</entry><entry morerows=\"0\" valign=\"top\">jump if greater or equal</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SF=OF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001110</entry><entry morerows=\"0\" valign=\"top\">JMPLE</entry><entry morerows=\"0\" valign=\"top\">jump if less or equal</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SF&lt;&gt;OF or ZF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001111</entry><entry morerows=\"0\" valign=\"top\">JMPG</entry><entry morerows=\"0\" valign=\"top\">jump if greater SF=OF and</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ZF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010000</entry><entry morerows=\"0\" valign=\"top\">SETB</entry><entry morerows=\"0\" valign=\"top\">set if below CF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010001</entry><entry morerows=\"0\" valign=\"top\">SETNB</entry><entry morerows=\"0\" valign=\"top\">set if not below CF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010010</entry><entry morerows=\"0\" valign=\"top\">SETA</entry><entry morerows=\"0\" valign=\"top\">set if above CF=0 &amp; ZF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010011</entry><entry morerows=\"0\" valign=\"top\">SETNA</entry><entry morerows=\"0\" valign=\"top\">set if not above CF=1 or</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ZF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010100</entry><entry morerows=\"0\" valign=\"top\">SETO</entry><entry morerows=\"0\" valign=\"top\">set if overflow OF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010101</entry><entry morerows=\"0\" valign=\"top\">SETNO</entry><entry morerows=\"0\" valign=\"top\">set if not overflow OF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010110</entry><entry morerows=\"0\" valign=\"top\">SETZ</entry><entry morerows=\"0\" valign=\"top\">set if zero ZF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010111</entry><entry morerows=\"0\" valign=\"top\">SETNZ</entry><entry morerows=\"0\" valign=\"top\">set if not zero ZF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010000</entry><entry morerows=\"0\" valign=\"top\">SETS</entry><entry morerows=\"0\" valign=\"top\">set if sign SF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">011001</entry><entry morerows=\"0\" valign=\"top\">SETNS</entry><entry morerows=\"0\" valign=\"top\">set if not sign SF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">011010</entry><entry morerows=\"0\" valign=\"top\">SETP</entry><entry morerows=\"0\" valign=\"top\">set if parity PF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">011011</entry><entry morerows=\"0\" valign=\"top\">SETNP</entry><entry morerows=\"0\" valign=\"top\">set if not parity PF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">011100</entry><entry morerows=\"0\" valign=\"top\">SETL</entry><entry morerows=\"0\" valign=\"top\">set if less SF&lt;&gt;OF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">011101</entry><entry morerows=\"0\" valign=\"top\">SETGE</entry><entry morerows=\"0\" valign=\"top\">set if greater or equal</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SF=OF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">011110</entry><entry morerows=\"0\" valign=\"top\">SETLE</entry><entry morerows=\"0\" valign=\"top\">set if less or equal SF&lt;&gt;OF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">or ZF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">011111</entry><entry morerows=\"0\" valign=\"top\">SETG</entry><entry morerows=\"0\" valign=\"top\">set if greater SF=OF and</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ZF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100000</entry><entry morerows=\"0\" valign=\"top\">SELB</entry><entry morerows=\"0\" valign=\"top\">move if below CF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100001</entry><entry morerows=\"0\" valign=\"top\">SELNB</entry><entry morerows=\"0\" valign=\"top\">move if not below CF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100010</entry><entry morerows=\"0\" valign=\"top\">SELA</entry><entry morerows=\"0\" valign=\"top\">move if above CF=0 &amp; ZF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100011</entry><entry morerows=\"0\" valign=\"top\">SELNA</entry><entry morerows=\"0\" valign=\"top\">move if not above CF=1 or</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ZF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100100</entry><entry morerows=\"0\" valign=\"top\">SELO</entry><entry morerows=\"0\" valign=\"top\">move if overflow OF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100101</entry><entry morerows=\"0\" valign=\"top\">SELNO</entry><entry morerows=\"0\" valign=\"top\">move if not overflow OF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100110</entry><entry morerows=\"0\" valign=\"top\">SELZ</entry><entry morerows=\"0\" valign=\"top\">move if zero ZF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100111</entry><entry morerows=\"0\" valign=\"top\">SELNZ</entry><entry morerows=\"0\" valign=\"top\">move if not zero ZF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101000</entry><entry morerows=\"0\" valign=\"top\">SELS</entry><entry morerows=\"0\" valign=\"top\">move if sign SF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101001</entry><entry morerows=\"0\" valign=\"top\">SELNS</entry><entry morerows=\"0\" valign=\"top\">move if not sign SF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101010</entry><entry morerows=\"0\" valign=\"top\">SELP</entry><entry morerows=\"0\" valign=\"top\">move if parity PF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101011</entry><entry morerows=\"0\" valign=\"top\">SELNP</entry><entry morerows=\"0\" valign=\"top\">move if not parity PF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101100</entry><entry morerows=\"0\" valign=\"top\">SELL</entry><entry morerows=\"0\" valign=\"top\">move if less SF&lt;&gt;OF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101101</entry><entry morerows=\"0\" valign=\"top\">SELGE</entry><entry morerows=\"0\" valign=\"top\">move if greater or equal</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SF=OF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101110</entry><entry morerows=\"0\" valign=\"top\">SELLE</entry><entry morerows=\"0\" valign=\"top\">move if less or equal</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SF&lt;&gt;OF or ZF=1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101111</entry><entry morerows=\"0\" valign=\"top\">SELG</entry><entry morerows=\"0\" valign=\"top\">move if greater SF=OF and</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ZF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110001</entry><entry morerows=\"0\" valign=\"top\">CONSTPC</entry><entry morerows=\"0\" valign=\"top\">move frorn EIP over DPC</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110010</entry><entry morerows=\"0\" valign=\"top\">JMP</entry><entry morerows=\"0\" valign=\"top\">relative jump</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110011</entry><entry morerows=\"0\" valign=\"top\">JMPI</entry><entry morerows=\"0\" valign=\"top\">absolute jump</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110100</entry><entry morerows=\"0\" valign=\"top\">JMPNU</entry><entry morerows=\"0\" valign=\"top\">absolute jump, no</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">prediction update</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110101</entry><entry morerows=\"0\" valign=\"top\">JMPIFAR</entry><entry morerows=\"0\" valign=\"top\">absolute far jump</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110110</entry><entry morerows=\"0\" valign=\"top\">JMPRZ</entry><entry morerows=\"0\" valign=\"top\">jump if A_OP == 0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110111</entry><entry morerows=\"0\" valign=\"top\">JMPNRZ</entry><entry morerows=\"0\" valign=\"top\">jump if A_OP != 0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111000</entry><entry morerows=\"0\" valign=\"top\">JMPNRZZ</entry><entry morerows=\"0\" valign=\"top\">jump if A_OP != 0 &amp; ZF==1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111001</entry><entry morerows=\"0\" valign=\"top\">JMPNRZNZ</entry><entry morerows=\"0\" valign=\"top\">jump if A_OP != 0 &amp; ZF==0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111010</entry><entry morerows=\"0\" valign=\"top\">JMPRS</entry><entry morerows=\"0\" valign=\"top\">jump if A_OP msb==1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111011</entry><entry morerows=\"0\" valign=\"top\">JMPRNS</entry><entry morerows=\"0\" valign=\"top\">jump if A_OP msb==0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111101</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>One exception in the above decoding is the reversed subtract which would be sent as subtract instruction. The MROM instruction will try to use the X86 opcode format. Some operations are not possible in the fast-path instructions such as floating point, string, integer divide, special register, and processor control. These MROM instructions will have different opcodes which need to be recognized by Idecode.</p><p>Signal List</p><p>ICPREF(<b>7</b>:<b>0</b>)\u2014Input from Icache and MROM indicates the encoded prefix byte. The two most significant bits are repeat prefixes for MROM.</p><p>IC<b>2</b>ROPn(<b>9</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates 2-dispatch positions instruction. Bit <b>3</b> indicates the first rop or second rop of the 2-dispatch positions instruction, bit <b>2</b> indicates POP instruction, bit <b>1</b> indicates the MUL instruction, and bit <b>0</b> indicates the SIB-byte instruction.</p><p>ICVALI(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates valid instructions. NOOP is generated for invalid instruction.</p><p>ICnOPC(<b>7</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the opcode byte.</p><p>ICnEOP(<b>2</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the extended opcode field.</p><p>PROTOCOLn(<b>3</b>:<b>0</b>)</p><p>OPCTLn(<b>5</b>:<b>0</b>)</p><p>PGALUn(<b>6</b>:<b>0</b>)\u2014Output indicates the type of instructions being dispatched, this is the decoded information for the functional units to execute.</p><p>Decoding for Registers and Flags</p><p>The opcode should also be decoded for the immediate field, the validation and direction of the operands to the FIROB and the register file. The decoding of the register direction and validation should be less than 1 clock cycle. During fetching, the register operands are speculatively decoded and sent to the FIROB for dependency checking. The FIROB's dependency checking may be in a critical speed path, and the decoding of the register direction and validation may be implemented in the early decoding in the Icache. Two register operands are sent to the FIROB. The Idecode sends the operand data to the functional units in the correct order of A and B. The A operand is the first operand which can be both destination and source. The B operand is the second operand which is source data. The immediate field co-exists with the B operand on three instructions, IMUL, SHLD, and SHRD. SHLD and SHRD are MROM instructions which will be sent as shifting one bit at a time. The exception is with the IMUL instruction. The first operand is only for destination which is not needed by the functional unit. The second operand will be sent on the A operand and immediate is on B operand. The data and address sizes and the sign-extended information for all operands and immediate data must also be decoded in this block. Data from Idecode is arranged on three 32-bit buses and one constant bus to the functional units:</p><p><tables id=\"TABLE-US-00025\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"112PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">From Idecode</entry><entry morerows=\"0\" valign=\"top\">To Functional Unit</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">First operand</entry><entry morerows=\"0\" valign=\"top\">32-bit A operand bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Second operand (not IMUL)</entry><entry morerows=\"0\" valign=\"top\">32-bit B operand bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Second operand - IMUL</entry><entry morerows=\"0\" valign=\"top\">32-bit A operand bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Immediate</entry><entry morerows=\"0\" valign=\"top\">32-bit B operand bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Predicted Branch Target</entry><entry morerows=\"0\" valign=\"top\">32-bit A operand bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EIP/second operand</entry><entry morerows=\"0\" valign=\"top\">32-bit B operand bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Displacement</entry><entry morerows=\"0\" valign=\"top\">32-bit Displacement bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Constant</entry><entry morerows=\"0\" valign=\"top\">4-bit Constant bus</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>For branch instructions, the target PC is sent on A operand bus because it is possible to have the immediate field (RETURN instructions) and displacement field. All predicted taken branch instructions have indication and branch tag to keep in the FIROB. Few non-taken branch instructions are not detected in branch prediction, the FIROB keeps track of the sequential PC.</p><p>This block also decodes the load/store, special register, and floating point operations, and serialization which are needed global control of the decode units.</p><p>Signal List</p><p>ICBTAG<b>1</b>(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates the position of the first target branch instruction with respect to the global shift register in case of branch mis-prediction. The branch can be taken or non-taken, branch tag must be sent with all branch instruction.</p><p>ICBTAG<b>2</b>(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates the position of the second target branch instruction with respect to the global shift register in case of branch mis-prediction. The branch can be taken or non-taken, branch tag must be sent with all branch instruction.</p><p>UNJMP(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates the unconditional branch instruction needs to calculate target address.</p><p>BRNTKN(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates which decode unit has a predicted taken branch. The operand steering uses this signal to latch and send BTADDR(<b>31</b>:<b>0</b>) to the functional unit.</p><p>BRNINST(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates which decode unit has a global branch prediction. The operand steering uses this signal to latch and send ICBTAG<b>1</b>(<b>3</b>:<b>0</b>) and ICBTAG<b>2</b>(<b>3</b>:<b>0</b>) to the functional units.</p><p>IB<b>2</b>(<b>191</b>:<b>0</b>)\u2014Input from Icache indicates the combined instruction line for reading the displacement and immediate field using pointers.</p><p>ICVALI(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates valid instructions. NOOP is generated for invalid instruction.</p><p>ICnOPC(<b>7</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the opcode byte.</p><p>ICnEOP(<b>2</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the extended opcode field.</p><p>ICnSS(<b>1</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the scale factor of the SIB byte.</p><p>DISPTRn(<b>6</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, bit <b>6</b>:<b>5</b> is the size, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Bit <b>6</b>:<b>5</b>=00 indicates no displacement.</p><p>IMMPTRn(<b>4</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Decoding of all opcodes is needed to detect immediate field.</p><p>CONSTn(<b>2</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the constant for add/substract to ESP of the two-dispatch position instruction.</p><p>ICPC<b>1</b>TAR\u2014Input from Icache indicates is ICPC<b>1</b> a branch target of a previous instruction which is a predicted taken branch instruction.</p><p>ICPC<b>2</b>TAR\u2014Input from Icache indicates is ICPC<b>2</b> a branch target of a previous instruction which is a predicted taken branch instruction.</p><p>ICPC<b>1</b>(<b>31</b>:<b>0</b>)\u2014Input from Icache indicates the current line PC of the first instruction in the 4 issued instructions to pass along with the instruction to FIROB.</p><p>ICPC<b>2</b>(<b>31</b>:<b>0</b>)\u2014Input from Icache indicates the current line PC of a second instruction which cross the 16-byte boundary or branch target in the 4 issued instructions to pass along with the instruction to FIROB.</p><p>ICPOSn(<b>4</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the PC's byte position of the next instruction. Bit <b>4</b> indicates the next instruction is on the next line.</p><p>IDxIMM(<b>2</b>:<b>0</b>)\u2014Output to indicates the immediate size information. 01- byte, 10-half word, 11-word, 00-not used. Bit <b>2</b> indicates (0) zero or (1) sign extend.</p><p>IDxDAT(<b>1</b>:<b>0</b>)\u2014Output to indicates the data size information. 01- byte, 10-half word, 11-word, 00-not used.</p><p>IDxADDR\u2014Output to indicates the address size information. 1-32 bit, 0-16 bit.</p><p>DxUSE<b>1</b>(<b>1</b>:<b>0</b>)\u2014Output to FIROB and register file indicates the type of operand being sent on operand <b>1</b> for decode units. Bit <b>1</b> indicates source operand, and bit <b>0</b> indicates destination operand.</p><p>DxUSE<b>2</b>\u2014Output to FIROB and register file indicates source operand.</p><p>INSDISP(<b>3</b>:<b>0</b>)\u2014Indicates that the instruction in decode unit is valid, if invalid, NOOP is passed to FIROB.</p><p>Segment Register and Special Control</p><p>In general, writing to special registers and cache array causes serialization after dispatching of the instruction. Reading of special register and cache array does not cause serialization. Cache array access is from MROM instructions for testing and debugging purposes. Most special register access is also from MROM instructions; few MOVE instructions specify the special register directly. Serialization is a major degradation in performance. Implementation of a special register buffer in the load/store section reduces the serialization as will be discussed in a later section. For special register access, the destination register of the instruction is the indication of special register (not a real register in the register file), the special register address and control information are encoded in the immediate field of the MROM instruction. The functional unit will pass the immediate field directly to the special register buffer. The immediate field is decoded in the special register to generate read/write to the appropriate special register or cache array. Fast-path instruction which read/write to the special register must provide the same format in the immediate field as the MROM to the functional unit.</p><p>The prefix of the instruction is decoded during fetching. The segment register override is encoded as a prefix byte. The MROM instruction provides the ES reference for the string operation. All accesses to segment registers must be detected in decoding to generate controls to the load/store section. The percentage of writing to some segment register is significant to the performance of Processor <b>500</b>. To further reduce the penalty of serialization due to the writing of segment registers, control signals and dependency status-bits are generated. In the next section, a detailed implementation of this technique is discussed.</p><p>The floating point unit is implemented as a co-processor. The MROM provides the same format for the floating point instructions in 4 issue positions. The first three issue positions are for the possible 80-bit load/store access of the floating point instructions. For 32-bit or 64-bit floating point operations, the issue position is filled with NOOP. The last issue position is the actual opcode of the floating point instruction. The floating point opcode is in the immediate field of the MROM instruction. Idecode treats the floating point instruction as a special register instruction; the immediate field is passed from special register block to the floating point unit. The floating point unit latches and loads data from the LSSEC and send the store data through the functional unit to the LSSEC.</p><p>Special-Register Instructions</p><p>There are two types of special-register (SR) instructions. One is for testing/debugging purpose, and the other is for normal execution. The testing/debugging SR instructions are for the cache arrays, it is not important to speed up these instructions. Implementation of the serialized instruction is as followed:</p><p>SR instructions can be issued from any dispatch position.</p><p>The SR address is sent to the functional unit in the Immediate field.</p><p>Read from SR instructions are not serialized.</p><p>Up to 4 SR instructions can be in execute. The load/store special register (LSR) buffer has 4 entries. The LSR buffer is global to both the SRB and LSR. Idecode will communicates with the LSR to allocate an entry when a SR instruction is dispatched. This is the same implementation as with the load/store buffer.</p><p>Write to SRs except to DS, GS, ES, and FS are serialized. The serialization is to dispatch the write to SR instruction, stall all other instructions, and wait for LSR to notify the completion of the instruction. The write to LSR instruction must execute in program order (same as STORE instructions)</p><p>Write to DS, GS, ES, and FS instruction sets a dependency bit for each of the four segment register when dispatching. Four global WRxS signals to all functional units indicate the write to the segment register is outstanding. The LSR will reset the dependency bit and clear WRxS from execution of the write to SR instruction. Any read to DS/GS/ES/FS instruction after the write will have a status read dependency bit (RD_DEP_xS). Instructions with RD_DEP_xS set, must wait in reservation station until WRxS is cleared. The read to GS/ES/FS instruction includes (1) Prefix segment override, (2) Move from segment register, and (3) String operation (ES only). The string operation will have indication from MROM. A second write to segment register with WRxS set, must stall in decode.</p><p>Signal List</p><p>IMMPTRn(<b>4</b>:<b>0</b>)\u2014Input from Icache to decode unit n indicates the displacement pointer and size. Bits <b>2</b>:<b>0</b> is the pointer to the 8-byte block, and bit <b>4</b>:<b>3</b> indicates which 8-byte block. Decoding of all opcodes is needed to detect immediate field.</p><p>MROMEN\u2014Input from MROM indicates the micro-instructions is sent to Idecode instead of the Icache.</p><p>IDxIMM(<b>2</b>:<b>0</b>)\u2014Output to indicates the immediate size information. 01- byte, 10-half word, 11-word, 00-not use. Bit <b>2</b> indicates (<b>0</b>) zero or (<b>1</b>) sign extend.</p><p>INSLSxB(<b>5</b>:<b>0</b>)\u2014Output from decode units indicates the prefix values. bit <b>5</b>\u2014data size, bit <b>4</b>\u2014address size, bit <b>3</b>\u2014lock, bit <b>2</b>:<b>0</b>\u2014segment registers.</p><p>Global Control of Decode Units</p><p>The decode units, can decode instructions, generate operand addresses, and dispatch to the functional units independent from each other. There are a few exceptions where global control is needed. With the extra pipeline stage before the alignment, some decoding of the instructions is done before sending to the decode units. Early decoding includes MROM instruction, SIB-byte instruction, 2-dispatch position instructions, multi-prefix instruction, and branch taken instructions. During decoding, partial dispatching of a line can happen for serialization, dependency, and move-to-special-register. Conditions to halt the line of instructions before dispatching to the functional units in the next ICLK are the reservation stations full, the FIROB full, and the Load/Store buffer full. These halt conditions will stop the pipeline in the decoder from advancing. For serialization, the instructions can occupy the entries in the FIROB and wait for ROBEMPTY to dispatch the instructions to functional units. Most of the serialization conditions is provided by the MENG, few serialized instructions must be decoded from fast-path instructions. The two clock cycle in decode units are pipelined, the appropriate pipeline control such as HOLD and REFRESH are needed for the decode units and Icache.</p><p>Stalling and Partially Dispatching of Instructions</p><p>Each stage of the pipeline has a latch and the instructions can be refreshed. In the first stage, the stalling conditions for the operand pointers and instructions from Icache to decode units are:</p><p>If the FIROB is full, the decoding is stalled until the FIROB can accept another line of instruction.</p><p>In the next stage, the line in the FIROB must be allocated, the stalling conditions for the operand data to remain on the buses are:</p><p>If there is a narrow-to-wide dependency; i.e. the read operand is 32-bit and the previous destination operand is 8-bit, the decoding is stalled until the FIROB retires the previous destination entry. Instructions may be partially dispatched, the FIROB invalidates instructions from the narrow-to-wide dependency. The Idecode invalidates instructions before the narrow-to-wide dependency and re-issues the instructions to FIROB. A similar procedure is needed for the second group of flag dependency checking.</p><p>Dependency is detected for the third group of flags. If the load/store buffer is full, the decoding is stalled until the load/store buffer is available. Partial line dispatching can be done instead of stalling the whole line. This will be discussed in a later section.</p><p>If the special register buffer is full, the decoding is stalled until the load/store buffer is available. This was discussed in an earlier section.</p><p>Decoding is stalled on write to special registers and cache array except for write to DS, ES, FS, and GS. This was discussed in an earlier section.</p><p>If any set of reservation stations is full, the decoding is stalled until the reservation station is available.</p><p>Serialized instructions.</p><p>Instruction Serialization</p><p>Serialization is controlled by MROM and the decode units. On some processors, the ROB must be empty before the instructions can be dispatched from the decode units, and the ROB must be empty again before the next instruction can be dispatched. The cost is about 6 cycles to execute a single instruction. The performance degrades tremendously by serialization. On Processor <b>500</b>, serialization will be minimized, most frequent serialization instructions will be in the fast path. The serialization can be categorized into serialized instructions, exception instructions, break-point instructions, and special register instructions.</p><p>Serialized instructions which must be handled by the decode units:</p><p>INVD\u2014Dispatch the instruction to invalidate the data/instruction cache and wait for the FIROB re-fetch the next instruction.</p><p>HALT\u2014Dispatch the instruction to the FIROB and wait for interrupt.</p><p>WAIT\u2014Dispatch the instruction to the FIROB and wait.</p><p>Instruction Breakpoints and Tracing</p><p>When enabled, instruction breakpoint check instructions are inserted before each instruction by the decode unit. A hardwired input to dispatch position zero is serially dispatched before every instruction. The breakpoint instructions go to the LSSEC to check for breakpoint.</p><p>Handling of Load/Store Instructions</p><p>The load/store section implements a finite size load/store buffer. There would be cases that the buffer is full and creates a stall in functional units. To avoid stalling in the functional units, the decode will not dispatch the current line of instructions if there is not enough space in the load/store buffer to handle the load/store instructions of the current line. The decode units have more time to make this decision than the functional units.</p><p>At dispatch, the decode units send the load/store information to the load/store section. The information includes the current FIROB line, data dependency tags, and load/store type LSTYPE(<b>1</b>:<b>0</b>):</p><p>00: No load/store</p><p>01: Load operation</p><p>10: Store operation</p><p>11: Both Load and Store operations</p><p>If the instruction has a memory reference, then the load/store type should be set. The linear address and/or data will be sent to the load/store buffer from the functional units or reservation station at a later time. The load/store buffer allocates entries for the dispatched instructions. The store operation should get a slot in the load/store buffer and the load instruction increases a counter to keep track of the number of load in the executing stage. A 3-bit count is sent to the decode units to indicate the number of empty entries in the load/store buffer. The decode units will dispatch a line of instructions only if the number of load/store instructions in the line is less than or equal to the empty entries in the load/store buffer.</p><p>Signal List</p><p>LSCNT(<b>2</b>:<b>0</b>)\u2014Input from LSSEC indicates the number of empty entries in the load/store buffer.</p><p>RSFULL\u2014Input from functional units indicates that the reservation stations are full. This signal is the OR of the 6 functional units</p><p>ROBFULL\u2014Input from FIROB indicates the FIROB is full.</p><p>REFRESH<b>2</b>\u2014Output indicates that the operand pointer to the register file and the FIROB will be refreshed and not accept new operand.</p><p>REFRESH<b>1</b>\u2014Output indicates current line of instructions will be refreshed and not accept new instructions from Icache.</p><p>IDPREF(<b>5</b>:<b>0</b>)\u2014Output from 2-cycle prefix decode to decode units indicates the prefix values. bit <b>5</b>\u2014data size, bit <b>4</b>\u2014address size, bit <b>3</b>\u2014lock, bit <b>2</b>:<b>0</b>\u2014segment registers.</p><p>IDSIB(<b>3</b>:<b>0</b>)\u2014Output to FIROB indicates which decode unit has the SIB-byte instruction. The FIROB should generate dependency on the previous instruction of the last line in the same issue position.</p><p>Timing</p><p>The Idecode has 2 pipeline stages:</p><p>first stage: Decode instruction opcode for functional units. Decode register direction and validation for operands to dispatch to functional units. Dependency checking in the FIROB.</p><p>second stage: Operand steering for tags and operand data to the functional units. Complete decoding for instruction and send to functional units.</p><p>Layout</p><p>The Idecode includes six decode unit blocks. The decode unit <b>0</b> and <b>6</b> are slightly different because of passing part of the instruction from different lines. The global blocks are: MROM interface unit, the prefix decoding and control for 2-cycle Processor <b>500</b> fast-path instructions, the return stack and controls for branch instructions, and global decoding controls. The MROM interface unit includes global registers accessible by MROM instruction. FIG. 28 is a block diagram of the IDECODE layout.</p><p>Dispatch and Issue Logic</p><p>For this section, dispatch means sending a new set of up to four pseudo-opcodes with their tags and operands to the operand steering unit and then to the reservation station. Issue means sending the source operands to the FNCU for execution. The term pseudo-opcode is used since fast path x86 instructions are sent as either one or two side by side pseudo-opcodes. Each pseudo-opcode is further sub-divided into two vectors (a type of mini-opcode). Both vectors have access to the same four data busses {Aop(<b>31</b>:<b>0</b>), Bop(<b>31</b>:<b>0</b>), Disp(<b>31</b>:<b>0</b>), and Const(<b>3</b>:<b>0</b>)} but use the data differently depending on which reservation station protocol that the reservation station entry has. There are a total of three reservation station entries. Every pseudo-opcode is one dispatch position that carries an identification or DTAG denoted by the FIROB line number and entry number that will become its destination. Only the FIROB line number needs to be carried around since the entry number will correspond to a fixed dispatch position from <b>0</b> to <b>3</b>. DTAG (destination tags) can only be <b>0</b>_<b>0</b> to <b>5</b>_<b>3</b> which represents four dispatch positions and six FIROB lines.</p><p>Allocation and Dispatch</p><p>Once the opcode has been dispatched to a reservation station (station <b>0</b>, <b>1</b>, or <b>2</b>), the station then watches the result bus tags for the remaining operands that will be forwarded to it. Issue from the reservation stations to the functional units can be done out of order on Processor <b>500</b>. The oldest opcode (in program order) which has all of its operands will be issued to the functional unit and the functional unit cannot stall. The decoder/dispatcher communicates with the FPU, LSSEC, and SRB, and FIROB and will stall if a new opcode( ready to be dispatched) has no place to go. As an example, when all six FIROB lines are allocated or when all eight LSSEC entries are allocated, the dispatcher must stall.</p><p>Opcodes, tags, and operands for the reservation stations are always dispatched into RS<b>2</b>. Issue to the functional unit can then come from RS<b>2</b>, RS<b>1</b>, or RS<b>0</b>. When a another opcode is dispatched into RS<b>2</b>, the previous opcode in RS<b>2</b> is shifted down to RS<b>1</b>. If an opcode was in RS<b>1</b>, it would in turn be shifted to RS<b>0</b>.</p><p>Reservation Station Sub-Blocks</p><p>The reservation station logic (per dispatch/issue position) is divided into a control sub-block named RSCTL and three reservation stations named RS<b>2</b>, RS<b>1</b>, and RS<b>0</b>. Opcodes, tags, and operands are only dispatched to RS<b>2</b>, while any of the reservation stations can issue to the FNCU. If an operation gets all of its operands from the REGF and FIROB data section and has no higher priority requests in the reservation stations before it, it can go from the operand steering section directly to the FNCU for evaluation; otherwise, the operation waits in the reservation station until its operands are forwarded to it. The entry being issued to the FNCU is driven on a set of tristate busses. Another set of tristate busses is used by the Multiplier for source operands. These tristate busses (SAOPND and SBOPND) are shared by all four reservation block positions, and a multiplier request/grant protocol determines which position drives them.</p><p>The RSCTL decides which operations end up in which reservation stations. A set of operands will stay in their current reservation station entry unless they are shifted to the next entry or sent to the FNCU for evaluation. No attempt is made to keep all operations pushed up against one side or the other of the reservation station chain. A block diagram of reservation station logic is shown as FIG. 29. A timing diagram for the reservation stations is shown as FIG. <b>30</b>.</p><p>Reservation Station Protocols</p><p>Various protocols are used to indicate how the reservation station should use the two vectors stored in the VCBS (vector control-bit store) section of the FNCU and which operands are needed.</p><p>Protocol Definitions</p><p>OP\u2014operation only valid</p><p>(v<b>0</b>: na {<b>0</b>}; v<b>1</b>: operation {F})</p><p>TOP\u2014two opcode are fully supplied (not used by uCode) (fast path only)</p><p>(v<b>0</b>: decode supplied; v<b>1</b>: decode supplied)</p><p>V<b>12</b>\u2014v<b>0</b> fwd to v<b>1</b></p><p>(v<b>0</b>: Bop+const {I}; v<b>1</b>: operation {F)})</p><p>LO\u2014Load-Operation</p><p>(v<b>0</b>: Bop+disp {Lw}; v<b>1</b>: operation {F})</p><p>after v<b>0</b>, BTAG=DTAG</p><p>LOS\u2014Load-OP-Store</p><p>(v<b>0</b>: Aop+disp {Lw}; v<b>1</b>: op &amp; store {M})</p><p>after v<b>0</b>, BTAG=DTAG</p><p>OS\u2014op-store</p><p>(v<b>0</b>: Aop+disp {L}; v<b>1</b>: op &amp; store {M})</p><p>SRB\u2014SRB info</p><p>(v<b>0</b>: na {<b>0</b>}; v<b>1</b>:pass Bop {S})</p><p>FLA\u2014fpu linear adr</p><p>(v<b>0</b>: Bop+disp {I}; v<b>1</b>: fwd+const {L})</p><p>unlike regular linear adr calc; this one immediately clears the resv_sta entry</p><p>BRN\u2014Branch eval</p><p>(v<b>0</b>: na {<b>0</b>}; v<b>1</b>: operation,brn eval {B})</p><p>LBR\u2014Load-brn (RET)</p><p>(v<b>0</b>: Aop+disp {Lw}; v<b>1</b>: operation,brn eval {B})</p><p>SIB\u20141st pos SIB</p><p>(v<b>0</b>: Aop+scaled(Bop) {F}; v<b>1</b>: na {<b>0</b>})</p><p>PU\u2014Push</p><p>(v<b>0</b>: Aop-const {L,F} v<b>1</b>: op &amp; store {M})</p><p>POP\u2014Pop</p><p>(v<b>0</b>: Aop+const {F} v<b>1</b>: na {<b>0</b>})</p><p>DIV \u2014vector<b>0</b> or vector<b>1</b></p><p>(v<b>0</b>: ADD {F}; v<b>1</b>: SUB {F})</p><p>The following letters indicate which blocks should latch data off the RES bus (enclosed in { }):</p><p><b>0</b> (nothing)</p><p>F (FIROB or FNCU forwarding)</p><p>L (linear address for store)</p><p>Lw (linear address for load; Res_sta changes Bop=DTAG and waits)</p><p>M (memory data for store only)</p><p>S (SRB)</p><p>B (Branch eval info for FIROB)</p><p>I (intermediate value; ignored for forwarding except for same Res sta)</p><p>Summary of How Protocols Apply to Various Instructions</p><p><tables id=\"TABLE-US-00026\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"56PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">dispatch positions</entry><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"112PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1st pos</entry><entry morerows=\"0\" valign=\"top\">2nd pos</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"7PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"91PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">regular operation</entry><entry morerows=\"0\" valign=\"top\">OP</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">regular op w/ imm</entry><entry morerows=\"0\" valign=\"top\">OP</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">Load-op</entry><entry morerows=\"0\" valign=\"top\">LO</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">OP-store</entry><entry morerows=\"0\" valign=\"top\">OS</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">Load-op-store</entry><entry morerows=\"0\" valign=\"top\">LOS</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">SIB w/ Load-op</entry><entry morerows=\"0\" valign=\"top\">SIB</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">LO</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">SIB w/ OP-store</entry><entry morerows=\"0\" valign=\"top\">SIB</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">OS</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">SIB w/ L-O-S</entry><entry morerows=\"0\" valign=\"top\">SIB</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">LOS</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">divide opcode</entry><entry morerows=\"0\" valign=\"top\">DIV</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">FPU linear adr</entry><entry morerows=\"0\" valign=\"top\">FLA</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">Jcc</entry><entry morerows=\"0\" valign=\"top\">BRN</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">JMP nr disp rel</entry><entry morerows=\"0\" valign=\"top\">BRN</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">JMP nr reg indr</entry><entry morerows=\"0\" valign=\"top\">BRN</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">JMP nr mem indr</entry><entry morerows=\"0\" valign=\"top\">LBR</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">PUSH reg</entry><entry morerows=\"0\" valign=\"top\">PU</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">PUSH mem</entry><entry morerows=\"0\" valign=\"top\">LO</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">PU</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">PUSH mem w/SIB</entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\">PUSHF</entry><entry morerows=\"0\" valign=\"top\">Pu</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">; using MOVF</entry></row><row><entry morerows=\"0\" valign=\"top\">PUSHF w/OF fwd</entry><entry morerows=\"0\" valign=\"top\">V2</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">PU</entry><entry morerows=\"0\" valign=\"top\">; using MOVF and MOVOF</entry></row><row><entry morerows=\"0\" valign=\"top\">CALL nr disp rel</entry><entry morerows=\"0\" valign=\"top\">PU</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">BRN</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">CALL nr reg indr</entry><entry morerows=\"0\" valign=\"top\">PU</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">BRN</entry><entry morerows=\"0\" valign=\"top\">; pos 2 adds indr_reg w/</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2009zero instead of EIP+rel</entry></row><row><entry morerows=\"0\" valign=\"top\">CALL nr mem indr</entry><entry morerows=\"0\" valign=\"top\">PU</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">LBR</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">POP mem</entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\">POP mem w/SIB</entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\">POPF</entry><entry morerows=\"0\" valign=\"top\">uCode</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">; this goes to uCode since</entry></row><row><entry morerows=\"0\" valign=\"top\">IOPL can change</entry></row><row><entry morerows=\"0\" valign=\"top\">RET</entry><entry morerows=\"0\" valign=\"top\">LBR</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">OP</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">RET imm</entry><entry morerows=\"0\" valign=\"top\">LBR</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">V12</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">XCHG</entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\">XADD</entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\">LEAVE</entry><entry morerows=\"0\" valign=\"top\">POP</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">LO</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">LOOP</entry><entry morerows=\"0\" valign=\"top\">OP</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">BRN</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">LOOPcond</entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\">JCXZ</entry><entry morerows=\"0\" valign=\"top\">OP</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">BRN</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">MUL 1 disp pos</entry><entry morerows=\"0\" valign=\"top\">OP</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">-</entry><entry morerows=\"0\" valign=\"top\">;</entry></row><row><entry morerows=\"0\" valign=\"top\">MUL 2 disp pos</entry><entry morerows=\"0\" valign=\"top\">OP</entry><entry morerows=\"0\" valign=\"top\">/</entry><entry morerows=\"0\" valign=\"top\">OP</entry><entry morerows=\"0\" valign=\"top\">; 2nd pos is a NOP</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"5\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Operand to bus assignments and opcode details: Aop,Bop, and Disp busses are 32 bits Const bus is 4 bits</p><p><tables id=\"TABLE-US-00027\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">regular operation</entry><entry morerows=\"0\" valign=\"top\">OP\u2003\u2003/\u2003-\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">same but with immediate data</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">regular operation</entry><entry morerows=\"0\" valign=\"top\">OP\u2003\u2003/\u2003-\u2003;\u2003OP_STR block moves imm</entry></row><row><entry morerows=\"0\" valign=\"top\">to Bop</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">imm</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">imm</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">Load-op</entry><entry morerows=\"0\" valign=\"top\">LO\u2003\u2003/\u2003-\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Bop+disp</entry><entry morerows=\"0\" valign=\"top\">{Lw}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"154PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">&amp;\u2003Btag&lt;=Dtag</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRES</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">OP-store</entry><entry morerows=\"0\" valign=\"top\">OS\u2003\u2003/\u2003-\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Aop+disp</entry><entry morerows=\"0\" valign=\"top\">{L}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{M}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">Load-op-store</entry><entry morerows=\"0\" valign=\"top\">LOS\u2003\u2003/\u2003-\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Aop+disp</entry><entry morerows=\"0\" valign=\"top\">{Lw}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"154PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">&amp; Atag&lt;=Dtag</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">LSRES</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{M}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">SIB w/ Load-op</entry><entry morerows=\"0\" valign=\"top\">SIB\u2003/\u2003LO\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">base</entry><entry morerows=\"0\" valign=\"top\">index</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">base</entry><entry morerows=\"0\" valign=\"top\">index</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">base+scaled</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">(ind)</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">fwd</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">fwd+disp</entry><entry morerows=\"0\" valign=\"top\">{Lw}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"154PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">&amp;\u2003Btag&lt;=Dtag</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRES</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">SIB w/ OP-store</entry><entry morerows=\"0\" valign=\"top\">SIB\u2003/\u2003OS\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">base</entry><entry morerows=\"0\" valign=\"top\">index</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">base</entry><entry morerows=\"0\" valign=\"top\">index</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">base+scaled</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">(ind)</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">fwd</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">fwd+disp</entry><entry morerows=\"0\" valign=\"top\">{L}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{M}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">SIB w/ L-O-S</entry><entry morerows=\"0\" valign=\"top\">SIB\u2003/\u2003LOS\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">base</entry><entry morerows=\"0\" valign=\"top\">index</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">base</entry><entry morerows=\"0\" valign=\"top\">index</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">base+scaled</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">(ind)</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">fwd</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">fwd+disp</entry><entry morerows=\"0\" valign=\"top\">{Lw}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"154PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">&amp;\u2003Atag&lt;=Dtag</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">LSRES</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{M}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">divide opcode</entry><entry morerows=\"0\" valign=\"top\">DIV\u2003/\u2003-\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ADD A,B</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SUB A,B</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"126PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">FPU linear address</entry><entry morerows=\"0\" valign=\"top\">FLA\u2003/ \u2003-\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Bop+disp</entry><entry morerows=\"0\" valign=\"top\">{I}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"154PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">&amp;\u2003Btag&lt;=Dtag</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">fwd</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\">fwd+const</entry><entry morerows=\"0\" valign=\"top\">{L}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">Jcc</entry><entry morerows=\"0\" valign=\"top\">BRN\u2003/\u2003-\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\">pre_adr</entry><entry morerows=\"0\" valign=\"top\">rel</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">rel</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EIP+rel</entry><entry morerows=\"0\" valign=\"top\">{B}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003next cycle\u2003flag logic compares EIP+rel &amp; pre_adr for</entry></row><row><entry morerows=\"0\" valign=\"top\">predicted taken</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">JMP nr disp rel</entry><entry morerows=\"0\" valign=\"top\">BRN\u2003/\u2003-\u2003;\u2003same as conditional</entry></row><row><entry morerows=\"0\" valign=\"top\">except always taken</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\">pre_adr</entry><entry morerows=\"0\" valign=\"top\">rel</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">rel</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EIP+rel</entry><entry morerows=\"0\" valign=\"top\">{B}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003next cycle\u2003flag logic compares EIP+rel &amp; pre_adr for</entry></row><row><entry morerows=\"0\" valign=\"top\">predicted taken</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">JMP nr reg indr</entry><entry morerows=\"0\" valign=\"top\">BRN\u2003/\u2003-\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">reg</entry><entry morerows=\"0\" valign=\"top\">pre_adr</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">reg</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">reg+0</entry><entry morerows=\"0\" valign=\"top\">{B}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003next cycle\u2003flag logic compares reg+0 &amp; pre_adr for</entry></row><row><entry morerows=\"0\" valign=\"top\">predicted taken</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">JMP nr mem indr</entry><entry morerows=\"0\" valign=\"top\">LBR\u2003/\u2003-\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">pre_adr</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Aop+disp</entry><entry morerows=\"0\" valign=\"top\">{Lw}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"154PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">&amp;\u2003Atag&lt;=Dtag</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">LSRES</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">LSRES+0</entry><entry morerows=\"0\" valign=\"top\">{B}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003next cycle\u2003flag logic compares LSRES+0 &amp; pre_adr for</entry></row><row><entry morerows=\"0\" valign=\"top\">predicted taken</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">PUSH reg</entry><entry morerows=\"0\" valign=\"top\">PU\u2003/\u2003-\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\">ESP-const</entry><entry morerows=\"0\" valign=\"top\">{L,F}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{M}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">PUSH mem</entry><entry morerows=\"0\" valign=\"top\">LO\u2003/\u2003PU\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Bop+disp</entry><entry morerows=\"0\" valign=\"top\">{Lw}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"154PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">&amp;\u2003Btag&lt;=Dtag</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRES</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">fwd</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\">ESP-const</entry><entry morerows=\"0\" valign=\"top\">{L,F}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">fwd</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{M}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">PUSHF</entry><entry morerows=\"0\" valign=\"top\">PU\u2003/\u2003-\u2003; using MOVF</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">flg</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\">ESP-const</entry><entry morerows=\"0\" valign=\"top\">{L,F}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">flg</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVF</entry><entry morerows=\"0\" valign=\"top\">{M}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003the MOVF on v1 combines system flags on Bop with CF &amp; XF</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">PUSHF w/OF fwd</entry><entry morerows=\"0\" valign=\"top\">OP\u2003/\u2003Pu\u2003; using MOVF and MOVOF</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">flg</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">flg</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVF</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003the MOVF on v1 combines system flags on Bop with CF &amp; XF</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">fwd</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\">ESP-const</entry><entry morerows=\"0\" valign=\"top\">{L,F}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">fwd</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVOF</entry><entry morerows=\"0\" valign=\"top\">{M}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003the MOVOF on v1 overwrites the OF bit position of Bop</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">CALL nr disp rel</entry><entry morerows=\"0\" valign=\"top\">PU\u2003/\u2003BRN\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\">ESP-const</entry><entry morerows=\"0\" valign=\"top\">{L,F}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{M}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\">pre_adr</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">EIP+disp</entry><entry morerows=\"0\" valign=\"top\">{B}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003next cycle\u2003flag logic compares EIP+disp &amp; pre_adr for</entry></row><row><entry morerows=\"0\" valign=\"top\">predicted taken</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">CALL nr reg indr</entry><entry morerows=\"0\" valign=\"top\">PU\u2003/\u2003BRN ; pos 2 adds indr_reg w/</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">zero instead of EIP+rel</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\">ESP-const</entry><entry morerows=\"0\" valign=\"top\">{L,F}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{M}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">reg</entry><entry morerows=\"0\" valign=\"top\">pre_adr</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">reg</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">reg+0</entry><entry morerows=\"0\" valign=\"top\">{B}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003next cycle\u2003flag logic compares reg+0 &amp; pre_adr for</entry></row><row><entry morerows=\"0\" valign=\"top\">predicted taken</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">CALL nr mem indr</entry><entry morerows=\"0\" valign=\"top\">PU\u2003/\u2003LBR\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\">ESP-const</entry><entry morerows=\"0\" valign=\"top\">{L,F}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{M}</entry></row><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">pre_adr</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Aop+disp</entry><entry morerows=\"0\" valign=\"top\">{Lw}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"154PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">&amp;\u2003Atag&lt;=Dtag</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">LSRES</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRES+0</entry><entry morerows=\"0\" valign=\"top\">{B}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003next cycle\u2003flag logic compares LSRES+0 &amp; pre_adr for</entry></row><row><entry morerows=\"0\" valign=\"top\">predicted taken</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">POP reg</entry><entry morerows=\"0\" valign=\"top\">LO\u2003/\u2003POP\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ESP+0</entry><entry morerows=\"0\" valign=\"top\">{Lw}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"154PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">&amp;\u2003Btag&lt;=Dtag</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRES</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\">ESP+const</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">RET</entry><entry morerows=\"0\" valign=\"top\">LBR\u2003/\u2003OP\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">pre_adr</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">ESP+0</entry><entry morerows=\"0\" valign=\"top\">{Lw}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"154PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">&amp;\u2003Atag&lt;=Dtag</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">LSRES</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">LSRES+0</entry><entry morerows=\"0\" valign=\"top\">{B}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003next cycle\u2003flag logic compares LSRES+0 &amp; pre_adr for</entry></row><row><entry morerows=\"0\" valign=\"top\">predicted taken</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\">ESP+const</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">RET imm</entry><entry morerows=\"0\" valign=\"top\">LBR\u2003/\u2003V12\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">pre_adr</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ESP+0</entry><entry morerows=\"0\" valign=\"top\">{Lw}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"154PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">&amp;\u2003Atag&lt;=Dtag</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">LSRES</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRES+0</entry><entry morerows=\"0\" valign=\"top\">{B}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003next cycle\u2003flag logic compares LSRES+0 &amp; pre_adr for</entry></row><row><entry morerows=\"0\" valign=\"top\">predicted taken</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\">imm</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\">ESP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\">ESP+const</entry><entry morerows=\"0\" valign=\"top\">{I}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">fwd</entry><entry morerows=\"0\" valign=\"top\">imm</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">fwd+imm</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">LEAVE</entry><entry morerows=\"0\" valign=\"top\">V12\u2003/\u2003LO\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EBP</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">const</entry><entry morerows=\"0\" valign=\"top\">EBP+const</entry><entry morerows=\"0\" valign=\"top\">{I}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">fwd</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">R&lt;-fwd</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003\u2003this one is used so another protocol is not needed and</entry></row><row><entry morerows=\"0\" valign=\"top\">dependency checking is easy; otherwise, use a version of the</entry></row><row><entry morerows=\"0\" valign=\"top\">POP protocol with Bop+const.</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2003\u2003FIROB latches the output as the new ESP value.</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EBP</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EBP</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EBP+0</entry><entry morerows=\"0\" valign=\"top\">{Lw}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"154PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">&amp;\u2003Btag&lt;=Dtag</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRES</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003\u2003FIROB latches v1 result as the new EBP value</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">LOOP</entry><entry morerows=\"0\" valign=\"top\">Op\u2003/\u2003BRN\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ECX</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">ECX</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\">pre_adr</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">EIP+disp</entry><entry morerows=\"0\" valign=\"top\">{B}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003next cycle\u2003flag logic compares EIP+disp &amp; pre_adr for</entry></row><row><entry morerows=\"0\" valign=\"top\">predicted taken</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">JCXZ</entry><entry morerows=\"0\" valign=\"top\">OP\u2003/\u2003BRN\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">ECX</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">ECX</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\">pre_adr</entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">EIP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">disp</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">EIP+disp</entry><entry morerows=\"0\" valign=\"top\">{B}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003next cycle\u2003flag logic compares EIP+disp &amp; pre_adr for</entry></row><row><entry morerows=\"0\" valign=\"top\">predicted taken</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">MUL 1 disp pos</entry><entry morerows=\"0\" valign=\"top\">OP\u2003/\u2003-\u2003;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003\u2003resv_sta receives grant and sends source on SAOPND &amp;</entry></row><row><entry morerows=\"0\" valign=\"top\">SBOPND; FNCU is idle</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2003\u2003resv_sta starts counting 3 cycles and issues v1 to pass</entry></row><row><entry morerows=\"0\" valign=\"top\">MUL result</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"140PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">pass MUL</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">MUL 2 disp pos</entry><entry morerows=\"0\" valign=\"top\">OP\u2003/\u2003Op\u2003; 2nd pos is a NOP</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 1:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs-&gt;</entry><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\">--</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">none</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003\u2003resv_sta receives grant and sends source on SAOPND &amp;</entry></row><row><entry morerows=\"0\" valign=\"top\">SBOPND; FNCU is idle</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2003\u2003resv_sta starts counting 3 cycles and issues v1 to pass</entry></row><row><entry morerows=\"0\" valign=\"top\">MUL result</entry></row><row><entry morerows=\"0\" valign=\"top\">\u2003\u2003resv_sta(i) signals resv_sta(i+1) to start counting 4</entry></row><row><entry morerows=\"0\" valign=\"top\">cycles</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"140PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">pass MUL</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"21PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">dsptch pos 2:</entry><entry morerows=\"0\" valign=\"top\">Aop</entry><entry morerows=\"0\" valign=\"top\">Bop</entry><entry morerows=\"0\" valign=\"top\">Disp</entry><entry morerows=\"0\" valign=\"top\">Const</entry><entry morerows=\"0\" valign=\"top\">operation</entry><entry morerows=\"0\" valign=\"top\">Latch</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">inputs</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">\u2002v0:</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NOP</entry><entry morerows=\"0\" valign=\"top\">{0}</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"217PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2003\u2003resv_sta starts counting 4 cycles and issues v1 to pass</entry></row><row><entry morerows=\"0\" valign=\"top\">MUL result</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"140PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">\u2002v1:</entry><entry morerows=\"0\" valign=\"top\">NOP</entry><entry morerows=\"0\" valign=\"top\">{F}</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Cycle Type</p><p>Sometimes incorrect data will be sent by the Dcache or the LSSEC. The reservation station will resend the cancelled cycle after the correct data comes from the data cache in the case of a hit in a mispredicted way. When the DCUNPAHIT or DCUNPBHIT (Dcache hit in unpredicted way) signal is detected, the R_VALID status is changed to an R_NONE status by the FNCU and the reservation station will latch in the correct data next cycle. The correct data from an unpredicted way will have to wait one extra cycle to be issued since the reservation station has already prioritized another entry for issue. DCUNPAHIT and DCUNPBHIT correspond to Dcache results for the data on LSRES<b>0</b> and LSRES<b>1</b> respectively. A Dcache miss is detected when valid tags match on LSTAGO bus but no DCUNPAHIT or DCPRPAHIT is detected. The DCUNPBHIT and DCPRPBHIT signals are for the LSTAG<b>1</b> bus status. The LSSEC uses a similar protocol for miss only by sending the LSCANFWD signal which indicates that the forwarded data was incorrect. When load data is received on the LSRES bus, the reservation station keeps the corresponding entry for a cycle after it is issued to the FNCU and checks to see if its tags needed to be set again for the miss condition. Keeping the reservation station entry valid for an extra cycle is not needed in the case of an FPU load linear address calculation. The FPU reservation station must be responsible for detecting and handling the incorrect load data conditions. Another side note is that AHBYTE data is not sent back to bits 15:8 for \u201cstore\u201d data.</p><p>SRB, FPU, and MULT Handling</p><p>SRB opcodes look like a move instruction with the exception that a STAT_SRB signal is asserted to let the LSSEC know the 32 bit value needs to be latched into the 4 entry SRB file. FPU opcodes go to uCode and get dispatched on a single FIROB line which uses the first three positions for calculating linear addresses and the last position for the entry point into the Fcode (FPU microcode). FPU entry points are sent directly from dispatch to the FPU.</p><p>Each of the four dispatch positions can send a multiply request signal to the multiplier unit, and wait to see which position receives a grant signal. Once a reservation station position has the grant it can use the SAOPND and SBOPND busses to send its sources to the multiplier. It also starts counting three cycles. Nothing except a DTAG, valid status, and a selection signal are sent to the FNCU at the end of the count. The multiply result will be multiplexed onto the FNCU's RES bus. If two results are going to be written by the multiplier, the reservation station that gets the multiplier grant will send a count start signal to the (I+1) reservation station position. After four cycles the (I+1) reservation station will finish its count and let the second multiply result pass onto the RES bus for it's FNCU.</p><p>Reservation Station Signals</p><p>This signal list covers the reservation station at the top of its hierarchy. There are three reservation station entries covered in the RS signal list and a control section signal list covered in the RSCTL.</p><p>Reservation Station Input Signals</p><p>AXBLAC<b>3</b>\u2014use A operand or B operand for linear address calc</p><p>DCPAPRHIT\u2014data cache port A predicted way hit</p><p>DCPBPRHIT\u2014data cache port B predicted way hit</p><p>DCUNPAHIT\u2014data cache port A unpredicted way hit</p><p>DCUNPBHIT\u2014data cache port B unpredicted way hit</p><p>FOCTLST_VUSE<b>3</b>\u2014valid control store use next cycle</p><p>FOCTLST_VWR<b>3</b>\u2014valid control store write next cycle</p><p>MULCYC<b>2\u00d73_3\u2014indicates </b>2 or 3 cycle multiply is required</p><p>MULGRn\u2014multiply grant to position n<b>1</b></p><p>MULRES<b>3</b>_<b>3</b>\u2014leave RES bus free for MUL result in 3 cycles MULX;</p><p>RD_DEP_DS<b>3</b>\u2014entry specific read bit for DS; entry wait if both read and write are set</p><p>RD_DEP_ES<b>3</b>\u2014entry specific read bit for ES; entry wait if both read and write are set</p><p>RD_DEP_FS<b>3</b>\u2014entry specific read bit for FS; entry wait if both read and write are set</p><p>RD_DEP_GS<b>3</b>\u2014entry specific read bit for GS; entry wait if both read and write are set</p><p>RQLAC<b>3</b>\u2014request linear address calc</p><p>VAT<b>3</b>\u2014valid A operand tag</p><p>VBT<b>3</b>\u2014valid B operand tag</p><p>VCFT<b>3</b>\u2014valid carry flag operand tag</p><p>VRS<b>3</b>\u2014valid entry going from op steer to RS<b>2</b></p><p>VSFT<b>3</b>\u2014valid status flag operand tag</p><p>WRDS\u2014global bit for write to DS</p><p>WRES\u2014global bit for write to ES</p><p>WRFS\u2014global bit for write to FS</p><p>WRGS\u2014global bit for write to GS</p><p>[<b>10</b>:<b>0</b>] INSSEG\u2014LSSEC segment MUX select</p><p>[<b>10</b>:<b>0</b>] RSPROTOCOL<b>3</b>\u2014determines protocol (ie: LOS, MUL, DIV, etc.)</p><p>[<b>1</b>:<b>0</b>] LSCANFWD\u2014LSSEC cancel signal for forwarded data on the LSRESn bus</p><p>[<b>2</b>:<b>0</b>] CDTAG<b>3</b>\u2014current destination tag for the incoming opcode for RS<b>2</b></p><p>[<b>31</b>:<b>0</b>] AOPND<b>3</b>\u2014A operand</p><p>[<b>31</b>:<b>0</b>] BOPND<b>3</b>\u2014B operand</p><p>[<b>31</b>:<b>0</b>] DSPR<b>3</b>\u2014displacement</p><p>[<b>31</b>:<b>0</b>] LSRES<b>0</b>\u2014LSSEC result bus <b>0</b></p><p>[<b>31</b>:<b>0</b>] LSRES<b>1</b>\u2014LSSEC result bus <b>1</b></p><p>[<b>31</b>:<b>0</b>] RES<b>0</b>\u2014forwarded result bus from position <b>0</b></p><p>[<b>31</b>:<b>0</b>] RES<b>1</b>\u2014forwarded result bus from position <b>1</b></p><p>[<b>31</b>:<b>0</b>] RES<b>2</b>\u2014forwarded result bus from position <b>2</b></p><p>[<b>31</b>:<b>0</b>] RES<b>3</b>\u2014forwarded result bus from position <b>3</b></p><p>[<b>3</b>:<b>0</b>] FOCTLST_WR\u2014indicates which control store vector to use</p><p>[<b>4</b>:<b>0</b>] ATAG<b>3</b>\u2014A operand tag sent to RS<b>2</b></p><p>[<b>4</b>:<b>0</b>] BTAG<b>3</b>\u2014B operand tag sent to RS<b>2</b></p><p>[<b>4</b>:<b>0</b>] CFTAG<b>3</b>\u2014carry (CF) tag sent to RS<b>2</b></p><p>[<b>4</b>:<b>0</b>] DTAG<b>0</b>\u2014destination ID for result at position <b>0</b></p><p>[<b>4</b>:<b>0</b>] DTAG<b>1</b>\u2014destination ID for result at position <b>1</b></p><p>[<b>4</b>:<b>0</b>] DTAG<b>2</b>\u2014destination ID for result at position <b>2</b></p><p>[<b>4</b>:<b>0</b>] DTAG<b>3</b>\u2014destination ID for result at position <b>3</b></p><p>[<b>4</b>:<b>0</b>] LSTAG<b>0</b>\u2014destination ID for LS result at position <b>0</b></p><p>[<b>4</b>:<b>0</b>] LSTAG<b>1</b>\u2014destination ID for LS result at position <b>1</b></p><p>[<b>4</b>:<b>0</b>] SFTAG<b>3</b>\u2014status flags (ZF,AF,PF,SF,DF,OF) tag sent to RS<b>2</b></p><p>[<b>6</b>:<b>0</b>] FLGD<b>3</b>\u2014input flag data from the reservation station</p><p>[<b>6</b>:<b>0</b>] RFLAG<b>0</b>\u2014input flag data from position <b>0</b></p><p>[<b>6</b>:<b>0</b>] RFLAG<b>1</b>\u2014input flag data from position <b>1</b></p><p>[<b>6</b>:<b>0</b>] RFLAG<b>2</b>\u2014input flag data from position <b>2</b></p><p>[<b>6</b>:<b>0</b>] RFLAG<b>3</b>\u2014input flag data from position <b>3</b></p><p>[<b>6</b>:<b>0</b>] RFLAGLS<b>0</b>\u2014input flag data from LSSEC <b>0</b></p><p>[<b>6</b>:<b>0</b>] RFLAGLS<b>1</b>\u2014input flag data from LSSEC <b>1</b></p><p>[<b>7</b>:<b>0</b>] FOCTLST_USE<b>3</b>\u2014indicates which control store vector to use</p><p>Reservation Station Output Signal List</p><p>FOCTLST_VUSE\u2014valid control store use next cycle</p><p>FOCTLST_VWR\u2014valid control store write next cycle</p><p>FNCUGO\u2014functional unit GO indication</p><p>FUGNT<b>3</b>\u2014indicates for operand steer to drive the shared data busses into the FNCU</p><p>MULCYC2\u00d73\u2014number of multiply cycles is 2, else use 3</p><p>MULONEOP\u2014opcode is for the one operand version</p><p>MULRES<b>3</b>\u2014leave RES bus free for MUL result in 3 cycles</p><p>MULRQn\u2014multiply request from position n</p><p>MULSIGN\u2014signed values</p><p>OPALSRES<b>0</b>\u2014used to qualify valid status; else mispredicted way miss; Aop &amp; DC port <b>0</b></p><p>OPALSRES<b>1</b>\u2014used to qualify valid status; else mispredicted way miss; Aop &amp; DC port <b>1</b></p><p>OPBLSRES<b>0</b>\u2014used to qualify valid status; else mispredicted way miss; Bop &amp; DC port <b>0</b></p><p>OPBLSRES<b>1</b>\u2014used to qualify valid status; else mispredicted way miss; Bop &amp; DC port <b>1</b></p><p>RSFULL\u2014reservation station full</p><p>[<b>10</b>:<b>0</b>] INSSEG\u2014LSSEC segment MUX select</p><p>[<b>1</b>:<b>0</b>] MULOPSIZE\u2014output operands are 01: byte, 10: word, or 11: dword</p><p>[<b>2</b>:<b>0</b>] CDTAG\u2014current destination tag for the incoming opcode YY use DTAG</p><p>[<b>31</b>:<b>0</b>] AOPND\u2014A operand</p><p>[<b>31</b>:<b>0</b>] BOPND\u2014B operand</p><p>[<b>31</b>:<b>0</b>] DSPR\u2014displacement</p><p>[<b>31</b>:<b>0</b>] SAOPND\u2014shared A operand bus</p><p>[<b>31</b>:<b>0</b>] SBOPND\u2014shared B operand bus</p><p>[<b>3</b>:<b>0</b>] FOCTLST_WR\u2014indicates which control store vector to use</p><p>[<b>6</b>:<b>0</b>] FLGD\u2014input flag data from the reservation station</p><p>[<b>6</b>:<b>0</b>] FNCUMUXA\u2014mux control from reservation station for A operand input</p><p>[<b>6</b>:<b>0</b>] FNCUMUXB\u2014mux control from reservation station for B operand input</p><p>[<b>6</b>:<b>0</b>] FNCUMUXCF\u2014mux control from reservation station for the carry flag</p><p>[<b>6</b>:<b>0</b>] FNCUMUXSF\u2014mux control from reservation station for the status flags</p><p>[<b>7</b>:<b>0</b>] FOCTLST_USE\u2014indicates which control store vector to use</p><p>RS: Reservation Station Entry Signal List</p><p>Three identical reservation station entries for each reservation station block allow storage and forwarding for three outstanding dispatch positions.</p><p>RS Input Signal List</p><p>AXBLACI\u2014use A operand or B operand for linear address calc</p><p>FOCTLST_VUSEI\u2014valid control store use next cycle</p><p>FOCTLST_VWRI\u2014valid control store write next cycle</p><p>MULCYC2\u00d73I\u20142 or 3 cycle multiply</p><p>MULGRI\u2014multiply grant to position n<b>1</b></p><p>MULRES<b>3</b>I\u2014leave RES bus free for MUL result in 3 cycles</p><p>RD_DEP_DSI\u2014entry specific read bit for DS; entry wait if both read and write are set</p><p>RD_DEP_ESI\u2014entry specific read bit for ES; entry wait if both read and write are set</p><p>RD_DEP_FSI\u2014entry specific read bit for FS; entry wait if both read and write are set</p><p>RD_DEP_GSI\u2014entry specific read bit for GS; entry wait if both read and write are set</p><p>RQLACI\u2014request linear address calc</p><p>VATI\u2014valid A operand tag</p><p>VBTI\u2014valid B operand tag</p><p>VCFTI\u2014valid carry flag operand tag</p><p>VRSI\u2014valid entry going from op steer to RS<b>2</b></p><p>VSFTI\u2014valid status flag operand tag</p><p>[<b>10</b>:<b>0</b>] INSSEGI\u2014LSSEC segment MUX select</p><p>[<b>10</b>:<b>0</b>] RSPROTOCOLI\u2014determines protocol (ie: LOS, MUL, DIV, etc.)</p><p>[<b>2</b>:<b>0</b>] CDTAGI\u2014current destination tag for the incoming opcode for RS<b>2</b></p><p>[<b>31</b>:<b>0</b>] AOPNDI\u2014A operand</p><p>[<b>31</b>:<b>0</b>] BOPNDI\u2014B operand</p><p>[<b>31</b>:<b>0</b>] DSPRI\u2014displacement</p><p>[<b>31</b>:<b>0</b>] LSRES<b>0</b>\u2014LSSEC result bus <b>0</b></p><p>[<b>31</b>:<b>0</b>] LSRES<b>1</b>\u2014LSSEC result bus <b>1</b></p><p>[<b>31</b>:<b>0</b>] RES<b>0</b>\u2014forwarded result bus from position <b>0</b></p><p>[<b>31</b>:<b>0</b>] RES<b>1</b>\u2014forwarded result bus from position <b>1</b></p><p>[<b>31</b>:<b>0</b>] RES<b>2</b>\u2014forwarded result bus from position <b>2</b></p><p>[<b>31</b>:<b>0</b>] RES<b>3</b>\u2014forwarded result bus from position <b>3</b></p><p>[<b>3</b>:<b>0</b>] FOCTLST_WRI\u2014indicates which control store vector to use</p><p>[<b>4</b>:<b>0</b>] ATAGI\u2014A operand tag sent to RS<b>2</b></p><p>[<b>4</b>:<b>0</b>] BTAGI\u2014B operand tag sent to RS<b>2</b></p><p>[<b>4</b>:<b>0</b>] CFTAGI\u2014carry (CF) tag sent to RS<b>2</b></p><p>[<b>4</b>:<b>0</b>] DTAG<b>0</b>\u2014destination ID for result at position <b>0</b></p><p>[<b>4</b>:<b>0</b>] DTAGI\u2014destination ID for result at position <b>1</b></p><p>[<b>4</b>:<b>0</b>] DTAG<b>2</b>\u2014destination ID for result at position <b>2</b></p><p>[<b>4</b>:<b>0</b>] DTAG<b>3</b>\u2014destination ID for result at position <b>3</b></p><p>[<b>4</b>:<b>0</b>] LSTAG<b>0</b>\u2014destination ID for LS result at position <b>0</b></p><p>[<b>4</b>:<b>0</b>] LSTAG<b>1</b>\u2014destination ID for LS result at position <b>1</b></p><p>[<b>4</b>:<b>0</b>] SFTAGI\u2014status flags (ZF,AF,PF,SF,DF,OF) tag sent to RS<b>2</b></p><p>[<b>6</b>:<b>0</b>] FLGDI\u2014input flag data from the reservation station</p><p>[<b>6</b>:<b>0</b>] RFLAG<b>0</b>\u2014input flag data from position <b>0</b></p><p>[<b>6</b>:<b>0</b>] RFLAG<b>1</b>\u2014input flag data from position <b>1</b></p><p>[<b>6</b>:<b>0</b>] RFLAG<b>2</b>\u2014input flag data from position <b>2</b></p><p>[<b>6</b>:<b>0</b>] RFLAG<b>3</b>\u2014input flag data from position <b>3</b></p><p>[<b>6</b>:<b>0</b>] RELAGLS<b>0</b>\u2014input flag data from LSSEC <b>0</b></p><p>[<b>6</b>:<b>0</b>] RFLAGLS<b>1</b>\u2014input flag data from LSSEC <b>1</b></p><p>[<b>7</b>:<b>0</b>] FOCTLST_USEI\u2014indicates which control store vector to use</p><p>RS Output Signal List</p><p>AXBLACO\u2014use A operand or B operand for linear address calc</p><p>F<b>0</b>CTLST_VUSE\u2014valid control store use next cycle</p><p>F<b>0</b>CTLST_VUSEO valid control store use next cycle</p><p>F<b>0</b>CTLST_VWR\u2014valid control store write next cycle</p><p>F<b>0</b>CTLST_VWRO\u2014valid control store write next cycle</p><p>FNCUGO\u2014functional unit GO indication</p><p>MULCYC2\u00d73\u2014number of multiply cycles is 2, else use 3 MULCYC2\u00d73O</p><p>MULGRO\u2014multiply grant to position n<b>1</b></p><p>MULONEOP\u2014opcode is for the one operand version</p><p>MULRES<b>3</b>\u2014leave RES bus free for MUL result in 3 cycles</p><p>MULRES<b>3</b>O\u2014leave RES bus free for MUL result in 3 cycles</p><p>MULSIGN\u2014signed values</p><p>OPALSRES<b>0</b>\u2014used to qualify valid status; else mispredicted way miss; Aop &amp; DC port <b>0</b></p><p>OPALSRES<b>1</b>\u2014used to qualify valid status; else mispredicted way miss; Aop &amp; DC port <b>1</b></p><p>OPBLSRES<b>0</b>\u2014used to qualify valid status; else mispredicted way miss; Bop &amp; DC port <b>0</b></p><p>OPBLSRES<b>1</b>\u2014used to qualify valid status; else mispredicted way miss; Bop &amp; DC port <b>1</b></p><p>RD_DEP_DSO\u2014entry specific read bit for DS; entry wait if both read and write are set</p><p>RD<sub>\u2014DEP_ESO\u2014entry specific read bit for ES; entry wait if both read and write are set </sub></p><p>RD<sub>\u2014DEP_FSO\u2014entry specific read bit for FS; entry wait if both read and write are set </sub></p><p>RD<sub>\u2014DEP_GSO\u2014entry specific read bit for GS; entry wait if both read and write are set </sub></p><p>RQLACO\u2014request linear address calc</p><p>VATO\u2014valid A operand tag</p><p>VBTO\u2014valid B operand tag</p><p>VCFTO\u2014valid carry flag operand tag</p><p>VRSO\u2014valid entry going from op steer to RS<b>2</b></p><p>VSFTO\u2014valid status flag operand tag</p><p>[<b>10</b>:<b>0</b>] INSSEG\u2014LSSEC segment MUX select</p><p>[<b>10</b>:<b>0</b>] INSSEGO\u2014LSSEC segment MUX select</p><p>[<b>10</b>:<b>0</b>] RSPROTOCOLO\u2014determines protocol (ie: LOS, MUL, DIV, etc.)</p><p>[<b>1</b>:<b>0</b>] MULOPSIZE\u2014output operands are 01: byte, 10: word, or 11: dword</p><p>[<b>2</b>:<b>0</b>] CDTAG\u2014current destination tag for the incoming opcode YY use DTAG</p><p>[<b>2</b>:<b>0</b>] CDTAGO\u2014current destination tag for the incoming opcode for RS<b>2</b></p><p>[<b>31</b>:<b>0</b>] AOPND\u2014A operand</p><p>[<b>31</b>:<b>0</b>] AOPNDO\u2014A operand</p><p>[<b>31</b>:<b>0</b>] BOPND\u2014B operand</p><p>[<b>31</b>:<b>0</b>] BOPNDO\u2014B operand</p><p>[<b>31</b>:<b>0</b>] DSPR\u2014displacement</p><p>[<b>31</b>:<b>0</b>] DSPRO\u2014displacement</p><p>[<b>31</b>:<b>0</b>] SAOPND\u2014shared A operand bus</p><p>[<b>31</b>:<b>0</b>] SBOPND\u2014shared B operand bus</p><p>[<b>3</b>:<b>0</b>] FOCTLST_WR\u2014indicates which control store vector to use</p><p>[<b>3</b>:<b>0</b>] FOCTLST_WRO\u2014indicates which control store vector to use</p><p>[<b>4</b>:<b>0</b>] ATAGO\u2014A operand tag sent to RS<b>2</b></p><p>[<b>4</b>:<b>0</b>] BTAGO\u2014B operand tag sent to RS<b>2</b></p><p>[<b>4</b>:<b>0</b>] CFTAGO\u2014carry (CF) tag sent to RS<b>2</b></p><p>[<b>4</b>:<b>0</b>] SFTAGO\u2014status flags (ZF,AF,PF,SF,D F,OF) tag sent to RS<b>2</b></p><p>[<b>6</b>:<b>0</b>] FLGD\u2014input flag data from the reservation station</p><p>[<b>6</b>:<b>0</b>] FLGDO\u2014input flag data from the reservation station</p><p>[<b>6</b>:<b>0</b>] FNCUMUXA\u2014mux control from reservation station for A operand input</p><p>[<b>6</b>:<b>0</b>] FNCUMUXB\u2014mux control from reservation station for B operand input</p><p>[<b>6</b>:<b>0</b>] FNCUMUXCF\u2014mux control from reservation station for the carry flag</p><p>[<b>6</b>:<b>0</b>] FNCUMUXSF\u2014mux control from reservation station for the status flags</p><p>[<b>7</b>:<b>0</b>] F<b>0</b>CTLST_USE\u2014indicates which control store vector to use</p><p>[<b>7</b>:<b>0</b>] F<b>0</b>CTLST_USEO\u2014indicates which control store vector to use</p><p>RSCTL Sub-Block</p><p>Controls shifting of entries within the reservation station and controls what the FNCU does and which control bit vector is used.</p><p>RSCTL Input Signal List</p><p>AXBLACx\u2014use A operand or B operand for linear address calc</p><p>DCPAPRHIT\u2014data cache port A predicted way hit</p><p>DCPBPRHIT\u2014data cache port B predicted way hit</p><p>DCUNPAHIT\u2014data cache port A unpredicted way hit</p><p>DCUNPBHIT\u2014data cache port B unpredicted way hit</p><p>MATx\u2014match on A operand tag</p><p>MBTx\u2014match on B operand tag</p><p>MCFTx\u2014match on carry flag (CF) tag</p><p>MSFTx\u2014match on status flag (STF) tag</p><p>MULCYC2\u00d73_x\u2014multiply takes 2 or 3 cycles MULGRn;</p><p>MULRES<b>3</b>_x\u2014leave RES bus free for MUL result in 3 cycles</p><p>RD_DEP_DSx\u2014entry specific read bit for DS; entry wait if both read and write are set</p><p>RD_DEP_ESx\u2014entry specific read bit for ES; entry wait if both read and write are set</p><p>RD_DEP_FSx\u2014entry specific read bit for FS; entry wait if both read and write are set</p><p>RD_DEP_GSx\u2014entry specific read bit for GS; entry wait if both read and write are set</p><p>RQLACx\u2014request linear address calc</p><p>VATx\u2014valid A operand tag</p><p>VBTx\u2014valid B operand tag</p><p>VCFTx\u2014valid carry flag operand tag</p><p>VRSx\u2014valid entry going from op steer to RS<b>2</b></p><p>VSFTx\u2014valid status flag operand tag</p><p>WRDS\u2014global bit for write to DS</p><p>WRES\u2014global bit for write to ES</p><p>WRFS\u2014global bit for write to FS</p><p>WRGS\u2014global bit for write to GS</p><p>[<b>10</b>:<b>0</b>] RSPROTOCOLx\u2014determines protocol (ie: LOS, MUL, DIV, etc.)</p><p>[<b>1</b>:<b>0</b>] LSCANFWD\u2014LSSEC cancel signal for forwarded data on the LSRESn bus</p><p>RSCTL Output Signal List</p><p>FNCUGO\u2014functional unit GO indication</p><p>FUGNT<b>0</b>\u2014indicates for operand steer to drive the shared data busses into the FNCU</p><p>FUGNT<b>1</b>\u2014indicates for operand steer to drive the shared data busses into the FNCU</p><p>FUGNT<b>2</b>\u2014indicates for operand steer to drive the shared data busses into the FNCU</p><p>FUGNT<b>3</b>\u2014indicates for operand steer to drive the shared data busses into the FNCU</p><p>MULRQn\u2014request use of multiplier</p><p>R<b>0</b>SHF\u2014shift new data into entry <b>0</b></p><p>R<b>1</b>SHF\u2014shift new data into entry <b>1</b></p><p>R<b>2</b>SHF\u2014shift new data into entry <b>2</b></p><p>RSFULL\u2014reservation station full</p><p>Operand Steering</p><p>The operand steering sections purpose is to give an extra cycle to gather source data together for the reservation station or functional unit and to provide time to decode opcodes into two vectors of fully decoded control signals for the functional unit. Since several units may be sending data/tags to the operand steering block at the same time, the operand steering section uses the following priority: 1) tags, 2) FIROB data, 3) REGF. The incoming data for the two sources may also be in the incorrect position, and the operand steering section will need to swap the sources to the correct positions for the A and B operands. The operand steering section will also need to detect any forwarding and have RS<b>2</b> latch in the forwarded data. The operand steering section cannot issue directly to the functional unit while using forwarded data. Reservation station entries however can be issued to the functional unit while forwarded busses arrive at the FNCU inputs at the same cycle.</p><p>Tag Bus</p><p>The ATAG and BTAG busses are used for renaming when the actual operand value is not available to be sent to the reservation station. The tag takes the form of three bits representing the FIROB line. The entry position on the FIROB line is understood by the physical placement of each operand steering section. Since each functional unit only drives its own dedicated result bus, the reservation stations compare for the FIROB line value on the three bits of the corresponding result bus The tag entry on a given FIROB line is known by the physical placement of the FNCU and its dedicated result bus. The only exception is data for the LSRES<b>1</b> and LSRES<b>0</b> busses; the tag of the entry that made the load request is driven on the LSTAG<b>0</b> or LSTAG<b>1</b> busses. For example when the operation for FIROB line <b>2</b> entry <b>3</b> is waiting on the LSSEC for the load data, it will compare both the LSRES<b>0</b> and LSRES<b>1</b> busses for the <b>010</b>_<b>11</b> tag. Instead of watching for a tag from another FNCU, the reservation station is watching its own tag to be sent along with load data from the LSSEC.</p><p>Vector Generation for the Vector Bit Control Store (VBCS)</p><p>During the operand steering cycle, the two vectors per dispatch position entry will be generated. The FNCU does not have time to decode an opcode, execute the opcode, and generate flags in one cycle. The opcode generation has been pushed back in to the operand steering section while the flag generation has been pushed out to the cycle after execution. A seven bit opcode comes from decode to the operand steering section along with five bits of reservation station control protocol. This information and some other signals such as size, ahbyte, etc. are used by the operand steering section to generate the two vectors. Sometimes the first vector will be used for linear address generation while the second is used for the actual opcode. For the divide opcodes there will be a division direction signal held locally at the FNCUO. This signal determines when to use vector<b>0</b> (ADD) or vector<b>1</b> (SUB).</p><p>Reservation Station Protocol Control</p><p>This table is used to give control signals to the reservation station and decide what types of control vectors and status signals to generate.</p><p>OP\u2014operation only valid</p><p>(v<b>0</b>: na {<b>0</b>}; v<b>1</b>: operation {F})</p><p>TOP\u2014two opcode are fully supplied (not used by uCode) (fast path only)</p><p>(v<b>0</b>: decode supplied; v<b>1</b>: decode supplied)</p><p>V<b>12</b>\u2014v<b>0</b> fwd to v<b>1</b></p><p>(v<b>0</b>: Bop+const {I}; v<b>1</b>: operation {F})</p><p>LO\u2014Load-Operation</p><p>(v<b>0</b>: Bop+disp {Lw}; v<b>1</b>: operation {F})</p><p>after v<b>0</b>, BTAG=DTAG</p><p>LOS\u2014Load-OP-Store</p><p>(v<b>0</b>: Aop+disp {Lw}; v<b>1</b>: op &amp; store {M})</p><p>after v<b>0</b>, BTAG=DTAG</p><p>OS\u2014op-store</p><p>(v<b>0</b>: Aop+disp {L}); v<b>1</b>: op &amp; store {M})</p><p>SRB\u2014SRB info</p><p>(v<b>0</b>: na {<b>0</b>}; v<b>1</b>:pass Bop {S})</p><p>FLA\u2014fpu linear adr</p><p>(v<b>0</b>: Bop+disp {I}; v<b>1</b>: fwd+const {L})</p><p>unlike regular linear adr calc; this one immediately clears the resv_sta entry</p><p>BRN\u2014Branch eval</p><p>(v<b>0</b>: na {<b>0</b>}; v<b>1</b>: operation,brn eval {B})</p><p>LBR\u2014Load-brn (RET)</p><p>(v<b>0</b>: Aop+disp {Lw}; v<b>1</b>: operati on,brn eval {B})</p><p>SIB\u20141st pos SIB</p><p>(v<b>0</b>: Aop+scaled(Bop) {F}; v<b>1</b>: na {<b>0</b>})</p><p>PU\u2014Push</p><p>(v<b>0</b>: Aop-const {L,F} v<b>1</b>: op &amp; store {M})</p><p>POP\u2014Pop</p><p>(v<b>0</b>: Aop+const {F} v<b>1</b>: na {<b>0</b>})</p><p>DIV\u2014vector<b>0</b> or vector<b>1</b></p><p>(v<b>0</b>: ADD {F}; v<b>1</b>: SUB {F})</p><p>The following letters indicate which blocks should latch data off the RES bus (enclosed in { })</p><p><b>0</b> (nothing)</p><p>F (FIROB or FNCU forwarding)</p><p>L (linear address for store)</p><p>Lw (linear address for load; Res_sta changes Bop=DTAG and waits)</p><p>M (memory data for store only)</p><p>S (SRB)</p><p>B (Branch eval info for FIROB)</p><p>I (intermediate value; ignored for forwarding except for same Res sta)</p><p>Definitions of the Flag Equations and the Opcode Bus</p><p>Flag Equation Groups</p><p><tables id=\"TABLE-US-00028\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"right\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"119PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ADD_F</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">// flag equations for addition, sub,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2002etc.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LOG_F</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">// flag equations for logical</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMC_F</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">// flag equations for complement CF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BCD_FS</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">// flag equations for AAA, AAS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BCD_FC</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">// flag equations for AAA, AAS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DAA_FS1</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">// flag equations for DAA, DAS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STD_F</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">// flag equations for STD</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CLD_F</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">// flag equations for CLD</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The opcode groups form the first three bits of the opcode. A fourth bit may be needed if new opcodes are added.</p><p>Opcode Groups</p><p><tables id=\"TABLE-US-00029\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">G_ALU</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">G_XFR</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">G_SFT</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">G_BIT</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">G_MUL</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">G_DIV</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">//</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">G_IDIV</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">//</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Basic ALU Group</p><p><tables id=\"TABLE-US-00030\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"6\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"5\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ADD</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A + B</entry><entry morerows=\"0\" valign=\"top\">p=1001,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003g=110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OR</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A | B</entry><entry morerows=\"0\" valign=\"top\">p=1000,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003g=111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ADC</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A + B + CF</entry><entry morerows=\"0\" valign=\"top\">p=1001,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003g=110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SBB</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A \u2212 B + CF</entry><entry morerows=\"0\" valign=\"top\">p=O110,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003g=101</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">AND</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A &amp; B</entry><entry morerows=\"0\" valign=\"top\">p=1110,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003g=111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SUB</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A \u2212 B</entry><entry morerows=\"0\" valign=\"top\">p=0110,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003g=101</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">XOR</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A  B</entry><entry morerows=\"0\" valign=\"top\">p=1001,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003g=111</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"112PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MULH</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">this opcode is a NOP which</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003holds a res sta slot</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003and waits for</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">the 2nd multiply result to</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003request to drive data to</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003the FNCU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Branch and Extended ALU Group</p><p>(for BRN &gt;&gt;&gt; FNCU receives: A \u2190 EIP, disp \u2190 rel, B \u2190 pred addr)</p><p><tables id=\"TABLE-US-00031\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"77PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"5\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">JMPRI</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A</entry><entry morerows=\"0\" valign=\"top\">register indirect</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"133PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">(uncond); source = r16,r32, [r16+d16],</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">or [r32+d32] &amp; set R_BRN_ADR</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"77PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">JMP</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A + disp</entry><entry morerows=\"0\" valign=\"top\">jump relative (uncond)</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"140PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">&amp; set R_BRN_ADR</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"77PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">JMPCC</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A + disp</entry><entry morerows=\"0\" valign=\"top\">jump relative if</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"140PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">condition true &amp;</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">set R_BRN_OK, R_BRN_NT, or R_BRN<sub>\u2014</sub></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ADR</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"77PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">SETCC</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(0) &lt;- 1'b1</entry><entry morerows=\"0\" valign=\"top\">set result bit 0 if</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"140PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">condition true</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"77PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">ANDN</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A &amp; XB</entry><entry morerows=\"0\" valign=\"top\">p=1101, g=111</entry></row><row><entry morerows=\"0\" valign=\"top\">SUBR</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- B \u2212 A</entry><entry morerows=\"0\" valign=\"top\">p=0110, g=011</entry></row><row><entry morerows=\"0\" valign=\"top\">DFADD</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A + B</entry><entry morerows=\"0\" valign=\"top\">p=1001, g=110 &lt;-when</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"119PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EFLAGDF=0</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"77PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A \u2212 B</entry><entry morerows=\"0\" valign=\"top\">p=0110, g=101 &lt;-when</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"119PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EFLAGDF=1</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"77PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">MOVCC</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- B</entry><entry morerows=\"0\" valign=\"top\">p=1010, g=111 &lt;-when</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"119PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">condition is true</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"77PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A</entry><entry morerows=\"0\" valign=\"top\">p=1010, g=111 ignore</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"119PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">adder result and pass Aop when</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">cond. false</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>/ / * note: JMP w/ R \u2190 immed will be handled in the IFETCH for absolute jump using immediate value</p><p>Transfer Group</p><p><tables id=\"TABLE-US-00032\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"70PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"5\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">MOVSX</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- B</entry><entry morerows=\"0\" valign=\"top\">p=1010, g=111 sign</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003extend B</entry></row><row><entry morerows=\"0\" valign=\"top\">MOVZX</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- B</entry><entry morerows=\"0\" valign=\"top\">p=1010, g=111 zero</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003extend B</entry></row><row><entry morerows=\"0\" valign=\"top\">SIGNXA</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A</entry><entry morerows=\"0\" valign=\"top\">p=1100, g=111 sign</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003extend A</entry></row><row><entry morerows=\"0\" valign=\"top\">ZEROXA</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A</entry><entry morerows=\"0\" valign=\"top\">p=1100, g=111 zero</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003extend A</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"70PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">MOVDSPSX</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- disp</entry><entry morerows=\"0\" valign=\"top\">p=1010, g=111 sign</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003extend disp</entry></row><row><entry morerows=\"0\" valign=\"top\">MOVDSPZX</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- disp</entry><entry morerows=\"0\" valign=\"top\">p=1010, g=111 zero</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003extend disp</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"112PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">LEAA</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">\u2003R &lt;- A+disp\u2003p=1001, g=110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">loads effective address (Aside)</entry></row><row><entry morerows=\"0\" valign=\"top\">LEAB</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">\u2003R &lt;- B+disp p=1001, g=110 loads</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">effective address (Bside)</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Shift Group</p><p><tables id=\"TABLE-US-00033\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"right\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"112PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ROL</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">rotate left</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ROR</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">rotate right</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCL_1</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">rotate left through carry (1 bit</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">only)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCR_1</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">rotate right through carry (1 bit</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">only)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHL</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">shift left arithmetic or logical</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHR</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">shift right logical</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCO</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">initial step of rotate through</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">carry sequence</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SAR</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">shift right arithmetic</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Bit Group</p><p><tables id=\"TABLE-US-00034\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"right\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BT</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">bit test</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LAHF</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">load flags into AH</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003R &lt;- flags</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">(sf:zf:00:af:00:pf:00:df)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SAHF</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">store AH into flags R &lt;- A;</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">flags &lt;- A(low byte)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">(sf:zf:00:af:00:pf:00:df)</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVF</entry><entry morerows=\"0\" valign=\"top\">// combine Bop and flag to form result</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVOF</entry><entry morerows=\"0\" valign=\"top\">// overwrite the OF position of Bop to</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003form result</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVDF</entry><entry morerows=\"0\" valign=\"top\">// overwrite the DF position of Bop to</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003form result</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"right\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"98PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BSF</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">bit scan forward</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BSR</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">bit scan reverse</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTS</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">bit test and set</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTR</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">bit test and reset</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTC</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">bit test and complement</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Multiply Group</p><p><tables id=\"TABLE-US-00035\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"right\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"133PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">MUL16</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(word) &lt;- A * B(byte)</entry></row><row><entry morerows=\"0\" valign=\"top\">IMUL16</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(word) &lt;- A * B(byte)</entry></row><row><entry morerows=\"0\" valign=\"top\">IMUL16S</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(word) &lt;- A * B(word)</entry></row><row><entry morerows=\"0\" valign=\"top\">MUL32</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(low word) &lt;- A * B(word);</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">allocate high word with MULH</entry></row><row><entry morerows=\"0\" valign=\"top\">IMUL32</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(low word) &lt;- A * B(word);</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">allocate high word with MULH</entry></row><row><entry morerows=\"0\" valign=\"top\">IMUL32S</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(dword) &lt;- A * B(dword)</entry></row><row><entry morerows=\"0\" valign=\"top\">MUL64</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(low dword) &lt;- A * B(dword);</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">allocate high dword with MULH</entry></row><row><entry morerows=\"0\" valign=\"top\">IMUL64</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(low dword) &lt;- A * B(dword);</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">allocate high dword with MULH</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">if result fits in A then CF=OF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003else CF=OF=1; SF=ZF=AF=PF=xxx</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>DIV Group</p><p><tables id=\"TABLE-US-00036\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DIV</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=1001, g=110 &lt;-when SDF= 0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0110, g=101 &lt;-when SDF= 1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DIVL</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=1001, g=110 &lt;-when SDF= 0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0110, g=101 &lt;-when SDF= 1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DIVO</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DIVREM</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=1001, g=110 &lt;-when SDF= 0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=1100, g=111 &lt;-when SDF= 1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DIVCMP</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0110, g=101</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DIVQ</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"126PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DIV_X0</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">// not used</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DIV_X1</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">// not used</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>IDIV Group</p><p><tables id=\"TABLE-US-00037\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"70PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIVSGN</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0110, g=101</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIVCMP</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0011, g=111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0011, g=111</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"70PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIVDEND0</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0011, g=111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIVDEND1</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0011, g=111</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"70PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIVSOR</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0011, g=111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIVQ</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0011, g=111</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"98PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIV_X0</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">// not used</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIV_X1</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">// not used</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The following two groups of encodings indicate what the RES bus of the functional unit contains.</p><p>Status Signals for RES Bus</p><p>[<b>10</b>:<b>0</b>] INSLSB indicates segment information for LSSEC</p><p>F<b>0</b>BRN_ADR; assert proper branch status</p><p>F<b>0</b>BRN_NT; assert proper branch status</p><p>F<b>0</b>BRN_OK; assert proper branch status</p><p>F<b>0</b>BRN_T_ADR; assert proper branch status</p><p>F<b>0</b>BRN_T_OK; assert proper branch status</p><p>F<b>0</b>STAT_LD; RES bus status\u2014load linear address</p><p>F<b>0</b>STAT_MUL; RES bus status\u2014mulitplier</p><p>F<b>0</b>STAT_NONE; RES bus status\u2014no result</p><p>F<b>0</b>STAT_OPST; RES bus status\u2014operand data for a store</p><p>F<b>0</b>STAT_SRB; RES bus status\u2014SRB information</p><p>F<b>0</b>STAT_ST; RES bus status\u2014store linear address</p><p>F<b>0</b>STAT_VAL; RES bus status\u2014valid</p><p>[<b>10</b>:<b>0</b>] INSLSB; LSSEC segment MUX</p><p>[<b>2</b>:<b>0</b>] DTAG; destination tag</p><p>Operand Steering Section Signal List</p><p>Inputs from the REGF and FIROB</p><p>FLAGCFDATn; CF flag from FIROB</p><p>FLAGXFDATn; CF flag from FIROB</p><p>RESET; resets all processes in the multiplier and GRNT_CNT</p><p>ROBDCKnDAT<b>1</b>; use the data from FIROB for pointer <b>1</b></p><p>ROBDCKnDAT<b>2</b>; use the data from FIROB for pointer <b>2</b></p><p>SWAPPTR<b>1</b>W<b>2</b>; swap pointer <b>1</b> data with pointer <b>2</b> data</p><p>VATIn; A TAG is valid\u2014don't use data for Aoperand</p><p>VBTIn; B TAG is valid\u2014don't use data for Boperand</p><p>VCFTIn; CF TAG is valid\u2014don't use data for carry flag</p><p>VFLAGCFnD; valid flag data on the CF flag bus</p><p>VFLAGXFnD; valid flag data on the status flag bus</p><p>VSFTIn; XF TAG is valid\u2014don't use data for status flags</p><p>[<b>2</b>:<b>0</b>] DESTAGn; destination tag which indicates the ID of entry</p><p>[<b>31</b>:<b>0</b>] DISPIMM; displacement and immediate data (immediate will go to Bop bus)</p><p>[<b>31</b>:<b>0</b>] RBnDAT<b>1</b>; FIROB data for pointer<b>1</b></p><p>[<b>31</b>:<b>0</b>] RDnREG<b>1</b>; data from the register read of pointer <b>1</b></p><p>[<b>31</b>:<b>0</b>] RDnREG<b>2</b>; data from the register read of pointer <b>2</b></p><p>[<b>3</b>:<b>0</b>] CONSTD; four bits of constant offsets for PUSHes, POPs, and FPU linear addresses</p><p>[<b>4</b>:<b>0</b>] ATAGIn; A tag</p><p>[<b>4</b>:<b>0</b>] BTAGIn; B tag</p><p>[<b>4</b>:<b>0</b>] CFTAGIn; CF tag</p><p>[<b>4</b>:<b>0</b>] SFTAGIn; XF tag</p><p>Inputs from the Decode/ucode</p><p>RD_DEP_DS; entry specific read bit for DS; entry wait if both read and write are set</p><p>RD_DEP_ES; entry specific read bit for ES; entry wait if both read and write are set</p><p>RD_DEP_FS; entry specific read bit for FS; entry wait if both read and write are set</p><p>RD_DEP_GS; entry specific read bit for GS; entry wait if both read and write are set</p><p>VALPOS; valid entry going from op steer to RS<b>2</b></p><p>WRDS; global bit for write to DS</p><p>WRES; global bit for write to ES</p><p>WRFS; global bit for write to FS</p><p>WRGS; global bit for write to GS</p><p>[<b>3</b>:<b>0</b>] FLGEQ_CC_CHK; flag equation or condition code checks</p><p>[<b>3</b>:<b>0</b>] OPSIZE; size position of result (dword, word, ah, al)</p><p>[<b>3</b>:<b>0</b>] SEGSEL; LSSEC segment MUX select</p><p>[<b>4</b>:<b>0</b>] PROTOCOL; determines protocol (ie: LOS, MUL, DIV, etc.) RQLAC AXBLAC</p><p>[<b>6</b>:<b>0</b>] OPCODE<b>2</b>; this is for extra control of vector <b>2</b> by the fast path (not for ucode)\u2014might this remove later</p><p>[<b>6</b>:<b>0</b>] OPCODE; the main opcode for both fast path and ucode</p><p>Outputs for the Reservation Station Control</p><p>MULCYC2\u00d73N; number of multiply cycles is 2, else use 3</p><p>RSRD_DEP_DS; entry specific read bit for DS; entry wait if both read and write are set</p><p>RSRD_DEP_ES; entry specific read bit for ES; entry wait if both read and write are set</p><p>RSRD_DEP_FS; entry specific read bit for FS; entry wait if both read and write are set</p><p>RSRD_DEP_GS; entry specific read bit for GS; entry wait if both read and write are set</p><p>[<b>10</b>:<b>0</b>] RSPROTOCOL; determines protocol (ie: LOS, SRB, DIV, etc.)</p><p>Outputs for the Reservation Station Entries</p><p>FLGCFDATn; CF flag from FIROB</p><p>FLGXFDATn; CF flag from FIROB</p><p>VATn; A TAG is valid\u2014don't use data for Aoperand</p><p>VBTn; B TAG is valid\u2014don't use data for Boperand</p><p>VCFTn; CF TAG is valid\u2014don't use data for carry flag</p><p>VFLGCFnD; valid flag data on the CF flag bus</p><p>VFLGXFnD; valid flag data on the status flag bus</p><p>VSFTn; XF TAG is valid\u2014don't use data for status flags</p><p>[<b>10</b>:<b>0</b>] INSSEG; LSSEC segment MUX select</p><p>[<b>2</b>:<b>0</b>] CDTAG; current destination tag for the incoming opcode</p><p>[<b>31</b>:<b>0</b>] AOPND; A operand</p><p>[<b>31</b>:<b>0</b>] BOPND; B operand</p><p>[<b>31</b>:<b>0</b>] DSPR; displacement</p><p>[<b>3</b>:<b>0</b>] CONST; constant offset value for PUSHes, POPes, FPU linear addresses</p><p>[<b>4</b>:<b>0</b>] ATAGn; A tag</p><p>[<b>4</b>:<b>0</b>] BTAGn; B tag</p><p>[<b>4</b>:<b>0</b>] CFTAGn; CF tag</p><p>[<b>4</b>:<b>0</b>] SFTAGn; XF tag</p><p>Outputs for Control Store\u2014Shared for both Vectors (for FNCU<b>0</b> only)</p><p>F<b>0</b>CTLST_VWR; valid control store write next cycle</p><p>F<b>0</b>DIV<b>0</b>; initial divide opcode</p><p>F<b>0</b>DIV; divide opcode</p><p>F<b>0</b>DIVCMP; divide opcode</p><p>F<b>0</b>DIVL; divide opcode</p><p>F<b>0</b>DIVQ; divide opcode</p><p>F<b>0</b>DIVREM; divide opcode</p><p>F<b>0</b>DIVSGN; divide opcode</p><p>F<b>0</b>IDIVCMP; divide opcode</p><p>F<b>0</b>IDIVDEND<b>0</b>; divide opcode</p><p>F<b>0</b>IDIVDEND<b>1</b>; divide opcode</p><p>F<b>0</b>IDIVSOR; divide opcode</p><p>F<b>0</b>SELOPA; The initial quotient is from operand A else from adder output</p><p>F<b>0</b>UPDDF; update division direction bit</p><p>F<b>0</b>UPDQ; update division quotient</p><p>SELSQXOPA; indicates that quotient gets shifted quotient slave instead of adder or OPA</p><p>[<b>3</b>:<b>0</b>] F<b>0</b>CTLST_WR; indicates which control store vector to use</p><p>[<b>7</b>:<b>0</b>] F<b>0</b>CTLST_USE; indicates which control store vector to use</p><p>Outputs for Control Store\u2014Shared for Both Vectors FNCU<b>1</b>, FNCU<b>2</b>, and FNCU<b>3</b></p><p>F<b>0</b>CTLST_VWR; valid control store write next cycle</p><p>[<b>3</b>:<b>0</b>] F<b>0</b>CTLST_WR; indicates which control store vector to use</p><p>[<b>7</b>:<b>0</b>] F<b>0</b>CTLST_USE; indicates which control store vector to use</p><p>[<b>7</b>:<b>0</b>] FRESMUX; select lines for MUX to RES bus</p><p>Outputs for Control Store\u2014Vector <b>0</b>; No Shifts Allowed</p><p>AXBLAC<b>0</b>; indicates if operand A or B is used for linear addr calc</p><p>F<b>0</b>ADD_F<b>0</b>; addition type flag generation</p><p>F<b>0</b>BCD_FC<b>0</b>; BCD clear type flag generation</p><p>F<b>0</b>BCD_FS<b>0</b>; BCD set type flag generation</p><p>F<b>0</b>CIN<b>0</b>; carry-in from the control block</p><p>F<b>0</b>CLD_F<b>0</b>; clear direction flag generation</p><p>F<b>0</b>CMC_F<b>0</b>; complement carry type flag generation</p><p>F<b>0</b>COMPB<b>0</b>; complement the B operand</p><p>F<b>0</b>COND_CODE<b>0</b>; evaluate condition codes</p><p>F<b>0</b>DAA_FS<b>0</b>; DAA type flag generation</p><p>F<b>0</b>FLAGCF<b>0</b>; opcode requires using a version of EFLAGSCF</p><p>F<b>0</b>LOG_F<b>0</b>; logical type flag generation</p><p>F<b>0</b>MOVCC<b>0</b>; MOVCC instruction</p><p>F<b>0</b>MUXCIN<b>0</b>; carry-in MUX</p><p>F<b>0</b>MUXDF<b>0</b>; direction flag MUX</p><p>F<b>0</b>SETCC<b>0</b>; SETCC-instruction</p><p>F<b>0</b>SETCF<b>0</b>; ADC uses true version of EFLAGSCF else \u02dcEFLAGSCF</p><p>F<b>0</b>STD_F<b>0</b>; store direction flag generation</p><p>F<b>0</b>UNC_BRN<b>0</b>; unconditional branch evaluation</p><p>FISTAT_BRN<b>0</b>; assert proper branch status</p><p>FISTAT_LD<b>0</b>; RES bus status\u2014load linear address</p><p>FISTAT_MUL<b>0</b>; RES bus status\u2014mulitplier</p><p>FISTAT_NONE<b>0</b>; RES bus status\u2014no result</p><p>FISTAT_OPST<b>0</b>; RES bus status\u2014operand data for a store</p><p>FISTAT_SRB<b>0</b>; RES bus status\u2014SRB information</p><p>FISTAT_ST<b>0</b>; RES bus status\u2014store linear address</p><p>FISTAT_VAL<b>0</b>; RES bus status\u2014valid</p><p>RQLAC<b>0</b>; linear address calculation</p><p>SIGNXA<b>0</b>; sign extend the A operand</p><p>SIGNXB<b>0</b>; sign extend the B operand</p><p>SIGNXD<b>0</b>; sign extend the D operand</p><p>USEOFFSET<b>0</b>; use offset for PUSH, POP, or FPU lin adr calc</p><p>ZEROXA<b>0</b>; zero extend the A operand</p><p>ZEROXB<b>0</b>; zero extend the B operand</p><p>ZEROXD<b>0</b>; zero extend the D operand</p><p>[<b>1</b>:<b>0</b>] AHBYTE<b>0</b>; alignment select bits<b>0</b>; move bits <b>15</b>:<b>8</b> to <b>7</b>:<b>0</b></p><p>[<b>2</b>:<b>0</b>] F<b>0</b>GIN<b>0</b>; generate style inputs (used here to indicate type of operation)</p><p>[<b>3</b>:<b>0</b>] F<b>0</b>PIN<b>0</b>; propagate style inputs (used here to indicate type of operation)</p><p>[<b>3</b>:<b>0</b>] OPSIZEIN<b>0</b>; size position of result (dword, word, ah, al)</p><p>[<b>4</b>:<b>0</b>] F<b>0</b>SCALE<b>0</b>; scale for SIB: <b>8</b>,<b>4</b>,<b>2</b>,<b>1</b>,<b>0</b></p><p>[<b>7</b>:<b>0</b>] FRESMUX<b>0</b>; select lines for MUX to RES bus</p><p>Outputs for Control Store\u2014Vector <b>1</b>; Shifts Allowed</p><p>AXBLAC<b>1</b>; indicates if operand A or B is used for linear addr calc</p><p>F<b>0</b>ADD_F<b>1</b>; addition type flag generation</p><p>F<b>0</b>BCD_FC<b>1</b>; BCD clear type flag generation</p><p>F<b>0</b>BCD_FS<b>1</b>; BCD set type flag generation</p><p>F<b>0</b>CIN<b>1</b>; carry-in from the control block</p><p>F<b>0</b>CLD_F<b>1</b>; clear direction flag generation</p><p>F<b>0</b>CMC_F<b>1</b>; complement carry type flag generation</p><p>F<b>0</b>COMPB<b>1</b>; complement the B operand</p><p>F<b>0</b>COND_CODE<b>1</b>; evaluate condition codes</p><p>F<b>0</b>DAA_FS<b>1</b>; DAA type flag generation</p><p>F<b>0</b>FLAGCF<b>1</b>; opcode requires using a version of EFLAGSCF</p><p>F<b>0</b>LOG_F<b>1</b>; logical type flag generation</p><p>F<b>0</b>MOVCC<b>1</b>; MOVCC instruction</p><p>F<b>0</b>MUXCIN<b>1</b>; carry-in MUX</p><p>F<b>0</b>MUXDF<b>1</b>; direction flag MUX</p><p>F<b>0</b>SETCC<b>1</b>; SETCC instruction</p><p>F<b>0</b>SETCF<b>1</b>; ADC uses true version of EFLAGSCF else \u02dcEFLAGSCF</p><p>F<b>0</b>STD_F<b>1</b>; store direction flag generation</p><p>F<b>0</b>UNC_BRN<b>1</b>; unconditional branch evaluation</p><p>FISTAT_BRN<b>1</b>; assert proper branch status</p><p>FISTAT_LD<b>1</b>; RES bus status\u2014load linear address</p><p>FISTAT_MUL<b>1</b>; RES bus status\u2014mulitplier FISTAT_NONE<b>1</b>; RES bus status\u2014no result FISTAT_OPST<b>1</b>; RES bus status\u2014operand data for a store</p><p>FISTAT_SRB<b>1</b>; RES bus status\u2014SRB information FISTAT_ST<b>1</b>; RES bus status\u2014store linear address</p><p>FISTAT_VAL<b>1</b>; RES bus status\u2014valid</p><p>RQLAC<b>1</b>; linear address calculation</p><p>SHFBCMP<b>1</b>; indicates a Bit Test and Complement</p><p>SHFBITEST<b>1</b>; a select signal for any Bit Test opcode</p><p>SHFBITOPA<b>1</b>; a select signal for only the BTEST (BT) opcode</p><p>SHFBSF<b>1</b>; select signal for Bit Scan Forward</p><p>SHFBSR<b>1</b>; select signal for Bit Scan Reverse</p><p>SHFBSXR<b>1</b>; indicates a set/reset for bit test instruction</p><p>SHFEFLAG<b>1</b>; merge Bop &amp; all flags into result</p><p>SHFFLGDF<b>1</b>; overwrite the DF position of Bop to form result</p><p>SHFFLGOF<b>1</b>; overwrite the OF position of Bop to form result</p><p>SHFLAHF<b>1</b>; load Flags into AH opcode</p><p>SHFLEFT<b>1</b>; indicates RCL, ROL, or SHL opcode</p><p>SHFRIGHT<b>1</b>; indicates RCR, ROR, SAR, or SHR opcode</p><p>SHFROT<b>1</b>; indicates a rotate or SHL opcode</p><p>SHFSAHF<b>1</b>; store AH into Flags opcode</p><p>SHFSELSF<b>31</b>_<b>1</b>; set the sign flag to the shifter output bit <b>31</b></p><p>SHFSETCF<b>1</b>; set carry flag for RCL &amp; RCR equal to EFLAGSCF</p><p>SHF_UPD_RC<b>1</b>; select for updating the local carry flag</p><p>SIGNXA<b>1</b>; sign extend the A operand</p><p>SIGNXB<b>1</b>; sign extend the B operand</p><p>SIGNXD<b>1</b>; sign extend the D operand</p><p>USEOFFSET<b>1</b>; use offset for PUSH, POP, or FPU lin adr calc</p><p>ZEROXA<b>1</b>; zero extend the A operand</p><p>ZEROXB<b>1</b>; zero extend the B operand</p><p>ZEROXD<b>1</b>; zero extend the D operand</p><p>[<b>1</b>:<b>0</b>] AHBYTE<b>1</b>; alignment select bits<b>0</b>; move bits <b>15</b>:<b>8</b> to <b>7</b>:<b>0</b></p><p>[<b>21</b>:<b>0</b>] SHFSELPRE<b>1</b>; the preshift mux select signals</p><p>[<b>2</b>:<b>0</b>] F<b>0</b>GIN<b>1</b>; generate style inputs (used here to indicate type of operation)</p><p>[<b>2</b>:<b>0</b>] SHFSELZF<b>1</b>; determines which groups of bit to use for setting the zero flag</p><p>[<b>3</b>:<b>0</b>] F<b>0</b>PIN<b>1</b>; propagate style inputs (used here to indicate type of operation)</p><p>[<b>3</b>:<b>0</b>] OPSIZEIN<b>1</b>; size/position of result (dword, word, ah, al)</p><p>[<b>3</b>:<b>0</b>] SHFSELOF<b>1</b>; determines which groups of bit to use for setting the overflow flag</p><p>[<b>3</b>:<b>0</b>] SHFSELOUT<b>1</b>; indicates final byte alignment for the shifter output</p><p>[<b>7</b>:<b>0</b>] FRESMUX<b>1</b>; select lines for MUX to RES bus</p><p>[<b>7</b>:<b>0</b>] SHFSELCF<b>1</b>; determines which shifter bits to use to set the carry flag</p><p>[<b>9</b>:<b>0</b>] SHFSELCNT<b>1</b>; mux select signals determining source of shifter count value</p><p>Functional Unit (FNCU)</p><p>This section covers the functional unit (FNCU) which contains the ALU, branch evaluation, and shifter. The six sub blocks of the FNCU are the CBVS (control bit vector store), the OPSEL (operand selection and alignment), the ALU (for logical and arithmetic operations), the SHFT (shifter), the FLGCC (flag generations, branch/condition code evaluation), and the MXDVR (output multiplier, alignment, and drivers). An overview of basic flow (shown in FIG. 31) is that all opcode, tag, and operand information goes to the operand steering section where the appropriate information is determined and driven onto the A operand, B operand, A tag, B tag, and other busses. Also some decode is done in the operand steering section for such information as the P and G bits for the given opcode. The operand steering section drives RS<b>2</b> of the reservation station block. Reservation station control logic latches in tags at the beginning of the cycle, compares to determine if forwarding can be done, and prioritizes which reservation station will drive the FNCU. At the beginning of the next cycle the DTAG for the opcode to be executed that cycle is driven out to allow other reservation stations to forward during the following cycle. Then a short delay is given to allow the latched in MUX controls, the P and G bits, and other input information to set up the adder or shifter. Then if needed, the B operand can be aligned (bits <b>15</b>:<b>8</b> to <b>7</b>:<b>0</b>, or scaled 1\u00d7,2\u00d7,4\u00d7,8\u00d7) or complemented. The execution (add, and, shift, etc) then takes place, and the output of the adder is driven ASAP for bits <b>14</b>:<b>0</b> to the RESLA bus. Two control bit vectors can be used by each entry in the reservation station. These vectors come from decoding logic in the operand steering block and the Idecode block. For example one vector could be for linear address calculation while the second is for the actual operation. Another example is that one vector could represent an ADD while the other represents a SUB and the division direction flag would be used to choose the vector to use. The FDRES bus drives (with minimum capacitive load) to the input MUXes of the FNCUs. The FDRES bus also is buffered to become the RES (result) bus which goes to the reservation stations (not for immediate forwarding), LSSEC, and the FIROB data block.</p><p>Branch evaluations are performed in the FNCU with a branch address being generated along with a branch status. Logical load/store address are calculated in the FNCU and sent out on the LSSEC bus (also RESLA) bus with a corresponding encoding on the status bus to identify them. Multiply operands are sent from the reservation station onto the A operand and B operand busses and then onto the shared tristate SAOPND and SBOPND busses (shared A operand) to the multiplier and the floating point unit.</p><p>RFLAGs (result flags: {ZF,AF,PF,SF,DF,OF }) are generated the during the cycle following the execution of the corresponding opcode. The carry flag {CF} is generated the same cycle that the result gets generated. A block diagram of a functional unit is shown as FIG. <b>32</b>.</p><p>Basic Flow of Operands to the FNCU</p><p>This section will cover the general flow of operands meeting up with their opcodes. For more detailed descriptions, refer to the sections on operand steering and on dependency checking. Forwarding is used here to indicate that a unit other than the FIROB has watched the DTAG busses and LSTAG busses for a renamed value (eg: EAX renamed to DTAG=<b>2</b>_<b>0</b>) and latched the value off of the corresponding result bus. The operand steering blocks, the 12 reservation stations, and the FNCU can all receive data by forwarding; the multiplier cannot. In some cases such as receiving load data from the LSRES busses, both the FNCU and the reservation station can receive the forwarded data. The FNCU will execute the opcode using the forwarded data, and the reservation station that issued that opcode would hold the entry for an extra cycle just in case a miss or way_misprediction signal comes back. In the following example, the B, C, and D instructions are all waiting for data that is generated by the A instruction.</p><p>Example</p><p><tables id=\"TABLE-US-00038\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"126PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">instruction</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">ID</entry><entry morerows=\"0\" valign=\"top\">instruction</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">A</entry><entry morerows=\"0\" valign=\"top\">DTAG=1_0\u2003ADD EAX,immed</entry></row><row><entry morerows=\"0\" valign=\"top\">B</entry><entry morerows=\"0\" valign=\"top\">DTAG=2_1\u2003SUB EBX,EAX</entry></row><row><entry morerows=\"0\" valign=\"top\">C</entry><entry morerows=\"0\" valign=\"top\">DTAG=3_0\u2003XOR ECX,EAX</entry></row><row><entry morerows=\"0\" valign=\"top\">D</entry><entry morerows=\"0\" valign=\"top\">DTAG=4_3\u2003OR\u2002 EDX,EAX</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"182PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Cycle</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"6\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"6\" colwidth=\"35PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">Stage</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">4</entry><entry morerows=\"0\" valign=\"top\">5</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"6\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">dep. chec</entry><entry morerows=\"0\" valign=\"top\">inst A</entry><entry morerows=\"0\" valign=\"top\">inst B</entry><entry morerows=\"0\" valign=\"top\">inst C</entry><entry morerows=\"0\" valign=\"top\">inst D</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">decode</entry><entry morerows=\"0\" valign=\"top\">dtag= 1_0</entry><entry morerows=\"0\" valign=\"top\">dtag= 2_1</entry><entry morerows=\"0\" valign=\"top\">dtag= 3_0</entry><entry morerows=\"0\" valign=\"top\">dtag= 4_3</entry></row><row><entry morerows=\"0\" valign=\"top\">REGF</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">btag= 1_0</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EAX from</entry></row><row><entry morerows=\"0\" valign=\"top\">access</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">regf</entry></row><row><entry morerows=\"0\" valign=\"top\">operand</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">inst A</entry><entry morerows=\"0\" valign=\"top\">inst B</entry><entry morerows=\"0\" valign=\"top\">inst C</entry><entry morerows=\"0\" valign=\"top\">inst D</entry></row><row><entry morerows=\"0\" valign=\"top\">steering</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">dtag= 1_0</entry><entry morerows=\"0\" valign=\"top\">dtag= 2_1</entry><entry morerows=\"0\" valign=\"top\">dtag= 3_0</entry><entry morerows=\"0\" valign=\"top\">dtag= 4_3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">btag= 1_0</entry><entry morerows=\"0\" valign=\"top\">EAX from</entry><entry morerows=\"0\" valign=\"top\">EAX from</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">FIROB</entry><entry morerows=\"0\" valign=\"top\">regf</entry></row><row><entry morerows=\"0\" valign=\"top\">execute</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">inst A</entry><entry morerows=\"0\" valign=\"top\">inst B</entry><entry morerows=\"0\" valign=\"top\">inst C</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">dtag= 1_0</entry><entry morerows=\"0\" valign=\"top\">dtag= 2_1</entry><entry morerows=\"0\" valign=\"top\">dtag= 3_0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">forwarding</entry></row><row><entry morerows=\"0\" valign=\"top\">writeback</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">inst A</entry><entry morerows=\"0\" valign=\"top\">inst B</entry></row><row><entry morerows=\"0\" valign=\"top\">(same as</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">dtag= 1_0</entry><entry morerows=\"0\" valign=\"top\">dtag= 2_1</entry></row><row><entry morerows=\"0\" valign=\"top\">dep check</entry></row><row><entry morerows=\"0\" valign=\"top\">stage)</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"6\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The B instruction uses forwarding to get the operand steering section to receive the EAX result from the A instruction. The C instruction gets its EAX data from the FIROB, and the D instruction gets its EAX data from the REGF. The \u201cA\u201d result tags are driven through cycle 3 so that any other reservation stations or the operand steering section can detect BTAG=<b>1</b>_<b>0</b> and latch the \u201cA\u201d result value at the end of cycle 3. No \u201cA\u201d result tag information is being broadcast in cycle 4, so the C instruction cannot receive EAX by forwarding. This example assumes that the FIROB is writing back every cycle; otherwise, the D instruction would also get its EAX data from the FIROB if EAX had not been written back yet. The operand steering must have tag compare logic inside it to get the EAX operand.</p><p>ALU/Shift/Rotate/Branch Opcodes</p><p>The following encodings determine which flag equations to generate. Separate signals are sent from the Idecode to the FIROB to indicate which combination of the three flag groups gets written back by the FIROB to the EFLAGSO (standard) or EFLAGS<b>1</b> (scratch) registers.</p><p>Flag Equation Groups</p><p><tables id=\"TABLE-US-00039\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"right\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"112PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">ADD_F</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">flag equations for addition, sub,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">etc.</entry></row><row><entry morerows=\"0\" valign=\"top\">LOG_F</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">flag equations for logical</entry></row><row><entry morerows=\"0\" valign=\"top\">CMC_F</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">flag equations for complement CF</entry></row><row><entry morerows=\"0\" valign=\"top\">BCD_FS</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">flag equations for AAA, AAS</entry></row><row><entry morerows=\"0\" valign=\"top\">BCD_FC</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">flag equations for AAA, AAS</entry></row><row><entry morerows=\"0\" valign=\"top\">DAA_FS1</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">flag equations for DAA, DAS</entry></row><row><entry morerows=\"0\" valign=\"top\">STD_F</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">flag equations for STD</entry></row><row><entry morerows=\"0\" valign=\"top\">CLD_F</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">flag equations for CLD</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Basic ALU Group</p><p><tables id=\"TABLE-US-00040\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"6\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"right\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"63PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"5\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ADD</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A + B</entry><entry morerows=\"0\" valign=\"top\">p=1001, g=110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OR</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A | B</entry><entry morerows=\"0\" valign=\"top\">p=1000, g=111</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"6\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"right\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"49PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ADC</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A + B + CF</entry><entry morerows=\"0\" valign=\"top\">p=1001, g=110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SBB</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A \u2212 B + CF</entry><entry morerows=\"0\" valign=\"top\">p=0110, g=101</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"6\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"right\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">AND</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A &amp; B</entry><entry morerows=\"0\" valign=\"top\">p=1110, g=111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SUB</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A \u2212 B</entry><entry morerows=\"0\" valign=\"top\">p=0110, g=101</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">XOR</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A B</entry><entry morerows=\"0\" valign=\"top\">p=1001, g=111</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"right\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"112PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MULH</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">this opcode is a NOP which holds</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003a res sta slot and waits for</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">the 2nd multiply result to</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">request to drive data to the FNCU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Branch and Extended ALU Group</p><p>(for BRN &gt;&gt;&gt; FNCU receives: A \u2190 EIP, disp \u2190 rel, B \u2190 pred addr)</p><p><tables id=\"TABLE-US-00041\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"56PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"5\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">JMPRI</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A</entry><entry morerows=\"0\" valign=\"top\">register</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"119PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">indirect (uncond) ;</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"126PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">source = r16,r32, [r16+d16], or</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"119PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">[r32+d32] &amp; set R_BRN_ADR</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"56PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">JMP</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A + disp</entry><entry morerows=\"0\" valign=\"top\">jump relative</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">(uncond)</entry><entry morerows=\"0\" valign=\"top\">&amp; set R_BRN_ADR</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"56PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">JMPCC</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A + disp</entry><entry morerows=\"0\" valign=\"top\">jump relative if</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"119PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">condition true &amp; set R_BRN_OK,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">R_BRN_NT, or R_BRN_ADR</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"56PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">SETCC</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(0) &lt;- 1'b1</entry><entry morerows=\"0\" valign=\"top\">set result bit 0</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"119PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">if condition true</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">ANDN</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A &amp; XB</entry><entry morerows=\"0\" valign=\"top\">p=1101, g=111</entry></row><row><entry morerows=\"0\" valign=\"top\">SUBR</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- B \u2212 A</entry><entry morerows=\"0\" valign=\"top\">p=0110, g=011</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"112PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">DFADD</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A + B p=1001, g=110 &lt;-when</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003EFLAGDF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A \u2212 B p=0110, g=101 &lt;-when</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003EFLAGDF=1</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"84PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">MOVCC</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- B</entry><entry morerows=\"0\" valign=\"top\">p=1010, g=111 &lt;-when</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"119PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"98PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">condition is true</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"84PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A</entry><entry morerows=\"0\" valign=\"top\">p=1010, g=111</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"119PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"98PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ignore adder result and</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">pass Aop when cond. false</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>/ / * note: JMP w/ R \u2190 immed will be handled in the IFETCH for absolute jump using immediate value</p><p>Transfer Group</p><p><tables id=\"TABLE-US-00042\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"119PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">MOVSX</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- B p=1010, g=111 sign</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003extend B</entry></row><row><entry morerows=\"0\" valign=\"top\">MOVZX</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- B p=1010, g=111 zero</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003extend B</entry></row><row><entry morerows=\"0\" valign=\"top\">SIGNXA</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A p=1100, g=111 sign</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003extend A</entry></row><row><entry morerows=\"0\" valign=\"top\">ZEROXA</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A p=1100, g=111 zero</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003extend A</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"126PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">MOVDSPSX</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- disp p=1010, g=111 sign</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003\u2003\u2003extend disp</entry></row><row><entry morerows=\"0\" valign=\"top\">MOVDSPZX</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- disp p=1010, g=111 zero</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003\u2003\u2003extend disp</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"119PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">LEAA</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- A+disp\u2003\u2003\u2003\u2003p=1001, g=110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003loads effective address</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003(Aside)</entry></row><row><entry morerows=\"0\" valign=\"top\">LEAB</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R &lt;- B+disp\u2003\u2003\u2003\u2003p=1001, g=110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003loads effective address</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003(Bside)</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Shift Group</p><p><tables id=\"TABLE-US-00043\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ROL</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">rotate left</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ROR</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">rotate right</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCL_1</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">rotate left through carry (1 bit</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">only)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCR_1</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">rotate right through carry (1 bit</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">only)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHL</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">shift left arithmetic or logical</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHR</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">shift right logical</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCO</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">initial step of rotate through</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">carry sequence</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SAR</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">shift right arithmetic</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Bit Group</p><p><tables id=\"TABLE-US-00044\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"right\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BT</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">bit test</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LAHF</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">load flags into AH</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">R &lt;- flags</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">(sf:zf:00:af:00:pf:00:df)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SAHF</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">store AH into flags R &lt;- A;</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">flags &lt;- A(low byte)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003(sf:zf:00:af:00:pf:00:df)</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"161PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVF</entry><entry morerows=\"0\" valign=\"top\">// combine Bop and flag to form result</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVOF</entry><entry morerows=\"0\" valign=\"top\">// overwrite the OF position of Bop to</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003form result</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVDF</entry><entry morerows=\"0\" valign=\"top\">// overwrite the DF position of Bop to</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003\u2003form result</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"right\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"105PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BSF</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">bit scan forward</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BSR</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">bit scan reverse</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTS</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">bit test and set</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTR</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">bit test and reset</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTC</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">bit test and complement</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Multiply Group</p><p><tables id=\"TABLE-US-00045\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"right\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"119PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">MUL16</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(word) &lt;- A * B(byte)</entry></row><row><entry morerows=\"0\" valign=\"top\">IMUL16</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(word) &lt;- A * B(byte)</entry></row><row><entry morerows=\"0\" valign=\"top\">IMUL16S</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(word) &lt;- A * B(word)</entry></row><row><entry morerows=\"0\" valign=\"top\">MUL32</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(low word) &lt;- A * B(word);</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">allocate high word with MULH</entry></row><row><entry morerows=\"0\" valign=\"top\">IMUL32</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(low word) &lt;- A * B(word);</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">allocate high word with MULH</entry></row><row><entry morerows=\"0\" valign=\"top\">IMUL32S</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(dword) &lt;- A * B(dword)</entry></row><row><entry morerows=\"0\" valign=\"top\">MUL64</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(low dword) &lt;- A * B(dword);</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">allocate high dword with MULH</entry></row><row><entry morerows=\"0\" valign=\"top\">IMUL64</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">R(low dword) &lt;- A * B(dword);</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">allocate high dword with MULH</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">if result fits in A then CF=OF=0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">else CF=OF=1; SF=ZF=AF=PF=xxx</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>DIV Group</p><p><tables id=\"TABLE-US-00046\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"112PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">DIV</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=1001, g=110 &lt;-when SDF= 0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0110, g=101 &lt;-when SDF= 1</entry></row><row><entry morerows=\"0\" valign=\"top\">DIVL</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=1001, g=110 &lt;-when SDF= 0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0110, g=101 &lt;-when SDF= 1</entry></row><row><entry morerows=\"0\" valign=\"top\">DIVO</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry></row><row><entry morerows=\"0\" valign=\"top\">DIVREM</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">\u2002p=1001, g=110 &lt;-when SDF= 0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">\u2002p=1100, g=111 &lt;-when SDF= 1</entry></row><row><entry morerows=\"0\" valign=\"top\">DIVCMP</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">\u2002p=0110, g=101</entry></row><row><entry morerows=\"0\" valign=\"top\">DIVQ</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"133PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">DIV_X0</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">// not used</entry></row><row><entry morerows=\"0\" valign=\"top\">DIV_X1</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">// not used</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>IDIV Group</p><p><tables id=\"TABLE-US-00047\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"70PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIVSGN</entry><entry morerows=\"0\" valign=\"top\">3'b000</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0110, g=101</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIVCMP</entry><entry morerows=\"0\" valign=\"top\">3'b001</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0011, g=111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0011, g=111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIVDEND0</entry><entry morerows=\"0\" valign=\"top\">3'b010</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0011, g=111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIVDEND1</entry><entry morerows=\"0\" valign=\"top\">3'b011</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0011, g=111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIVSOR</entry><entry morerows=\"0\" valign=\"top\">3'b100</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0011, g=111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIVQ</entry><entry morerows=\"0\" valign=\"top\">3'b101</entry><entry morerows=\"0\" valign=\"top\">//</entry><entry morerows=\"0\" valign=\"top\">p=0011, g=111</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"98PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIV_X0</entry><entry morerows=\"0\" valign=\"top\">3'b110</entry><entry morerows=\"0\" valign=\"top\">// not used</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIV_X1</entry><entry morerows=\"0\" valign=\"top\">3'b111</entry><entry morerows=\"0\" valign=\"top\">// not used</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The following two groups of encodings indicate what the RES bus of the functional unit contains.</p><p>Status Signals for RES Bus</p><p>[<b>10</b>:<b>0</b>] INSLSB indicates segment information for LSSEC</p><p>F<b>0</b>BRN_ADR; assert proper branch status</p><p>F<b>0</b>BRN_NT; assert proper branch status</p><p>F<b>0</b>BRN_OK; assert proper branch status</p><p>F<b>0</b>BRN_T_ADR; assert proper branch status</p><p>F<b>0</b>BRN_T_OK; assert proper branch status</p><p>F<b>0</b>STAT_LD; RES bus status\u2014load linear address</p><p>F<b>0</b>STAT_MUL; RES bus status\u2014mulitplier</p><p>F<b>0</b>STAT_NONE; RES bus status\u2014no result</p><p>F<b>0</b>STAT_OPST; RES bus status\u2014operand data for a store</p><p>F<b>0</b>STAT_SRB; RES bus status\u2014SRB information</p><p>F<b>0</b>STAT_ST; RES bus status\u2014store linear address</p><p>F<b>0</b>STAT_VAL; RES bus status\u2014valid</p><p>[<b>10</b>:<b>0</b>] INSLSB; LSSEC segment MUX</p><p>[<b>2</b>:<b>0</b>] DTAG; destination tag</p><p>ALU Sub-Block</p><p>This sub-block is used for calculating linear addresses needed by the LSSEC, performing comparisons, and for computing arithmetic operations. Operations such as DAA, DAS, AAA, AAS, AAM, and AAD will be done in microcode and will not receive direct support from the ALU except maybe for flag handling. The adder uses propagates and generates which are setup in the reservation stations based on the type of operation.</p><p>Shifter Sub Block The FNCU contains a barrel shifter which shifts the A operand by the amount indicated on the B operand. This unit handles bit manipulation instructions, counting leading zeroes/ones, and shifts and rotates. RCL and RCR by one is handled but microcode is used for RCL and RCR by more than one. There is a SHFT block which contains the data path portion of the shifter while the control logic is contained along with the ALU control logic in the FNCUCTL block. The output of the shifter has tristate drivers which drive the result bus. At the beginning of the cycle the opcode type is latched in from the reservation station and this information is used to decide if the ALU or the SHFT block will drive the result bus.</p><p>Branch Evaluation For branch instructions, the EIP value is sent on the A operand bus while the relative jump value is sent on the displacement bus. The B operand bus is used for the predicted address. For \u201cjump near indirect\u201d the jump address is the r/m<b>16</b> or r/m<b>32</b> loaded into the EIP. The control section of the functional unit evaluates whether the condition codes and the forwarded flags result in a branch taken or not taken. The same logic is also used for the SETcc opcode. Branch prediction information is sent by the branch prediction unit to the dispatch unit and then to the IFCORE. Four different cases for conditional branches are handled.</p><p><tables id=\"TABLE-US-00048\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Cond Code</entry><entry morerows=\"0\" valign=\"top\">Predicted</entry><entry morerows=\"0\" valign=\"top\">ALU</entry><entry morerows=\"0\" valign=\"top\">Status</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">not taken</entry><entry morerows=\"0\" valign=\"top\">not taken</entry><entry morerows=\"0\" valign=\"top\">EIP (Aopnd) + displacement</entry><entry morerows=\"0\" valign=\"top\">R_BRN_OK</entry></row><row><entry morerows=\"0\" valign=\"top\">not taken</entry><entry morerows=\"0\" valign=\"top\">taken</entry><entry morerows=\"0\" valign=\"top\">EIP (Aopnd) + displacement</entry><entry morerows=\"0\" valign=\"top\">R_BRN_NT</entry></row><row><entry morerows=\"0\" valign=\"top\">taken</entry><entry morerows=\"0\" valign=\"top\">not taken</entry><entry morerows=\"0\" valign=\"top\">EIP (Aopnd) + displacement</entry><entry morerows=\"0\" valign=\"top\">R_BRN_ADR</entry></row><row><entry morerows=\"0\" valign=\"top\">taken</entry><entry morerows=\"0\" valign=\"top\">taken</entry><entry morerows=\"0\" valign=\"top\">EIP (Aopnd) + displacement</entry><entry morerows=\"0\" valign=\"top\">R_BRN_ADR</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>For the case of a predicted taken branch, either the R_BRN_NT status shows that the branch was not taken, or the R_BRN_ADR indicates that the actual branch address will be compared to the predicted address using the flag evaluation unit and the result of that compare will be seen next cycle.</p><p>1st cycle RES_STA assign branch evaluation to FNCU for next cycle</p><p>2nd cycle EIP+d32; evaluate condition codes and flags (last cycle for predicted not taken)</p><p>3rd cycle Flags block compares the predicted branch address with the actual branch address. ZF=1 indicates that the two addresses are the same.</p><p>Output Drivers (Buffers/MUX) Sub Block</p><p>This block muxes the output data from either the adder, shifter, exception vector, or the MULTFP bus (for FNCU<b>0</b>). The linear address calculation uses the adder. Some bits, RESLAn(<b>14</b>:<b>5</b>), for the linear address are sent out to the data cache early while the entire result goes out on FDRESn(<b>31</b>:<b>0</b>) at the end of the cycle. The purpose of the FDRESn bus is to forward quickly to the input MUXes of all four functional units. RESn is a buffered version of FDRESn which is less time critical than FDRESn. The RESn bus drives the LSSEC, the FIROB, and all of the reservation stations. To determine which sub-block will be MUXed onto the FDRES bus, the opcode group indicator, the multiply request (also MULH mnemonic), exception information, linear address indication, and branch information are used.</p><p>Condition Flags Sub Block</p><p>Three flag groups are defined as follows: {CF}, {OF,ZF,SF,AF,PF,DF}, and {TF,IF,IOPL,NT,RF,VM,AC,VIF,VIP,ID}. These flags are generated during the next cycle after the FNCU executes. The carry flag will simply be the carry out from cell <b>31</b>, <b>15</b>, or <b>7</b> based on operand size. For the case of a subtract opcode, the carry flag is used to represent the borrow and is the inverted bit from the bit <b>31</b>, <b>15</b>, or <b>7</b> carry out. The parity flag is the even parity on the lowest byte which requires about 2*Order(log 2n)=6 gate levels. The sign flag is a mux of the highest order bit (<b>31</b>, <b>15</b>, or <b>7</b>). These flags are latched by the FIROB at the beginning of the next cycle and also forwarded to any FNCU looking for them. The dependency checking will be done individually on each of the three groups. The first two flag groups allow forwarding of the results while the last group will require serialization when a dependency is detected. The reservation station receives an early use signal from decode which corresponds to the two flag groups. This means that for a given opcode which is sitting in a reservation station entry and waiting on flags, an early use entry can issue the cycle right after the flag match is detected. Any other reservation station entry must wait an additional cycle before issuing to the functional units. The additional cycle is because the flags are generated the cycle after the functional unit executes. For instructions like ADC, the carry flag will be needed at the beginning of the cycle. For instructions like jump, the flags and condition codes start evaluating during the middle of the cycle. The conditional jumps, MOVCC, and SETCC opcodes get their flags forwarded during mid-cycle while all others wait until the beginning of one additional cycle.</p><p>In addition to the standard EFLAGS register (EFLAGS<b>0</b>) there is also a scratch EFLAGS register (EFLAGS<b>1</b>) for microcode. The FNCU knows nothing about these two different EFLAGS registers. It simply gets forwarded flag data off the RFLAGSn busses or off its flag input bus. The cycle after every opcode execution, the flags block generates a complete set of flags according to the flag equations mnemonics generated by the IDECODE.</p><p>The flag section also takes the B operand (predicted branch address) and compares it the result (EIP+d32). If the two are equal for a branch evaluation, the ZF (zero flag) is set during the next cycle. If the ZF is not set, then the FIROB knows that for a predicted branch taken and actual branch taken case, the IFETCH did not branch to the correct address.</p><p>Flag Equations for Functional Units</p><p>(these are what the FNCU generates; not what the FIROB writesback)</p><p>ADD_F flag equations for addition, sub, etc.</p><p>if (Byte): OF=CO(<b>7</b>){circumflex over ( )}CO(<b>6</b>); SF=R(<b>7</b>); ZF=\u02dc|R(<b>7</b>:<b>0</b>); AF=CO(<b>3</b>); PF=\u02dc{circumflex over ( )}R(<b>7</b>:<b>0</b>); CF=CO(<b>7</b>); DF=DF(in)</p><p>if (Word): OF=CO(<b>15</b>){circumflex over ( )}CO(<b>14</b>); SF=R(<b>15</b>); ZF=\u02dc|R(<b>15</b>:<b>0</b>); AF=CO(<b>3</b>); PF=\u02dc{circumflex over ( )}R(<b>7</b>:<b>0</b>); CF=CO(<b>15</b>); DF=DF(in)</p><p>if (Dword): OF=CO(<b>31</b>){circumflex over ( )}CO(<b>30</b>); SF=R(<b>31</b>); ZF=\u02dc|R(<b>31</b>:<b>0</b>); AF=CO(<b>3</b>); PF=\u02dc{circumflex over ( )}R(<b>7</b>:<b>0</b>); CF=CO(<b>31</b>) DF=DF(in)</p><p>* CF is inverted when representing borrow instead of carry out</p><p>LOG_F flag equations for logical</p><p>if (Byte): OF=0; SF=R(<b>7</b>); ZF=\u02dc|R(<b>7</b>:<b>0</b>); AF=xxx; PF=\u02dc{circumflex over ( )}R(<b>7</b>:<b>0</b>); CF=0; DF=DF(in)</p><p>if (Word): OF=0; SF=R(<b>15</b>); ZF=\u02dc|R(15:0); AF=xxx; PF=\u02dc{circumflex over ( )}R(<b>7</b>:<b>0</b>); CF=0; DF=DF(in)</p><p>if (Dword): OF=0; SF=R(<b>31</b>); ZF=\u02dc|R(<b>31</b>:<b>0</b>); AF=xxx; PF=\u02dc{circumflex over ( )}R(<b>7</b>:<b>0</b>); CF=0; DF=DF(in)</p><p>CMC_F flag equations</p><p>if (Byte): OF=CO(<b>7</b>){circumflex over ( )}CO(<b>6</b>); SF=R(<b>7</b>); ZF=\u02dc|R(<b>7</b>:<b>0</b>); AF=CO(<b>3</b>); PF=\u02dc{circumflex over ( )}R(<b>7</b>:<b>0</b>); CF=\u02dcCF(in); DF=DF(in)</p><p>if (Word): OF=CO(<b>15</b>){circumflex over ( )}CO(<b>14</b>); SF=R(<b>15</b>); ZF=\u02dc|R(<b>15</b>:<b>0</b>); AF=CO(<b>3</b>); PF=\u02dc{circumflex over ( )}R(<b>7</b>:<b>0</b>); CF=\u02dcCF(in); DF=DF(in)</p><p>if (Dword): OF=CO(<b>31</b>){circumflex over ( )}CO(<b>30</b>); SF=R(<b>31</b>); ZF=\u02dc|R(<b>31</b>:<b>0</b>); AF=CO(<b>3</b>); PF=\u02dc{circumflex over ( )}R(<b>7</b>:<b>0</b>); CF=\u02dcCF(in); DF=DF(in)</p><p>BCD_FS flag equations</p><p>if (Byte): OF=CO(<b>7</b>){circumflex over ( )}CO(<b>6</b>); SF=R(<b>7</b>); ZF=\u02dc|R(<b>7</b>:<b>0</b>); AF=1; PF=\u02dc{circumflex over ( )}R(<b>7</b>:<b>0</b>); CF=1; DF=DF(in)</p><p>BCD_FC flag equations</p><p>if (Byte): OF=CO(<b>7</b>){circumflex over ( )}CO(<b>6</b>); SF=R(<b>7</b>); ZF=\u02dc|R(<b>7</b>:<b>0</b>); AF=0; PF=\u02dc{circumflex over ( )}R(<b>7</b>:<b>0</b>); CF=0; DF=DF(in)</p><p>DAA_FS<b>1</b> flag equations</p><p>if (Byte): OF CO(<b>7</b>){circumflex over ( )}CO(<b>6</b>); SF=R(<b>7</b>); ZF=\u02dc|R(<b>7</b>:<b>0</b>); AF=1; PF=\u02dc{circumflex over ( )}R(<b>7</b>:<b>0</b>); CF=CF(input) |CO(<b>7</b>) DF=DF(in)</p><p>* CF is inverted when representing borrow instead of carry out</p><p>STD_F flag equations</p><p>OF=OF(in); SF=SF(in); ZF=ZF(in); AFS=AF(in); PF=PF(in); CF=CF(in); DF=1;</p><p>CLD_F flag equations</p><p>OF=OF(in); SF=SF(in); ZF=ZF(in); AFS=AF(in); PF=PF(in); CF=CF(in); DF=1;</p><p>* note: the flag equations mnemonic sent to the FNCU is ignored during LAHF and SAHF; the FNCU generates all flags per the flag mnemonic but the FIROB decides which flags are actually written back.</p><p>Method of Sending Data Cache Linear Addresses to LSSEC</p><p>The FNCU can be used to calculate a linear address using the displacement bus and either the A or B operand bus. The result is sent to the LSSEC using the RES bus. This assumes that a segment with no offset is being used. When the segment offset needs to be added in, the LSSEC handles the segment offset addition. AXBnLAC lets the functional unit know if the AOPND or BOPND bus will be added to the displacement bus. RQnLAC indicates that the functional unit is performing a linear address calculation. In the case of [EAX] Which has no displacement, the decode block will have sent a zero constant on the displacement bus.</p><p>Linear address calculations will be handled as follows:</p><p>1) SIB will be mapped to two dispatch positions such that the first one adds the base with the scaled index; this result goes to the second dispatch position which operates like a regular opcode but gets results from the first (eg: OPCODE [1st_result+d32],r32. The reason for dividing the SIB into two opcodes is to get dependency checking performed on three source operands.</p><p>2) All other linear address calculations (one forwarded variable and one displacement) go to the reservation station where they wait for the forwarded variable. Then for a Load or Load followed by store, the reservation station keeps its information with the forwarded variable and displacement go to the functional unit to be added. Then the result bus is used to send the Load linear address to the LSSEC. The LSSEC must be able to latch one linear address from each functional unit during a cycle. Dispatch/decode makes sure that no more than 8 loads and stores are pending at any one time. If a non-zero segment offset is present, four adders are used in the LSSEC to complete the calculation from logical to linear address.</p><p>3) For a Load and Store, once the Load linear address is calculated by the functional unit this linear address is both saved for the subsequent store and also sent to the LSSEC for the Load.</p><p>In the case of a load, the reservation station remains valid and waits for the LSSEC to return the data. The status bus indicates whether the RES bus contains an FOSTAT_NONE, FOSTAT_LD, etc. The LSSEC can do Loads in any order but also checks them with the Store buffer (in parallel) for any dependencies. DTAG Information is sent from the decode/dispatch directly to the LSSEC to indicate the true store order, since the functional units (FNCU) may give stores to the LSSEC in out of order sequence.</p><p>The typical flow for forwarding from a Load-OP instruction followed by an operation only instruction is shown. Note that after the BTAG changes from its original value (don't care for this case) to the DTAG value of its opcode. When the LSSEC sends back the data the DTAG of the receiving opcode will be on the LSTAG bus.</p><p><tables id=\"TABLE-US-00049\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"84PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ADD EAX, [ECX+d32]</entry><entry morerows=\"0\" valign=\"top\">send to issue position 0</entry></row><row><entry morerows=\"0\" valign=\"top\">example:</entry><entry morerows=\"0\" valign=\"top\">XOR EBX,EAX</entry><entry morerows=\"0\" valign=\"top\">send to issue position 2</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">RES_STA</entry><entry morerows=\"0\" valign=\"top\">RES_STA</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">DTAG=1_0</entry><entry morerows=\"0\" valign=\"top\">DTAG=2_2</entry></row><row><entry morerows=\"0\" valign=\"top\">BTAG=xxx</entry><entry morerows=\"0\" valign=\"top\">BTAG=1_0</entry></row><row><entry morerows=\"0\" valign=\"top\">calc LA</entry><entry morerows=\"0\" valign=\"top\">idle</entry><entry morerows=\"0\" valign=\"top\">idle</entry></row><row><entry morerows=\"0\" valign=\"top\">FNCU0</entry><entry morerows=\"0\" valign=\"top\">FNCU2</entry><entry morerows=\"0\" valign=\"top\">LSSEC:SRB</entry></row><row><entry morerows=\"0\" valign=\"top\">_RES0_</entry><entry morerows=\"0\" valign=\"top\">_RES2_</entry><entry morerows=\"0\" valign=\"top\">_LSRES_</entry></row><row><entry morerows=\"0\" valign=\"top\">B+disp</entry></row><row><entry morerows=\"0\" valign=\"top\">DTAG=1_0</entry></row><row><entry morerows=\"0\" valign=\"top\">R_LOAD</entry></row><row><entry morerows=\"0\" valign=\"top\">RES_STA</entry><entry morerows=\"0\" valign=\"top\">RES_STA</entry></row><row><entry morerows=\"0\" valign=\"top\">DTAG=1_0</entry><entry morerows=\"0\" valign=\"top\">DTAG=2_2</entry></row><row><entry morerows=\"0\" valign=\"top\">BTAG=1_0</entry><entry morerows=\"0\" valign=\"top\">BTAG=1_0</entry><entry morerows=\"0\" valign=\"top\">performs</entry></row><row><entry morerows=\"0\" valign=\"top\">idle</entry><entry morerows=\"0\" valign=\"top\">idle</entry><entry morerows=\"0\" valign=\"top\">load</entry></row><row><entry morerows=\"0\" valign=\"top\">FNCU0</entry><entry morerows=\"0\" valign=\"top\">FNCU2</entry><entry morerows=\"0\" valign=\"top\">LSSEC:SRB</entry></row><row><entry morerows=\"0\" valign=\"top\">_RES0_</entry><entry morerows=\"0\" valign=\"top\">_RES2_</entry><entry morerows=\"0\" valign=\"top\">__LSRES__</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSTAG=1_0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">R_LD_DAT</entry></row><row><entry morerows=\"0\" valign=\"top\">RES_STA</entry><entry morerows=\"0\" valign=\"top\">RES_STA</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DTAG=2_2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTAG=1_0</entry></row><row><entry morerows=\"0\" valign=\"top\">execute</entry><entry morerows=\"0\" valign=\"top\">idle</entry><entry morerows=\"0\" valign=\"top\">idle</entry></row><row><entry morerows=\"0\" valign=\"top\">FNCU0</entry><entry morerows=\"0\" valign=\"top\">FNCU2</entry><entry morerows=\"0\" valign=\"top\">LSSEC:SRB</entry></row><row><entry morerows=\"0\" valign=\"top\">_RES0_</entry><entry morerows=\"0\" valign=\"top\">_RES2_</entry><entry morerows=\"0\" valign=\"top\">__LSRES_</entry></row><row><entry morerows=\"0\" valign=\"top\">execute</entry></row><row><entry morerows=\"0\" valign=\"top\">DTAG=1_0</entry></row><row><entry morerows=\"0\" valign=\"top\">R_VAL</entry></row><row><entry morerows=\"0\" valign=\"top\">RES_STA</entry><entry morerows=\"0\" valign=\"top\">RES_STA</entry></row><row><entry morerows=\"0\" valign=\"top\">idle</entry><entry morerows=\"0\" valign=\"top\">execute</entry><entry morerows=\"0\" valign=\"top\">idle</entry></row><row><entry morerows=\"0\" valign=\"top\">FNCU0</entry><entry morerows=\"0\" valign=\"top\">FNCU2</entry><entry morerows=\"0\" valign=\"top\">LSSEC:SRB</entry></row><row><entry morerows=\"0\" valign=\"top\">_RES0_</entry><entry morerows=\"0\" valign=\"top\">RES2_</entry><entry morerows=\"0\" valign=\"top\">_LSRES_</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">execute</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DTAG=2_2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">R_VAL</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Push/Pop Linear address calculations will be handled as follows:</p><p>For a PUSH, the first vector will subtract 2 h or 4 h from the ESP and the result will be both latched by the FIROB as the new ESP and latched by the LSSEC as the store linear address. The second vector is a move of some register (passes through the FNCU) to the LSSEC, and to memory. A push memory will require two dispatch positions (see reservation station document for more details).</p><p>For a POP, two dispatch positions are always required because there are two register destinations that must be updated. Vector <b>0</b> of the first dispatch position passes the ESP value through the FNCU and the LSSEC latches it as a load linear address. The reservation station waits for the load data to be returned and uses the next vector to pass the load through the FNCU and onto the RES bus where the FIROB latches it and eventually writes it back to a the correct register. The second dispatch position is to add 2 h or 4 h to ESP.</p><p>Interface for Multiply, Divide, SRB, and FPU</p><p>Each of the four issue positions has AOPND and BOPND busses which are tristated and transfer operands from the operand steering unit, RS<b>2</b>, RS<b>1</b>, and RSO to the FNCU. No forwarding is allowed on these AOPND and BOPND busses. Forwarding from the RES busses is multiplexed directly at the input to the FNCU. These AOPND and BOPND busses also have tristate drivers onto the SAOPND and SBOPND busses which are shared operand busses going to the integer multiplier block.</p><p>Floating point instructions go to the Integer uCode to have one FIROB line with four entries assigned to it. If needed, the first three dispatch positions will contain linear address calculations for the 3 possible floating point loads (32 bits, 32 bits, and 16 bits), and those integer reservation station entries free up after the linear address calculations for the FPU. The last dispatch position is a NOOP from the functional unit point of view. The uCode sends an Fcode entry point (corresponding to the last dispatch position) directly to the FPU. For floating point stores, the integer reservation stations perform the linear address calculations, and the LSSEC latches the linear addresses. Those integer reservation station entries then free up. Later, the FPU would request the multiplier for use of the MUL result bus and indicate to the reservation station control for position <b>3</b> that it needs to drive store data from the FPU to the MUL result bus to the FNCU<b>3</b> result MUX to the RES<b>3</b> bus. The LSSEC latches the data off the RES<b>3</b> bus and performs the stores.</p><p>The SRB instructions go to issue positions in any order. They use a similar protocol to the LOAD/STORE instructions. The SRB contains a four entry file which receives tags and other information from the IDECODE/DISPATCH. SRB opcodes can pass through the functional units in any order and then be reordered in the SRB file before the SRB executes them. No renaming is done on the SRB registers (CR<b>0</b>, CR<b>4</b>, various array entries, etc.). Data from the SRB to a standard x86 register or temporary register is returned to the FIROB using the LSRES<b>0</b> bus and can be forwarded to the reservation stations at the same time. The following example shows how information is sent to the SRB and how information is forwarded from the LSRES<b>0</b> bus. The actual SRB transfers (setup and move) would take several cycles to complete and the latencies are not shown in this example.</p><p>The SRB flow follows:</p><p><tables id=\"TABLE-US-00050\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"63PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES_STA</entry><entry morerows=\"0\" valign=\"top\">RES_STA</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DTAG=2_2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTAG=1_0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">pass SRB info</entry><entry morerows=\"0\" valign=\"top\">idle</entry><entry morerows=\"0\" valign=\"top\">idle</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">FNCU0</entry><entry morerows=\"0\" valign=\"top\">FNCU2</entry><entry morerows=\"0\" valign=\"top\">LSSEC:SRB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">_RES0_</entry><entry morerows=\"0\" valign=\"top\">_RES2_</entry><entry morerows=\"0\" valign=\"top\">_LSRES_</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">pass</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DTAG=1_0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">R_SRB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES_STA</entry><entry morerows=\"0\" valign=\"top\">RES_STA</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DTAG=2_2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTAG=1_0</entry><entry morerows=\"0\" valign=\"top\">perform</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">idle</entry><entry morerows=\"0\" valign=\"top\">idle</entry><entry morerows=\"0\" valign=\"top\">reg &lt;- CR0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">FNCU0</entry><entry morerows=\"0\" valign=\"top\">FNCU2</entry><entry morerows=\"0\" valign=\"top\">LSSEC:SRB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">_RES0<sub>\u2014</sub></entry><entry morerows=\"0\" valign=\"top\">_RES2<sub>\u2014</sub></entry><entry morerows=\"0\" valign=\"top\">_LSRES<sub>\u2014</sub></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSTAG=1_0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">R_SRB_DAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES_STA</entry><entry morerows=\"0\" valign=\"top\">RES_STA</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">idle</entry><entry morerows=\"0\" valign=\"top\">execute</entry><entry morerows=\"0\" valign=\"top\">idle</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">FNCU0</entry><entry morerows=\"0\" valign=\"top\">FNCU2</entry><entry morerows=\"0\" valign=\"top\">LSSEC:SRB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">_RES0<sub>\u2014</sub></entry><entry morerows=\"0\" valign=\"top\">_RES2<sub>\u2014</sub></entry><entry morerows=\"0\" valign=\"top\">_LSRES<sub>\u2014</sub></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">execute</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DTAG=2_2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">R_VALID</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Functional Unit Handling of Unaligned Operands and SIB</p><p>When a byte operand such as AH is not located in the lowest bits, the functional unit needs to shift the AH operand from bits (<b>15</b>:<b>8</b>) to bits (<b>7</b>:<b>0</b>), perform the operation, and shift the result back to bits (<b>15</b>:<b>8</b>). The AHBYTE information will tell the functional unit when this alignment is required. SIB (scale, index, and base) addressing forms are sent as two dispatch positions because the instructions require dependency checking and renaming on three source operands. During the first opcode the base and the scaled index are added together, the result is given to the second opcode to perform the actual operation. IDECODE will send scale information to the functional unit indicating shifts by (<b>0</b>,<b>1</b>,<b>2</b>,<b>3</b>, or <b>4</b>). Except for the scale information, the FNCU would not have needed to know anything about SIBs.</p><p>Integer Multiplier</p><p>The integer multiplier will use a two iteration method, the first pass goes through an 8\u00d732 array, then through the Wallace tree, and if the final result is 32 bits or less, go through the carry propagate adder and be finished, else take another iteration using a larger Wallace tree to combine the carries and sums from the first iteration with the carries and sum generated from the 8\u00d732 array on the second iteration, and finish with a pass through the carry propagate adder.</p><p>As the reservation stations get all of the operands needed for the multiply, they will send the multiply on the SAOPND and the SBOPND busses which are shared tristate busses from the AOPND and the BOPND of each reservation station group. There will be a a total of three cycles used for the multiply. The Multiply block and the FPU will arbitrate for the MUL result bus such that the multiplier always has highest priority.</p><p>X86 Assembly Instruction Mapping for Fast Path</p><p>Processor <b>500</b> executes a small subset of the x86 instruction set (around 50 instructions) as fast path instructions while everything else gets sent to microcode. The current startup delay for the microcode engine is one extra cycle. The following chart lists the instructions which go to fast path and the ones which get sent to the microcode engine. Some of the x86 instructions are also broken up into two dispatch positions.</p><p><tables id=\"TABLE-US-00051\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">x86 Assembly</entry><entry morerows=\"0\" valign=\"top\">Fast Path</entry><entry morerows=\"0\" valign=\"top\">Opcode seen by FNCU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">AAA</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">AAD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">AAM</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">AAS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ADC</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">ADC</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ADD</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">ADD</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">AND</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">AND</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ARPL</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BOUND</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BSF</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">BSF (may become uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">eight bits at</entry><entry morerows=\"0\" valign=\"top\">with 16 bit BSF)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">a time</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BSR</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">BSR (may become uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">eight bits at</entry><entry morerows=\"0\" valign=\"top\">with 16 bit BSR)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">a time</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BSWAP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BT</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">BT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTC</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">BTC</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTR</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">BTR</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTS</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">BTS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CALL</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">near indirect or near</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">relative else uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CBW</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SIGNXA</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CWDE</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SIGNXA</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CLC</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">use flag equations</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CLD</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">use flag equations</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CLI</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CLTS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMC</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">use flag equations</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMP</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SUB (no result writeback</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">by</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">FIROB)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMPS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMPSB</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMPSW</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMPSD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMPXCHG</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMPXCHG8B</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CPUID</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CWD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CWQ</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DDA</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DAS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DEC</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SUB wo/ CF save</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DIV</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ENTER</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">HLT</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIV</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IMUL</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">IMUL, some are 2 dispatch</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">\u2003pos</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IN</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INC</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">ADD wo/ CF save</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSB</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSW</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INT</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INTO</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INVD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INVLPG</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IRET</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IRETD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Jcc</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">JMPCC</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">JCXZ</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">two dispatch positions</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">JECXZ</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">two dispatch positions</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">JMP</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">near and indirect else</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LAHF</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">LAHF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LAR</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LDS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LES</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LFS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LGS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LEA</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">LEAB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LEAVE</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">two dispatch position</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LGDT</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LIDT</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LLDT</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LMSW</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LODS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LODSB</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LODSW</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LODSD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LOOP</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">two dispatch positions</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LOOPcond</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSL</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LTR</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOV</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">MOVZX</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVCC</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">MOVCC</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOV CR</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOV DR</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MCVSB</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVSW</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVSD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVSX</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">MOVSX</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVZX</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">MOVZX</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MUL</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">MUL; some are two</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">dispatch pos</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEG</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SUB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NOP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">not sent to FNCU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NOT</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SUB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OR</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">OR</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OUT</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OUTS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OUTSB</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OUTSW</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OUTSD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POP</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">two dispatch positions</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POPA</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POPAD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POPF</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode-may change IOPL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POPFD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode-may change IOPL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PUSH</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">some are two dispatch pos</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PUSHA</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PUSHAD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PUSHF</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">MOVF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PUSHFD</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">MOVF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCL</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode using RCL_1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCR</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode using RCR_1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ROL</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">ROL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ROR</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">ROR</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RDMSR</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">REP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">REPE</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">REPZ</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">REPNE</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">REPNZ</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RET</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">two dispatch positions</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSM</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SAHF</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SAHF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SAL</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SHL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SAR</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SAR</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHL</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SHL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHR</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SHR</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SBB</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SBB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode using DFADD</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCASB</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode using DFADD</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCASW</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode using DFADD</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCASD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode using DFADD</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SETcc</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SETCC</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SGDT</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SIDT</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHLD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHRD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SLDT</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SMSW</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STC</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">ZEROXA &amp; flags=BCD_FS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STD</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">FIROB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STI</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STOS</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STOSB</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STOSW</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STOSD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STR</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SUB</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">SUB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">TEST</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">AND (no result writeback</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">by FIROB)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">VERR</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">VERW</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WBINVD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WRMSR</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">XADD</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">XCHG</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uCode</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">XLAT</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">MOV</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">XLATB</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">MOV</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">XOR</entry><entry morerows=\"0\" valign=\"top\">fast</entry><entry morerows=\"0\" valign=\"top\">XOR</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Details of the Divide Mnemonics and Their Use</p><p>The restoring division algorithm is done using uCode and FNCU<b>0</b> only. Local divide direction bits are kept by FNCU<b>0</b> and can be used to select between two different vectors (one for ADD and one for SUB). Numerous signals are supplied from the control bit vector to the FNCU<b>0</b> special logic so that proper handling of the division direction bit and proper multiplexing of the result can be performed.</p><p>FNCU<b>0</b> Signal List</p><p>Functional Unit <b>0</b> is the only one which can do divides.</p><p>This signal list shows where the various functional unit signals come from or go to.</p><p>FNCU<b>0</b> Output Signals</p><p>F<b>0</b>BRN_ADR; assert proper branch status</p><p>F<b>0</b>BRN_NT; assert proper branch status</p><p>F<b>0</b>BRN_OK; assert proper branch status</p><p>F<b>0</b>BRN_T_ADR; assert proper branch status</p><p>F<b>0</b>BRN_T_OK; assert proper branch status</p><p>F<b>0</b>STAT_LD; RES bus status\u2014load linear address</p><p>F<b>0</b>STAT_MUL; RES bus status\u2014multiplier</p><p>F<b>0</b>STAT_NONE; RES bus status\u2014no result</p><p>F<b>0</b>STAT_OPST; RES bus status\u2014operand data for a store</p><p>F<b>0</b>STAT_SRB; RES bus status\u2014SRB information</p><p>F<b>0</b>STAT_ST; RES bus status\u2014store linear address</p><p>F<b>0</b>STAT_VAL; RES bus status\u2014valid</p><p>[<b>10</b>:<b>0</b>] INSLSB; LSSEC segment MUX</p><p>[<b>14</b>:<b>0</b>] RESLA; early result bits send to LSSEC DCACHE</p><p>[<b>2</b>:<b>0</b>] DTAG; destination tag</p><p>[<b>2</b>:<b>0</b>] RSTAT; result status</p><p>[<b>31</b>:<b>0</b>] FDRES; forwarded RES bus</p><p>[<b>6</b>:<b>0</b>] RFLAG; result flags</p><p>FNCU<b>0</b> Inputs from Reservation Station, Forwarding, and Multiplier</p><p>DCPAPRHIT; data cache port A predicted way hit</p><p>DCPBPRHIT; data cache port B predicted way hit</p><p>DCUNPAHIT; data cache port A unpredicted way hit</p><p>DCUNPBHIT; data cache port B unpredicted way hit</p><p>FNCUGO; functional unit GO indication</p><p>MULXF; value of all multiply flags</p><p>OPALSRES<b>0</b>; used to qualify valid status; else mispredicted way miss; Aop &amp; DC port <b>0</b></p><p>OPALSRES<b>1</b>; used to qualify valid status; else mispredicted way miss; Aop &amp; DC port <b>1</b></p><p>OPBLSRES<b>0</b>; used to qualify valid status; else mispredicted way miss; Bop &amp; DC port <b>0</b></p><p>OPBLSRES<b>1</b>; used to qualify valid status; else mispredicted way miss; Bop &amp; DC port <b>1</b></p><p>PURGE; resets all processes in the multiplier</p><p>RESET; resets all processes in the multiplier and GRNT_CNT</p><p>[<b>1</b>:<b>0</b>] LSCANFWD LSSEC cancel of forwarded load data on LSRESn</p><p>[<b>10</b>:<b>0</b>] INSSEG; LSSEC segment MUX select</p><p>[<b>2</b>:<b>0</b>] CDTAG; current destination tag for the incoming opcode</p><p>[<b>31</b>:<b>0</b>] AOPND; A operand</p><p>[<b>31</b>:<b>0</b>] BOPND; B operand</p><p>[<b>31</b>:<b>0</b>] DSPR; displacement</p><p>[<b>31</b>:<b>0</b>] FDRES<b>0</b>; forwarded result bus from position <b>0</b></p><p>[<b>31</b>:<b>0</b>] FDRES<b>1</b>; forwarded result bus from position <b>1</b></p><p>[<b>31</b>:<b>0</b>] FDRES<b>2</b>; forwarded result bus from position <b>2</b></p><p>[<b>31</b>:<b>0</b>] FDRES<b>3</b>; forwarded result bus from position <b>3</b></p><p>[<b>31</b>:<b>0</b>] LSRES<b>0</b>; LSSEC result bus <b>0</b></p><p>[<b>31</b>:<b>0</b>] LSRES<b>1</b>; LSSEC result bus <b>1</b></p><p>[<b>31</b>:<b>0</b>] MULTRES; multiply floating point bus</p><p>[<b>6</b>:<b>0</b>] FLGD; input flag data from the reservation station</p><p>[<b>6</b>:<b>0</b>] RFLAG<b>0</b>; input flag data from position <b>0</b></p><p>[<b>6</b>:<b>0</b>] RFLAG<b>1</b>; input flag data from position <b>1</b></p><p>[<b>6</b>:<b>0</b>] RFLAG<b>2</b>; input flag data from position <b>2</b></p><p>[<b>6</b>:<b>0</b>] RFLAG<b>3</b>; input flag data from position <b>3</b></p><p>[<b>6</b>:<b>0</b>] RFLAGLS<b>0</b>; input flag data from LSSEC <b>0</b></p><p>[<b>6</b>:<b>0</b>] RFLAGLS<b>1</b>; input flag data from LSSEC <b>1</b></p><p>[<b>7</b>:<b>0</b>] FNCUMUXA; mux control from reservation station for A operand input</p><p>[<b>7</b>:<b>0</b>] FNCUMUXB; mux control from reservation station for B operand input</p><p>[<b>7</b>:<b>0</b>] FNCUMUXCF; mux control from reservation station for the carry flag</p><p>[<b>7</b>:<b>0</b>] FNCUMUXSTF; mux control from reservation station for the status flags</p><p>FNCU<b>0</b> Inputs for Control Store\u2014Shared for Both Vectors</p><p>FOCTLST_VWR; valid control store write next cycle</p><p>F<b>0</b>DIV<b>0</b>; initial divide opcode</p><p>F<b>0</b>DIV; divide opcode</p><p>F<b>0</b>DIVCMP; divide opcode</p><p>F<b>0</b>DIVL; divide opcode</p><p>F<b>0</b>DIVQ; divide opcode</p><p>F<b>0</b>DIVREM; divide opcode</p><p>F<b>0</b>DIVSGN; divide opcode</p><p>F<b>0</b>IDIVCMP; divide opcode</p><p>F<b>0</b>IDIVDEND<b>0</b>; divide opcode</p><p>F<b>0</b>IDIVDEND<b>1</b>; divide opcode</p><p>F<b>0</b>IDIVSOR; divide opcode</p><p>F<b>0</b>SELOPA; The initial quotient is from operand A else from adder output</p><p>F<b>0</b>UPDDF; update division direction bit</p><p>F<b>0</b>UPDQ; update division quotient</p><p>SELSQXOPA; indicates that quotient gets shifted quotient slave instead of adder or OPA</p><p>[<b>3</b>:<b>0</b>] F<b>0</b>CTLST_WR; indicates which control store vector to use</p><p>[<b>7</b>:<b>0</b>] F<b>0</b>CTLST_USE; indicates which control store vector to use</p><p>[<b>7</b>:<b>0</b>] FRESMUX; select lines for MUX to RES bus</p><p>FNCU<b>0</b> Inputs for Control Store\u2014Vector <b>0</b>; no Shifts Allowed</p><p>AXBLACO; indicates if operand A or B is used for linear addr calc</p><p>F<b>0</b>ADD_F<b>0</b>; addition type flag generation</p><p>F<b>0</b>BCD_FC<b>0</b>; BCD clear type flag generation</p><p>F<b>0</b>BCD_FS<b>0</b>; BCD set type flag generation</p><p>F<b>0</b>CIN<b>0</b>; carry-in from the control block</p><p>F<b>0</b>CLD_F<b>0</b>; clear direction flag generation</p><p>F<b>0</b>CMC_F<b>0</b>; complement carry type flag generation</p><p>F<b>0</b>COMPB<b>0</b>; complement the B operand</p><p>F<b>0</b>COND_CODE<b>0</b>; evaluate condition codes</p><p>F<b>0</b>DAA_FS<b>0</b>; DAA type flag generation</p><p>F<b>0</b>FLAGCF<b>0</b>; opcode requires using a version of EFLAGSCF</p><p>F<b>0</b>LOG_F<b>0</b>; logical type flag generation</p><p>F<b>0</b>MOVCC<b>0</b>; MOVCC instruction</p><p>F<b>0</b>SETCC<b>0</b>; SETCC instruction</p><p>F<b>0</b>MUXCIN<b>0</b>; carry-in MUX</p><p>F<b>0</b>MUXDF<b>0</b>; direction flag MUX</p><p>F<b>0</b>SETCF<b>0</b>; ADC uses true version of EFLAGSCF else \u02dcEFLAGSCF</p><p>F<b>0</b>STD_F<b>0</b>; store direction flag generation</p><p>F<b>0</b>UNC_BRN<b>0</b>; unconditional branch evaluation</p><p>FISTAT_BRN<b>0</b>; assert proper branch status</p><p>FISTAT_LD<b>0</b>; RES bus status\u2014load linear address</p><p>FISTAT_MUL<b>0</b>; RES bus status\u2014mulitplier</p><p>FISTAT_NONE<b>0</b>; RES bus status\u2014no result</p><p>FISTAT_OPST<b>0</b>; RES bus status\u2014operand data for a store</p><p>FISTAT_SRB<b>0</b>; RES bus status\u2014SRB information</p><p>FISTAT_ST<b>0</b>; RES bus status\u2014store linear address</p><p>FISTAT_VAL<b>0</b>; RES bus status\u2014valid</p><p>RQLAC<b>0</b>; linear address calculation</p><p>SIGNXA<b>0</b>; sign extend the A operand</p><p>SIGNXB<b>0</b>; sign extend the B operand</p><p>SIGNXD<b>0</b>; sign extend the D operand</p><p>USEOFFSET<b>0</b>; use offset for PUSH, POP, or FPU lin adr calc</p><p>ZEROXA<b>0</b>; zero extend the A operand</p><p>ZEROXB<b>0</b>; zero extend the B operand</p><p>ZEROXD<b>0</b>; zero extend the D operand</p><p>[<b>1</b>:<b>0</b>] AHBYTE<b>0</b>; alignment select bits<b>0</b>; move bits <b>15</b>:<b>8</b> to <b>7</b>:<b>0</b></p><p>[<b>2</b>:<b>0</b>] F<b>0</b>GIN<b>0</b>; generate style inputs (used here to indicate type of operation)</p><p>[<b>3</b>:<b>0</b>] F<b>0</b>PIN<b>0</b>; propagate style inputs (used here to indicate type of operation)</p><p>[<b>3</b>:<b>01</b>] OPSIZEIN<b>0</b>; size/position of result (dword, word, ah, al)</p><p>[<b>4</b>:<b>0</b>] F<b>0</b>SCALE; scale for SIB: <b>8</b>,<b>4</b>,<b>2</b>,<b>1</b>,<b>0</b></p><p>[<b>7</b>:<b>0</b>] FRESMUX<b>0</b>; select lines for MUX to RES bus</p><p>FNCU<b>0</b> Inputs for Control Store\u2014Vector <b>1</b>; Shifts Allowed</p><p>AXBLAC<b>1</b>; indicates if operand A or B is used for linear addr calc</p><p>F<b>0</b>ADD_F<b>1</b>; addition type flag generation</p><p>F<b>0</b>BCD_FC<b>1</b>; BCD clear type flag generation</p><p>F<b>0</b>BCD_FS<b>1</b>; BCD set type flag generation</p><p>F<b>0</b>CIN<b>1</b>; carry-in from the control block</p><p>F<b>0</b>CLD_F<b>1</b>; clear direction flag generation</p><p>F<b>0</b>CMC_F<b>1</b>; complement carry type flag generation</p><p>F<b>0</b>COMPB<b>1</b>; complement the B operand</p><p>F<b>0</b>COND_CODE<b>1</b>; evaluate condition codes</p><p>F<b>0</b>DAA_FS<b>1</b>; DAA type flag generation</p><p>F<b>0</b>FLAGCF<b>1</b>; opcode requires using a version of EFLAGSCF</p><p>F<b>0</b>LOG_F<b>1</b>; logical type flag generation</p><p>SHFEFLAG<b>1</b>; merge Bop and all flags into result</p><p>F<b>0</b>MOVCC<b>1</b>; MOVCC instruction</p><p>F<b>0</b>SETCC<b>1</b>; SETCC instruction</p><p>F<b>0</b>MUXCIN<b>1</b>; carry-in MUX</p><p>F<b>0</b>MUXDF<b>1</b>; direction flag MUX</p><p>F<b>0</b>SETCF<b>1</b>; ADC uses true version of EFLAGSCF else \u02dcEFLAGSCF</p><p>F<b>0</b>STD_F<b>1</b>; store direction flag generation</p><p>F<b>0</b>UNC_BRN<b>1</b>; unconditional branch evaluation</p><p>FISTAT_BRN<b>1</b>; assert proper branch status</p><p>FISTAT_LD<b>1</b>; RES bus status\u2014load linear address</p><p>FISTAT_MUL<b>1</b>; RES bus status\u2014mulitplier</p><p>FISTAT_NONE<b>1</b>; RES bus status\u2014no result</p><p>FISTAT_OPST<b>1</b>; RES bus status\u2014operand data for a store</p><p>FISTAT_SRB<b>1</b>; RES bus status\u2014SRB information</p><p>FISTAT_ST<b>1</b>; RES bus status\u2014store linear address</p><p>FISTAT_VAL<b>1</b>; RES bus status\u2014valid</p><p>RQLAC<b>1</b>; linear address calculation</p><p>SHFBCMP<b>1</b>; indicates a Bit Test and Complement</p><p>SHFBITEST<b>1</b>; a select signal for any Bit Test opcode</p><p>SHFBITOPA<b>1</b>; a select signal for only the BTEST (BT) opcode</p><p>SHFBSF<b>1</b>; select signal for Bit Scan Forward</p><p>SHFBSR<b>1</b>; select signal for Bit Scan Reverse</p><p>SHFBSXR<b>1</b>; indicates a set/reset for bit test instruction</p><p>SHFEFLAG<b>1</b>; merge Bop and all flags into result</p><p>SHFFLGOF<b>1</b>; overwrite the OF position of Bop to form result</p><p>SHFFLGEF<b>1</b>; overwrite the OF position of Bop to form result</p><p>SHFLAHF<b>1</b>; load Flags into AH opcode</p><p>SHFLEFT<b>1</b>; indicates RCL, ROL, or SHL opcode</p><p>SHFRIGHT<b>1</b>; indicates RCR, ROR, SAR, or SHR opcode</p><p>SHFROT<b>1</b>; indicates a rotate or SHL opcode</p><p>SHFSAHF<b>1</b>; store AH into Flags opcode</p><p>SHFSELSF<b>31</b>_<b>1</b>; set the sign flag to the shifter output bit <b>31</b></p><p>SHFSETCF<b>1</b>; set carry flag for RCL &amp; RCR equal to EFLAGSCF</p><p>SHF_UPD_RC<b>1</b>; select for updating the local carry flag</p><p>SIGNXA<b>1</b>; sign extend the A operand</p><p>SIGNXB<b>1</b>; sign extend the B operand</p><p>SIGNXD<b>1</b>; sign extend the D operand</p><p>USEOFFSET<b>0</b>; use offset for PUSH, POP, or FPU lin adr calc</p><p>ZEROXA<b>1</b>; zero extend the A operand</p><p>ZEROXB<b>1</b>; zero extend the B operand</p><p>ZEROXD<b>1</b>; zero extend the D operand</p><p>[<b>1</b>:<b>0</b>] AHBYTE<b>1</b>; alignment select bits<b>0</b>;move bits <b>15</b>:<b>8</b> to <b>7</b>:<b>0</b></p><p>[<b>21</b>:<b>0</b>] SHFSELPRE<b>1</b>; the preshift mux select signals</p><p>[<b>2</b>:<b>0</b>] F<b>0</b>GIN<b>1</b>; generate style inputs (used here to indicate type of operation)</p><p>[<b>2</b>:<b>0</b>] SHFSELZF<b>1</b>; determines which groups of bit to use for setting the zero flag</p><p>[<b>3</b>:<b>0</b>] FOPIN<b>1</b>; propagate style inputs (used here to indicate type of operation)</p><p>[<b>3</b>:<b>0</b>] OPSIZEIN<b>1</b>; size/position of result (dword, word, ah, al)</p><p>[<b>3</b>:<b>0</b>] SHFSELOF<b>1</b>; determines which groups of bit to use for setting the overflow flag</p><p>[<b>13</b>:<b>0</b>] SHFSELOUT<b>1</b>; indicates final byte alignment for the shifter output</p><p>[<b>7</b>:<b>0</b>] FRESMUX<b>1</b>; select lines for MUX to RES bus</p><p>[<b>7</b>:<b>0</b>] SHFSELCF<b>1</b>; determines which shifter bits to use to set the carry flag</p><p>[<b>9</b>:<b>0</b>] SHFSELCNT<b>1</b>; mux select signals determining source of shifter count value</p><p>FNCU<b>1</b> to <b>3</b> Signals List</p><p>FNCU<b>1</b> to FNCU<b>3</b> contain the same signals as FNCU<b>0</b> except for the shared list</p><p>FNCU<b>1</b> Inputs for control store\u2014shared for both vectors</p><p>F<b>0</b>CTLST_VWR; valid control store write next cycle</p><p>[<b>7</b>:<b>0</b>] F<b>0</b>CTLST_USE; indicates which control store vector to use</p><p>[<b>3</b>:<b>0</b>] FOCTLST_WR; indicates which control store vector to use</p><p>CBVS Sub-Block</p><p>Fully decoded control vectors are stored in the Control Bit Vector Store sub-block. The reservation station and/or division direction flag determine which vector to use. As an example vector <b>0</b> and <b>1</b> could be used by the entry <b>2</b> of the reservation station. To do the linear address calculation for a load, entry <b>2</b> of the reservation station could select vector <b>0</b> and perform the add. When the load data came back, entry <b>2</b> of the reservation station would detect the tag match and use vector <b>2</b> along with the forwarded data to perform the actual operation. Only vector <b>2</b> can be used for shifting.</p><p>CBVS Input Signals List</p><p>AXBLAC<b>0</b>; indicates if operand A or B is used for linear addr calc</p><p>AXBLAC<b>1</b>; indicates if operand A or B is used for linear addr calc</p><p>F<b>0</b>ADD_F<b>0</b>; addition type flag generation</p><p>F<b>0</b>ADD_F<b>1</b>; addition type flag generation</p><p>F<b>0</b>BCD_FC<b>0</b>; BCD clear type flag generation</p><p>F<b>0</b>BCD_FC<b>1</b>; BCD clear type flag generation</p><p>F<b>0</b>BCD_FS<b>0</b>; BCD set type flag generation</p><p>F<b>0</b>BCD_FS<b>1</b>; BCD set type flag generation</p><p>F<b>0</b>CIN<b>0</b>; carry-in from the control block</p><p>F<b>0</b>CIN<b>1</b>; carry-in from the control block</p><p>F<b>0</b>CLD_F<b>0</b>; clear direction flag generation</p><p>F<b>0</b>CLD_F<b>1</b>; clear direction flag generation</p><p>F<b>0</b>CMC_F<b>0</b>; complement carry type flag generation</p><p>F<b>0</b>CMC_F<b>1</b>; complement carry type flag generation</p><p>F<b>0</b>COMPB<b>0</b>; complement the B operand</p><p>F<b>0</b>COMPB<b>1</b>; complement the B operand</p><p>F<b>0</b>COND_CODE<b>0</b>; evaluate condition codes</p><p>F<b>0</b>COND_CODE<b>1</b>; evaluate condition codes</p><p>F<b>0</b>CTLST_VWR; valid control store write next cycle</p><p>F<b>0</b>DAA_FS<b>0</b>; DAA type flag generation</p><p>F<b>0</b>DAA_FS<b>1</b>; DAA type flag generation</p><p>F<b>0</b>DIV<b>0</b>; initial divide opcode</p><p>F<b>0</b>DIV; divide opcode</p><p>F<b>0</b>DIVCMP; divide opcode</p><p>F<b>0</b>DIVL; divide opcode</p><p>F<b>0</b>DIVQ; divide opcode</p><p>F<b>0</b>DIVREM; divide opcode</p><p>F<b>0</b>DIVSGN; divide opcode</p><p>F<b>0</b>FLAGCF<b>0</b>; opcode requires using a version of EFLAGSCF</p><p>F<b>0</b>FLAGCF<b>1</b>; opcode requires using a version of EFLAGSCF</p><p>F<b>0</b>IDIVCMP; divide opcode</p><p>F<b>0</b>IDIVDEND<b>0</b>; divide opcode</p><p>F<b>0</b>IDIVDEND<b>1</b>; divide opcode</p><p>F<b>0</b>IDIVSOR; divide opcode</p><p>F<b>0</b>LOG_F<b>0</b>; logical type flag generation</p><p>F<b>0</b>LOG_F<b>1</b>; logical type flag generation</p><p>F<b>0</b>MUXCIN<b>0</b>; carry-in MUX</p><p>F<b>0</b>MUXCIN<b>1</b>; carry-in MUX</p><p>F<b>0</b>MUXDF<b>0</b>; direction flag MUX</p><p>F<b>0</b>MUXDF<b>1</b>; direction flag MUX</p><p>F<b>0</b>SELOPA; The initial quotient is from operand A else from adder output</p><p>F<b>0</b>SETCF<b>0</b>; ADC uses true version of EFLAGSCF else \u02dcEFLAGSCF</p><p>F<b>0</b>SETCF<b>1</b>; ADC uses true version of EFLAGSCF else \u02dcEFLAGSCF</p><p>F<b>0</b>STD_F<b>0</b>; store direction flag generation</p><p>F<b>0</b>STD_F<b>1</b>; store direction flag generation</p><p>F<b>0</b>UNC_BRN<b>0</b>; unconditional branch evaluation</p><p>F<b>0</b>UNC_BRN<b>1</b>; unconditional branch evaluation</p><p>F<b>0</b>UPDDF; update division direction bit</p><p>F<b>0</b>UPDQ; update division quotient</p><p>FISTAT_BRN<b>0</b>; assert proper branch status</p><p>FISTAT_BRN<b>1</b>; assert proper branch status</p><p>FISTAT_LD<b>0</b>; RES bus status\u2014load linear address</p><p>FISTAT_LD<b>1</b>; RES bus status\u2014load linear address</p><p>FISTAT_MUL<b>0</b>; RES bus status\u2014mulitplier</p><p>FISTAT_MUL<b>1</b>; RES bus status\u2014mulitplier</p><p>FISTAT_NONE<b>0</b>; RES bus status\u2014no result</p><p>FISTAT_NONE<b>1</b>; RES bus status\u2014no result</p><p>FISTAT_OPST<b>0</b>; RES bus status\u2014operand data for a store</p><p>FISTAT_OPST<b>1</b>; RES bus status\u2014operand data for a store</p><p>FISTAT_SRB<b>0</b>; RES bus status\u2014SRB information</p><p>FISTAT_SRB<b>1</b>; RES bus status\u2014SRB information</p><p>FISTAT_ST<b>0</b>; RES bus status\u2014store linear address</p><p>FISTAT_ST<b>1</b>; RES bus status\u2014store linear address</p><p>FISTAT_VAL<b>0</b>; RES bus status\u2014valid</p><p>FISTAT_VAL<b>1</b>; RES bus status\u2014valid</p><p>FNCUGO; functional unit GO indication</p><p>PURGE; resets all processes</p><p>RESET; resets all processes</p><p>RQLAC<b>0</b>; linear address calculation</p><p>RQLAC<b>1</b>; linear address calculation</p><p>SELSQXOPA; indicates that quotient gets shifted quotient slave instead of adder or OPA</p><p>SHFBCMP<b>1</b>; indicates a Bit Test and Complement</p><p>SHFBITEST<b>1</b>; a select signal for any Bit Test opcode</p><p>SHFBITOPA<b>1</b>; a select signal for only the BTEST (BT) opcode</p><p>SHFBSF<b>1</b>; select signal for Bit Scan Forward</p><p>SHFBSR<b>1</b>; select signal for Bit Scan Reverse</p><p>SHFBSXR<b>1</b>; indicates a set/reset for bit test instruction</p><p>SHFEFLAG<b>1</b>; merge Bop &amp; all flags into result</p><p>SHFFLGDF<b>1</b>; overwrite the DF position of Bop to form result</p><p>SHFFLGOF<b>1</b>; overwrite the OF position of Bop to form result</p><p>SHFLAHF<b>1</b>; load Flags into AH opcode</p><p>SHFLEFT<b>1</b>; indicates RCL, ROL, or SHL opcode</p><p>SHFRIGHT<b>1</b>; indicates RCR, ROR, SAR, or SHR opcode</p><p>SHFROT<b>1</b>; indicates a rotate or SHL opcode</p><p>SHFSAHF<b>1</b>; store AH into Flags opcode</p><p>SHFSELSF<b>31</b>_<b>1</b>; set the sign flag to the shifter output bit <b>31</b></p><p>SHFSETCF<b>1</b>; set carry flag for RCL &amp; RCR equal to EFLAGSCF</p><p>SHF_UPD_RC<b>1</b>; select for updating the local carry flag</p><p>SIGNXA<b>0</b>; sign extend the A operand</p><p>SIGNXA<b>1</b>; sign extend the A operand</p><p>SIGNXB<b>0</b>; sign extend the B operand</p><p>SIGNXB<b>1</b>; sign extend the B operand</p><p>SIGNXD<b>0</b>; sign extend the D operand</p><p>SIGNXD<b>1</b>; sign extend the D operand</p><p>USEOFFSET<b>0</b>; use offset for PUSH, POP, or FPU lin adr calc</p><p>USEOFFSET<b>1</b>; use offset for PUSH, POP, or FPU lin adr calc</p><p>ZEROXA<b>0</b>; zero extend the A operand</p><p>ZEROXA<b>1</b>; zero extend the A operand</p><p>ZEROXB<b>0</b>; zero extend the B operand</p><p>ZEROXB<b>1</b>; zero extend the B operand</p><p>ZEROXD<b>0</b>; zero extend the D operand</p><p>ZEROXD<b>1</b>; zero extend the D operand</p><p>[<b>1</b>:<b>0</b>] AHBYTE<b>0</b>; alignment select bits<b>0</b>; move bits <b>15</b>:<b>8</b> to <b>7</b>:<b>0</b></p><p>[<b>1</b>:<b>0</b>] AHBYTEL; alignment select bits<b>0</b>; move bits <b>15</b>:<b>8</b> to <b>7</b>:<b>0</b></p><p>[<b>21</b>:<b>0</b>] SHFSELPRE<b>1</b>; the preshift mux select signals</p><p>[<b>2</b>:<b>0</b>] F<b>0</b>GIN<b>0</b>; generate style inputs (used here to indicate type of operation)</p><p>[<b>2</b>:<b>0</b>] F<b>0</b>GIN<b>1</b>; generate style inputs (used here to indicate type of operation)</p><p>[<b>2</b>:<b>0</b>] SHFSELZF<b>1</b>; determines which groups of bit to use for setting the zero flag</p><p>[<b>13</b>:<b>01</b>] F<b>0</b>CTLST_WR; indicates which control store vector to use</p><p>[<b>3</b>:<b>0</b>] F<b>0</b>PIN<b>0</b>; propagate style inputs (used here to indicate type of operation)</p><p>[<b>3</b>:<b>0</b>] F<b>0</b>PIN<b>1</b>; propagate style inputs (used here to indicate type of operation)</p><p>[<b>3</b>:<b>0</b>] OPSIZEIN<b>0</b>; size/position of result (dword, word, ah, al)</p><p>[<b>3</b>:<b>0</b>]OPSIZEIN<b>1</b>; size/position of result (dword, word, ah, al)</p><p>[<b>3</b>:<b>0</b>] SHFSELOF<b>1</b>; determines which groups of bit to use for setting the overflow flag</p><p>[<b>3</b>:<b>0</b>] SHFSELOUT<b>1</b>; indicates final byte alignment for the shifter output</p><p>[<b>4</b>:<b>0</b>] F<b>0</b>SCALE; scale for SIB: <b>8</b>,<b>4</b>,<b>2</b>,<b>1</b>,<b>0</b></p><p>[<b>7</b>:<b>0</b>] F<b>0</b>CTLST_USE; indicates which control store vector to use</p><p>[<b>7</b>:<b>0</b>] FRESMUX<b>0</b>; select lines for MUX to RES bus</p><p>[<b>7</b>:<b>0</b>] FRESMUX<b>1</b>; select lines for MUX to RES bus</p><p>[<b>7</b>:<b>0</b>] FRESMUX; select lines for MUX to RES bus</p><p>[<b>7</b>:<b>0</b>] SHFSELCF<b>1</b>; determines which shifter bits to use to set the carry flag</p><p>[<b>9</b>:<b>0</b>] SHFSELCNT<b>1</b>; mux select signals determining source of shifter count value</p><p>CBVS Output Signal List (Control Bit Vector Store)</p><p>AXBLAC; indicates if operand A or B is used for linear addr calc</p><p>DIV<b>0</b>; initial divide opcode</p><p>DIV; divide opcode</p><p>DIVCMP; divide opcode</p><p>DIVL; divide opcode</p><p>DIVQ; divide opcode</p><p>DIVREM; divide opcode</p><p>DIVSGN; divide opcode</p><p>F<b>0</b>ADD_F; addition type flag generation</p><p>F<b>0</b>BCD_FC; BCD clear type flag generation</p><p>F<b>0</b>BCD_FS; BCD set type flag generation</p><p>F<b>0</b>CIN; carry-in from the control block</p><p>F<b>0</b>CLD_F; clear direction flag generation</p><p>F<b>0</b>CMC_F; complement carry type flag generation</p><p>F<b>0</b>COMPB; complement the B operand</p><p>F<b>0</b>COND_CODE; evaluate condition codes</p><p>F<b>0</b>DAA_FS; DAA type flag generation</p><p>F<b>0</b>FLAGCF; opcode requires using a version of EFLAGSCF</p><p>F<b>0</b>LOG_F; logical type flag generation</p><p>F<b>0</b>MUXCIN; carry-in MUX</p><p>F<b>0</b>MUXDF; direction flag MUX</p><p>F<b>0</b>SETCF; ADC uses true version of EFLAGSCF else \u02dcEFLAGSCF</p><p>F<b>0</b>STD_F; store direction flag generation</p><p>F<b>0</b>UNC_BRN; unconditional branch evaluation</p><p>FISTAT_BRN; assert proper branch status</p><p>FISTAT_LD; RES bus status\u2014load linear address</p><p>FISTAT_MUL; RES bus status\u2014mulitplier</p><p>FISTAT_NONE; RES bus status\u2014no result</p><p>FISTAT_OPST; RES bus status\u2014operand data for a store</p><p>FISTAT_SRB; RES bus status\u2014SRB information</p><p>FISTAT_ST; RES bus status\u2014store linear address</p><p>FISTAT_VAL; RES bus status\u2014valid</p><p>IDIVCMP; divide opcode</p><p>IDIVDEND<b>0</b>; divide opcode</p><p>IDIVDEND<b>1</b>; divide opcode</p><p>IDIVSOR; divide opcode</p><p>ISELOPA; The initial quotient is from operand A else from adder output</p><p>ISELSQXOPA; indicates that quotient gets shifted quotient slave instead of adder or OPA</p><p>MOVCC; select Bop from ALU output else take Aop</p><p>RQLAC; linear address calculation</p><p>SETCC; set bit <b>0</b> if conditions are true</p><p>SHFBCMP; indicates a Bit Test and Complement</p><p>SHFBITEST; a select signal for any Bit Test opcode</p><p>SHFBITOPA; a select signal for only the BTEST (BT) opcode</p><p>SHFBSF; select signal for Bit Scan Forward</p><p>SHFBSR; select signal for Bit Scan Reverse</p><p>SHFBSXR; indicates a set/reset for bit test instruction</p><p>SHFEFLAG; merge Bop &amp; all flags into result</p><p>SHFFLGDF; overwrite the DF position of Bop to form result</p><p>SHFFLGOF; overwrite the OF position of Bop to form result</p><p>SHFLAHF; load Flags into AH opcode</p><p>SHFLEFT; indicates RCL, ROL, or SHL opcode</p><p>SHFRIGHT; indicates RCR, ROR, SAR, or SHR opcode</p><p>SHFROT; indicates a rotate or SHL opcode</p><p>SHFSAHF; store AH into Flags opcode</p><p>SHFSELSF<b>31</b>; set the sign flag to the shifter output bit <b>31</b></p><p>SHFSETCF; set carry flag for RCL &amp; RCR equal to EFLAGSCF</p><p>SHF_UPD_RC; select for updating the local carry flag</p><p>SIGNXA; sign extend the A operand</p><p>SIGNXB; sign extend the B operand</p><p>SIGNXD; sign extend the D operand</p><p>UPDDF; update division direction bit</p><p>UPDQ; update division quotient</p><p>USEOFFSET; use offset for PUSH, POP, or FPU lin adr calc</p><p>ZEROXA; zero extend the A operand</p><p>ZEROXB; zero extend the B operand</p><p>ZEROXD; zero extend the D operand</p><p>[<b>1</b>:<b>0</b>] AHBYTE; alignment select bits<b>0</b>; move bits <b>15</b>:<b>8</b> to <b>7</b>:<b>0</b></p><p>[<b>21</b>:<b>0</b>] SHFSELPRE; the preshift mux select signals</p><p>[<b>2</b>:<b>0</b>] F<b>0</b>GIN; generate style inputs (used here to indicate type of operation)</p><p>[<b>2</b>:<b>0</b>] SHFSELZF; determines which groups of bit to use for setting the zero flag</p><p>[<b>3</b>:<b>0</b>] F<b>0</b>PIN; propagate style inputs (used here to indicate type of operation)</p><p>[<b>3</b>:<b>0</b>] OPSIZEIN; size/position of result (dword, word, ah, al)</p><p>[<b>3</b>:<b>0</b>] SHFSELOF; determines which groups of bit to use for setting the overflow flag</p><p>[<b>3</b>:<b>0</b>] SHFSELOUT; indicates final byte alignment for the shifter output</p><p>[<b>7</b>:<b>0</b>] FRESMUX; select lines for MUX to RES bus</p><p>[<b>7</b>:<b>0</b>] SHFSELCF; determines which shifter bits to use to set the carry flag</p><p>[<b>9</b>:<b>0</b>] SHFSELCNT; mux select signals determining source of shifter count value</p><p>OPSEL Sub-Block</p><p>The operand selection sub-block multiplexes the correct data in for forwarding and latches in the A operand, B operand, Displacement/immediate bus, and flags. Sign extension and alignment for Ahbyte data is also performed here.</p><p>OPSEL Input Signals (Operand Select and Alignment)</p><p>AXBLAC; indicates if operand A or B is used for linear addr calc</p><p>F<b>0</b>COMPB; complement the B operand</p><p>RQLAC; linear address calculation</p><p>SIGNXA; sign extend the A operand</p><p>SIGNXB; sign extend the B operand</p><p>SIGNXD; sign extend the D operand</p><p>USEOFFSET; use offset for PUSH, POP, or FPU lin adr calc</p><p>ZEROXA; zero extend the A operand</p><p>ZEROXB; zero extend the B operand</p><p>ZEROXD; zero extend the D operand</p><p>[<b>1</b>:<b>0</b>] AHBYTE; alignment select bits<b>0</b>; move bits <b>15</b>:<b>8</b> to <b>7</b>:<b>0</b></p><p>[<b>31</b>:<b>0</b>] AOPND; A operand</p><p>[<b>31</b>:<b>0</b>] BOPND; B operand</p><p>[<b>31</b>:<b>0</b>] DSPR; displacement</p><p>[<b>31</b>:<b>0</b>] FDRES<b>0</b>; forwarded result bus from position <b>0</b></p><p>[<b>31</b>:<b>0</b>] FDRES<b>1</b>; forwarded result bus from position <b>1</b></p><p>[<b>31</b>:<b>0</b>] FDRES<b>2</b>; forwarded result bus from position <b>2</b></p><p>[<b>31</b>:<b>0</b>] FDRES<b>3</b>; forwarded result bus from position <b>3</b></p><p>[<b>31</b>:<b>0</b>] LSRES<b>0</b>; LSSEC result bus <b>0</b></p><p>[<b>31</b>:<b>0</b>] LSRES<b>1</b>; LSSEC result bus <b>1</b></p><p>[<b>3</b>:<b>0</b>] OFFSET; offset used for PUSH, POP, and FPU lin adr calc</p><p>[<b>3</b>:<b>0</b>] OPSIZEIN; size/position of result (dword, word, ah, al)</p><p>[<b>4</b>:<b>0</b>] F<b>0</b>SCALE; scale for SIB: <b>8</b>,<b>4</b>,<b>2</b>,<b>1</b>,<b>0</b></p><p>[<b>6</b>:<b>0</b>] FLGD; input flag data from the reservation station</p><p>[<b>6</b>:<b>0</b>] RFLAG<b>0</b>; input flag data from position <b>0</b></p><p>[<b>6</b>:<b>0</b>] RFLAG<b>1</b>; input flag data from position <b>1</b></p><p>[<b>6</b>:<b>0</b>] RFLAG<b>2</b>; input flag data from position <b>2</b></p><p>[<b>6</b>:<b>0</b>] RFLAG<b>3</b>; input flag data from position <b>3</b></p><p>[<b>6</b>:<b>0</b>] RFLAGLS<b>0</b>; input flag data from LSSEC <b>0</b></p><p>[<b>6</b>:<b>0</b>] RFLAGLS<b>1</b>; input flag data from LSSEC <b>1</b></p><p>[<b>7</b>:<b>0</b>] FNCUMUXA; mux control from reservation station for A operand input</p><p>[<b>7</b>:<b>0</b>] FNCUMUXB; mux control from reservation station for B operand input</p><p>[<b>7</b>:<b>0</b>] FNCUMUXCF; mux control from reservation station for the carry flag</p><p>[<b>7</b>:<b>0</b>] FNCUMUXSTF; mux control from reservation station for the status flags</p><p>OPSEL Output Signals (Operand Select and Alignment)</p><p>[<b>31</b>:<b>0</b>] OPA; aligned operand A</p><p>[<b>31</b>:<b>0</b>] OPB; aligned operand B</p><p>[<b>6</b>:<b>0</b>] IFLG; latched input flags</p><p>ALU Sub-Block</p><p>All logical, arithmetic, and basic moves are performed by this block. Linear address calculations and branch address calculations are also performed here. Only FNCU<b>0</b> is capable of performing division operations.</p><p>ALU Input Signals for FNCU<b>0</b> Type</p><p>DIV<b>0</b>; initial divide opcode</p><p>DIV; divide opcode</p><p>DIVCMP; divide opcode</p><p>DIVL; divide opcode</p><p>DIVQ; divide opcode</p><p>DIVREM; divide opcode</p><p>DIVSGN; divide opcode</p><p>F<b>0</b>CIN; carry-in from the control block</p><p>F<b>0</b>MUXCIN; carry-in MUX</p><p>F<b>0</b>MUXDF; direction flag MUX</p><p>FNCUGO; functional unit GO indication</p><p>IDIVCMP; divide opcode</p><p>IDIVDEND<b>0</b>; divide opcode</p><p>IDIVDEND<b>1</b>; divide opcode</p><p>IDIVSOR; divide opcode</p><p>ISELOPA; The initial quotient is from operand A else from adder output</p><p>ISELSQXOPA; indicates that quotient gets shifted quotient slave instead of adder or OPA</p><p>PURGE; resets all processes</p><p>RESET; resets all processes</p><p>UPDDF; update division direction bit</p><p>UPDQ; update division quotient</p><p>[<b>2</b>:<b>0</b>] F<b>0</b>GIN; generate style inputs (used here to indicate type of operation)</p><p>[<b>31</b>:<b>0</b>] OPA; aligned operand A</p><p>[<b>31</b>:<b>0</b>] OPB; aligned operand B</p><p>[<b>3</b>:<b>0</b>] F<b>0</b>PIN; propagate style inputs (used here to indicate type of operation)</p><p>[<b>3</b>:<b>0</b>] OPSIZEIN; size/position of result (dword, word, ah, al)</p><p>ALU Input Signals for FNCU<b>1</b> to FNCU<b>3</b> Types</p><p>F<b>0</b>CIN; carry-in from the control block</p><p>F<b>0</b>MUXCIN; carry-in MUX</p><p>F<b>0</b>MUXDF; direction flag MUX</p><p>FNCUGO; functional unit GO indication</p><p>PURGE; resets all processes</p><p>RESET; resets all processes</p><p>[<b>2</b>:<b>0</b>] F<b>0</b>GIN; generate style inputs (used here to indicate type of operation)</p><p>[<b>31</b>:<b>0</b>] OPA; aligned operand A</p><p>[<b>31</b>:<b>0</b>] OPB; aligned operand B</p><p>[<b>3</b>:<b>0</b>] F<b>0</b>PIN; propagate style inputs (used here to indicate type of operation)</p><p>[<b>3</b>:<b>0</b>] OPSIZEIN; size/position of result (dword, word, ah, al)</p><p>ALU Output Signals</p><p>A<b>0</b>COUT<b>14</b>; ALU output bit</p><p>A<b>0</b>COUT<b>30</b>; ALU output bit</p><p>A<b>0</b>COUT<b>3</b>; ALU output bit</p><p>A<b>0</b>COUT<b>6</b>; ALU output bit</p><p>F<b>0</b>COUT<b>15</b>; ALU output bit</p><p>F<b>0</b>COUT<b>31</b>; ALU output bit</p><p>F<b>0</b>COUT<b>7</b>; ALU output bit</p><p>[<b>31</b>:<b>0</b>] ARES; ALU result</p><p>SHFT Sub-Block</p><p>The shifter sub-block performs right shifts only. It can also perform bit test and set/clear/complement as well as RCL by one or RCR by one.</p><p>SHFT Input Signals (Shifter)</p><p>FNCUGO; functional unit GO indication</p><p>PURGE; resets all processes</p><p>RESET; resets all processes</p><p>SFTCFIN; carry in flag for shifter</p><p>SHFBCMP; indicates a Bit Test and Complement</p><p>SHFBITEST; a select signal for any Bit Test opcode</p><p>SHFBITOPA; a select signal for only the BTEST (BT) opcode</p><p>SHFBSF; select signal for Bit Scan Forward</p><p>SHFBSR; select signal for Bit Scan Reverse</p><p>SHFBSXR; indicates a set/reset for bit test instruction</p><p>SHFEFLAG; merge Bop &amp; all flags into result</p><p>SHFFLGDF; overwrite the DF position of Bop to form result</p><p>SHFFLGOF; overwrite the OF position of Bop to form result</p><p>SHFLAHF; load Flags into AH opcode</p><p>SHFLEFT; indicates RCL, ROL, or SHL opcode</p><p>SHFRIGHT; indicates RCR, ROR, SAR, or SHR opcode</p><p>SHFROT; indicates a rotate or SHL opcode</p><p>SHFSAHF; store AH into Flags opcode</p><p>SHFSELSF<b>31</b>; set the sign flag to the shifter output bit <b>31</b></p><p>SHFSETCF; set carry flag for RCL &amp; RCR equal to EFLAGSCF</p><p>SHF<sub>\u2014UPD_RC; select for updating the local carry flag </sub></p><p>[<b>21</b>:<b>0</b>] SHFSELPRE; the preshift mux select signals</p><p>[<b>2</b>:<b>0</b>] SHFSELZF; determines which groups of bit to use for setting the zero flag</p><p>[<b>31</b>:<b>0</b>] OPA; aligned operand A</p><p>[<b>31</b>:<b>0</b>] OPB; aligned operand B</p><p>[<b>3</b>:<b>0</b>] OPSIZEIN; size/position of result (dword, word, ah, al)</p><p>[<b>3</b>:<b>0</b>] SHFSELOF; determines which groups of bit to use for setting the overflow flag</p><p>[<b>3</b>:<b>0</b>] SHFSELOUT; indicates final byte alignment for the shifter output</p><p>[<b>7</b>:<b>0</b>] SHFSELCF; determines which shifter bits to use to set the carry flag</p><p>[<b>9</b>:<b>0</b>] SHFSELCNT; mux select signals determining source of shifter count value</p><p>SHFT Output Signals (Shifter)</p><p>[<b>31</b>:<b>0</b>] SHFTOUT; shifter information for flag generation</p><p>[<b>31</b>:<b>0</b>] SRES; shifter result</p><p>MXDRV Sub-Block</p><p>This block multiplexes results from several different sub-blocks and from the multiplier and aligns the output properly before driving the result onto the FDRES bus.</p><p>MXDRV Input Signals (Output Multiplier, Aligment, and Drivers)</p><p>BRN_ADR; assert proper branch status</p><p>BRN_NT; assert proper branch status</p><p>BRN_OK; assert proper branch status</p><p>BRN_T_ADR; assert proper branch status</p><p>BRN_T_OK; assert proper branch status</p><p>DCPAPRHIT; data cache port A predicted way hit</p><p>DCPBPRHIT; data cache port B predicted way hit</p><p>DCUNPAHIT; data cache port A unpredicted way hit</p><p>DCUNPBHIT; data cache port B unpredicted way hit</p><p>FISTAT_BRN; assert proper branch status</p><p>FISTAT_LD; RES bus status\u2014load linear address</p><p>FISTAT_MUL; RES bus status\u2014mulitplier</p><p>FISTAT_NONE; RES bus status\u2014no result</p><p>FISTAT OPST; RES bus status\u2014operand data for a store</p><p>FISTAT_SRB; RES bus status\u2014SRB information</p><p>FISTAT_ST; RES bus status\u2014store linear address</p><p>FISTAT_VAL; RES bus status\u2014valid</p><p>FNCUGO; functional unit GO indication</p><p>MOVCCSEL; select Bop from ALU input else take Aop</p><p>OPALSRES<b>0</b>; used to qualify valid status; else mispredicted way miss; Aop &amp; DC port <b>0</b></p><p>OPALSRES<b>1</b>; used to qualify valid status; else mispredicted way miss; Aop &amp; DC port <b>1</b></p><p>OPBLSRES<b>0</b>; used to qualify valid status; else mispredicted way miss; Bop &amp; DC port <b>0</b></p><p>OPBLSRES<b>1</b>; used to qualify valid status; else mispredicted way miss; Bop &amp; DC port <b>1</b></p><p>PURGE; resets all processes</p><p>RESET; resets all processes</p><p>[<b>10</b>:<b>0</b>] INSSEG; LSSEC segment MUX select</p><p>[<b>1</b>:<b>0</b>] LSCANFWD; LSSEC cancel signal for forwarded data on the LSRESn bus</p><p>[<b>2</b>:<b>0</b>] CDTAG; current destination tag for the incoming opcode</p><p>[<b>31</b>:<b>0</b>] ARES; ALU result</p><p>[<b>31</b>:<b>0</b>] FLGRES; combined EFLAGS result</p><p>[<b>31</b>:<b>0</b>] MULTRES; multiply floating point bus</p><p>[<b>31</b>:<b>0</b>] SRES; shifter result</p><p>[<b>3</b>:<b>0</b>] OPSIZEIN; size/position of result (dword, word, ah, al)</p><p>[<b>7</b>:<b>0</b>] FRESMUX; select lines for MUX to RES bus</p><p>MXDRV Output Signals (Output Multiplier, Aligment, and Drivers)</p><p>F<b>0</b>BRN_ADR; assert proper branch status</p><p>F<b>0</b>BRN_NT; assert proper branch status</p><p>F<b>0</b>BRN_OK; assert proper branch status</p><p>F<b>0</b>BRN_T_ADR; assert proper branch status</p><p>F<b>0</b>BRN_T_OK; assert proper branch status</p><p>F<b>0</b>STAT_LD; RES bus status\u2014load linear address</p><p>F<b>0</b>STAT_MUL; RES bus status\u2014mulitplier</p><p>F<b>0</b>STAT_NONE; RES bus status\u2014no result</p><p>F<b>0</b>STAT_OPST; RES bus status\u2014operand data for a store</p><p>F<b>0</b>STAT_SRB; RES bus status\u2014SRB information</p><p>F<b>0</b>STAT_ST; RES bus status\u2014store linear address</p><p>F<b>0</b>STAT_VAL; RES bus status\u2014valid</p><p>[<b>10</b>:<b>0</b>] INSLSB; LSSEC segment MUX</p><p>[<b>14</b>:<b>0</b>] RESLA; early result bits send to LSSEC DCACHE</p><p>[<b>2</b>:<b>0</b>] DTAG; destination tag</p><p>[<b>2</b>:<b>0</b>] RSTAT; result status</p><p>[<b>31</b>:<b>0</b>] FDRES; forwarded RES bus</p><p>FLGCC Sub-Block</p><p>This block is responsible for the flag generation, condition code evaluation, and branch evaluation. The CF, carry flag, is generated the same same and can be immediately forwarded with the result data. However, the other six flags are generated next cycle and can only be forwarded to such operations as jumps which can accept the flags mid-cycle.</p><p>FLGCC Input Signals (Flags Generation, Condition Codes and Branch Evaluation)</p><p>A<b>0</b>COUT<b>14</b>; ALU output bit</p><p>A<b>0</b>COUT<b>30</b>; ALU output bit</p><p>A<b>0</b>COUT<b>3</b>; ALU output bit</p><p>A<b>0</b>COUT<b>6</b>; ALU output bit</p><p>F<b>0</b>ADD_F; addition type flag generation</p><p>F<b>0</b>BCD_FC; BCD clear type flag generation</p><p>F<b>0</b>BCD_FS; BCD set type flag generation</p><p>F<b>0</b>CLD_F; clear direction flag generation</p><p>F<b>0</b>CMC_F; complement carry type flag generation</p><p>F<b>0</b>COND_CODE; evaluate condition codes</p><p>F<b>0</b>COUT<b>15</b>; ALU output bit</p><p>F<b>0</b>COUT<b>31</b>; ALU output bit</p><p>F<b>0</b>COUT<b>7</b>; ALU output bit</p><p>F<b>0</b>DAA_FS; DAA type flag generation</p><p>F<b>0</b>LOG_F; logical type flag generation</p><p>F<b>0</b>STD_F; store direction flag generation</p><p>F<b>0</b>UNC_BRN; unconditional branch evaluation</p><p>FISTAT BRN; assert proper branch status</p><p>FNCUGO; functional unit GO indication</p><p>MOVCC; select Bop from ALU output else take Aop</p><p>MULXF; value of all multiply flags</p><p>PURGE; resets all processes</p><p>RESET; resets all processes SETCC; set bit <b>0</b> if conditions are true</p><p>[<b>31</b>:<b>0</b>] OPB; aligned operand B</p><p>[<b>31</b>:<b>0</b>] SHFTOUT; shifter information for flag generation</p><p>[<b>3</b>:<b>0</b>] OPSIZEIN; size/position of result (dword, word, ah, al)</p><p>[<b>6</b>:<b>0</b>] IFLG; latched input flags</p><p>FLGCC Output Signals (Flags Generation, Condition Codes and Branch Evaluation)</p><p>BRN_ADR; assert proper branch status</p><p>BRN_NT; assert proper branch status</p><p>BRN_OK; assert proper branch status</p><p>BRN_T_ADR; assert proper branch status</p><p>BRN_T_OK; assert proper branch status</p><p>MOVCCSEL; select Bop from ALU output else take Aop</p><p>[<b>31</b>:<b>0</b>] FLGRES; combined EFLAGS result</p><p>[<b>6</b>:<b>0</b>] RFLAG; result flags</p><p>Multiplier Signal List</p><p>Multiplier Input Signals List</p><p>MULCYC2\u00d73; number of multiply cycles is 2, else use 3</p><p>MULONEOP; opcode is for the one operand version</p><p>MULRQ<b>0</b>; multiply request from position <b>0</b></p><p>MULRQ<b>1</b>; multiply request from position <b>1</b></p><p>MULRQ<b>2</b>; multiply request from position <b>2</b></p><p>MULRQ<b>3</b>; multiply request from position <b>3</b></p><p>MULSIGN; signed values</p><p>PURGE; resets all processes in the multiplier</p><p>RESET; resets all processes in the multiplier and GRNT_CNT</p><p>[<b>1</b>:<b>01</b> ] MULOPSIZE; input operands are <b>01</b>: byte, <b>10</b>: word, or <b>11</b>: dword</p><p>[<b>31</b>:<b>0</b>] SAOPND; shared A operand bus</p><p>[<b>31</b>:<b>0</b>] SBOPND; shared B operand bus</p><p>Multiplier Outputs</p><p>MULGR<b>0</b>; multiply grant to position <b>0</b></p><p>MULGR<b>1</b>; multiply grant to position <b>1</b></p><p>MULGR<b>2</b>; multiply grant to position <b>2</b></p><p>MULGR<b>3</b>; multiply grant to position <b>3</b></p><p>MULXF; value of all multiply flags</p><p>[<b>31</b>:<b>0</b>] MULRES; multiplier output bus <b>0</b></p><p>Overview of the Processor <b>500</b> FIROB</p><p>This section describes the Four-Issue Re-Order Buffer (FIROB), including methods of reducing the dependency checking time. The Processor <b>500</b> FIROB has a structure including the data array, the status and control arrays with associated control logic, and the special registers. The four-issue ROB is line-oriented which means that the number of dispatched instructions is always 4 (some of the instructions may be NOOP), and the number of retired instructions is always 4. The FIROB size is 6 lines of 4 instructions for a total of 24 entries. There are a few exceptions to retire the partial line such as branch mis-prediction, interrupt, and re-synchronization. There are 8 read buses and 4 retire buses to support a line of Processor <b>500</b> instructions. The number of result buses are <b>6</b>, <b>4</b> result buses are for results from 4 functional units and 2 results buses are for load/store and special register instructions to return data to the FIROB. The buses are 32-bits wide. The FIROB supports a massive number of comparators to dispatch 4 instructions in a line. To support the push/pop instructions with indirect references to the ESP, the FIROB includes 6 ESP latches. The latches are strictly for updating the ESP in the register file correctly.</p><p>Top Level of the FIROB</p><p>The FIROB is accessed by a line of instructions instead of an individual instruction. The line has 4 instructions, some instructions can be NOOP. Line-oriention has the advantage of a single input and allocation in the FIROB. The logic to deal with one line is much simpler than logic to deal with a combination of 0 to 4 instructions. Since the clock cycle time is short, a new method has to be implemented to do the dependency checking in one clock cycle and driving the data in the next cycle. The FIROB includes of 6 lines of instructions, where each line has 4 instructions. FIROB will have one clock cycle to compare the read addresses of the dispatched line to the destination entries of the previous 5 lines for dependency and to check the dependency within the dispatched line. The FIROB implements new status bits to indicate the most up-to-date destination to reduce the dependency checking time. The X86 instructions allow 2 operands, wherein one of the operands can be both destination and source. The FIROB checks dependency on both source and destination operands, the dependency of the destinations sets the last-in-line status which reduces the future dependency checking. A set of ESP latches are implemented to provide fast execution of the push/pop instructions. The FIROB can keep track and generate dependency data for the ESP without stalling or serializing any ESP instructions.</p><p>Organization of the FIROB</p><p>Processor <b>500</b> uses fixed issue positions for the decode units and the functional units. The FIROB and the register file conform to this arrangement. The operand addresses from the decode unit and the result buses from the functional unit individually access the fixed positions of the FIROB. The proposed arrangement of the FIROB is to have the address and data registers, the comparator, and the control status bits for the comparator in the data path between the decode units and the functional units. Other status bits and control logic are on one side of the data path as shown in FIG. 33. A proposed layout of the FIROB and register file is described below. The read buses can come from any entry in the FIROB because of forwarding. An operand bus steering may be needed to take the inputs from the FIROB or REGF and route to the functional units.</p><p>FIROB is organized as 6 lines of 4 instructions each. The pointer to the entries has two parts: a 3-bit line pointer and a 2-bit entry pointer. The line pointer increases after every dispatch, and the whole line is dispatched or retired at one time. This is 3-bit incrementor and wraps around at the count of 5. Other reorder buffers (ROBs) are implemented with read and write pointers, the read pointer increases as instructions are dispatched and the write pointer increases as the instruction are retired. Since Processor <b>500</b> FIROB allocates or retires one line of instructions at a time and the number of dependency comparator is large, FIROB should be a FIFO (First-In-First-Out) instead of moving the pointers. The dependency comparators are always at lines <b>0</b>-<b>4</b>. No dependency checking is needed in line <b>5</b>, and the retire line (write pointer) is always from line <b>0</b>. As a line of instructions is retired from line <b>0</b>, lines <b>1</b>-<b>5</b> will shift up by 1. The read pointer increases as a new line is dispatched and decreases as a line is retired. To track the FIROB line number for the instructions in the reservation station, functional units, and load/store section, a virtual line pointer is assigned to each line as the line is dispatched from the decode units. The virtual line pointer is used by the reservation stations for result forwarding, by the functional unit and the load/store section to return result data to the FIROB, and by the load/store buffer to access the data cache in program order. The FIROB use the virtual line pointer to latch the result data. The virtual line pointer is attached to each line in the FIROB and circular shifted as the line is retired from the FIROB.</p><p>From FIG. 33, the result data of the FIROB and the register file drive the source data to 8 horizontal buses. Each functional unit receives 2 read buses from these horizontal buses. The layout of the result data of the FIROB and the register file sis adjacent to access the horizontal buses directly. A suggested layout organization is illustrated in FIG. <b>34</b>.</p><p>Signal List</p><p>IRESET\u2014Global signal used to reset all decode units. Clears all states.</p><p>NMI_P\u2014Input from BIU indicates non-maskable interrupt, the FIROB generates a clean instruction boundary trap to a fixed entry point. The FIROB is sensitive only to the rising edge of this signal</p><p>INTR_P\u2014Input from BIU indicates the external interrupt. This signal is qualified with the IF bit of the EFLAGS register. The interrupt occurs at appropriate instruction boundaries.</p><p>SRBHALT\u2014Input from SRB to enter HALT mode. The FIROB stops retiring instructions until RESET, NMI, or external interrupt occurs. The FIROB must retire the HALT instruction before shutting down.</p><p>CRONE\u2014Input from SRB indicates the NE bit of the CRO register. The NE bit indicates the floating point exception can be trapped directly (NE=1) or via XFERR_P and an external interrupt (NE=0).</p><p>XIGNNE_P\u2014Input from BIU indicates the copy of pin IGNNE. When CRONE=0, this signal is inspected to response to enabled floating point exceptions.</p><p>XFLUSH_P\u2014Input from BIU indicates an external flush request occurs. It is falling edge sensitive and trap on instruction boundary. It is sample during IRESET to enter tri-state test mode, the FIROB should not generate exception.</p><p>IINIT\u2014Input from BIU indicates an initialization request. It is rising edge sensitive and trap on instruction boundary. It is sample during IRESET to enter BIST test mode, the FIROB generates on of the two reset entry point.</p><p>MVTOSRIAD\u2014Input from SRB, indicates a move to IAD special register, FIROB needs to check its pointer against the pointer driven on IAD.</p><p>MVFRSRIAD\u2014Input from SRB, indicates a move from IAD special register, FIROB needs to check its pointer against the pointer driven on IAD.</p><p>MVTOARIAD\u2014Input from SRB, indicates a move to IAD special register array, FIROB needs to check its pointer against the pointer driven on IAD.</p><p>MVFRARIAD\u2014Input from SRB, indicates a move from IAD special register array, FIROB needs to check its pointer against the pointer driven on IAD.</p><p>MROMDEC(<b>3</b>:<b>0</b>)\u2014Input from MROM indicates the microcodes are being decoded by the decode units. Use to set the ROBEXIT bit.</p><p>RESx(<b>31</b>:<b>0</b>)\u2014Input from FU indicates result data.</p><p>DTAGx(<b>2</b>:<b>0</b>)\u2014Input from FU indicates FIROB line number of the result.</p><p>DSTATx(<b>3</b>:<b>0</b>)\u2014Input from FU indicates the status of the result data:</p><p>0000\u2014no result</p><p>0001\u2014valid result</p><p>0010\u2014valid result, shift by zero</p><p>0011\u2014exception with vector</p><p>0100\u2014software interrupt with vector</p><p>0101\u2014TLB miss with vector</p><p>0110\u2014load/store breakpoint</p><p>0111\u2014exchange result</p><p>1000\u2014exchange with underflow</p><p>1001\u2014exchange abort</p><p>1010\u2014branch taken, mis-prediction</p><p>1011\u2014branch not taken, mis-prediction</p><p>1100\u2014reserved for FPU</p><p>1101\u2014reserved for FPU</p><p>1110\u2014reserved for FPU</p><p>1111\u2014reserved for FPU</p><p>RFLAGx(<b>31</b>:<b>0</b>)\u2014Input from FU indicates result flags.</p><p>LSTAG<b>0</b>(<b>4</b>:<b>0</b>)\u2014Input from LSSEC indicates FIROB line number of the first access.</p><p>LSTAG<b>1</b>(<b>4</b>:<b>0</b>)\u2014Input from LSSEC indicates FIROB line number of the second access.</p><p>LSRES<b>0</b>(<b>31</b>:<b>0</b>)\u2014Input from LSSEC indicates result data of the first access.</p><p>LSRES<b>1</b>(<b>31</b>:<b>0</b>)\u2014Input from LSSEC indicates result data of the second access.</p><p>IDPC<b>1</b>(<b>31</b>:<b>0</b>)\u2014Input from Idecode indicates the current line PC of the first instruction in the 4 dispatched instructions.</p><p>IDPC<b>2</b>(<b>31</b>:<b>0</b>)\u2014Input from Idecode indicates the current line PC of a second instruction which cross the 16-byte boundary or branch target in the 4 dispatched instructions</p><p>ICPOSx(<b>3</b>:<b>0</b>)\u2014ICLK<b>7</b> Input from Icache to decode units indicates the PC's byte position of the instruction.</p><p>IDxDAT(<b>1</b>:<b>0</b>)\u2014Input from Idecode indicates the data size information. 01-byte, 10-half word, 11-word, 00-not use.</p><p>IDxADDR\u2014Input from Idecode indicates the address size information. 1-32 bit, 0-bit.</p><p>ICVALI(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates valid instructions. NOOP is generated for invalid instruction.</p><p>NODEST(<b>3</b>:<b>0</b>)\u2014Input from Icache indicates no destination for the first rop of the SIB-byte instruction.</p><p>DEPTAG(<b>3</b>:<b>1</b>)\u2014Input from Icache indicates forced dependency tag on the first instruction; the second rop of the SIB-byte instruction.</p><p>DxUSEFL(<b>2</b>:<b>0</b>)</p><p>DxWRFL(<b>2</b>:<b>0</b>)\u2014Input from Icache indicates the type of flag uses/writes for this instruction of decode units:</p><p>xx<b>1</b> CF\u2014carry flag,</p><p>x<b>1</b>x OF\u2014overflow flag,</p><p><b>1</b>xx SF\u2014sign, ZF\u2014zero, PF\u2014parity, and AF\u2014auxiliary carry</p><p>DxUSE<b>1</b>(<b>1</b>:<b>0</b>)\u2014Input from Icache indicates the type of operand being sent on operand <b>1</b> for decode units. Bit <b>1</b> indicates source operand, and bit <b>0</b> indicates destination operand.</p><p>DxUSE<b>2</b>\u2014Input from Idecode indicates indicates source operand.</p><p>INSDISP(<b>3</b>:<b>0</b>)\u2014Input from Idecode indicates that the instruction in decode unit is valid, if invalid, NOOP is passed to FIROB.</p><p>RDxPTR<b>1</b>(<b>5</b>:<b>0</b>)\u2014Input from Icache indicates the register address for operand <b>1</b> of the instructions.</p><p>RDxPTR<b>2</b>(<b>5</b>:<b>0</b>)\u2014Input from Icache indicates the register address for operand <b>2</b> of the instructions.</p><p>INSLSxB(<b>5</b>:<b>0</b>)\u2014Input from decode units indicates the prefix values. bit <b>5</b>\u2014data size, bit <b>4</b>\u2014address size, bit <b>3</b>\u2014lock, bit <b>2</b>:<b>0</b>\u2014segment registers.</p><p>IDECJAMIC\u2014Output indicates that an interrupt or trap is being taken. Effect on Icache is to clear all pre-fetch or access in progress, and set all state machines to Idle/Reset.</p><p>EXCEPTION\u2014Global output indicates that an interrupt or trap is being taken including resynchronization. Effect on Idecode and Fus is to clear all instructions in progress. REQTRAP\u2014Global output, one cycle after EXCEPTION,</p><p>indicates that the trap is initiated with new entry point or new PC is driven.</p><p>SYNC\u2014Output indicates whether the new entry point or new PC is driven.</p><p>EXCHGSYNC\u2014Output indicates exchange instruction resynchronization to Icache. This occurs when an exchange with a masked underflow is retired. It is a special resynchronize exchange with alternate entry point.</p><p>XFERR_P\u2014Output to BIU indicates the floating point error which is inverted of the ES bit from the slave of the floating point status register. It is also used by the FIROB to generate the plunger traps.</p><p>EFLAGSAC</p><p>EFLAGSVM</p><p>EFLAGSRF</p><p>EFIOPL(<b>13</b>:<b>12</b>)</p><p>EFLAGSOF</p><p>EFLAGSDF</p><p>EFLAGSAF</p><p>EFLAGSCF\u2014Output generates from the EFLAGS register, these bits are visible from the slave copy of the EFLAGS register. The RF bit is also used in the FIROB to handle instruction breakpoint.</p><p>BRNMISP\u2014Input from the Branch execution of the FU indicates that a branch mis-prediction. The Idecode clears all instructions in progress.</p><p>UPDFPC\u2014Output to Icache indicate that a new Fetch PC has been detected. This signal accompanies the FPC for the Icache to begin access the cache arrays.</p><p>TARGET(<b>31</b>:<b>0</b>)\u2014Output to Icache as the new PC for branch correction path.</p><p>BRNMISP\u2014Input to Icache indicates that a branch mis-prediction. The Icache changes its state machine to access a new PC and clears all pending instructions.</p><p>BRNTAKEN\u2014Output to Icache indicates the status of the mis-prediction. This signal must be gated with UPDFPC.</p><p>BRNFIRST\u2014Output to Icache indicates the first or second target in the ICNXTBLK for updating the branch prediction.</p><p>BRNCOL(<b>3</b>:<b>0</b>)\u2014Output to Icache indicates the instruction byte for updating the branch prediction in the ICNXTBLK.</p><p>FPCTYP\u2014Input to Icache indicates the type of address that is being passed to the Icache.</p><p>BPC(<b>11</b>:<b>0</b>)\u2014Output indicates the PC index and byte-pointer of the branch instruction which has been mis-predicted for updating the ICNXTBLK.</p><p>ROBEMPTY\u2014Output indicates the FIROB is empty.</p><p>ROBFULL\u2014Output indicates the FIROB is full.</p><p>LINEPTR(<b>2</b>:<b>0</b>)\u2014Output indicates the current line pointer in the FIROB for the dispatch line of instructions.</p><p>WBLPTR(<b>2</b>:<b>0</b>)\u2014Output indicates the write-back line pointer in the FIROB for the retiring line of instructions.</p><p>WBxNC\u2014Output indicates the invalid write-back data to the register file for retiring instructions.</p><p>WBxPTR(<b>5</b>:<b>0</b>)\u2014Output indicates the write-back pointer to the register file for retiring instructions.</p><p>WBxD(<b>31</b>:<b>0</b>)\u2014Output indicates the write-back data to the register file for retiring instructions.</p><p>WBxBYTE(<b>3</b>:<b>0</b>)\u2014Output indicates the write-back selected bytes to the register for retiring instructions.</p><p>RBxDAT<b>1</b>(<b>31</b>:<b>0</b>)\u2014Output indicates the first source operand data for dispatching instructions.</p><p>RBxDAT<b>2</b>(<b>31</b>:<b>0</b>)\u2014Output indicates the second source operand data for dispatching instructions.</p><p>FLGxDAT<b>1</b>(<b>5</b>:<b>0</b>)\u2014Output indicates the status flags for dispatching instructions.</p><p>RBxTAG<b>1</b>(<b>4</b>:<b>0</b>)\u2014Output indicates the first dependency tag for dispatching instructions.</p><p>RBxTAG<b>2</b>(<b>4</b>:<b>0</b>)\u2014Output indicates the second dependency tag for dispatching instructions.</p><p>FCFxTAG(<b>4</b>:<b>0</b>)\u2014Output indicates the CF flag dependency tag for dispatching instructions.</p><p>FOFxTAG(<b>4</b>:<b>0</b>)\u2014Output indicates the CF flag dependency tag for dispatching instructions.</p><p>FXFxTAG(<b>4</b>:<b>0</b>)\u2014Output indicates the CF flag dependency tag for dispatching instructions.</p><p>PUSHPOP(<b>2</b>:<b>1</b>)\u2014Output to register file indicates the pop bits of the floating point status register to clear the full bits of the register being popped. FPTOP(<b>2</b>:<b>0</b>) contains the current top-of-stack when these bits are asserted.</p><p>FPTOP(<b>2</b>:<b>0</b>)\u2014Output to register file indicates the current top-of-stack to identify the registers being popped to clear the full bits.</p><p>WBEXCHG\u2014Output to register file indicates the exchange instruction being retired. It causes the permanent remapping register to be updated from the write-back bus.</p><p>WRPTR(<b>4</b>:<b>0</b>)\u2014Output to LSSEC indicates the bottom (oldest) entry in the FIROB without valid result. If this entry matches the store or load-miss entry in the LSSEC, the entry can access the data cache at this time.</p><p>CANENTRY\u2014Output to LSSEC indicates the bottom entry in the FIROB without valid result is canceled. If this entry matches the store or load-miss entry in the LSSEC, the entry can return without access the data cache at this time.</p><p>WRPTR<b>1</b>(<b>4</b>:<b>0</b>)\u2014Output to LSSEC indicates the next to bottom entry in the FIROB without valid result. If this entry matches the store or load-miss entry in the LSSEC, the entry can access the data cache.</p><p>CANENTRY\u2014Output to LSSEC indicates the next to bottom entry in the FIROB without valid result is canceled. If this entry matches the store or load-miss entry in the LSSEC, the entry can return without access the data cache.</p><p>Basic Operations</p><p>The FIROB interfaces with the decode units for dispatching instructions, with the functional units and LSSEC for results, and with the register file for retiring instructions. The FIROB updates the special registers correctly with each retiring instructions, handles trap/interrupt gracefully, and re-synchronizes the pipeline after branch mis-prediction, self-modifying code, or changing the code segment register.</p><p>Dispatch Interface</p><p>Every cycle, the FIROB indicates the space status to the decode unit via ROBFULL or ROBEMPTY. As long as the FIROB is not full a line of instructions can be dispatched. The empty status is for serialized instructions. The dependency checking is performed for the operands and flags of the top 5 valid lines of the FIROB. The FIROB performs the dependency checking for 2 register operands and validates the results with decode information and hit signals. The FIROB keeps the destination operands of the X86 instructions.</p><p>The FIROB provides the dependency tags for the source operands and flags. The destination tags is by the virtual line number. The fixed location of the instructions is simple for returning of the results. The FIROB implements a FIFO shifter to limit the dependency checking to the first 5 lines. The virtual line number is shifted along with retiring line to keep track of the instructions in the functional units.</p><p>Result Bus Interface</p><p>The result buses are dedicated between the functional units and the destination buffers of the FIROB. The FIROB compares the line number for returning results. The exceptions are the floating point unit and LSSEC. The line number and the entry number are compared in this case. The functional units send the data and address to the LSSEC for data cache access. The result buses contain the status flags, and results. Various status/control bits in the FIROB will be set and cleared for the benefit of the retire logic. Since the store and move-to-special-register instructions must access the data cache in the program order, all previous instructions must be completed with valid results. The FIROB broadcasts the top two entries which do not have the valid results to the LSSEC and SRB. If the broadcasted entries match the store or load-miss instructions, the LSSEC can access the data cache and returns results. Similar procedure is used for the move-to-special-register instruction in the SRB.</p><p>The result data and tag are returned to the FIROB in the execution and data cache access cycle. The status can be a cycle later because of the zero-detect, carry, and tag-hit in the data cache. The retire logic may not be able to retire the instructions with late result immediately (require some work in logic and circuit design). There may be a cycle delay in retiring instructions with late statuses. Furthermore, the limit violation checking on data access in the LSSEC can be later in the next clock cycle along with the late tag-hit status. The limit violation results in trap instead of retiring the instruction.</p><p>Write-Back Interface</p><p>The write-back interface of the FIROB is to ensure the retiring of instructions in program order. In addition to controlling write back to the register file, the FIROB updates the EIP register and flags registers and controls the order of the load-miss, store accesses and move-to-special-register instructions. In normal operation, the FIROB retires an entire line of instructions at a time. All instructions in the line must have the valid results from the functional units or LSSEC. All entries with valid result destination will write back to the register file. The LIL and NC status bits of the FIROB ensures that none of the write-back destinations are the same. The destination address includes the selected bytes for writing back data. In the case LIL and NC status bits are set for destinations of different size, and the FIROB masks the selected bytes before sending to the register file. In some special case, the FIROB retires a partial line. The LIL and NC status bits must be checked and reset before retiring, an extra cycle is needed for this case. The LIL and NC status bits are also used for the flags to simplify updating the flags registers.</p><p>A branch mis-prediction causes a partial line to be retired. The register file destination addresses are compared to all the previous destinations within the partial line and reset the LIL and NC bits before retiring the store instruction in the next cycle. The write-back data is in the correct byte position with byte enables for the register file. The bytes are put in the correct position from the functional units, no shifting is needed in the FIROB.</p><p>Two PC's are kept for each line. The first PC is for the first instruction in the line, the second PC is for a second instruction which crosses the 16-byte boundary or the branch target within the line. The PC offset is concatenated with line PC to get the current PC for retired instructions. A real register for the flags and program states is updated with the retired instruction. As the taken branch instruction is retiring, the PC is updated with the branch target or next line instruction.</p><p>Updating the EIP Register</p><p>The EIP is used to keep track of the X86 instruction execution. Instructions can be aligned on any byte boundary so 32 bits of EIP are implemented. Each retiring instruction updates the EIP register, and there is no concept of freezing. The MROM instructions do not update the EIP register, indicatds by ROBEXIT, except for the last MROM instruction in the sequence. The EIP update falls into one of three categories:</p><p>Retire the entire line, no mis-prediction, EIP=Next line PC<b>1</b>.</p><p>Retire the line with branch mis-prediction, EIP=branch target.</p><p>Retire the partial line, ROBNPC=0, EIP=EIP: next entry PC offset.</p><p>Retire the partial line, ROBNPC=1, EIP=Next line PC<b>2</b>.</p><p>Floating-Point Interface</p><p>The FIROB keeps the floating point instruction pointer, data pointer, floating point status and opcode registers for floating point interfacing. The data pointer is updated on each floating point load with the instruction pointer and opcode registers are updated on floating point exception. The data pointer is implemented in the load/store section. The floating point status register is implemented with working and backup copies to ensure correct operation of floating point stores.</p><p>Trap and Interrupt Processing</p><p>For internal exceptions from the functional units, LSSEC, and SRB, the exception entry in the FIROB will be retired in order. Similar to the branch mis-prediction, the pipe and fetching should stop on an exception indication. When all entries before the exception entry have completed and retired, the exception procedure is initiated. All entries in the FIROB, the functional units, and LSSEC will be purged. The exception routine will be fetched. The FIROB is responsible to generate the entry point to the MROM exception routine or new PC to the Icache. No state is updated when a trap is taken. The processor fetches from an appropriate entry point and allows the microcode to perform the necessary state modifications. It is up to the microcode to save the current EIP on the stack before the user's trap handler is called.</p><p>Dependency Checking &amp; Dispatching</p><p>The FIROB is responsible for checking dependency of the source operands of the dispatched line of instructions against the destination operands of the previous lines of instructions. The dependency comparators are needed for the first 5 lines in the FIROB and within the current line. The source addresses are checked for dependency against the previous destination addresses, and the dependency tags are generated by the end of this cycle. The forwarding data from the FIROB is driven in the next clock to the reservation station. Since the X86 instruction can only have 2 operands, the operand can be both destination and source which is indicated by the operand's tag bits, the current destination addresses are checked for dependency against the previous destination addresses with no extra cost in hardware. The write-after-write dependency information is used to set three new status bits for most up-to-date destination and the previously match destination. The three new status bits are referred to as Last-In-Line (LIL) bit for each line, and No-Compare (NC) bit for the whole FIROB. The NC bits ensure that there is only a single HIT for any read operand. The NC bits are used to qualify the dependency checking comparator, and the LIL bits are used to restore the most up-to-date status of the destination in case of partial-line retiring by branch mis-prediction. Other ROBs can have multiple HITs and search for the most current HIT. The procedure for dependency checking on this type of ROB is:</p><p>Compare source addresses to previous destination addresses.</p><p>Search for the most current HIT from multiple HITs.</p><p>Encode for the dependency tag.</p><p>Route tag and data to reservation station.</p><p>On Processor <b>500</b>, the two intermediate steps are eliminated, since there is only a single HIT, the HIT signal can be used as control to mux the tag and data directly. The NC and LIL bits are also used for retiring the line to the register file. No two entries have the same destination pointer for the line of instruction. The same method can be applied to the status flags. The FNC and FLIL bits are used for the status flags. The status flags are in three groups, OF, {SF,ZF,AF,PF}, and CF.</p><p>As illustrated in FIG. 35, the matrix for dependency checking is 20 6-bit destination addresses against the 8 source operand addresses. For read operand, if there is a hit in the FIROB, the FIROB has the highest priority to drive the data on the operand bus to the functional unit.</p><p>If there is a branch mis-prediction, all instructions in the same line after the mis-predicted branch with the LIL bit set feed back to the RD<b>0</b>PTR to check and reset the previous entries with the NC bit set. An extra cycle is used to retire instructions. The CANCEL status bits for all instruction after the branch mis-prediction should be used to qualify the instructions as NC.</p><p>Operand's Size Dependency</p><p>The size of the operands in dependency checking is quite complex for the X86 instruction set. Processor <b>500</b> checks for dependency from wide to narrow and stalls the dispatch line in decode for the narrow to wide dependency. Only one dependency tag is needed for each source operand.</p><p>Signal List</p><p>TOPPTR(<b>2</b>:<b>0</b>)\u2014Pointer to the top of the FIROB. This pointer is used to enable the number of lines in the FIROB for dependency checking.</p><p>ENINTR(<b>3</b>:<b>0</b>)\u2014Input from Idecode indicates external interrupt enable for each instruction. This information is used for retiring instruction.</p><p>IDSIB(<b>3</b>:<b>0</b>)\u2014Input from Idecode indicates which decode unit has the SIB-byte instruction. The FIROB should generate dependency on the previous instruction of the last line in the same issue position.</p><p>MROMDEC(<b>3</b>:<b>0</b>)\u2014Input from MROM indicates the microcodes are being decoded by the decode units. Use to set the ROBEXIT bit.</p><p>INSDISP(<b>3</b>:<b>0</b>)\u2014Input from Idecode indicates that the instruction in decode unit is valid, if invalid, NOOP is passed to FIROB.</p><p>INSLSxB(<b>5</b>:<b>0</b>)\u2014Input from decode units indicates the prefix values. bit <b>5</b>\u2014data size, bit <b>4</b>\u2014address size, bit <b>3</b>\u2014lock, bit <b>2</b>:<b>0</b>\u2014segment registers.</p><p>IDSIB(<b>3</b>:<b>0</b>)\u2014Input from Idecode indicates which decode unit has the SIB-byte instruction.</p><p>RBxTAG<b>1</b>(<b>4</b>:<b>0</b>)\u2014Output indicates the first dependency tag for dispatching instructions.</p><p>RBxTAG<b>2</b>(<b>4</b>:<b>0</b>)\u2014Output indicates the second dependency tag for dispatching instructions.</p><p>FCFxTAG(<b>4</b>:<b>0</b>)\u2014Output indicates the CF flag dependency tag for dispatching instructions.</p><p>FOFxTAG(<b>4</b>:<b>0</b>)\u2014Output indicates the CF flag dependency tag for dispatching instructions.</p><p>FXFxTAG(<b>4</b>:<b>0</b>)\u2014Output indicates the CF flag dependency tag for dispatching insructions.</p><p>DSETALL(<b>4</b>:<b>0</b>)</p><p>DSETEXIT(<b>4</b>:<b>0</b>)</p><p>DSETINTR(<b>4</b>:<b>0</b>)\u2014Input to set signals for dispatched instructions. The bits should be set in the cycle after the dependency checking.</p><p>Handling of Load/Store</p><p>Handling of store and load-miss can also be done with the broadcasted entry. The FIROB broadcasts the next-in-line entry which does not yet have a the result from a functional unit. With this FIROB entry, WRPTR(<b>4</b>:<b>0</b>), the LSSEC knows when to execute the store or load-miss instruction without any handshake from the FIROB. This implementation will eliminate the signals between the FIROB and the load/store unit. An extra signal, CANENTRY, will accompany the WRPTR to indicate that this entry has been canceled by mis-prediction. The LSSEC and the reservation stations can use this information to return the results without any execution, and any data dependency in the load/store buffer is ignored. The FIROB treats the load/store instructions the same as other ALU instructions with this method.</p><p>The LSSEC implements a store buffer to keep track of the store instructions in the pipe for address dependency checking. The store buffer is capable of issuing 2 store instructions to the data cache if the store instructions are next-in-line for retiring. To accomplish this, the FIROB will broadcast another pointer, WRPTR<b>1</b>(<b>4</b>:<b>0</b>), and CANENTRY<b>1</b> to the store buffer, if the first two entries in the store buffer match the WRPTR and WRPTR<b>1</b>, two stores can be executed concurrently as long as they accesses two different banks in the data cache. The WRPTR and WRPTR<b>1</b> point to two entries in the FIROB which need results. The two entries do not necessarily point to store instructions.</p><p>A similar procedure is also used for in-order execution of the move-to-special-register instructions. A buffer in the load/store special register is used for the special register instructions, the ROB tag is compare to the WRPTR to execute the instruction and return result to the FIROB.</p><p>Load and store instructions assume single cycle access to the data cache. The results are speculatively latched into the data buffer. The validation of the load/store is from the HIT signal of the data cache early in the next cycle. The result valid bits of the load/store is clear in the next cycle if miss in the data cache.</p><p>Unaligned Accesses</p><p>Processor <b>500</b> is optimized for aligned 8/16/32 bits accesses. For aligned access, the operand comparison is for bit <b>31</b>:<b>2</b> with indication for checking of 8/16/32 bits. The LSSEC takes two or more clock cycles to execute the instruction. The operation of the LSSEC for unaligned load is as followed:</p><p>First cycle: Access the data cache (DC) to read data with the current address, another access may be concurrent. Increase the address by 4 for the second access.</p><p>Second cycle: Access the DC to read data with the increased address, other access can be concurrent. Latch the data of the first access at the beginning of this cycle. The DC puts the 8 or 16 bits at the least significant byte (same as any narrow access), and the LSSEC puts the first half data of the unaligned at the most significant byte of the result bus.</p><p>A miss in either part of the unaligned access must wait for the WRPTR or WRPTRl of the FIROB to execute the instruction in program order. The load/store buffer must keep the status to access the data cache and send the results correctly on the buses.</p><p>Both halves of the unaligned store are written into the cache at one time to avoid any intermediate exception. The operation of the LSSEC for unaligned store is as follows:</p><p>First cycle: Access the data cache (DC) with the current address, do not write data, another access may be concurrent. If miss in the data cache, the reload routine may start this cycle. Increase the address by 4 for the second access.</p><p>Second cycle: Access the DC using two ports to write data with both addresses.</p><p>The Advantages of the Above Procedure Are</p><p>The LSSEC always does two accesses and the unaligned access always takes two cycles. The LSSEC has a whole cycle to increase the address; no different for crossing the line boundary.</p><p>The LSSEC does all the merging for unaligned load with ease. The DC does not need to know about the unaligned access.</p><p>Signal list</p><p>LSTAG<b>0</b>(<b>4</b>:<b>0</b>)\u2014Input from LSSEC indicates FIROB line number of the first access.</p><p>LSTAG<b>1</b>(<b>4</b>:<b>0</b>)\u2014Input from LSSEC indicates FIROB line number of the second access.</p><p>LSRES<b>0</b>(<b>31</b>:<b>0</b>)\u2014Input from LSSEC indicates result data of the first access.</p><p>LSRES<b>1</b>(<b>31</b>:<b>0</b>)\u2014Input from LSSEC indicates result data of the second access.</p><p>WRPTR(<b>4</b>:<b>0</b>)\u2014Output to LSSEC indicates the bottom (oldest) entry in the FIROB without valid result. If this entry matches the store or load-miss entry in the LSSEC, the entry can access the data cache at this time.</p><p>CANENTRY\u2014Output to LSSEC indicates the bottom entry in the FIROB without valid result is canceled. If this entry matches the store or load-miss entry in the LSSEC, the entry can return without access the data cache at this time.</p><p>WRPTR<b>1</b>(<b>4</b>:<b>0</b>)\u2014Output to LSSEC indicates the next to bottom entry in the FIROB without valid result. If this entry matches the store or load-miss entry in the LSSEC, the entry can access the data cache.</p><p>CANENTRY\u2014Output to LSSEC indicates the next to bottom entry in the FIROB without valid result is canceled. If this entry matches the store or load-miss entry in the LSSEC, the entry can return without access the data cache.</p><p>Handling of Branch and Re-synchronization</p><p>Since branches may be executed in parallel in multiple functional units, branch mis-prediction is handled in order. The mis-prediction of branches is handled by the FIROB. There are two types of branches, the conditional branch and the unconditional branch. The unconditional branch is always taken and includes call, return, and unconditional jump. The mis-prediction is when the targets do not match. For conditional branch, the mis-prediction is from taken/non-taken prediction and/or matching target address. Branch mis-prediction stops the pipe which can be done from the functional units, and all instructions in decode are cleared, and the new target is fetched by the Icache at a later time. The functional units may send the mis-predicted signal to stop the pipe and return the correct logical PC address to the FIROB. Because of the branch holding register, the branch mis-prediction does not update the ICNXTBLK until the next branch mis-prediction. The FIROB can speculatively send the branch mis-prediction to the Icache. If there is another mis-predicted branch prior to the last one, the FIROB can invalidate the branch holding register in the ICNXTBLK. The Icache uses an extra cycle to update the previously mis-predicted branch into the ICNXTBLK, and the FIROB uses this cycle to update the NC status bit and retire the instruction to the register file. The new logical PC address from branch mis-prediction should be sent to the Icache and allow the code segment to be added to generate the linear address for accessing the Icache. When an entry in the FIROB is completed with mis-prediction status, entries after the branch are marked with cancelled status. The cancelled entries can have incorrect result data from the functional units or LSSEC.</p><p>Another condition to re-fetch the instructions is re-synchronization. There is a possibility of executing a wrong instruction from self-modifying code and updating the code segment register. The stream of instructions must be re-fetched. From external snooping which cause an invalidation of a line in the instruction cache or an internal store instruction which can change a line in the instruction cache, the FIROB is re-synchronized at this point. As soon as the write to code-segment register is detected, following instructions are re-fetched upon completion of the code segment register write.</p><p>Recover of Status Bits from Branch Mis-prediction</p><p>The status bits are no longer correct with branch mis-prediction. The FIROB takes one clock cycle to reset the status bits for each line of the FIROB after the branch mis-prediction. First, the line with the branch mis-prediction will be corrected. Within the line if there is any LIL bit is set after the branch mis-prediction, the destination is compared against the previous destinations before the branch mis-prediction. A match will set the LIL bit and clear the NC bit for that entry</p><p>Updating PC</p><p>Each line of the FIROB has two PCs, and each entry has a PC offset of the next instruction and one status bit to indicate if the offset is related to the second PC. As the line is retired, the current PC pointer will point to the next line PC. For partial retiring of the line, the line PC is updated with the offset of the present entry in the FIROB. For the MROM entry, the offset is with the last MROM instruction, and all other MROM instruction should have the same offset with the line PC. With this technique, handling of the PC is relatively simple. In the case of branch mis-prediction for sequential fetch, (the branch prediction is taken) the PC can be calculated by concatenating the line PC with the offset. If the PC is at the end of the line, the sequential PC is +16.</p><p>Signal List</p><p>BRNMISP\u2014Input from the Branch execution of the FU indicates that a branch mis-prediction. The Idecode clears all instructions in progress.</p><p>UPDFPC\u2014Output to Icache indicate that a new Fetch PC has been detected. This signal accompanies the FPC for the Icache to begin access the cache arrays.</p><p>TARGET(<b>31</b>:<b>0</b>)\u2014Output to Icache as the new PC for branch correction path.</p><p>BRNMISP\u2014Input to Icache indicates a branch mis-prediction. The Icache changes its state machine to access a new PC and clears all pending instructions.</p><p>BRNTAKEN\u2014Output to Icache indicates the status of the mis-prediction. This signal must be gated with UPDFPC.</p><p>BRNFIRST\u2014Output to Icache indicates the first or second target in the ICNXTBLK for updating the branch prediction.</p><p>BRNCOL(<b>3</b>:<b>0</b>)\u2014Output to Icache indicates the instruction byte for updating the branch prediction in the ICNXTBLK.</p><p>FPCTYP\u2014Input to Icache indicates the type of address that is being passed to the Icache.</p><p>BPC(<b>11</b>:<b>0</b>)\u2014Output indicates the PC index and byte-pointer of the branch instruction which has been mis-predicted for updating the ICNXTBLK.</p><p>Handling Traps and Interrupts</p><p>A function of the FIROB is to detect and prioritize the traps and interrupts and to initiate specific redirections at appropriate times. The LSSEC and functional units send the highest exceptions to the FIROB. The basic mechanism for redirection is:</p><p>Assert EXCEPTION to clear out instructions in the pipe.</p><p>One cycle later, assert REQTRAP and drive new entry point to the MROM.</p><p>Correct look-ahead registers at decode and in the branch units.</p><p>The FIROB initiates the microcode routine from the MROM by REQTRAP and does not wait for LSSEC to be idle. There are three groups of traps and interrupts:</p><p>Exception results from functional units, FPU, and LSSEC.</p><p>External interrupts (maskable and non-maskable).</p><p>Single step traps.</p><p>The FIROB includes a set of entry point vectors which can be sent to MROM on REQTRAP indication.</p><p>Internal Traps and Interrupts</p><p>The internal exception results are coded into 3 bits of ROBEXC:</p><p>000\u2014no exception</p><p>001\u2014load/store breakpoint</p><p>This is set when any load or store breakpoint status is returned. The instruction is retired normally. The debug entry point is generated and the B bits of the debug status register are set according to the 2-bit debug register hit code reported with the result. The redirection starts when the whole instruction is completed; the ROBEXIT bit is set. Another trap or interrupt can have higher priority while the load/store breakpoint is waiting for the rest of the instruction to complete. The floating point exception causes the FIROB to update all the floating point exception registers but the debug trap has higher priority.</p><p>010\u2014software interrupt with vector</p><p>This is set when a software interrupt status is returned. This exception includes the INTO instruction. When the instruction is retired, the PC is updated and the exception with vector is taken.</p><p>011\u2014floating point exception with write-back/push/pop</p><p>This is set when the corresponding status is returned. The instruction retires normally with the floating point opcode and instruction pointer registers are updated. The FIROB does one of the four actions:</p><p>if a pending breakpoint exits, take a breakpoint trap.</p><p>if NE=1, take a floating point trap directly.</p><p>if NE=0 and IGNNE=0, freeze and wait for an external interrupt.</p><p>if NE=0 and IGNNE=1, resync to the next instruction.</p><p>100\u2014exception with vector</p><p>This is set when an exception result is returned with a vector (including a TLB miss). When the instruction is retired, no write-back nor PC update occurs and the redirection with the entry point is initiated. This is used for majority of traps, the entry point is provided with the results.</p><p>101\u2014exchange abort</p><p>This is set when an exchange abort status is returned. The retire procedure is the same as exception with vector except that the PC is driven back instead of the MROM entry point. The signal SYNC and EXCHGSYNC are asserted along with REQTRAP to notify the Icache.</p><p>110\u2014not used.</p><p>111\u2014floating point exception without write-back/push/pop</p><p>This is set when the corresponding status or an exchange result with underflow is returned. The retire procedure is the same as the above floating point exception without write-back or push/pop.</p><p>External Interrupts</p><p>The external interrupts include both maskable and non-maskable interrupts. The non-maskable interrupt (NMI) is a normal, precise, external interrupt. The NMI should only be seen by the FIROB. The external interrupt is only recognized during selected windows:</p><p>Partially retired valid instructions in the bottom line with ROBEXIT status and did not cause a trap or resynchronization.</p><p>Frozen due to having retired a floating point exception with NE=0 and IGNNE=0.</p><p>On external interrupts, the entry point is generated locally by the FIROB at the time the redirection is initiated. The maskable interrupt is level sensitive while the NMI is edge sensitive. FLUSH and INIT are also treated as edge sensitive asynchronous interrupts, similar to NMI. If the NMI is taken, it cannot be taken again before an IRET is executed. The microcode maintains a series of global flags that are inspected and modified by many of the trap handler entry points, and the IRET instruction. It is also the responsibility of the microcode to detect the NMI and delay the NMI until after executing of the IRET. The MROM allows only one level of NMI. Many other aspects of nested trap control (double fault, shutdown, etc.) will be handled with this microcode mechanism. There is no hardware support for this. When an enabled trap condition arises, the FIROB takes it at the next available window.</p><p>The HALT instruction causes the FIROB to update the EIP before entering shutdown mode. If the shutdown is entered as a result of a failed NMI, microcode should also clear the IF bit before halting.</p><p>Single Step Traps</p><p>When the TF bit of the EFLAGS register is set, a debug trap is taken at the successful completion of each instruction, not including the instruction that actually caused TF to be set (i.e. the POP or IRET). The FIROB takes a single step trap on the successful retirement of the second instruction after the setting of the TF bit. When the TF bit is clear the effect is immediate. When a single step trap is taken, the entry point is generated locally by the FIROB, and the BS bit of the debug status register is set. The TF bit of the EFLAGS register is not cleared by hardware; it is cleared by microcode after pushing EFLAGS onto the stack.</p><p>Debug Interface</p><p>A summary of each type of debug trap is presented in this section. Load and store breakpoints are detected by the LSSEC and returned as a status to the FIROB with a 2-bit code identifying the breakpoint register matched. When the instruction is retired the FIROB initiates a debug trap and sets the corresponding B bit in the debug status register. The entry point for this trap is generated locally. The instructions with load/store breakpoint trap are considered to have completed successfully.</p><p>Instruction breakpoints are not handled by the FIROB. The pre-decode disables the Icache and sends a special serializing instruction to each new instruction, whenever any of the debug registers are enabled for code breakpoints. The special instruction is serially dispatched to the LSSEC where it compares the pre-decode PC to the breakpoint registers, accounting for the state of the RF bit. If a breakpoint is detected, a normal exception status is returned to the FIROB and a trap is taken. The provided entry point depends upon which breakpoint register got the hit, and the setting of the appropriate B bit is the responsibility of the microcode. The FIROB is unaware of the nature of the trap being taken. The RF bit is cleared automatically by the FIROB on the successful retire of the second instruction following its low to high transition.</p><p>Single step debug traps are handled in hardware by the FIROB as was described in previous section. The setting of the BS bit is done automatically by the FIROB but the handling of the TF bit is the responsibility of the microcode.</p><p>The global detect debug trap is handled by the SRB, by inspecting the state of the GD bit in the debug control register whenever a move to or from any debug register is attempted. If it is set, no move is performed and a trap status is returned. The setting of the BD bit when the trap is taken is performed by microcode; the FIROB is unaware of the nature of the trap being taken.</p><p>The task-switch debug trap is handled by microcode, including the setting of the BT bit in the debug status register.</p><p>The breakpoint instruction (INT <b>3</b>\u2014<b>0</b>xCC) is treated like a normal software interrupt. It is dispatched to a functional unit and returns an appropriate status. The FIROB updates the EIP register (which is one byte for the INT <b>3</b> instruction) and traps to the provided entry point. The FIROB does not treat this instruction any different than other software interrupts.</p><p>Signal List</p><p>NMI_P\u2014Input from BIU indicates non-maskable interrupt, the FIROB generates a clean instruction boundary trap to a fixed entry point. The FIROB is sensitive only to the rising edge of this signal.</p><p>INTR_P\u2014Input from BIU indicates the external interrupt. This signal is qualified with the IF bit of the EFLAGS register. The interrupt occurs at appropriate instruction boundaries.</p><p>SRBHALT\u2014Input from SRB to enter HALT mode. The FIROB stops retiring instructions until RESET, NMI, or external interrupt occurs. The FIROB must retire the HALT instruction before shutting down.</p><p>CRONE\u2014Input from SRB indicates the NE bit of the CR<b>0</b> register. The NE bit indicates the floating point exception can be trapped directly (NE=1) or via XFERR_P and an external interrupt (NE=0).</p><p>XIGNNE_P\u2014Input from BIU indicates the copy of pin IGNNE. When CRONE=0, this signal is inspected to response to enabled floating point exceptions.</p><p>XFLUSH_P\u2014Input from BIU indicates an external flush request occurs. It is falling edge sensitive and trap on instruction boundary. It is sample during IRESET to enter tri-state test mode, the FIROB should not generate exception.</p><p>IINIT\u2014Input from BIU indicates an initialization request. It is rising edge sensitive and trap on instruction boundary. It is sample during IRESET to enter BIST test mode, the FIROB generates on of the two reset entry point.</p><p>EFLAGSRF\u2014Output generates from the EFLAGS register, these bits are visible from the slave copy of the EFLAGS register. The RF bit is also used in the FIROB to handle instruction breakpoint.</p><p>EFLAGSIF\u2014Output generates from the EFLAGS register, this is the mask bit for INTR_P. When clear, INTR_P is ignored.</p><p>EFLAGSTF\u2014Output generates from the EFLAGS register, the interrupt and trace flags are needed locally to control external interrupts and single step trapping after two completed instructions retires.</p><p>LOCVEC\u2014Input from ROBCTL indicates whether entry point of the redirection is from the result status or locally generated.</p><p>ASYNCOK\u2014Input from ROBWB indicates an external interrupt or NMI can be taken.</p><p>DOEXC\u2014Input from ROBWB indicates an EXCEPTION is asserted and a trap to the entry point returned with the instruction is initiated.</p><p>DOXABORT\u2014Input from ROBWB indicates an EXCEPTION is asserted and a resync is initiated. The signal EXCHGSYNC is asserted in addition to the normal resync signals.</p><p>DOFP\u2014Input from ROBWB indicates an floating point exception by inspecting CRONE and XIGNNE_P. Exception, freeze mode, or resync is taken in next cycle.</p><p>DOBREAK\u2014Input from ROBWB indicates an EXCEPTION is asserted and a trap to a locally generated debug entry point is initiated.</p><p>DOSBZ\u2014Input from ROBWB indicates an EXCEPTION is asserted and a resync to the next instruction is initiated.</p><p>DOLSYNC\u2014Input from ROBWB indicates an EXCEPTION is asserted and a resync to the next instruction is initiated.</p><p>DOTRACE\u2014Input from ROBWB indicates an EXCEPTION is asserted and a trap to a locally generated single-step entry point is initiated.</p><p>LOCENTRY(<b>9</b>:<b>0</b>)\u2014Output of local entry point vector for traps or interrupts.</p><p>EXCEPTION\u2014Global output indicates that an interrupt or trap is being taken including resynchronization. Effect on Idecode and Fus is to clear all instructions in progress.</p><p>REQTRAP\u2014Global output, one cycle after EXCEPTION, indicates that the trap is initiated with new entry point or new PC is driven.</p><p>SYNC\u2014Output indicates whether the new entry point or new PC is driven.</p><p>FREEZE\u2014Output from a latch indicates when an SRBHALT occurs, or when DOFP is asserted with CRONE=0 and</p><p>XIGNNE_P=1. The latch is reset when an enabled external interrupt, NMI, or IRESET occurs.</p><p>XFERR_P\u2014Output to BIU indicates the floating point error which is inverted of the ES bit from the slave of the floating point status register. It is also used by the FIROB to generate the plunger traps.</p><p>EXCHGSYNC\u2014Output indicates exchange instruction resynchronization to Icache. This occurs when an exchange with a masked underflow is retired. It is a special resynchronize exchange with alternate entry point.</p><p>Listing of Status Bits</p><p>This block describes the status bits and fields in the FIROB. The FIROB keeps track of the processor states, status flags, handling correct PC, and retires instructions in program order to the register file. The number of status bits and fields in the FIROB is organized in four groups: the data path, the entry's status bits, the line's status, and the global field.</p><p>The Data Path</p><p>The data path contains the necessary data for the 32-bit communication with the decode units, the register file, and the functional units.</p><p>ROBDATA\u2014RESULT DATA\u201432-bit\u2014Receive data from functional unit by comparison of result line number. Write data back to the register file from the bottom of the FIROB. This can also be the branch target to be routed to the Icache.</p><p>ROBDEST\u2014DESTINATION OPERAND\u20146-bit\u2014Receive the register address from the decode units into the top of the FIROB. Send the address to the register file to latch valid result data from the bottom of the FIROB. The address routes to the comparators for dependency checking.</p><p>ROBTYPE\u2014OPERAND TYPE\u20141-bit\u2014Receive the type of the destination operand from the decode units. Indicates if ROBDEST is valid.</p><p>ROBBYTE\u2014SELECT BYTE\u20143-bit\u2014Receive the operand size from the decode units. Decode into 3 bits and for comparators and write back to the register.</p><p>ROBNC\u2014NO-COMPARE\u20143-bit\u2014Received from the dispatch line comparator; indicates that there is another instruction in the dispatch line with the same destination. The 3 bits is used for the bytes in the data word. This entry should not used in dispatch dependency checking. If the ROBLIL bit is not set, the destination of this entry should not be used for writing back to the register file.</p><p>ROBLIB\u2014LAST-IN-BUFFER BIT\u20143-bit\u2014From comparing of the dispatch line against the previous line in the FIROB. The 3 bits are used for the bytes in the data word. This entry ensures a single hit for lines in the FIROB. Use for dispatch dependency checking.</p><p>ROBLIL\u2014LAST-IN-LINE BIT\u20143-bit\u2014Received from the dispatch line comparator; indicates that there is another instruction in the dispatch line with the same destination. The 3 bits are used for the bytes in the data word. Use for writing back to the register file and for dependency checking. If the ROBNC bit is also set; indicates the matched destination with another entry in the buffer.</p><p>ROBFNC\u2014FLAG NO-COMPARE\u20145-bit\u2014Received from the dispatch line comparator, indicates that there is another instruction in the dispatch line with the same flag destination. This entry is not used in flag dependency checking. If the ROBFLIL bit is not set, the destination of this entry should not be used for updating the flags registers.</p><p>ROBFLIB\u2014FLAG LAST-IN-BUFFER BIT\u20145-bit\u2014From comparing of the dispatch line against the previous line in the FIROB. This entry to ensure a single hit for all lines in the FIROB. Use for flag dependency checking.</p><p>ROBFLIL\u2014FLAG LAST-IN-LINE BIT\u20145-bit\u2014Received from the dispatch line comparator; indicates that there is another instruction in the dispatch line with the same flag destination. Use for updating the flags registers and for dependency checking. If the ROBFNC bit is also set, indicates the matched destination with another entry in the buffer.</p><p>ROBPCOFF\u2014PC OFFSET\u20144-bit\u2014Received from the decode units, indicates the offset from the current line PC. This PC offset concatenates with the PC to form the 32-bit address.</p><p>ROBTAG\u2014FIROB TAG\u20143-bit\u2014The hard-wired tag of the FIROB entries. A single tag is used for all lines in the FIROB.</p><p>This tag in combination with the ROBLTAG is multiplexed to the reservation station in case of dependency.</p><p>ROBFUPD\u2014FLAG UPDATE\u20143-bit\u2014Received from the decode units, indicates that the instructions will update the status flags. Use for flag dependency checking and writing back to the global status flag registers. Bit <b>2</b>\u2014OF, bit <b>1</b>\u2014SF, ZF, AF,PF, bit <b>0</b>\u2014CF.</p><p>ROBFLDAT\u2014FLAG RESULT\u20146-bit\u2014Received from the functional units for the updates flags. Use for writing back to the global status flag registers.</p><p>Signal List</p><p>RB<b>0</b>P<b>0</b>HIT<b>1</b>(<b>3</b>:<b>0</b>)\u2014Input from ROBCMP indicates that the FIROB line <b>0</b> matches with the first operand of the instruction at position <b>0</b>. There are a total of 24 RBxPxHIT<b>1</b>(<b>3</b>:<b>0</b>) signals. These signals are used to mux the dependency tag and data to the functional units.</p><p>RB<b>1</b>P<b>0</b>HIT<b>1</b>(<b>3</b>:<b>0</b>)</p><p>RB<b>2</b>P<b>0</b>HIT<b>1</b>(<b>3</b>:<b>0</b>)</p><p>RB<b>3</b>P<b>0</b>HIT<b>1</b>(<b>3</b>:<b>0</b>)\u2014Input from ROBCMP indicates that the FIROB line <b>1</b>-<b>3</b> matches with the first operand of the instruction at position <b>0</b>.</p><p>RB<b>0</b>P<b>1</b>HIT<b>1</b>(<b>3</b>:<b>0</b>)</p><p>RB<b>0</b>P<b>2</b>HIT<b>1</b>(<b>3</b>:<b>0</b>)</p><p>RB<b>0</b>P<b>3</b>HIT<b>1</b>(<b>3</b>:<b>0</b>)</p><p>RB<b>0</b>P<b>4</b>HIT<b>1</b>(<b>3</b>:<b>0</b>)</p><p>RB<b>0</b>P<b>5</b>HIT<b>1</b>(<b>3</b>:<b>0</b>)\u2014Input from ROBCMP indicates that the FIROB line <b>0</b> matches with the first operand of the instruction at position <b>1</b>-<b>5</b>.</p><p>RB<b>0</b>P<b>0</b>HIT<b>2</b>(<b>3</b>:<b>0</b>)\u2014Input from ROBCMP indicates that the FIROB line <b>0</b> matches with the second operand of the instruction at position <b>0</b>. There are a total of 24 RBxPxHIT<b>2</b>(<b>3</b>:<b>0</b>) signals.</p><p>RB<b>1</b>P<b>0</b>HIT<b>2</b>(<b>3</b>:<b>0</b>)</p><p>RB<b>2</b>P<b>0</b>HIT<b>2</b>(<b>3</b>:<b>0</b>)</p><p>RB<b>3</b>P<b>0</b>HIT<b>2</b>(<b>3</b>:<b>0</b>)\u2014Input from ROBCMP indicates that the FIROB line <b>1</b>-<b>3</b> matches with the second operand of the instruction at position <b>0</b>.</p><p>RB<b>0</b>P<b>1</b>HIT<b>2</b>(<b>3</b>:<b>0</b>)</p><p>RB<b>0</b>P<b>2</b>HIT<b>2</b>(<b>3</b>:<b>0</b>)</p><p>RB<b>0</b>P<b>3</b>HIT<b>2</b>(<b>3</b>:<b>0</b>)</p><p>RB<b>0</b>P<b>4</b>HIT<b>2</b>(<b>3</b>:<b>0</b>)</p><p>RB<b>0</b>P<b>5</b>HIT<b>2</b>(<b>3</b>:<b>0</b>)\u2014Input from ROBCMP indicates that the FIROB line <b>0</b> matches with the second operand of the instruction at position <b>1</b>-<b>5</b>.</p><p>WBENB(<b>3</b>:<b>0</b>)\u2014Input from ROBCTL indicates that writing back is enable from the bottom of the FIROB.</p><p>RESx(<b>31</b>:<b>0</b>)\u2014Input from FU indicates result data.</p><p>DTAGx(<b>2</b>:<b>0</b>)\u2014Input from FU indicates FIROB line number of the result.</p><p>RFLAGx(<b>31</b>:<b>0</b>)\u2014Input from FU indicates result flags.</p><p>LSTAG<b>0</b>(<b>4</b>:<b>0</b>)\u2014Input from LSSEC indicates FIROB line number of the first access.</p><p>LSTAG<b>1</b>(<b>4</b>:<b>0</b>)\u2014Input from LSSEC indicates FIROB line number of the second access.</p><p>LSRES<b>0</b>(<b>31</b>:<b>0</b>)\u2014Input from LSSEC indicates result data of the first access.</p><p>LSRES<b>1</b>(<b>31</b>:<b>0</b>)\u2014Input from LSSEC indicates result data of the second access.</p><p>WBxNC\u2014Output indicates the invalid write-back data to the register file for retiring instructions.</p><p>WBxPTR(<b>5</b>:<b>0</b>)\u2014Output indicates the write-back pointer to the register file for retiring instructions.</p><p>WBxD(<b>31</b>:<b>0</b>)\u2014Output indicates the write-back data to the register file for retiring instructions.</p><p>WBxBYTE(<b>3</b>:<b>0</b>)\u2014Output indicates the write-back selected bytes to the register file for retiring instructions.</p><p>RBxDAT<b>1</b>(<b>31</b>:<b>0</b>)\u2014Output indicates the first source operand data for dispatching instructions.</p><p>RBxDAT<b>2</b>(<b>31</b>:<b>0</b>)\u2014Output indicates the second source operand data for dispatching instructions.</p><p>FLGxDAT<b>1</b>(<b>5</b>:<b>0</b>)\u2014Output indicates the status flags for dispatching instructions.</p><p>RBxTAG<b>1</b>(<b>4</b>:<b>0</b>)\u2014Output indicates the first dependency tag for dispatching instructions.</p><p>RBxTAG<b>2</b>(<b>4</b>:<b>0</b>)\u2014Output indicates the second dependency tag for dispatching instructions.</p><p>FCFxTAG(<b>4</b>:<b>0</b>)\u2014Output indicates the CF flag dependency tag for dispatching instructions.</p><p>FOFxTAG(<b>4</b>:<b>0</b>)\u2014Output indicates the CF flag dependency tag for dispatching instructions.</p><p>FXFxTAG(<b>4</b>:<b>0</b>)\u2014Output indicates the CF flag dependency tag for dispatching instructions.</p><p>TARGET(<b>31</b>:<b>0</b>)\u2014Output to Icache indicates the new PC for branch correction path and resynchronization. It is also used for special register updates in the FIROB.</p><p>RBxNC\u2014Output to ROBCMP indicates the invalid entry for dependency checking.</p><p>RBxLIL\u2014Output to ROBCMP indicates the last-in-line entry for dependency checking.</p><p>RBxFNC\u2014Output to ROBCMP indicates the invalid entry for flag dependency checking.</p><p>RBxFLIL\u2014Output to ROBCMP indicates the last-in-line entry for flag dependency checking.</p><p>ICPOSx(<b>3</b>:<b>0</b>)\u2014ICLK<b>7</b> Input from Icache to decode units indicates the PC's byte position of the next instruction.</p><p>IDxDAT(<b>1</b>:<b>0</b>)\u2014Input from Idecode indicates the data size information. 01-byte, 10-half word, 11-word, 00-not use.</p><p>IDxADDR\u2014Input from Idecode indicates the address size information. 1-32 bit, 0-16 bit.</p><p>DxUSEFL (<b>2</b>:<b>0</b>)</p><p>DxWRFL(<b>2</b>:<b>0</b>)\u2014Input from Idecode indicates the type of flag uses/writes for this instruction of decode units:</p><p>xx<b>1</b> CF\u2014carry flag,</p><p>x<b>1</b>x OF\u2014overflow flag,</p><p><b>1</b>xx SF\u2014sign, ZF\u2014zero, PF\u2014parity, and AF\u2014auxiliary carry</p><p>INSDISP(<b>3</b>:<b>0</b>)\u2014Input from Idecode indicates that the instruction in decode unit is valid, if invalid, NOOP is passed to FIROB.</p><p>DxUSE<b>1</b>(<b>1</b>:<b>0</b>)\u2014Input from Idecode indicates the type of operand being sent on operand <b>1</b> for decode units. Bit <b>1</b> indicates source operand, and bit <b>0</b> indicates destination operand.</p><p>DxUSE<b>2</b>\u2014Input from Idecode indicates indicates source operand.</p><p>RDxPTR<b>1</b>(<b>5</b>:<b>0</b>)\u2014Input from Idecode indicates the register address for operand <b>1</b> of the instructions.</p><p>RDxPTR<b>2</b>(<b>5</b>:<b>0</b>)\u2014Input from Idecode indicates the register address for operand <b>2</b> of the instructions.</p><p>INSLSxB(<b>5</b>:<b>0</b>)\u2014Input from decode units indicates the prefix values. bit <b>5</b>\u2014data size, bit <b>4</b>\u2014address size, bit <b>3</b>\u2014lock, bit <b>2</b>:<b>0</b>\u2014segment registers.</p><p>The Entry's Status</p><p>Each entry of the FIROB has many status's.</p><p>ROBVAL\u2014VALID RESULT\u20141-bit\u2014Set when functional units return valid results. The entry can be retired when this bit is set. A NOOP sets this bit during dispatching.</p><p>ROBTKN\u2014TAKEN BRANCH\u20141-bit\u2014Set when functional units return valid results. Use to update the EIP with the taken branch target.</p><p>ROBJMP\u2014BRANCH INFORMATION\u20143-bit\u2014Receive from the decode units, indicates CALL/RETURN (bit <b>0</b>) or unconditional jump instruction (bit <b>1</b>) and valid branch instruction (bit <b>2</b>). The branch resets the branch tag in the global shift register and the return stack.</p><p>ROBGBTAG\u2014GLOBAL BRANCH TAG\u20144-bit\u2014Receive from the decode units, indicates the global branch prediction tag. Use to recover the global branch prediction shift register, the counters, and the byte position of the mis-predicted branch instruction. This is to properly update the ICNXTBLK.</p><p>ROBCAN\u2014CANCELED ENTRY\u20141-bit\u2014Set when branch mis-prediction is detected or SC-read_after_DC-write dependency is detected from load/store dependency checking. The entry is retired normally without updating the EIP.</p><p>ROBLSYNC\u2014LOAD/STORE RESYNC\u20141-bit\u2014Set when functional units return valid results with resync status. The load/store hits in the Icache for self-modifying code. The next instruction should be re-fetched from the Icache.</p><p>ROBSBZ\u2014SHIFT BY ZERO\u20141-bit\u2014Set when functional units return valid results with SBZ status. The scheduled flags updates are canceled. This status is used to qualify the ROBFUPD.</p><p>ROBEXIT\u2014LAST MROM INSTRUCTION\u20141-bit\u2014Set for instructions except for MROM instructions and SIB-byte instructions. This status is used to update the EIP and flags registers when retiring instructions.</p><p>ROBNPC\u2014NEXT PC\u20141-bit\u2014Set for instructions which use the second PC in the line\u2014ROBLPC<b>2</b>. This status is used to update the EIP with ROBLPC<b>2</b> when retiring instructions.</p><p>ROBEXC\u2014EXCEPTION STATUS\u20142-bit\u2014Set when functional units return valid results with exception status. The exception code is:</p><p>000\u2014no exception</p><p>001\u2014load/store breakpoint</p><p>010\u2014software interrupt with error</p><p>011\u2014floating point exception with write-back/push/pop</p><p>100\u2014exception with vector (including TLB miss)</p><p>101\u2014exchange abort</p><p>110\u2014reserved</p><p>111\u2014floating point exception without write-back/push/pop</p><p>ROBFP\u2014FLOATING POINT ENTRY\u20141-bit\u2014Set for floating point instruction during dispatching.</p><p>Signal List</p><p>DSTATx(<b>3</b>:<b>0</b>)\u2014Input from FU indicates the status of the result data:</p><p>0000\u2014no result</p><p>0001\u2014valid result</p><p>0010\u2014valid result, shift by zero</p><p>0011\u2014exception with vector</p><p>0100\u2014software interrupt with vector</p><p>0101\u2014TLB miss with vector</p><p>0110\u2014load/store breakpoint</p><p>0111\u2014exchange result</p><p>1000\u2014exchange with underflow</p><p>1001\u2014exchange abort</p><p>1010\u2014branch taken, mis-prediction</p><p>1011\u2014branch not taken, mis-prediction</p><p>1100\u2014reserved for FPU</p><p>1101\u2014reserved for FPU</p><p>1110\u2014reserved for FPU</p><p>1111\u2014reserved for FPU</p><p>DSETALL(<b>3</b>:<b>0</b>)</p><p>DSETEXIT(<b>3</b>:<b>0</b>)</p><p>DSETINTR(<b>3</b>:<b>0</b>)\u2014Input to set signals for dispatched instructions. The bits should be set in the cycle after the dependency checking.</p><p>RSETTKN (<b>3</b>:<b>0</b>)</p><p>RSETVAL(<b>3</b>:<b>0</b>)</p><p>RSETEXC(<b>3</b>:<b>0</b>)</p><p>RSETSBZ (<b>3</b>:<b>0</b>)</p><p>RSETLSYNC(<b>3</b>:<b>0</b>)\u2014Input to set signals for result instructions. The bits are set in the same cycle as the results from functional units.</p><p>WBALL(<b>3</b>:<b>0</b>)</p><p>WBVAL(<b>3</b>:<b>0</b>)</p><p>WBCAN(<b>3</b>:<b>0</b>)</p><p>WBTKN(<b>3</b>:<b>0</b>)</p><p>WBSBZ (<b>3</b>:<b>0</b>)</p><p>WBEXC(<b>23</b>:<b>0</b>)</p><p>WBEXIT(<b>3</b>:<b>0</b>)</p><p>WBNPC(<b>3</b>:<b>0</b>)</p><p>WBLSYNC(<b>3</b>:<b>0</b>)</p><p>WBFP(<b>3</b>:<b>0</b>)\u2014Output indicates the current status of the bottom line of the FIROB for retiring instructions.</p><p>The Line's Status</p><p>Each line in the FIROB has its own status and information for dispatching and retiring instructions. The FIROB is a set of FIFO registers to avoid the dependency checking for the top line. The virtual line tag which is routed to the functional units is rotated with the shifting of the line.</p><p>ROBPC<b>1</b>\u2014LINE PC <b>1</b>\u201428-bit\u2014Receive from the decode units. This is the PC for the first instruction in the line. Use to update the current retired PC, branch mis-prediction, or re-fetch from Icache.</p><p>ROBPC<b>2</b>\u2014LINE PC <b>2</b>\u201428-bit\u2014Receive from the decode units. This is when the instruction cross the 16-byte line boundary in the Icache, and branch target of the instruction within the 4 entries in the ROB line. Use to update the current retired PC, branch mis-prediction, or re-fetch from Icache.</p><p>ROBPCB<b>1</b>\u2014PC<b>1</b> BRANCH TARGETS\u20142-bit\u2014Receive from the decode units. This is information of the two branch targets in the ICNXTBLK for the line PC <b>1</b>. For each bit, reset is non-taken or not valid, set is taken branch target. This information is for selecting a branch target for replacement in case of branch mis-prediction on the undetected branch in fetching.</p><p>ROBPCB<b>2</b>\u2014PC<b>2</b> BRANCH TARGETS\u20142-bit\u2014Receive from the decode units. This is information of the two branch targets in the ICNXTBLK for the line PC <b>2</b>. For each bit, reset is non-taken or not valid, set is taken branch target. This information is for selecting a branch target for replacement in case of branch mis-prediction on the undetected branch in fetching.</p><p>ROBLTAG\u2014VIRTUAL LINE TAG\u20143-bit\u2014Reset for each line from <b>0</b> to <b>4</b>. These virtual line tags are rotated with retiring instructions. The line write pointer points to the bottom of the FIROB and the line read pointer points to the next available line in the FIROB. The virtual line tags are sent to functional units.</p><p>ROBALL\u2014ALLOCATE\u20141-bit\u2014Set during dispatching of a line of instructions. Clear on retiring instructions. This status qualifies all other status's.</p><p>Signal List</p><p>IDPC<b>1</b>(<b>31</b>:<b>0</b>)\u2014Input from Idecode indicates the current line PC of the first instruction in the 4 dispatched instructions.</p><p>IDPC<b>2</b>(<b>31</b>:<b>0</b>)\u2014Input from Idecode indicates the current line PC of a second instruction which cross the 16-byte boundary or branch target in the 4 dispatched instructions.</p><p>ROBPC(<b>31</b>:<b>0</b>)\u2014Output indicates the current retire line PC.</p><p>ROBEMPTY\u2014Output indicates the FIROB is empty.</p><p>ROBFULL\u2014Output indicates the FIROB is full.</p><p>LINEPTR(<b>2</b>:<b>0</b>)\u2014Output indicates the current line pointer in the FIROB for the dispatch line of instructions.</p><p>TOPPTR(<b>2</b>:<b>0</b>)\u2014Pointer to the top of the FIROB. This pointer is used to enable the number of lines in the FIROB for dependency checking.</p><p>The Global Status &amp; Registers</p><p>The FIROB includes some of the processor special registers. They are used for instruction execution. These registers can be accessed using move to/from protocol of the SRB. The special registers located in the FIROB are:</p><p>ROBEIP\u2014PROCESSOR PC\u201432-bit\u2014The register is updated on-the-fly by retiring instructions. It tracks the real instruction execution, regardless of the current state of the processor i.e. there is no concept of freezing the PC. The EIP can be accessed using the standard move to/from protocol of the SRB.</p><p>RCVBASE\u2014RECOVERY PC BASE\u201432-bit\u2014Update at the retirement of each taken branch instruction by the content of the ROBEIP(<b>31</b>:<b>4</b>) and the offset of the branch instruction within the line. It is used by microcode to recover the PC of a branch to an illegal address. This is necessary since the limit violation is not detected until the branch instruction is fetched.</p><p>EFLAGS\u2014THE FLAG REGISTER\u201419-bit\u2014Update at the retire of the instructions. The six status bits are divided into three groups OF, {SF,ZF,AF,PF}, and CF. The RF bit is cleared during certain debug operations. EFLAGS bits are cleared by IRESET. The non-status bits can be accessed via the move to/from protocol of the SRB by 10 different pointers. These ten pointers provide independent software read/write access as:</p><p>read/write the entire EFLAG register\u2014bits <b>18</b>:<b>0</b>.</p><p>read/write the lower word\u2014bit <b>15</b>:<b>0</b>.</p><p>read/write the lower byte\u2014bit <b>7</b>:<b>0</b>.</p><p>complement the carry flag\u2014bit <b>0</b>.</p><p>set/clear the direction flag\u2014bit <b>10</b>.</p><p>set/clear the interrupt flag\u2014bit <b>9</b>.</p><p>set/clear the carry flag\u2014bit <b>0</b>.</p><p>FPIP\u2014FLOATING POINT PC\u201448-bit\u2014Update at the retirement of floating point instructions. The FPIP can be accessed using the standard move to/from protocol of the SRB.</p><p>FPSR\u2014FLOATING POINT STATUS REGISTER\u201416-bit\u2014Update at the retirement of floating point instructions. The FPSR can be accessed either by using the standard move to/from protocol of the SRB or by a unique pointer to clear the exception bits. A move to FPSR must be accompanied by a move to the look-ahead copy which is the responsibility of the microcode.</p><p>FPOPCODE\u2014FLOATING POINT OPCODE REGISTER\u201411-bit\u2014Update at the retirement of floating point instructions. The FPOPCODE can be accessed using the standard move to/from protocol of the SRB.</p><p>DR<b>6</b>\u2014DEBUG STATUS REGISTER\u201416-bit\u2014Update the B bits at the retirement of the load/store breakpoints instruction and update the BS bits during single stepping. On instruction breakpoints, global debug traps, and task switch debug traps, DR<b>6</b> must be set by microcode. The DR<b>6</b> can be accessed using the standard move to/from protocol of the SRB.</p><p>Signal List</p><p>WRFPSR(<b>1</b>:<b>0</b>)\u2014Input from ROBCTL indicates to write the two floating point flag groups, {C<b>3</b>,C<b>2</b>,C<b>1</b>,C<b>0</b>} and {SF,PE,UE,OE,ZE,DE,IE}. The updating of FPSR register is from FPSRIN.</p><p>FPSRIN(<b>10</b>:<b>0</b>)\u2014Input data for FPSR register updates.</p><p>WRFPOPCD\u2014Input from ROBCTL indicates to write the FPOPCODE register from FPOPCDIN.</p><p>FPOPCDIN(<b>10</b>:<b>0</b>)\u2014Input data for FPOPCODE register updates.</p><p>PUSHPOP(<b>2</b>:<b>0</b>)\u2014Input to increment or decrement the TOP field of the FPSR register. Bit <b>0</b>\u2014push, decrement by 1. Bit<b>1</b>\u2014pop, increment by 1. Bit <b>2</b>\u2014double pop, increment by 2.</p><p>WRxFLG(<b>2</b>:<b>0</b>)\u2014Input from ROBCTL indicates to write the three flags of EFLAGS register.</p><p>EFTOFLGB(<b>2</b>:<b>0</b>)\u2014Input from ROBCMP indicates to drive the flags to functional units on flag dependency checking.</p><p>CLRRF\u2014Input from ROBCTL indicates to clear the RF bit of EFLAGS register.</p><p>UPDFPIP\u2014Input from ROBCTL indicates to update FPIP from LSCSSEL and EIP.</p><p>SETBS\u2014Input from ROBCTL indicates to update the B bit of DR<b>6</b>.</p><p>LSCSSEL(<b>15</b>:<b>0</b>)\u2014Input from LSSEC indicates the current code segment used for updating FPIP.</p><p>WRPC(<b>3</b>:<b>0</b>)\u2014Input from ROBCTL indicates which PC offset to use to update EIP.</p><p>RBLPC(<b>31</b>:<b>4</b>)\u2014Input from the next to bottom line PC for updating of EIP.</p><p>MVTEIP\u2014Input ROBCTL indicates EIP register updates from IAD bus.</p><p>MVFEIP\u2014Input ROBCTL indicates EIP register move to IAD bus.</p><p>MVTCVB\u2014Input ROBCTL indicates RCVBASE register updates from IAD bus.</p><p>MVFCVB\u2014Input ROBCTL indicates RCVBASE register move to IAD bus.</p><p>MVTCVIO\u2014Input ROBCTL indicates RCVIO register updates from IAD bus.</p><p>MVFCVIO\u2014Input ROBCTL indicates RCVIO register move to IAD bus.</p><p>MVTIPCS\u2014Input ROBCTL indicates the upper 16 bits of the FPIP register updates from IAD bus.</p><p>MVFIPCS\u2014Input ROBCTL indicates the upper 16 bits of the FPIP register move to IAD bus.</p><p>MVTIPOFS\u2014Input ROBCTL indicates the lower 32 bits of the FPIP register updates from IAD bus.</p><p>MVFIPOFS\u2014Input ROBCTL indicates the lower 32 bits of the FPIP register move to IAD bus.</p><p>MVTDR<b>6</b>\u2014Input ROBCTL indicates DR<b>6</b> register updates from IAD bus.</p><p>MVFDR<b>6</b>\u2014Input ROBCTL indicates DR<b>6</b> register move to IAD bus.</p><p>MVTEFLAGS(<b>2</b>:<b>0</b>)\u2014Input ROBCTL indicates EFLAGS register updates in three pieces (the upper half-word and the lower two bytes) from IAD bus.</p><p>MVFEFLAGS(<b>2</b>:<b>0</b>)\u2014Input ROBCTL indicates EFLAGS register moves in three pieces (the upper half-word and the lower two bytes) to IAD bus.</p><p>MVTEFBIT(<b>6</b>:<b>0</b>)\u2014Input ROBCTL indicates manipulation of individual bits in the EFLAGS register. The action performed for each of these bits is:</p><p>bit <b>6</b>: complement the carry flag (bit <b>0</b>)</p><p>bit <b>5</b>: set the direction flag (bit <b>10</b>)</p><p>bit <b>4</b>: set the interrupt flag (bit <b>9</b>)</p><p>bit <b>3</b>: set the carry flag (bit <b>0</b>)</p><p>bit <b>2</b>: clear the direction flag (bit <b>10</b>)</p><p>bit <b>1</b>: clear the interrupt flag (bit <b>9</b>)</p><p>bit <b>0</b>: clear the carry flag (bit <b>0</b>)</p><p>MVFDR<b>6</b>\u2014Input ROBCTL indicates DR<b>6</b> register move to IAD bus.</p><p>EFLAGSAC</p><p>EFLAGSVM</p><p>EFLAGSRF</p><p>EFIOPL(<b>13</b>:<b>12</b>)</p><p>EFLAGSOF</p><p>EFLAGSDF</p><p>EFLAGSAF</p><p>EFLAGSCF\u2014Output generates from the EFLAGS register, these bits are visible from the slave copy of the EFLAGS register. The RF bit is also used in the FIROB to handle instruction breakpoint.</p><p>EFLAGSIF</p><p>EFLAGSTF\u2014Output generates from the EFLAGS register, the interrupt and trace flags are needed locally to control external interrupts and single step trapping.</p><p>XRDFLGB(<b>3</b>:<b>0</b>)\u2014Output to flag operand bus, the bits are read by EFTOFLGB. The order of the bits is OF, SF,ZF,AF,PF,CF.</p><p>MVTFPSR\u2014Input ROBCTL indicates FPSR register updates from IAD bus.</p><p>MVFFPSR\u2014Input ROBCTL indicates FPSR register move to IAD bus.</p><p>CLRFPEXC\u2014Input ROBCTL indicates to clear the stack fault and exception bits {SF,PE,UE,OE,ZE,DE,IE} in the FPSR register. Indirectly the ES and B bits are cleared.</p><p>FPTOP(<b>2</b>:<b>0</b>)\u2014Output to register file indicates the current top-of-stack to identify the registers being popped to clear the full bits.</p><p>REQTRAP\u2014Global output, one cycle after EXCEPTION, indicates to drive the XLASTKPTR.</p><p>XFERR_P\u2014Output to BIU indicates the floating point error which is inverted of the ES bit from the slave of the FPSR. It is also used by the FIROB to generate the plunger traps.</p><p>XLASTKPTR(<b>2</b>:<b>0</b>)\u2014Output to Idecode indicates the TOP bits for the FPSR for correct floating point stack pointer.</p><p>MVTFPOPCD\u2014Input ROBCTL indicates FPOPCODE register updates from IAD bus.</p><p>MVFFPOPCD\u2014Input ROBCTL indicates FPOPCODE register move to IAD bus.</p><p>Timing</p><p>Since the clock cycle is short, the comparators and detection of the hit for dependency can be done in a phase using CAM cells. The tag and decision to send data should be done in another cycle.</p><p>ICLK<b>2</b>: The operand linear address and register address is available at the end of this cycle.</p><p>ICLK<b>3</b>: Dependency checking. Generate dependency tag and read data to operand steering if hit.</p><p>ICLK<b>4</b>: Read and mux data to the operand data buses to the functional units. Update status bits.</p><p>For Retiring Instructions</p><p>ICLK<b>5</b>: Results from the functional units. Compare tag to latch data. Update status and check for branch mis-prediction.</p><p>ICLK<b>6</b>: Retire a line if all entries have valid results. Update PC, flags. Drive new WRPTR and WRPTR<b>1</b>.</p><p>Layout</p><p>The layout of the FIROB is in three locations:</p><p>The operand addresses and comparators in the data path next to the decode units.</p><p>The result data in the data path next to the reservation stations and functional units.</p><p>The status and global controls on the left side of the data path.</p><p>A block diagram of the layout is shown as FIG. <b>36</b>.</p><p>Register File Overview</p><p>Processor <b>500</b> has the standard x86 register file (EAX to ESP) which is read from four dispatch positions and written to from the FIROB using four writeback positions. It is the FIROB's responsibility to make sure that no two writebacks go to the same register. There are also 16 scratch registers available to all 4 dispatch positions. Eight registers are currently in the design for microcode use. Only the real (non-speculative) states are stored in the register file. No floating point registers are stored in the integer register file. Each of the 8 visible registers and the 16 temporary registers have enables to selectively write/read to bits (<b>31</b>:<b>16</b>), (<b>15</b>:<b>8</b>), or (<b>7</b>:<b>0</b>). The FIROB send bytes enable bits and valid write bits to the register file. Read valid bits and read byte enables will be sent by the dispatch/decode unit. Constants are not handled in the register file but rather get sent on the BOPND bus using the decode unit.</p><p>Registers</p><p><tables id=\"TABLE-US-00052\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Address</entry><entry morerows=\"0\" valign=\"top\">Register Name</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">00</entry><entry morerows=\"0\" valign=\"top\">EAX</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01</entry><entry morerows=\"0\" valign=\"top\">EDX</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">02</entry><entry morerows=\"0\" valign=\"top\">ECX</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">03</entry><entry morerows=\"0\" valign=\"top\">EBX</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">04</entry><entry morerows=\"0\" valign=\"top\">EBP</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">05</entry><entry morerows=\"0\" valign=\"top\">ESI</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">06</entry><entry morerows=\"0\" valign=\"top\">EDI</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">07</entry><entry morerows=\"0\" valign=\"top\">ESP</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">10</entry><entry morerows=\"0\" valign=\"top\">TMPREG00</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11</entry><entry morerows=\"0\" valign=\"top\">TMPREG01</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">12</entry><entry morerows=\"0\" valign=\"top\">TMPREG02</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">13</entry><entry morerows=\"0\" valign=\"top\">TMPREG03</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1F</entry><entry morerows=\"0\" valign=\"top\">TMPREG0F</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Register File Timing</p><p>A register file timing diagram is illustrated in FIG. <b>37</b>. Instead of the normal method of a write to the register file followed by a read from the register file, Processor <b>500</b> does a read first followed by a write. The early read allows sufficient time for multiplexing between the register value (the one actually read) and forwarding from the incoming writes. The end of the cycle is needed to drive the read value over to the operand steering unit. A self timing circuit is used to provide sufficient delay for the write and read decoding logic to complete before the read and write actually take place. Both the read and write decoding sections start decoding immediately after the ALAT's latch in the read and write pointer busses. There are sixteen 5 bit comparators which detect if forwarding is needed from a writeback port to a read port. The forwarding will bypass the delay through the register latch and help allow the read to complete within the cycle. The Read outputs from the register file will drive on a dedicated bus over to the operand steering unit. For maintaining fast logic, 3 input nand gates are used in the decode section. The 4 input nand gate is a large decrease in speed, and the 5 bit pointer bus along with an enable signal fit a two 3 input nand gate structure. There is not any reset logic for the register array.</p><p>Register File Sub Blocks</p><p>A block diagram of the register file sub blocks is given as FIG. <b>38</b>. The register sub-blocks are the register cell array with four data inputs and eight data outputs, the compare array, the read decode array, the write array, the muxing section, and the output drivers. The ability to both read and write in during the same cycle is important to this block, and careful attention needs to be paid to the layout, capacitive loading and the bussing. Due to problems with fringing capacitance between adjacent metal lines, the register file does not contain precharge/discharge logic. It makes use of multiplexers, tristate gates, and static logic.</p><p>Signal List</p><p>RDnPTR<b>1</b>(<b>4</b>:<b>0</b>)\u2014the first operand pointer for reading from the register file for positions <b>0</b> to <b>3</b>.</p><p>RDnPTR<b>2</b>(<b>4</b>:<b>0</b>)\u2014the second operand pointer for reading from the register file for positions <b>0</b> to <b>3</b>.</p><p>USE<b>1</b>RD(<b>3</b>:<b>0</b>)\u2014These signals are valid bits from IDECODE indicating which reads are valid for the 1st operand. Each bit in these busses correspond to a dispatch position.</p><p>USE<b>2</b>RD(<b>3</b>:<b>0</b>)\u2014These signals are valid bits from IDECODE indicating which reads are valid for the 2nd operand. Each bit in these busses correspond to a dispatch position.</p><p>RDnENB<b>1</b>(<b>2</b>:<b>0</b>)\u2014byte enables for position n and for the 1st operand. Bit <b>2</b> refers to the upper two bytes while bits <b>1</b> and <b>0</b> refer to the lower bytes (bits <b>15</b>:<b>8</b>) and (bits <b>7</b>:<b>0</b>).</p><p>RDnENB<b>2</b>(<b>2</b>:<b>0</b>)\u2014byte enables for position n and for the 2nd operand. Bit <b>2</b> refers to the upper two bytes while bits <b>1</b> and <b>0</b> refer to the lower bytes (bits <b>15</b>:<b>8</b>) and (bits <b>7</b>:<b>0</b>).</p><p>WBnPTR(<b>4</b>:<b>0</b>)\u2014the writeback pointer for position n. This must be qualified with the register write valid bits</p><p>VRWB(<b>3</b>:<b>0</b>)\u2014valid register writeback indication for each of six positions.</p><p>WBnENB<b>1</b>(<b>2</b>:<b>0</b>)\u2014byte enables for position n and for the register writeback. Bit <b>2</b> refers to the upper two bytes while bits <b>1</b> and <b>0</b> refer to the lower bytes (bits <b>15</b>:<b>8</b>) and (bits <b>7</b>:<b>0</b>).</p><p>RDnREGA(<b>31</b>:<b>0</b>)\u2014read data from the register file for position n and operand A.</p><p>RDnREGB(<b>31</b>:<b>0</b>)\u2014read data from the register file for position n and operand B.</p><p>WBnD(<b>31</b>:<b>0</b>)\u2014writeback data from the FIORB for position n.</p><p>Load/Store Section Overview</p><p>The load store section in Processor <b>500</b> can perform single-cycle access of two memory based operands (2 loads or 1 load and 1 store). It can also perform out-of-order loads requested by the functional units. The stores go in-order and are performed as pure writes. The data cache is a linear cache, dual ported for the two concurrent accesses, 16KB 8-way set associative with way prediction. FIG. 39 shows the basic organization of the load/store section. It is comprised of a special unified load-store buffer. The information on whether an instruction is a load or a store is sent to the LSSEC by the decode unit. The linear address and data are computed by the functional units and sent to the LSSEC on the RESLA and result buses. The load/store unit then performs two data cache accesses. The loads may be performed out-of-order, but the stores are always in order. The unified load-store buffer is 8-entries deep. It can accept up to four instructions per cycle.</p><p>Other Features are</p><p>* Unaligned accesses have at least one cycle penalty (2-cycle latency).</p><p>* The current scheme supports non-blocking loads.</p><p>Note: Unaligned accesses in this section means accesses crossing double word boundaries.</p><p>Unified Load-Store Buffer (LDSTBUF)</p><p>The loads and stores are buffered up in a common queue, called the unified load-store buffer. The load and store instructions are buffered up in this common queue in program order with the earliest instruction at the bottom and the latest instruction at the location pointed to by LDSTPTR-<b>1</b>, as shown in FIG. <b>40</b>.</p><p>The advantages of this scheme over the conventional scheme where the loads and stores are buffered up in different queues are:</p><p>1. Efficient utilization of space due to which the dispatch would stall based on the total number of loads and stores as opposed to the number of loads or number of stores in the conventional method.</p><p>2. Also, since communication is between the decode unit and load-store section, the functional units would never stall. They can keep executing the instructions in their reservation stations.</p><p>3. The order of loads and stores are known since they are dispatched directly to the load-store section, instead of going through the functional units which could send requests out of order.</p><p>Each entry (as shown in FIG. 41) in the buffer is broken down into three fields. The first field is made up of the FIROB instruction tag and the instruction type (load, store or load-op-store). The source of updates for this field is the decode unit/FIROB. The second field has the linear address and store data and the associated valid bits, the update source being the functional units. The third field is made up of some control information (for e.g. M bit indicating that this entry missed in the data cache on a prior access, D bit indicating that the load in the entry is dependent on a store in the buffer), the update source being the load-store section itself.</p><p>LSCNT[<b>2</b>:<b>0</b>] indicates to the decode unit the number of free entries in the buffer so that decode can take the necessary action. It is the difference between <b>8</b> and LDSTPTR.</p><p>Updating the Entries</p><p>FIG. 42 illustrates a timing diagram of when the different fields of each entry in the buffer are updated. The instruction types (ITYPEnB[<b>1</b>:<b>0</b>]) and ROB tags (DTAGnB[<b>2</b>:<b>0</b>]) are sent in a given(i)th ICLK. The corresponding mux select lines are generated and the entries updated. Also the LDSTPTR is incremented/decremented and by the end of that cycle LSCNT[<b>2</b>:<b>0</b>] is generated. At the beginning of the (i+1)th ICLK, the functional units send the tags of the instructions they are currently processing. The LSSEC looks at the tag information from the functional units, compares against the DTAG information in the LDSTBUF and sets up the appropriate mux select lines to latch in the linear address and store data. Also, the corresponding valid bits (LV and DV) are set up at this point so that they can be latched when the address and data get latched on the rising edge of (i+2)th ICLK. The load-store section then accesses the data-cache.</p><p>Prioritizing the Accesses</p><p>The accesses to be performed sit in the unified load-store buffer with or without the linear addresses and store data. The load-store section is able to forward the linear addresses from the functional units for data cache accesses. In general, the processing of instructions is prioritized according to the following:</p><p>1. Misses and stores have the highest priority. They are processed as soon as they are known to be non-speculative. The reason that the stores have higher priority over loads is because of the line-oriented nature of the reorder buffer and we would want to retire instructions as quickly as possible.</p><p>2. Loads can go out of order. The linear address for a load can be in the buffer or can be forwarded directly from the functional units. The result can come back from the data cache or the unified load-store buffer from stores that have not been retired. The results are returned on the dedicated load-store result buses LSRES<b>0</b> and LSRES<b>1</b>.</p><p>Forwarding the linear address from the functional units directly for data cache accesses is based on the assumption that there is no valid outstanding load in the buffer. If there is any load (even one) in the buffer, it is sent to access the data cache and the linear addresses from the functional units are latched in the LDSTBUF. This scheme is followed because of cycle time constraints.</p><p>Data-Cache Accesses</p><p>The data-cache accesses are performed through the LSLINAD<b>0</b> and LSLINAD<b>1</b> buses. LSLINAD<b>0</b> is connected to port A and LSLINAD<b>1</b> is connected to port B of the data cache. The results are returned on LSRES<b>0</b> and LSRES<b>1</b> buses. The data for store accesses is driven on SBADAT and SBBDAT buses.</p><p>Hits</p><p>Bits <b>13</b>:<b>0</b> of the linear address are presented to the data cache just before a given clock edge, so that the DCACHE has enough time to latch it. The array is accessed and the tag is compared with the upper 17-bits of the linear address to generate the hit signal. The data is driven to the functional units prior to the hit being generated. A cancel signal is sent in the next cycle based on whether the access hits/hits in unpredicted way/misses.</p><p>Misses</p><p>If there is a miss, the M bit (Miss) for that entry is set. The load/store section based on the WRPTR information determines whether the instruction is non-speculative in order to go external to fetch the data. There is no handshaking between LSSEC and FIROB. Once the data is written to the data cache, the LSSEC performs the access again.</p><p>Handling Branch Mispredictions</p><p>Whenever a branch misprediction is encountered, the FIROB asserts the BRNMISP signal. The load-store section then sets a latch based on this signal. When a new load or store instruction gets dispatched, the load-store section sets the NF bit for all stores in the buffer and clears the latch. Setting the NF bit for a store indicates that the data from that store should not be forwarded. If there is a load that is dependent on a store with the NF bit set, it is serialized by setting the S bit. The loads keep returning results as they would normally. The stores and load misses are canceled when the FIROB asserts CANENTRY for that instruction.</p><p>Handling Misses</p><p>After a data cache miss, the load-store section performs speculative MMU/PT accesses for possible alias. If an alias exists, the data cache tag is updated and the access performed again. If cache master reports a miss in the physical tags, the load-store section marks the M bit in the entry. The miss is processed after the instruction becomes non-speculative. This is similar to stores based on the WRPTR information.</p><p>If the CMASTER reports that the line is in the ICACHE (self-modifying code) and if the access happens to be a store, the LSSEC sends a \u201cstore-with-resync\u201d status to the ROB to flush out the instructions after the store.</p><p>Unaligned Accesses</p><p>Unaligned loads are performed as 2-cycle single port accesses. When a load access is unaligned, the LSSEC splits that access into 2 single port accesses and issues them in two separate cycles to the data cache. Another aligned load or store can accompany the access on the other port. In the first cycle as the first half of the access is occurring, the address is incremented by 4 and in the second cycle, the other half of the access is performed. The merging is done by the LSSEC.</p><p>Unaligned stores as single port accesses have a problem if they cross a line boundary. If one access hits and the other misses, and if a fault occurs while processing the miss, it could leave the processor in an undesirable state. The safest and probably the easiest approach is to let the LSSEC perform a dual port access so that if any of the two accesses misses, the other is canceled and is performed only after the appropriate line is brought in.</p><p>Checking for Unaligned Accesses</p><p>To determine whether an access is unaligned or not, the LSSEC detects the least significant two bits of LSLINAD<b>0</b> and LSLINAD<b>1</b> and the corresponding data operand sizes. An access is unaligned if the operand size is 32-bits and any one of the two least significant address bits is set or if the operand size is 16 bits and both the least significant bits of the linear address are set.</p><p>Aliasing Problem and Solution</p><p>The data cache is a linear cache with two ports. There is a potential that two or more linear addresses map to the same physical address (aliasing). There can never be more than one location in the data cache for a physical address. The problem is with the loads going out-of-order. A load with linear address LA<b>1</b> has the potential of going out-of-order and if that location exists in the data cache, it hits and returns the result. A store with linear address LA<b>2</b> ahead of the load might be mapped to the same physical address. Then, the result that the load returned is wrong since the load was not able to see the dependency. The solution to the problem is the way load-store dependency checking is performed (described later).</p><p>Non-blocking Loads</p><p>The gap between microprocessor and memory speeds is widening with every new generation of microprocessors. This speed discrepancy can impact performance if the load-store section of the processor stalls whenever a data cache miss occurs. To prevent stalling of the load-store section, loads in the buffer can access the data cache as any miss is being processed. The following describes, in brief, the method that Processor <b>500</b> uses to perform non-blocking loads.</p><p>Load and store instructions in Processor <b>500</b> are sent to a unified load-store buffer. Each entry in this buffer has a bit M that indicates if the load or store in the entry missed on a prior access. Whenever a data cache access misses, the M bit (miss) is set in the entry. Since the processor allows speculative execution, the miss cannot be processed immediately. It can be processed only when the instruction is no longer speculative. In conventional implementations, when a miss is being processed, loads or stores in the queue are held up till the miss gets resolved. The load-store section requests the Cache Master (CMASTER) to perform an external access to process a miss. The CMASTER goes-external and takes a long time before it can fetch the line of interest. The fetched line comes in packets of 64 bits over the data bus to CMASTER which in turn sends the packet over to the data cache. The data cache latches the packets in a local buffer (BUF<b>1</b>). In the mean time, the load-store section can keep sending load accesses to the data cache. If the accesses hit in the cache, the results are returned. If an access misses, the M bit for that entry is set and the remaining loads in the buffer can be sent to the data cache. Once the data cache receives the entire line from CMASTER, it initiates the reload sequence. This reload sequence involves reading the line to be replaced into another local buffer (BUF<b>2</b>) and then updating the line and tag with the contents of BUF<b>1</b>. When it performs the line write, the load-store section clears the M bit for all the entries in the LDSTBUF, so that if any of the accesses missed on the line that was being brought in, it need not go external again. If the line in BUF<b>2</b> is dirty, the load-store section initiates an external write cycle through the CMASTER.</p><p>Possible Data Cache Access Scenarios</p><p>Port A:</p><p>Reloads from Physical Tags (PT)</p><p>Accesses from LSLINAD<b>0</b></p><p>Drives result on LSRES<b>0</b></p><p>Port B:</p><p>Reload invalidations</p><p>Accesses from LSLINAD<b>1</b></p><p>Drives result on LSRES<b>1</b></p><p>Before accessing the data cache, the load-store section will check for bank conflicts and unaligned accesses. If there is a bank conflict, the load-store section will issue only one access. This is transparent to the data cache.</p><p>Port A\u2014load, Port B\u2014load</p><p>Port A hit, port B hit\u2014Complete both accesses</p><p>Port A miss, port B hit\u2014Complete Port B access, mark entry as miss</p><p>Port A hit, port B miss\u2014Complete Port A access, mark entry as miss</p><p>Port A miss, port B miss\u2014Mark entries as misses</p><p>Port A access unaligned\u2014Perform access. Take penalty.</p><p>Port B access unaligned\u2014Perform access. Take penalty.</p><p>Port A\u2014store, Port B\u2014load</p><p>Port A hit, port B hit\u2014Complete both accesses</p><p>Port A miss, port B hit\u2014Complete Port B access, mark entry as miss</p><p>Port A hit, port B miss\u2014Complete Port A access, mark entry as miss</p><p>Port A miss, port B miss\u2014Serialize</p><p>Port B access unaligned\u2014Perform access. Take penalty.</p><p>Port A\u2014load, Port B\u2014store</p><p>Same as the previous case.</p><p>Port A\u2014store, Port B\u2014store</p><p>The ROB provides two signals: WRPTR\u2014the current instruction (store) to be retired and WRPTRI\u2014the next store in the current line that can be retired. By looking at this information, the LSSEC should be able to perform two simultaneous stores to the DCACHE.</p><p>Port A hit, port B hit\u2014Complete accesses</p><p>Port A miss, Port B hit\u2014Complete Port B access</p><p>Port A hit, port B miss\u2014Complete Port A access</p><p>Port A miss, Port B miss\u2014Serialize</p><p>Port B access unaligned\u2014do not perform access</p><p>FIG. 43 gives the timing of aligned data cache accesses. As can be seen, there are three different cases\u2014hit, hit in unpredicted way and miss. The data cache uses a way prediction scheme to access its data and tag arrays. If the prediction is wrong and the data happens to reside in the cache, a 1-cycle penalty is taken. The result is returned in the next cycle. It is also important to cancel the previous result.</p><p>Unaligned accesses are more complicated. The following flow charts give the details. Note that cycles for speculative MMU/PT accesses are not taken into consideration in the flow charts.</p><p>Unaligned Load</p><p>Single Port Access</p><p>Cycle 1: Perform MA<b>1</b> access, increment address</p><p>Cycle 2: Hit/Hit in unpred way/Miss indication for MA<b>1</b> Perform MA<b>2</b> access</p><p>Cycle 3: Hit/Hit in unpred way/Miss indication for MA<b>2</b></p><p>If MA<b>1</b>_hit,</p><p>Perform next access</p><p>If MA<b>1</b>_hit_in_unpred_way,</p><p>Perform MA<b>2</b> again</p><p>If MA<b>1</b>_miss,</p><p>Mark M bit</p><p>Cycle 4:</p><p>If MA<b>2</b>_hit,</p><p>Instruction out of buffer</p><p>If MA<b>2</b>_hit_in_unpred_way,</p><p>Perform next access again</p><p>Instruction out of buffer</p><p>If MA<b>2</b>_miss,</p><p>Mark M<b>2</b> bit.</p><p>Unaligned Store</p><p>2-port Access</p><p>Cycle 1:</p><p>Unmerge data, increment address</p><p>Cycle 2: Perform dual port access</p><p>Cycle 3: Hit/Hit in unpred way/Miss indication for MA<b>1</b> and MA<b>2</b>. Perform next access</p><p>Cycle 4: If MA<b>1</b>_hit and MA<b>2</b>_hit,</p><p>Instruction out of buffer</p><p>If MA<b>1</b>_hit and MA<b>2</b>_hit_in_unpred_way,</p><p>Perform next B access again</p><p>Instruction out of buffer</p><p>If MA<b>1</b>_hit_in_unpred_way and MA<b>2</b>_hit,</p><p>Perform next A access again</p><p>Instruction out of buffer</p><p>If MA<b>1</b>_miss,</p><p>Mark M bit</p><p>If MA<b>2</b>_miss,</p><p>Mark M<b>2</b> bit</p><p>Checking for Bank and Index Conflicts</p><p>For circuit reasons, two concurrent accesses to the data cache cannot be to the same bank. Therefore, the LSSEC must determine if there is a bank conflict and cancel the port B access and issue it in the next cycle. Since the tag array is also dual ported, the data cache needs information if two concurrent accesses are to the same index.</p><p>Bank Conflict: LSBNKCT is driven high if LSLINAD<b>1</b>[<b>4</b>:<b>2</b>]==LSLINAD<b>0</b> [<b>4</b>:<b>2</b>]</p><p>Index Conflict: LSINDXCT is driven high if LSLINAD<b>1</b>[<b>10</b>:<b>5</b>]==LSLINAD<b>0</b>[<b>10</b>:<b>5</b>]</p><p>Also for the way prediction array, which is also dual ported, another signal LSPRWYCT is driven if LSLINAD[<b>13</b>:<b>5</b>]==LSLINAD<b>0</b>[<b>13</b>:<b>5</b>].</p><p>Dependency Checking Against Stores in the Buffer</p><p>When the load-store section performs data cache accesses, it also performs dependency checking against the stores in the store buffer. Bits <b>11</b>:<b>2</b> of the linear addresses are compared against the corresponding bits of the linear addresses of the stores ahead of the load[Also, the operand sizes and other misaligned address information are used in the equation to figure out dependency]. If the addresses match, the data of the latest store to that address is forwarded on to the result bus. To perform dependency checking and forward the store data, the load-store section has one whole cycle. In the following cycle, the rest of the bits (<b>31</b>:<b>12</b>) are compared. If this compare fails, the LSSEC signals FIROB and the functional units to cancel that result just the way the data cache does and the LSSEC serializes that load.</p><p>The advantage of using 10/12-bit comparators instead of 32-bit comparators is the reduction in hardware and increase in speed. By comparing bits <b>11</b>:<b>2</b>, and serializing loads that have partial address matches, the the aliasing problem may be solved.</p><p>On the condition that the addresses match and the operand sizes are different, the load is serialized. A timing diagram of dependency checking is given as FIG. 44. A hardware block diagram is given as FIG. <b>45</b>.</p><p>Summary of Dependency Checking/store Forwarding:</p><p>1. Forward data operand from a store if:</p><p>the load and store addresses match completely, store data is valid and the operand sizes are equal.</p><p>** This is true if both the load and store accesses are misaligned.</p><p>2. Set \u2018D\u2019 bit for the load if:</p><p>the store address is not computed yet or</p><p>the addresses match, opsizes match and data is not valid.</p><p>** The D bit is cleared on any store data or address update from the functional units.</p><p>3. Set \u2018S\u2019 bit if:</p><p>the addresses match and opsizes are different or</p><p>the load access is to the same bank as the store and not to the same byte (partial dependency) or</p><p>the load access is to the adjacent bank as a misaligned store (partial dependency\u2014tricky case)</p><p>** S\u2192this load is serialized\u2014wait till load is at the bottom of the load-store buffer.</p><p>Snooping the Load-store Buffer</p><p>During prefetch, the CMASTER snoops the LDSTBUF entries to check if there are valid pending stores to that line. If there is a pending load to the line, then the prefetch holds till the store is done. To limit hardware supporting this feature, eight dedicated 8-bit comparators are provided for partial comparison of the line address. This structure can be used for the general snooping issues.</p><p>No snooping structures are required in the load-store buffer. The reasoning goes as follows:</p><p>In previous processors, a store sitting in the store buffer is retired as far as the ROB and the execution core of the machine are concerned. The ROB can retire instructions that are past the store even before the store is written to the data cache.</p><p>During prefetch of a cacheable line, the store buffer entries need to be snooped make sure that a store in the store buffer is not to the same prefetched line. If it is (self-modifying code case), the prefetch stalls till the store is written.</p><p>The reservation stations need not be snooped in this case since the store has not performed the data cache lookup yet. When the store does the lookup (a speculative read), it is going to miss in the data cache and the Physical Tags (PT) will assert IC_CACHED signal indicating the LSSEC to return with the \u201cstore with resync\u201d status. The ROB will then flush all instructions after the store and instructions are redispatched.</p><p>If the prefetched line is non-cacheable, prefetch stalls if there are stores in the store buffer to the same line or if there isa store in the reservation stations. The reason for making sure that the reservation stations do not have stores is that Physical Tags (PT) will not assert IC_CACHED since the prefetched line is not cached and might not be in the prefetch buffer.</p><p>Serialization Conditions</p><p>a) Miss\u2014Any entry that misses has to wait for WRPTR from FIROB to compare against its tag before it can go external.</p><p>b) Store\u2014Wait for WRPTR from FIROB.</p><p>c) Store address match , data not ready\u2014Wait for store data.</p><p>d) Store address match, data ready but of different size\u2014wait till the store is done.</p><p>e) Store linear address not ready\u2014wait for store linear address.</p><p>f) Store address match, NF bit set.</p><p>g) Bits <b>11</b>:<b>0</b> match and <b>31</b>:<b>12</b> don't\u2014possible alias.</p><p>Handling Non-zero Segment Bases</p><p>The discussion above assumes that the linear addresses are sent over to the load store section by the functional units. This is true if the corresponding segment base is zero. If the segment base is non-zero, the functional units send the logical address. This logical address when added to the segment base in the corresponding segment register generates the linear address. The buffer stores linear addresses and therefore, the following scheme where an extra cycle is taken to compute the linear address is proposed.</p><p>For null segment indications from microcode and when all the segment bases are zero, there is a bypass path to the load-store buffer from the functional units. This is shown in FIG. <b>46</b>.</p><p>Floating Point Loads and Stores</p><p>The floating point instructions are done in microcode. Thus the load-store section handles the FP loads and stores as normal loads and stores. The unit load/store does not know that it is performing an FP load or store.</p><p>Special Registers (LSSPREG)</p><p>Special Registers in the load store section include the segment registers and the debug registers. The addresses that are generated by the functional units do not account for the segment base. If the appropriate segment base is not zero, it has to be added to the result generated by the functional units. In the case of non-zero segment base, an extra clock cycle is taken to compute the linear address. The LSSEC maintains all the segment registers and their invisible portion\u2014the 8-byte descriptor. The segment registers can be loaded using a load instruction with the selector value as the operand. The special registers are summarized below:</p><p><tables id=\"TABLE-US-00053\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"70PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CS</entry><entry morerows=\"0\" valign=\"top\">Selector, CSDES.HI,</entry><entry morerows=\"0\" valign=\"top\">CSDES.LO</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">Selector, SSDES.HI,</entry><entry morerows=\"0\" valign=\"top\">SSDES.LO</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DS</entry><entry morerows=\"0\" valign=\"top\">Selector, DSDES.HI,</entry><entry morerows=\"0\" valign=\"top\">DSDES.LO</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ES</entry><entry morerows=\"0\" valign=\"top\">Selector, ESDES.HI,</entry><entry morerows=\"0\" valign=\"top\">ESDES.LO</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">FS</entry><entry morerows=\"0\" valign=\"top\">Selector, FSDES.HI,</entry><entry morerows=\"0\" valign=\"top\">FSDES.LO</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">GS</entry><entry morerows=\"0\" valign=\"top\">Selector, GSDES.HI,</entry><entry morerows=\"0\" valign=\"top\">GSDES.LO</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LDTR</entry><entry morerows=\"0\" valign=\"top\">Selector, LDTRDES.HI,</entry><entry morerows=\"0\" valign=\"top\">LDTRDES.LO</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">TR</entry><entry morerows=\"0\" valign=\"top\">Selector, TRDES.HI,</entry><entry morerows=\"0\" valign=\"top\">TRDES.LO</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">TEMP</entry><entry morerows=\"0\" valign=\"top\">Selector, TEMPDES.HI,</entry><entry morerows=\"0\" valign=\"top\">TEMPDES.LO</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>All of the above have BASE, LIMIT and-ATTR fields within their descriptor HI and LO fields and can be read independently.</p><p><tables id=\"TABLE-US-00054\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"70PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">GDTR</entry><entry morerows=\"0\" valign=\"top\">BASE,</entry><entry morerows=\"0\" valign=\"top\">LIMIT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDTR</entry><entry morerows=\"0\" valign=\"top\">BASE,</entry><entry morerows=\"0\" valign=\"top\">LIMIT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">FPDP</entry><entry morerows=\"0\" valign=\"top\">FPDP.HI,</entry><entry morerows=\"0\" valign=\"top\">FPDP.LO</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CAR</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DR0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DR1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DR2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DR3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DR7</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The SRB can access all the following fields: DESC.HI, DESC.LO, LIMIT, ATTR, BASE, SELECTOR.</p><p>Limit Checking</p><p>The limit checking is done in the LSSPREG section. The following information is needed to perform limit checking.</p><p>* Data size\u2014byte, word, dword.</p><p>* PE, VM bits.</p><p>* D, G, ED from the descriptor.</p><p>The load-store buffer has the linear address, and the limit obtained from the segment descriptor is a logical limit. In order to perform limit checking with these two quantities, the segment base is added to the limit to obtain the linear limit. The linear limit is computed when performing the segment load and a copy of it stored for use during limit checking. Protection checking logic is also in this block. The limit/protection check logicis pipelined, as shown in FIG. <b>47</b>.</p><p>Handling Special Register Moves</p><p>It has been found that serialization in microcode of several instructions limits performance. To improve performance, some instructions are not serialized in Processor <b>500</b>. This requires hardware support in the respective units.</p><p>All moves to and from GS, ES and FS are not serialized in dispatch. These moves will be dispatched to the LSSEC similar to a load or a store, but they sit in a special four-entry FIFO. This FIFO is physically located in the LSSPREG block. The move-to's in this buffer are performed when they are non-speculative. This is very much similar to the store operation. FIG. 48 illustrates the details of each entry of this LSRBUF.</p><p>Segment Loads</p><p>A segment load instruction will be dispatched both to the LDSTBUF and the special registers FIFO. These instructions are interpreted by the LDSTBUF as loads and as writes (or move to's) by the special register FIFO. The results from the loads are forwarded into the FIFO which writes the appropriate segment registers after the FIROB indicates that the instruction is non-speculative.</p><p>In addition to the instruction type information, the decode/microcode unit sends additional control bits to the load-store section directly as summarized below. The information is to inform the LSSEC which segment is being accessed, the type of protection checks that need to be performed, etc. That there are four buses INSLSnB[<b>10</b>:<b>0</b>] that supply this information.</p><p>Also, the LSSEC needs three bits of information communicated by the microcode about types of segment loads, types of protection checking, reporting of error codes, etc.</p><p>INSLSnB[<b>10</b>:<b>8</b>]</p><p>CS Loads</p><p><b>000</b> Normal segment load for a far jump, call, move, etc.</p><p><b>001</b> due to selector from call gate when executing jmp instruction.</p><p><b>010</b> due to selector call from call gate when executing call instruction.</p><p><b>011</b> due to selector from task gate. Should not result in another gate. Should be type TSS</p><p><b>100</b> Selector from RET instruction.</p><p><b>101</b> Selector from IRET instruction.</p><p><b>110</b> Selector from INT instruction.</p><p><b>111</b> This is used when loading selectors from TSS on a task switch.</p><p>SS Loads</p><p><b>001</b> Selector from TSS. This is used when performing SS load on a privilege level change using a selector that has been read out of TSS.</p><p><b>111</b> Report errors as TSS faults as selector came from TSS. DS, ES, FS, GS, LDTR, TR</p><p><b>111</b> Report errors as TSS faults as selector came from TSS.</p><p>TR Loads</p><p><b>001</b> All busy checks are done by microcode when performing task switches. However, when loading TR using LTR instruction, the busy check has to be done by LSSEC.</p><p><b>000</b> This is the normal TR load. No busy checks. When performing task switches.</p><p>General Loads and Stores</p><p><b>010</b> When these operations are performed, report CPL as zero to DCACHE and TLB so that they can do page level protection checking using CPL of <b>0</b> instead of CURCPL.</p><p><b>001</b> All pushes and pops of copying parameters, when switching stacks, will report errors as TSS faults.</p><p><b>011</b> Ignore alignment checking.</p><p><b>110</b> Used in CMPXCHG<b>8</b>B routine.</p><p>IDT Loads</p><p><b>001</b> This switch indicates that the IDT lookup was initiated by a software interrupt and the DPL and CPL checks should be done.</p><p><b>010</b> When these operations are performed, report CPL as zero to DCACHE and TLB so that they can do page level protection checking using CPL of <b>0</b> instead of CURCPL.</p><p>A diagram of protection checking hardware is illustrates in FIG. <b>49</b>.</p><p>LSSEC\u2014Cache Master Interface</p><p>This Section Covers the Following Topics:</p><p>1. Protocol for handling data cache misses</p><p>2. Protocol for handling non-cacheable accesses</p><p>3. Protocol for handling locked accesses</p><p>Misses</p><p>Load Miss[Paging on, DCACHE on]</p><p>When a load access to the data cache misses, the LSSEC does a speculative lookup of the TLB/PT to check if there is an alias. It does this by asserting LS_MMU_RD signal with the linear address on the DADDR[<b>31</b>:<b>0</b>] bus. The CMASTER can respond with the following signals</p><p>TLB_MISS\u2014The look up in the TLB missed. Therefore, a true miss.</p><p>PT_MISS\u2014The lookup hit in the TLB but missed in the PT. Therefore, a true miss.</p><p>CM_DC_ALIAS\u2014There is an alias in the data cache.</p><p>IC_CACHED\u2014The line requested is in the instruction cache.</p><p>Load Miss\u2014Data cache on, paging off</p><p>When paging is off, the linear address and the physical address are the same. If a load accesses misses in the data cache, it is also going to miss in the TLB. So, in this case, as soon as there is a data cache miss, LSSEC goes external to get the data of interest. The M bit for the load is set when a dcache miss is encountered.</p><p>As soon as the instruction becomes non-speculative, the address is sent on the DADDR bus and the signals LS_MMU_RD and LS_NOT_SP are asserted. At this point in time, the CMASTER and the DCACHE go through the reload sequence. After reload is done, the data cache asserts the DCDATRDY signal and in the next cycle the dcache drives the result on the LSRES bus while the lssec drives the LSTAG bus.</p><p>Load Miss\u2014Data Cache On, Paging On</p><p>In this case, when the load-store section encounters a data cache miss, it does a speculative TLB/PT access. It does so by asserting LS_MMU_RD and driving the DADDR bus with the load linear address.[It is noted that LS_NOT_SP signal is not asserted during speculative lookups. During speculative look up, the CMASTER can assert one of the following three signals\u2014TLB_LS_MISS [access missed in the TLB], CM_DC_ALIAS [access hit in the TLB and the physical tags reported an alias], PT_MISS [access hit in the TLB but missed in the physical tags], MMULSPGFLT [encountered a protection violation in the TLB]. For the case of CM_DC_ALIAS, the CMASTER sends the column information to the data cache and the LSSEC drives the address and LSUPDATERD signal to the data cache which will then update its tag and drive the result. For TLB_LS_MISS and PT_MISS cases, the M bit in the entry is set. When the instruction becomes non-speculative, the address is sent on the DADDR bus and the signals LS_MMU_RD and LS_NOT_SP are asserted. It is now the responsibility of the CMASTER to resolve TLB miss and get the line-of interest from memory. For the case of page fault, the LSSEC sends a page fault status to the FIROB with a page fault vector on the result bus. If the instruction is non-speculative, the FIROB then asserts EXCEPTION and drives the entry point of the page fault routine.</p><p>Handling Physical Addresses from Microcode</p><p>The microcode can send physical addresses for HDT mode, microcode patch, etc. The LSSEC and the cache master handles this. There is an indication on the INSLS bus if an address from the functional unit is a physical address. The LSSEC latches this information in the unified load-store buffer. It treats this access as a non-cacheable access. The address is driven on the DADDR bus to the CMASTER and the signal LS_PHYSICAL is asserted. The cache master, when it sees this signal, disables translation and performs a physical tags look up. If there is an alias, the CMASTER asserts CM_DC_ALIAS signal and drives the column information over to the data cache. After the data cache signals that it is ready to receive the access, the LSSEC drives the index without LSUPDATERD being asserted. The data cache then drives the data and presents the hit status to the functional units and FIROB.</p><p>If there is no alias, the access is treated as a non-cacheable access.</p><p>There is a problem with this approach\u2014load-store dependency checking is disabled when there is a combination of physical and linear addresses. But, this may be handled if only linear addresses and only physical addresses are used. The best solution is if microcode introduces serialization when switching between HDT (patch) and non-HDT (non-patch) modes. Dependency checking can now be handled in the same way for all the modes.</p><p>Signal List</p><p>Inputs</p><p><tables id=\"TABLE-US-00055\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BIU_NC[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from CMASTER</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>When this signal is asserted, the reload data should not be placed in the data cache.</p><p><tables id=\"TABLE-US-00056\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CANENTRY</entry><entry morerows=\"0\" valign=\"top\">Input from FIROB</entry><entry morerows=\"0\" valign=\"top\">ICLK7</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>When this bit is asserted, the instruction pointed to by WRPTR is invalidated.</p><p><tables id=\"TABLE-US-00057\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CANENTRY1</entry><entry morerows=\"0\" valign=\"top\">Input from FIROB</entry><entry morerows=\"0\" valign=\"top\">ICLK8</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>When this bit is asserted, the instruction pointed to by WRPTR<b>1</b> is invalidated.</p><p><tables id=\"TABLE-US-00058\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMSTRBUSY</entry><entry morerows=\"0\" valign=\"top\">Input from CMASTER</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates that the cache master is busy.</p><p><tables id=\"TABLE-US-00059\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CM_DC_ALIAS</entry><entry morerows=\"0\" valign=\"top\">Input from CMASTER</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates that there is an alias in the data cache for the request sent.</p><p><tables id=\"TABLE-US-00060\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CROWP</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CROAM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CROPE</entry><entry morerows=\"0\" valign=\"top\">Inputs from SRB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Bits from the CR<b>0</b> register. WP bit is used in preventing supervisory accesses to read-only pages. The AM flag if set means that all unaligned accesses will generate exceptions. The PE bit is used to change the mode of processor to protected mode from real mode.</p><p><tables id=\"TABLE-US-00061\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCCNCLA</entry><entry morerows=\"0\" valign=\"top\">Input from DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK7</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates that the port A access must be canceled and reissued in the next clock cycle.</p><p><tables id=\"TABLE-US-00062\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCCNCLB</entry><entry morerows=\"0\" valign=\"top\">Input from DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK7</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates that the port B access must be canceled and reissued in the next clock cycle.</p><p><tables id=\"TABLE-US-00063\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCDATARDY</entry><entry morerows=\"0\" valign=\"top\">Input from DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCBUSY</entry><entry morerows=\"0\" valign=\"top\">Input from DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK12</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The data cache asserts this signal to inform that it is busy either doing a snoop read, snoop invalidation, reload or a cache line read that is done prior to a reload. The LSSEC does not send any access as long as this is asserted.</p><p><tables id=\"TABLE-US-00064\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCFINRLD</entry><entry morerows=\"0\" valign=\"top\">Input from DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indication from the data cache that a reload has been completed. The LSSEC can now request for DCACHE loads and stores.</p><p><tables id=\"TABLE-US-00065\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCLSD[1:0]</entry><entry morerows=\"0\" valign=\"top\">Input from DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>DCLSD[<b>0</b>] and DCLSD[<b>1</b>] are the dirty bits corresponding to port A and port B respectively. The are used by the LSSEC during stores to determine if the corresponding dirty bit in the page table entry is set correctly in the TLB.</p><p><tables id=\"TABLE-US-00066\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCLSPROK[1:0]</entry><entry morerows=\"0\" valign=\"top\">Input from DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates that a protection violation occured during a DCACHE access. Bit <b>0</b> corresponds to port A while bit <b>1</b> corresponds to port B.</p><p><tables id=\"TABLE-US-00067\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCPAPRHIT</entry><entry morerows=\"0\" valign=\"top\">Input from DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indication that the port A access hit in the predicted way.</p><p><tables id=\"TABLE-US-00068\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCPBPRHIT</entry><entry morerows=\"0\" valign=\"top\">Input from DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indication that the port B access hit in the predicted way.</p><p><tables id=\"TABLE-US-00069\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCUNPAHIT</entry><entry morerows=\"0\" valign=\"top\">Input from DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indication that the port A access hit in one of the unpredicted ways.</p><p><tables id=\"TABLE-US-00070\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCUNPBHIT</entry><entry morerows=\"0\" valign=\"top\">Input from DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indication that the port B access hit in one of the unpredicted ways.</p><p><tables id=\"TABLE-US-00071\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"112PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EFIOPL[1:0]</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EFLAGSAC</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EFLAGSVM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EFLAGSRF</entry><entry morerows=\"0\" valign=\"top\">Inputs from FIROB [EFLAGS]</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Various bits from the EFLAGS register that are needed elsewhere in the processor. AC is the alignment check bit used in preventing unaligned memory accesses if AM is set in CR<b>0</b>. The VM bit is for virtual mode of operation. The RF flag is looked up by the break point detection hardware before reporting any breakpoint matches. If RF is set, breakpoint matches are not reported. IOPL bits are used for input/output protection checking.</p><p><tables id=\"TABLE-US-00072\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">EXCEPTION</entry><entry morerows=\"0\" valign=\"top\">Input from FIROB</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Global exception indication from ROB to cancel all pending instructions and to not return any more results.</p><p><tables id=\"TABLE-US-00073\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IC_CACHED</entry><entry morerows=\"0\" valign=\"top\">Input from CMASTER</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indication that the line the LSSEC/DCACHE requested is in the ICACHE.</p><p><tables id=\"TABLE-US-00074\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"56PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSLS0B[10:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSLS1B[10:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSLS2B[10:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSLS3B[10:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These buses give the load-store section information as to which segment is currently being accessed and types of protection checking that need to be performed. The information is sent to the FU by decode/microcode and the FU sends the information while computing the linear address.</p><p><tables id=\"TABLE-US-00075\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"112PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IRESET</entry><entry morerows=\"0\" valign=\"top\">Input from CLOCKS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Global reset signal. Clears all LDSTBUF entries. Puts the control state machine to idle/reset state.</p><p><tables id=\"TABLE-US-00076\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ITYPE0B[1:0]</entry><entry morerows=\"0\" valign=\"top\">Input from IDECODE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ITYPE1B[1:0]</entry><entry morerows=\"0\" valign=\"top\">Input from IDECODE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ITYPE2B[1:0]</entry><entry morerows=\"0\" valign=\"top\">Input from IDECODE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ITYPE3B[1:0]</entry><entry morerows=\"0\" valign=\"top\">Input from IDECODE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These buses give the type of instructions dispatched.</p><p><tables id=\"TABLE-US-00077\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"70PT\"></colspec><colspec align=\"right\" colname=\"1\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"133PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">00</entry><entry morerows=\"0\" valign=\"top\">NULL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01</entry><entry morerows=\"0\" valign=\"top\">LOAD</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">10</entry><entry morerows=\"0\" valign=\"top\">STORE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11</entry><entry morerows=\"0\" valign=\"top\">LOAD-OP-STORE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p><tables id=\"TABLE-US-00078\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"70PT\"></colspec><colspec align=\"right\" colname=\"1\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"133PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">00</entry><entry morerows=\"0\" valign=\"top\">NULL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01</entry><entry morerows=\"0\" valign=\"top\">LOAD</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">10</entry><entry morerows=\"0\" valign=\"top\">STORE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11</entry><entry morerows=\"0\" valign=\"top\">LOAD-OP-STORE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These buses give the FIROB line number associated with the instructions dispatched.</p><p><tables id=\"TABLE-US-00079\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES0B[31:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES1B[31:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES2B[31:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES3B[31:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ICLK12</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The store data is driven on the result buses by the functional units.</p><p><tables id=\"TABLE-US-00080\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RESLA0B[14:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RESLA1B[14:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RESLA2B[14:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RESLA3B[14:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\">ICLK10</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Linear addresses from the functional units. The result buses are slow. The linear addresses need to come to the LSSEC faster so that it can perform two accesses at the end of the cycle. If needed, the bus width can be reduced to 14 bits\u2014so that the cache indexing can be done. The rest of the bits can be grabbed from the result buses.</p><p><tables id=\"TABLE-US-00081\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT0LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT1LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT2LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT3LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p><b>00</b> Null</p><p><b>01</b> Address is driven by the functional unit on the RESLA bus</p><p><b>10</b> Data is driven on the result bus by the functional unit</p><p>Bit <b>2</b>=1 indicates that the linear address generated is for a load instruction. This is used by the LSSEC to forward linear addresses to the data cache directly to the functional units.</p><p><tables id=\"TABLE-US-00082\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"56PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RTAG0B[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RTAG0B[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RTAG0B[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RTAG0B[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This gives the ROB line number of the instruction that the FU is processing.</p><p><tables id=\"TABLE-US-00083\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">TLB_LS_MISS</entry><entry morerows=\"0\" valign=\"top\">Input from CMASTER</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the TL hit/miss indication from MMU.</p><p><tables id=\"TABLE-US-00084\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WRPTR[5:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FIROB</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This gives the line and entry numbers of the instruction that is ready to get retired.</p><p><tables id=\"TABLE-US-00085\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WRPTR1[5:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FIROB</entry><entry morerows=\"0\" valign=\"top\">ICLK6</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This gives the line and entry numbers of the next store in a FIROB line that can be retired with another store. This aids in sending out two store accesses.</p><p>Outputs</p><p><tables id=\"TABLE-US-00086\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CURCPL[1:0]</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK10</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This indicates the current privilege level. The data cache uses the D, R/W and U/S bits in conjunction with the CURCPL information to determine the protection violations.</p><p><tables id=\"TABLE-US-00087\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LDORST[1:0]</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK12</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indication whether an access is a load or a store.</p><p><tables id=\"TABLE-US-00088\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSBNKCT</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This indicates if there is a bank conflict for the two concurrent data cache accesses to be performed.</p><p><tables id=\"TABLE-US-00089\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSBREAK[1:0]</entry><entry morerows=\"0\" valign=\"top\">Output to FIROB</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Load/Store breakpoint identification from LSSEC. When a load or store breakpoint status is returned, this 2-bit code indicates which of the four debug address registers had the match.</p><p><tables id=\"TABLE-US-00090\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSCNT[2:0]</entry><entry morerows=\"0\" valign=\"top\">Output to IDECODE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ICLK11</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Number of free entries in the LDSTBUF. Decode can make use of this information and dispatch instructions accordingly.</p><p><tables id=\"TABLE-US-00091\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSDCEXC[1:0]</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates the data cache that limit check or protection violation has occured on the current port A [bit<b>0</b>] or port B[bit<b>1</b>] access. If the access is a store, the data cache has to restore the data back into the data cache.</p><p><tables id=\"TABLE-US-00092\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS_FAKE_LOAD</entry><entry morerows=\"0\" valign=\"top\">Output to CMASTER</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS_FAKE_LOCK</entry><entry morerows=\"0\" valign=\"top\">Output to CMASTER</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSINDXCT</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This indicates if there is an index conflict for the two concurrent data cache accesses to be performed.</p><p><tables id=\"TABLE-US-00093\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS_IO_CYCLE</entry><entry morerows=\"0\" valign=\"top\">Output to CMASTER</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSLINAD0[31:2]</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The linear address which would be sent as the port A access to the data cache.</p><p><tables id=\"TABLE-US-00094\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSLINAD1[31:2]</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The linear address which would be sent as the port B access to the data cache.</p><p><tables id=\"TABLE-US-00095\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS_LOCK</entry><entry morerows=\"0\" valign=\"top\">Output of CMASTER</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p><tables id=\"TABLE-US-00096\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS_LOCK</entry><entry morerows=\"0\" valign=\"top\">Output of CMASTER</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal is asserted when the load-store section is performing a data cache read. The read is done speculatively.</p><p><tables id=\"TABLE-US-00097\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS_UNLOCK</entry><entry morerows=\"0\" valign=\"top\">Output to CMASTER</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p><tables id=\"TABLE-US-00098\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS_UNLOCK</entry><entry morerows=\"0\" valign=\"top\">Output to CMASTER</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal is asserted when the load-store section is performing a data cache write. The look up is done speculatively.</p><p>LSPASHFT[<b>1</b>:<b>0</b>] Output to DCACHE ICLK<b>14</b></p><p>This signal gives the shift count to the data cache when performing unaligned accesses within a double word on port A.</p><p><tables id=\"TABLE-US-00099\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"77PT\"></colspec><colspec align=\"right\" colname=\"1\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"126PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">00</entry><entry morerows=\"0\" valign=\"top\">shft by 0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01</entry><entry morerows=\"0\" valign=\"top\">shft by 1 byte</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">10</entry><entry morerows=\"0\" valign=\"top\">shft by 2 bytes</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11</entry><entry morerows=\"0\" valign=\"top\">shft by 3 bytes</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p><tables id=\"TABLE-US-00100\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"77PT\"></colspec><colspec align=\"right\" colname=\"1\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"126PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">00</entry><entry morerows=\"0\" valign=\"top\">shft by 0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01</entry><entry morerows=\"0\" valign=\"top\">shft by 1 byte</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">10</entry><entry morerows=\"0\" valign=\"top\">shft by 2 bytes</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11</entry><entry morerows=\"0\" valign=\"top\">shft by 3 bytes</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal gives the shift count to the data cache when performing unaligned accesses within a double word on port B.</p><p><tables id=\"TABLE-US-00101\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRES0B[31:0]/XLSRES0</entry><entry morerows=\"0\" valign=\"top\">Output to FNCU/FIROB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Result bus returning results for AC<b>0</b>. The intermediate results for load-op-store instructions are indicated by the LSSTAT<b>0</b>B bus.</p><p>XLSRES<b>0</b>B is the inverse of LSRES<b>0</b>B. The differential buses are used for speed.</p><p><tables id=\"TABLE-US-00102\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRES1B[31:0]/ XLSRES1</entry><entry morerows=\"0\" valign=\"top\">Output to FNCU/FIROB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Result bus returning results for AC<b>1</b> The intermediate results for load-op-store instructions are indicated by the LSSTAT<b>1</b>B bus.</p><p>LST_SRB</p><p>LST_LDOP</p><p>LST_LOAD</p><p><tables id=\"TABLE-US-00103\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSSTAT0B[3:0]</entry><entry morerows=\"0\" valign=\"top\">Output to FIROB/FNCU</entry><entry morerows=\"0\" valign=\"top\">ICLK10</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Status of the result returned on LSRES<b>0</b>B. Bit <b>3</b> defines whether a result is intermediate.</p><p><tables id=\"TABLE-US-00104\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSSTAT1B[3:0]</entry><entry morerows=\"0\" valign=\"top\">Output to FIROB/FNCU</entry><entry morerows=\"0\" valign=\"top\">ICLK10</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Status of the result returned on LSRES<b>1</b>B. Bit <b>3</b> defines whether a result is intermediate.</p><p><tables id=\"TABLE-US-00105\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSTAG0B[5:0]</entry><entry morerows=\"0\" valign=\"top\">Output to FNCU/FIROB</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This gives the tag of the instruction returned on LSRES<b>0</b>B.</p><p><tables id=\"TABLE-US-00106\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSTAG1B[5:0]</entry><entry morerows=\"0\" valign=\"top\">Output to FNCU/FIROB</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This gives the tag of the instruction returned on LSRES<b>1</b>B.</p><p><tables id=\"TABLE-US-00107\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSUNALGN[1:0]</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>LSUNALGN[<b>0</b>] indicates that the load/store access to the data cache from port A is unaligned. LSUNALGN[<b>1</b>] indicates the same for port B. An unaligned load can be issued to either port A or port B whereas an unaligned store uses both ports simultaneously.</p><p><tables id=\"TABLE-US-00108\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSUPDATERD</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK10</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates the data cache to update its tag with the new linear address. The data cache also needs to update its valid and status bits.</p><p><tables id=\"TABLE-US-00109\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSWYPRCT</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This indicates if there is an index conflict in the way prediction array for the two concurrent accesses to be performed.</p><p><tables id=\"TABLE-US-00110\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PABYTEN[3:0]</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The byte enables saying which of the bytes in a bank are being accessed.[port A]</p><p><tables id=\"TABLE-US-00111\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PBBYTEN[3:0]</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The byte enables saying which of the bytes in a bank are being accessed.[port B]</p><p><tables id=\"TABLE-US-00112\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SBADAT[31:0]</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus is used to drive the store data for port A. This is a static bus.</p><p><tables id=\"TABLE-US-00113\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SBBDAT[31:0]</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus is used to drive the store data for port B.</p><p><tables id=\"TABLE-US-00114\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"56PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ST_NC</entry><entry morerows=\"0\" valign=\"top\">Output to CMASTER</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates the CMASTER that the store that just got retired is a non-cacheable store.</p><p><tables id=\"TABLE-US-00115\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SUPERV</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CS32X16</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SS32X16</entry><entry morerows=\"0\" valign=\"top\">Outputs to IDECODE</entry><entry morerows=\"0\" valign=\"top\">ICLK10</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p><tables id=\"TABLE-US-00116\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"133PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DADDR[31:2]</entry><entry morerows=\"0\" valign=\"top\">Birdirect. Connects to DCACHE and</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMASTER</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus is used by the load-store section to send linear address to the cache master to check for aliases, initiate reloads and writebacks. The cache master sends the new tag on this bus to the data cache for the case of an alias.</p><p><tables id=\"TABLE-US-00117\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"133PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DATB[63:0]</entry><entry morerows=\"0\" valign=\"top\">Birdirect. Connects to DCACHE and</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMASTER</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This shared bus is used to send data to the CMASTER for non-cacheable and write through stores. The data cache and the cache master use this bus for reloads and writebacks.</p><p><tables id=\"TABLE-US-00118\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"56PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SRBB[31:0]</entry><entry morerows=\"0\" valign=\"top\">Bidirect - SRB</entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bi-directional bus is used by the SRB for moving to and from special registers and accessing arrays.</p><p>Partitioning of L-SSEC</p><p>The load-store section is partitioned into the following blocks:</p><p>1. LDSTDAT\u2014The store data array.</p><p>2. LDSTADR\u2014The array having the address portion of the load-store buffer. It also contains the dependency checking logic for store data forwarding.</p><p>3. LDSTSTAT\u2014Array holding the status information. The status information is looked at mostly by the control unit.</p><p>4. LDSTTAGS\u2014Array containing the instruction tags. This array is updated by the decode unit and the information is needed to update LDSTDAT and LDSTADR blocks and to perform dependency checking.</p><p>5. LSSPREG\u2014Array of segment registers. Further details of this block are provided above.</p><p>6. LSCTL\u2014The load-store section control block.</p><p>A block diagram of this partitioning is shown as FIG. 50</p><p>Layout of LSSEC</p><p>FIG. 51 shows a possible layout configuration of the LSSEC. LDSTDAT, LDSTADR, LDSTTAGS and LDSTSTAT constitute the unified load-store buffer (LDSTBUF).</p><p>LDSTDAT (The Array Containing the Store Data)</p><p>This array contains the store data. There are eight entries of 32-bits each. The sources of updates to this array are the functional units. The array looks at the LATYPE signal which indicates whether address or data is driven on the result bus. The control section indicates which of the entries need to be updated (LSUPD[<b>15</b>:<b>0</b>]). LSRDDAT<b>0</b>[<b>15</b>:<b>0</b>] and LSRDDAT<b>1</b>[<b>15</b>:<b>0</b>] indicate which of the two entries go out as accesses for stores. LSFWD<b>0</b>[<b>15</b>:<b>0</b>] LSFWD<b>1</b>[<b>15</b>:<b>0</b>] indicate as to which entries need to get forwarded over to LSRES<b>0</b> and LSRES<b>1</b> buses.</p><p>Signal List</p><p><tables id=\"TABLE-US-00119\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"119PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES0B[31:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES1B[31:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES2B[31:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES3B[31:0]</entry><entry morerows=\"0\" valign=\"top\">Inputs from Functional Units</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The result buses from the functional units.</p><p><tables id=\"TABLE-US-00120\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT0LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT1LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT2LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT3LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p><b>00</b> Null</p><p><b>01</b> Address is driven by the functional unit on the RESLA bus</p><p><b>10</b> Data is driven on the result bus by the functional unit</p><p>Bit <b>2</b>=1 indicates that the linear address generated is for a load instruction. This is used by the LSSEC to forward linear addresses to the data cache directly to the functional units.</p><p><tables id=\"TABLE-US-00121\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS0UPD[3:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS1UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS2UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS3UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS4UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS5UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS6UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS7UPD[3:0]</entry><entry morerows=\"0\" valign=\"top\">Inputs from LDSTTAGS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The update signals after comparing the tags.</p><p><tables id=\"TABLE-US-00122\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS0RDDAT[7:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries must go out as AC<b>0</b> for stores.</p><p><tables id=\"TABLE-US-00123\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS1RDDAT[7:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries must go out as AC<b>1</b> for stores.</p><p><tables id=\"TABLE-US-00124\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS0FWD[7:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LDSTADR</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries need to be forwarded on to LSRES<b>0</b>.</p><p><tables id=\"TABLE-US-00125\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS1FWD[7:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LDSTADR</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries need to be forwarded on to LSRES<b>1</b>.</p><p><tables id=\"TABLE-US-00126\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"119PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRES0[31:0], XLSRES0[31:0]</entry><entry morerows=\"0\" valign=\"top\">Output to FUn/FIROB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Load-store result bus.</p><p><tables id=\"TABLE-US-00127\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"119PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRES1[31:0], XLSRES1[31:0]</entry><entry morerows=\"0\" valign=\"top\">Output to FUn/FIROB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Load-store result bus.</p><p><tables id=\"TABLE-US-00128\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHF1ENT[7:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHF2ENT[7:0]</entry><entry morerows=\"0\" valign=\"top\">Inputs from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Shift signals to shift the entries down.</p><p>shflent xor SHF<b>2</b>ENT=1\u2014shift entry by 1</p><p>shflent and SHF<b>2</b>ENT=1\u2014shift entry by 2</p><p>DATB[<b>63</b>:<b>0</b>] Birdirect. Connects to DCACHE and CMASTER</p><p>This shared bus is used to send data to the CMASTER for non-cacheable and write through stores. The data cache and the cache master use this bus for reloads and writebacks.</p><p><tables id=\"TABLE-US-00129\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SBADAT[31:0]</entry><entry morerows=\"0\" valign=\"top\">Output to the data cache</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus is used to drive the store data for port A. This is a static bus.</p><p><tables id=\"TABLE-US-00130\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SBBDAT[31:0]</entry><entry morerows=\"0\" valign=\"top\">Output to the data cache</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus is used to drive the store data for port B.</p><p>LDSTADR (The Array Containing the Load-store Address)</p><p>This array of eight entries contains the address for the load-store accesses. The update sources for the array are the functional units. The functional units send the bits[<b>14</b>:<b>0</b>] on the RESLAn buses and the entire address on the RESnB buses. The array gets updated via the RESnB buses. The RESLA buses are much faster than the result buses and are used to send out the index for the data cache accesses as soon as possible. Also, the LSSEC needs to determine bank conflicts and unaligned accesses. This again needs the LSBs of the address available to the LSSEC early.</p><p>This block also contains the logic for dependency checking against stores in the buffer and sending the forwarding signals to LDSTDAT.</p><p>Signal List</p><p><tables id=\"TABLE-US-00131\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"119PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES0B[31:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES1B[31:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES2B[31:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES3B[31:0]</entry><entry morerows=\"0\" valign=\"top\">Inputs from Functional Units</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The result buses from the functional units.</p><p><tables id=\"TABLE-US-00132\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT0LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT1LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT2LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT3LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p><b>00</b> Null</p><p><b>01</b> Address is driven by the functional unit on the RESLA bus</p><p><b>10</b> Data is driven on the result bus by the functional unit</p><p>Bit <b>2</b>=1 indicates that the linear address generated is for a load instruction. This is used by the LSSEC to forward linear addresses to the data cache directly to the functional units.</p><p><tables id=\"TABLE-US-00133\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS0UPD[3:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS1UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS2UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS3UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS4UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS5UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS6UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS7UPD[3:0]</entry><entry morerows=\"0\" valign=\"top\">Inputs from LDSTTAGS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The update signals after comparing the tags.</p><p><tables id=\"TABLE-US-00134\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSLINAD0[31:0]</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The address for access AC<b>0</b>.</p><p><tables id=\"TABLE-US-00135\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSLINAD1[31:0]</entry><entry morerows=\"0\" valign=\"top\">Output to DCACHE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The address for access AC<b>1</b>.</p><p><tables id=\"TABLE-US-00136\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHF1ENT[7:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHF2ENT[7:0]</entry><entry morerows=\"0\" valign=\"top\">Inputs from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Shift signals to shift the entries down.</p><p>shflent xor SHF<b>2</b>ENT=1\u2014shift entry by 1</p><p>shflent and SHF<b>2</b>ENT=1\u2014shift entry by 2</p><p><tables id=\"TABLE-US-00137\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS0RDDAT[7:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries must go out as AC<b>0</b> for stores.</p><p><tables id=\"TABLE-US-00138\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS1RDDAT[7:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries must go out as AC<b>1</b> for stores.</p><p><tables id=\"TABLE-US-00139\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS0FWD[7:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LDSTADR</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries need to be forwarded on to LSRES<b>0</b>.</p><p><tables id=\"TABLE-US-00140\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS1FWD[7:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LDSTADR</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries need to be forwarded on to LSRES<b>1</b>.</p><p>LDSTSTAT (The Array Containing the Control/status Information)</p><p>This array is also eight entries deep and contains the control/status information of the loads and stores in the LSSEC. The update source for this array is the load-store section itself.</p><p>Signal List</p><p><tables id=\"TABLE-US-00141\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL0ENT[2:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL1ENT[2:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL2ENT[2:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL3ENT[2:0]</entry><entry morerows=\"0\" valign=\"top\">Inputs from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These indicate what entries can be allocated for the next dispatch.</p><p><tables id=\"TABLE-US-00142\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL0V[3:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL1V[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL2V[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL3V[3:0]</entry><entry morerows=\"0\" valign=\"top\">Inputs from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These signals are associated with ALLnENT and indicate which of the four dispatch positions they correspond to.</p><p><tables id=\"TABLE-US-00143\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SET0MISS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the M bit for the entry indicated by SET<b>0</b>MISS if a port A access missed.</p><p><tables id=\"TABLE-US-00144\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SET1MISS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the M bit for the entry indicated by SET<b>1</b>MISS if a port B access missed.</p><p><tables id=\"TABLE-US-00145\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SETM2[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Based on this, the M<b>2</b> bit for an entry in the array is set.</p><p><tables id=\"TABLE-US-00146\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SET0DEP[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the D (dependent) bit.</p><p><tables id=\"TABLE-US-00147\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SET1DEP[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the D (dependent) bit.</p><p><tables id=\"TABLE-US-00148\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SET0SER[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the S (Serialize) bit.</p><p><tables id=\"TABLE-US-00149\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SET1SER[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the S (Serialize) bit.</p><p><tables id=\"TABLE-US-00150\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LDAC[7:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries have valid loads that can go out as accesses.</p><p><tables id=\"TABLE-US-00151\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSAC[1:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries have valid stores that can go out as accesses.</p><p><tables id=\"TABLE-US-00152\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CLRDEP</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Clear the D bit for all the entries.</p><p><tables id=\"TABLE-US-00153\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CLRMISS1</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Clear the M bit for all the entries.</p><p><tables id=\"TABLE-US-00154\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SETNF</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the NF bit for all the stores in the buffer. This will prevent forwarding store data for dependent loads.</p><p><tables id=\"TABLE-US-00155\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHF1ENT[7:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHF2ENT[7:0]</entry><entry morerows=\"0\" valign=\"top\">Inputs from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Shift signals to shift the entries down.</p><p>shflent xor SHF<b>2</b>ENT=1\u2014shift entry by 1</p><p>shflent and SHF<b>2</b>ENT=1\u2014shift entry by 2</p><p>LDSTTAGS (Array Containing the FIROB Tags)</p><p>This 8-entry array contains the FIROB tags for the instructions in the LSSEC. The tags are looked up by the control unit during access prioritization. The tags in the entries are compared against the tags from the functional units when updating the address and data arrays. The tags information is also needed when performing dependency checking.</p><p>Signal List</p><p><tables id=\"TABLE-US-00156\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RLINE[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FIROB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These buses give the FIROB line number associated with the instructions dispatched.</p><p><tables id=\"TABLE-US-00157\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RTAG0B[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FUn</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RTAG0B[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FUn</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RTAG0B[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FUn</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RTAG0B[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FUn</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This gives the ROB line number of the instruction that the FU is processing.</p><p><tables id=\"TABLE-US-00158\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"133PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS0UPD[3:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS1UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS2UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS3UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS4UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS5UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS6UPD[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS7UPD[3:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTDAT, LDSTADR and</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LDSTSTAT.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The update signals after comparing the tags.</p><p><tables id=\"TABLE-US-00159\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSTAG0B[5:0]</entry><entry morerows=\"0\" valign=\"top\">Output to FNCU/FIROB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This gives the tag of the instruction returned on LSRES<b>0</b>B.</p><p><tables id=\"TABLE-US-00160\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSTAG1B[5:0]</entry><entry morerows=\"0\" valign=\"top\">Output to FNCU/FIROB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This gives the tag of the instruction returned on LSRES<b>1</b>B.</p><p>LSORDDAT[<b>7</b>:<b>0</b>] Input from LSCTL</p><p>Indicates which of the entries must go out as AC<b>0</b> for stores.</p><p><tables id=\"TABLE-US-00161\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS1RDDAT[7:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries must go out as AC<b>1</b> for stores.</p><p><tables id=\"TABLE-US-00162\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS0FWD[7:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LDSTADR</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries need to be forwarded on to LSRES<b>0</b>.</p><p><tables id=\"TABLE-US-00163\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LS1FWD[7:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LDSTADR</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries need to be forwarded on to LSRES<b>1</b>.</p><p><tables id=\"TABLE-US-00164\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL0ENT[2:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL1ENT[2:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL2ENT[2:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL3ENT[2:0]</entry><entry morerows=\"0\" valign=\"top\">Inputs from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These indicate what entries can be allocated for the next dispatch.</p><p><tables id=\"TABLE-US-00165\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL0V[3:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL1V[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL2V[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL3V[3:0]</entry><entry morerows=\"0\" valign=\"top\">Inputs from LSCTL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These signals are associated with ALLnENT and indicate which of the four dispatch positions they correspond to.</p><p><tables id=\"TABLE-US-00166\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WRPTR</entry><entry morerows=\"0\" valign=\"top\">Input from FIROB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the indication of head of the ROB.</p><p><tables id=\"TABLE-US-00167\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WRPTR1</entry><entry morerows=\"0\" valign=\"top\">Input from FIROB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This indicates the ROB position of the next non-speculative store instruction</p><p>LSCTL (The Control Block for LSSEC)</p><p>Signal List</p><p><tables id=\"TABLE-US-00168\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">LS0RDDAT[2:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTDAT/LDSTADDR/LDSTTAGS</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries must go out as AC<b>0</b> for stores.</p><p><tables id=\"TABLE-US-00169\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"154PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">LS1RDDAT[2:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTDAT/LDSTADDR/LDSTTAGS</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries must go out as AC<b>1</b> for stores.</p><p><tables id=\"TABLE-US-00170\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"133PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL0ENT[2:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL1ENT[2:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL2ENT[2:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL3ENT[2:0]</entry><entry morerows=\"0\" valign=\"top\">Outputs to LDSTTAGS/LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These indicate what entries can be allocated for the next dispatch.</p><p><tables id=\"TABLE-US-00171\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"133PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL0V[3:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL1V[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL2V[3:0]</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ALL3V[3:0]</entry><entry morerows=\"0\" valign=\"top\">Outputs to LDSTTAGS/LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These signals are associated with ALLnENT and indicate which of the four dispatch positions they correspond to.</p><p><tables id=\"TABLE-US-00172\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SET0MISS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the M bit for the entry indicated by SET<b>0</b>MISS if a port A access missed.</p><p><tables id=\"TABLE-US-00173\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SET1MISS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the M bit for the entry indicated by SET<b>1</b>MISS if a port B access missed.</p><p><tables id=\"TABLE-US-00174\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SETM2[2:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Based on this, the M<b>2</b> bit for an entry in the array is set.</p><p><tables id=\"TABLE-US-00175\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SET0DEP[2:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the D (dependent) bit.</p><p><tables id=\"TABLE-US-00176\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SET1DEP[2:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the D (dependent) bit.</p><p><tables id=\"TABLE-US-00177\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SET0SER[2:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the S (Serialize) bit.</p><p><tables id=\"TABLE-US-00178\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SET1SER[2:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the S (Serialize) bit.</p><p><tables id=\"TABLE-US-00179\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"112PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LDAC[7:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries have valid loads that can go out as accesses.</p><p><tables id=\"TABLE-US-00180\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"112PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSAC[1:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates which of the entries have valid stores that can go out as accesses.</p><p><tables id=\"TABLE-US-00181\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CLRDEP</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Clear the D bit for all the entries.</p><p><tables id=\"TABLE-US-00182\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CLRMISS1</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Clear the M bit for all the entries.</p><p><tables id=\"TABLE-US-00183\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"112PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SETNF</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Set the NF bit for all the stores in the buffer. This will prevent forwarding store data for dependent loads.</p><p><tables id=\"TABLE-US-00184\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHF1ENT[7:0]</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHF2ENT[7:0]</entry><entry morerows=\"0\" valign=\"top\">Output to</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"175PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LDSTDAT/LDSTADDR/LDSTTAGS/LDSTSTAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Shift signals to shift the entries down.</p><p>shflent xor SHF<b>2</b>ENT=1\u2014shift entry by 1</p><p>shflent and SHF<b>2</b>ENT=1\u2014shift entry by 2</p><p>LSSPREG (The Load-store Special Registers)</p><p>Signal List</p><p><tables id=\"TABLE-US-00185\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"119PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRES0[31:0], XLSRES0[31:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LDSTDAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Load-store result bus.</p><p><tables id=\"TABLE-US-00186\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"119PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRES1[31:0], XLSRES1[31:0]</entry><entry morerows=\"0\" valign=\"top\">Input from LDSTDAT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Load-store result bus.</p><p><tables id=\"TABLE-US-00187\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"112PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IRESET</entry><entry morerows=\"0\" valign=\"top\">Input from CLOCKS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Global reset signal. Clears all LDSTBUF entries. Puts the control state machine to idle/reset state.</p><p><tables id=\"TABLE-US-00188\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"56PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSLS0B[10:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSLS1B[10:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSLS2B[10:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSLS3B[10:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These buses give the load-store section information as to which segment is currently being accessed and types of protection checking that need to be performed. The information is sent to the FU by decode/microcode and the FU sends the information while computing the linear address.</p><p><tables id=\"TABLE-US-00189\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ITYPE0B[1:0]</entry><entry morerows=\"0\" valign=\"top\">Input from IDECODE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ITYPE1B[1:0]</entry><entry morerows=\"0\" valign=\"top\">Input from IDECODE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ITYFE2B[1:0]</entry><entry morerows=\"0\" valign=\"top\">Input from IDECODE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ITYPE3B[1:0]</entry><entry morerows=\"0\" valign=\"top\">Input from IDECODE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These buses give the type of instructions dispatched.</p><p><tables id=\"TABLE-US-00190\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"70PT\"></colspec><colspec align=\"right\" colname=\"1\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"133PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">00</entry><entry morerows=\"0\" valign=\"top\">NULL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01</entry><entry morerows=\"0\" valign=\"top\">LOAD</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">10</entry><entry morerows=\"0\" valign=\"top\">STORE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11</entry><entry morerows=\"0\" valign=\"top\">LOAD-OP-STORE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p><tables id=\"TABLE-US-00191\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"70PT\"></colspec><colspec align=\"right\" colname=\"1\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"133PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">00</entry><entry morerows=\"0\" valign=\"top\">NULL</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01</entry><entry morerows=\"0\" valign=\"top\">LOAD</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">10</entry><entry morerows=\"0\" valign=\"top\">STORE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11</entry><entry morerows=\"0\" valign=\"top\">LOAD-OP-STORE</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These buses give the FIROB line number associated with the instructions dispatched.</p><p><tables id=\"TABLE-US-00192\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRLMODE</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates that the processor is in real mode.</p><p><tables id=\"TABLE-US-00193\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSPRMODE</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates that the processor is in protected mode.</p><p><tables id=\"TABLE-US-00194\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSEFLAGSVM</entry><entry morerows=\"0\" valign=\"top\">Input from LSCTL</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates that the processor is in V86 mode.</p><p><tables id=\"TABLE-US-00195\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES0B[31:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES1B[31:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES2B[31:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RES3B[31:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ICLK12</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The store data is driven on the result buses by the functional units.</p><p><tables id=\"TABLE-US-00196\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RESLA0B[14:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RESLA1B[14:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RESLA2B[14:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RESLA3B[14:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\">ICLK10</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Linear addresses from the functional units. The result buses are slow. The linear addresses need to come to the LSSEC faster so that it can perform two accesses at the end of the cycle. If needed, the bus width can be reduced to 14 bits\u2014so that the cache indexing can be done. The rest of the bits can be grabbed from the result buses.</p><p><tables id=\"TABLE-US-00197\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT0LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT1LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT2LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSTAT3LS[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>00 Null</p><p>01 Address is driven by the functional unit on the RESLA bus</p><p>10 Data is driven on the result bus by the functional unit</p><p>Bit <b>2</b>=1 indicates that the linear address generated is for a load instruction. This is used by the LSSEC to forward linear addresses to the data cache directly to the functional units.</p><p><tables id=\"TABLE-US-00198\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"56PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RTAG0B[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RTAG0B[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RTAG0B[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RTAG0B[2:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FU</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This gives the ROB line number of the instruction that the FU is processing.</p><p><tables id=\"TABLE-US-00199\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WRPTR[5:0]</entry><entry morerows=\"0\" valign=\"top\">Input from FIROB</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DTBRKPT</entry><entry morerows=\"0\" valign=\"top\">Output to LSCTL</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DBGMTCH</entry><entry morerows=\"0\" valign=\"top\">Output to LSCTL</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSLMTCHK[1:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LSCTL</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRDAT[31:0]</entry><entry morerows=\"0\" valign=\"top\">Output to LDSTDAT</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Dcache</p><p>Overview</p><p>The data cache (henceforth referred to as dcache) on Processor <b>500</b> is a 16 KB linearly addressed, 8-way set associative cache. In order to facilitate single cycle dcache access, a way prediction scheme is used. This section discusses a 16 KB dcache.</p><p>Some of the other salient features of this dcache are 8-way interleaving, two concurrent accesses per cycle if they are not to the same bank, random replacement policy and one cycle penalty for unaligned loads and unaligned stores.</p><p>Dcache Organization</p><p>The dcache on Processor <b>500</b> is a 16 KB linearly addressed cache implementing the MESI protocol. The line size is <b>32</b> bytes and the arrays are organized in a 8-way set associative structure with 8 banks. The 8 banks allow two concurrent accesses per cycle as long as the two accesses are not to the same bank. Bits <b>4</b>:<b>2</b> of the two linear addresses from the Processor <b>500</b> core are used for bank selection and identifying bank conflicts. Due to the interleaving, the data arrays are effectively dual ported and do not need to be implemented as actual dual ported structures. FIG. 52 shows a diagram of the dcache organization.</p><p>The dcache is partitioned into three functionally separate arrays. They are the tag array, data array and the way prediction array. The tag arrays are physically dual-ported. Since it is a 16 KB dcache with a 32 byte line size, there are 64 tags per way. Bits <b>10</b>:<b>5</b> of the linear address are used to index the tag array with bits <b>31</b>:<b>11</b> used for comparison to determine hit or miss.</p><p>The data arrays are organized as 8 set arrays in each of the 8 banks. In order to facilitate 8/16 bit accesses as well as unaligned accesses, the LSSEC will generate byte enables for each of the two accesses. Bits <b>10</b>:<b>5</b> of the linear address are used to index the data arrays. The two ports that allow two concurrent accesses per clock cycle will henceforth be called Port A and Port B. The actions supported on Port A are: aligned loads/stores, unaligned loads/stores, reloads, SRB accesses, line reads(both snoop and non-snoop) and line invalidations. The actions supported on Port B are aligned/unaligned loads, unaligned stores(since a unaligned store uses both ports) and snoop invalidations.</p><p>Way prediction will allow the Processor <b>500</b> dcache Lo attain single cycle access at our targeted clock speeds while using a set-associative cache array. Single cycle dcache access is feasible only when the predicted way hits in the tag compare. If a hit occurs in any of the unpredicted ways then there is a one cycle penalty which would be equivalent to a replacement cache performance. However, unlike a replacement cache there will be no swap penalty. The way prediction array entry is updated with the new predicted value. Bits <b>13</b>:<b>5</b> of the linear address are used to index the way prediction array. Like the tag array, the way prediction array is also dual ported. The details of the way prediction scheme are described below.</p><p>Tag Array</p><p>The tag array is organized into an 8-way set associative structure. It is dual ported so as to allow two concurrent accesses per cycle and is laid out as one 64 rows\u00d7200 column array. This is optimal since the speed target does not allow a contiguous array larger than 64 rows. Bits <b>10</b>:<b>5</b> of the port linear address will be used to index the array. This will be true for both port A and B accesses. A tag array entry per way consisting of 25 bits is as shown in FIG. <b>53</b>.</p><p>A description of the various fields is as follows:</p><p>Tag is bits (<b>31</b>:<b>11</b>) of the linear address.</p><p>D is the dirty bit that indicates that the line has been previously modified. This information is used during a store by the LSSEC when the TLB is accessed to determine whether the corresponding dirty bit in the page table entry is correctly set. If the dirty bit in the page table entry is not set then an exception must occur to write the dirty bit in the external page table entries so that the page gets written back to external memory.</p><p>U/S* is the user/supervisor bit that indicates the access privilege of the dcache line. If this bit is 0 then user level programs cannot access this dcache entry. The supervisor can access any line regardless of this bit.</p><p>R/W* indicates the read/write privilege for user level programs. Supervisor level programs ignore this bit when the WP bit in CR<b>0</b> register is 0. If the WP bit is set to 1 then supervisor level programs will use the R/W* bit. The dcache does the protection checking and sends an exception to the LSSEC if a violation occurs.</p><p>V is the linear valid bit. This bit is 0 on reset and is set to 1 when a new line gets loaded into the dcache. This bit is also reset to 0 on invalidation.</p><p>The tag and the protection bits (D, U/S* and R/W*) are always accessed together. The V bit can be accessed independently for invalidations and resets.</p><p>Data Array</p><p>The data array is effectively dual ported due to banking. Each bank is physically laid out as one 64 row\u00d7256 column array. This again is optimal since the speed target for Processor <b>500</b> does not allow a contiguous array larger than 64 rows. During a clock cycle (regular load/store accesses), at most two banks can be accessed. The banks are selected by the bank select bits <b>4</b>:<b>2</b> of the port addresses. Bits <b>10</b>:<b>5</b> of the port linear address will be used to index each selected bank. The data array is byte addressable. Two sets of byte enables are generated per clock corresponding to the two banks being accessed. The byte enables are generated using the operand size information as well as bits <b>1</b>:<b>0</b> of the linear address. The byte enables are critical to doing stores in a single cycle for aligned accesses since stores are done as pure writes. Unaligned accesses and 8/16 bit accesses use byte enable information in the same fashion as well. All 8 banks are accessed on port A only during a reload or during a writeback. At this time (i.e. during reload or writeback) port B is unused.</p><p>Way Prediction Array</p><p>The way prediction array is a 512 rows\u00d78 columns direct mapped cache that is physically organized into eight 64\u00d78 arrays. Each column corresponds to one of the eight ways of the data and tag arrays as shown in FIG. <b>54</b>. The way prediction array is implemented as a dual ported array to allow two concurrent accesses per cycle. It is indexed by bits <b>13</b>:<b>5</b> of the port A and B linear addresses. Note that unlike the data and tag array the index here is 9 bits wide. Therefore for each tag/data array index, there are 8 possible indexes in the way predict array( provided by extra index bits <b>13</b>:<b>11</b>). It is noted here that greater the mapping( i.e. more index bits for way prediction array), the more accurate the way prediction. This mapping was determined to be optimal based on performance/implementation tradeoffs. Each of the eight arrays will be addressed by bits <b>10</b>:<b>5</b> of the linear address. Bits <b>13</b>:<b>11</b> will select the output of one of the eight arrays.</p><p>Aligned Loads</p><p>There are two cases to be considered here.</p><p>(a) 32 bit aligned loads and</p><p>(b) 8/16 bit aligned loads.</p><p>FIG. 56 shows a block diagram of the hardware to do aligned loads for both these cases.</p><p>The dcache receives the linear address before the end of the 7th XICLK. The LSSEC also sends the index conflict and way conflict signals before the end of the 7th XICLK. At the beginning of the 8th XICLK, the dcache latches these signals, does the row decode and also the bank selection. The index conflict and way conflict signals are used to fire only one port of the dual ported tag and way prediction arrays. If a bank conflict occurs the LSSEC serializes the two accesses. Therefore, for that clock cycle, only one dcache access will be issued on port A. The LSSEC should also in the 8th XICLK send the shift code that is based on the operand size and bits <b>1</b>:<b>0</b> of the port linear address and also the byte enables. For the 32 bit load, the shift code is zero. The data from the predicted way will be driven on the LSRESn (n=0 or 1) and XLSRESn buses differentially towards the end of the 8th XICLK. The appropriate functional unit latches this data at the beginning of the 9th XICLK and uses it. The dcache meanwhile computes the hit/miss indication for the 8 ways and sends that indication to the functional unit and LSSEC. If there was a hit in the predicted way, then there is single cycle dcache access and the dcache can proceed with the next pending access. If there was a miss in the predicted way and a hit in one of the unpredicted ways, the LSSEC will cancel the next access that it had initiated on that port and drive the previous tag again on the LSTAGn bus. The functional unit will then cancel the operation and wait for data to be driven to it again in the 9th XICLK. The data from one of the unpredicted ways is driven to the functional unit during the 9th XICLK and is latched at the beginning of the 10th XICLK. Therefore, there is a one cycle penalty when there is a miss in the predicted way and a hit in one of the unpredicted ways. Also, the way prediction array will be updated with the new prediction in the 9th XICLK. FIG. 55 shows a timing diagram of the above stated actions.</p><p>For the 8/16 bit loads that are contained within one doubleword, the flow is the same except that the shift logic that is present before the bus driver is utilized. This logic is present for the 32 bit loads also, but it is a shift by 0. This shift logic can be implemented using transmission gate muxes. For the 8 bit data, we can have either a shift by 0,8,16 or 24. For 16 bit data, it is a shift by 0, 8 or 16. The shift will be determined by the operand size information and bits <b>1</b>:<b>0</b> of the port linear address. Both of these controls should be known at the beginning of the 8th XICLK and the muxes can be setup before the data is available.</p><p>If there is a miss on all the ways, the LSSEC marks that access as a miss and proceeds with the next dcache access if one is pending. The LSSEC also sends the address of the missed access to the CMASTER to check for an alias. If no aliasing has occurred, the LSSEC waits until the missed access is no longer speculative and then will initiate a reload sequence.</p><p>Aligned Stores</p><p>Stores on Processor <b>500</b> are done as pure writes. The dcache on Processor <b>500</b> supports byte write capability which allows pure writes. The byte enables used to do this are generated based on the operand size and bits <b>1</b>:<b>0</b> of the port linear address. Processor <b>500</b> dcache supports single cycle dcache access for stores if the store is to the predicted way. FIG. 57 is timing sequence of the actions that take place during the store.</p><p>The sequence of actions until the dcache access are similar for both the load and store accesses. When the senseamps are turned on, the arrays are isolated from the senseamp to prevent the bit lines from being pulled down. Thus, the senseamp provides an automatic latch structure to hold the read data. When the way prediction is available, the write strobe for the predicted way is turned on thereby writing the store data speculatively into the predicted way. At the beginning of the 9th XICLK, the hit/miss indications are generated and protection violations detected. If there was a hit to the predicted way and no protection violation, then a single cycle dcache store access has been performed. If there is a miss in the predicted way but a hit in one of the unpredicted ways and no protection violations, then in the 9th XICLK the store data is written into the way that hit and the predicted way is restored with the data that was read out in the 8th XICLK. Also the way prediction array is updated with the new prediction. If there is a protection violation, then the predicted way is restored with the data that was read out in the 8th XICLK. The protection violation information is sent to LSSEC to generate an exception. The access is thus terminated and the dcache can proceed with the next pending access on the following clock cycle.</p><p>For 8/16 bit stores, the above actions still hold except that depending on the byte enables that are active, only enabled bytes are updated with the new store data.</p><p>Unaligned Loads</p><p>Unaligned loads on Processor <b>500</b> require at least a two cycle dcache access. FIG. 58 illustrates the sequence of actions for unaligned loads when both accesses hit in the predicted way.</p><p>In the 8th XICLK, the LSSEC will access the dcache with the current address. During this time, the LSSEC also increments the address by 4 to set up for the second half of the unaligned access. The dcache latches the first half of the unaligned load at the beginning of the 9th XICLK and does the shift necessary to set up the data to drive on the appropriate bits of the LSRESn and XLSRESn buses. During the 9th XICLK, the dcache reads the second half of the unaligned load. The actions taken are exactly the same as for a 8/16 bit aligned load. The two halves of the data will be driven on the LSRESn and XLSRESn buses at the end of the 9th XICLK. Note that in this process, the byte enables are used to select the appropriate bytes from the two doublewords that have been read out.</p><p>There are three more cases that are considered:</p><p>(a) Unpredicted way hit in first access\u2014Predicted way hit in second access. FIG. 59 shows the timing diagram for handling this case. This case occurs both when the unaligned load is contained within a line and when the load crosses a line boundary. As can be seen from FIG. 59, this case requires 3 clock cycles.</p><p>(b) Predicted way hit in first access\u2014Unpredicted way hit in second access. FIG. 60 shows the timing diagram for handling this case. This case occurs when the unaligned load crosses a line boundary. This is because if the access were completely contained within the same line, there would not be a unpredicted way hit in the second access. This case also requires 3 clock cycles.</p><p>(c) Unpredicted way hit in first access\u2014Unpredicted way hit in second access. This case will also occur when the unaligned load crosses the line boundary. This case will require 4 clock cycles to complete. FIG. 61 shows the timing diagram for this case.</p><p>The cases covered so far only involved hits in the dcache. There are two cases of misses: Miss in first access and miss in second access. When there is a miss during the first access, the LSSEC will mark that load as a miss. The LSSEC will then process the miss as described below. If there is a miss on the second half of the unaligned load, the first half of the unaligned load that has been read out will be discarded. This case would occur when the load crosses a line boundary. The LSSEC sets the M<b>2</b> bit in the LSSEC buffer and then processes the miss as described below.</p><p>Unaligned Stores</p><p>Unaligned stores are executed in a slightly different fashion from unaligned loads. For unaligned stores, the incremented address is generated in the 8th XICLK. In the 9th XICLK, port A is accessed with the original address and port B with the incremented address. The byte enables for both the ports are used to write the appropriate bytes of the two doublewords. If there is a miss on any one of the ports then the old data that is read out on the other port is restored in the next cycle. The LSSEC then processes the store miss as described below. FIG. 62 shows a timing diagram when both store accesses hit in the predicted way.</p><p>The other two cases that are considered are:</p><p>(a) At least one of the two accesses misses in the predicted way but hits in an unpredicted way. FIG. 63 shows the timing diagram for this case</p><p>(b) There is a miss in all the ways for at least one access. FIG. 64 shows the timing diagram for each case.</p><p>Processing a Load Miss</p><p>On a load miss, the LSSEC sends the address on the DADDR bus to the CMASTER to check for aliasing. If it is a speculative request, then LSSEC does not assert the ROB_REL signal. The CMASTER in this case checks for an alias. If aliasing has occurred, the CMASTER sends the CM_DC_ALIAS signal back to LSSEC and dcache and also drive the way to be replaced to the dcache on the CM_REPCOL bus and the protection information on PAGE_PROT(<b>2</b>:<b>0</b>). The LSSEC, upon receiving the aliasing indication, drives the LSLINADO bus with the tag and index on the following cycle and also assert the LSUPDATERD signal. This causes the new tag and protection bits to be written in the selected way on the next cycle. The valid bit for that way also set. See FIG. 65 for timing diagram.</p><p>If there is a miss in the physical tags, the CM_MISS is asserted. The LSSEC then waits until the dcache request that caused the miss is no longer speculative and then again sends the address on DADDR bus. The ROB_REL signal is now asserted. The CMASTER latches the address and checks for aliasing again. If no aliasing has occurred, it will initiate the bus cycle and fetch the line in four packets of 64 bits each (external data bus=64 bits). The CMASTER can transfer each packet to the dcache on the DATB bus as soon as it is received. The dcache will latch each packet into the appropriate location in a 256 bit buffer(BUF<b>1</b>). The dcache on receiving the first packet asserts DCFSTPCK to the LSSEC. The LSSEC, on the next cycle, sends the reload address(tag and index) to dcache. After this point the LSSEC does not issue any more requests to dcache. The CMASTER also selects the way in the dcache to be replaced and sends that selection to the dcache along with the last packet on the CM_REPCOL(<b>2</b>:<b>0</b>) bus. The last packet will be flagged by the CMASTER by the assertion of CM2LS. The replacement policy is pseudo-random and is determined in the CMASTER. After all 4 packets have been received, the dcache asserts the DCBUSY signal and then initiates the line swap. The dcache reads the line to be replaced into another 256 bit buffer(BUF<b>2</b>) and writes the line in BUF<b>1</b> into that way. This swap can be done in one clock cycle. Note that this is a store to all eight banks and hence there is no port B access. The dcache will also update the tag and way prediction arrays. The way into which the new line was put will be the new way prediction for that index. See FIG. 66 for a timing diagram for reloads. If the line that was replaced was dirty, the CMASTER requests the dcache to send the line from BUF<b>2</b>. The dcache sends the line in four packets of 64 bits each on the DATB bus. The CMASTER then initiates an external write cycle to send each of these packets as they are received.</p><p>Processing a Store Miss</p><p>The Processor <b>500</b> dcache implements a no-write allocate policy for store misses. A no write allocate policy will still require the CMASTER to check for aliasing using the same protocol described for load misses. If no aliasing occurred, the LSSEC initiates a memory write cycle through the CMASTER. The data is sent to the CMASTER from the LSSEC on the DATB bus. The dcache is not involved in this transaction.</p><p>Non-cacheable Accesses</p><p>Non-cacheable accesses are detected in three ways: The first is when the PCD bit is set. The second is through the sampling of KEN# inactive during the same clock that the first BRDY# is sampled active. The third is when the CD and NW bits in the CR<b>0</b> register are programmed as follows CD=1, NW=0. The actions when a miss occurs are the same for all these three cases.</p><p>For a miss (load or store), the LSSEC still sends the address to the CMASTER to check for aliasing. If aliasing has occurred then the procedure for handling of non-cacheable accesses is the same as for cacheable accesses (see above). For a load miss, the LSSEC requests the CMASTER to initiate an external memory read cycle. The CMASTER reads the requested doubleword(or less if a byte or word is requested) and sends it to the dcache over the DATB bus. This data is latched in the dcache. The dcache will inform the LSSEC that the data has been transferred. The LSSEC then drives the tag for that load on the LSTAG<b>0</b> bus and also commands the dcache to route/mux the data so as to drive the appropriate bits of the LSRES<b>0</b> and XLSRES<b>0</b> buses.</p><p>For a store miss (if no aliasing), the LSSEC initiates a memory write cycle through the CMASTER. The data is sent to the CMASTER from the LSSEC on the DATB bus. The dcache is not be involved in this transaction.</p><p>Dcache Hooks to Support Snooping</p><p>The dcache is involved when an inquire cycle hits a modified line since a writeback cycle is issued to update the modified line in external memory. The dcache is also involved during snoop invalidations.</p><p>Dcache/SRB Interface</p><p>The dcache interfaces to the SRB through one bi-directional bus\u2014SRBB(<b>31</b>:<b>0</b>) and two unidirectional signals SRB_VAL and DCTARVAL. The functions that can be requested by the SRB of the dcache include array reads/writes, line invalidations and global invalidations.</p><p>An array read cycle is initiated by the SRB when it wishes to perform an array read. The array to be accessed (e.g. dcache, icache . . . ) and the action performed are specified in the first packet sent on the SRBB bus with the SRB_VAL signal in cycle N. The SRB will then send out the array locator doubleword on the SRBB bus in cycle N+2. The dcache will latch this array locator at end of cycle N+2 and read the appropriate word in cycle N+6. The dcache drives the requested data on the SRBB bus and also assert the DCTARVAL signal during cycle N+7. Note that the SRB/dcache interface is slow and hence, the data read from the array can be latched and driven out on a later clock cycle.</p><p>An array write cycle is initiated by the SRB when it wishes to write to an array. During cycle N, the SRB will specify the array to be accessed and the action to be performed. The SRB then sends out the array locator doubleword on the SRBB bus in cycle N+2. The dcache latches this array locator at end of cycle N+2. During cycle N+4 the SRB sends the data to be written into the dcache. The dcache writes this data in cycle N+6. The dcache will assert the DCTARVAL signal during cycle N+7 to indicate the end of the write operation.</p><p>For invalidations, the SRB initiates the array invalidate bus cycle on the SRBB bus in cycle N. The array locator is sent on the SRBB bus in cycle N+2. The type of invalidation( line/global) is based on the OP field in the array locator. During cycle N+6, the dcache executes the invalidation requested(line/global). In cycle N+7, the dcache asserts the DCTARVAL signal to indicate end of the requested operation.</p><p>Dcache Top Level I/O Signal List</p><p>DATB(<b>63</b>:<b>0</b>): Input/Output Connects to LSSEC/CMASTER</p><p>This is a bi-directional bus between the CMASTER, LSSEC and the dcache. This bus has the following uses:</p><p>(a) to send data to the dcache from the CMASTER during reloads.</p><p>(b) to send data to the CMASTER from the dcache during writebacks.</p><p>(c) to send data to CMASTER from the LSSEC for non-cacheable stores( bits <b>31</b>:<b>0</b> only)</p><p>SRBB(<b>31</b>:<b>0</b>): Input/Output Connects to SRB/LSSEC/CMASTER/ICACHE</p><p>This bi-directional bus is used by the SRB to move data to/from arrays and special registers, to send the array locator and to send the command word.</p><p>SRB_VAL: Input/Output of SRB</p><p>This signal is asserted by the SRB whenever it sends the command word on the SRBB bus to initiate an access.</p><p><tables id=\"TABLE-US-00200\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"105PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSLINAD0(31:2): Input.</entry><entry morerows=\"0\" valign=\"top\">Connects to</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"105PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSSEC/FIROB/CMASTER</entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus carries the dcache port A linear address. In addition to having the port A linear address for loads/stores, this bus will also carry the linear address when a reload from the CMASTER is ready to be done. i.e. the new line from CMASTER has been read into the 256 bit buffer(BUF<b>1</b>) that exists in the dcache and it is ready to be put in place of the replaced line.</p><p><tables id=\"TABLE-US-00201\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"105PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSLINAD1(31:2): Input.</entry><entry morerows=\"0\" valign=\"top\">Connects to</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"105PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSSEC/FIROB/CMASTER</entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus carries the dcache port B linear address.</p><p><tables id=\"TABLE-US-00202\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SBADAT(31:0): Input/Output of LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus drives the store data for port A. This is a static bus. This bus can be driven from the beginning of the clock thereby ensuring that the data has enough time to propagate to the dcache and CMASTER blocks. This bus is required because the LSRESO bus cannot be used for this purpose. The LSRESO and XLSRESO buses are differential buses that are evaluated by a senseamp on the falling edge of XICLK. Therefore the data would be available only in the next cycle which would prevent single cycle stores.</p><p><tables id=\"TABLE-US-00203\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SBBDAT(31:0): Input/Output of LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus drives the store data for port B. This is a static bus. This bus can be driven from the beginning of the clock thereby ensuring that the data has enough time to propagate to the dcache and CMASTER blocks. This bus is required because the LSRES<b>1</b> bus cannot be used for this purpose. The LSRES<b>1</b> and XLSRES<b>1</b> buses are differential buses that are evaluated by a senseamp on the falling edge of XICLK. Therefore the data would be available only in the next cycle which would prevent single cycle stores.</p><p><tables id=\"TABLE-US-00204\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSPASHFT(1:0): Input/Output of LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus determines how much the data that is read from the dcache on port A should be shifted. This shift code is determined based on the operand size as well as bits <b>1</b>:<b>0</b> of the linear address.</p><p><tables id=\"TABLE-US-00205\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSPASHFT(1:0)</entry><entry morerows=\"0\" valign=\"top\">Shift Value</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">00</entry><entry morerows=\"0\" valign=\"top\">shift by 0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01</entry><entry morerows=\"0\" valign=\"top\">shift by 8</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">10</entry><entry morerows=\"0\" valign=\"top\">shift by 16</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11</entry><entry morerows=\"0\" valign=\"top\">shift by 24</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"126PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSPBSHFT(1:0): Input/Output of LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus determines how much the data that is read from the dcache on port B should be shifted. This shift code is determined based on the operand size as well as bits <b>1</b>:<b>0</b> of the linear address.</p><p><tables id=\"TABLE-US-00206\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSPBSHFT(1:0)</entry><entry morerows=\"0\" valign=\"top\">Shift Value</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">00</entry><entry morerows=\"0\" valign=\"top\">shift by 0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01</entry><entry morerows=\"0\" valign=\"top\">shift by 8</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">10</entry><entry morerows=\"0\" valign=\"top\">shift by 16</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">11</entry><entry morerows=\"0\" valign=\"top\">shift by 24</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"126PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSINDXCT: Input/Output from LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates an index conflict for the two dcache accesses. An index conflict is generated if bits <b>11</b>:<b>5</b> of the two linear addresses match. This signal will be used to read only one port of the dual ported tag arrays. As long as there is no bank conflict, this signal will not cause any serialization of dcache accesses.</p><p><tables id=\"TABLE-US-00207\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSWYPRCT: Input/Output from LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates an index conflict for the way prediction array in dcache. Note that the index for this array is bits <b>14</b>:<b>5</b> of the linear address. This signal will be used to fire only one port of the way predict array.</p><p>CM<b>2</b>LS_CPBK(<b>3</b>:<b>0</b>): Input/Output from CMASTER</p><p>The CMASTER sends the information as to which 64 bit packet of the 32 byte line is to be sent by the dcache on the DATB bus during a writeback. The decoding of this bus is as follows:</p><p><tables id=\"TABLE-US-00208\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"105PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CM2LS_CFBK(3:0)</entry><entry morerows=\"0\" valign=\"top\">Actions taken</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0001</entry><entry morerows=\"0\" valign=\"top\">bits 63:0 of writeback line</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">driven on DATB(63:0)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0010</entry><entry morerows=\"0\" valign=\"top\">bits 127:64 of writeback line</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">driven on DATB(63:0)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0100</entry><entry morerows=\"0\" valign=\"top\">bits 191:128 of writeback line</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">driven on DATB(63:0)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1000</entry><entry morerows=\"0\" valign=\"top\">bits 255:192 of writeback line</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">driven on DATB(63:0)</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"119PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RD_SNP: Input</entry><entry morerows=\"0\" valign=\"top\">Output of CMASTER</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The CMASTER sends this signal to the dcache to start driving bits <b>63</b>:<b>0</b> of the line that has been read as part of a snoop writeback(initiated by CM_DC_SNP) on the DATB bus. On the next XICLK, the dcache will drive bits <b>127</b>:<b>64</b> of the line. The dcache will then drive bits <b>191</b>:<b>128</b> and <b>255</b>:<b>192</b> on the two following clocks.</p><p>LS_IDX(<b>5</b>:<b>0</b>): Input/Output of CMASTER</p><p>This is the index sent to the dcache from the CMASTER to be used for snoop read, snoop invalidates, writebacks and non-snoop invalidations.</p><p>CM<b>2</b>DC(<b>3</b>:<b>0</b>): Input/Output from CMASTER</p><p>This bus is part of the reload sequence. It indicates which 64 bit packet of the requested line is being sent to the dcache from the CMASTER on the DATB bus.</p><p><tables id=\"TABLE-US-00209\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"105PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"91PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CM2DC(3:0)</entry><entry morerows=\"0\" valign=\"top\">Actions taken</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0001</entry><entry morerows=\"0\" valign=\"top\">bits 63:0 of requested lin</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">driven on DATB(63:0) by</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMASTER</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0010</entry><entry morerows=\"0\" valign=\"top\">bits 127:64 of requested line</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">driven on DATB(63:0) by</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMASTER</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0100</entry><entry morerows=\"0\" valign=\"top\">bits 191:128 of requested line</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">driven on DATB(63:0) by</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMASTER</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1000</entry><entry morerows=\"0\" valign=\"top\">bits 255:192 of requested line</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">driven on DATB(63:0) by</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMASTER</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"133PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"63PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSDCEXC: Input/Output of LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal informs the dcache that an exception has been detected by the LSSEC during its protection checking and limit checking actions. This signal is used only during stores. When this signal goes active during a store, we restore the cache location that was written.</p><p><tables id=\"TABLE-US-00210\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LDORST(1:0): Input/Output from LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK12</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>LDORST(<b>0</b>) indicates whether the port A access when issued from the LSSEC is a load or a store. LDORST(<b>0</b>)=0 indicates a load and LDORST(<b>0</b>)=1 indicates a store. LDORST(<b>1</b>) does the same for port B.</p><p><tables id=\"TABLE-US-00211\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PABYTEN(3:0): Input/Output from LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These are the byte enables for the dcache port A access. They will be used in unaligned accesses and 8/16 bit accesses.</p><p><tables id=\"TABLE-US-00212\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PBBYTEN(3:0): Input/Output from LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK14</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>These are the byte enables for the dcache port B access. They will be used in unaligned accesses and 8/16 bit accesses.</p><p><tables id=\"TABLE-US-00213\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSUNALGN(1:0): Input/Output of LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>LSUNALGN(<b>0</b>) indicates that the load/store access to the dcache from port A is unaligned. LSUNALGN(<b>1</b>) indicates the same for port B. An unaligned load can be issued to either port A or port B. An unaligned store uses both ports simultaneously.</p><p>BIU_NC: Input/Output of CMASTER</p><p>When there is a miss in the dcache, this signal when active indicates that the external data access caused by the miss is non-cacheable.</p><p>CM_REPCOL(<b>2</b>:<b>0</b>): Input/Output from CMASTER</p><p>This bus selects the way to be replaced during an external reload cycle. Note that the pseudo-random replacement strategy will be implemented in the CMASTER. It will also be used during writebacks and non-snoop invalidations.</p><p>IRESET: Input</p><p>This is the global internal reset signal. All entries in the dcache must be invalidated on assertion of IRESET.</p><p>PAGE_PROT(<b>2</b>:<b>0</b>): Input/Output of CMASTER</p><p>These are the page protection bits(D, U/S*,R/W*) that are sent by the TLB on dcache misses. They are written into the tag array. In the case of non-cacheable accesses, the PAGE_PROT bits should be used for page protection checks.</p><p>CM_DC_INV: Input/Output of CMASTER</p><p>This signal is used to (non-snoop) invalidate a dcache line.</p><p>CM_DC_RD: Input/Output of CMASTER</p><p>This signal is used by the CMASTER to initiate a dcache read as part of the reload or writeback sequence.</p><p>CM_DC_SNP: Input/Output of CMASTER</p><p>Used by the CMASTER to initiate a snoop related read of the dcache.</p><p>CM_DC_SINV: Input/Output of CMASTER</p><p>Used by the CMASTER to do a snoop invalidation of a dcache line.</p><p>CM<b>2</b>LS_RST: Input/Output of CMASTER</p><p>Used to restart the CMASTER\u2014dcache line transfer if the transfer was halted. For example, if BOFF# was asserted in the middle of this transfer, Processor <b>500</b> would relinquish the external bus to another bus master. When BOFF# is de-asserted, the bus cycle that was interrupted has to be restarted. Therefore, the all four packets would be transferred regardless of how many had been transferred before the assertion of BOFF#.</p><p>CM<b>2</b>LS: Input/Output from CMASTER</p><p>This signal is a flag from the Cmaster to the dcache and the LSSEC that the last packet of a reload sequence is being sent.</p><p>CM<b>2</b>LS_CAN: Input/Output from CMASTER</p><p>This signal is used by the CMASTER handles a special case of invalidation. If during the reload sequence, we get a snoop invalidate for the new line that is to be loaded into the dcache. This signal is used to reset the valid bit for the new line when it is loaded into the cache when the line swap occurs during the reload.</p><p>CROWP: Input/Output from SRB</p><p>This is the write protect(WP) bit in the CR<b>0</b> special register. This bit is used with the page protection bits to determine protection violations.</p><p><tables id=\"TABLE-US-00214\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CURCPL(1:0): Input/Output of LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK10</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the Current Privilege level information. The dcache uses the D, R/W* and U/S* bits in conjunction with the CURCPL bits to determine protection violations.</p><p>CM_DC_ALIAS: Input/Output of CMASTER</p><p>This signal from the CMASTER indicates to the dcache and LSSEC that an alias was detected by the CMASTER. The CMASTER will also send the way information on the CM_REPCOL bus along with this signal. The dcache will use this to update the linear tag in the aliased way.</p><p>CROPG: Input/Output from SRB</p><p>This is the paging enabled (PG) bit in the CRO special register. Paging is enabled when CROPG=1.</p><p><tables id=\"TABLE-US-00215\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSUPDATERD: Input/Output from LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK10</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal is used to generate write signals to update the tag, status and valid bits in the tag array when aliasing has occurred.</p><p>LS_SNP_COL(<b>2</b>:<b>0</b>): Input/Output from CMASTER</p><p>This bus selects the way in the dcache to be used for the writeback cycle that follows an inquire cycle. This writeback cycle occurs only if the inquire cycle hits a M-state line. It is also used to select the way during snoop invalidations.</p><p><tables id=\"TABLE-US-00216\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSRSLD(1:0) Input/Output from LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>LSRSLD(<b>0</b>) indicates that there is a port A dcache access issued from the LSSEC. LSRSLD(<b>1</b>) does the same for port B.</p><p><tables id=\"TABLE-US-00217\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSDCFWD(1:0): Input/Output from LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK11</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>LSFWD(<b>0</b>) indicates to the dcache not to drive the LSRESO/XLSRESO buses. LSFWD(<b>1</b>) indicates to the dcache not to drive the LSRES<b>1</b>/XLSRES<b>1</b> buses.</p><p>LSCPLISZERO: Input/Output from LSSEC</p><p>The protection checking in the dcache uses the current CPL bits CURCPL(<b>1</b>:<b>0</b>). LSCPLISZERO being active will cause them to be overridden with zero.</p><p>LSCNMA(<b>1</b>:<b>0</b>): Input/Output from LSSEC</p><p>LSCNMA(<b>0</b>) when active, indicates to the dcache that it must cancel the misaligned load being executed on port A. This condition happens when the first half of the misaligned access is complete and the LSSEC finds out that it can forward the data from the store buffer. The LSSEC then will discard the data and will not drive the LSRESO bus. LSCNMA(<b>1</b>) serves the same function for port B and the LSRES<b>1</b> bus.</p><p>BSTRST: Input/Output from JTAG_BIST</p><p>This signal causes the address counter for the BIST logic in dcache to reset.</p><p>BSTRUN: Input/Output from JTAG\u2212BIST</p><p>This signal causes BIST to start.</p><p>BSTRD: Input/Output from JTAG_BIST</p><p>This signal is asserted to read the dcache arrays and do the compare in the TAEC registers.</p><p>BSTWR: Input/Output from JTAG_BIST</p><p>This signal is asserted to write the dcache arrays when in BIST mode.</p><p>BSTINCR: Input/Output from JTAG_BIST</p><p>This signal is asserted to request an increment of the BIST address counter.</p><p>BSTDIN: Input/Output from JTAG_BIST</p><p>This is the data to be loaded into the TAEC input registers prior to being written into the arrays.</p><p>FLUSHON: Input\u2014Connects to JTAG_BIST</p><p>This signal enables the shifting of the data on the BSTDIN input into the TAEC input registers.</p><p>UPDOWN: Input\u2014Connects to JTAG_BIST</p><p>This signal control whether the BIST address counter will counter up or down. UPDOWN=1 is up and UPDOWN=0 is down.</p><p>BSTSHF<b>1</b>: Input\u2014Connects to JTAG_BIST</p><p>This is the signal that clocks the master latch in the TAEC registers.</p><p>BSTSHF<b>2</b>: Input\u2014Connects to JTAG_BIST</p><p>This is the signal that clocks the slave latch in the TAEC registers.</p><p>BSTFALSE: Input\u2014Connects to JTAG_BIST</p><p>BSTFALSE when active will cause the test pattern to be inverted.</p><p>PORTSEL: Input\u2014Connects to JTAG_BIST</p><p>This signal when active selects the second port of the tag and way predict arrays.</p><p><tables id=\"TABLE-US-00218\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCTARVAL: Output - Connects to SRB</entry><entry morerows=\"0\" valign=\"top\">ICLK8</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal is asserted by the dcache to indicate the end of the requested SRB operation. If the requested operation was a read, then the dcache will also drive the SRBB bus with the read data.</p><p>LSRESO(<b>31</b>:<b>0</b>): Output. Connects to LSSEC/FNCU/FIROB. ICLK<b>14</b></p><p>This is the true portion of the LSSEC/dcache port A access result bus. On Processor <b>500</b>, driving buses is a major task and it has been determined that for speed reasons this bus in conjunction with XLSRESO(<b>31</b>:<b>0</b>) will be a differential bus. Data is output from dcache on this bus during loads.</p><p>XLSRES<b>0</b>(<b>31</b>:<b>0</b>): Output. Connects to LSSEC/FNCU/FIROB. ICLK<b>14</b></p><p>This is the false portion of the LSSEC/dcache port A access result bus. As stated above, the XLSRESO bus is part of a differential bus.</p><p>LSRES<b>1</b>(<b>31</b>:<b>0</b>): Output. Connects to LSSEC/FNCU/FIROB. ICLK<b>14</b></p><p>This is the true portion of the LSSEC/dcache port B access result bus. On Processor <b>500</b>, driving buses is a major task and it has been determined that for speed reasons this bus in conjunction with XLSRES<b>1</b>(<b>31</b>:<b>0</b>) will be a differential bus. Data is output from dcache on this bus during loads.</p><p>XLSRES<b>1</b>(<b>31</b>:<b>0</b>): Output. Connects to LSSEC/FNCU/FIROB. ICLK<b>14</b></p><p>This is the false portion of the LSSEC/dcache port B access result bus. As stated above, the XLSRES<b>1</b> bus is part of a differential bus.</p><p><tables id=\"TABLE-US-00219\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"154PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCLSPROK(1:0): Output - Connects to LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Indicates a protection violation during a dcache access. DCLSPROK(<b>0</b>) corresponds to port A and DCLSPROK(<b>1</b>) corresponds to port B.</p><p><tables id=\"TABLE-US-00220\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCLSD(1:0): Output - Connects to LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>DCLSD(<b>0</b>) and DCLSD(<b>1</b>) are the dirty bits corresponding to port A and port B respectively. They are used by the LSSEC during stores to determine if the corresponding dirty bit in the page table entry in the TLB is correctly set. If the store is released and we find that the page table entry thinks it is clean, then an exception must occur to write the dirty bit into the external page table entries so as to insure that this page gets written back to external memory.</p><p><tables id=\"TABLE-US-00221\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"203PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCFINRLD: Output - Connects to LSSEC/CMASTER ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates to the LSSEC and CMASTER that the reload has been completed. The LSSEC may now issue load/store requests to the dcache. The CMASTER on receiving this signal may request a writeback cycle if the replaced line was dirty.</p><p><tables id=\"TABLE-US-00222\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCDATRDY:Output - Connects to LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK13</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal informs the LSSEC that the data for a non-cacheable load is available to be driven on the LSRESO bus. The LSSEC must then on the next clock, drive the tag on the LSTAGO bus when the dcache drives the data on the LSRESO bus.</p><p><tables id=\"TABLE-US-00223\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCFSTPCK: Output - Connects to LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK11</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal informs the LSSEC that the first packet for a reload has arrived at the dcache. The LSSEC on the next cycle will cancel any access it had in progress and send the reload address(tag and index) on the LSLINADO bus.</p><p><tables id=\"TABLE-US-00224\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCPAPRHIT: Output - Connects to LSSEC/FNCU</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates to the functional units and the LSSEC that there was a hit on the port A predicted way. Single cycle dcache access is achieved on port A when this signal is active.</p><p><tables id=\"TABLE-US-00225\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCPBPRHIT: Output - Connects to LSSEC/FNCU</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates to the functional units and the LSSEC that there was a hit on the port B predicted way. Single cycle dcache access is achieved on port B when this signal is active.</p><p><tables id=\"TABLE-US-00226\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCUNPAHIT: Output - Connects to LSSEC/FNCU</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates to the functional units and the LSSEC that there was a hit in one of the port A unpredicted ways. Two cycle dcache access is achieved on port A when this signal is active.</p><p><tables id=\"TABLE-US-00227\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCUNPBHIT: Output - Connects to LSSEC/FNCU</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates to the functional units and the LSSEC that there was a hit in one of the port B unpredicted ways. Two cycle dcache access is achieved on port B when this signal is active.</p><p><tables id=\"TABLE-US-00228\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCBUSY: Output - Connects to LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK12</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal is asserted to inform the LSSEC that the dcache is busy doing either a snoop read, snoop invalidation, non-snoop invalidation, reload or a cache line read that is done prior to a reload. The LSSEC must not send any dcache accesses as long as this signal is active.</p><p><tables id=\"TABLE-US-00229\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCCNCLA:Output - Connects to LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK7</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates to the LSSEC that it must cancel the port A access and reissue it on the next clock. This signal will be activated when the port B access hits in the unpredicted way in cycle N. During cycle N, port A has hit in the predicted way and achieved single cycle access. Now in cycle N+1, the LSSEC issues another access to port A. Now if there is a bank conflict between the new access on port A and the old access on port B, then we want to cancel the port A access. This signal will achieve this purpose.</p><p><tables id=\"TABLE-US-00230\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCCNCLB:Output - Connects to LSSEC</entry><entry morerows=\"0\" valign=\"top\">ICLK7</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates to the LSSEC that it must cancel the port B access and reissue it on the next clock. This signal will be activated when the port A access hits in the unpredicted way in cycle N. During cycle N, port B has hit in the predicted way and achieved single cycle access. Now in cycle N+1, the LSSEC issues another access to port B. Now if there is a bank conflict between the new access on port B and the old access on port A, then we want to cancel the port B access. This signal will achieve this purpose.</p><p>BSTDDOUT: Output\u2014Connects to JTAG_BIST</p><p>This signal is the output of the result register path of the TAEC chain for the data array.</p><p>BSTDTOUT: Output\u2014Connects to JTAG_BIST</p><p>This signal is the output of the result register path of the TAEC chain for the tag and way prediction arrays.</p><p>MAXADDR: Output\u2014Connects to JTAG_BIST</p><p>This signal indicates that the address counter for the arrays has reached its maximum count.</p><p>Dcache Hierarchy and Internal Signal Definition</p><p>The dcache at the first level of hierarchy is partitioned into two blocks: DCARRAYS and DCCTL. DCCTL will be the synthesized control block and DCARRAYS will have all the custom logic. DCARRAY is further partitioned into four blocks: DCTSVARRAY which is the tag, protection, valid bit array, DCDATARRAY which is the data array, DCWYPRARRAY which is the way prediction array and DCDCBUS which will provide a clean interface to the arrays from the LSSEC and CMASTER. The internal signals down 2 levels of hierarchy will be described in the following four sections. For each block, only output signals will be described since the outputs of one block will be inputs of another and repetition can be avoided. Also signals that are top level I/O for the dcache will also not be described here. See above for their description.</p><p>DCCTL Signal List</p><p>DCDATWR(<b>7</b>:<b>0</b>): Output\u2014Connects to DCDATARRAY ICLK<b>9</b></p><p>This bus is the write strobe for each bank of the data array.</p><p><tables id=\"TABLE-US-00231\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"168PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCDATARRD(7:0): Output - Connects to</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"140PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCDATARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK6</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus is the evaluate strobe for each bank of the data array. This signal is asserted for any access of the data array (read or write).</p><p>SRBVALP<b>2</b>: Output\u2014Connects to DCDCBUS ICLK<b>3</b></p><p>This signal is asserted two clocks after the SRB_VAL signal is received if the dcache is the target of the SRB access. SRBVALP<b>2</b> is then used to latch the array locator.</p><p>SRBVALP<b>4</b>: Output\u2014Connects to all array blocks ICLK<b>3</b></p><p>This signal is asserted four clocks after the SRB_VAL signal is received if the dcache is the target of the SRB access and the requested operation is a write. SRBVALP<b>4</b> is then used to latch the write data.</p><p><tables id=\"TABLE-US-00232\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"105PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"70PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SRBDCACC: Output</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal is a decode of the SRB control word(CW(<b>4</b>:<b>0</b>)=14h) that is sent out in the first packet. It indicates that the dcache is the target of the dcache access.</p><p><tables id=\"TABLE-US-00233\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SRBWYRD: Output - Connects to DCDCBUS</entry><entry morerows=\"0\" valign=\"top\">ICLK4</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates that the requested operation is a read of the way predict array.</p><p><tables id=\"TABLE-US-00234\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"182PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">DCTSWR: Output - Connects to DCTSVARRAY/DCDCBUS</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the write strobe for the tag and protection bits in the tag array. This signal is asserted during a reload or an SRB access or during an update when an alias has been detected by the CMASTER. Write to the tag and protection bits can occur only from port A.</p><p><tables id=\"TABLE-US-00235\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCPAVALWR: Output - Connects to DCDCBUS/</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCTSVARRAY</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the write signal corresponding to port A for the valid bit in the tag array. This signal is asserted for either reloads, line invalidations, SRB access or updates when an alias is detected by CMASTER.</p><p><tables id=\"TABLE-US-00236\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCPBVALWR: Output - Connects to DCDCBUS/</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCTSVARRAY</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the write signal corresponding to port B for the valid bit in the tag array. This signal is asserted for snoop invalidations.</p><p><tables id=\"TABLE-US-00237\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"168PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCPAVALIN: Output - Connects to DCTSVARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the bit corresponding to port A that is to be written into the valid bit in the tag array. This bit will be 1 for reloads and updates when an alias has been detected. This bit will be 0 for line invalidations (through CMASTER and SRB).</p><p><tables id=\"TABLE-US-00238\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCLTRLDAD:Output - Connects to DCDCBUS/</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCTSVARRAY</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal when active indicates the presence of the reload/aliased address(tag and index) on the LSLINADO bus. The DCDCBUS block will latch the index and the DCTSVARRAY will latch the tag.</p><p><tables id=\"TABLE-US-00239\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"196PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCUSERLDAD:Output - Connects to DCDCBUS ICLK1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal chooses the previously latched reload address for the next dcache access on port A. The index and the column to be written (PAWRITECOL) will be generated in the DCDCBUS block. No port B access will occur.</p><p><tables id=\"TABLE-US-00240\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"196PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCENRLD:Output - Connects to DCTSVARRAY ICLK2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal goes active when the address and data are ready to do a reload.</p><p><tables id=\"TABLE-US-00241\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"196PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCENNC:Output - Connects to DCTSVARRAY ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal goes active when the access on port A is a non-cacheable load.</p><p><tables id=\"TABLE-US-00242\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"168PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCALLBNKS:Output - Connects to DCDATARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal is used to select all the banks of the data array in order to do either a writeback or a reload. The port A index will be used for all the banks.</p><p><tables id=\"TABLE-US-00243\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCPABKEN:Output - Connects to DCDATARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal enables the choosing of the appropriate bank for the port A access. It is generated when either LSRSLD(<b>0</b>)=1 or there is an SRB access.</p><p><tables id=\"TABLE-US-00244\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SELPAIDX:Output - Connects to DCDCBUS</entry><entry morerows=\"0\" valign=\"top\">ICLK2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal selects the LS_IDX bus as the index for the port A dcache access. This signal is active when a writeback (snoop and non-snoop) or invalidation is being processed by the dcache.</p><p><tables id=\"TABLE-US-00245\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCSNPLIN:OutPut - Connects to DCDATARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK9</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal when active will latch the line that is read out of the data array on a snoop read into a 32 byte buffer. The CMASTER will then assert RD_SNP to indicate to the dcache that it may start driving the DATB bus with 64 bit packets of the data in this buffer.</p><p><tables id=\"TABLE-US-00246\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SRBWYWR:Output - Connects to DCDCBUS</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates that the requested operation is a write of the way predict array.</p><p><tables id=\"TABLE-US-00247\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SRBGLINV:OutPut - Connects to DCTSVARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK7</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal will cause a global invalidation of the tag array.</p><p><tables id=\"TABLE-US-00248\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SRBTAGRD:Output - Connects to DCDCBUS</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal indicates that the requested operation is a read of the dcache tag array.</p><p><tables id=\"TABLE-US-00249\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"168PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DRSRBDAT:Output - Connects to</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCTSVARRAY/DCWYPRARRAY/DCDATARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal when active will drive the data from the chosen dcache array on the SRBB bus to the SRB.</p><p>DCDCBUS Signal List</p><p><tables id=\"TABLE-US-00250\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"168PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCPATSVRD: Output - Connects to DCTSVARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the port A evaluate signal for the tag array. This signal is asserted for any port A access of the tag array (read or write).</p><p><tables id=\"TABLE-US-00251\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"168PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCPBTSVRD: Output - Connects to DCTSVARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the port B evaluate signal for the tag array. This signal is asserted for any port B access of the tag array (read or write).</p><p>DCPAINDX(<b>5</b>:<b>0</b>): Output\u2014Connects to DCTSVARRAY/DCDATARRAY ICLK<b>3</b></p><p>This is the index for the port A access to both the tag and data arrays. The index corresponds to either bits <b>10</b>:<b>5</b> of LSLINADO or LS_IDX(<b>5</b>:<b>0</b>).</p><p>DCPBINDX(<b>5</b>:<b>0</b>): Output\u2014Connects to DCTSVARRAY/DCDATARRAY ICLK<b>3</b></p><p>This is the index for the port B access to both the tag and data arrays. The index corresponds to either bits<b>10</b>:<b>5</b> of LSLINAD<b>1</b> or the LS_IDX(<b>5</b>:<b>0</b>) or the bits of the SRBB bus corresponding to index.</p><p><tables id=\"TABLE-US-00252\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"182PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">WYAINDX(8:0): Output - Connects to DCWYPRARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the index for the way prediction array, port A access. Corresponds to bits <b>13</b>:<b>5</b> of the LSLINAD<b>0</b> bus.</p><p><tables id=\"TABLE-US-00253\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"182PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">WYBINDX(8:0): Output - Connects to DCWYPRARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the index for the way prediction array, port B access. Corresponds to bits <b>13</b>:<b>5</b> of the LSLINAD<b>1</b> bus.</p><p><tables id=\"TABLE-US-00254\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"168PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WAYRDA: Output - Connects to DCWYPRARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the port A evaluate signal for the way predict array. This signal is asserted for any port A access of the way predict array (read or write).</p><p><tables id=\"TABLE-US-00255\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"168PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WAYRDB: Output - Connects to DCWYPRARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the port B evaluate signal for the way predict array. This signal is asserted for any port B access of the way predict array( read or write).</p><p><tables id=\"TABLE-US-00256\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"168PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WAYWRA: Output - Connects to DCWYPRARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK9</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the port A write signal for the way predict array. This signal is asserted when updating the array when a misprediction occurs or when a reload occurs.</p><p><tables id=\"TABLE-US-00257\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"168PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WAYWRB: Output - Connects to DCWYPRARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK9</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This is the port B evaluate signal for the way predict array. This signal is asserted when updating the array when a misprediction occurs.</p><p><tables id=\"TABLE-US-00258\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"182PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">PABNKSEL(7:0): Output - Connects to DCDATARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus selects the bank in the data array for the port A access.</p><p><tables id=\"TABLE-US-00259\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"182PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">PBBNKSEL(7:0): Output - Connects to DCDATARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK5</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus selects the bank in the data array for the port B access.</p><p><tables id=\"TABLE-US-00260\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCPABNKSEL(2:0): Output - Connects to DCCTL</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus is the encoded version of PABNKSEL bus. It selects the bank in the data array for the port A access.</p><p><tables id=\"TABLE-US-00261\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DCPBBNKSEL(2:0): Output - Connects to DCCTL</entry><entry morerows=\"0\" valign=\"top\">ICLK3</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus is the encoded version of PBBNKSEL bus. It selects the bank in the data array for the port B access.</p><p><tables id=\"TABLE-US-00262\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"182PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">DCWYXFER: Output - Connects to DCWYPRARRAY</entry><entry morerows=\"0\" valign=\"top\">ICLK7</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This signal is used for a very specific case. Consider the case as follows: There are two load accesses to the dcache on cycle I. The port A access hits in the predicted way while the port B access hits in unpredicted way. Now in cycle I+1, there can be a new access on port A while the data from unpredicted way will be driven out on port B. Also, the way prediction array will be updated. Now if there is a way conflict between the new port A access and the old port B access, the way predict array need not be read since the port B update to way predict array is the prediction for port A. DCWYXFER will facilitate transfer of this update from one port to the other port in such a case. The direction of the transfer can be determined by looking at the HIT signals for both ports(DCPAPRHIT,DCPBPRHIT,DCUNPAHIT,DCUNPBHIT).</p><p>PAWRITECOL(<b>2</b>:<b>0</b>): Output\u2014Connects to DCTSVARRAY/DCDATARRAY ICLK<b>4</b></p><p>This bus selects the way to be used for reloads, updates to fix aliases, SRB accesses and invalidations.</p><p>PBWRITECOL(<b>2</b>:<b>0</b>): Output\u2014Connects to DCTSVARRAY/DCDATARRAY ICLK<b>4</b></p><p>This bus selects the way to be used for snoop invalidations.</p><p><tables id=\"TABLE-US-00263\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ARRTYP(2:0): Output - Connects to DCCTL</entry><entry morerows=\"0\" valign=\"top\">ICLK4</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus carries the type information of the array locator word. ARRTYP specifies the array in the dcache that the SRB wishes to access.</p><p><tables id=\"TABLE-US-00264\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"147PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ARROP(1:0):Output - Connects to DCCTL</entry><entry morerows=\"0\" valign=\"top\">ICLK4</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This bus carries the OP field of the array locator word. ARROP specifies the type of invalidation(line/global) to be done if the SRB requested action was a dcache invalidation.</p><p>DCTSVARRAY Signal List</p><p>PATAGCOM: Output\u2014Connects to DCDATARRAY/DCWYPRARRAY/DCCTL ICLK<b>14</b></p><p>This bus indicates the result of the tag compare for all 8 ways for port A. This bus will therefore provide the update to the way predict array if a misprediction occurs on port A.</p><p>PBTAGCOM: Output\u2014Connects to DCDATARRAY/DCWYPRARRAY/DCCTL ICLK<b>14</b></p><p>This bus indicates the result of the tag compare for all 8 ways for port B. This bus will therefore provide the update to the way predict array if a misprediction occurs on port B.</p><p>Turning now to FIG. 67, a computer system <b>1000</b> including microprocessor <b>200</b>, an interrupt controller <b>1004</b>, a plurality of input/output (I/O) devices <b>1006</b>A-<b>1006</b>N (referred to collectively as I/O devices <b>1006</b>), a bus bridge <b>1008</b>, a main memory <b>1010</b>, and a cache <b>1012</b> is shown. Microprocessor <b>200</b>, interrupt controller <b>1004</b>, bus bridge <b>1008</b>, main memory <b>1010</b>, and cache <b>1012</b> are coupled to a CPU bus <b>1014</b> which effects high speed, high bandwidth communication between the connected devices. Lower speed, lower bandwidth communication is provided for I/O devices <b>1006</b> via input/output bus <b>1016</b>. I/O devices <b>1006</b> are coupled to interrupt controller <b>1004</b> via an interrupt bus <b>1018</b>.</p><p>Interrupt bus <b>1018</b> may include at least one interrupt conductor per I/O device <b>1006</b>A-<b>1006</b>N. An interrupt request signal conveyed on the associated interrupt conductor is indicative of a request for interrupt of microprocessor <b>200</b> by the associated I/O device <b>1006</b>A-<b>1006</b>N. Interrupt controller <b>1004</b> is configured to receive the interrupt request signals and to convey an interrupt signal to microprocessor <b>200</b> upon CPU bus <b>1014</b> in response to the interrupt request signals. In one embodiment, interrupt controller <b>1004</b> is an 8259A interrupt controller used in IBM compatible personal computer systems. In another embodiment, interrupt controller <b>1004</b> includes multiple interrupt controllers similar to the 8259A cascaded to allow a larger number of I/O devices <b>1006</b> to be connected. Interrupt controller <b>1004</b> is programmable, and may be enabled to assert the interrupt signal individually for each interrupt request signal. In other words, interrupt controller may be enabled to assert the interrupt signal if the interrupt request signal from I/O device <b>1006</b>A is asserted but not if the interrupt request signal from I/O device <b>1006</b>B is asserted (or vice-versa). In another embodiment, interrupt controller <b>1004</b> may be programmed with a priority scheme for the interrupt request signals. The priority scheme is devised such that, if multiple interrupt request lines are asserted concurrently: the highest priority interrupt request is service first; followed by the next highest priority interrupt request; etc.</p><p>Bus bridge <b>1008</b> is provided to assist in communications (other than interrupt requests) between I/O devices <b>1006</b> and devices coupled to CPU bus <b>1014</b>. I/O devices <b>1006</b> typically require longer bus clock cycles than microprocessor <b>200</b> and other devices coupled to CPU bus <b>1014</b>. Therefore, bus bridge <b>1008</b> provides a buffer between CPU bus <b>1014</b> and input/output bus <b>1016</b>. Additionally, bus bridge <b>1008</b> translates transactions from one bus protocol to another. In one embodiment, input/output bus <b>1016</b> is an Enhanced Industry Standard Architecture (EISA) bus and bus bridge <b>1008</b> translates from the CPU bus protocol to the EISA bus protocol. In another embodiment, input/output bus <b>1016</b> is a Peripheral Component Interconnect (PCI) bus and bus bridge <b>1008</b> translates from the CPU bus protocol to the PCI bus protocol. It is noted that many variations of CPU bus protocols exist. Microprocessor <b>200</b> may employ any suitable bus protocol.</p><p>I/O devices <b>1006</b> provide an interface between computer system <b>1000</b> and other devices external to the computer system. Exemplary I/O devices include a modem, a serial or parallel port, a sound card, etc. I/O devices <b>1006</b> may also be referred to as peripheral devices. Certain I/O devices <b>1006</b> may also be used to enhance the performance of computer system <b>1000</b> by performing certain tasks such that microprocessor <b>200</b> may perform other tasks. Exemplary devices include hardware accelerators. Additionally, mass storage devices such as hard disk drives may be included within I/O devices <b>1006</b>. Main memory <b>1010</b> stores data and instructions for use by microprocessor <b>200</b>. In one embodiment, main memory <b>1010</b> includes one or more dynamic random access memory (DRAM) cells and a DRAM memory controller. It is understood that main memory <b>1010</b> may be configured as multi-banked or interleaved memory. Cache <b>1012</b> is a small, high speed memory for temporarily storing data and instructions from main memory <b>1010</b>. If microprocessor <b>200</b> requests an address from main memory <b>1010</b> and cache <b>1012</b> is storing data associated with the requested address, then cache <b>1012</b> provides the data. Cache <b>1012</b> is an optional component, and computer system <b>1000</b> is fully functional without it. However, cache <b>1012</b> may improve the performance of computer system <b>1000</b>. It is noted that cache <b>1012</b> may also be inserted between microprocessor <b>200</b> and CPU bus <b>1014</b> in other embodiments. It is further noted that cache <b>1012</b> may employ a write-through or writeback protocol.</p><p>Although FIG. 67 shows a computer system <b>1000</b> including one microprocessor <b>200</b>, computer system <b>1000</b> may include multiple microprocessors similar to microprocessor <b>200</b> coupled to CPU bus <b>1014</b>. It is further noted that interrupt controller <b>1004</b>, although shown in FIG. 67 to be connected to CPU bus <b>1014</b>, may be coupled to I/O bus <b>1016</b> or yet another bus (not shown). When coupled in this manner, interrupt acknowledge bus transactions are conveyed through one or more bus bridges similar to bus bridge <b>1008</b> to interrupt controller <b>1004</b>. Often, interrupt controller <b>1004</b> is coupled directly to an interrupt conductor upon microprocessor <b>200</b> for signalling interrupts in these embodiments.</p><p>It is noted that a superscalar microprocessor in accordance with the foregoing may further employ the latching structures as disclosed within the co-pending, commonly assigned patent application entitled \u201cConditional Latching Mechanism and Pipelined Microprocessor Employing the Same\u201d, Ser. No. 08/400,608 filed Mar. 8, 1995, by Pflum et al., now abandoned and continued in U.S. patent application Ser. No. 08/744,707, now U.S. Pat. No. 5,831,462. The disclosure of this patent application is incorporated herein by reference in its entirety.</p><p>It is further noted that aspects regarding array circuitry may be found in the co-pending, commonly assigned patent application entitled \u201cHigh Performance Ram Array Circuit Employing Self-Time Clock Generator for Enabling Array Access\u201d, Ser. No. 08/473,103 filed Jun. 7, 1995 by Tran, now U.S. Pat. No. 5,619,464. The disclosure of this patent application is incorporated herein by reference in its entirety.</p><p>It is additionally noted that other aspects regarding superscalar microprocessors may be found in the co-pending, commonly assigned patent application entitled \u201cSuperscalar Microprocessor Including a High Performance Instruction Alignment Unit\u201d, Ser. No. 08/377,843, filed Jan. 25, 1995 by Witt, et al., abandoned and continued in application Ser. No. 08/884,818 filed Jun. 30, 1997, now U.S. Pat. No. 5,819,057. The disclosure of this patent application is incorporated herein by reference in its entirety.</p><p>In accordance with the above disclosure, a return prediction unit is shown which predicts the return address of return instructions when these instructions are fetched. Advantageously, instructions stored at the return address may be fetched immediately upon detecting the return instruction. Clock cycles may be saved in the fetching of instructions residing at the return address. Performance of a superscalar microprocessor including the return prediction unit may be advantageously increased by incorporating the return prediction unit described herein. The present return prediction unit recovers from mispredicted branches, allowing return addresses to be predicted correctly even subsequent to a mispredicted branch.</p><p>Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Thang M.", "last_name": "Tran", "name": ""}, {"first_name": "Rupaka", "last_name": "Mahalingaiah", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}, {"first_name": "", "last_name": "GLOBALFOUNDRIES U.S. INC.", "name": ""}, {"first_name": "", "last_name": "GLOBALFOUNDRIES INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  15/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/30        20060101A I20051008RMEP"}, {"label": "G06F  11/267       20060101A N20051008RMEP"}, {"label": "G01R  31/3185      20060101A N20051008RMEP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712023"}, {"primary": false, "label": "712E09057"}, {"primary": false, "label": "712243"}, {"primary": false, "label": "712228"}, {"primary": false, "label": "712E09029"}, {"primary": false, "label": "712229"}], "ecla_classes": [{"label": "S06F11:22A12"}, {"label": "G06F   9/38B2B"}, {"label": "G06F   9/38C2"}, {"label": "G06F   9/30T2A"}, {"label": "G06F   9/38B9"}, {"label": "G06F   9/38E2D"}, {"label": "S01R31:3185S"}], "cpc_classes": [{"label": "G01R  31/318533"}, {"label": "G06F   9/3848"}, {"label": "G06F   9/3806"}, {"label": "G06F   9/382"}, {"label": "G06F   9/30152"}, {"label": "G06F   9/3816"}, {"label": "G06F   9/3844"}, {"label": "G06F   9/3844"}, {"label": "G06F   9/382"}, {"label": "G06F   9/30152"}, {"label": "G01R  31/318533"}, {"label": "G06F   9/3806"}, {"label": "G06F   9/30054"}, {"label": "G06F   9/3848"}, {"label": "G06F   9/3832"}, {"label": "G06F   9/3832"}, {"label": "G06F  11/2236"}, {"label": "G06F  11/2236"}, {"label": "G06F   9/3816"}, {"label": "G06F   9/30054"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1995-12-11", "application_date": "1999-09-08", "family_members": [{"ucid": "US-5864707-A", "titles": [{"lang": "EN", "text": "Superscalar microprocessor configured to predict return addresses from a return stack storage"}]}, {"ucid": "US-6014734-A", "titles": [{"lang": "EN", "text": "Superscalar microprocessor configured to predict return addresses from a return stack storage"}]}, {"ucid": "US-6269436-B1", "titles": [{"lang": "EN", "text": "Superscalar microprocessor configured to predict return addresses from a return stack storage"}]}]}