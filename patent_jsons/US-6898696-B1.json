{"patent_number": "US-6898696-B1", "publication_id": 74250539, "family_id": 34589933, "publication_date": "2005-05-24", "titles": [{"lang": "EN", "text": "Method and system for efficiently restoring a processor's execution state following an interrupt caused by an interruptible instruction"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50827218\"><p num=\"p-0001\">A method and system for increasing the efficiency of execution in a processor. Instructions are dispatched in instruction groups, wherein if such an instruction group contains an interruptible instruction of a selected type, only one interruptible instruction of the selected type is included in the instruction group. A state of the processor is recorded, associated respectively with each of said dispatched instruction groups. The processor is restored to the recorded state associated with the instruction group containing the interruptible instruction of the selected type causing an interrupt, in response to the interrupt from one of the interruptible instructions of the selected type.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00001\" num=\"00001\">\n<claim-text>1. A method of increasing the efficiency of execution of a processor, comprising:\n<claim-text>dispatching instructions in instruction groups, wherein if an instruction group contains an interruptible instruction of a selected type, only one interruptible instruction of said selected type is included in said instruction group, wherein said interruptible instruction of said selected type is dispatched at the front of said instruction group; </claim-text>\n<claim-text>recording a state for the processor associated with a dispatched instruction group; and </claim-text>\n<claim-text>restoring said processor to said recorded state associated with said dispatched instruction group containing said interruptible instruction of said selected type causing an interrupt, in response to said interrupt from one of said interruptible instructions of said selected type. </claim-text>\n</claim-text>\n</claim>"}, {"num": 2, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00002\" num=\"00002\">\n<claim-text>2. A method of increasing the efficiency of execution of a processor comprising:\n<claim-text>searching a group of N fetched instructions for an interruptible instruction of said selected type; </claim-text>\n<claim-text>dispatching said group of N fetched instructions in response to not finding said interruptible instruction of said selected type in said group of N fetched instructions; </claim-text>\n<claim-text>selectively dispatching instructions from said group of instructions up to and including said interruptible instruction of said selected type, in response to finding an interruptible instruction of said selected type in said group of N fetched instructions, wherein if an instruction group contains an interruptible instruction of a selected type, only one interruptible instruction of said selected type is included in said instruction group; </claim-text>\n<claim-text>recording a state for the processor associated with a dispatched instruction group; and </claim-text>\n<claim-text>restoring said processor to said recorded state associated with said dispatched instruction group containing said interruptible instruction of said selected type causing an interrupt, in response to said interrupt from one of said interruptible instructions of said selected type. </claim-text>\n</claim-text>\n</claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00003\" num=\"00003\">\n<claim-text>3. The method of increasing the efficiency of execution of a processor according to <claim-ref idref=\"CLM-00002\">claim 2</claim-ref>, said method further comprising the step of:\n<claim-text>designating branch instructions as said interruptible instruction of said selected type. </claim-text>\n</claim-text>\n</claim>"}, {"num": 4, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00004\" num=\"00004\">\n<claim-text>4. The method of increasing the efficiency of execution of a processor according to <claim-ref idref=\"CLM-00002\">claim 2</claim-ref>, wherein said method further comprises the steps of:\n<claim-text>in response to an interrupt from any alternate interruptible instruction which is not of said selected type: \n<claim-text>determining the position of said alternate interruptible instruction within the instruction group in which said alternate interruptible instruction is included; </claim-text>\n<claim-text>flushing said instruction group in which said alternate interruptible instruction is included and all instruction groups dispatched thereafter and restoring said processor state to the processor state associated with the instruction group prior to said flushed instruction group, in response to determining that said alternate interruptible instruction is located at the front of said instruction group; </claim-text>\n<claim-text>flushing all instruction groups dispatched after said instruction group in which said alternate interruptible instruction is included and restoring said processor state to the processor state of said instruction group, in response to determining that said alternate interruptible instruction is located at the end of said instruction group. </claim-text>\n</claim-text>\n</claim-text>\n</claim>"}, {"num": 5, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00005\" num=\"00005\">\n<claim-text>5. A method of increasing the efficiency of execution of a processor comprising the steps of:\n<claim-text>dispatching instructions in instruction groups, wherein if an instruction group contains an interruptible instruction of a selected type, only one interruptible instruction of said selected type is included in said instruction group; </claim-text>\n<claim-text>recording a state for the processor associated with a dispatched instruction group; </claim-text>\n<claim-text>in response to said interrupt from one of said interruptible instructions of said selected type: \n<claim-text>restoring said processor to said recorded state associated with said dispatched instruction group containing said interruptible instruction of said selected type causing an interrupt; </claim-text>\n<claim-text>in response to an interrupt from any alternate interruptible instruction which is not of said selected type: </claim-text>\n<claim-text>flushing any instruction groups dispatched including and after said instruction group which contains said alternate interruptible instruction; </claim-text>\n<claim-text>restoring said deep-pipelined processor to a processor state recorded for the instruction group prior to said instruction group containing said alternate interruptible instruction; </claim-text>\n<claim-text>refetching said instruction group which contains said alternate interruptible instruction; and </claim-text>\n<claim-text>determining if said alternative interruptible instruction is to be re-executed; </claim-text>\n<claim-text>re-dispatching said re-fetched instruction group into two instruction groups where said alternate interruptible instruction is the first instruction of a second instruction group, in response to determining that said alternate interruptible instruction is to be re-executed; </claim-text>\n<claim-text>re-dispatching said re-fetched instruction group into two instruction groups where said alternate interruptible instruction is the last instruction of a first groups in response to determining that said alternate interruptible instruction is not to be re-executed; and setting said processor state prior to said second instruction group. </claim-text>\n</claim-text>\n</claim-text>\n</claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00006\" num=\"00006\">\n<claim-text>6. A system for increasing the efficiency of execution of a processor, comprising:\n<claim-text>means for dispatching instructions in instruction groups, wherein if an instruction group contains an interruptible instruction of a selected type, only one interruptible instruction of said selected type is included in said instruction group, wherein said interruptible instruction of said selected type is dispatched at the front of said instruction group; </claim-text>\n<claim-text>means for recording a state for the processor associated with a dispatched instruction group; and </claim-text>\n<claim-text>means for restoring said processor to said recorded state associated with said dispatched instruction group containing said interruptible instruction of said selected type causing an interrupt, in response to said interrupt from one of said interruptible instructions of said selected type. </claim-text>\n</claim-text>\n</claim>"}, {"num": 7, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00007\" num=\"00007\">\n<claim-text>7. A system for increasing the efficiency of execution of a processor comprising:\n<claim-text>means for searching a group of N fetched instructions for an interruptible instruction of said selected type; </claim-text>\n<claim-text>means for dispatching said group of N fetched instructions in response to not finding said interruptible instruction of said selected type in said group of N fetched instructions; </claim-text>\n<claim-text>means for selectively dispatching instructions from said group of instructions up to and including said interruptible instruction of said selected type, in response to finding an interruptible instruction of said selected type in said group of N fetched instructions, wherein if an instruction group contains an interruptible instruction of a selected type, only one interruptible instruction of said selected type is included in said instruction group; </claim-text>\n<claim-text>means for recording a state for the processor associated with a dispatched instruction group; and </claim-text>\n<claim-text>means for restoring said processor to said recorded state associated with said dispatched instruction group containing said interruptible instruction of said selected type causing an interrupt, in response to said interrupt from one of said interruptible instructions of said selected type. </claim-text>\n</claim-text>\n</claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00008\" num=\"00008\">\n<claim-text>8. The system for increasing the efficiency of execution of a processor according to <claim-ref idref=\"CLM-00007\">claim 7</claim-ref>, said system further comprising:\n<claim-text>means for designating branch instructions as said interruptible instruction of said selected type. </claim-text>\n</claim-text>\n</claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00009\" num=\"00009\">\n<claim-text>9. The system for increasing the efficiency of execution of a processor according to <claim-ref idref=\"CLM-00007\">claim 7</claim-ref>, wherein said system further comprises:\n<claim-text>in response to an interrupt from any alternate interruptible instruction which is not of said selected type: </claim-text>\n<claim-text>means for determining the position of said alternate interruptible instruction within the instruction group in which said alternate interruptible instruction is included; </claim-text>\n<claim-text>means for flushing said instruction group in which said alternate interruptible instruction is included and all instruction groups dispatched thereafter and restoring said processor state to the processor state associated with the instruction group prior to said flushed instruction group, in response to determining that said alternate interruptible instruction is located at the front of said instruction group; </claim-text>\n<claim-text>means for flushing all instruction groups dispatched after said instruction group in which said alternate interruptible instruction is included and restoring said processor state to the processor state of said instruction group, in response to determining that said alternate interruptible instruction is located at the tail of said instruction group. </claim-text>\n</claim-text>\n</claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00010\" num=\"00010\">\n<claim-text>10. A system for increasing the efficiency of execution of a processor comprising:\n<claim-text>means for dispatching instructions in instruction groups, wherein if an instruction group contains an interruptible instruction of a selected type, only one interruptible instruction of said selected type is included in said instruction group; </claim-text>\n<claim-text>means for recording a state for the processor associated with a dispatched instruction group; </claim-text>\n<claim-text>means, in response to said interrupt from one of said interruptible instructions of said selected type for: \n<claim-text>restoring said processor to said recorded state associated with said dispatched instruction group containing said interruptible instruction of said selected type causing an interrupt; </claim-text>\n<claim-text>means, in response to an interrupt from any alternate interruptible instruction which is not of said selected type for: </claim-text>\n<claim-text>flushing any instruction groups dispatched including and after said instruction group which contains said alternate interruptible instruction; </claim-text>\n<claim-text>restoring said deep-pipelined processor to a processor state recorded for the instruction group prior to said instruction group containing said alternate interruptible instruction; </claim-text>\n<claim-text>re-fetching said instruction group which contains said alternate interruptible instruction; and </claim-text>\n<claim-text>determining if said alternative interruptible instruction is to be re-executed; </claim-text>\n<claim-text>means for re-dispatching said re-fetched instruction group into two instruction groups where said alternate interruptible instruction is the first instruction of a second instruction group, in response to determining that said alternate interruptible instruction is to be re-executed; </claim-text>\n<claim-text>means for re-dispatching said re-fetched instruction group into two instruction groups where said alternate interruptible instruction is the last instruction of a first instruction group, in response to determining that said alternate interruptible instruction is not to be re-executed; and </claim-text>\n</claim-text>\n<claim-text>means for setting said processor state prior to said second group. </claim-text>\n</claim-text>\n</claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00011\" num=\"00011\">\n<claim-text>11. A data processing system comprising:\n<claim-text>a processor having a plurality of execution units including a branch execution unit and an instruction fetching unit; </claim-text>\n<claim-text>a memory that stores instructions utilized by said execution units; </claim-text>\n<claim-text>means for coupling said memory to said processor; </claim-text>\n<claim-text>means for dispatching instructions in instruction groups, wherein if an instruction group contains an interruptible instruction of a selected type, only one interruptible instruction of said selected type is included in said instruction group, wherein said interruptible instruction of said selected type is dispatched at the front of said instruction group; </claim-text>\n<claim-text>means for recording a state for the processor associated with a dispatched instruction group; and </claim-text>\n<claim-text>means for restoring said processor to said recorded state associated with said dispatched instruction group containing said interruptible instruction of said selected type causing an interrupt, in response to said interrupt from one of said interruptible instructions of said selected type. </claim-text>\n</claim-text>\n</claim>"}, {"num": 12, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00012\" num=\"00012\">\n<claim-text>12. A data processing system comprising:\n<claim-text>a processor having a plurality of execution units including a branch execution unit and an instruction fetching unit; </claim-text>\n<claim-text>a memory that stores instructions utilized by said execution units; </claim-text>\n<claim-text>means for coupling said memory to said processor; </claim-text>\n<claim-text>means for searching a group of N fetched instructions for an interruptible instruction of said selected type; </claim-text>\n<claim-text>means for dispatching said group of N fetched instructions in response to not finding said interruptible instruction of said selected type in said group of N fetched instructions; </claim-text>\n<claim-text>means for selectively dispatching instructions from said group of instructions up to and including said interruptible instruction of said selected type, in response to finding an interruptible instruction of said selected type in said group of N fetched instructions, wherein if an instruction group contains an interruptible instruction of a selected type, only one interruptible instruction of said selected type is included in said instruction group; </claim-text>\n<claim-text>means for recording a state for the processor associated with a dispatched instruction group; and </claim-text>\n<claim-text>means for restoring said processor to said recorded state associated with said dispatched instruction group containing said interruptible instruction of said selected type causing an interrupt, in response to said interrupt from one of said interruptible instructions of said selected type. </claim-text>\n</claim-text>\n</claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00013\" num=\"00013\">\n<claim-text>13. A data processing system comprising:\n<claim-text>a processor having a plurality of execution units including a branch execution unit and an instruction fetching unit; </claim-text>\n<claim-text>a memory that stores instructions utilized by said execution units; </claim-text>\n<claim-text>means for coupling said memory to said processor; </claim-text>\n<claim-text>means for dispatching instructions in instruction groups, wherein if an instruction group contains an interruptible instruction of a selected type, only one interruptible instruction of said selected type is included in said instruction group; </claim-text>\n<claim-text>means for recording a state for the processor associated with a dispatched instruction group; </claim-text>\n<claim-text>means, in response to said interrupt from one of said interruptible instructions of said selected type for: \n<claim-text>restoring said processor to said recorded state associated with said dispatched instruction group containing said interruptible instruction of said selected type causing an interrupt; </claim-text>\n<claim-text>means, in response to an interrupt from any alternate interruptible instruction which is not of said selected type for: </claim-text>\n<claim-text>flushing any instruction groups dispatched including and after said instruction group which contains said alternate interruptible instruction; </claim-text>\n<claim-text>restoring said deep-pipelined processor to a processor state recorded for the instruction group prior to said instruction group containing said alternate interruptible instruction; </claim-text>\n<claim-text>re-fetching said instruction group which contains said alternate interruptible instruction; and </claim-text>\n<claim-text>determining if said alternative interruptible instruction is to be re-executed; </claim-text>\n<claim-text>means for re-dispatching said re-fetched instruction group into two instruction groups where said alternate interruptible instruction is the first instruction of a second instruction group, in response to determining that said alternate interruptible instruction is to be re-executed; </claim-text>\n<claim-text>means for re-dispatching said re-fetched instruction group into two instruction groups where said alternate interruptible instruction is the last instruction of a first instruction group, </claim-text>\n</claim-text>\n<claim-text>in response to determining that said alternate interruptible instruction is not to be re-executed; and </claim-text>\n<claim-text>means for setting said processor state prior to said second group.</claim-text>\n</claim-text>\n</claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES15870985\">\n<?BRFSUM description=\"Brief Summary\" end=\"lead\"?>\n<h4>BACKGROUND OF THE INVENTION</h4>\n<p num=\"p-0002\">1. Field of the Invention</p>\n<p num=\"p-0003\">The present invention relates in general to an improved data processing system and in particular to an improved system and method for increasing the efficiency of execution of a processor in restoring a state of the processor. Still more particularly, the present invention relates to an improved system and method for restoring a pipelined processor to the proper state after a branch which is mispredicted where the restoration does not degrade the performance of the processor and where instructions within the improved data processing system are tracked in groups.</p>\n<p num=\"p-0004\">2. Description of the Related Art</p>\n<p num=\"p-0005\">High performance processors currently utilized in data processing systems today may be capable of \u201csuperscalar\u201d operation and may have \u201cpipelined elements.\u201d A superscalar processor has multiple elements which operate in parallel to process multiple instructions in a single processing cycle. Pipelining involves processing instructions in stages, so that the pipelined stages may process a number of instructions concurrently. In these high performance microprocessors, it is also advantageous to support speculative execution of instructions using branch prediction mechanisms, out-of order execution, and multiple pipelines in order to increase the number of instructions being processed at one time.</p>\n<p num=\"p-0006\">While instructions may be originally prepared to be processed in some logical programmed sequence, it should be understood that the instructions may be processed, in some respects, in a different sequence through speculative execution. However, since instructions are not totally independent of one another, complications may arise. Furthermore, if one instruction is dependent on a first instruction and the instructions are to be processed concurrently or the dependent instruction is to be processed before the first instruction, an assumption must be made regarding the result produced by the first instruction.</p>\n<p num=\"p-0007\">If an assumption used for processing an instruction proves to be incorrect then the result produced by the processing of the instruction will almost certainly be incorrect. Therefore, the pipeline must be flushed of all instructions after the instruction for which the assumption is made and the processor state must recover to a state with known correct results up to the instruction for which the assumption is made. (Herein, an instruction for which an assumption has been made is referred to as an \u201cinterruptible instruction,\u201d and the determination that an assumption is incorrect, triggering the need for the processor state to recover to a prior state, is referred to as an \u201cinterruption\u201d or an \u201cinterrupt point.\u201d) For example, when a branch instruction is speculatively executed, but is mispredicted, an interruption occurs and the processor needs to return to the state of the branch instruction and abandon any instructions or results executed thereafter. Moreover, in addition to the previous example, there are other events which may occur which require recovery of the processor state due to an interrupt.</p>\n<p num=\"p-0008\">A completion table or re-order buffer is known for saving a processor state before an interruptible instruction so that if an interrupt does occur, the completion table control logic may recover the processor state to the interrupt point. In a shallow-pipelined processor, saving the state of each interruptible instruction within the pipeline is relatively easy and many such methods have been developed. However, in a deep-pipelined processor, the number of available pipeline stages is increased, whereby the number of possible active instructions is increased. Saving the state of each interruptible instruction in the same manner as for shallow-pipelines would require a much larger set of state information with greater complexity for restoration. In addition, in microprocessors which allow multiple branch predictions at one time, the complexity of storing the state information needed to restore the processor state increases dramatically as the number of positions in a pipeline increases.</p>\n<p num=\"p-0009\">In keeping a record in the completion table for each instruction, a large number of records are created without ever being utilized and the space utilized to store the groups of records is inefficient. For example, in order to keep track of N active instructions with a maximum of M instructions dispatched per cycle, it would be necessary to create M records to be saved during the dispatch cycle. Furthermore, N state records must be kept so that the state of the processor can be restored when an interrupt occurs. When M and N grow in wide dispatch and deep-pipelined processors, the complexity to create, manage and retrieve records has a negative impact on the high frequency ability of the microprocessor.</p>\n<p num=\"p-0010\">There is a need for a method of bookkeeping for a deep-pipelined processor such that the number of records and complexity thereof is reduced. In addition, for such a method, it is desirable that a deep-pipeline processor may be utilized without the performance of the microprocessor being degraded due to branch and other interruptible instructions in speculative execution. Furthermore, for such a method, it is desirable that in particular, in the event of a branch misprediction or other such interruptible instructions for which a fast restoration time is desired, the pipeline is quickly flushed and the processor restored to the proper state before the branch misprediction occurred.</p>\n<h4>SUMMARY OF THE INVENTION</h4>\n<p num=\"p-0011\">It is therefore one object of the present invention to provide an improved data processing system.</p>\n<p num=\"p-0012\">It is another object of the present invention to provide an improved method and system increasing the efficiency of a processor for restoring a state of the processor.</p>\n<p num=\"p-0013\">It is yet another object of the present invention to provide an improved system and method for restoring a pipelined processor to the proper state after a branch that is mispredicted where the restoration does not degrade the performance of a microprocessor and where instructions within the improved data processing system are tracked in groups.</p>\n<p num=\"p-0014\">The foregoing objects are achieved as is now described. A method and system for increasing the efficiency of execution in a processor are provided. Instructions are dispatched in instruction groups, wherein if such an instruction group contains an interruptible instruction of a selected type, only one interruptible instruction of the selected type is included in the instruction group. A state of the processor is recorded, associated respectively with each of said dispatched instruction groups. The processor is restored to the recorded state associated with the instruction group containing the interruptible instruction of the selected type causing an interrupt, in response to the interrupt from one of the interruptible instructions of the selected type.</p>\n<?BRFSUM description=\"Brief Summary\" end=\"tail\"?>\n<?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?>\n<description-of-drawings>\n<h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4>\n<p num=\"p-0015\">The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objects and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:</p>\n<p num=\"p-0016\"><figref idrefs=\"DRAWINGS\">FIG. 1</figref> illustrates a block diagram of a processor for processing data in accordance with the present invention;</p>\n<p num=\"p-0017\"><figref idrefs=\"DRAWINGS\">FIG. 2</figref> depicts an example of a speculative instruction path for the microprocessor of the present invention;</p>\n<p num=\"p-0018\"><figref idrefs=\"DRAWINGS\">FIG. 3</figref> illustrates a pictorial illustration of a pipeline containing multiple instructions in multiple states of execution;</p>\n<p num=\"p-0019\"><figref idrefs=\"DRAWINGS\">FIG. 4</figref> depicts a pictorial illustration of a pipeline after a branch misprediction;</p>\n<p num=\"p-0020\"><figref idrefs=\"DRAWINGS\">FIG. 5</figref> is a high level logic flowchart illustrating the process of storing a processor state for each instruction group;</p>\n<p num=\"p-0021\"><figref idrefs=\"DRAWINGS\">FIG. 6</figref> is a high level logic flowchart depicting the process of flushing and restoring a pipeline when a branch misprediction occurs as depicted in <figref idrefs=\"DRAWINGS\">FIG. 4</figref>;</p>\n<p num=\"p-0022\"><figref idrefs=\"DRAWINGS\">FIG. 7</figref> illustrates a pictorial illustration of a pipeline containing multiple instructions in multiple states of execution;</p>\n<p num=\"p-0023\"><figref idrefs=\"DRAWINGS\">FIG. 8</figref> depicts a pictorial illustration of the pipeline of <figref idrefs=\"DRAWINGS\">FIG. 7</figref> where instruction groups have been flushed by the pipeline due to the execution of instruction x;</p>\n<p num=\"p-0024\"><figref idrefs=\"DRAWINGS\">FIG. 9</figref> illustrates a pictorial illustration of the pipeline of <figref idrefs=\"DRAWINGS\">FIG. 7</figref> where an instruction group is redispatched into two new record groups;</p>\n<p num=\"p-0025\"><figref idrefs=\"DRAWINGS\">FIG. 10</figref> depicts a pictorial illustration of the pipeline of <figref idrefs=\"DRAWINGS\">FIG. 7</figref> where an instruction group of the two new instruction groups of <figref idrefs=\"DRAWINGS\">FIG. 9</figref> has been flushed from the pipeline; and</p>\n<p num=\"p-0026\"><figref idrefs=\"DRAWINGS\">FIG. 11</figref> is a high level logic flowchart illustrating a process for flushing instructions from a pipeline and restoring the pipeline to the proper processor state following an interruption caused by an interruptible instruction other than the selected type of interruptible instruction.</p>\n</description-of-drawings>\n<?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?>\n<?DETDESC description=\"Detailed Description\" end=\"lead\"?>\n<h4>DESCRIPTION OF THE PREFERRED EMBODIMENT</h4>\n<p num=\"p-0027\">With reference now to the figures and in particular with reference to <figref idrefs=\"DRAWINGS\">FIG. 1</figref>, there is depicted a block diagram of a processor, indicated generally at <b>10</b>, for processing data in accordance with the present invention. In the depicted illustrative embodiment, processor <b>10</b> comprises a single integrated circuit superscalar microprocessor capable of executing multiple instructions per processor cycle. For the present embodiment of the invention, the selected type of interruptible instructions illustrated which require fast restoration time are branch instructions. However, in other embodiments alternate types of interruptible instructions which require fast restoration time may be selected. Accordingly, as discussed further below, processor <b>10</b> includes various execution units, registers, buffers, memories, and other functional units, which are all formed by integrated circuitry. In a preferred embodiment of the present invention, processor <b>10</b> comprises one of the PowerPC\u2122 line of microprocessors or other deep-pipelined processors. However, those skilled in the art will appreciate from the following description that the present invention can advantageously be implemented within other suitable processors, particularly those which provide a substantial amount of pipeline stages.</p>\n<p num=\"p-0028\">As illustrated in <figref idrefs=\"DRAWINGS\">FIG. 1</figref>, processor <b>10</b> is coupled to bus <b>11</b> via a bus interface unit (BIU) <b>12</b> within processor <b>10</b>. BIU <b>12</b> controls the transfer of information between processor <b>10</b> and other devices coupled to bus <b>11</b>, such as a lower level cache or main memory (not illustrated), which together with processor <b>10</b> and bus <b>11</b> form a fully functional data processing system. BIU <b>12</b> is also connected to instruction cache <b>14</b> and data cache <b>16</b> within processor <b>10</b>. High-speed caches, such as instruction cache <b>14</b> and data cache <b>16</b>, enable processor <b>10</b> to achieve relatively fast access times to a subset of data or instructions previously transferred from lower level memory to caches <b>14</b> and <b>16</b>, thus improving the overall performance of the data processing system. Instruction cache <b>14</b> is further connected to sequential fetcher <b>17</b>, which fetches up to a cache line of instructions from instruction cache <b>14</b> during each cycle and transmits the fetched instructions to both branch processing unit (BPU) <b>18</b> and instruction queue <b>19</b>. Branch instructions are retained by BPU <b>18</b> for execution and are cancelled from instruction queue <b>19</b>; sequential instructions, on the other hand, are cancelled from BPU <b>18</b> and buffered within instruction queue <b>19</b> for subsequent execution by sequential instruction execution circuitry within processor <b>10</b>.</p>\n<p num=\"p-0029\">In the depicted illustrative embodiment, in addition to BPU <b>18</b>, the execution circuitry of processor <b>10</b> comprises multiple execution units for sequential instructions, including one or more integer units (IUs) <b>22</b>, a load-store unit (LSU) <b>28</b>, and a floating-point unit (FPU) <b>30</b>. As is well-known to those skilled in the computer arts, each of execution units <b>22</b>, <b>28</b>, and <b>30</b> typically executes one or more instructions of a particular type of sequential instructions during each processor cycle. For example, IU(s) <b>22</b> perform integer mathematical and logical operations such as addition, subtraction, ANDing, ORing, and XORing, utilizing source operands received from specified general purpose registers (GPRs) <b>32</b> or GPR rename buffers <b>33</b>. Following the execution of an integer instruction, IU <b>22</b> outputs the data results of the instruction to GPR rename buffers <b>33</b>, which provide temporary storage for the result data until the result data is written from GPR rename buffers <b>33</b> to one or more of GPRs <b>32</b>. FPU <b>30</b> typically performs single and double-precision floating-point arithmetic and logical operations, such as floating-point multiplication and division, on source operands received from floating-point registers (FPRs) <b>36</b> or FPR rename buffers <b>37</b>. FPU <b>30</b> outputs data resulting from the execution of floating-point instructions to selected FPR rename buffers <b>37</b>, which temporarily store the result data until the result data is written from FPR rename buffers <b>37</b> to selected FPRs <b>36</b>. As its name implies, LSU <b>28</b> typically executes floating-point and fixed-point instructions which either load data from memory (i.e., either data cache <b>16</b> or main memory) into selected GPRs <b>32</b> or FPRs <b>36</b> or which store data from a selected one of GPRs <b>32</b>, GPR rename buffers <b>33</b>, FPRs <b>36</b>, or FPR rename buffers <b>37</b> to memory.</p>\n<p num=\"p-0030\">Processor <b>10</b> employs both pipelining and out-of-order execution of instructions to further improve the performance of its superscalar architecture. Accordingly, instructions can be executed opportunistically by IUs <b>22</b>, CCU <b>24</b>, LSU <b>28</b>, and FPU <b>30</b> in any order as long as data dependencies and antidependencies are observed. In addition, as is typical of many high-performance processors, each instruction is processed at a number of pipeline stages, including fetch, decode/dispatch, execute, finish, and completion/writeback.</p>\n<p num=\"p-0031\">During the fetch stage, sequential fetcher <b>17</b> retrieves up to a cache line of instructions from instruction cache <b>14</b>. As noted above, sequential instructions fetched from instruction cache <b>14</b> are buffered within instruction queue <b>19</b>, while branch instructions are removed (folded out) from the sequential instruction stream. Branch instructions are processed at each of the remaining pipeline stages by circuitry within BPU <b>18</b>.</p>\n<p num=\"p-0032\">During the decode/dispatch stage, dispatch unit <b>20</b> decodes and dispatches one or more sequential instructions from instruction queue <b>19</b> to execution units <b>22</b>, <b>24</b>, <b>28</b>, and <b>30</b>. In particular, during the decode stage the instruction is decoded into different control bits, which in general designate: i) a type of functional unit for performing the operation specified by the instruction; ii) source operands for the instruction; iii) destinations for results of operations. During the decode/dispatch stage, dispatch unit <b>20</b> also allocates a rename buffer within GPR rename buffers <b>33</b> or FPR rename buffers <b>37</b> for each dispatched instruction's result data, if necessary. In the depicted illustrative embodiment, instructions dispatched by dispatch unit <b>20</b> are also passed to a completion buffer within completion unit <b>40</b>. Processor <b>10</b> tracks the program order of the dispatched instructions during out-of-order execution utilizing unique instruction identifiers associated with the instructions in the completion buffer of completion unit <b>40</b>. In addition, during the decode/dispatch stage, a processor state record may be made in the completion buffer of completion unit <b>40</b>.</p>\n<p num=\"p-0033\">During the execute stage, execution units <b>22</b>, <b>24</b>, <b>28</b>, and <b>30</b> execute sequential instructions received from dispatch unit <b>20</b> opportunistically as operands and execution resources for the indicated operations become available. Each of execution units <b>22</b>, <b>24</b>, <b>28</b>, and <b>30</b> are preferably equipped with a reservation station that stores instructions dispatched to that execution unit until operands or execution resources become available. After execution of an instruction has terminated, execution units <b>22</b>, <b>28</b>, and <b>30</b> store data results of the instruction within either GPR rename buffers <b>33</b> or FPR rename buffers <b>37</b>, depending upon the instruction type. CCU <b>24</b>, on the other hand, stores the condition code bits it generates within the condition code field of one of CR rename buffers <b>46</b>.</p>\n<p num=\"p-0034\">Next, execution units <b>22</b>, <b>24</b>, <b>28</b>, and <b>30</b> notify completion unit <b>40</b> which instructions stored within the completion buffer of completion unit <b>40</b> have finished execution. Instructions are then completed by completion unit <b>40</b> in program order by marking the instructions as complete in the completion buffer. Thereafter, during the writeback stage, which is preferably merged with the completion stage, the results of the instructions are transferred from a CR rename buffer <b>46</b> to CR <b>44</b> and from GPR rename buffers <b>33</b> and FPR rename buffers <b>37</b> to GPRs <b>32</b> and FPRs <b>36</b>, respectively.</p>\n<p num=\"p-0035\">Referring now to <figref idrefs=\"DRAWINGS\">FIG. 2</figref>, there is depicted an example of a speculative instruction path for the microprocessor of the present invention. Upon dispatch from the dispatch unit, instructions are assigned an instruction identifier (IID) that is maintained in association with the issued instruction until the instruction is completed. As illustrated in <figref idrefs=\"DRAWINGS\">FIG. 2</figref>, eight speculative instructions have been issued IIDs 1-8. Instruction 3 and instruction 6 are branch instructions that modify the link or count registers. Each instruction 1-8 belongs to a speculative instruction path in the instruction stream executed by the microprocessor. Instructions 1-3 lie within speculative instruction path A. Instruction 3 is a branch instruction which branches the instruction stream into speculative path B. If the branch had not been taken an interrupt would occur and the instruction sequence would continue along instruction path A to the subsequent instructions in leg A\u2032 of path A. Instructions 4-6 comprise speculative instruction path B. Instruction 6 is a branch instruction that branches the instruction sequence to speculative path C. Speculative instruction path C includes instructions 7 and 8. If the branch at instruction 6 had not been taken, an interrupt would occur and the instruction sequence would continue along speculative instruction path B to execute subsequent instructions in leg B\u2032 of speculative path B. In addition, instructions 1, 2, 4, 5, 7 and 8 may be interruptible instructions other than branch instructions whereby an interrupt would disrupt the path sequence.</p>\n<p num=\"p-0036\">With reference now to <figref idrefs=\"DRAWINGS\">FIG. 3</figref>, there is illustrated a pictorial illustration of pipeline <b>70</b> containing multiple instructions in multiple states of execution. The instructions are dispatched in the order indicated by the arrow illustrated at reference numeral <b>71</b>.</p>\n<p num=\"p-0037\">Multiple instructions are depicted in instruction groups where each instruction group contains a maximum of N instructions where N is the maximum number of instructions dispatched per cycle by dispatch unit <b>20</b>. Each instruction group is represented by a single record of the state of the processor following the last instruction dispatched in the group. In the present example, pipeline <b>70</b> contains instruction group I as illustrated at reference numeral <b>72</b>, instruction group I+1 as depicted at reference numeral <b>74</b> and instruction group I+2 as illustrated at reference numeral <b>76</b>. The processor state record for instruction group I is recorded as R1. Next, the processor state for instruction group I+1 is recorded as R2. Finally, the processor state for instruction group I+2 is recorded as R3. For the present example, it is assumed that instruction group I+I is the guessed path from branch instruction <b>78</b> and that instruction group I+2 is the guessed path from the branch instruction of instruction group I+1.</p>\n<p num=\"p-0038\">Also in the example depicted, any branch instructions are ordered at the end of an instruction group, whereby the state of the processor after the branch instruction is recorded as the processor state record. For example, branch instruction <b>78</b> is the last instruction in instruction group I.</p>\n<p num=\"p-0039\">By the present invention, the processor state may be quickly restored when it is discovered that a branch instruction has been mispredicted, thus restoring the processor state to that of the mispredicted branch instruction, as will be further depicted.</p>\n<p num=\"p-0040\">The order of instructions dispatched per cycle in the instruction groups is determined in order to favor instructions that would most likely cause an interruption. In particular, a type of interruptible instruction to be favored is selected and ordered. From program running time statistics, branch instructions are most likely to cause an interruption due to branch misprediction. From the example illustrated in <figref idrefs=\"DRAWINGS\">FIG. 2</figref>, it is evident that if a branch or multiple branches are speculatively executed and then found to be mispredicted, in order to take the proper path, the speculatively executed instructions must be abandoned and the processor state returned to the branch instruction in order to take the correct path.</p>\n<p num=\"p-0041\">In the present embodiment, since branch instructions are most likely to cause an interruption and the processor state can be easily recovered to the last instruction of an instruction group, one branch instruction may be dispatched at the end of each instruction group, wherein the selected type of instruction is a branch instruction. In alternate embodiments, other high frequency flush instructions, such as load and store instructions, may be determined as the selected type of interruptible instruction to be distributed to the end of each instruction group.</p>\n<p num=\"p-0042\">Referring now to <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, there is depicted a pictorial illustration of pipeline <b>70</b> after an interruption due to a branch misprediction of branch instruction <b>78</b>. As illustrated at reference numeral <b>80</b>, all instructions recorded after processor state R1 are flushed from the pipeline. In addition, the pipeline is returned to the processor state R1. Thereafter, new instruction groups are dispatched to pipeline <b>70</b> and the processor executes these instructions within pipeline <b>70</b> from the processor state following the branch instruction.</p>\n<p num=\"p-0043\">In addition, <figref idrefs=\"DRAWINGS\">FIG. 4</figref> depicts the importance of placement of the selected type of interruptible instruction, which is a branch instruction in the present example. If other instructions followed branch instruction <b>78</b> within instruction group I, upon a misprediction, the processor state would not return to the branch instruction. For example, consider instruction group I including the following instructions in order: \u201cinst\u201d, \u201cinst\u201d, \u201cbranch instruction <b>78</b>, \u201cinst\u201d, and \u201cinst\u201d, where branch instruction <b>78</b> is the selected type of interruptible instruction and the processor state R1 for instruction group I is recorded after the last \u201cinst\u201d. Instruction groups I+1 and I+2 are dispatched as the predicted path from the branch instruction. In this case, in the event of a misprediction from the branch instruction, the processor state would be returned to the last \u201cinst\u201d instruction in instruction group I. However, these \u201cinst\u201d instructions following the branch instruction should also be flushed to recover the processor state after the branch instruction.</p>\n<p num=\"p-0044\">With reference now to <figref idrefs=\"DRAWINGS\">FIG. 5</figref>, there is illustrated a high level logic flowchart illustrating the process of storing the processor state for each instruction group. As depicted, the process starts at block <b>80</b> and thereafter proceeds to block <b>81</b>. Block <b>81</b> illustrates fetching a group of instructions from the instruction cache. Thereafter, block <b>82</b> depicts searching N instructions for the branch instruction. Preferably, the fetched instruction group contains a number of instructions greater than N where N is the maximum number of instructions which may be dispatched during a single cycle. Further, since the branch instruction is the selected type of interruptible instruction with a fast restoration time, the branch instruction is the instruction searched for in block <b>82</b>.</p>\n<p num=\"p-0045\">Next, block <b>83</b> illustrates a determination of whether there is a branch instruction within the N instructions. If there is not a branch instruction, the process passes to block <b>84</b>. Block <b>84</b> depicts dispatching the group of N instructions. By the process, it is not necessary to include an interruptible instruction of the selected type in an instruction group. If there is a branch instruction in the N instructions, the process passes to block <b>85</b>. Block <b>85</b> illustrates dispatching a group of instructions up to and including the first branch instruction within the N instructions. Thereby, branch instructions are always the last instruction dispatched within a group if there is a branch instruction to be dispatched and only one branch instruction is included in a single instruction group. Furthermore, if an interruptible instruction other than a branch instruction is the selected type of interruptible instruction, that interruptible instruction would follow the same process above as depicted for the branch instruction.</p>\n<p num=\"p-0046\">From either block <b>84</b> or block <b>85</b>, the process passes to block <b>86</b>. Block <b>86</b> illustrates the recordation of the processor state. Next, block <b>88</b> depicts a determination of whether all the fetched instructions have been dispatched. If all the fetched instructions have been dispatched, the process passes to block <b>81</b>. If all the fetched instructions have not been dispatched, the process passes to block <b>82</b>.</p>\n<p num=\"p-0047\">Referring now to <figref idrefs=\"DRAWINGS\">FIG. 6</figref>, there is depicted a high level logic flowchart illustrating flushing and restoring a pipeline when an interruption due to a branch misprediction occurs as depicted in FIG. <b>4</b>. As illustrated, the process starts at block <b>90</b> as an interrupt when a branch misprediction occurs. Thereafter, block <b>92</b> depicts locating the state of the processor occurring just after the branch instruction was mispredicted. In particular, the state of the processor recorded for the instruction group causing the interruption, is located. Next, block <b>94</b> illustrates flushing of all instructions included in instruction groups following the located processor state. Thereafter, block <b>96</b> depicts setting the current processor state to the located processor state whereafter the process returns. In particular, in the example illustrated, since the recorded processor state is the state of the last instruction which is a branch instruction, the state of the branch instruction is always readily available for fast restoration when a branch misprediction occurs.</p>\n<p num=\"p-0048\">Referring now to <figref idrefs=\"DRAWINGS\">FIG. 7</figref>, there is depicted a pictorial illustration of a pipeline <b>100</b> containing multiple instructions in multiple states of execution. Instruction groups of instructions are illustrated at reference numerals <b>102</b>, <b>104</b> and <b>106</b>. The size of the instruction groups and recordation thereof is similar to the method described in <figref idrefs=\"DRAWINGS\">FIG. 3. A</figref> state record R4 is recorded after dispatching instruction group I. Next, a state record R5 is recorded after dispatching instruction group I+1. Thereafter, a state record R6 is recorded after dispatching instruction group I+2. In the particular example, instruction X illustrated at reference numeral <b>108</b> is an interruptible instruction in which an interrupt is initiated during execution in order to re-execute instruction X. Furthermore, instruction X is not a branch instruction and is dispatched in the middle of the group, thus the processor state corresponding to instruction X is not available for fast restoration.</p>\n<p num=\"p-0049\">With reference now to <figref idrefs=\"DRAWINGS\">FIG. 8</figref>, there is illustrated a pictorial illustration of pipeline <b>100</b> where instruction groups I+1 and I+2 have been flushed by pipeline <b>100</b> due to the execution of instruction X. In addition, the processor state returns to R4 which is the processor state prior to the execution of instruction group I+1.</p>\n<p num=\"p-0050\">Referring now to <figref idrefs=\"DRAWINGS\">FIG. 9</figref>, there is depicted a pictorial illustration of pipeline <b>100</b> where instruction group I+1 is redispatched into two new instruction groups. An instruction group I+1(a) is illustrated at reference numeral <b>112</b> containing instructions Z and Y which were executed prior to instruction X. After the dispatching of instruction group I+1(a) a processor state R7 is recorded. In addition, an instruction group I+1(b) is depicted at reference numeral <b>114</b> containing instruction X and all instructions following thereafter from the previous instruction group I+1. A processor state RB is recorded after instruction group I+1(b).</p>\n<p num=\"p-0051\">With reference now to <figref idrefs=\"DRAWINGS\">FIG. 10</figref>, there is illustrated a pictorial illustration of pipeline <b>100</b> where instruction group I+1(b) has been flushed from pipeline <b>100</b>. For instruction X, upon execution, instruction X is flushed. In addition, in the present example, the processor state is restored to R7.</p>\n<p num=\"p-0052\">Referring now to <figref idrefs=\"DRAWINGS\">FIG. 11</figref>, there is depicted a high level logic flowchart illustrating a process for flushing instructions from a pipeline and restoring the pipeline to the proper processor state following an interruption caused by an interruptible instruction other than the selected type of interruptible instruction. As illustrated, the process starts at block <b>120</b> whenever an instruction other than a branch instruction causes an interruption. Thereafter, block <b>122</b> depicts flushing all instructions included in instructions groups including and following the instruction causing the interruption. Next, block <b>124</b> illustrates refetching the instruction group containing the instruction causing the interruption. Thereafter, block <b>126</b> depicts a determination of whether or not the instruction causing the interruption is to be re-executed. If the instruction is to be re-executed, the process passes to block <b>128</b>. However, if the instruction is not to be re-executed, the process passes to block <b>132</b>.</p>\n<p num=\"p-0053\">Block <b>128</b> illustrates re-dispatching the fetched instruction group into two instruction groups where the instruction causing the interruption is the first instruction of the second instruction group. Thereafter, block <b>130</b> depicts setting the current processor state to the end of the first re-dispatched group such that when the process returns, the instruction that caused the interruption will be re-executed.</p>\n<p num=\"p-0054\">Block <b>132</b> depicts re-dispatching the fetched instruction group into two instruction groups where the instruction causing the interruption is the last instruction in the first group. Thereafter, block <b>134</b> illustrates setting the current processor state to the end of the first re-dispatched group such that when the processor returns, the instruction following the instruction that caused the interruption will be executed.</p>\n<p num=\"p-0055\">While the invention has been particularly shown and described with reference to a preferred embodiment, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. For example, while the selected type of interruptible instruction is depicted being dispatched at the tail of an instruction group in the previous description, the selected type of interruptible instruction may alternatively be dispatched at the head of an instruction group and the processor state prior to dispatch associated with the instruction group. By dispatching a selected type of interruptible instruction at the head of an instruction group and associating the processor state recorded prior to dispatch, the processor state occurring prior to the selected type of interruptible instruction is easily recovered.</p>\n<p num=\"p-0056\">In addition, in an alternate embodiment, if an alternate type of instruction happens to be dispatched at the head or tail of an instruction group and causes an interrupt, the fast recovery method similar to that depicted in <figref idrefs=\"DRAWINGS\">FIG. 6</figref> may be utilized to recover the processor state in lieu of the process depicted in FIG. <b>11</b>. For example, if an instruction group includes instructions load0, load1, load2 and load3 and the instruction load0 has an exception, it is preferable to recover the processor state prior to the instruction load0. In such a case, the processor state associated with the instruction group prior to the instruction group causing the exception would be recovered. Alternatively, if the instruction load3 causes an exception and it is preferable to recover the processor state just after the load3 instruction, then the processor state would be recovered as described in <figref idrefs=\"DRAWINGS\">FIG. 6</figref> for an instruction other than a branch instruction.</p>\n<?DETDESC description=\"Detailed Description\" end=\"tail\"?>\n</description>"}], "inventors": [{"first_name": "Hoichi", "last_name": "Cheong", "name": ""}, {"first_name": "Hung Qui", "last_name": "Le", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTERNATIONAL BUSINESS MACHINES CORPORATION"}, {"first_name": "", "last_name": "INTERNATIONAL BUSINESS MACHINES CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  15/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  15/00        20060101A I20051110RMEP"}, {"label": "G06F   9/38        20060101A I20070721RMEP"}], "national_classes": [{"primary": true, "label": "712228"}, {"primary": false, "label": "712E09061"}, {"primary": false, "label": "712239"}, {"primary": false, "label": "712206"}], "ecla_classes": [{"label": "G06F   9/38H2"}], "cpc_classes": [{"label": "G06F   9/3863"}, {"label": "G06F   9/3863"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1999-06-14", "application_date": "1999-06-14", "family_members": [{"ucid": "US-6898696-B1", "titles": [{"lang": "EN", "text": "Method and system for efficiently restoring a processor's execution state following an interrupt caused by an interruptible instruction"}]}]}