{"patent_number": "US-6289433-B1", "publication_id": 72798445, "family_id": 25333867, "publication_date": "2001-09-11", "titles": [{"lang": "EN", "text": "Superscalar RISC instruction scheduling"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11245761\" source=\"national office\"><p>A register renaming system for out-of-order execution of a set of reduced instruction set computer instructions having addressable source and destination register fields, adapted for use in a computer having an instruction execution unit with a register file accessed by read address ports and for storing instruction operands. A data dependence check circuit is included for determining data dependencies between the instructions. A tag assignment circuit generates one of more tags to specify the location of operands, based on the data dependencies determined by the data dependence check circuit. A set of register file port multiplexers select the tags generated by the tag assignment circuit and pass the tags onto the read address ports of the register file for storing execution results.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72613678\"><p>A register renaming system for out-of-order execution of a set of reduced instruction set computer instructions having addressable source and destination register fields, adapted for use in a computer having an instruction execution unit with a register file accessed by read address ports and for storing instruction operands. A data dependence check circuit is included for determining data dependencies between the instructions. A tag assignment circuit generates one of more tags to specify the location of operands, based on the data dependencies determined by the data dependence check circuit. A set of register file port multiplexers select the tags generated by the tag assignment circuit and pass the tags onto the read address ports of the register file for storing execution results.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00001\" num=\"1\"><claim-text>1. A system for register renaming in a computer system capable of out-of-order instruction execution, comprising:</claim-text><claim-text>a temporary buffer comprising a plurality of storage locations for storing execution results, wherein an execution result for an instruction in an instruction window is stored at one of said plurality of storage locations, said one of said plurality of storage locations being assigned to said instruction in said instruction window; and </claim-text><claim-text>tag assignment logic for receiving data dependency results from a data dependency checker and for outputting a tag comprising a temporary buffer storage location address in place of a register address for an operand of a first instruction, wherein said temporary buffer storage location address is an address of said operand in one of said plurality of storage locations if said first instruction is dependent on a previous one of said plurality of instructions in said instruction window for said operand. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00002\" num=\"2\"><claim-text>2. The register renaming system of claim <b>1</b>, further comprising termination logic that transfers the execution results in said plurality of storage locations in said temporary buffer to register file locations in-order based on the order of instructions in said instruction window.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00003\" num=\"3\"><claim-text>3. The register renaming system of claim <b>2</b>, wherein said termination logic transfers a plurality of execution results from said temporary buffer to said register file simultaneously.</claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00004\" num=\"4\"><claim-text>4. The register renaming system of claim <b>3</b>, wherein said termination logic transfers an execution result for an instruction from said temporary buffer to said register file when all execution results for all prior instructions are retirable.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00005\" num=\"5\"><claim-text>5. The register renaming system of claim <b>1</b>, wherein said tag further comprises a 1-bit identifier that indicates whether said address within said tag is an address within a register file or within said plurality of storage locations.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00006\" num=\"6\"><claim-text>6. The register renaming system of claim <b>1</b>, further comprising register file port MUXes that pass said tags to read address ports of said temporary buffer for accessing said instruction execution results.</claim-text></claim>"}, {"num": 7, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00007\" num=\"7\"><claim-text>7. A computer system, comprising:</claim-text><claim-text>a memory unit for storing program instructions; </claim-text><claim-text>a bus coupled to said memory unit for retrieving said program instructions; and </claim-text><claim-text>a processor coupled to said bus, wherein said processor comprises a register renaming system, comprising: </claim-text><claim-text>a temporary buffer comprising a plurality of storage locations for storing execution results, wherein an execution result for an instruction in an instruction window is stored at one of said plurality of storage locations, said one of said plurality of storage locations being assigned to said instruction in said instruction window; and </claim-text><claim-text>tag assignment logic that receives data dependency results from a data dependency checker and outputs a temporary buffer storage location address in place of a register address for an operand of a first instruction if said first instruction is dependent on a previous one of said plurality of instructions in said instruction window for said operand, wherein said temporary buffer storage location address is an address of said operand in one of said plurality of storage locations. </claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00008\" num=\"8\"><claim-text>8. The computer system of claim <b>7</b>, wherein said processor further comprises termination logic that transfers the execution results in said plurality of storage locations in said temporary buffer to register file locations in-order based on the order of instructions in said instruction window.</claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00009\" num=\"9\"><claim-text>9. The computer system of claim <b>8</b>, wherein said termination logic transfers a plurality of execution results from said temporary buffer to said register file simultaneously.</claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00010\" num=\"10\"><claim-text>10. The computer system of claim <b>9</b>, wherein said termination logic transfers an execution result for an instruction from said temporary buffer to said register file when all execution results for all prior instructions are retirable.</claim-text></claim>"}, {"num": 11, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00011\" num=\"11\"><claim-text>11. The computer system of claim <b>7</b>, wherein said tag comprises an address and a 1-bit identifier that indicates whether said address within said tag is an address within a register file or said plurality of storage locations.</claim-text></claim>"}, {"num": 12, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00012\" num=\"12\"><claim-text>12. The computer system of claim <b>7</b>, wherein said processor further comprises register file port MUXes that pass said tag to read address ports of said temporary buffer for accessing said execution results.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00013\" num=\"13\"><claim-text>13. A register renaming method, comprising the steps of:</claim-text><claim-text>(1) storing, in a temporary buffer, out-of-order execution results in storage locations assigned to instructions in an instruction window; </claim-text><claim-text>(2) generating at least one tag to specify an address in said temporary buffer at which said out-of-order execution results are temporarily stored; and </claim-text><claim-text>(3) outputting one of said at least one tag comprising an address in place of a register address for an operand of a first instruction if a data dependency result indicates that said first instruction is dependent on a previous instruction in said instruction window, wherein said tag comprises an address of said operand in said temporary buffer. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00014\" num=\"14\"><claim-text>14. The register renaming method of claim <b>13</b>, further comprising the step of transferring said out-of-order execution results in said temporary buffer to a register file in-order based on the order of instructions in said instruction window.</claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00015\" num=\"15\"><claim-text>15. The register renaming method of claim <b>14</b>, further comprising the step of transferring a plurality of execution results from said temporary buffer to said register file simultaneously.</claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00016\" num=\"16\"><claim-text>16. The register renaming method of claim <b>15</b>, further comprising the step of transferring an out-of-order execution result from said temporary buffer to said register file when all execution results for all prior instructions are retirable.</claim-text></claim>"}, {"num": 17, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00017\" num=\"17\"><claim-text>17. The register renaming method of claim <b>13</b>, further comprising the step of determining data dependencies between the instructions in said instruction window to produce said data dependency results.</claim-text></claim>"}, {"num": 18, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00018\" num=\"18\"><claim-text>18. The register renaming method of claim <b>13</b>, wherein said step (2) further comprises the step of generating tags that comprise an address and a 1-bit identifier that indicates whether said address within said tags is an address within a register file or said temporary buffer.</claim-text></claim>"}, {"num": 19, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6289433-B1-CLM-00019\" num=\"19\"><claim-text>19. The register renaming method of claim <b>13</b>, further comprising the step of passing said tags to read address ports of said temporary buffer for accessing said out-of-order execution results.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54725050\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This application is a continuation of appl. Ser. No. 08/990,414, filed Dec. 15, 1997, now U.S. Pat. No. 5,974,526, which is a continuation of appl. Ser. No. 08/594,401, filed Jan. 31, 1996, now U.S. Pat. No. 5,737,624, which is a continuation of appl. Ser. No. 08/219,425, filed Mar. 29, 1994, now U.S. Pat. No. 5,497,499 which is a continuation of appl. Ser. No. 07/860,719, filed Mar. 31, 1992 (status: abandoned).</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>CROSS-REFERENCE TO RELATED APPLICATIONS</h4><p>The following are commonly owned applications:</p><p>\u201cSemiconductor Floor Plan and Method for a Register Renaming Circuit\u201d, Ser. No. 04/860,718, concurrently filed with the present application, now U.S. Pat. No. 5,371,684;</p><p>\u201cHigh Performance RISC Microprocessor Architecture\u201d, Ser. No. 07/817,810, filed Jan. 8, 1992 now U.S. Pat. No. 5,539,911;</p><p>\u201cExtensible RISC Microprocessor Architecture\u201d, Ser. No. 07/817,809, filed Jan. 8, 1992, now abandoned.</p><p>The disclosures of the above applications are incorporated herein by reference.</p><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates to superscalar reduced instruction set computers (RISC), more particularly, the present invention relates to instruction scheduling including register renaming and instruction issuing for superscalar RISC computers.</p><p>2. Related Art</p><p>A more detailed description of some of the basic concepts discussed in this application is found in a number of references, including Mike Johnson, Superscalar Microprocessor Design (Prentice-Hall, Inc., Englewood Ciffs, N.J., 1991); John L. Hennessy et. al., Computer Architecture\u2014A Quantitative Approach\u201d (Morgan Kaufmann Publishers, Inc., San Mateo, Calif., 1990). Johnson's text, particularly Chapters 2, 6 and 7 provide an excellent discussion of the register renaming issues addressed by the present invention.</p><p>A major consideration in a superscalar RISC processor is to how to execute multiple instructions in parallel and out-of-order, without incurring data errors due to dependencies inherent in such execution. Data dependency checking, register renaming and instruction scheduling are integral aspects of the solution.</p><h4>Storage Conflicts and Register Renaming</h4><p>True dependencies (sometimes called \u201cflow dependencies\u201d or \u201cwrite-read\u201d dependencies) are often grouped with anti-dependencies (also called \u201cread-write\u201d dependencies) and output dependencies (also called \u201cwrite-write\u201d dependencies) into a single group of instruction dependencies. The reason for this grouping is that each of these dependencies manifests itself through use of registers or other storage locations. However, it is important to distinguish true dependencies from the other two. True dependencies represent the flow of data and information through a program. Anti- and output dependencies arise because, at different points in time, registers or other storage locations hold different values for different computations.</p><p>When instructions are issued in order and complete in order, there is a one-to-one correspondence between registers and values. At any given point in execution, a register identifier precisely identifies the value contained in the corresponding register. When instructions are issued out of order and complete out of order, correspondence between registers and values breaks down, and values conflict for registers. This problem is severe when the goal of register allocation is to keep as many values in as few registers as possible. Keeping a large number of values in a small number of registers creates a large number of conflicts when the execution order is changed from the order assumed by the register allocator.</p><p>Anti- and output dependencies are more properly called \u201cstorage conflicts\u201d because reusing storage locations (including registers) causes instructions to interfere with one another even though conflicting instructions are otherwise independent. Storage conflicts constrain instruction issue and reduce performance. But storage conflicts, like other resource conflicts, can be reduced or eliminated by duplicating the troublesome resource.</p><h4>Dependency Mechanisms</h4><p>Johnson also discusses in detail various dependency mechanisms, including: software, register renaming, register renaming with a reorder buffer, register renaming with a future buffer, interlocks, the copying of operands in the instruction window to avoid dependencies, and partial renaming.</p><p>A conventional hardware implementation relies on software to enforce dependencies between instructions. A compiler or other code generator can arrange the order of instructions so that the hardware cannot possibly see an instruction until it is free of true dependencies and storage conflicts. Unfortunately, this approach runs into several problems. Software does not always know the latency of processor operations, and thus, cannot always know how to arrange instructions to avoid dependencies. There is the question of how the software prevents the hardware from seeing an instruction until it is free of dependencies. In a scalar processor with low operation latencies, software can insert \u201cno-ops\u201d in the code to satisfy data dependencies without too much overhead. If the processor is attempting to fetch several instructions per cycle, or if some operations take several cycles to complete, the number of no-ops required to prevent the processor from seeing dependent instructions rapidly becomes excessive, causing an unacceptable increase in code size. The no-ops use a precious resource, the instruction cache, to encode dependencies between instructions.</p><p>When a processor permits out-of-order issue, it is not at all clear what mechanism software should use to enforce dependencies. Software has little control over the behavior of the processor, so it is hard to see how software prevents the processor from decoding dependent instructions. The second consideration is that no existing binary code for any scalar processor enforces the dependencies in a superscalar processor, because the mode of execution is very different in the superscalar processor. Relying on software to enforce dependencies requires that the code be regenerated for the superscalar processor. Finally, the dependencies in the code are directly determined by the latencies in the hardware, so that the best code for each version of a superscalar processor depends on the implementation of that version.</p><p>On the other hand, there is some motivation against hardware dependency techniques, because they are inherently complex. Assuming instructions with two input operands and one output value, as holds for typical RISC instructions, then there are five possible dependencies between any two instructions: two true dependencies, two anti-dependencies, and one output dependency. Furthermore, the number of dependencies between a group of instructions, such as a group of instructions in a window, varies with the square of the number of instructions in the group, because each instruction must be considered against every other instruction.</p><p>Complexity is further multiplied by the number of instructions that the processor attempts to decode, issue, and complete in a single cycle. These actions introduce dependencies. The only aid in reducing complexity is that the dependencies can be determined incrementally, over many cycles to help reduce the scope and complexity of the dependency hardware.</p><p>One technique for removing storage conflicts is by providing additional registers that are used to reestablish the correspondence between registers and values. The additional registers are conventionally allocated dynamically by hardware, and the registers are associated with values needed by the program using \u201cregister renaming.\u201d To implement register renaming, processors typically allocate a new register for every new value produced (i.e., for every instruction that writes a register). An instruction identifying the original register, for the purpose of reading its value, obtains instead the value in the newly allocated register. Thus, hardware renames the original register identifier in the instruction to identify the new register and correct value. The same register identifier in several different instructions may access different hardware registers, depending on the locations of register references with respect to register assignments.</p><p>Consider the following code sequence where \u201cop\u201d is an operation, \u201cRn\u201d represents a numbered register, and \u201c:=\u201d represents assignment:</p><p><maths><formula-text>R<b>3</b><i>b</i>:=R<b>3</b><i>a </i>op R<b>5</b><i>a</i>\u2003\u2003(1)</formula-text></maths></p><p><maths><formula-text>R<b>4</b><i>b</i>:=R<b>3</b><i>b </i>+1\u2003\u2003(2)</formula-text></maths></p><p><maths><formula-text>R<b>3</b><i>c</i>:=R<b>5</b><i>a </i>+1\u2003\u2003(3)</formula-text></maths></p><p><maths><formula-text>R<b>7</b><i>b</i>:=R<b>3</b><i>c </i>op R<b>4</b><i>b</i>\u2003\u2003(4)</formula-text></maths></p><p>Each assignment to a register creates a new \u201cinstance\u201d of the register, denoted by an alphabetic subscript. The creation of a new instance for R<b>3</b> in the third instruction avoids the anti- and output dependencies on the second and first instructions, respectively, and yet does not interfere with correctly supplying an operand to the fourth instruction. The assignment to R<b>3</b> in the third instruction supersedes the assignment to R<b>3</b> in the first instruction, causing R<b>3</b><i>c </i>to become the new R<b>3</b> seen by subsequent instructions until another instruction assigns a value to R<b>3</b>.</p><p>Hardware that performs renaming creates each new register instance and destroys the instance when its value is superseded and there are no outstanding references to the value. This removes anti- and output dependencies and allows more instruction parallelism. Registers are still reused, but reuse is in line with the requirements of parallel execution. This is particularly helpful with out-of-order issue, because storage conflicts introduce instruction issue constraints that are not really necessary to produce correct results. For example, in the preceding instruction sequence, renaming allows the third instruction to be issued immediately, whereas, without renaming, the instruction must be delayed until the first instruction is complete and the second instruction is issued.</p><p>Another technique for reducing dependencies is to associate a single bit (called a \u201cscoreboard bit\u201d) with each register. The scoreboard bit is used to indicate that a register has a pending update. When an instruction is decoded that will write a register, the processor sets the associated scoreboard bit. The scoreboard bit is reset when the write actually occurs. Because there is only one scoreboard bit indicating whether or not there is a pending update, there can be only one such update for each register. The scoreboard stalls instruction decoding if a decoded instruction will update a register that already has a pending update (indicated by the scoreboard bit being set). This avoids output dependencies by allowing only one pending update to a register at any given time.</p><p>Register renaming, in contrast, uses multiple-bit tags to identify the various uncomputed values, some of which values may be destined for the same processor register (that is, the same program-visible register). Conventional renaming requires hardware to allocate tags from a pool of available tags that are not currently associated with any value and requires hardware to free the tags to the pool once the values have been computed. Furthermore, since scoreboarding allows only one pending update to a given register, the processor is not concerned about which update is the most recent.</p><p>A further technique for reducing dependencies is using register renaming with a \u201creorder buffer\u201d which uses associative lookup. The associative lookup maps the register identifier to the reorder buffer entry as soon as the entry is allocated, and, to avoid output dependencies, the lookup is prioritized so that only the value for the most recent assignment is obtained if the register is assigned more than once. A tag is obtained if the result is not yet available. There can be as many instances of a given register as there are reorder buffer entries, so there are no storage conflicts between instructions. The values for the different instances are written from the reorder buffer to the register file in sequential order. When the value for the final instance is written to the register file, the reorder buffer no longer maps the register, the register file contains the only instance of the register, and this is the most recent instance.</p><p>However, renaming with a reorder buffer relies on the associative lookup in the reorder buffer to map register identifiers to values. In the reorder buffer, the associative lookup is prioritized so that the reorder buffer always provides the most recent value in the register of interest (or a tag). The reorder buffer also writes values to the register file in order, so that, if the value is not in the reorder buffer, the register file must contain the most recent value.</p><p>In a still further technique for reducing dependencies, associative lookup can be eliminated using a \u201cfuture file.\u201d The future file does not have the properties of the reorder buffer discussed in the preceding paragraph. A value presented to the future file to be written may not be the most recent value destined for the corresponding register, and the value cannot be treated as the most recent value unless it actually is. The future file therefore keeps track of the most recent update and checks that each write corresponds to the most recent update before it actually performs the write.</p><p>When an instruction is decoded, it accesses tags in the future file along with the operand values. If the register has one or more pending updates, the tag identifies the update value required by the decoded instruction. Once an instruction is decoded, other instructions may overwrite this instructions's source operands without being constrained by anti-dependencies, because the operands are copied into the instruction window. Output dependencies are handled by preventing the writing as a result into the future file if the result does not have a tag for the most recent value. Both anti- and output dependencies are handled without stalling instruction issue.</p><p>If dependencies are not removed through renaming, \u201cinterlocks\u201d must use to enforce dependencies. An interlock simply delays the execution of an instruction until the instruction is free of dependencies. There are two ways to prevent an instruction from being executed: one way is to prevent the instruction from being decoded, and the other is to prevent the instruction from being issued.</p><p>To improve performance over scoreboarding, interlocks are moved from the decoder to the instruction window using a \u201cdispatch stack.\u201d The dispatch stack is an instruction window that augments each instruction in the window with dependency counts. There is a dependency count associated with the source register of each instruction in the window, giving the number of pending prior updates to the source register and thus the number of updates that must be completed before all possible true dependencies are removed. There are two similar dependency counts associated with the destination register of each instruction in the window, giving both the number of pending prior uses of the register (which is the number of anti-dependencies) and the number of pending prior updates to the register (which is the number of output dependencies).</p><p>When an instruction is decoded and loaded into the dispatch stack, the dependency counts are set by comparing the instruction's register identifiers with the register identifiers of all instructions already in the dispatch stack. As instructions complete, the dependency counts of instructions that are still in the window are decremented based on the source and destination register identifiers of completing instructions (the counts are decremented by a variable amount, depending on the number of instructions completed). An instruction is independent when all of its counts are zero. The use of counts avoids having to compare all instructions in the dispatch stack to all other instructions on every cycle.</p><p>Anti-dependencies can be avoided altogether by copying operands to the instruction window (for example, to the reservation stations) during instruction decode. In this manner, the operands cannot be overwritten by subsequent register updates. Operands can be copied to eliminate anti-dependencies in any approach, independent of register renaming. The alternative to copying operands is to interlock anti-dependencies, but the comparators and/or counters required for these interlocks are costly, considering the number of combinations of source and result registers to be compared.</p><p>A tag can be supplied for the operand rather than the operand itself. This tag is simply a means for the hardware to identify which value the instruction requires, so that, when the operand value is produced, it can be matched to the instruction. If there can be only one pending update to a register, the register identifier can serve as a tag (as with scoreboarding). If there can be more than one pending update to a register (as with renaming), there must be a mechanism for allocating result tags and insuring uniqueness.</p><p>An alternative to scoreboarding interlocking is to allow multiple pending updates of registers to avoid stalling the decoder for output dependencies, but to handle anti-dependencies by copying operands (or tags) during decode. An instruction in the window is not issued until it is free of output dependencies, so the updates to each register are performed in the same order in which they would be performed with in-order completion, except that updates for different registers are out of order with respect to each other. This alternative has almost all of the capabilities of register renaming, lacking only the capability to issue instructions so that updates to the same register occur out of order.</p><p>There appears to be no better alternative to renaming other than with a reorder buffer. Underlying the discussion of dependencies has been the assumption that the processor performs out-of-order issue and already has a reorder buffer for recovering from mispredicted branches. Out-of-order issue makes it unacceptable to stall the decoder for dependencies. If the processor has an instruction window, it is inconsistent to limit the look ahead capability of the processor by interlocking the decoder. There are then only two alternatives: implement anti- and output dependency interlocks in the window or remove these altogether with renaming.</p><h4>SUMMARY OF THE INVENTION</h4><p>The present invention is directed to instruction scheduling including register renaming and instruction issuing for superscalar RISC computers. A Register Rename Circuit (RRC), which is part of the scheduling logic allows a computer's Instruction Execution Unit (IEU) to execute several instructions at the same time while avoiding dependencies. In contrast to conventional register renaming, the present invention does not actually rename register addresses. The RRC of the present invention temporarily buffers the instruction results, and the results of out-of-order instruction execution are not transferred to the register file until all previous instructions are done. The RRC also performs result forwarding to provide temporarily buffered operands (results) to dependant instructions. The RRC contains three subsections: a Data Dependency Checker (DDC), Tag Assign Logic (TAL) and Register file Port MUXes (RPM).</p><p>The function of the DDC is to locate the dependencies between the instructions for a group of instructions. The DDC does this by comparing the addresses of the source registers of each instruction to the addresses of the destination registers of each previous instruction in the group. For example, if instruction A reads a value from a register that is written to by instruction B, then instruction A is dependent upon instruction B and instruction A cannot start until instruction B has finished. The DDC outputs indicate these dependencies.</p><p>The outputs of the DDC go to the TAL. Because it is possible for an instruction to be dependent on more than one previous instruction, the TAL must determine which of those previous instructions will be the last one to be executed The present invention automatically maps each instruction a predetermined temporary buffer location; hence, the present invention does not need prioritized associative look-up as used by convention reorder buffers, thereby saving chip area/cost and execution speed.</p><p>Out-of-order results for several instructions being executed at the same time are stored in a set of temporary buffers, rather that the file register designated by the instruction. If the DDC determines, for example, that a register that instruction <b>6</b>'s source is written to by instructions <b>2</b>, <b>3</b> and <b>5</b>, then the TAL will indicate that instruction <b>6</b> must wait for instruction <b>5</b> by outputting the \u201ctag\u201d of instruction <b>5</b> for instruction <b>6</b>. The tag of instruction <b>5</b> shows the temporary buffer location where instruction <b>5</b>'s result is stored. It also contains a one bit signal (called a \u201cdone flag\u201d) that indicates if instruction <b>5</b> is finished or not. The TAL will output three tags for each instruction, because each instruction can have three source registers. If an instruction is not dependent on any previous instruction, the TAL will output the register file address of the instruction's input, rather an a temporary buffer's address.</p><p>The last part of the RRC are the RPMs or Register file Port MUXes. The inputs of the RPMs are the outputs of the TAL, and the select lines for the RPMs come from another part of the IEU called the Instruction Scheduler or Issuer. The Instruction Scheduler chooses which instruction to execute (this decision is based partly on the done flags) and then uses the RPMs to select the tags of that instruction. These tags go to the read address ports of the computer's register files. In the previous example, once instruction <b>5</b> has finished, the Instruction Scheduler will start instruction <b>6</b>. It will select the RPM so that the address of instruction <b>5</b>'s result (its tag) is sent to the register file, and the register file will make the result of instruction <b>5</b> available to instruction <b>6</b>.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><p>The foregoing and other features and advantages of the present invention will be apparent from the following more particular description of the preferred embodiments of the invention, as illustrated in the accompanying drawings.</p><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>The invention will be better understood if reference is made to the accompanying drawings.</p><p>FIG. 1 shows a representative high level block diagram of the register renaming circuit of the present invention.</p><p>FIG. 2 shows a representative block diagram of the data dependency check circuit of the present invention.</p><p>FIG. 3 shows a representative block diagram of the tag assignment logic of the present invention.</p><p>FIG. 4 shows a representative block diagram of the register port file multiplexers of the present invention.</p><p>FIG. 5 is a representative flowchart showing a data dependency check method for IXS<b>1</b> and IYS/D in accordance with the present invention.</p><p>FIGS. 6A and 6B are representative flowcharts showing a tag assignment method in accordance with the present invention.</p><p>FIG. 7 shows a representative block diagram which compares an instruction Y's source/destination operand with each operand of an instruction X in accordance with an embodiment of the present invention.</p><p>FIG. 8 shows a representative circuit diagram for comparator block <b>706</b> of FIG. <b>7</b>.</p><p>FIG. 9 shows a representative block diagram of a Priority Encoder in accordance with an embodiment of the present invention.</p><p>FIG. 10 shows a representative block diagram of the instruction scheduling logic of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION</h4><p>FIG. 1 shows a representative high level block diagram of an Instruction Execution Unit (IEU) <b>100</b> associated with the present invention. The goal of IEU <b>100</b> is to execute as many instructions as possible in the shortest amount of time. There are two basic ways to accomplish this: optimize IEU <b>100</b> so that each instruction takes as little time as possible or optimize IEU <b>100</b> so that it can execute several instructions at the same time.</p><p>Instructions are sent to IEU <b>100</b> from an Instruction Fetch Unit (IFU, not shown) through an instruction FIFO (first-in-first-out register stack storage device) <b>101</b> in groups of four called \u201cbuckets.\u201d IEU <b>100</b> can decode and schedule up to two buckets of instructions at one time. FIFO <b>101</b> stores <b>16</b> total instructions in four buckets labeled <b>0</b>-<b>3</b>. IEU <b>100</b> looks at the an instruction window <b>102</b>. In one embodiment of the present invention, window <b>102</b> comprises eight instructions (buckets <b>0</b> and <b>1</b>). Every cycle IEU <b>100</b> tries to issue a maximum number of instructions from window <b>102</b>. Window <b>102</b> functions as a instruction buffer register. Once the instructions in a bucket are executed and their results stored in the processor's register file (see block <b>117</b>), the bucket is flushed out at a bottom <b>104</b> and a new bucket is dropped in at a top <b>106</b>.</p><p>In order to execute instructions in parallel or out of order, care must be taken so that the data that each instruction needs is available when the instruction needs it and also so that the result of each instruction is available for any future instructions that might need it. A Register Rename Circuit (RRC), which is part of the scheduling logic of the computer's IEU performs this function by locating dependencies between current instructions and then renaming the sources (inputs) of the instruction.</p><p>As noted above, there are three types of dependencies: input dependencies, output dependencies and anti-dependencies. Input dependencies occur when an instruction, call it A, that performs an operation on the result of a previous instruction, call it B. Output dependencies occur when the outputs of A and B are to be stored in the same place. Anti-dependencies occur when instruction A comes before B in the instruction stream and B's result will be stored in the same place as one of A's inputs.</p><p>Input dependencies are handled by not executing instructions until their inputs are available. RRC <b>112</b> is used to locate the input dependencies between current instructions and then to signal an Instruction Scheduler or Issuer <b>118</b> when all inputs for a particular instruction are ready. In order to locate these dependencies, RRC <b>112</b> compares the register file addresses of each instruction's inputs with the addresses of each previous instruction's output using a data dependency circuit (DDC) <b>108</b>. If one instruction's input comes from a register where a previous instruction's output will be stored, then the latter instruction must wait for the former to finish.</p><p>This implementation of RRC <b>112</b> can check eight instructions at the same time, so a current instruction is defined as any one of those eight from window <b>102</b>. It should become evident to those skilled in the art that the present invention can easily be adapted to check more or less instructions.</p><p>In one embodiment of the present invention, instructions can have from <b>0</b> to <b>3</b> inputs and <b>0</b> or <b>1</b> outputs. Most instructions' inputs and outputs come from, or are stored in, one of several register files. Each register file <b>117</b> (e.g., separate integer, floating and boolean register files) has 32 real entries plus the group of 8 temporary buffers <b>116</b>. When an instruction completes, (The term \u201ccomplete\u201d means that the operation is complete and the operand is ready to be written to its destination register.) its result is stored in its preassigned location in the temporary buffers <b>116</b>. Its result is later moved to the appropriate place in register file <b>117</b> after all previous instructions' results have been moved to their places in the register file. This movement of results from temporary buffers <b>116</b> to register file <b>117</b> is called \u201cretirement\u201d and is controlled by termination logic, as should become evident to those skilled in the art. More than one instruction may be retired at a time. Retirement comprises updating the \u201cofficial state\u201d of the machine including the computer's Program Counter, as will become evident to those skilled in the art. For example, if instruction <b>10</b> happens to complete directly before instruction I<b>1</b>, both results can be stored directly into register file <b>117</b>. But if instruction I<b>3</b> then completes, its result must be stored in temporary buffer <b>116</b> until instruction I<b>2</b> completes. By having IEU <b>100</b> store each instruction's result in its preassigned place in the temporary buffers <b>116</b>, IEU <b>100</b> can execute instructions out of program order and still avoid the problems caused by output and anti-dependencies.</p><p>RRC <b>112</b> sends a bit map to an Instruction Scheduler <b>118</b> via a bus <b>120</b> indicating which instructions in window <b>102</b> are ready for issuing. Instruction decode logic (not shown) indicates to Issuer <b>118</b> the resource requirements for each instruction over a bus <b>123</b>. For each resource in IEU <b>100</b> (e.g., each functional unit being an adder, multiplier, shifter, or the like), Issuer <b>118</b> scans this information and selects the first and subsequent instructions for issuing by sending issue signals over bus <b>121</b>. The issue signals select a group of Register File Port MUXes (RPMs) <b>124</b> inside RRC <b>112</b> whose inputs are the addresses of each instruction's inputs.</p><p>Because the results may stay in temporary buffer <b>116</b> several cycles before going to register file <b>117</b>, a mechanism is provided to get results from temporary buffer <b>116</b> before they go to register file <b>117</b>, so the information can be used as operands for other instructions. This mechanism is called \u201cresult forwarding,\u201d and without it, Issuer <b>118</b> would not be able to issue instructions out of order. This result forwarding is done in register file <b>117</b> and is controlled by RRC <b>112</b>. The control signals necessary for performing the result forwarding will become evident to those skilled in the art, as should the random logic used for generating such control signals.</p><p>If an instruction is not dependent on any of the current instructions result forwarding is not necessary since the instruction's inputs are already in register file <b>117</b>. When Issuer <b>118</b> decides to execute that instruction, RRC <b>112</b> tells register file <b>117</b> to output its data.</p><p>RRC <b>112</b> contains three subsections: a Data Dependency Checker (DDC) <b>103</b>, Tag Assign Logic (TAL) <b>122</b> and Register File Port MUXes (RPM) <b>124</b>. DDC <b>108</b> determines where the input dependencies are between the current instructions. TAL <b>122</b> monitors the dependencies for Issuer <b>118</b> and controls result forwarding. RPM <b>124</b> is controlled by Issuer <b>118</b> and directs the outputs of TAL <b>122</b> to the appropriate register file address ports <b>119</b>. Instructions are passed to DDC <b>108</b> via bus <b>110</b>. All source registers are compared with all previous destination registers for each instruction in window <b>102</b>.</p><p>Each instruction has only one destination, which may be a double register in one embodiment. An instruction can only depend on a previous instruction and may have up to three source registers. There are various register file source and destination addresses that need to be checked against each other for any dependencies. As noted above, the eight bottom instructions corresponding to the lower two buckets are checked by DDC <b>108</b>. All source register addresses are compared with all previous destination register addresses for the instructions in window <b>102</b>.</p><p>For example, let's say a program has the following instruction sequence:</p><p><maths><formula-text>add R<b>0</b>, R<b>1</b>, R<b>2</b>\u2003\u2003(0)</formula-text></maths></p><p><maths><formula-text>add R<b>0</b>, R<b>2</b>, R<b>3</b>\u2003\u2003(1)</formula-text></maths></p><p><maths><formula-text>add R<b>4</b>, R<b>5</b>, R<b>2</b>\u2003\u2003(2)</formula-text></maths></p><p><maths><formula-text>add R<b>2</b>, R<b>3</b>, R<b>4</b> (3)</formula-text></maths></p><p>The first two registers in each instruction <b>0</b>-<b>3</b> are the source registers, and the last listed register in each instruction is the destination register. For example, R<b>0</b> and R<b>1</b> are the source registers for instruction <b>0</b> and R<b>2</b> is the destination register. Instruction <b>0</b> adds the contents of registers <b>0</b> and <b>1</b> and stores the result in R<b>2</b>. For instructions <b>1</b>-<b>3</b> in this example, the following are the comparisons needed to evaluate all of the dependencies:</p><p><maths><formula-text>I<b>1</b>S<b>1</b>, I<b>1</b>S<b>2</b> vs. I<b>0</b>D</formula-text></maths></p><p><maths><formula-text>I<b>2</b>S<b>1</b>, I<b>2</b>S<b>2</b> vs. I<b>1</b>D, I<b>0</b>D</formula-text></maths></p><p><maths><formula-text>I<b>3</b>S<b>1</b>, I<b>3</b>S<b>2</b> vs. I<b>2</b>D, I<b>1</b>D, I<b>0</b>D</formula-text></maths></p><p>The key to the above is as follows: IXRS<b>1</b> is the address of source (input) number <b>1</b> of instruction X; IXRS<b>2</b> is the address of source (input) number <b>2</b> of instruction X; and IXD is the address of the destination (output) of instruction x Note also that RRC <b>112</b> can ignore the fact that instruction <b>2</b> is output dependent on instruction <b>0</b>, because the processor has a temporary buffer where instruction <b>2</b>'s result can be stored without interfering with instruction <b>0</b>'s result. As discussed before, instruction <b>2</b>'s result will not be moved from temporary buffers <b>116</b> to register file <b>117</b> until instructions <b>0</b> and l's results are moved to register file <b>117</b>.</p><p>The number of instructions that can be checked by RRC <b>112</b> is easily scaleable. In order to check eight instructions at a time instead of four, the following additional comparisons would also need to be made:</p><p><maths><formula-text>I<b>4</b>S<b>1</b>, I<b>4</b>S<b>2</b> vs I<b>3</b>D, I<b>2</b>D, I<b>1</b>D, I<b>0</b>D</formula-text></maths></p><p><maths><formula-text>ISS<b>1</b>, I<b>5</b>S<b>2</b> vs I<b>4</b>D, I<b>3</b>D, I<b>2</b>D, I<b>1</b>D, I<b>0</b>D</formula-text></maths></p><p><maths><formula-text>I<b>6</b>S<b>1</b>, I<b>6</b>S<b>2</b> vs ISD, I<b>4</b>D, I<b>3</b>D, I<b>2</b>D, I<b>1</b>D, I<b>0</b>D</formula-text></maths></p><p><maths><formula-text>I<b>7</b>S<b>1</b>, I<b>7</b>S<b>2</b> vs I<b>6</b>D, I<b>5</b>D, I<b>4</b>D, I<b>3</b>D, I<b>2</b>D, I<b>1</b>D, I<b>0</b>D</formula-text></maths></p><p>There are several special cases that RRC <b>112</b> must handle in order to do the dependency check. First, there are some instructions that use the same register as an input and an output. Thus, RRC <b>112</b> must compare this source/destination register address with the destination register addresses of all previous instructions. So for instruction <b>7</b>, the following comparisons would be necessary:</p><p><maths><formula-text>I<b>7</b>S<b>1</b>,I<b>7</b>S<b>2</b>,I<b>7</b>S/D vs. I<b>6</b>D,I<b>5</b>D,I<b>4</b>D,I<b>3</b>D,I<b>2</b>D,I<b>1</b>D,I<b>0</b>D.</formula-text></maths></p><p>Another special case occurs when a program contains instructions that generate 64 bit outputs (called long-word operations). These instructions need two registers in which to store their results. In this embodiment, these registers must be sequential. Thus if RRC <b>112</b> is checking instruction <b>4</b>'s dependencies and instruction <b>1</b> is a long-word operation, then it must do the following comparisons:</p><p><maths><formula-text>I<b>4</b>S<b>1</b>,I<b>4</b>S<b>2</b> vs. I<b>3</b>D,I<b>2</b>D,I<b>1</b>D,I<b>1</b>D+<b>1</b>,I<b>0</b>D</formula-text></maths></p><p>Sometimes, instructions do not have destination registers. Thus RRC <b>112</b> must ignore any dependencies between instructions without destination registers and any future instructions. Also, instructions may not have only one valid source register, so RRC <b>112</b> must ignore any dependencies between the unused source register (usually S<b>2</b>) and any previous instructions.</p><p>RRC <b>112</b> is also capable of dealing with multiple register files. When using multiple register files, dependencies only occur when one instruction's source register has the same address and is in the same register file as some other instruction's destination register. RRC <b>112</b> treats the information regarding which register file a particular address is from as part of the address. For example, in an implementation using four 32 bit register files, RRC <b>112</b> would do 7 bit compares instead of 5 bit compares (5 for the address and 2 for the register file).</p><p>Signals indicating which instructions are long-word operations or have invalid source or destination registers are sent to RRC <b>112</b> from Instruction Decode Logic (IDL; not shown). IDL also tells RRC <b>112</b> which register file each instruction's sources and destinations will come from or go to.</p><p>A block diagram of DDC <b>108</b> is shown in FIG. <b>2</b>. Source address signals arrive from IFIFO <b>101</b> for all eight instructions of window <b>102</b>. Additional inputs include long-word load operation flags, register file decode signals, invalid destination register flags, destination address signals and addressing mode flags for all eight instructions.</p><p>DDC <b>208</b> comprises 28 data dependency blocks <b>204</b>. Each block <b>204</b> is described in a KEY <b>206</b>. Each block <b>204</b> receives 3 inputs, IXS<b>1</b>, IXS<b>2</b> and IXS/D. IXS<b>1</b> is the address of source (input) number <b>1</b> of instruction X; IXS<b>2</b> is the address of source (input) number <b>2</b> of instruction X; and IXS/D is the address of the source/destination (input) of instruction X Each block <b>204</b> also receives input IYS/D, which is the destination register address for some previous instruction Y. A top row <b>208</b>, for example, receives I<b>0</b>S/D, which is the destination register address for instruction <b>0</b>. Each block <b>204</b> outputs the data dependency results to one of a corresponding bus line <b>114</b>. For example, the address of I<b>2</b>S/D must be checked with operand addresses S<b>1</b>, S<b>2</b> and S/D of instructions <b>7</b>, <b>6</b>, <b>5</b>, <b>4</b>, and <b>3</b>.</p><p>Each block <b>204</b> performs the three comparisons. To illustrate these comparisons, consider a generic block <b>700</b> shown in FIG. 7, which compares instruction Y's source/destination operand with each operand of instruction X In this example, the three following comparisons must be made:</p><p><maths><formula-text>IXS<b>1</b>=IYS/D</formula-text></maths></p><p><maths><formula-text>IXS<b>2</b>=IYS/D</formula-text></maths></p><p><maths><formula-text>IXS/D=IYS/D</formula-text></maths></p><p>These comparisons are represented by three comparator blocks <b>702</b>, <b>704</b> and <b>706</b>, respectively. One set of inputs to comparator blocks <b>702</b>, <b>704</b> and <b>706</b> are the bits of the IYS/D field, which is represented by number <b>708</b>. Comparator block <b>702</b> has as its second set of inputs the bits of the IXS<b>1</b>. Similarly, comparator block <b>704</b> has as its second set of inputs the bits of the IXS<b>1</b>, and comparator block <b>706</b> has as its second set of inputs the bits of the IXS/D.</p><p>In a preferred embodiment, the comparisons performed by blocks <b>702</b>, <b>704</b> and <b>706</b> can be performed by random logic. An example of random logic for comparator block <b>706</b> is shown in FIG. <b>8</b>. Instruction Y's source/destination bits [<b>6</b>:<b>0</b>] are shown input from the right at reference number <b>802</b> and instruction X's source/destination bits [<b>6</b>:<b>0</b>] are shown input from the top at reference number <b>804</b>. The most significant bit (MSB) is bit <b>6</b> and the least significant bit (LSB) is bit <b>0</b>. The corresponding bits from the two operands are fed to a set of seven exclusive NOR gates (XNORS) <b>806</b>. The outputs of XNORs <b>806</b> are then ANDed by a seven input AND gate <b>808</b>. If the corresponding bits are the same, the output of XNOR <b>806</b> will be logic high. When all bits are the same, all seven XNOR <b>806</b> outputs are logic high and the output of AND gate <b>808</b> is logic high, this indicates that there is a dependency between IXS/D and IYS/D.</p><p>The random logic for comparator blocks <b>702</b> and <b>704</b> will be identical to that shown in FIG. <b>8</b>. The present invention contemplates many other random logic circuits for performing data dependency checking, as will become evident to those skilled in the art without departing from the spirit of this example.</p><p>As will further become evident to those skilled in the art, various implementation specific special cases can arise which require additional random logic to perform data dependency checking. An illustrative special data dependency checking case is for long word handling.</p><p>As mentioned before, if a long word operation writes to register X the first 32 bits are written to register X and the second 32 bits are written to register X+1. The data dependency checker therefore needs to check both registers when doing a comparison. In a preferred embodiment, register X is an even register, X+1 is an odd register and thus they only differ by the LSB. The easiest way to check both registers at the same time is to simply ignore the LSB. In the case of a store long (STLG) or load long (LDLG) operation, if X and Y only differ by the LSB bit [<b>0</b>], the logic in FIG. 8 would cause there to be no dependency, when there really is a dependency. Therefore, for a long word operation the STLG and LDLG flags must be ORed with the output of the [<b>0</b>] bit XNOR to assure that all dependencies are detected.</p><p>A data dependency check flowchart for IXS<b>1</b> and IYS/D is shown in FIG. <b>5</b>. DDC <b>108</b> first checks whether IXS<b>1</b> and IYS/D are in the same register file, as shown at a conditional block <b>502</b>. If they are not in the same register file there is no dependency. This is shown at block a <b>504</b>. If there is a dependency, DDC <b>108</b> then determines whether IXS<b>1</b> and IYS/D are in the same register, as shown at a block <b>506</b>. If they are not in the same register, flow proceeds to a conditional block <b>508</b> where DDC <b>108</b> determines whether IY is a long word operation. If IY is not a long word operation there is no dependency and flow proceeds to a block <b>504</b>. If IY is a long word operation, flow then proceeds to a conditional statement <b>510</b> where DDC <b>108</b> determines whether IXS<b>1</b> and IYS/D+1 are the same register. If they are not, there is no dependency and flow proceeds to a block <b>504</b>. If IXS<b>1</b> and IYS/D+1 are the same register, flow proceeds to a conditional block <b>512</b> where DDC <b>108</b> determines if IY has a valid destination. If it does not have a valid destination, there is no dependency and flow proceeds to block <b>504</b>. If IY does have a valid destination, flow proceeds to a conditional block <b>514</b> where DDC <b>108</b> determines if IXS<b>1</b> has a valid source register. Again, if no valid source register is detected there is no dependency, and flow proceeds to a block <b>504</b>. If a valid source register is detected, DDC <b>108</b> has determined that there is a dependency between IXS<b>1</b> and IYX/D, as shown at a block <b>516</b>.</p><p>A more detailed discussion of data dependency checking is found in commonly owned, copending application Ser. No. 07/860,718, the disclosure of which is incorporated herein by reference.</p><p>Because it is possible that an instruction might get one of its inputs from a register that was written to by several other instructions, the present invention must choose which one is the real dependency. For example, if instructions <b>2</b> and <b>5</b> write to register <b>4</b> and instruction <b>7</b> reads register <b>4</b>, then instruction <b>7</b> has two possible dependencies. In this case, it is assumed that since instruction <b>5</b> came after instruction <b>2</b> in the program, the programmer intended instruction <b>7</b> to use instruction <b>5</b>'s result and not instruction <b>2</b>'s. So, if an instruction can be dependent on several previous instructions, RRC <b>112</b> will consider it to be dependent on the highest numbered previous instruction.</p><p>Once TAL <b>122</b> has determined where the real dependencies are, it must locate the inputs for each instruction. In a preferred embodiment of the present invention, the inputs can come from the actual register file or an array temporary buffers <b>116</b>. RRC <b>112</b> assumes that if an instruction has no dependencies, its inputs are all in the register file. In this case, RRC <b>112</b> passes the IXS<b>1</b>, IXS<b>2</b> and IXS/D addresses that came from IFIFO <b>102</b> to the register file. If an instruction has a dependency, then RRC <b>112</b> assumes that the data is in temporary buffers <b>116</b>. Since RRC <b>112</b> knows which previous instruction each instruction depends on, and since each instruction always writes to the same place in temporary buffers <b>116</b>, RRC <b>112</b> can determine where in temporary buffers <b>116</b> an instruction's inputs are stored. It sends these addresses to register file read ports <b>119</b> and register file <b>117</b> outputs the data from temporary buffers <b>116</b> so that the instruction can use it.</p><p>The following is an example of tag assignments:</p><p><maths><formula-text><b>0</b>: add r<b>0</b>, r<b>1</b>, r<b>2</b></formula-text></maths></p><p><maths><formula-text><b>1</b>: add r<b>0</b>, r<b>2</b>, r<b>3</b></formula-text></maths></p><p><maths><formula-text><b>2</b>: add r<b>4</b>, r<b>5</b>, r<b>2</b></formula-text></maths></p><p><maths><formula-text><b>3</b>: add r<b>2</b>, r<b>3</b>, r<b>4</b></formula-text></maths></p><p>The following are the dependencies for the above operations (dependencies are represented by the symbol \u201c#\u201d):</p><p><maths><formula-text>I<b>1</b>S<b>2</b>#I<b>0</b>S/D</formula-text></maths></p><p><maths><formula-text>I<b>3</b>S<b>1</b>#I<b>0</b>S/D</formula-text></maths></p><p><maths><formula-text>I<b>3</b>S<b>1</b>#I<b>2</b>S/D</formula-text></maths></p><p><maths><formula-text>I<b>3</b>S<b>2</b>#I<b>1</b>S/D</formula-text></maths></p><p>First, look at I<b>0</b>; since it has no dependencies, its tags are equal to its original source register addresses:</p><p><maths><formula-text>I<b>0</b>S<b>1</b> TAG=I<b>0</b>S<b>1</b>=r<b>0</b></formula-text></maths></p><p><maths><formula-text>I<b>0</b>S<b>2</b> TAG=I<b>0</b>S<b>2</b>=r<b>1</b></formula-text></maths></p><p><maths><formula-text>I<b>0</b>S/D TAG=I<b>0</b>S/D=r<b>2</b></formula-text></maths></p><p>I<b>1</b> has one dependency, and its tags are as follows:</p><p>\u2003I<b>1</b>S<b>1</b> TAG=I<b>1</b>S<b>1</b>=r<b>0</b></p><p><maths><formula-text>I<b>1</b>S<b>2</b> TAG=I<b>0</b>S/D=t<b>0</b></formula-text></maths></p><p>where: (t<b>0</b>=inst. <b>0</b>'s slot in temporary buffer)</p><p><maths><formula-text>I<b>1</b>S/D TAG=I<b>1</b>/ID=r<b>3</b></formula-text></maths></p><p>I<b>2</b> is also independent:</p><p><maths><formula-text>I<b>2</b>S<b>1</b> TAG=I<b>2</b>S<b>1</b>=r<b>4</b></formula-text></maths></p><p><maths><formula-text>I<b>2</b>S<b>2</b> TAG=I<b>2</b>S<b>2</b>=r<b>5</b></formula-text></maths></p><p><maths><formula-text>I<b>2</b>S/D TAG=I<b>2</b>S/D=r<b>2</b></formula-text></maths></p><p>I<b>3</b>S<b>1</b> has two possible dependencies, I<b>0</b>S/D and <b>12</b>S/D. Because TAL <b>122</b> must pick the last one (highest numbered one), I<b>2</b>S/D is chosen.</p><p><maths><formula-text>I<b>3</b>S<b>1</b> TAG=I<b>2</b>S/D=t<b>2</b></formula-text></maths></p><p><maths><formula-text>I<b>3</b>S<b>2</b> TAG=I<b>1</b>S/D=t<b>1</b></formula-text></maths></p><p><maths><formula-text>I<b>3</b>S/D TAG=I<b>3</b>S/D=r<b>4</b></formula-text></maths></p><p>These tags are then sent to RPM <b>124</b> via bus <b>126</b> to be selected by Issuer <b>118</b>. At the same time TAL <b>122</b> is preparing the tags, it is also monitoring the outputs of DCL <b>130</b> and passing them on to Issuer <b>118</b> using bus <b>120</b>. TAL <b>122</b> chooses the proper outputs of DCL's <b>130</b> to pass to Issuer <b>118</b> by the same method that it chooses the tags that it sends to RPM <b>124</b>.</p><p>Continuing the example, TAL <b>122</b> sends the following ready signals to Issuer <b>118</b>:</p><p><maths><formula-text>I<b>0</b>S<b>1</b> INFO=1</formula-text></maths></p><p>(Inst <b>0</b> is independent so it can start immediately)</p><p><maths><formula-text>I<b>0</b>S<b>2</b> INFO=1</formula-text></maths></p><p><maths><formula-text>I<b>0</b>S/D INFO=1</formula-text></maths></p><p><maths><formula-text>I<b>1</b>S<b>1</b> INFO=1</formula-text></maths></p><p><maths><formula-text>I<b>1</b>S<b>2</b> INF<b>0</b>=DONE[<b>0</b>]</formula-text></maths></p><p>(DONE[<b>0</b>]=1 when I<b>0</b> is done)</p><p><maths><formula-text>I<b>1</b>S/D INFO=1</formula-text></maths></p><p><maths><formula-text>I<b>2</b>S<b>1</b> INFO=1</formula-text></maths></p><p><maths><formula-text>I<b>2</b>S<b>2</b> INFO=1</formula-text></maths></p><p><maths><formula-text>I<b>2</b>S/D INFO=1</formula-text></maths></p><p><maths><formula-text>I<b>3</b>S<b>1</b> INFO=DONE[<b>2</b>]</formula-text></maths></p><p><maths><formula-text>I<b>3</b>S<b>2</b> INFO=DONE[<b>1</b>]</formula-text></maths></p><p><maths><formula-text>I<b>3</b>S/D READ=1</formula-text></maths></p><p>(The DONE signals come from DCL <b>130</b> via a bus <b>132</b>. In connection with the present invention, the term \u201cdone\u201d means the result of the instruction is in a temporary buffer or otherwise available at the output of a functional unit. Contrastingly, the term \u201cterminate\u201d means the result of the instruction is in the register file.)</p><p>Turning now to FIG. 3, a representative block diagram of TAL <b>122</b> will be discussed. TAL <b>122</b> comprises <b>8</b> tag assignment logic blocks <b>302</b>. Each TAL block <b>302</b> receives the corresponding data dependency results via buses <b>114</b>, as well as further signals that come from the computer's Instruction Decode and control logic (not shown). The BKT bit signal forms the least significant bit of the tag. DONE[X] flags are for instructions <b>0</b> through <b>6</b>, and indicate if instruction X is done. DBLREG[X] flags indicates which, if any, of the instructions is a double (long) word. Each TAL block <b>302</b> also receives its own instructions register addresses as inputs. The Misc. signals, DBLREG and BKF signals are all implementation dependent control signals. Each TAL block <b>302</b> outputs 3 TAGs <b>126</b> labeled IXS<b>1</b>, IXS<b>2</b> and IXS/D, which are 6 bits. TAL <b>122</b> outputs the least significant 5 bits of each TAG signal to RPMs <b>124</b> and the most significant TAG to Issuer <b>118</b>.</p><p>Each block <b>302</b> of FIG. 3 comprises three Priority Encoders (PE), one for S<b>1</b>, one for S<b>2</b> and one for S/D. There is one exception however. I<b>10</b> requires no tag assignment. Its tags are the same as the original S<b>1</b>, S<b>2</b> and S/D addresses, because I<b>0</b> is always independent.</p><p>An illustrative PE is shown in FIG. <b>9</b>. PE <b>902</b> has eight inputs <b>904</b> and eight outputs <b>906</b>. Inputs <b>904</b> for PE <b>902</b> are outputs <b>114</b> from DDC <b>108</b> which show where dependencies exist. For example, in the case of source register <b>1</b> (S<b>1</b>), I<b>7</b>S<b>1</b> tag assign PE <b>902</b>'s seven inputs are the seven outputs <b>114</b> of DDC <b>108</b> that indicate whether I<b>7</b>S<b>1</b> is dependent on I<b>6</b>D, whether I<b>7</b>S<b>1</b> is dependent on ISD, and so on down to whether I<b>7</b>S<b>1</b> is dependent on I<b>0</b>D. An eighth input, shown at reference number <b>908</b>, is always tied high because there should always be an output from PE <b>902</b>.</p><p>As stated before, if an instruction depends on several previous instructions, PE <b>902</b> will select and output only the most previous instruction (in program order) on which there is a dependency. This is accomplished by connecting the signal showing if there is a dependency on the most previous instruction to the highest priority input of the PE <b>902</b> and the signal showing if there is a dependency on the second most previous instruction to the input of PE <b>902</b> with the second highest priority and so on for all previous instructions. The input of the PE <b>902</b> with the lowest priority is always tied high so that at least one of PE <b>902</b>'s outputs will be asserted.</p><p>Outputs <b>906</b> are used as select lines for a MUX <b>910</b>. MUX <b>910</b> has eight inputs <b>912</b> to which the tags for each instruction are applied.</p><p>To illustrate this, assume that I<b>7</b> depends on I<b>6</b> and I<b>5</b>, then, since I<b>6</b> has a higher priority than I<b>5</b>, the bit corresponding to I<b>6</b> at outputs <b>906</b> of PE <b>902</b> will be high. At the corresponding input <b>912</b> of MUX <b>910</b> will be I<b>6</b>'s tag for S<b>1</b> (recall PE <b>902</b> is for I<b>7</b>S<b>1</b>). Because I<b>7</b> is dependent on I<b>6</b>, the location of I<b>6</b>'s result must be output from MUX <b>910</b> so that it can be used by I<b>7</b>. I<b>6</b>'s tag will therefore be selected and output on an output line <b>914</b>. I<b>6</b>'s done flag, DONE[<b>6</b>] must also be output from MUX <b>910</b> so that Issuer <b>118</b> will know when I<b>7</b>'s input is ready. This data is passed to Issuer <b>118</b> via bus <b>120</b>. Since an instruction can have up to three sources, TAL <b>122</b> monitors up to three dependencies for each instruction and sends three vectors for each instruction (totaling 24 vectors) to Issuer <b>118</b>. If an instruction is independent, TAL <b>122</b> signals to Issuer <b>118</b> that the instruction can begin immediately.</p><p>The MSB of the tag outputs which are sent to RPMs <b>124</b> is used to indicate if the address is a register file address or a temporary buffer address. If an instruction is independent, then the five LSB outputs indicate the source register address. For instructions that have dependencies: the second MSB indicates that the address is for a 64 bit valve; the third through fifth MSB outputs specie the temporary buffer address; and the LSB output indicates which bucket is the current bucket, which is equal to the BKT signal in TAL <b>122</b>.</p><p>Like DDC <b>108</b>, TAL <b>122</b> has numerous implementation dependent situations, (i.e., special cases) that it handles. First, in an embodiment of the present invention, register number <b>0</b> of the register file is always equal to 0. Therefore, even if one instruction writes to register <b>0</b> and another reads from register <b>0</b>, there will be no dependency between them. TAL <b>122</b> receives three signals from Instruction Decode Logic (IDL; not shown) for each instruction to indicate if one of that instruction's sources is register <b>0</b>. If any of those is asserted, TAL <b>122</b> will ignore any dependencies for that particular input of that instruction.</p><p>Another special case occurs because under some circumstances, an instruction in bucket <b>0</b> will be guaranteed to not have any of the instructions in bucket <b>1</b> dependent on it. A four bit signal called BKT<b>1</b><sub>13 </sub>NODEP<sub>13 </sub>is sent to RRC <b>112</b> from the IEU control logic (not shown) and if BKT<b>1</b><sub>13 </sub>NODEP[X]=1 then RRC <b>112</b> knows to ignore any dependencies between instructions, <b>4</b>,<b>5</b>,<b>6</b> or <b>7</b> and instruction X An example for TAG assignment of instruction <b>7</b>'s source <b>1</b> (I<b>7</b>S<b>1</b>) is shown in a flowchart in FIGS. 6A-6B. TAL <b>122</b> first determines whether I<b>7</b>S<b>1</b> is register <b>0</b>, as shown at a conditional block <b>602</b>. If the first source operand for I<b>7</b> is register <b>0</b>, the TAG is set equal to zero, and the I<b>7</b>S<b>1</b>'s INFO flag is set equal to one, as shown in a block <b>604</b>. If the first source operand (S<b>1</b>) for I<b>7</b> is not register <b>0</b>, TAL <b>122</b> then determines if I<b>7</b>S<b>1</b> is dependent on I<b>6</b>S/D, as shown at a conditional block <b>606</b>. If I<b>7</b>S<b>1</b> is dependent on I<b>6</b>S/D flow then proceeds to a block <b>610</b> where I<b>7</b>S<b>1</b>'s TAG is set equal to {<b>1</b>,DBLREG[<b>6</b>],<b>0</b>,<b>1</b>,<b>0</b>,BKT} and I<b>7</b>S<b>1</b>'s INFO flag is set equal to DONE[<b>6</b>], as shown at a block <b>610</b>. If either of the condition tested at a conditional block <b>606</b> is not met, flow proceeds to conditional block <b>612</b> where TAL <b>122</b> determines if I<b>7</b>S<b>1</b> is dependent on I<b>5</b>S/D. If there is a dependency, flow then proceeds to block <b>616</b> where TAL <b>122</b> sets I<b>7</b>S<b>1</b>'s TAG equal to {<b>1</b>,DBLREG[<b>5</b>],<b>0</b>,<b>0</b>,<b>1</b>,BKT} and I<b>7</b>S<b>1</b>'s INFO flag is set equal to DONE[<b>5</b>]. If the condition tested at block <b>612</b> is not met, flow proceeds to a block <b>618</b> where TAL <b>122</b> determines if I<b>7</b>S<b>1</b> is dependent on <b>14</b>S/D.</p><p>As evident by inspection of the remaining sections of FIGS. 6A and 6B, similar TAG determinations are made depending on whether I<b>7</b>S<b>1</b> is dependent on I<b>4</b>S/D, I<b>3</b>S/D, I<b>2</b>S/D, I<b>1</b>S/D and I<b>0</b>S/ID, as shown at sections <b>620</b>, <b>622</b>, <b>624</b>, <b>626</b> and <b>628</b>, respectively. Finally, if instruction <b>7</b> is independent of instruction <b>0</b> or if all instructions in bucket <b>1</b> are independent of instruction <b>0</b> (i.e., if BKT<b>1</b><sub>13 </sub>NODEP[<b>0</b>]=1), as tested at a conditional block <b>630</b>, the flow proceeds to block <b>632</b> where TAL <b>122</b> sets I<b>7</b>S<b>1</b>'s TAG equal to {<b>0</b>,I<b>7</b>S<b>1</b>} and I<b>7</b>S<b>1</b>'s INFO flag equal to 1. It should be noted for the above example that I<b>7</b>S<b>1</b> TAG signals are forwarded directly the register file port MUXes of register file <b>117</b>. The I<b>7</b>S<b>1</b> INFO signals are sent to Issuer <b>118</b> to tell it when I<b>7</b>'s S<b>1</b> input is ready.</p><p>A representative block diagram of Issuer <b>118</b> is shown in FIG. <b>10</b>. In a preferred embodiment, Issuer <b>118</b> has one scanner block <b>1002</b> for each resource (functional unit) that has to be allocated. In this example, Issuer <b>118</b> has scanner blocks FU<b>1</b>, FU<b>2</b>, FU<b>3</b>, FU<b>4</b> through FUn. Requests for functional units are generated from instruction information by decoding logic (not shown) in a known manner, which are sent to scanners <b>1002</b> via bus <b>123</b>. Each scanner block <b>1002</b> scans from instruction I<b>0</b> to I<b>7</b> and selects the first request for the corresponding functional unit to be serviced during that cycle.</p><p>In the case of multiple register files (integer, floating and/or boolean), Issuer <b>118</b> is capable of issuing instructions having operands stored in different register files. For example, an ADD instruction may have a first operand from the floating point register file and a second operand from the integer register file. Instructions with operands from different register files are typically given higher issue priority (i.e., they are issued first). This issuing technique conserves processor execution time and functional unit resources.</p><p>In a further embodiment in which IEU <b>100</b> may include two ALU's, ALU scanning becomes a bit more complicated. For speed reasons, one ALU scanner block scans from I<b>0</b> to I<b>7</b>, while the other scanner block scans from I<b>7</b> to I<b>0</b>. This is how two ALU requests are selected. With this scheme it is possible that an ALU instruction in bucket <b>1</b> will get issued before an ALU instruction in bucket <b>0</b>, while increasing scanning efficiency.</p><p>Scanner outputs <b>1003</b> are selected by MUXing logic <b>1004</b>. A set of SELect inputs <b>1006</b> for MUX <b>1004</b> receive three 8-bit vectors (one for each operand) from TAL <b>122</b> via bus <b>120</b>. The vectors indicate which of the eight instructions have no dependencies and are ready to be issued. Issuer <b>118</b> must wait for this information before it can start to issue any instructions. Issuer <b>118</b> monitors these vectors and when all three go high for a particular instruction, Issuer <b>118</b> knows that the inputs for that instruction are ready. Once the necessary functional unit is ready, the issuer can issue that instruction and send select signals to the register file port MUXes to pass the corresponding instructions outputs to register file <b>117</b>.</p><p>In a preferred embodiment of the present invention, after Issuer <b>118</b> is done it provides two <b>8</b>-bit vectors per register file back to RRC <b>112</b> via MUXOUTputs <b>1008</b> to bus <b>121</b>. These vectors indicate which instructions are issued this cycle, are used a select lines for RPMs <b>124</b>.</p><p>The maximum number of instructions that can be issued simultaneously for each register file is restricted by the number of register file read ports available. A data dependency with a previous uncompleted instruction may prevent an instruction from being issued. In addition, an instruction may be prevented from being issued if the necessary functional unit is allocated to another instruction.</p><p>Several instructions, such as load immediate instructions, Boolean operations and relative conditional branches, may be issued independently, because they may not require resources other than register file read ports or they may potentially have no dependencies.</p><p>The last section of RRC <b>112</b> is the register file port MUX (RPM) section <b>124</b>. The function of RPMs <b>124</b> is to provide a way for Issuer <b>118</b> to get data out of register files <b>117</b> for each instruction to use. RPMs <b>124</b> receive tag information via bus <b>126</b>, and the select lines for RPMs <b>124</b> come from Issuer <b>118</b> via a bus <b>121</b> and also from the computer's IEU control logic. The selected TAGs comprise read addresses that are sent to a predetermined set of ports <b>119</b> of register file <b>117</b> using bus <b>128</b>.</p><p>The number and design of RPMs <b>124</b> depend on the number of register files and the number of ports on each register file. One embodiment of RPMs <b>124</b> is shown in FIG. <b>4</b>. In this embodiment, RPMs <b>124</b> comprises <b>3</b> register port file MUXes <b>402</b>, <b>404</b> and <b>406</b>. MUX <b>402</b> receives as inputs the TAGs of instructions <b>0</b>-<b>7</b> corresponding to the source register field S<b>1</b> that are generated by TAL <b>122</b>. MUX <b>404</b> receives as inputs the TAGs of instructions <b>0</b>-<b>7</b> corresponding to the source register field S<b>2</b> that are generated by TAL <b>122</b>. MUX <b>406</b> receives as inputs the TAGs of instructions <b>0</b>-<b>7</b> corresponding to the source/destination register field S/D that are generated by TAL <b>122</b>. The outputs of MUXes <b>402</b>, <b>404</b> and <b>406</b> are connected to the read addresses ports of register file <b>117</b> via bus <b>128</b>.</p><p>RRC <b>112</b> and Issuer <b>118</b> allow the processor to execute instructions simultaneously and out of program order. An IEU for use with the present invention is disclosed in commonly owned, co-pending application Ser. No. 07/817,810, the disclosure of which is incorporated herein by reference.</p><p>While various embodiments of the present invention have been described above, it should be understood that they have been presented by way of example, and not limitation. Thus the breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Sanjiv", "last_name": "Garg", "name": ""}, {"first_name": "Kevin Ray", "last_name": "Iadonato", "name": ""}, {"first_name": "Le Trong", "last_name": "Nguyen", "name": ""}, {"first_name": "Johannes", "last_name": "Wang", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "TRANSMETA CORPORATION"}, {"first_name": "", "last_name": "INTELLECTUAL VENTURES ASSETS 158 LLC", "name": ""}, {"first_name": "", "last_name": "HANGER SOLUTIONS, LLC", "name": ""}, {"first_name": "", "last_name": "TRANSMETA LLC", "name": ""}, {"first_name": "", "last_name": "INTELLECTUAL VENTURE FUNDING LLC", "name": ""}, {"first_name": "", "last_name": "SEIKO EPSON CORPORATION", "name": ""}, {"first_name": "", "last_name": "TRANSMETA CORPORATION", "name": ""}, {"first_name": "", "last_name": "S-MOS SYSTEMS, INC.", "name": ""}, {"first_name": "", "last_name": "TRANSMETA CORPORATION", "name": ""}, {"first_name": "", "last_name": "S-MOS SYSTEMS, INC.", "name": ""}, {"first_name": "", "last_name": "SEIKO EPSON CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  15/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/34        20060101ALI20051220RMJP"}, {"label": "G06F   9/38        20060101A I20070721RMEP"}, {"label": "G06F  15/00        20060101A I20051110RMEP"}, {"label": "G06F   9/30        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712023"}, {"primary": false, "label": "712E09025"}, {"primary": false, "label": "712216"}, {"primary": false, "label": "712E09049"}, {"primary": false, "label": "712E09046"}, {"primary": false, "label": "712218"}], "ecla_classes": [{"label": "G06F   9/38E1R"}, {"label": "G06F   9/38E1"}, {"label": "G06F   9/30R5D"}, {"label": "G06F   9/38D"}, {"label": "G06F   9/38E"}], "cpc_classes": [{"label": "G06F   9/3013"}, {"label": "G06F   9/3824"}, {"label": "G06F   9/3855"}, {"label": "G06F   9/3838"}, {"label": "G06F   9/384"}, {"label": "G06F   9/3838"}, {"label": "G06F   9/3013"}, {"label": "G06F   9/3824"}, {"label": "G06F   9/3855"}, {"label": "G06F   9/384"}, {"label": "G06F   9/38"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1992-03-31", "application_date": "1999-06-10", "family_members": [{"ucid": "US-20060041736-A1", "titles": [{"lang": "EN", "text": "Superscalar RISC instruction scheduling"}]}, {"ucid": "WO-1993020505-A3", "titles": [{"lang": "EN", "text": "SUPERSCALAR RISC INSTRUCTION SCHEDULING"}, {"lang": "FR", "text": "PLANIFICATION D'INSTRUCTIONS POUR ORDINATEURS SUPERSCALAIRES A JEU D'INSTRUCTIONS REDUIT"}]}, {"ucid": "US-6289433-B1", "titles": [{"lang": "EN", "text": "Superscalar RISC instruction scheduling"}]}, {"ucid": "JP-2000148486-A", "titles": [{"lang": "JA", "text": "\u30b3\u30f3\u30d4\u30e5\u2015\u30bf\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "COMPUTER SYSTEM"}]}, {"ucid": "US-20030005260-A1", "titles": [{"lang": "EN", "text": "Superscalar RISC instruction scheduling"}]}, {"ucid": "WO-1993020505-A2", "titles": [{"lang": "FR", "text": "PLANIFICATION D'INSTRUCTIONS POUR ORDINATEURS SUPERSCALAIRES A JEU D'INSTRUCTIONS REDUIT"}, {"lang": "EN", "text": "SUPERSCALAR RISC INSTRUCTION SCHEDULING"}]}, {"ucid": "KR-100371930-B1", "titles": []}, {"ucid": "US-20080059770-A1", "titles": [{"lang": "EN", "text": "Superscalar RISC instruction scheduling"}]}, {"ucid": "US-5737624-A", "titles": [{"lang": "EN", "text": "Superscalar risc instruction scheduling"}, {"lang": "EN", "text": "SYSTEM FOR REGISTER RENAMING IN A COMPUTER SYSTEM"}]}, {"ucid": "JP-2000148488-A", "titles": [{"lang": "JA", "text": "\u30b9\u2015\u30d1\u2015\u30b9\u30ab\u30e9\u30d7\u30ed\u30bb\u30c3\u30b5"}, {"lang": "EN", "text": "SUPERSCALAR PROCESSOR"}]}, {"ucid": "JP-H07505494-A", "titles": []}, {"ucid": "JP-3730252-B2", "titles": [{"lang": "JA", "text": "\u30ec\u30b8\u30b9\u30bf\u540d\u79f0\u5909\u66f4\u65b9\u6cd5\u53ca\u3073\u540d\u79f0\u5909\u66f4\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "Register name changing method and name changing system"}]}, {"ucid": "EP-0636256-A1", "titles": [{"lang": "FR", "text": "Plassification d'instructions d'un processeur RISC superscalaire."}, {"lang": "EN", "text": "SUPERSCALAR RISC INSTRUCTION SCHEDULING."}, {"lang": "DE", "text": "BEFEHLSABLAUFFOLGEPLANNUNG VON EINEM RISC-SUPERSKALARPROZESSOR."}]}, {"ucid": "JP-3571263-B2", "titles": [{"lang": "JA", "text": "\u30ec\u30b8\u30b9\u30bf\u540d\u79f0\u5909\u66f4\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "Register Name change system"}]}, {"ucid": "US-5974526-A", "titles": [{"lang": "EN", "text": "Superscalar RISC instruction scheduling"}]}, {"ucid": "US-5497499-A", "titles": [{"lang": "EN", "text": "Superscalar risc instruction scheduling"}]}, {"ucid": "DE-69311330-D1", "titles": [{"lang": "EN", "text": "COMMAND SEQUENCE PLANNING FROM A RISC SUPER SCALAR PROCESSOR"}, {"lang": "DE", "text": "BEFEHLSABLAUFFOLGEPLANUNG VON EINEM RISC-SUPERSKALARPROZESSOR"}]}, {"ucid": "DE-69311330-T2", "titles": [{"lang": "EN", "text": "COMMAND SEQUENCE PLANNING FROM A RISC SUPER SCALAR PROCESSOR"}, {"lang": "DE", "text": "BEFEHLSABLAUFFOLGEPLANUNG VON EINEM RISC-SUPERSKALARPROZESSOR"}]}, {"ucid": "KR-957001101-A", "titles": []}, {"ucid": "US-7802074-B2", "titles": [{"lang": "EN", "text": "Superscalar RISC instruction scheduling"}]}, {"ucid": "JP-3571267-B2", "titles": [{"lang": "JA", "text": "\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "Computer system"}]}, {"ucid": "EP-0636256-B1", "titles": [{"lang": "DE", "text": "BEFEHLSABLAUFFOLGEPLANUNG VON EINEM RISC-SUPERSKALARPROZESSOR"}, {"lang": "EN", "text": "SUPERSCALAR RISC PROCESSOR INSTRUCTION SCHEDULING"}, {"lang": "FR", "text": "Planification d'instructions d'un processeur RISC superscalaire"}]}, {"ucid": "JP-2000148489-A", "titles": [{"lang": "JA", "text": "\u30b3\u30f3\u30d4\u30e5\u2015\u30bf\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "COMPUTER SYSTEM"}]}, {"ucid": "JP-3571266-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30d7\u30ed\u30bb\u30c3\u30b5"}, {"lang": "EN", "text": "Super scalar processor"}]}, {"ucid": "JP-3571265-B2", "titles": [{"lang": "JA", "text": "\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "Computer system"}]}, {"ucid": "JP-3571264-B2", "titles": [{"lang": "JA", "text": "\u30ec\u30b8\u30b9\u30bf\u540d\u79f0\u5909\u66f4\u30b7\u30b9\u30c6\u30e0\u53ca\u3073\u540d\u79f0\u5909\u66f4\u65b9\u6cd5"}, {"lang": "EN", "text": "Register Name change system and name change method"}]}, {"ucid": "JP-2000148485-A", "titles": [{"lang": "JA", "text": "\u30ec\u30b8\u30b9\u30bf\u540d\u79f0\u5909\u66f4\u30b7\u30b9\u30c6\u30e0\u53ca\u3073\u540d\u79f0\u5909\u66f4\u65b9\u6cd5"}, {"lang": "EN", "text": "SYSTEM AND METHOD FOR CHANGING REGISTER NAME"}]}, {"ucid": "JP-2000148484-A", "titles": [{"lang": "JA", "text": "\u30ec\u30b8\u30b9\u30bf\u540d\u79f0\u5909\u66f4\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "REGISTER NAME CHANGE SYSTEM"}]}, {"ucid": "KR-100371927-B1", "titles": []}, {"ucid": "KR-950701101-A", "titles": [{"lang": "KO", "text": "\uc288\ud37c\uc2a4\uce7c\ub77c \uc54c\uc544\uc774\uc5d0\uc2a4\uc528(RISC) \uba85\ub839\uc5b4 \uc2a4\ucf00\uc974\ub9c1"}, {"lang": "EN", "text": "Superscalar RCS command scheduling"}]}, {"ucid": "US-7051187-B2", "titles": [{"lang": "EN", "text": "Superscalar RISC instruction scheduling"}]}, {"ucid": "JP-2000148487-A", "titles": [{"lang": "JA", "text": "\u547d\u4ee4\u5b9f\u884c\u65b9\u6cd5"}, {"lang": "EN", "text": "INSTRUCTION EXECUTING METHOD"}]}]}