{"patent_number": "US-5761712-A", "publication_id": 71728028, "family_id": 23893628, "publication_date": "1998-06-02", "titles": [{"lang": "EN", "text": "Data memory unit and method for storing data into a lockable cache in one clock cycle by previewing the tag array"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA10715088\" source=\"national office\"><p>A data memory unit having a load/store unit and a data cache is provided which allows store instructions that are part of a load-op-store instruction to be executed with one access to a data cache. The load/store unit is configured with a load/store buffer having a checked bit and a way field for each buffer storage location. For load-op-store instructions, the checked bit associated with the store portion of the of the instruction is set when the load portion of the instruction accesses and hits the data cache. Also, the way field associated with the store portion is set to the way of the data cache in which the load portion hits. The data cache is configured with a locking mechanism for each cache line stored in the data cache. When the load portion of a load-op-store instruction is executed, the associated line is locked such that the line will remain in the data cache until a store instruction executes. In this way, the store portion of the load-op-store instruction is guaranteed to hit the data cache. The store may then store its data into the data cache without first performing a read cycle to determine if the store address hits the data cache.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA37767515\"><p>A data memory unit having a load/store unit and a data cache is provided which allows store instructions that are part of a load-op-store instruction to be executed with one access to a data cache. The load/store unit is configured with a load/store buffer having a checked bit and a way field for each buffer storage location. For load-op-store instructions, the checked bit associated with the store portion of the of the instruction is set when the load portion of the instruction accesses and hits the data cache. Also, the way field associated with the store portion is set to the way of the data cache in which the load portion hits. The data cache is configured with a locking mechanism for each cache line stored in the data cache. When the load portion of a load-op-store instruction is executed, the associated line is locked such that the line will remain in the data cache until a store instruction executes. In this way, the store portion of the load-op-store instruction is guaranteed to hit the data cache. The store may then store its data into the data cache without first performing a read cycle to determine if the store address hits the data cache.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. A data memory unit comprising:<claim-text>a load/store unit configured to execute load and store instructions wherein said load/store unit includes a first plurality of storage locations configured to store outstanding store instructions and associated store data, and wherein each one of said plurality of storage locations is further configured to store a checked bit; and</claim-text><claim-text>a data cache coupled to said load/store unit wherein said data cache includes a second plurality of storage locations configured to store cache lines, and wherein said data cache is configured to lock a cache line stored within said second plurality of storage locations such that said cache line remains stored within said second plurality of storage locations at least until a clock cycle in which said lock is released;</claim-text><claim-text>wherein said checked bit is indicative, when set, that said load/store unit has performed a load instruction which accesses a same cache line, within said data cache, as a store instruction stored in said one of said first plurality of storage locations and that said load instruction hit in said data cache, and wherein said load/store unit is configured to convey said store instruction to said data cache for storage without first checking said data cache for a hit by said store instruction if said checked bit is set, and wherein said load/store unit is configured to check said data cache for a hit by said store instruction prior to conveying said store instruction for storage if said checked bit is clear.</claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. The data memory unit as recited in claim 1 wherein said data cache is further configured to lock a plurality of said cache lines simultaneously.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. The data memory unit as recited in claim 1 wherein each one of said first plurality of storage locations within said load/store unit is configured to store a way value.</claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. The data memory unit as recited in claim 3 wherein said way value stored within one of said first plurality of storage locations is provided to said first plurality of storage locations during a first clock cycle in which a load instruction accesses said data cache with a load address which is within said same cache line as an address associated with a store instruction stored within said one of said first plurality of storage locations, and wherein said way value is a way of said data cache in which said load address is found to hit.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. The data memory unit as recited in claim 1 wherein said checked bit stored within one of said first plurality of storage locations is set by said load/store unit during a first clock cycle in which a load instruction accesses said data cache with a load address which is within said same cache line as an address associated with a store instruction stored within said one of said first plurality of storage locations, and wherein said checked bit stored within said one of said first plurality of storage locations is set if said load address is found to hit said data cache.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. The data memory unit as recited in claim 1 wherein said data cache is configured to set a lock bit associated with said cache line that is to be locked.</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. The data memory unit as recited in claim 6 wherein said lock bit is set by said data cache during a first clock cycle in which a load instruction accesses said data cache with a load address which is within said same cache line as an address associated with a store instruction stored within one of said first plurality of storage locations of said load/store unit, and wherein said data cache is configured to set said lock bit if said load address is found to hit said data cache.</claim-text></claim>"}, {"num": 8, "parent": 6, "type": "dependent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. The data memory unit as recited in claim 6 wherein said lock bit is cleared during a first clock cycle in which a load-op-store instruction is cancelled.</claim-text></claim>"}, {"num": 9, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. The data memory unit as recited in claim 1 where said checked bits stored within said first plurality of storage locations within said load/store unit are cleared during a first clock cycle in which a load-op-store instruction is cancelled.</claim-text></claim>"}, {"num": 10, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. The data memory unit as recited in claim 1 wherein said first plurality of storage locations within said load/store buffer are further configured to store outstanding load instructions such that said first plurality of storage locations within said load/store unit forms a unified load/store buffer.</claim-text></claim>"}, {"num": 11, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. The data memory unit as recited in claim 1 wherein said load instruction and said store instruction comprise a load portion and a store portion of a load-op-store instruction, respectively.</claim-text></claim>"}, {"num": 12, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"12\"><claim-text>12. A method for storing store data into a data cache without first having to check said data cache for a hit on an address associated with said store data comprising:<claim-text>storing a store instruction into a buffer within a load/store unit;</claim-text><claim-text>clearing a checked bit upon storing said store instruction into said buffer,</claim-text><claim-text>setting said checked bit if a load instruction to a same cache line, within said data cache, as said store instruction is performed by said load/store unit and said load instruction hits in said data cache,</claim-text><claim-text>storing said store data into said data cache during a first clock cycle if said checked bit associated with said store data is set without checking if said store instruction hits in said data cache; and</claim-text><claim-text>checking said data cache for a hit by said store instruction during said first clock cycle if said checked bit associated with said stored data is clear, and storing said store data into said data cache during a second clock cycle subsequent to said first clock cycle if said store instruction hits in said data cache.</claim-text></claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim num=\"13\"><claim-text>13. The method as recited in claim 12 further comprising storing a way value associated with said same cache line in a storage location within said buffer upon said setting said checked bit, wherein said storage location is associated with said store instruction.</claim-text></claim>"}, {"num": 14, "parent": 12, "type": "dependent", "paragraph_markup": "<claim num=\"14\"><claim-text>14. The method as recited in claim 12 further comprising setting a lock bit associated with said same cache line upon detecting that said load instruction hits said same cache line.</claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim num=\"15\"><claim-text>15. The method as recited in claim 14 further comprising clearing said lock bit during a third clock cycle in which a load-op-store type instruction is cancelled.</claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim num=\"16\"><claim-text>16. The method as recited in claim 15 further comprising clearing said check bit during said third clock cycle.</claim-text></claim>"}, {"num": 17, "parent": 15, "type": "dependent", "paragraph_markup": "<claim num=\"17\"><claim-text>17. The method as recited in claim 15 further comprising clearing said lock bit associated with said cache line during a fourth clock cycle in which a store instruction is executed to said cache line.</claim-text></claim>"}, {"num": 18, "parent": 12, "type": "dependent", "paragraph_markup": "<claim num=\"18\"><claim-text>18. The method as recited in claim 12 wherein said load instruction and said store instruction comprise a load portion and a store portion of a load-op-store instruction, respectively.</claim-text></claim>"}, {"num": 19, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"19\"><claim-text>19. A data memory unit comprising:<claim-text>a load/store unit configured to execute load and store instructions wherein said load/store unit includes a first plurality of storage locations configured to store outstanding store instructions and associated store data, and wherein each one of said plurality of storage locations is further configured to store a checked bit; and</claim-text><claim-text>a data cache coupled to said load/store unit wherein said data cache includes a second plurality of storage locations configured to store cache lines;</claim-text><claim-text>wherein said checked bit is indicative, when set, that said load/store unit has performed a load instruction which accesses a same cache line, within said data cache, as a store instruction stored in said one of said first plurality of storage locations and that said load instruction hit in said data cache, and wherein said load/store unit is configured to convey said store instruction to said data cache for storage without first checking said data cache for a hit by said store instruction if said checked bit is set, and wherein said load/store unit is configured to check said data cache for a hit by said store instruction prior to conveying said store instruction for storage if said checked bit is clear.</claim-text></claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim num=\"20\"><claim-text>20. The data memory unit as recited in claim 19 wherein each one of said first plurality of storage locations within said load/store unit is configured to store a way value.</claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim num=\"21\"><claim-text>21. The data memory unit as recited in claim 20 wherein said way value stored within one of said first plurality of storage locations is provided to said first plurality of storage locations during a first clock cycle in which a load instruction accesses said data cache with a load address which is within the said same cache line as an address associated with a store instruction stored within said one of said first plurality of storage locations, and wherein said way value is the a way of said data cache in which said load address is found to hit.</claim-text></claim>"}, {"num": 22, "parent": 19, "type": "dependent", "paragraph_markup": "<claim num=\"22\"><claim-text>22. The data memory unit as recited in claim 19 wherein said checked bit stored within one of said first plurality of storage locations is set by said load/store unit during a first clock cycle in which a load instruction accesses said data cache with a load address which is within said same cache line as an address associated with a store instruction stored within said one of said first plurality of storage locations, and wherein said checked bit stored within said one of said first plurality of storage locations is set if said load address is found to hit said data cache.</claim-text></claim>"}, {"num": 23, "parent": 19, "type": "dependent", "paragraph_markup": "<claim num=\"23\"><claim-text>23. The data memory unit as recited in claim 19 where said checked bits stored within said first plurality of storage locations within said load/store unit are cleared during a first clock cycle in which a load-op-store instruction is cancelled.</claim-text></claim>"}, {"num": 24, "parent": 19, "type": "dependent", "paragraph_markup": "<claim num=\"24\"><claim-text>24. The data memory unit as recited in claim 19 wherein said data cache is further configured to transfer said store data into a receiving cache line stored within said second plurality of storage locations within said data cache during a first clock cycle in which said checked bit associated with said store data is set wherein said receiving cache line is identified by an address associated with said store data and a way value associated with said address.</claim-text></claim>"}, {"num": 25, "parent": 19, "type": "dependent", "paragraph_markup": "<claim num=\"25\"><claim-text>25. The data memory unit as recited in claim 19 wherein said first plurality of storage locations within said load/store buffer are further configured to store outstanding load instructions such that said first plurality of storage locations within said load/store unit forms a unified load/store buffer.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES317748681\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This application is a continuation of application Ser. No. 08/476,879, filed Jun. 7, 1995, now abandoned.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention relates to the field of superscalar microprocessors, and more particularly to a load/store unit and a data cache in a superscalar microprocessor.</p><p>2. Description of the Relevant Art</p><p>Superscalar microprocessors achieve high performance by simultaneously executing multiple instructions in a clock cycle and by specifying the shortest possible clock cycle consistent with the design. As used herein, the term \"clock cycle\" refers to an interval of time during which the pipeline stages of a microprocessor preform their intended functions. At the end of a clock cycle, the resulting values are moved to the next pipeline stage.</p><p>Since superscalar microprocessors execute multiple instructions per clock cycle and the clock cycle is short, a high bandwidth memory system is required to provide instructions and data to the superscalar microprocessor (i.e. a memory system that can provide a large number of bytes in a short period of time). Without a high bandwidth memory system, the microprocessor would spend a large number of clock cycles waiting for instructions or data to be provided, then would execute the received instructions and/or the instructions dependent upon the received data in a relatively small number of clock cycles. Overall performance would be degraded by the large number of idle clock cycles. However, superscalar microprocessors are ordinarily configured into computer systems with a large main memory composed of dynamic random access memory (DRAM) cells. DRAM cells are characterized by access times which are significantly longer than the clock cycle of modern superscalar microprocessors. Also, DRAM cells typically provide a relatively narrow output bus to convey the stored bytes to the superscalar microprocessor. Therefore, DRAM cells provide a memory system that provides a relatively small number of bytes in a relatively long period of time, and do not form a high bandwidth memory system.</p><p>Because superscalar microprocessors are typically not configured into a computer system with a memory system having sufficient bandwidth to continuously provide instructions and data, superscalar microprocessors are often configured with caches. Caches are multiple blocks of storage locations, configured on the same silicon substrate as the microprocessor or coupled nearby. The blocks of storage locations are used to hold previously fetched instruction or data bytes. The bytes can be transferred from the cache to the destination (a register or an instruction processing pipeline) quickly; commonly one or two clock cycles are required as opposed to a large number of clock cycles to transfer bytes from a DRAM main memory.</p><p>Caches may be organized into an \"associative\" structure. In an associative structure, the blocks of storage locations are accessed as a two-dimensional array having rows and columns. When a cache is searched for bytes residing at an address, a number of bits from the address are used as an \"index\" into the cache. The index selects a particular row within the two-dimensional array, and therefore the number of address bits required for the index is determined by the number of rows configured into the cache. The addresses associated with bytes stored in the multiple blocks of a row are examined to determine if any of the addresses stored in the row match the requested address. If a match is found, the access is said to be a \"hit\", and the cache provides the associated bytes. If a match is not found, the access is said to be a \"miss\". When a miss is detected, the bytes are transferred from the memory system into the cache. The addresses associated with bytes stored in the cache are also stored. These stored addresses are referred to as \"tags\" or \"tag addresses\".</p><p>The blocks of memory configured into a row form the columns of the row. Each block of memory is referred to as a \"way\"; multiple ways comprise a row. The way is selected by providing a way value to the cache. The way value is determined by examining the tags for a row and finding a match between one of the tags and the requested address. A cache designed with one way per row is referred to as a \"direct-mapped cache\". In a direct-mapped cache, the tag must be examined to determine if an access is a hit, but the tag examination is not required to select the which bytes are transferred to the outputs of the cache.</p><p>Both direct-mapped and associative caches are employed in high frequency (i.e. short clock cycle) superscalar microprocessors. For both types of caches, one read or one write may be performed in a clock cycle when the cache is configured with a single port. Even when the cache is configured with multiple ports, generally the same block of memory may not be read and written in the same clock cycle. Caches are large structures which typically require most (if not all) of a clock cycle to perform a read or a write due to the large capacitances involved and other well-known properties with respect to cache arrays. Furthermore, reading and writing the same memory location in a clock cycle involves making the array significantly larger and slower, thus impacting the clock cycle time and the silicon area of a superscalar microprocessor.</p><p>Due to the requirement that a memory location of a cache cannot be read and written in the same clock cycle, store instructions require two cache accesses to complete. The first cache access reads the cache to check for a hit of the address associated with the store instruction. If the address is a hit, then a second cycle is used to write the store data into the cache. If the address is a miss, the bytes associated with the address are transferred into the cache. After the bytes are transferred, the store instruction accesses the cache again to write the store data into the cache. A solution to the problem of store instructions requiring at least two cache access cycles is desired.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by a data memory unit employing a load/store unit and a data cache according to the present invention. The load/store unit is configured with a load/store buffer having a checked bit and a way field for each buffer storage location. For load-op-store instructions, the checked bit of the storage location storing the store portion of the instruction is set when the load portion of the instruction accesses and hits the data cache. Also, the way field of the storage location is set to the way of the data cache in which the load portion hits. The data cache is configured with a locking mechanism for each cache line stored in the data cache. When the load portion of a load-op-store instruction is executed, the associated line is locked such that the line will remain in the data cache until a store instruction executes. In this way, the store portion of the load-op-store instruction is guaranteed to hit the data cache in the way indicated by the way field associated with the store portion.</p><p>The load/store unit and data cache allow the advantageous reduction of the store portion of load-op-store instructions from two clock cycles of data cache access to one clock cycle of data cache access. Performance of a superscalar microprocessor employing such a data memory unit may be increased by allowing more data cache accesses in a given set of clock cycles in which load-op-store instructions are executed.</p><p>Broadly speaking, the present invention contemplates a data memory unit comprising a load/store unit and a data cache. The load/store unit is configured to execute load and store instructions and includes a first plurality of storage locations configured to store outstanding store instructions and associated store data. Each one of said plurality of storage locations is configured to store a checked bit. The data cache is coupled to the load/store unit and includes a second plurality of storage locations configured to store cache lines. The data cache is configured to lock a cache line stored within the second plurality of storage locations such that the cache line remains stored within the plurality of storage locations at least until a clock cycle in which the lock is released.</p><p>The present invention further contemplates a method for storing store data into a data cache without first having to check the data cache for a hit on an address associated with the store data. The method comprises storing the store data into the data cache during a first clock cycle in which a checked bit associated with the store data is set.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of a superscalar microprocessor including a load/store unit and a data cache in accordance with the present invention.</p><p>FIG. 2 is a diagram showing certain internal components of the load/store unit including a load/store buffer in accordance with the present invention.</p><p>FIG. 3 is a diagram of the bit fields of a storage location of the load/store buffer shown in FIG. 2.</p><p>FIG. 4A is a diagram of a tag entry for the data cache in accordance with the present invention.</p><p>FIG. 4B is a diagram of a data cache tag array including tag entries shown in FIG. 4A, including a clearing mechanism for the lock bit of the tag entry.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>Referring next to FIG. 1, a block diagram of a superscalar microprocessor 200 including a load/store unit 222 and a data cache 224 in accordance with the present invention is shown. As illustrated in the embodiment of FIG. 1, superscalar microprocessor 200 includes a prefetch/predecode unit 202 and a branch prediction unit 220 coupled to an instruction cache 204. Instruction alignment unit 206 is coupled between instruction cache 204 and a plurality of decode units 208A-208F (referred to collectively as decode units 208). Each decode unit 208A-208F is coupled to respective reservation station units 210A-210F (referred to collectively as reservation stations 210), and each reservation station 210A-210F is coupled to a respective functional unit 212A-212F (referred to collectively as functional units 212). Decode units 208, reservation stations 210, and functional units 212 are further coupled to a reorder buffer 216, a register file 218 and a load/store unit 222. A data cache 224 is finally shown coupled to load/store unit 222, and an MROM unit 209 is shown coupled to instruction alignment unit 206.</p><p>Generally speaking, instruction cache 204 is a high speed cache memory provided to temporarily store instructions prior to their dispatch to decode units 208. In one embodiment, instruction cache 204 is configured to cache up to 32 kilobytes of instruction code organized in lines of 16 bytes each (where each byte consists of 8 bits). During operation, instruction code is provided to instruction cache 204 by prefetching code from a main memory (not shown) through prefetch/predecode unit 202. It is noted that instruction cache 204 could be implemented in a set-associative, a fully-associative, or a direct-mapped configuration.</p><p>Prefetch/predecode unit 202 is provided to prefetch instruction code from the main memory for storage within instruction cache 204. In one embodiment, prefetch/predecode unit 202 is configured to burst 64-bit wide code from the main memory into instruction cache 204. It is understood that a variety of specific code prefetching techniques and algorithms may be employed by prefetch/predecode unit 202.</p><p>As prefetch/predecode unit 202 fetches instructions from the main memory, it generates three predecode bits associated with each byte of instruction code: a start bit, an end bit, and a \"functional\" bit. The predecode bits form tags indicative of the boundaries of each instruction. The predecode tags may also convey additional information such as whether a given instruction can be decoded directly by decode units 208 or whether the instruction must be executed by invoking a microcode procedure controlled by MROM unit 209, as will be described in greater detail below.</p><p>Table 1 indicates one encoding of the predecode tags. As indicated within the table, if a given byte is the first byte of an instruction, the start bit for that byte is set. If the byte is the last byte of an instruction, the end bit for that byte is set. If a particular instruction cannot be directly decoded by decode units 208, the functional bit associated with the first byte of the instruction is set. On the other hand, if the instruction can be directly decoded by the decode units 208, the functional bit associated with the first byte of the instruction is cleared. The functional bit for the second byte of a particular instruction is cleared if the opcode is the first byte, and is set if the opcode is the second byte. It is noted that in situations where the opcode is the second byte, the first byte is a prefix byte. The functional bit values for instruction byte numbers 3-8 indicate whether the byte is a MODRM or an SIB byte, or whether the byte contains displacement or immediate data. The SIB byte is the scale-index-base byte defined by the x86 microprocessor architecture. The byte is used to specify an base-index addressing mode for a memory operand of an instruction.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 1                                                     \n______________________________________                                    \nEncoding of Start, End and Functional Bits                                \nInstr.  Start    End    Functional                                        \nByte    Bit      Bit    Bit                                               \nNumber  Value    Value  Value     Meaning                                 \n______________________________________                                    \n1       1        X      0         Fast decode                             \n1       1        X      1         MROM instr.                             \n2       0        X      0         Opcode is first                         \n                                  byte                                    \n2       0        X      1         Opcode is this                          \n                                  byte, first                             \n                                  byte is prefix                          \n3-8     0        X      0         Mod R/M or                              \n                                  SIB byte                                \n3-8     0        X      1         Displacement or                         \n                                  immediate data;                         \n                                  the second                              \n                                  functional bit                          \n                                  set in bytes                            \n                                  3-8 indicates                           \n                                  immediate data                          \n1-8     X        0      X         Not last byte                           \n                                  of instruction                          \n1-8     X        1      X         Last byte of                            \n                                  instruction                             \n______________________________________                                    \n</pre><p>As stated previously, in one embodiment certain instructions within the x86 instruction set may be directly decoded by decode unit 208. These instructions are referred to as \"fast path\" instructions. The remaining instructions of the x86 instruction set are referred to as \"MROM instructions\". MROM instructions are executed by invoking MROM unit 209. More specifically, when an MROM instruction is encountered, MROM unit 209 parses and serializes the instruction into a subset of defined fast path instructions to effectuate a desired operation.</p><p>Instruction alignment unit 206 is provided to channel variable byte length instructions from instruction cache 204 to fixed issue positions formed by decode units 208A-208F. Instruction alignment unit 206 independently and in parallel selects instructions from three groups of instruction bytes provided by instruction cache 204 and arranges these bytes into three groups of preliminary issue positions. Each group of issue positions is associated with one of the three groups of instruction bytes. The preliminary issue positions are then merged together to form the final issue positions, each of which is coupled to one of decode units 208.</p><p>Before proceeding with a detailed description of load/store unit 222 and data cache 224, general aspects regarding other subsystems employed within the exemplary superscalar microprocessor 200 of FIG. 1 will be described. For the embodiment of FIG. 1, each of the decode units 208 includes decoding circuitry for decoding the predetermined fast path instructions referred to above. In addition, each decode unit 208A-208F routes displacement and immediate data to a corresponding reservation station unit 210A-210F. Output signals from the decode units 208 include bit-encoded execution instructions for the functional units 212 as well as operand address information, immediate data and/or displacement data.</p><p>The superscalar microprocessor of FIG. 1 supports out of order execution, and thus employs reorder buffer 216 to keep track of the original program sequence for register read and write operations, to implement register renaming, to allow for speculative instruction execution and branch misprediction recovery, and to facilitate precise exceptions. As will be appreciated by those of skill in the art, a temporary storage location within reorder buffer 216 is reserved upon decode of an instruction that involves the update of a register to thereby store speculative register states. Reorder buffer 216 may be implemented in a first-in-first-out configuration wherein speculative results move to the \"bottom\" of the buffer as they are validated and written to the register file, thus making room for new entries at the \"top\" of the buffer. Other specific configurations of reorder buffer 216 are also possible, as will be described further below. If a branch prediction is incorrect, the results of speculatively-executed instructions along the mispredicted path can be invalidated in the buffer before they are written to register file 218.</p><p>The bit-encoded execution instructions and immediate data provided at the outputs of decode units 208A-208F are routed directly to respective reservation station units 210A-210F. In one embodiment, each reservation station unit 210A-210F is capable of holding instruction information (i.e., bit encoded execution bits as well as operand values, operand tags and/or immediate data) for up to three pending instructions awaiting issue to the corresponding functional unit. It is noted that for the embodiment of FIG. 1, each decode unit 208A-208F is associated with a dedicated reservation station unit 210A-210F, and that each reservation station unit 210A-210F is similarly associated with a dedicated functional unit 212A-212F. Accordingly, six dedicated \"issue positions\" are formed by decode units 208, reservation station units 210 and functional units 212. Instructions aligned and dispatched to issue position 0 through decode unit 208A are passed to reservation station unit 210A and subsequently to functional unit 212A for execution. Similarly, instructions aligned and dispatched to decode unit 208B are passed to reservation station unit 210B and into functional unit 212B, and so on.</p><p>Upon decode of a particular instruction, if a required operand is a register location, register address information is routed to reorder buffer 216 and register file 218 simultaneously. Those of skill in the art will appreciate that the x86 register file includes eight 32 bit real registers (i.e., typically referred to as EAX, EBX, ECX, EDX, EBP, ESI, EDI and ESP). Reorder buffer 216 contains temporary storage locations for results which change the contents of these registers to thereby allow out of order execution. A temporary storage location of reorder buffer 216 is reserved for each instruction which, upon decode, is determined to modify the contents of one of the real registers. Therefore, at various points during execution of a particular program, reorder buffer 216 may have one or more locations which contain the speculatively executed contents of a given register. If following decode of a given instruction it is determined that reorder buffer 216 has a previous location or locations assigned to a register used as an operand in the given instruction, the reorder buffer 216 forwards to the corresponding reservation station either: 1) the value in the most recently assigned location, or 2) a tag for the most recently assigned location if the value has not yet been produced by the functional unit that will eventually execute the previous instruction. If the reorder buffer has a location reserved for a given register, the operand value (or tag) is provided from reorder buffer 216 rather than from register file 218. If there is no location reserved for a required register in reorder buffer 216, the value is taken directly from register file 218. If the operand corresponds to a memory location, the operand value is provided to the reservation station unit through load/store unit 222.</p><p>Details regarding suitable reorder buffer implementations may be found within the publication \"Superscalar Microprocessor Design\" by Mike Johnson, Prentice-Hall, Englewood Cliffs, N.J., 1991, and within the co-pending, commonly assigned patent application entitled \"High Performance Superscalar Microprocessor\", Ser. No. 08/146,382, filed Oct. 29, 1993 by Witt, et al. These documents are incorporated herein by reference in their entirety.</p><p>Reservation station units 210A-210F are provided to temporarily store instruction information to be speculatively executed by the corresponding functional units 212A-212F. As stated previously, each reservation station unit 210A-210F may store instruction information for up to three pending instructions. Each of the six reservation stations 210A-210F contain locations to store bit-encoded execution instructions to be speculatively executed by the corresponding functional unit and the values of operands. If a particular operand is not available, a tag for that operand is provided from reorder buffer 216 and is stored within the corresponding reservation station until the result has been generated (i.e., by completion of the execution of a previous instruction). It is noted that when an instruction is executed by one of the functional units 212A-212F, the result of that instruction is passed directly to any reservation station units 210A-210F that are waiting for that result at the same time the result is passed to update reorder buffer 216 (this technique is commonly referred to as \"result forwarding\"). Instructions are issued to functional units for execution after the values of any required operand(s) are made available. That is, if an operand associated with a pending instruction within one of the reservation station units 210A-210F has been tagged with a location of a previous result value within reorder buffer 216 which corresponds to an instruction which modifies the required operand, the instruction is not issued to the corresponding functional unit 212 until the operand result for the previous instruction has been obtained. Accordingly, the order in which instructions are executed may not be the same as the order of the original program instruction sequence. Reorder buffer 216 ensures that data coherency is maintained in situations where read-after-write dependencies occur.</p><p>In one embodiment, each of the functional units 212 is configured to perform integer arithmetic operations of addition and subtraction, as well as shifts, rotates, logical operations, and branch operations. It is noted that a floating point unit (not shown) may also be employed to accommodate floating point operations.</p><p>Each of the functional units 212 also provides information regarding the execution of conditional branch instructions to the branch prediction unit 220. If a branch prediction was incorrect, branch prediction unit 220 flushes instructions subsequent to the mispredicted branch that have entered the instruction processing pipeline, and causes prefetch/predecode unit 202 to fetch the required instructions from instruction cache 204 or main memory. It is noted that in such situations, results of instructions in the original program sequence which occur after the mispredicted branch instruction are discarded, including those which were speculatively executed and temporarily stored in load/store unit 222 and reorder buffer 216. Exemplary configurations of suitable branch prediction mechanisms are well known.</p><p>Results produced by functional units 212 are sent to the reorder buffer 216 if a register value is being updated, and to the load/store unit 222 if the contents of a memory location is changed. If the result is to be stored in a register, the reorder buffer 216 stores the result in the location reserved for the value of the register when the instruction was decoded. As stated previously, results are also broadcast to reservation station units 210A-210F where pending instructions may be waiting for the results of previous instruction executions to obtain the required operand values.</p><p>Generally speaking, load/store unit 222 provides an interface between functional units 212A-212F and data cache 224. In one embodiment, load/store unit 222 is configured with a load/store buffer with sixteen storage locations for data and address information for pending loads or stores. Decode units 208 arbitrate for access to the load/store unit 222. When the buffer is full, a decode unit must wait until the load/store unit 222 has room for the pending load or store request information. Functional units 212 provide the load/store instruction and associated address and data information to load/store unit 222. Load/store unit 222 executes the load/store instructions by accessing data cache 224 and causing data cache 224 to fetch a line from main memory when a non-speculative load/store instruction misses the cache. Load/store unit 222 returns the requested data for load instructions to reorder buffer 216 as well as any reservation stations 210 that may be waiting for the data. Store data is stored into data cache 224 by load/store unit 222. The load/store unit 222 also performs dependency checking for load instructions against pending store instructions to ensure that data coherency is maintained.</p><p>Data cache 224 is a high speed cache memory provided to temporarily store data being transferred between load/store unit 222 and the main memory subsystem. In one embodiment, data cache 224 has a capacity of storing up to thirty-two kilobytes of data in an eight way set associative structure with thirty-two byte lines. It is understood that data cache 224 may be implemented in a variety of specific memory configurations, including a set associative configuration.</p><p>Turning now to FIG. 2, a diagram depicting several important components of load/store unit 222 employing an embodiment of the present invention is shown. Load/store unit 222 has an input bus 250 coupled to functional units 212 for providing load/store instructions, address and data information. Input bus 250 conveys information to a load/store buffer 251. Load/store buffer 251 stores information pertaining to outstanding load and store instructions. Request bus 253 conveys a load/store request to data cache 224 as selected by multiplexor circuit 254 under the control of output control circuit 255. Returning from the data cache is a hit/way bus 256 which is coupled to load/store buffer 251. On hit/way bus 256, load/store unit 222 receives hit/miss information and the way value of data cache 224 in which the hit is detected for requests conveyed on request bus 253. Clear signal line 257 from reorder buffer 216 is coupled to control circuits related to load/store buffer 251.</p><p>Generally speaking, load/store unit 222 selects a load or store memory request to convey to data cache 224 on request bus 253. A \"checked bit\" in the associated buffer storage location will be set if the current request hits data cache 224. The checked bit remains set as long as the instruction is valid and the clear signal on clear signal line 257 is not asserted. Also, the way value from data cache 224 indicating the way in which the current request address hits is stored in the associated buffer storage location in a way field. Updating the load/store buffer storage location of the current request with the cache information associated with the current request serves three purposes: 1) load instructions that miss the data cache will be updated with the miss information, 2) store instructions will be updated with the hit and way for the second cycle access during which the write occurs, and 3) store instructions that are part of a \"load-op-store\" instruction are updated with the way and hit values for the associated load instruction, allowing the store to execute with only one access to data cache 224.</p><p>Load-op-store instructions are x86 instructions that use a memory location as both a source and a target. In other words, one of the operands of a load-op-store instruction is a memory location and the result of the load-op-store instruction is stored into the memory location. Load-op-store instructions, when executed on superscalar microprocessor 200, are dispatched as both a load and a store instruction to load/store unit 222 with the same reorder buffer tag associated with both. The load and store instruction are both stored in the same storage location within load/store buffer 251. Cache hit and way information is recorded for the store portion of the load-op-store instruction when the load portion executes, and the first clock cycle of the normal two-clock cycle store access can be eliminated. It is important to ensure that in clock cycles between the execution of the load portion and the execution of the store portion of a load-op-store instruction that the associated data cache line remain stored in the data cache. This function is implemented through the use of a lock bit which will be explained in more detail below.</p><p>As shown in the embodiment of FIG. 2, load/store buffer 251 is a linear array of storage locations containing a reorder buffer tag (indicated by the TAG field in FIG. 2), a checked bit (the C field), and a way field (the W field) associated with load/store instructions. In one embodiment, load/store buffer 251 is configured with sixteen storage locations. Other information is stored in each load/store buffer entry as will be described in more detail below. Associated with each storage location is a block of logic circuits to update the checked bit each clock cycle.</p><p>An embodiment of the logic circuits associated with one entry are shown in FIG. 2 as AND gates 258, 259 and 261 as well as OR gate 260. Similar circuits are created for each storage location within load/store buffer 251. AND gate 261 decodes the buffer entry of the request on request bus 253. If the buffer entry matches the buffer entry associated with this group of logic circuits, then it is eligible for update. The output of AND gate 261 will be high if the entry is eligible for update. AND gate 258 receives the output of AND gate 261 as well as the hit bit from the cache. AND gate 258 forms one of the inputs to OR gate 260, which sets or clears the checked bit within the storage location. Therefore, if this buffer entry is currently accessing data cache 224 and the access is a hit, the output of AND gate 258 (and therefore OR gate 260) is a logical one and the checked bit is set. AND gate 259 receives the current state of the checked bit and clear signal line 257 from reorder buffer 216. The clear signal conveyed on clear signal line 257 is asserted by reorder buffer 216 whenever an exception, branch misprediction, or other event occurs which causes the flow of instructions to change from the path that was predicted. When these types of events occur, it may be necessary to cancel some of the instructions in the load/store buffer via a mechanism between load/store unit 222 and reorder buffer 216 (not shown). Therefore, the checked bits are cleared in load/store buffer 251 because the lock bits are being cleared in data cache 224 (as will be detailed below). AND gate 259 provides this functionality. The checked bit will remain set unless the clear signal is asserted, in which case the checked bit will be cleared.</p><p>Multiplexor 254 and output control unit 255 are used to select requests for access to data cache 224 in a given clock cycle. In one embodiment, up to two requests are selected each clock cycle. In this embodiment, output control unit 255 implements a priority scheme for selecting operations from load/store buffer 251, in which store instructions that are no longer speculative and load instructions that are no longer speculative and have missed the data cache are given a high priority, and load instructions that are speculative are given a low priority. It is understood that multiplexor circuit 254 may be implemented as multiple multiplexor circuits which produce the requests transferred on request bus 253. Request bus 253 conveys at least the address associated with the request, whether the request is a load or a store type request, and the way value, checked bit, and store data for store requests. Data cache 224 is configured to store data into the cache line indexed by the request address and selected by the associated way value if the checked bit is set. If the checked bit is not set, data cache 224 reads the indexed lines of the cache to check for a cache hit for the request address. In one embodiment, the load-op-store bit is conveyed for load requests (as will be explained below).</p><p>It is noted that load/store buffer 251 may vary in number of entries from embodiment to embodiment. Furthermore, load/store buffer 251 may be configured as a separate load buffer and store buffer, in which the load buffer stores all load instructions and the store buffer stores all store instructions. It is further noted that more than one request may be transferred per clock cycle on request bus 253.</p><p>In another embodiment, the addresses accessing data cache 224 are compared to the addresses stored with load/store buffer 251. This embodiment is more general than the previous embodiment in that the store instructions that may eliminate the two cycle access need not be the store portion of a load-op-store instruction. However, the locking of the cache is more complicated. The lock bit associated with an accessed cache line would need to be set if a checked bit is set due to the cache access, instead of locking based on the fact that the load is a part of a load-op-store instruction. This embodiment would generally lock the cache line in a clock cycle subsequent to the clock cycle in which the access occurs.</p><p>Turning now to FIG. 3, a diagram of the bit fields in a load/store buffer storage location is shown for one embodiment of load/store buffer 251. Field 300 includes the reorder buffer tag for the storage location as well as a valid bit indicating when set that the storage location is currently storing a valid load or store instruction. Field 301 stores the address associated with the load or store instruction, as provided by functional units 212. A valid bit is also included in field 301 indicating when set that the address is valid. Output control unit 255 does not select a load/store instruction for access to data cache 224 until the address valid bit is set. Field 302 stores the data associated with store instructions, as well as a valid bit indicating when set that the data field is valid. Bit 303 is the checked bit discussed above, and field 304 is the way field discussed above. Bit 305 is a bit used for load instructions which indicates when set that the load instruction is the load portion of a load-op-store instruction. This bit is used to determine whether or not to set the lock bit for an associated cache line, as detailed below. It is understood that other bits may be added to the storage locations by various embodiments of load/store unit 222. For example, a miss bit and a dependent bit may be added to indicate that an instruction is a data cache miss and that an instruction is dependent on a store instruction residing in another storage location within the load/store buffer, respectively.</p><p>Turning now to FIG. 4A, a diagram of bit fields in a data cache tag entry is shown for one embodiment. The tag entry is configured with a state field 401 indicating the state of the associated cache line. In one embodiment, state field 401 is two bits wide to encode an MESI state for the cache line. As will be understood by those skilled in the art, an MESI state encodes a modified or \"dirty\" state in which the cache line has been modified with respect to the contents stored at the associated address in main memory and therefore the cache line must be written back to main memory when removed from data cache 224; an exclusive state in which the cache line is stored in data cache 224 and no other copies of the cache line exist in other superscalar microprocessors configured into a system with superscalar microprocessor 200; a shared state in which the cache line is stored in data cache 224 and other copies of the cache line may be stored in other superscalar microprocessors configured into a system with superscalar microprocessor 200; and an invalid state indicating the associated cache line is not valid and the bytes stored therein should not be used.</p><p>Field 402 of the tag entry contains the tag of the entry. As discussed above, a tag is the portion of the address which uniquely identifies which bytes from main memory are stored in the cache line. In one embodiment, field 402 is 20 bits wide and contains the 20 highest order bits of the address associated with the bytes stored in the cache line. Bit 403 is the aforementioned lock bit. If bit 403 is set, then the associated cache line may not be removed from data cache 224 when a new cache line is fetched from main memory. Instead, another cache line within the row must be removed. Lock bit 403 is set when a load instruction with its corresponding load-op-store bit set accesses the associated cache line and is found to hit. Since each tag entry is configured with a lock bit, data cache tag array 404 may maintain locks for multiple cache lines simultaneously. Lock bit 403 is cleared when a store instruction is executed to the associated cache line, or when the clear signal conveyed on clear signal line 257 is asserted from reorder buffer 216 (as will be discussed in more detail below).</p><p>A scenario requiring special attention is the case where the load portion of a load-op-store instruction accesses a cache line in which the lock bit is already set. The lock bit being set indicates that a previous load-op-store instruction has accessed the cache line with its load portion but the store portion has not executed yet. When the store portion of the previous load-op-store instruction stores into the cache line, it will clear the lock bit, as noted above. Therefore, the lock bit will be cleared before the store portion of the current load-op-store instruction accesses data cache 224, and the associated line may be removed from the cache. Dependency checking within load/store unit 222 prevents the load portion from accessing the cache. When load/store unit 222 performs load data cache accesses, load/store unit 222 also performs dependency checking against stores in load/store buffer 251. If the address of a store matches the address of the load, then a dependency is detected. Instead, the load data is provided by the load/store buffer 251. In one embodiment, the checked bit is not set for the associated store portion. Therefore, the store portion of the load-op-store instruction will require two data cache accesses to complete for this scenario. In another embodiment, the checked bit for the associated store portion is set, and a bit is set for the store instruction providing the data for the load portion indicating that it should not reset the lock bit when it accesses data cache 224. In this embodiment, both stores complete in a single access to the cache.</p><p>Turning now to FIG. 4B, a block diagram of a data cache tag array 404 associated with data cache 224 is shown. In one embodiment, data cache 224 is eight way set associative and so each row of data cache tag array 404 contains eight entries of the type shown in FIG. 4A. Cache tag array 404 is also coupled to clear signal line 257 such that during a clock cycle in which the clear signal is asserted, each lock bit within data cache tag array 404 is cleared. The clear signal allows lock bits to be cleared when reorder buffer 216 detects that a load-op-store instruction is cancelled. Exemplary cancellation reasons include a branch misprediction for a branch instruction prior to the load-op-store instruction and an exception associated with an instruction prior to the load-op-store instruction. Such cancellations may occur in a clock cycle between the execution of the load portion of a load-op-store instruction and the store portion of the instruction. If a lock bit which was set by a load-op-store instruction that was later cancelled is not cleared then the line would remain in data cache 224 indefinitely (since no store instruction would store into the line to clear the lock bit). Therefore, all lock bits are cleared in cases where a load-op-store instruction is cancelled after the execution of the load portion of the instruction. If store portions of load-op-store instructions that were not cancelled when the above clear occurred still reside in load/store buffer 251 (shown in FIG. 2) then those stores have their checked bits cleared (as shown in FIG. 2 with AND gate 259) and will take two cycles to execute. Events that cause the clear signal to be asserted are relatively rare in superscalar microprocessors, and so most load-op-store instructions will enjoy the benefit of a single cycle store.</p><p>It is noted that data cache tag array 404 may be implemented as part of the data cache array 224 which stores the data bytes, or may be implemented as a physically separate array. Furthermore, the associativity of data cache 224 may vary from embodiment to embodiment. In a direct-mapped embodiment of data cache 224, the way field in the storage locations of load/store buffer 251 may not be used.</p><p>It is noted that a superscalar microprocessor in accordance with the foregoing may further employ the latching structures as disclosed within the co-pending, commonly assigned patent application entitled \"Conditional Latching Mechanism and Pipelined Microprocessor Employing the Same\", Ser. No. 08/400,608 filed Mar. 8, 1995, by Pflum et al. The disclosure of this patent application is incorporated herein by reference in its entirety.</p><p>It is further noted that aspects regarding array circuitry may be found in the co-pending, commonly assigned patent application entitled \"High Performance Ram Array Circuit Employing Self-Time Clock Generator for Enabling Array Access\" filed concurrently herewith by Tran. The disclosure of this patent application is incorporated herein by reference in its entirety.</p><p>It is additionally noted that other aspects regarding superscalar microprocessors may be found in the co-pending, commonly assigned patent application entitled \"Superscalar Microprocessor Including a High Performance Instruction Alignment Unit\", Ser. No. 08/377,843, filed Jan. 25, 1995 by Witt, et al. The disclosure of this patent application is incorporated herein by reference in its entirety.</p><p>In accordance with the above disclosure, a load/store unit and a data cache for a superscalar microprocessor have been described. The combination of the load/store unit and the data cache allow for the store portion of load-op-store instructions to be executed in a single clock cycle of access to the data cache, as opposed to the two clock cycles typically used by stores to search for the associated cache line and store the data, respectively. Therefore, higher performance may be achieved through the removal of a data cache access cycle from most load-op-store instructions.</p><p>Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Thang M.", "last_name": "Tran", "name": ""}, {"first_name": "James K.", "last_name": "Pickett", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES"}, {"first_name": "", "last_name": "GLOBALFOUNDRIES U.S. INC.", "name": ""}, {"first_name": "", "last_name": "GLOBALFOUNDRIES INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/38        20060101A I20051008RMEP"}, {"label": "G06F   9/46        20060101A I20051008RMEP"}, {"label": "G06F  12/12        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711126"}, {"primary": false, "label": "711145"}, {"primary": false, "label": "712026"}, {"primary": false, "label": "712E09049"}, {"primary": false, "label": "712E09054"}, {"primary": false, "label": "711E12075"}], "ecla_classes": [{"label": "G06F   9/52"}, {"label": "G06F   9/38E"}, {"label": "G06F   9/38E6"}, {"label": "G06F  12/12B6"}], "cpc_classes": [{"label": "G06F   9/384"}, {"label": "G06F   9/3853"}, {"label": "G06F   9/3855"}, {"label": "G06F   9/52"}, {"label": "G06F   9/3857"}, {"label": "G06F  12/126"}, {"label": "G06F   9/3836"}, {"label": "G06F   9/3855"}, {"label": "G06F   9/3857"}, {"label": "G06F  12/126"}, {"label": "G06F   9/3853"}, {"label": "G06F   9/3836"}, {"label": "G06F   9/52"}, {"label": "G06F   9/384"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1995-06-07", "application_date": "1997-05-05", "family_members": [{"ucid": "US-5761712-A", "titles": [{"lang": "EN", "text": "Data memory unit and method for storing data into a lockable cache in one clock cycle by previewing the tag array"}]}]}