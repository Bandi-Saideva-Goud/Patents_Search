{"patent_number": "US-5386526-A", "publication_id": 70988381, "family_id": 25116286, "publication_date": "1995-01-31", "titles": [{"lang": "EN", "text": "Cache memory controller and method for reducing CPU idle time by fetching data during a cache fill"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA37396309\"><p>A cache memory controller and an associated method for fetching data are utilized to reduce the idle time of a central processing unit (CPU) of a computer system. Control circuitry and a plurality of cache fill status registers are provided to a cache controller to enable a data word to be fetched and returned to the CPU while a cache memory fill initiated due to a prior cache miss is still in progress. The data word is returned if the data word is stored in a main memory location which corresponds to a memory block offset of a main memory block frame currently being mapped into the cache memory. The data word is retrieved and returned to the CPU simultaneous with its writing into the cache memory, if the data word has not been written into the cache memory; otherwise, the data word is retrieved and returned to the CPU at the next dead cycle. As a result, CPU idle time due to cache read misses is reduced.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. In a computer system comprising a central processing unit (CPU) and a cache and main memory hierarchy having a cache memory and a main memory, a method for fetching data for said CPU from said cache and main memory hierarchy that reduces CPU idle time, said method comprising the steps of:<claim-text>receiving a first memory address from said CPU, said first memory address referencing a first memory location of said main memory where a first data word being fetched by said CPU is stored;</claim-text><claim-text>determining whether a first cache memory fill is in progress, said first cache memory fill being initiated due to a first cache read miss which resulted from previously receiving a second memory address from said CPU, said second memory address referencing a second memory location of said main memory where a second data word being fetched by said CPU is stored, said second data word having been subsequently retrieved from said cache and main memory hierarchy and returned to said CPU;</claim-text><claim-text>determining how to fetch said first data word from said cache memory and said main memory and return said first data word to said CPU, wherein said step of determining how to fetch and return said first data word comprises determining whether said first cache memory fill is in progress, and determining whether said first cache memory fill includes storing said first data word in said cache memory if said first cache memory fill is in progress;</claim-text><claim-text>sending signals to said CPU, said cache memory, and said main memory accordingly, thereby resulting in said first data word being retrieved from said cache and main memory hierarchy and returned to said CPU.</claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. The method for fetching data as set forth in claim 1, wherein said first and second memory addresses reference said first and second memory locations with a first and second plurality of ordered bits respectively,<claim-text>said first and second plurality of ordered bits comprising a first and a second plurality of high order bits referencing a first and a second memory block frame respectively, and a first and a second plurality of low order bits referencing a first and a second memory block offset respectively, into said first and second memory block frames where said first and second memory locations are located respectively;</claim-text><claim-text>said first and second memory block frames having first and second n<sub>1</sub> memory block offsets corresponding to first and second n<sub>1</sub> memory locations for storing first and second n<sub>1</sub> data words respectively, wherein said first memory block offset is one of said first n<sub>1</sub> memory block offsets and said second memory block offset is one of said second n<sub>1</sub> memory block offsets, said first memory location is one of said first n<sub>1</sub> memory locations and said second memory location is one of said second n<sub>1</sub> memory locations, and said first data word is one of said first n<sub>1</sub> data words and said second data word is one of said second n<sub>1</sub> data words;</claim-text><claim-text>said first and second n<sub>1</sub> memory locations being referenced by first and second n<sub>1</sub> memory addresses comprising first and second n<sub>1</sub> pluralities of ordered bits, wherein said first memory address is one of said first n<sub>1</sub> memory addresses and said second memory address is one of said second n<sub>1</sub> memory addresses, and said first plurality of ordered bits is one of said first n<sub>1</sub> pluralities of ordered bits and said second plurality of ordered bits is one of said second n<sub>1</sub> pluralities of ordered bits; and</claim-text><claim-text>said first and second n<sub>1</sub> pluralities of ordered bits comprising first and second n<sub>1</sub> pluralities of high ordered bits referencing said first and second memory block frames and first and second n<sub>1</sub> pluralities of low ordered bits referencing said first and second n<sub>1</sub> memory block offsets, wherein said first plurality of high order bits is one of said first n<sub>1</sub> pluralities of high order bits and said second plurality of high order bits is one of said second n<sub>1</sub> pluralities of high order bits, and said first plurality of low order bits is one of said first n<sub>1</sub> pluralities of low order bits and said second plurality of low order bits is one of said second n<sub>1</sub> pluralities of low order bits.</claim-text></claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. The method for fetching data as set forth in claim 2, wherein said first cache memory fill comprises mapping said second memory block frame into a first cache frame of said cache memory, said first cache frame being used for mapping at least said second memory block frame;<claim-text>said mapping of said second memory block frame into said first cache frame comprising updating a first cache tag of said first cache frame to identify said second memory block frame as the memory block frame currently being mapped in said first cache frame;</claim-text><claim-text>said mapping of said second memory block frame into said first cache frame further comprising storing said second n<sub>1</sub> data words into first n<sub>1</sub> cache locations of said first cache frame, including storing said second data word into a first cache location of said first cache frame, wherein said first cache location is one of said first n<sub>1</sub> cache locations;</claim-text><claim-text>said first n<sub>1</sub> cache locations being referenced by first n<sub>1</sub> cache addresses, including said first cache location being referenced by a first cache address, wherein said first cache address is one of said first n<sub>1</sub> cache addresses;</claim-text><claim-text>said first n<sub>1</sub> cache addresses comprising third n<sub>1</sub> pluralities of ordered bits, including said first cache address comprising a third plurality of ordered bits, wherein said third plurality of ordered bits is one of said third n<sub>1</sub> pluralities of ordered bits; and</claim-text><claim-text>said third n<sub>1</sub> pluralities of ordered bits comprising third n<sub>1</sub> pluralities of high order bits referencing said first cache frame, and third n<sub>1</sub> pluralities of low order bits referencing first n<sub>1</sub> cache offsets into said first cache frame, where said first n<sub>1</sub> cache locations are located, including said third plurality of ordered bits comprising a third plurality of high order bits referencing said first cache frame, and a third plurality of low order bits referencing a first cache offset into said first cache frame, where said first cache location is located, wherein said first cache offset is one of said first n<sub>1</sub> cache offsets, said third plurality of high order bits is one of said third n<sub>1</sub> pluralities of high order bits, and said third plurality of low order bits is one of said third n<sub>1</sub> pluralities of low order bits.</claim-text></claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. The method for fetching data as set forth in claim 3, wherein said second n<sub>1</sub> data words are written into said first n<sub>1</sub> cache locations in a pre-determined manner such that said second data word is written into said first cache location first.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. The method for fetching data as set forth in claim 4, wherein said second n<sub>1</sub> data-words are written into said first n<sub>1</sub> cache locations in multiple bursts of n<sub>2</sub> data words per n<sub>3</sub> clock cycles, where n<sub>1</sub> is divisible by n<sub>2</sub>, thereby resulting in n<sub>4</sub> dead cycles per n<sub>3</sub> clock cycles during said first cache memory fill.</claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. The method for fetching data as set forth in claim 5, wherein n<sub>1</sub> equals eight, n<sub>2</sub> equals two, n<sub>3</sub> equals three, and n<sub>4</sub> equals one.</claim-text></claim>"}, {"num": 7, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. The method for fetching data as set forth in claim 5, wherein whether said first cache memory fill is in progress is determined based on a plurality of internal control states,<claim-text>said internal control states comprising a first control state of waiting for a next memory address from said CPU, a second control state of waiting for said main memory to start transferring data words for said first cache memory fill, n<sub>2</sub> control states of indicating a number of data words transferred so far for said first cache memory fill, and n<sub>4</sub> control states of waiting for said main memory to resume transferring data words for said first cache memory fill, wherein</claim-text><claim-text>during said first control state, said first cache memory fill is not in progress, and during each of the other control states, said first cache memory fill is in progress, and</claim-text><claim-text>during each of said n<sub>2</sub> control states, one of said second n<sub>1</sub> data words is being stored in one of said first n<sub>1</sub> cache locations, and during each of said n<sub>4</sub> control states, one of said second n<sub>1</sub> data words is not being stored in one of said first n<sub>1</sub> cache locations.</claim-text></claim-text></claim>"}, {"num": 8, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. The method for fetching data as set forth in claim 5, wherein if said first cache memory fill is not in progress said step of determining how to fetch and return said first data word to said CPU further comprises determining whether said first memory address results in a second cache read miss;<claim-text>said first memory address not resulting in a second cache read miss if said first memory block frame is currently mapped in a second cache frame of said cache memory, said second cache frame being used for mapping at least said first memory block frame;</claim-text><claim-text>said second cache frame comprising a second cache tag identifying said first memory block frame, and second n<sub>1</sub> cache locations storing said first n<sub>1</sub> data words, including a second cache location storing said first data word, wherein said second cache location is one of said second n<sub>1</sub> cache locations, if said first memory block frame is currently mapped in said second cache frame;</claim-text><claim-text>said second n<sub>1</sub> cache locations being referenced by second n<sub>1</sub> cache addresses, including said second cache location being referenced by a second cache address, wherein said second cache address is one of said second n<sub>1</sub> cache addresses;</claim-text><claim-text>said second n<sub>1</sub> cache addresses comprising fourth n<sub>1</sub> pluralities of ordered bits, including said second cache address comprising a fourth plurality of ordered bits, wherein said fourth plurality of ordered bits is one of said fourth n<sub>1</sub> pluralities of ordered bits; and</claim-text><claim-text>said fourth n<sub>1</sub> pluralities of ordered bits comprising fourth n<sub>1</sub> pluralities of high order bits referencing said second cache frame, and fourth n<sub>1</sub> pluralities of low order bits referencing second n<sub>1</sub> cache offsets into said second cache frame, where said second n<sub>1</sub> cache locations are located, including said fourth plurality of ordered bits comprising a fourth plurality of high order bits referencing said second cache frame, and a fourth plurality of low order bits referencing a second cache offset into said second cache frame, where said second cache location is located, wherein said second cache offset is one of said second n<sub>1</sub> cache offsets, said fourth plurality of high order bits is one of said fourth n<sub>1</sub> pluralities of high order bits, and said fourth plurality of low order bits is one of said fourth n<sub>1</sub> pluralities of low order bits.</claim-text></claim-text></claim>"}, {"num": 9, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. The method for fetching data as set forth in claim 5, wherein if said first cache memory fill is not in progress, and said first memory address does not result in a second cache read miss, signals are sent to said cache memory and said CPU, thereby resulting in said first data word being retrieved from said cache memory and returned to said CPU, said signals comprising,<claim-text>a read signal and a second cache address being sent to said cache memory, said read signal and second cache address causing said cache memory to retrieve said first data word from a second cache location and provide said first data word to said CPU, and</claim-text><claim-text>a data valid signal being sent to said CPU indicating said first data word is being provided to said CPU, said data valid signal causing said CPU to accept said first data word;</claim-text><claim-text>said second cache address comprising a fourth plurality of ordered bits, said fourth plurality of ordered bits comprising a fourth plurality of high order bits referencing a second cache frame, and a fourth plurality of low order bits referencing a second cache offset into said second cache frame where said second cache location is located.</claim-text></claim-text></claim>"}, {"num": 10, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. The method for fetching data as set forth in claim 5, wherein if said first cache memory fill is not in progress, and said first memory address results in a second cache read miss, signals are sent to said main memory, said cache memory and said CPU, thereby resulting in a second cache memory fill being initiated for said first memory block frame, and said first data word being returned to said CPU simultaneous with said first data word being written into said cache memory, said signals comprising,<claim-text>a read signal and said first memory address being sent to said main memory, said read signal and first memory address causing said main memory to provide said first n<sub>1</sub> data words to said cache memory and said CPU simultaneously,</claim-text><claim-text>a write signal and second n<sub>1</sub> cache addresses being sent to said cache memory, said write signal and said cache address causing said cache memory to store said first n<sub>1</sub> data words into second n<sub>1</sub> cache locations, and</claim-text><claim-text>a data valid signal being sent to said CPU indicating said first data word is being provided to said CPU, said data valid signal causing said CPU to accept said first data word;</claim-text><claim-text>said second n<sub>1</sub> cache addresses comprising fourth n<sub>1</sub> pluralities of ordered bits, said fourth n<sub>1</sub> pluralities of ordered bits comprising fourth n<sub>1</sub> pluralities of high order bits referencing a second cache frame, and fourth n<sub>1</sub> pluralities of low order bits referencing second n<sub>1</sub> cache offsets into said second cache frame where said second n<sub>1</sub> cache locations are located.</claim-text></claim-text></claim>"}, {"num": 11, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. The method for fetching data as set forth in claim 5, wherein if said first cache memory fill is in progress, said first and second memory block frames are the same memory block frame, one of said second n<sub>1</sub> data words is not being stored into one of said first n<sub>1</sub> cache locations, and said first data word is stored in a second cache location of said first cache frame, signals are sent to said cache memory and said CPU, thereby resulting in said first data word being retrieved from said cache memory and returned to said CPU, said signals comprising,<claim-text>a read signal and a second cache address being sent to said cache memory, said read signal and second cache address causing said cache memory to retrieve said first data word from said second cache location and provide said first data word to said CPU, and</claim-text><claim-text>a data valid signal being sent to said CPU indicating said first data word is being provided to said CPU, said data valid signal causing said CPU to accept said first data word;</claim-text><claim-text>said second cache address comprising a fourth plurality of ordered bits, said fourth plurality of ordered bits comprising a fourth plurality of high order bits referencing said first cache frame, and a fourth plurality of low order bits referencing a second cache offset into said first cache frame where said second cache location is located.</claim-text></claim-text></claim>"}, {"num": 12, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"12\"><claim-text>12. The method for fetching data as set forth in claim 5, wherein if said first cache memory fill is in progress, said first and second memory block frames are the same memory block frame, one of said second n<sub>1</sub> data words is being stored into one of said first n<sub>1</sub> cache locations, and said first data word is the next data word being stored in a second cache location of said first cache frame, signals are sent to said cache memory and said CPU, thereby resulting in said first data word being returned to said CPU simultaneous with said first data word being written into said cache memory, said signals comprising,<claim-text>a data valid signal being sent to said CPU indicating said first data word is being provided to said CPU, said data valid signal causing said CPU to accept said first data word simultaneous with said first data word being written into said second cache location.</claim-text></claim-text></claim>"}, {"num": 13, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"13\"><claim-text>13. The method for fetching data as set forth in claim 5, wherein if said first cache memory fill is in progress, said step of determining how to fetch and return said first data word to said CPU further comprises determining whether said first and second memory block frames are the same memory block frame;<claim-text>said first and second memory block frames being the same if a memory block frame fill pointer points to said first memory block frame, said memory block frame fill pointer being used to point to the memory block frame currently being mapped;</claim-text><claim-text>said memory block frame fill pointer being set to said first plurality of high order bits if said memory block frame fill pointer points to said first memory block frame, wherein said memory block fill pointer was set to said first plurality of high order bits at the beginning of said first cache memory fill currently in progress if said first plurality of high order bits equals said second plurality of high order bits.</claim-text></claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"14\"><claim-text>14. The method for fetching data as set forth in claim 13, wherein if said first cache memory fill is in progress, and said first and second memory block frames are different memory block frames, said step of determining how to fetch and return said first data word to said CPU further comprises using control circuitry to determine whether said first cache memory fill is completed by repeatedly determining whether said first cache memory fill is in progress, and upon the completion of said first cache memory fill, determining whether said first memory address results in a second cache read miss.</claim-text></claim>"}, {"num": 15, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"15\"><claim-text>15. The method for fetching data as set forth in claim 13, wherein if said first cache memory fill is in progress, and said first and second memory block frames are the same memory block frame, said step of determining how to fetch and return said first data word to said CPU further comprises determining whether one of said second n<sub>1</sub> data words is in the process of being stored into one of said first n<sub>1</sub> cache locations;<claim-text>the determination of whether one of said second n<sub>1</sub> data words is in the process of being stored into one of said first n<sub>1</sub> cache locations being based on a plurality of internal control states; and</claim-text><claim-text>said internal control states comprising a first control state of waiting for a next memory address from said CPU, a second control state of waiting for said main memory to start transferring data words for said first cache memory fill, n<sub>2</sub> control states of indicating a number of data words transferred so far for said first cache memory fill, and n<sub>4</sub> control states of waiting for said main memory to resume transferring data words for said first cache memory fill, wherein</claim-text><claim-text>during each of said n<sub>2</sub> control states, one of said second n<sub>1</sub> data words is being stored in one of said first n<sub>1</sub> cache locations, and during each of said n<sub>4</sub> control states, one of said second n<sub>1</sub> data words is not being stored in one of said first n<sub>1</sub> cache locations.</claim-text></claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim num=\"16\"><claim-text>16. The method for fetching data as set forth in claim 15, wherein if said first cache memory fill is in progress, said first and second memory block frames are the same memory block frame, and one of said second n<sub>1</sub> data words is not in the process of being stored into one of said first n<sub>1</sub> cache locations, said step of determining how to fetch and return said first data word to said CPU further comprises determining whether said first data word is currently stored in a second cache location of said first cache frame;<claim-text>said first data word being currently stored in said second cache location if a bit, corresponding to said first memory block offset, in a vector of valid memory block offset bits, indicates said first memory block offset is valid, said vector of valid memory block offset bits comprising n<sub>1</sub> bits corresponding to the n<sub>1</sub> memory block offsets of the memory block frame currently being mapped, and being used to indicate which of the n<sub>1</sub> memory block offsets of the memory block frame currently being mapped have been mapped;</claim-text><claim-text>said bit corresponding to said first memory block offset; being set when said first memory block offset is mapped, wherein said first memory block offset is valid if said bit corresponding to said first memory block offset is set.</claim-text></claim-text></claim>"}, {"num": 17, "parent": 15, "type": "dependent", "paragraph_markup": "<claim num=\"17\"><claim-text>17. The method for fetching data as set forth in claim 15, wherein if said first cache memory fill is in progress, said first and second memory block frames are the same memory block frame, and one of said second n<sub>1</sub> data words is in the process of being stored into one of said first n<sub>1</sub> cache locations, said step of determining how to fetch and return said first data word to said CPU further comprises determining whether said first data word is currently being stored into a second cache location of said first cache frame;<claim-text>said first data word currently being stored into said second cache location if a memory block offset fill pointer points to said first memory block offset, said memory block offset fill pointer being used to point to a data word of the memory block frame being currently mapped, which is currently being stored;</claim-text><claim-text>said memory block offset fill pointer being set to said first plurality of low order bits if said memory block offset fill pointer points to said first memory block offset, wherein said memory block offset fill pointer is set to equal said first plurality of low order bits after a memory block offset preceding said first memory block offset has been mapped.</claim-text></claim-text></claim>"}, {"num": 18, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"18\"><claim-text>18. A cache memory controller for fetching data for a central processing unit (CPU) of a computer system from a cache and main memory hierarchy of the computer system that reduces CPU idle time, said memory hierarchy including a cache memory and a main memory, said cache memory controller comprising:<claim-text>an address register coupled to said CPU for receiving a first memory address from said CPU, said first memory address indicating a first memory location of said main memory where a first data word being fetched by said CPU is stored; and</claim-text><claim-text>control circuitry coupled to said address register, said CPU, said cache memory and said main memory for determining whether a first cache memory fill is in progress, determining how to fetch said first data word from said cache memory and said main memory and return said first data word to said CPU, wherein said determining how to fetch and return said first data word comprises determining whether said first cache memory fill is in progress, and determining whether said first cache memory fill includes storing said first data word in said cache memory if said first cache memory fill is in progress, and sending signals to said CPU, said cache memory, and said main memory accordingly, thereby resulting in said first data word being retrieved from said cache and main memory hierarchy and returned to said CPU, said CPU being coupled to said cache memory and said main memory;</claim-text><claim-text>said first cache memory fill being initiated due to a first cache read miss which resulted from previously receiving a second memory address from said CPU, said second memory address indicating a second memory location of said main memory where a second data word being fetched by said CPU is stored, said second data word having been subsequently retrieved from said cache and main memory hierarchy and returned to said CPU.</claim-text></claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim num=\"19\"><claim-text>19. The cache memory controller for fetching data as set forth in claim 18, wherein said first and second memory addresses reference said first and second memory locations with a first and second plurality of ordered bits respectively,<claim-text>said first and second plurality of ordered bits comprising a first and second plurality of high order bits referencing first and second memory block frames, respectively, and a first and second plurality of low order bits referencing first and second memory block offsets respectively, into said first and second memory block frames where said first and second memory locations are located respectively;</claim-text><claim-text>said first and second memory block frames having first and second n<sub>1</sub> memory block offsets corresponding to first and second n<sub>1</sub> memory locations for storing first and second n<sub>1</sub> data words respectively, wherein said first memory block offset is one of said first n<sub>1</sub> memory block offsets and said second memory block offset is one of said second n<sub>1</sub> memory block offsets, said first memory location is one of said first n<sub>1</sub> memory locations and said second memory location is one of said second n<sub>1</sub> memory locations, and said first data word is one of said first n<sub>1</sub> data words and said second data word is one of said second n<sub>1</sub> data words;</claim-text><claim-text>said first and second n<sub>1</sub> memory locations being referenced by first and second n<sub>1</sub> memory addresses comprising first and second n<sub>1</sub> pluralities of ordered bits, wherein said first memory address is one of said first n<sub>1</sub> memory addresses and said second memory address is one of said second n<sub>1</sub> memory addresses, and said first plurality of ordered bits is one of said first n<sub>1</sub> pluralities of ordered bits and said second plurality of ordered bits is one of said second n<sub>1</sub> pluralities of ordered bits; and</claim-text><claim-text>said first and second n<sub>1</sub> pluralities of ordered bits comprising first and second n<sub>1</sub> pluralities of high ordered bits referencing said first and second memory block frames and first and second n<sub>1</sub> pluralities of low ordered bits referencing said first and second n<sub>1</sub> memory block offsets, wherein said first plurality of high order bits is one of said first n<sub>1</sub> pluralities of high order bits and said second plurality of high order bits is one of said second n<sub>1</sub> pluralities of high order bits, and said first plurality of low order bits is one of said first n<sub>1</sub> pluralities of low order bits and said second plurality of low order bits is one of said second n<sub>1</sub> pluralities of low order bits.</claim-text></claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim num=\"20\"><claim-text>20. The cache memory controller for fetching data as set forth in claim 19, wherein said first cache memory fill comprises mapping said second memory block frame into a first cache frame of said cache memory, said first cache frame being used for mapping at least said second memory block frame;<claim-text>said mapping of said second memory block frame into said first cache frame comprising updating a first cache tag of said first cache frame to identify said second memory block frame as the memory block frame currently being mapped in said first cache frame;</claim-text><claim-text>said mapping of said second memory block frame into said first cache frame further comprising storing said second n<sub>1</sub> data words into first n<sub>1</sub> cache locations of said first cache frame, including storing said second data word into a first cache location of said first cache frame, wherein said first cache location is one of said first n<sub>1</sub> cache locations;</claim-text><claim-text>said first n<sub>1</sub> cache locations being referenced by first n<sub>1</sub> cache addresses, including said first cache location being referenced by a first cache address, wherein said first cache address is one of said first n<sub>1</sub> cache addresses;</claim-text><claim-text>said first n<sub>1</sub> cache addresses comprising third n<sub>1</sub> pluralities of ordered bits, including said first cache address comprising a third plurality of ordered bits, wherein said third plurality of ordered bits is one of said third n<sub>1</sub> pluralities of ordered bits; and</claim-text><claim-text>said third n<sub>1</sub> pluralities of ordered bits comprising third n<sub>1</sub> pluralities of high order bits referencing said first cache frame, and third n<sub>1</sub> pluralities of low order bits referencing first n<sub>1</sub> cache offsets into said first cache frame, where said first n<sub>1</sub> cache locations are located, including said third plurality of ordered bits comprising a third plurality of high order bits referencing said first cache frame, and a third plurality of low order bits referencing a first cache offset into said first cache frame, where said first cache location is located, wherein said first cache offset is one of said first n<sub>1</sub> cache offsets, said third plurality of high order bits is one of said third n<sub>1</sub> pluralities of high order bits, and said third plurality of low order bits is one of said third n<sub>1</sub> pluralities of low order bits.</claim-text></claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim num=\"21\"><claim-text>21. The cache memory controller for fetching data as set forth in claim 20, wherein said second n<sub>1</sub> data words are written into said first n<sub>1</sub> cache locations in a pre-determined manner such that said second data word is written into said first cache location first.</claim-text></claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim num=\"22\"><claim-text>22. The cache memory controller for fetching data as set forth in claim 21, wherein said second n<sub>1</sub> data words are written into said first n<sub>1</sub> cache locations in multiple bursts of n<sub>2</sub> data words per n<sub>3</sub> clock cycles, where n<sub>1</sub> is divisible by n<sub>2</sub>, thereby resulting in n<sub>4</sub> dead cycles per n<sub>3</sub> clock cycles during said first cache memory fill.</claim-text></claim>"}, {"num": 23, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"23\"><claim-text>23. The cache memory controller for fetching data as set forth in claim 22, wherein n<sub>1</sub> equals eight, n<sub>2</sub> equals two, n<sub>3</sub> equals three, and n<sub>4</sub> equals one.</claim-text></claim>"}, {"num": 24, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"24\"><claim-text>24. The cache memory controller for fetching data as set forth in claim 22, wherein said control circuitry determines whether said first cache memory fill is in progress based on a plurality of internal control states;<claim-text>said internal control states comprising a first control state of waiting for a next memory address from said CPU, a second control state of waiting for said main memory to start transferring data words for said first cache memory fill, n<sub>2</sub> control states of indicating a number of data words transferred so far for said first cache memory fill, and n<sub>4</sub> control states of waiting for said main memory to resume transferring data words for said first cache memory fill, wherein</claim-text><claim-text>during said first control state, said first cache memory fill is not in progress, and during each of the other control states, said first cache memory fill is in progress, and</claim-text><claim-text>during each of said n<sub>2</sub> control states, one of said second n<sub>1</sub> data words is being stored in one of said first n<sub>1</sub> cache locations, and during each of said n<sub>4</sub> control states, one of said second n<sub>1</sub> data words is not being stored in one of said first n<sub>1</sub> cache locations.</claim-text></claim-text></claim>"}, {"num": 25, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"25\"><claim-text>25. The cache memory controller for fetching data as set forth in claim 22, wherein if said first cache memory fill is not in progress, said control circuitry determines how to fetch and return said first data word to said CPU by determining whether said first memory address results in a second cache read miss;<claim-text>said first memory address not resulting in a second cache read miss if said first memory block frame is currently mapped in a second cache frame of said cache memory, said second cache frame being used for mapping at least said first memory block frame;</claim-text><claim-text>said second cache frame comprising a second cache tag identifying said first memory block frame, and second n<sub>1</sub> cache locations storing said first n<sub>1</sub> data words, including a second cache location storing said first data word, wherein said second cache location is one of said second n<sub>1</sub> cache locations, if said first memory block frame is currently mapped in said second cache frame;</claim-text><claim-text>said second n<sub>1</sub> cache locations being referenced by second n<sub>1</sub> cache addresses, including said second cache location being referenced by a second cache address, wherein said second cache address is one of said second n<sub>1</sub> cache addresses;</claim-text><claim-text>said second n<sub>1</sub> cache addresses comprising fourth n<sub>1</sub> pluralities of ordered bits, including said second cache address comprising a fourth plurality of ordered bits, wherein said fourth plurality of ordered bits is one of said fourth n<sub>1</sub> pluralities of ordered bits; and</claim-text><claim-text>said fourth n<sub>1</sub> pluralities of ordered bits comprising fourth n<sub>1</sub> pluralities of high order bits referencing said second cache frame, and fourth n<sub>1</sub> pluralities of low order bits referencing second n<sub>1</sub> cache offsets into said second cache frame, where said second n<sub>1</sub> cache locations are located, including said fourth plurality of ordered bits comprising a fourth plurality of high order bits referencing said second cache frame, and a fourth plurality of low order bits referencing a second cache offset into said second cache frame, where said second cache location is located, wherein said second cache offset is one of said second n<sub>1</sub> cache offsets, said fourth plurality of high order bits is one of said fourth n<sub>1</sub> pluralities of high order bits, and said fourth plurality of low order bits is one of said fourth n<sub>1</sub> pluralities of low order bits.</claim-text></claim-text></claim>"}, {"num": 26, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"26\"><claim-text>26. The cache memory controller for fetching data as set forth in claim 22, wherein if said first cache memory fill is not in progress, and said first memory address does not result in a second cache read miss, said control circuitry sends signals to said cache memory and said CPU, thereby resulting in said first data word being retrieved from said cache memory and returned to said CPU, said signals comprising,<claim-text>a read signal and a second cache address being sent to said cache memory, said read signal and second cache address causing said cache memory to retrieve said first data word from a second cache location and provide said first data word to said CPU, and</claim-text><claim-text>a data valid signal being sent to said CPU indicating said first data word is being provided to said CPU, said data valid signal causing said CPU to accept said first data word;</claim-text><claim-text>said second cache address comprising a fourth plurality of ordered bits, said fourth plurality of ordered bits comprising a fourth plurality of high order bits referencing a second cache frame, and a fourth plurality of low order bits referencing a second cache offset into said second cache frame where said second cache location is located.</claim-text></claim-text></claim>"}, {"num": 27, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"27\"><claim-text>27. The cache memory controller for fetching data as set forth in claim 22, wherein if said first cache memory fill is not in progress, and said first memory address results in a second cache read miss, said control circuitry sends signals to said main memory, said cache memory and said CPU, thereby resulting in a second cache memory fill being initiated for said first memory block frame, and said first data word being returned to said CPU simultaneous with said first data word being written into said cache memory, said signals comprising,<claim-text>a read signal and said first memory address being sent to said main memory, said read signal and first memory address causing said main memory to provide said first n<sub>1</sub> data words to said cache memory and said CPU simultaneously,</claim-text><claim-text>a write signal and second n<sub>1</sub> cache addresses being sent to said cache memory, said write signal and said cache addresses causing said cache memory to store said first n<sub>1</sub> data words into second n<sub>1</sub> cache locations, and</claim-text><claim-text>a data valid signal being sent to said CPU indicating said first data word is being provided to said CPU, said data valid signal causing said CPU to accept said first data word;</claim-text><claim-text>said second n<sub>1</sub> cache addresses comprising fourth n<sub>1</sub> pluralities of ordered bits, said fourth n<sub>1</sub> pluralities of ordered bits comprising fourth n<sub>1</sub> pluralities of high order bits referencing a second cache frame, and fourth n<sub>1</sub> pluralities of low order bits referencing second n<sub>1</sub> cache offsets into said second cache frame where said second n<sub>1</sub> cache locations are located.</claim-text></claim-text></claim>"}, {"num": 28, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"28\"><claim-text>28. The cache memory controller for fetching data as set forth in claim 22, wherein if said first cache memory fill is in progress, said first and second memory block flames are the same memory block frame, one of said second n<sub>1</sub> data words is not being stored into one of said first n<sub>1</sub> cache locations, and said first data word is stored in a second cache location of said first cache frame, said control circuitry sends signals to said cache memory and said CPU, thereby resulting in said first data word being retrieved from said cache memory and returned to said CPU, said signals comprising,<claim-text>a read signal and a second cache address being sent to said cache memory, said read signal and second cache address causing said cache memory to retrieve said first data word from said second cache location and provide said first data word to said CPU, and</claim-text><claim-text>a data valid signal being sent to said CPU indicating said first data word is being provided to said CPU, said data valid signal causing said CPU to accept said first data word;</claim-text><claim-text>said second cache address comprising a fourth plurality of ordered bits, said fourth plurality of ordered bits comprising a fourth plurality of high order bits referencing said first cache frame, and a fourth plurality of low order bits referencing a second cache offset into said first cache frame where said second cache location is located.</claim-text></claim-text></claim>"}, {"num": 29, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"29\"><claim-text>29. The cache memory controller for fetching data as set forth in claim 22, wherein if said first cache memory fill is in progress, said first and second memory block frames are the same memory block frame, one of said second n<sub>1</sub> data words is being stored into one of said first n<sub>1</sub> cache locations, and said first data word is the next data word being stored in a second cache location of said first cache frame, said control circuitry sends signals to said cache memory and said CPU, thereby resulting in said first data word being returned to said CPU simultaneous with said first data word being written into said cache memory, said signals comprising,<claim-text>a data valid signal being sent to said CPU indicating said first data word is being provided to said CPU, said data valid signal causing said CPU to accept said first data word simultaneous with said first data word being written into said second cache location.</claim-text></claim-text></claim>"}, {"num": 30, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"30\"><claim-text>30. The cache memory controller for fetching data as set forth in claim 22, wherein said cache memory controller further comprises a first fill register coupled to said control circuitry for storing a memory block frame fill pointer, said memory block frame fill pointer being used to point to the memory block frame currently being mapped;<claim-text>said control circuitry determining how to fetch and return said first data word to said CPU by determining whether said first and second memory block frames are the same memory block frame if said first cache memory fill is in progress, said first and second memory block frames being the same if said memory block frame fill pointer points to said first memory block frame;</claim-text><claim-text>said memory block frame fill pointer being set to said first plurality of high order bits if said memory block frame fill pointer points to said first memory block frame, wherein said memory block fill pointer was set to said first plurality of high order bits at the beginning of said first cache memory fill currently in progress by said control circuitry if said first plurality of high order bits equals said second plurality of high order bits.</claim-text></claim-text></claim>"}, {"num": 31, "parent": 30, "type": "dependent", "paragraph_markup": "<claim num=\"31\"><claim-text>31. The cache memory controller for fetching data as set forth in claim 30, wherein if said first cache memory fill is in progress, and said first and second memory block frames are different memory block frames, said control circuitry determines how to fetch and return said first data word to said CPU by further determining whether said first memory address results in a second cache read miss, at the completion of said first cache memory fill,<claim-text>the completion of said first cache memory fill being detected by said control circuitry by repeatedly determining whether said first cache memory fill is in progress.</claim-text></claim-text></claim>"}, {"num": 32, "parent": 30, "type": "dependent", "paragraph_markup": "<claim num=\"32\"><claim-text>32. The cache memory controller for fetching data as set forth in claim 30, wherein if said first cache memory fill is in progress, and said first and second memory block frames are the same memory block frame, said control circuitry determines how to fetch and return said first data word to said CPU by further determining whether one of said second n<sub>1</sub> data words is in the process of being stored into one of said first n<sub>1</sub> cache locations;<claim-text>the determination of whether one of said second n<sub>1</sub> data words is in the process of being stored into one of said first n<sub>1</sub> cache locations being made by said control circuitry based on a plurality of internal control states;</claim-text><claim-text>said internal control states comprising a first control state of waiting for a next memory address from said CPU, a second control state of waiting for said main memory to start transferring data words for said first cache memory fill, n<sub>2</sub> control states of indicating a number of data words transferred so far for said first cache memory fill, and n<sub>4</sub> control states of waiting for said main memory to resume transferring data words for said first cache memory fill, wherein</claim-text><claim-text>during each of said n<sub>2</sub> control states, one of said second n<sub>1</sub> data words is being stored in one of said first n<sub>1</sub> cache locations, and during each of said n<sub>4</sub> control states, one of said second n<sub>1</sub> data words is not being stored in one of said first n<sub>1</sub> cache locations.</claim-text></claim-text></claim>"}, {"num": 33, "parent": 32, "type": "dependent", "paragraph_markup": "<claim num=\"33\"><claim-text>33. The cache memory controller for fetching data as set forth in claim 32, wherein said cache controller further comprises a second fill register coupled to said control circuitry for storing a vector of valid memory block offset bits, said vector of valid memory block offset bits comprising n<sub>1</sub> bits corresponding to the n<sub>1</sub> memory block offsets of the memory block frame currently being mapped, and being used to indicate which of the n<sub>1</sub> memory block offsets of the memory block frame currently being mapped have been mapped;<claim-text>said control circuitry determining how to fetch and return said first data word to said CPU by further determining whether said first data word is currently stored in a second cache location of said first cache frame if said first cache memory fill is in progress, said first and second memory block frames are the same memory block frame, and one of said second n<sub>1</sub> data words is not in the process of being stored into one of said first n<sub>1</sub> cache locations, said first data word being currently stored in said second cache location if a bit, corresponding to said first memory block offset, in said vector of valid memory block offset bits, indicates said first memory block offset is valid;</claim-text><claim-text>said bit corresponding to said first memory block offset being set by said control circuitry when said first memory block offset is mapped, wherein said first memory block offset is valid if said bit corresponding to said first memory block offset is set.</claim-text></claim-text></claim>"}, {"num": 34, "parent": 32, "type": "dependent", "paragraph_markup": "<claim num=\"34\"><claim-text>34. The cache memory controller for fetching data as set forth in claim 32, wherein said cache memory controller comprises a third fill register coupled to said control circuitry for storing a memory block offset fill pointer, said memory block offset fill pointer being used to point to a word of the memory block frame being currently mapped, which is currently being stored;<claim-text>said control circuitry determining how to fetch and return said first data word to said CPU by further determining whether said first data word is currently being stored into a second cache location of said first cache frame if said first cache memory fill is in progress, said first and second memory block frames are the same memory block frame, and one of said second n<sub>1</sub> data words is in the process of being stored into one of said first n<sub>1</sub> cache locations, said first data word currently being stored into said second cache location if a memory block offset fill pointer points to said first memory block offset;</claim-text><claim-text>said memory block offset fill pointer being set to said first plurality of low order bits if said memory block offset fill pointer points to said first memory block offset, wherein said memory block offset fill pointer is set to equal said first plurality of low order bits by said control circuitry after a memory block offset preceding said first memory block offset has been mapped.</claim-text></claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES66638802\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates to the field of computer systems. More particularly, the present invention relates to a cache memory controller and method for fetching data for a central processing unit (CPU) that reduces CPU idle time.</p><p>2. Art Background</p><p>Typically the central processing unit (CPU) in a computer system operates at a substantially faster speed than the main memory. In order to avoid having the CPU idle too often while waiting for data or instructions from the main memory, a cache memory which can operate at a higher speed than the main memory is often used to buffer data and instructions between the main memory and the CPU. The data and instructions in memory locations of the main memory are mapped into the cache memory in block frames. Each block frame comprises a plurality of block offsets corresponding to a plurality of memory locations storing a plurality of the data and instructions. To further improve the overall CPU performance, some computer systems employ separate cache memories, one for data and one for instructions.</p><p>However, the use of separate cache memories does not solve the problem entirely. When a cache read miss occurs, that is, when the datum or instruction requested by the CPU is not in the cache memory, the cache memory has to retrieve the datum or instruction from the main memory. To do so, typically the entire block frame of data or instructions comprising the requested datum or instruction is retrieved; and the CPU goes idle until the retrieval is completed. For other cache performance problems and improvement techniques, see J. L. Hennessy, and D. A. Patterson, Computer Architecture-A Quantitative Approach, pp. 454-461, (Morgan Kaufmann, 1990).</p><p>The amount of time it takes to fill the cache memory with a replacement block frame is dependent on the block size and the transfer rate of the cache memory-main memory hierarchy. For example, if the block size is eight (8) words and the speed of the main memory is two (2) block offsets per three (3) clock cycles, then it takes eleven (11) clock cycles to fill the cache memory with the replacement block frame. Reducing the block frame size or filling a partial block on a cache read miss does not necessarily reduce the CPU idle time, since it will increase the likelihood of future cache read misses.</p><p>Various techniques have been used to minimize the amount of CPU idle time waiting for the cache memory when cache read misses occur. One common practice is early restart, that is, as soon as the requested datum or instruction arrives, it is sent to the CPU without waiting for the writing of the entire block to be completed. Therefore, the CPU may resume its execution while the rest of the replacement block frame is being written.</p><p>A further refinement of the early restart technique is out of order fetch which is a request to the main memory to retrieve the requested datum or instruction first, skipping all the data or instructions before the requested datum or instruction in the replacement block frame. Like the early restart, the retrieved datum or instruction is sent to the CPU as soon as it is retrieved. Again, the CPU may resume its execution while the rest of the replacement block frame is being retrieved. After retrieving the requested datum or instruction, the main memory continues to retrieve the remaining data and instructions in the replacement block frame, starting with the data and instruction after the requested datum or instruction, and loops around to retrieve the previously skipped data or instructions at the beginning of the block frame, until the end of the block frame is reached. Thus, the CPU can resume execution as soon as the first datum or instruction is retrieved from the main memory.</p><p>However, because handling subsequent requests from the CPU while trying to fill the rest of the replacement block frame gets complicated quickly, the CPU typically goes idle again after the datum or instruction is executed, and waits for the remaining retrievals to be completed. The CPU goes idle and waits, even if the datum instruction subsequently requested by the CPU is already in the cache memory or is part of the replacement block frame currently being retrieved. Thus, the benefits from early restart and out of order fetch are limited, especially if the CPU is likely to complete its execution before the rest of the replacement block frame is written to the cache memory. This is especially likely to occur on computer systems where the number of clock cycles required to execute a typical instruction is small, for example, reduced instruction set computer (RISC) systems.</p><p>Since the cache memory typically operates at a higher speed than the main memory, there are dead cycles where the cache memory is waiting for data or instructions to be transferred from the main memory, while the CPU is waiting for the cache memory. The number of dead cycles is also dependent on the block frame size and the transfer rate of the cache memory-main memory hierarchy. In the example discussed above, there are three (3) dead cycles per writing of a block frame, one in every three clock cycles. Therefore, subsequent requests for data or instructions that are in the cache memory can be satisfied during these dead cycles, thereby further reducing CPU idle time. The problem is knowing that the data or instructions are in the cache memory and synchronizing their read out from the cache memory to these dead cycles, without substantial investment in additional hardware.</p><p>Likewise, to satisfy the subsequent requests for data or instructions that are in the process of being retrieved from the main memory, problem is knowing when the data or instructions are retrieved and synchronizing their direct transfer to the CPU with their retrieval, without substantial investment in additional hardware.</p><p>As will be described, the present invention overcomes the disadvantages of the prior art, and provides a cache memory controller and method for fetching data for a CPU that reduces CPU idle time.</p><h4>SUMMARY OF THE INVENTION</h4><p>It is therefore an object of the present invention to provide a cache memory controller and method for fetching data for a central processing unit (CPU) that reduces CPU idle time.</p><p>It is an object of the present invention to retrieve and return data being fetched by the CPU during a cache memory fill without having the CPU remain idle waiting for the cache memory fill to complete, if the data being fetched is part of the memory block frame currently being mapped.</p><p>In the present invention, if the CPU fetches data during a cache memory fill and the data being fetched are part of the memory block frame currently being filled, the data are retrieved and returned to the CPU simultaneous with their writing into the cache memory, if the data have not been written into the cache memory; otherwise, the data are retrieved and returned to the CPU at the next dead cycle, since the data have already been written into the cache memory.</p><p>A control circuit is used to determine if a cache memory fill is in progress, and if one is in progress, determine if the data being fetched are part of the memory block frame being filled, and if they are part of the memory block frame, determine if the data have been written, and if the data have not been written, determine if the data are to be written next.</p><p>A plurality of fill registers are used to keep track of the memory block frame currently being mapped, memory block offsets of the memory block frame currently being mapped, and the memory block offset of the next memory block frame to be mapped, thereby allowing the control circuit, in conjunction with the fill registers, to make the above determinations.</p><p>Based on the results of the above determinations, the control circuit sends appropriate signals to the cache memory, the main memory and the CPU at the appropriate times, thereby causing the data to be fetched and returned to the CPU as desired. The control circuit detects the appropriate timings using its internal control states.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>The objects, features and advantages of the present invention will be apparent from the following detailed description of the preferred embodiment of the invention with references to the drawings in which:</p><p>FIG. 1 shows a block diagram illustrating the cache memory controller of the present invention for fetching data for a central processing unit (CPU).</p><p>FIG. 2 shows a block diagram illustrating the operational flow of the control circuit of the cache memory controller of the present invention.</p><p>FIG. 3 shows an exemplary state diagram for the control circuit of the cache memory controller of the present invention, for an exemplary cache memory-main memory hierarchy.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>A cache memory controller and method for fetching data for a central processing unit (CPU) that reduces CPU idle time is disclosed. In the following description for purposes of explanation, specific numbers, materials and configurations are set forth in order to provide a thorough understanding of the present invention. However, it should be apparent to one skilled in the art that the present invention may be practiced without these specific details. In other instances, well known systems are shown in diagrammatical or block diagram form in order not to obscure the present invention unnecessarily.</p><p>Referring now to FIG. 1, a block diagram illustrating the preferred embodiment of the cache memory controller of the present invention that reduces CPU idle time is shown. The cache memory controller (CMC) 20 is shown in the context of a typical computer system 10 comprising a central processing unit (CPU) 40, cache memory 50 and main memory 60 with early restart and out of order fetch capability.</p><p>The main memory 60 comprises a plurality of memory locations (not shown) for storing a plurality of data words. The memory locations are organized into a plurality of memory block frames with each memory block frame having n<sub>1</sub> memory block offsets corresponding to n<sub>1</sub> memory locations. Each memory location is referenced by a memory address having a plurality of ordered bits, with the high order bits referencing its memory block frame and the low order bits referencing its memory block offsets.</p><p>The cache memory 50 comprises a plurality of cache locations (not shown). The cache locations are organized into a plurality of cache frames for mapping at least one of the memory block frames. Each of the cache frames comprises n<sub>1</sub> cache offsets for mapping the n<sub>1</sub> memory block offsets of one of the memory block frames, and a cache tag indicating the memory block frame being mapped by the particular cache frame. Each cache location is referenced by a cache address having a plurality of ordered bits, with the high order bits referencing its cache frame and the low order bits referencing its cache offsets.</p><p>Each memory block frame is mapped into a cache frame during a cache memory fill initiated due to receiving a memory address referencing a memory block frame and one of its memory block offsets that resulted in a cache read miss. The data words stored in the memory locations corresponding to the memory offsets of the referenced memory block frame are written into the cache locations corresponding to the cache offsets of the mapping cache frame. The data word stored in the memory location corresponding to the memory offset referenced by the memory address that resulted in the cache read miss is written into its mapping cache location first (out-of-order fetch). The data words are written into the cache locations in multiple bursts of n<sub>2</sub> data words per n<sub>3</sub> clock cycles, where n<sub>1</sub> is divisible by n<sub>2</sub>, thereby resulting in n<sub>4</sub> dead cycles per n<sub>3</sub> clock cycles during each cache memory fill.</p><p>For a further description of mapping memory block frames and memory block offsets of a main memory into cache frames and cache offsets of a cache memory, see J. L. Hennessy, and D. A. Patterson, Computer Architecture-A Quantitative Approach, pp. 454-461, (Morgan Kaufman, 1990).</p><p>Continuing referring to FIG. 1, the CMC 20 comprises an address register 22 coupled to the CPU 40, a plurality of fill registers 24, 26 and 30, and a control circuit 32 coupled to the address register 22, the fill registers 24, 26 and 30, the CPU 40, the cache memory 50, and the main memory 60.</p><p>The address register 22 coupled to the CPU is for storing a memory address received from the CPU. The memory address indicates a memory location where a data word being fetched by the CPU is stored.</p><p>The fill registers 24, 26 and 30 store the status of mapping one of the memory block frames from-the main memory 60 into the cache memory 50. The fill registers 24, 26 and 30 comprise three registers for holding a memory block frame fill pointer, a memory block offset fill pointer, and a plurality of valid memory block offset fill bits.</p><p>The memory block frame fill register 24 coupled to the control circuit 32 stores a memory block frame fill pointer pointing to the memory block frame whose memory block offsets are currently being mapped from the main memory 60 into the cache memory 50. The memory block frame fill pointer is initialized by the control circuit 32 to the higher order bits of the memory address referencing the memory block frame being mapped, at the beginning of a cache memory fill.</p><p>The memory block offset fill register 26 coupled to the control circuit 32 stores a memory block offset fill pointer pointing to the next block offset being mapped from the main memory 60 into the cache memory 50. The memory block offset pointer is initialized by the control circuit 32 to the lower order bits of the memory address referencing the first block offset being written, at the beginning of a cache memory fill. Additionally, the memory block offset fill pointer is updated by the control circuit 32 to the lower order bits of the memory address referencing the next block offset being written, after each memory block offset is mapped into the cache memory 50.</p><p>The valid block offsets fill register 30 coupled to the control circuit 32 is for storing a vector of valid memory block offset fill bits indicating whether each of the memory block offsets of the memory block frame being mapped has been mapped. The valid memory block offset bits are initialized by the control circuit 32 to binary zeros, at the beginning of a cache memory fill. Additionally, the valid memory block offset bits are set individually by the control circuit 32 to binary ones after each of the corresponding memory block offsets is mapped.</p><p>The control circuit 32 is coupled to the address register 22, the fill registers 24, 26 and 30, the CPU 40 the cache memory 50 and the main memory 60. The control circuit 32 determines whether a cache memory fill initiated due to a prior cache read miss, which resulted from a previously received memory address from the CPU 40, is still in progress, the previously received memory address having been subsequently served. The control circuit 32 also determines whether the currently received memory address from the CPU 40 results in a cache read miss. Additionally, the control circuit 32 controls the sending of appropriate signals at the appropriate time, so that the data word being fetched by the CPU 40 is retrieved from the cache-main memory hierarchy 50, 60 and returned to the CPU 40.</p><p>Referring now to FIG. 2, a block diagram illustrating the operational flow of the control circuit of the present invention is shown. The control circuit is coupled to the address register and receives the memory address of the data word being fetched by the CPU as input (step 72). Upon receipt of the memory address being fetched, the control circuit determines whether the cache memory is being filled (step 74). The control circuit determines whether the cache memory is being filled based on its internal state, which will be described in further detail later.</p><p>If the cache memory is not being filled, the control circuit determines whether the memory address received results in a cache miss (step 76). The control circuit, being coupled to the address register 22, makes the determination by accessing the cache tags in the cache frames of the cache memory and comparing them against the high order bits of the memory address received.</p><p>If the high order bits of the memory address received match one of the cache tags (i.e. cache being idle and cache read hit), the control circuit sends a read signal and a corresponding cache address to the cache memory (step 108), thereby causing the cache memory to retrieve the data word being fetched from its cache location and return it to the CPU. Simultaneously, the control circuit sends a data valid signal to the CPU (step 106), thereby causing the CPU to accept the data word being returned by the cache memory.</p><p>If the high order bits of the memory address received do not match any of the cache tags (i.e. cache being idle and cache read miss), the control circuit sends a read signal and the memory address received to the main memory (step 102). This causes the main memory to provide to the cache memory and the CPU simultaneously, the data words stored in the memory locations corresponding to the memory block offsets of the memory block frame referenced by the high order bits of the memory address received. The control circuit further sends a write signal and corresponding cache addresses for the mapping cache frame to the cache memory (step 104), thereby causing the cache memory to store the data words being provided into the cache locations corresponding to the cache offsets of the mapping cache frame. Simultaneously, the control circuit also sends a data valid signal to the CPU (step 106), thereby causing the CPU to accept the first data word being returned by the main memory (i.e. the data word being fetched by the CPU).</p><p>If the cache memory is being filled, the control circuit also determines whether the high order bits of the memory address received reference the same memory block frame currently being mapped (step 80). The control circuit, which is also coupled to the memory block frame fill register, makes the determination by accessing the memory block frame pointer in the memory block frame fill register, and comparing it against the high order bits of the memory address received.</p><p>If the high order bits of the memory address received do not reference the same memory block frame currently being mapped, the control circuit waits until the cache memory fill in progress is completed (step 81). As described earlier, the control circuit determines whether the cache memory fill in progress is completed based on its internal state.</p><p>Upon completion of the cache memory fill, the control circuit handles the memory address received in the same manner as if the memory address were received while the cache memory was not being filled.</p><p>If the high order bits of the memory address received reference the same memory block frame concurrently being filled, the control circuit determines if memory block offsets are actually being mapped into the corresponding cache offsets (i.e., cache fill in progress, non-dead cycles) step 82. The control circuit also determines whether memory block offsets are actually being mapped into the corresponding cache offsets based on its internal state.</p><p>If memory block offsets are not actually being mapped into the corresponding cache offsets (i.e., cache fill just completed, or cache fill still in progress and dead cycle), the control circuit further determines if the lower order bits of the memory address received reference a memory block offset (of the memory block frame currently being mapped) that has been mapped (step 84). The control circuit, which is also coupled to the valid block offsets fill register, makes the determination by accessing the valid block offsets in the valid block offsets fill register, and comparing them against the memory block offset referenced by the lower order bits of the memory address received.</p><p>If the lower order bits of the memory address received do not reference a memory block offset (of the memory block frame currently being mapped) that has been mapped, the control circuit again determines if memory block offsets are actually being mapped into the corresponding cache offsets (i.e., cache fill in progress, non-dead cycle), step 82, at the next clock cycle, as described earlier.</p><p>If the lower order bits of the memory address received reference a memory block offset of the memory block frame currently being mapped that has been mapped, the control circuit determines if a data path to the CPU is available (step 86). The control circuit, being coupled to the data path, makes the determination by checking if the data path is being held.</p><p>If the data path to the CPU is not available, the control circuit again determines if memory block offsets are actually being mapped into the corresponding cache offsets (i.e., cache fill in progress, non-dead cycle), step 82, at the next clock cycle, as described earlier.</p><p>If the data path to the CPU is available, the control circuit sends a read signal and a corresponding cache address to the cache memory (step 108), thereby causing the cache memory to retrieve the data word being fetched from its cache location and return it to the CPU. Simultaneously, a data valid signal is also sent to the CPU (step 106), thereby causing the CPU to accept the data word being provided by the cache memory.</p><p>If memory block offsets are actually being mapped into the corresponding cache offsets (i.e., cache fill in progress, non-dead cycle), step 82, the control circuit further determines if the memory block offset referenced by the lower order bits of the memory address received is the memory block offset currently which is mapped (step 88). The control circuit, being coupled to the block offset fill register caches, makes its determination by accessing the memory block offset pointer in the memory block offset fill register, and comparing it against the lower order bits of the memory address received.</p><p>If the memory block offset being mapped is not the memory block, offset referenced by the lower order bits of the memory address received, the control circuit again determines if memory block offsets are actually being mapped into the corresponding cache offsets (i.e., cache fill in progress, non-dead cycle), step 82, at the next clock cycle, as described earlier.</p><p>If the memory block offset being mapped is the memory block offset referenced by the lower order bits of the memory address received, the control circuit determines if the data path to the CPU is available (step 90). The control circuit makes the determination in the same manner as described earlier.</p><p>Similarly, if the data path to the CPU is not available, the control circuit again determines if the memory block offsets are actually being mapped into the corresponding cache offsets (i.e., cache fill in progress, non-dead cycle), step 82, at the next cycle, as described earlier.</p><p>If the data path to CPU is available, the control circuit sends a data valid signal to the CPU (step 106), thereby causing the CPU to accept the next data word being provided by the main memory.</p><p>Referring now to FIG. 3, an exemplary state diagram illustrating the states and the transition rules of the control circuit of the present invention for an exemplary cache memory-main memory hierarchy is shown. The exemplary cache memory-main memory hierarchy has a memory block frame size of eight memory block offsets and a transfer rate of two memory block offsets per three CPU clock cycles. Thus, the exemplary cache memory enters a dead cycle three times during a cache memory fill, once every three clock cycles.</p><p>At the end of any clock cycle, the control circuit for the exemplary cache memory-main memory hierarchy is in one of five possible states. The five possible states are the \"waiting for CPU\" state 112, \"waiting for main memory to start data transfer\" state 114, \"odd number of data words transferred\" state 116, \"even number of data words transferred\" state 118, and \"waiting for main memory to resume data transfer-dead cycle\" state 120.</p><p>Initially, the control circuit is in the \"waiting for CPU\" state 112. From the \"waiting for CPU\" state 112, the control circuit either remains in the \"waiting for CPU\" state 112 or enters the \"waiting for main memory to start data transfer\" state 114 at the end of the next clock cycle. The control circuit remains in the \"waiting for CPU\" state 112 if no memory address is received from the CPU or the memory address received results in a cache hit, during the next clock cycle. The control circuit enters the \"waiting for main memory\" state 114 if the memory address received from the CPU results in a cache miss, during the next clock cycle.</p><p>From the \"waiting for main memory to start data transfer\" state 114, the control circuit either remains in the \"waiting for main memory to start data transfer\" state 114 or enters the \"odd number of data words transferred\" state 116, at the end of the next clock cycle. The control circuit remains in the \"waiting for main memory to start data transfer\" state 114, if the main memory has not returned the first data word at the end of the next clock cycle. The control circuit enters the \"odd number of data words transferred\" state 116, if the main memory returns the first data word, during the next clock cycle. The control circuit also enters the \"odd number of data words transferred\" state 116 from the \"waiting for main memory to resume data transfer-dead cycle\" state 120, which will be discussed in further detail later.</p><p>From the \"odd number of data words transferred\" state 116, the control circuit either enters the \"even number of data words transferred\" state 118, or the \"waiting for CPU\" state 112, at the end of the next clock cycle. The control circuit enters the \"even number of data words transferred\" state 118, if the second, fourth or sixth data word is returned from main memory, during the next clock cycle. The control circuit enters the \"waiting for CPU\" state 112 if the eighth data word is returned from main memory during the next clock cycle.</p><p>From the \"even number of data words transferred\" state 118, the control circuit always enters the \"waiting for main memory to resume data transfer-dead cycle\" state 120, since this exemplary cache memory enters a dead cycle three times during a cache fill, once every three clock cycles.</p><p>From the \"waiting for main memory to resume data transfer-dead cycle\" state 120, the control circuit always enters the \"odd number of data words transferred\" state 116, since the exemplary main memory returns the third, the fifth or the seventh data word during the next clock cycle.</p><p>If the control circuit receives a new memory address from the CPU during the next clock cycle, while the control circuit is in the \"odd number of data words transferred\" state 116, the \"even number of data words transferred\" state 118, or the \"waiting for main memory to resume data transfer\" state 120, the new data word being fetched is either satisfied immediately with the next data word provided by the main memory, or later on at the next dead cycle, or later on at the completion of current cache fill, depending on the memory block frame and the memory block offset referenced by the new memory address received, as described earlier.</p><p>Referring back to FIG. 1, it will be appreciated that the address register 22, the plurality of fill registers 24-30 and the control circuit 30, may be implemented with well known integrated circuits. For further descriptions on registers and sequential logic, see Horowitz and Hill, The Art of Electronics, (Cambridge, 1989), pp. 523-541.</p><p>Additionally, the control circuit 32 may optionally elect to direct the cache memory to retrieve a data word being fetched by the CPU, and return the data word to the CPU, during a dead cycle, instead of waiting for the completion of the current cache fill, if the data word is stored in a cache location other than those cache locations of the mapping cache frame for the memory block frame currently being mapped. It will be appreciated that by doing so, the complexity of the control circuit 32 will increase substantially. Since it is highly likely that the subsequent data fetches after a cache read miss will be stored in memory locations corresponding to memory block offsets of the same memory block frames, the return in benefits for the increase in complexity may be limited.</p><p>While the invention has been described in terms of a preferred embodiment, those skilled in the art will recognize that the invention is not limited to the exemplary cache memory-main memory hierarchy described. The cache memory controller of the present invention can be practiced with modification and alteration within the spirit and scope of the appended claims to serve as a cache memory controller for a variety of cache memory-main memory hierarchies.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Samir", "last_name": "Mitra", "name": ""}, {"first_name": "Renukanthan", "last_name": "Raman", "name": ""}, {"first_name": "Joseph", "last_name": "Petollno", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "SUN MICROSYSTEMS, INC."}, {"first_name": "", "last_name": "SUN MICROSYSTMES, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/06"}, {"primary": false, "label": "G06F  13/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711003"}, {"primary": false, "label": "711E12051"}], "ecla_classes": [{"label": "G06F  12/08B6P4"}], "cpc_classes": [{"label": "G06F  12/0859"}, {"label": "G06F  13/00"}, {"label": "G06F  12/08"}, {"label": "G06F  12/06"}, {"label": "G06F  12/0859"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1991-10-18", "application_date": "1991-10-18", "family_members": [{"ucid": "DE-69229213-T2", "titles": [{"lang": "EN", "text": "Method and cache control unit for fetching data for a central processing unit with reduced waiting time"}, {"lang": "DE", "text": "Verfahren und Cache-Speichersteuereinheit zum Holen von Daten f\u00fcr eine Zentraleinheit mit verringerter Wartezeit"}]}, {"ucid": "EP-0543487-A1", "titles": [{"lang": "FR", "text": "Proc\u00e9d\u00e9 et unit\u00e9 de commande d'ant\u00e9m\u00e9moire pour la recherche des donn\u00e9es pour une unit\u00e9 centrale avec r\u00e9duction du temps vide"}, {"lang": "EN", "text": "Method and cache memory controller for fetching data for a CPU that further reduces CPU idle time"}, {"lang": "DE", "text": "Verfahren und Cache-Speichersteuereinheit zum Holen von Daten f\u00fcr eine Zentraleinheit mit verringerter Wartezeit"}]}, {"ucid": "DE-69229213-D1", "titles": [{"lang": "EN", "text": "Method and cache control unit for fetching data for a central processing unit with reduced waiting time"}, {"lang": "DE", "text": "Verfahren und Cache-Speichersteuereinheit zum Holen von Daten f\u00fcr eine Zentraleinheit mit verringerter Wartezeit"}]}, {"ucid": "JP-H06236321-A", "titles": [{"lang": "EN", "text": "METHOD OF TAKING-OUT OF DATA TO CPU AND CACHE MEMORY CONTROLLER"}, {"lang": "JA", "text": "\uff23\uff30\uff35\u3078\u306e\u30c7\u30fc\u30bf\u3092\u53d6\u308a\u51fa\u3059\u65b9\u6cd5\u53ca\u3073\u30ad\u30e3\u30c3\u30b7\u30e5\u30e1\u30e2\u30ea\u5236\u5fa1\u88c5\u7f6e"}]}, {"ucid": "KR-0153539-B1", "titles": [{"lang": "EN", "text": "CACHE MEMORY CONTROLLER AND METHOD FOR REDUCING CPU IDLE TIME BY FETCHING DATA DURING A CHCHE FILL"}, {"lang": "KO", "text": "CPU \uc720\ud734\uc2dc\uac04\uc744 \ub354\uc6b1 \uac10\uc18c\uc2dc\ud0a4\ub294 CPU\ub97c \uc704\ud55c \ub370\uc774\ud0c0 \ud398\uce58 \ubc29\ubc95 \ubc0f \uce90\uc26c \uba54\ubaa8\ub9ac \uc81c\uc5b4\uae30"}]}, {"ucid": "KR-930008622-A", "titles": [{"lang": "EN", "text": "A method and cache memory controller to further reduce CPU idle time by fetching data to the central processing unit (CPU)"}, {"lang": "KO", "text": "\uc911\uc559\ucc98\ub9ac\uc7a5\uce58(CPU)\uc5d0 \ub300\ud574 \ub370\uc774\ud0c0\ub97c \ud398\uce58\ud558\uc5ec CPU\uc720\ud734\uc2dc\uac04\uc744 \ub354\uc6b1 \uac10\uc18c\uae30\ud0a4\uae30 \uc704\ud55c \ubc29\ubc95 \ubc0f \uce90\uc26c \uba54\ubaa8\ub9ac \uc81c\uc5b4\uae30"}]}, {"ucid": "US-5386526-A", "titles": [{"lang": "EN", "text": "Cache memory controller and method for reducing CPU idle time by fetching data during a cache fill"}]}, {"ucid": "EP-0543487-B1", "titles": [{"lang": "FR", "text": "Proc\u00e9d\u00e9 et unit\u00e9 de commande d'ant\u00e9m\u00e9moire pour la recherche des donn\u00e9es pour une unit\u00e9 centrale avec r\u00e9duction du temps vide"}, {"lang": "EN", "text": "Method and cache memory controller for fetching data for a CPU that further reduces CPU idle time"}, {"lang": "DE", "text": "Verfahren und Cache-Speichersteuereinheit zum Holen von Daten f\u00fcr eine Zentraleinheit mit verringerter Wartezeit"}]}]}