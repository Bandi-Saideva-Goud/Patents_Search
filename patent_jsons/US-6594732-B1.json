{"patent_number": "US-6594732-B1", "publication_id": 73476818, "family_id": 18481485, "publication_date": "2003-07-15", "titles": [{"lang": "EN", "text": "Computer system with memory system in which cache memory is kept clean"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50521883\"><p>A computer system includes a host bus, a CPU connected to the host bus, a main memory connected to the host bus, a cache memory and a memory controller. The cache memory is connected to at least one of the host-bus and the CPU, and stores cache data. A tag address and a flag are provided for each of the cache data and the flag indicates one of a clean state in which the corresponding cache data is written back into the main memory and a dirty state in which the corresponding cache data is not yet written back into the main memory. The memory controller is connected to the host bus, the cache memory and the main memory. The memory controller writes back dirty write back cache data into the main memory in a continuous write back mode, when the host bus is not used, wherein the dirty write back cache data is a part of the cache data stored in the cache memory, and each of the dirty write back cache data is not written back and includes a predetermined portion in the tag address.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00001\" num=\"1\"><claim-text>1. A computer system comprising:</claim-text><claim-text>a host bus; </claim-text><claim-text>a CPU connected to said host bus; </claim-text><claim-text>a main memory connected to said host bus; </claim-text><claim-text>a cache memory connected to at least one of said host bus and said CPU, said cache memory storing cache data, wherein a tag address and a flag are provided for each of said cache data and said flag indicates one of a clean state in which said corresponding cache data is written back into said main memory and a dirty state in which said corresponding cache data is not yet written back into said main memory; and </claim-text><claim-text>a memory controller connected to said host bus, said cache memory and said main memory, wherein said memory controller writes back dirty write back cache data into said main memory in a continuous write back mode when said host bus is not used, wherein said dirty write back cache data is a part of said cache data stored in said cache memory, and each of said dirty write back cache data is written back and each of said dirty write back cache data includes a predetermined portion in said tag address, wherein said memory controller cancels said continuous write back mode when said CPU accesses said cache memory or said main memory in a memory access using said host bus. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00002\" num=\"2\"><claim-text>2. A computer system according to <claim-ref idref=\"US-6594732-B1-CLM-00001\">claim 1</claim-ref>, wherein said CPU accesses said cache memory or said main memory in a memory access using said host bus, and said predetermined portion is a row address of a physical address in the latest memory access.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00003\" num=\"3\"><claim-text>3. A computer system according to <claim-ref idref=\"US-6594732-B1-CLM-00002\">claim 2</claim-ref>, wherein said memory controller holds said row address in said continuous write back mode.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00004\" num=\"4\"><claim-text>4. A computer system according to <claim-ref idref=\"US-6594732-B1-CLM-00001\">claim 1</claim-ref>, wherein said memory controller includes an address decoder connected to said host bus, wherein said address decoder decodes a logical address on said host bus into a physical address and detects said memory access by said CPU, and</claim-text><claim-text>wherein said memory controller cancels said continuous write back mode when said memory access is detected by said address decoder. </claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00005\" num=\"5\"><claim-text>5. A computer system according to <claim-ref idref=\"US-6594732-B1-CLM-00004\">claim 4</claim-ref>, wherein said predetermined portion is a row address of said physical address in the latest memory access.</claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00006\" num=\"6\"><claim-text>6. A computer system according to <claim-ref idref=\"US-6594732-B1-CLM-00005\">claim 5</claim-ref>, wherein said memory controller holds said row address in said continuous write back mode.</claim-text></claim>"}, {"num": 7, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00007\" num=\"7\"><claim-text>7. A computer system according to <claim-ref idref=\"US-6594732-B1-CLM-00003\">claim 3</claim-ref>, wherein said memory controller sequentially generates cleaning physical addresses while updating a column address, in said continuous write back mode, each of said cleaning physical addresses including said row address and said updated column address, and writes back said dirty write back cache in said main memory based on said generated cleaning physical addresses, and said tag addresses and said flags corresponding to said dirty write back cache data.</claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00008\" num=\"8\"><claim-text>8. A computer system according to <claim-ref idref=\"US-6594732-B1-CLM-00007\">claim 7</claim-ref>, wherein said memory controller updates said column address immediately when said cleaning physical address does not hit to any of said tag addresses, or when said cleaning physical address hits to one of said tag addresses but said flag corresponding to the hit tag address indicates that said corresponding cache data is in the clean state, and after said writing back of said dirty write back cache data in said main memory when said cleaning physical address hits to one of said tag addresses corresponding to said one dirty write back cache data and said flag corresponding to said one dirty write back cache data indicates that said one dirty write back cache data is in the dirty state.</claim-text></claim>"}, {"num": 9, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00009\" num=\"9\"><claim-text>9. A computer system according to <claim-ref idref=\"US-6594732-B1-CLM-00001\">claim 1</claim-ref>, further comprising a bus arbiter connected to said host bus, wherein said bus arbiter detects that said host bus is not used, and</claim-text><claim-text>wherein said memory controller sets said continuous write back mode. </claim-text></claim>"}, {"num": 10, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00010\" num=\"10\"><claim-text>10. A computer system according to <claim-ref idref=\"US-6594732-B1-CLM-00001\">claim 1</claim-ref>, wherein said memory controller detects that said host bus is not used, and sets said continuous write back mode.</claim-text></claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00011\" num=\"11\"><claim-text>11. A memory system comprising:</claim-text><claim-text>a host bus; </claim-text><claim-text>a main memory connected to said host bus; </claim-text><claim-text>a cache memory storing cache data, wherein a tag address and a flag are provided for each of said cache data and said flag indicates one of a clean state in which said corresponding cache data is written back into said main memory and a dirty state in which said corresponding cache data is not yet written back into said main memory; and </claim-text><claim-text>a memory controller connected to said host bus, said cache memory and said main memory, wherein said memory controller writes back dirty write back cache data into said main memory in a continuous write back mode when said host bus is not used, wherein said dirty write back cache data is a part of said cache data stored in said cache memory, and each of said dirty write back cache data is written back and each of said dirty write back includes a predetermined portion in said tag address, wherein said memory controller cancels said continuous write back mode when said host bus is used for a memory access to said cache memory or said main memory. </claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00012\" num=\"12\"><claim-text>12. A memory system according to <claim-ref idref=\"US-6594732-B1-CLM-00011\">claim 11</claim-ref>, wherein said memory controller includes:</claim-text><claim-text>an address decoder connected to said host bus, wherein said address decoder decodes a logical address on said host bus into a physical address and detects that said host bus is used; and </claim-text><claim-text>a controller cancels said continuous write back mode when it is detected by said address decoder that said host bus is used. </claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00013\" num=\"13\"><claim-text>13. A memory system according to <claim-ref idref=\"US-6594732-B1-CLM-00012\">claim 12</claim-ref>, wherein said predetermined portion is a row address of said physical address in the latest memory access, and said controller issues generation control signals in said continuous write back mode,</claim-text><claim-text>wherein said memory controller includes: </claim-text><claim-text>a latch circuit holding said row address; and </claim-text><claim-text>an address generator responsive to said generation control signals to generate cleaning physical addresses while updating a column address, in said continuous write back mode, respectively, each of said cleaning physical addresses including said row address and said updated column address. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00014\" num=\"14\"><claim-text>14. A memory system according to <claim-ref idref=\"US-6594732-B1-CLM-00013\">claim 13</claim-ref>, wherein said memory controller includes an address comparator comparing said cleaning physical address and one of said tag addresses and generating one of a cache hit signal or a cache miss hit signal based on the comparing result, and</claim-text><claim-text>said controller generates said generation control signal each time said cache miss hit signal is outputted from said address comparator or each time said cache hit signal is outputted from said address comparator but said flag corresponding to the cache hit signal indicates the clean state, and after one of said dirty write back cache data is written back in said main memory when said cache hit signal is outputted from said address comparator and said flag corresponding to the cache hit signal indicates the dirty state. </claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00015\" num=\"15\"><claim-text>15. A memory system according to <claim-ref idref=\"US-6594732-B1-CLM-00014\">claim 14</claim-ref>, wherein said memory controller includes:</claim-text><claim-text>a selector selecting said physical address outputted from said address decoder when said continuous write back mode is not set, and selecting said cleaning physical address generated by said address generator when said continuous write back mode is set. </claim-text></claim>"}, {"num": 16, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00016\" num=\"16\"><claim-text>16. A method of keeping a cache memory clean in a computer system comprising said cache memory, a main memory and a memory controller which are connected to a host bus, said cache memory storing cache data, wherein a tag address and a flag are provided for each of said cache data and said flag indicates one of a clean state in which said corresponding cache data is written back into said main memory and a dirty state in which said corresponding cache data is not yet written back into said main memory, said method comprising:</claim-text><claim-text>setting a continuous write back mode when said host bus is not used by said memory controller; </claim-text><claim-text>writing back dirty write back cache data into said main memory in said continuous write back mode by said memory controller, wherein said dirty write back cache data is a part of said cache data stored in said cache memory, and each of said dirty write back cache data is written back and each of said dirty write back cache data includes a predetermined portion in said tag address; and </claim-text><claim-text>canceling said continuous write back mode when said host bus is used for a memory access to said cache memory or said main memory by said memory controller. </claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00017\" num=\"17\"><claim-text>17. A method according to <claim-ref idref=\"US-6594732-B1-CLM-00016\">claim 16</claim-ref>, wherein said canceling includes:</claim-text><claim-text>detecting use of said host bus based on a logical address on said host bus, said logical address being decoded into a physical address. </claim-text></claim>"}, {"num": 18, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00018\" num=\"18\"><claim-text>18. A method according to <claim-ref idref=\"US-6594732-B1-CLM-00016\">claim 16</claim-ref>, wherein said predetermined portion is a row address of said physical address in the latest memory access, and</claim-text><claim-text>wherein said writing back includes: </claim-text><claim-text>holding said row address in said continuous write back mode; and </claim-text><claim-text>responding generation control signals to sequentially generate cleaning physical addresses while updating a column address, in said continuous write back mode, respectively, each of said cleaning physical addresses including said row address and said updated column address. </claim-text></claim>"}, {"num": 19, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00019\" num=\"19\"><claim-text>19. A method according to <claim-ref idref=\"US-6594732-B1-CLM-00016\">claim 16</claim-ref>, wherein said writing back includes:</claim-text><claim-text>comparing said cleaning physical address and one of said tag addresses; </claim-text><claim-text>generating one of a cache hit signal or a cache miss hit signal based on the comparing result; and </claim-text><claim-text>generating said generation control signal each time said cache miss hit signal is outputted from said address comparator or each time said cache hit signal is outputted from said address comparator but said flag corresponding to the cache hit signal indicates the clean state, and after one of said dirty write back cache data is written back in said main memory when said cache hit signal is outputted from said address comparator and said flag corresponding to the cache hit signal indicates the dirty state. </claim-text></claim>"}, {"num": 20, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6594732-B1-CLM-00020\" num=\"20\"><claim-text>20. A method according to <claim-ref idref=\"US-6594732-B1-CLM-00017\">claim 17</claim-ref>, further comprising:</claim-text><claim-text>selecting said physical address obtained from said logical address when said continuous write back mode is not set; and </claim-text><claim-text>selecting said cleaning physical address when said continuous write back mode is set. </claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53955891\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates to a computer system. More particularly, the present invention relates to a computer system having a memory system having a write back type cache memory.</p><p>2. Description of the Related Art</p><p>In a memory system for a high speed operation, SRAM (Synchronous DRAM) is typically used for a cache memory, DRAM is used for a main memory, and a write back system is employed.</p><p>In the write back system, there is a case that a data written in the cache memory is not immediately written back to the main memory so that a device (hereafter, referred to as a processor) can carry out a memory access at high speed. Accordingly, the cache memory and the main memory sometimes have data different from each other. This inconsistent state is referred to as a \u201cdirty\u201d state. On the contrary, the consistent state is referred to as a \u201cclean\u201d state.</p><p>FIGS. 1A to <b>1</b>H show the write back operation in a typical computer system with a main controller. Referring to FIGS. 1A to <b>1</b>H, a main controller typically expects a page hit to the main memory, and waits for a next memory access without carrying out the access while keeping the same row address active. This is carried out not only in the case of the write back operation, but also after the end of the main memory access. This is because the access can be carried out from a column cycle without need of a pre-charging operation, if an access to the same row address, i.e., the page hit occurs. Upon occurrence of an access of page miss, the row address is switched in accordance with the standard of DRAM. In this case, a RAS signal (row address strobe signal) is again outputted, i.e., the pre-charging operation is carried out again, and then the access is carried out.</p><p>It is necessary to carry out the write back operation to the main memory in case of a cache memory miss hit. In this case, a data to be abandoned in order to store a new data in the cache memory is written in the main memory. The write back operation to the main memory is carried out under a control of a memory controller, and carried out to only a cache memory area in the dirty state. This write back operation must be always carried out in order to write a correct data to the main memory. For this reason, the write back operation can not be interrupted even if a new memory access is requested from a CPU during the write back operation. Thus, the write back operation occupies a memory bus for a period of the write back operation. Therefore, it is not effective to carry out the write back operation for each cache memory miss hit, even if it is necessary. The reason is that a necessary process can not be forwarded while the write back operation is carried out.</p><p>The proposals to improve an efficiency of a computer system using the write back type cache memory are disclosed in Japanese Laid Open Patent Application (JP-A-Heisi 4-69750), Japanese Laid Open Patent Application (JP-A-Heisi 6-309231) and the like.</p><p>In the Japanese Laid Open Patent Application (JP-A-Heisei 5-20195), a page mode is used to carry out the write back operation. In the Japanese Laid Open Patent Application (JP-A-Heisei 4-69750), the write back operation and a reading out operation are continuously carried out if the write back operation and the reading out operation have the same row address. However, these two conventional examples are intended to improve the efficiency of the write back operation itself. They can not solve the problem that the necessary process can not be carried out while the write back operation is carried out.</p><p>In the Japanese Laid Open Patent Application (JP-A-Heisei 6-309231), an empty time of a bus is used to carry out the write back operation. If the write back operation is carried out by use of the empty time of the bus, the efficiency of the computer system can be improved as a whole because other processes are not disturbed. However, in the Japanese Laid Open Patent Application (JP-A-Heisei 6-309231), the write back operation using the empty time of the bus is autonomously started in a predetermined period. That is, it is checked whether or not the bus is empty, at every predetermined period. If the bus is empty, the write back operation is carried out. On the contrary, if the bus is not empty, the write back operation is not carried out, and the operational flow waits for a next period. For this reason, it is necessary to periodically check whether or not the bus is empty. Moreover, the write back operation itself is carried out by use of a procedure similar to the conventional write back operation. Thus, it does not improve the efficiency of the write back operation itself. Furthermore, the write back operation is not carried out if the bus is not empty. Hence, it is impossible to cope with the cache memory areas at the dirty state surely and quickly.</p><p>In conjunction with the above description, a DRAM control system is described in Japanese Laid Open Patent Application (JP-A-Heisei 7-271666). In the reference, there are two registers: one storing an address data in a range of the line size of a cache memory and the other storing an address data out of the range of the line size of the cache memory. When a snoop process is generated, an address information on a bus is held by the two registers and an active command is inputted. When the write back cycle is generated, only the address data in a range of the line size of the cache memory is held by the register and a write command is inputted. Thus, the active command to a synchronous DRAM can be inputted during the snoop process before the access to a main memory unit by a bus master is started. Therefore, when the write back cycle is carried out, the active command can be omitted, resulting in improvement of efficiency.</p><h4>SUMMARY OF THE INVENTION</h4><p>Therefore, an object of the present invention is to provide a computer system with a memory system having a write back type cache memory.</p><p>Another object of the present invention is to provide a computer system with a memory system in which a cache line in a write back type cache memory can be kept as clean as possible.</p><p>In order to achieve an aspect of the present invention, a computer system includes a host bus, a CPU connected to the host bus, a main memory connected to the host bus, a cache memory and a memory controller. The cache memory is connected to at least one of the host bus and the CPU, stores cache data. A tag address and a flag are provided for each of the cache data and the flag indicates one of a clean state in which the corresponding cache data is written back into the main memory and a dirty state in which the corresponding cache data is not yet written back into the main memory. The memory controller is connected to the host bus, the cache memory and the main memory. The memory controller writes back dirty write back cache data into the main memory in a continuous write back mode, when the host bus is not used, wherein the dirty write back cache data is a part of the cache data stored in the cache memory, and each of the dirty write back cache data is not written back and includes a predetermined portion in the tag address.</p><p>The CPU accesses the cache memory or the main memory in a memory access using the host bus, and the predetermined portion is a row address of a physical address in the latest memory access. It is preferable that the memory controller holds the row address in the continuous write back mode.</p><p>The memory controller may cancel the continuous write back mode when the CPU accesses the cache memory or the main memory in a memory access using the host bus. In this case, the memory controller includes an address decoder connected to the host bus. The address decoder decodes a logical address on the host bus into a physical address and detects the memory access by the CPU. The memory controller cancels the continuous write back mode when the memory access is detected by the address decoder. In this case, the predetermined portion may be a row address of the physical address in the latest memory access. Also, the memory controller may hold the row address in the continuous write back mode.</p><p>In addition, the memory controller sequentially generates cleaning physical addresses while updating a column address, in the continuous write back mode. Each of the cleaning physical addresses includes the row address and the updated column address. The memory controller writes back the dirty write back cache in the main memory based on the generated cleaning physical addresses, and the tag addresses and the flags corresponding to the dirty write back cache data. In this case, the memory controller updates the column address immediately when the cleaning physical address does not hit to any of the tag addresses, or when the cleaning physical address hits to one of the tag addresses but the flag corresponding to the hit tag address indicates that the corresponding cache data is in the clean state, and after the writing back operation of the dirty write back cache data in the main memory when the cleaning physical address hits to one of the tag addresses corresponding to the one dirty write back cache data and the flag corresponding to the one dirty write back cache data indicates that the one dirty write back cache data is in the dirty state.</p><p>Also, the computer system may further include a bus arbiter connected to the host bus. The bus arbiter detects that the host bus is not used, and the memory controller sets the continuous write back mode.</p><p>The memory controller may detect that the host bus is not used, and sets the continuous write back mode.</p><p>In order to achieve another aspect of the present invention, a memory system includes a host bus, a main memory connected to the host bus, a cache memory and a memory controller. The cache memory stores cache data. A tag address and a flag are provided for each of the cache data and the flag indicates one of a clean state in which the corresponding cache data is written back into the main memory and a dirty state in which the corresponding cache data is not yet written back into the main memory. The memory controller is connected to the host bus, the cache memory and the main memory. The memory controller writes back dirty write back cache data into the main memory in a continuous write back mode, when the host bus is not used, wherein the dirty write back cache data is a part of the cache data stored in the cache memory, and each of the dirty write back cache data is not written back and includes a predetermined portion in the tag address.</p><p>In this case, the memory controller may include an address decoder and a controller. The address decoder is connected to the host bus. The address decoder decodes a logical address on the host bus into a physical address and detects that the host bus is used. The controller cancels the continuous write back mode when it is detected by the address decoder that the host bus is used. In this case, the predetermined portion may be a row address of the physical address in the latest memory access, and the controller may issue generation control signals in the continuous write back mode. The memory controller includes a latch circuit holding the row address, and an address generator. The address generator is responsive to the generation control signals to generate cleaning physical addresses while updating a column address, in the continuous write back mode, respectively, each of the cleaning physical addresses including the row address and the updated column address. Also, the memory controller includes an address comparator comparing the cleaning physical address and one of the tag addresses and generating one of a cache hit signal or a cache miss hit signal based on the comparing result. The controller generates the generation control signal each time the cache miss hit signal is outputted from the address comparator or each time the cache hit signal is outputted from the address comparator but the flag corresponding to the cache hit signal indicates the clean state, and after one of the dirty write back cache data is written back in the main memory when the cache hit signal is outputted from the address comparator and the flag corresponding to the cache hit signal indicates the dirty state.</p><p>In addition, the memory controller may include a selector selecting the physical address outputted from the address decoder when the continuous write back mode is not set, and selecting the cleaning physical address generated by the address generator when the continuous write back mode is set.</p><p>In order to achieve still another aspect of the present invention, a method of keeping a cache memory clean in a computer system comprising the cache memory and a main memory which are both connected to a host bus, the cache memory storing cache data, wherein a tag address and a flag are provided for each of the cache data and the flag indicates one of a clean state in which the corresponding cache data is written back into the main memory and a dirty state in which the corresponding cache data is not yet written back into the main memory. The method includes:</p><p>setting a continuous write back mode when the host bus is not; and</p><p>writing back dirty write back cache data into the main memory in the continuous write back mode, wherein the dirty write back cache data is a part of the cache data stored in the cache memory, and each of the dirty write back cache data is not written back and includes a predetermined portion in the tag address.</p><p>Here, the continuous write back mode is cancelled when the host bus is used for a memory access to the cache memory or the main memory. In the canceling, use of the host bus is detected based on a logical address on the host bus, the logical address being decoded into a physical address.</p><p>Also, the predetermined portion may be a row address of the physical address in the latest memory access. In the writing back, the row address is held in the continuous write back mode. Also, generation control signals are responded to sequentially generate cleaning physical addresses while updating a column address, in the continuous write back mode, respectively, each of the cleaning physical addresses including the row address and the updated column address.</p><p>Moreover, in the writing back, the cleaning physical address and one of the tag addresses are compared with each other, and one of a cache hit signal or a cache miss hit signal is generated based on the comparing result. The generation control signal is generated each time the cache miss hit signal is outputted from the address comparator or each time the cache hit signal is outputted from the address comparator but the flag corresponding to the cache hit signal indicates the clean state, and after one of the dirty write back cache data is written back in the main memory when the cache hit signal is outputted from the address comparator and the flag corresponding to the cache hit signal indicates the dirty state.</p><p>The method may further includes:</p><p>selecting the physical address obtained from the logical address when the continuous write back mode is not set; and</p><p>selecting the cleaning physical address when the continuous write back mode is set.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIGS. 1A to <b>1</b>H are timing charts showing a write back operation in a conventional computer system with a memory system having a write back type cache memory;</p><p>FIG. 2 is a block diagram showing a whole configuration in a computer system with a memory system having a write back type cache memory according to the present invention;</p><p>FIG. 3 is a block diagram showing a memory controller in the memory system according to the present invention; and</p><p>FIGS. 4A to <b>4</b>H are timing charts showing a write back operation of the computer system with the memory system according to the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DESCRIPTION OF THE PREFERRED EMBODIMENTS</h4><p>Hereinafter, a computer system with a memory system having a write back type cache memory of the present invention will be described below with reference to the attached drawings.</p><p>FIG. 2 is a block diagram showing a whole configuration of the computer system with the memory system according to the present invention. Referring to FIG. 2, a host bus <b>10</b> is provided with an address bus and a data bus, and a control bus is included in the address bus. A CPU <b>12</b> and a memory controller <b>16</b> are connected to both the address bus and the data bus in the host bus <b>10</b>. A cache memory <b>14</b> is connected to only the data bus of the host bus <b>10</b>. It should be noted that the CPU <b>12</b> and the cache memory <b>14</b> may be connected to each other through a bus dedicated to a cache memory. The memory controller <b>16</b> sends only an address to the cache memory <b>14</b>. A main memory <b>18</b> has a quick page access mode and is controlled by the memory controller <b>16</b>. The main memory <b>18</b> receives an address from the memory controller <b>16</b>. Moreover, the main memory <b>18</b> receives a data through the memory controller <b>16</b>, and outputs a data through the memory controller <b>16</b>. In the example shown in FIG. 2, the main memory itself is composed of SDRAM. A bus arbiter <b>48</b> is connected to the host bus <b>10</b>. The bus arbiter <b>48</b> determines whether or not the main memory access is ended, by use of various methods. For example, the bus arbiter <b>48</b> determines a kind of access after reception of the address. The bus arbiter <b>48</b> monitors or counts the number of clocks. When the count reaches a value determined based on the kind of the access, the bus arbiter <b>48</b> determines that the main memory access is end. Or, after the reception of the address, the number of clocks is counted. When the count reaches a predetermined maximum clock number within the necessary clock number until the end of each type of access, the bus arbiter <b>48</b> determines that the main memory access is end. In the latter case, a slightly useless cycle is brought about.</p><p>FIG. 3 shows a block diagram of the memory controller <b>16</b> in the computer system according to the present invention. The memory controller <b>16</b> according to the present invention shown in FIG. 3 is composed of an address decoder <b>20</b>, a selector <b>22</b>, an address bus <b>24</b>, an address comparator <b>28</b>, a controller <b>30</b>, a column address generator <b>32</b>, an address multiplexer <b>34</b>, a latch circuit <b>36</b>, an address generator <b>38</b>, and a latch circuit <b>40</b>. The cache memory <b>14</b> has a tag region <b>14</b>-<b>1</b>. Thus, in the memory controller <b>16</b> of the present invention, the selector <b>22</b>, the address generator <b>38</b> and the latch circuit <b>40</b> are added to a conventional memory controller. Thus, the known portions in the conventional memory controller having no direct relation to the memory operation peculiar to the present invention are omitted or simplified to simplify the drawings. Especially, FIG. 3 shows only the portions having relation to an address, and the portions having relation to data is omitted, since it is not changed from the conventional memory controller. Hence, the data bus is omitted. Moreover, many control signals having relation to data transfer are omitted.</p><p>The address decoder <b>20</b> receives a virtual address or a logical address on the host bus <b>10</b> and outputs a physical address to the selector <b>22</b>. The selector <b>22</b> is connected to an address bus <b>24</b>. The selector <b>22</b> receives the physical addresses from the address decoder <b>20</b> and the latch circuit <b>40</b> and selectively outputs one of the physical addresses onto the address bus <b>24</b> in response to a selection control signal <b>53</b> from the controller <b>30</b>. The cache memory <b>14</b> is connected to the address bus <b>24</b>. The cache memory <b>14</b> is divided into a data section <b>14</b>-<b>2</b>, the tag region <b>14</b>-<b>1</b>, and a flags section <b>14</b>-<b>3</b>. The tag region <b>14</b>-<b>1</b> stores tag addresses for a plurality of cache data <b>14</b>-<b>2</b>. The flags section <b>14</b>-<b>3</b> of the cache memory <b>14</b> stores a dirty/clean flag and a valid/invalid flag for each cache data <b>14</b>-<b>2</b>. The dirty/clean flag indicates whether the cache data is clean. The valid/invalid flag indicates whether the cache data can be used.</p><p>The memory controller <b>16</b> further has the address comparator <b>28</b>. This address comparator <b>28</b> compares the physical address on the address bus <b>24</b> and the address stored in the tag region <b>14</b>-<b>1</b> of the cache memory <b>14</b>. When both the addresses are coincident with each other, the address comparator <b>28</b> outputs a cache hit signal <b>51</b> to the controller <b>30</b> and the column address generator <b>32</b>. Upon receipt of the cache memory hit signal <b>51</b>, the column address generator <b>32</b> receives a column address (<b>1</b>:<b>0</b>) of the physical address on the address bus <b>24</b>, and outputs a column address CA (<b>1</b>:<b>0</b>) to the cache memory <b>14</b>.</p><p>The controller <b>30</b> checks whether or not the cache hit signal <b>51</b> is outputted from the address comparator <b>28</b>. If the cache hit signal <b>51</b> is outputted, the controller <b>30</b> outputs an output enable signal OE <b>52</b> to the cache memory <b>14</b>. Moreover, the controller <b>30</b> generates the selection control signal <b>53</b> based on the cache hit signal <b>51</b> to output to the selector <b>22</b>. When receiving a signal <b>54</b> indicative of a change of an address from the address decoder <b>20</b>, namely, the signal indicative of a receipt of a new main memory access, the controller <b>30</b> outputs the selection control signal <b>53</b> to the selector <b>22</b> so as to output the physical address of the address decoder <b>20</b> onto the address bus <b>24</b>.</p><p>Moreover, the memory controller <b>16</b> has an address multiplexer <b>34</b>. The address multiplexer <b>34</b> receives the physical address (<b>31</b>:<b>3</b>) from the address bus <b>24</b> in response to a multiplex control signal from the controller <b>58</b>, and divides into a row address and a column address. The addresses outputted in order from the address multiplexer <b>34</b> are latched by the latch circuit <b>36</b> in response to a latch control signal <b>57</b> from the controller <b>30</b>. The memory address MA (<b>11</b>:<b>0</b>) latched by the latch circuit <b>36</b> is sent to the main memory <b>18</b>. Moreover, when the row address is latched by the latch circuit <b>36</b>, the latched row address is sent to the address generator <b>38</b>. The address generator <b>38</b> generates a physical address based on the row address in response to a generation control signal <b>55</b> from the controller <b>30</b>. The generated physical address is supplied and latched by the latched circuit <b>40</b> in response to a latch control signal <b>56</b> from the controller <b>30</b>. The address latched by the latch circuit <b>40</b> is supplied to the selector <b>22</b>, as described above.</p><p>As mentioned above, the memory controller <b>16</b> according to the present invention shown in FIG. 3 is constituted by adding the selector <b>22</b>, the address generator <b>38</b> and the latch circuit <b>40</b> to the conventional memory controller. Thus, the memory controller <b>16</b> is operated similarly to the conventional memory controller other than the operation having relation to the added components.</p><p>The operation of the computer system of the present invention will be described below.</p><p>If the cache memory hit would occur in a memory read access of the CPU <b>12</b>, the memory controller <b>16</b> is operated similarly to the conventional memory controller. That is, the address decoder <b>20</b> receives a logical address for a new main memory access to generate the signal <b>54</b> to the controller <b>30</b>. Also, the address decoder <b>20</b> decodes the logical address to generate a physical address. The controller <b>30</b> controls the selector <b>22</b> in response to the signal <b>54</b> to select and output the physical address from the address decoder <b>20</b> onto the address bus <b>24</b>. The address comparator <b>28</b> compares the physical address on the address bus <b>24</b> with the addresses stored in the tag region <b>14</b>-<b>1</b> of the cache memory <b>14</b>. When the physical address on the address bus <b>24</b> is coincident with one of the tag addresses, the address comparator <b>28</b> outputs the cache memory hit signal <b>51</b> to the controller <b>30</b> and the column address generator <b>32</b>. The column address generator <b>32</b> receives the column address (<b>1</b>:<b>0</b>) of the physical address on the address bus <b>24</b> in response to the cache memory hit signal <b>51</b>, and outputs the column address CA (<b>1</b>:<b>0</b>) to the cache memory <b>14</b>. The controller <b>30</b> outputs the output enable signal OE to the cache memory <b>14</b> in response to the cache memory hit signal <b>51</b> from the address comparator <b>28</b>. As a result, the data is outputted from the cache memory <b>14</b> to the CPU <b>12</b>.</p><p>If the cache memory miss hit would occur in the memory read access by the CPU <b>12</b>, the write back operation to the main memory <b>18</b> is carried out similarly to the conventional example. Since the configuration necessary for such an operation is conventionally known as mentioned above, it is omitted in FIG. <b>3</b>.</p><p>In this case, the address decoder <b>20</b> receives the address for the new main memory access to generate the signal <b>54</b> to the controller <b>30</b>. Also, the address decoder <b>20</b> decodes the logical address to generate the physical address. The controller <b>30</b> controls the selector <b>22</b> in response to the signal <b>54</b> to select and output the physical address from the address decoder <b>20</b> onto the address bus <b>24</b>. The address comparator <b>28</b> compares the physical address on the address bus <b>24</b> with the tag addresses stored in the tag region <b>14</b>-<b>1</b> of the cache memory <b>14</b>. As a result, the address comparator <b>28</b> outputs a cache memory miss hit signal <b>51</b> to the controller <b>30</b> and the column address generator <b>32</b>.</p><p>The controller <b>30</b> searches the tag region <b>14</b>-<b>1</b> for the oldest updated data in response to the cache memory miss hit signal <b>51</b> by use of the conventional known operation. There are known many algorithms for update of the cache memory. Therefore, another algorithm may be used. The controller <b>30</b> refers to the dirty/clean flag corresponding to the oldest updated data. When the dirty/clean flag indicates that the oldest updated data is clean, the controller <b>30</b> generates the signals <b>58</b> and <b>57</b> to control the address multiplexer <b>34</b> and the latch circuit <b>36</b> such that the physical address on the address bus <b>24</b> is outputted to the main memory <b>18</b> in an order of the row address and the column address. As a result, the data corresponding to the physical address in the main memory <b>18</b> is outputted to the host bus <b>10</b>. At that time, the data is sent to the cache memory <b>14</b> as well as the CPU <b>12</b>, and written in the cache memory <b>14</b>. On the other hand, the physical address on the address bus <b>24</b> is written to the tag region <b>14</b>-<b>1</b> as the tag address. Moreover, the dirty/clean flag is reset at a clean state, and the valid/invalid flag is set at a valid state.</p><p>Next, a case where the dirty/clean flag corresponding to the oldest updated data indicates the dirty state will be described below. In this case, the following operation is carried out before the above-mentioned operation in the case that the dirty/clean flag is clean.</p><p>As shown in FIGS. 4A to <b>4</b>H, when the oldest updated data is dirty, it is necessary to write back the cache data of the cache memory <b>14</b> into the main memory <b>18</b>. The controller <b>30</b> generates the signals <b>58</b> and <b>57</b> to control the address multiplexer <b>34</b> and the latch circuit <b>36</b> such that a tag address as a main memory address from the tag region <b>14</b>-<b>1</b> is latched through the address bus <b>24</b> and the address multiplexer <b>34</b>. Further, the controller <b>30</b> outputs the latched main memory address to the main memory <b>18</b> in the order of the row address and the column address. The oldest updated data is outputted from the cache memory <b>14</b> to the main memory <b>18</b>. As a result, the write back operation to the main memory <b>18</b> is carried out. Subsequently, the controller <b>30</b> carries out the operation similar to operation when the oldest updated data of the cache memory <b>14</b> is clean. In this way, the data of the main memory <b>18</b> is outputted to the host bus <b>10</b> and supplied to the CPU <b>12</b>. Also, the data is written to the cache memory <b>14</b>.</p><p>The above-mentioned operation is the write back operation. Thereafter, an operation associated with the present invention is carried out in a continuous write back mode.</p><p>That is, following the write back operation resulting from the cache memory miss hit, the controller <b>30</b> of the present invention determines whether or not the main memory access is ended. In this example, the bus arbiter <b>48</b> detects the end of the main memory access and outputs a main memory access end signal (not shown) to the controller <b>30</b>. However, the controller <b>30</b> may have the functions of the bus arbiter <b>48</b>. In this case, the main memory access end signal is unnecessary.</p><p>After the end of the main memory access is detected as mentioned above, the controller <b>30</b> issues the generation control signal <b>55</b>. That is, the controller <b>30</b> controls the address generator <b>38</b> to generate a new address corresponding to a row address of the physical address immediately before the end of the main memory access. The latch circuit <b>40</b> latches the generated physical address in response to the latch signal <b>56</b> from the controller <b>30</b>. Also, the controller <b>30</b> outputs the selection control signal <b>53</b> to the selector <b>22</b> such that the physical address latched in the latch circuit <b>40</b> is outputted to the address bus. Here, the new physical address has the same row address and a different column address, as shown FIGS. 4F and 4G. The different column address has an initial value. Then, the different column address is sequentially incremented, as described below.</p><p>The address comparator <b>28</b> compares the physical address on the address bus <b>24</b> with the tag addresses stored in the tag region <b>14</b>-<b>1</b> of the cache memory <b>14</b>. As a result, when the cache memory miss hit signal <b>51</b> is outputted to the controller <b>30</b>, the controller <b>30</b> issues the generation control signal <b>55</b> to the address generator <b>38</b>. The address generator <b>38</b> generates a new address composed of the row address and an incremented new column address. The row address is equal to that of the address immediately before the end of the main memory access. The column address is obtained by incrementing the above column address. Then, the controller <b>30</b> issues the latch control signal <b>56</b> and the selection control signal <b>53</b> to the latch circuit <b>40</b> and the selector <b>22</b>, respectively. Thus, the address comparator <b>28</b> again compares the physical address on the address bus <b>24</b> with the tag addresses stored in the tag region <b>14</b>-<b>1</b> of the cache memory <b>14</b>. As the compared result, it is supposed that the cache memory hit signal <b>51</b> is outputted to the controller <b>30</b>. In this case, if the dirty/clean flag is clean, the controller <b>30</b> again issues the generation control signal <b>55</b>, the latch control signal <b>56</b>, and the selection control signal <b>53</b> to the address generator <b>38</b>, the latch circuit <b>40</b> and the selector <b>22</b>, respectively. As a result, a new physical address is generated by the address generator <b>38</b>. Here, the column address is further incremented.</p><p>Next, as the compared result, it is supposed that the cache memory hit signal <b>51</b> is outputted to the controller <b>30</b>. Also, it is supposed that the dirty/clean flag is dirty. In this case, as shown in FIGS. 4A to <b>4</b>H, the controller <b>30</b> controls the address multiplexer <b>34</b> and the latch circuit <b>36</b> such that the latch circuit <b>36</b> latches the main memory address on the address bus <b>24</b> through the address multiplexer <b>34</b>. Then, the controller <b>30</b> controls the latch circuit <b>36</b> to output the main memory address to the main memory <b>18</b> in the order of the row address and the column address. The data of the cache memory <b>14</b> corresponding to the hit address is outputted to the main memory <b>18</b>. Thus, the write back operation to the main memory <b>18</b> is carried out. Subsequently, the dirty/clean flag of the flags region <b>14</b>-<b>3</b> is reset to the clean state. Accordingly, one cache memory line at the dirty state can be changed into the clean state. Accordingly, one cache memory line at the dirty state can be changed into the clean state.</p><p>In succession, the controller <b>30</b> issues the generation control signal <b>55</b>, the latch control signal <b>56</b>, and the selection control signal <b>53</b> to the address generator <b>38</b>, the latch circuit <b>40</b> and the selector <b>22</b>. The address generator <b>38</b> generates a new address composed of the same row address and the further-incremented column address.</p><p>The above-mentioned cycles are continued until the memory controller <b>16</b> receives a new main memory access. That is, it is supposed that the address decoder <b>10</b> receives a new main memory address, as shown in FIGS. 4A to <b>4</b>H. In this case, the address decoder <b>10</b> outputs the signal <b>54</b> indicative of the reception of the new main memory access to the controller <b>30</b>. The controller <b>30</b> issues the selection control signal <b>53</b> to the selector <b>22</b> to control the selector <b>22</b> to output the physical address decoded by the address decoder <b>10</b> on to the address bus <b>24</b>. Consequently, the write back operation of the cache memory <b>14</b> is immediately ended. This is, the operation corresponding to failure of a cleaning operation of a memory data is stopped. Thus, if the memory controller <b>16</b> receives the new main memory access, the write back operation of the present invention is immediately ended. Hence, the main memory is not disturbed at all.</p><p>As mentioned above, following the write back operation resulting from the cache memory miss hit, the memory controller <b>16</b> according to the present invention selectively carries out the write back operation after the end of the main memory access. In the above, if a cache memory line indicated by the tag is dirty, the write back operation is carried out in succession while the row address is fixed to be active. Also, after the end of the write back operation according to the present invention, the memory controller sets the dirty/clean flag to the clean state. This process is performed on all the lines which correspond to the same row address in the cache memory, and in which the dirty/clean flags indicate the dirty state.</p><p>On the other hand, if a new memory access resulting from the CPU <b>12</b> occurs during the period of the write back operation according to the present invention, the write back operation according to the present invention is immediately ended. Then, the dirty bit in its line ends while maintaining its dirty state. At this time, data in the main memory is re-written until the middle of the cache memory line. However, since the cache memory line is kept dirty, the memory data may be re-written until the middle. Thus, the conventional access is not disturbed at all even if the write back operation according to the present invention is ended.</p><p>The state of the line in which the write back operation is ended is changed into the clean state. Thus, the cache memory line in which the write back operation according to the present invention is ended does not require the write back operation that occupies the bus of the main memory and leads to the drop of the performance. Hence, the performance of the system can be improved as a whole. The present invention is especially effective in improving the performance of the system using as the main memory SDRAM in which a command can be sent and received at a speed equal to or faster than that of the clock of the processor.</p><p>According to the present invention, the empty time of the bus is used to change the dirty cache memory line into the clean cache memory line without dropping the performance of the system. Thus, the performance of the system can be improved as a whole. Its reason is as follows. That is, after the end of the read/write cycle resulting from the cache memory miss hit, it is determined whether or not another tag region corresponding to the row address in its cycle exists and further the cache memory line is dirty. Then, the write back operation is carried out while the row address is fixed. On the other hand, if an access resulting from the other factor occurs, the process is stopped in the middle thereof. Thus, the access is not disturbed.</p><p>Moreover, after the end of the read/write cycle resulting from the cache memory miss, the write back operation is carried out while the row address in its cycle is fixed. Thus, differently from the procedure of the conventional write back operation, it is not necessary to again send the row address. As a result, the efficiency of the write back operation itself can be improved as compared with the case of carrying out the write back operation by using the procedure similar to that of the conventional write back operation.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Noriaki", "last_name": "Sugiyama", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "NEC ELECTRONICS CORPORATION"}, {"first_name": "", "last_name": "NEC ELECTRONICS CORPORATION", "name": ""}, {"first_name": "", "last_name": "NEC CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  13/14"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20060722RMJP"}, {"label": "G06F  13/14        20060101A I20051110RMEP"}], "national_classes": [{"primary": true, "label": "711143"}, {"primary": false, "label": "711E1204"}, {"primary": false, "label": "710244"}, {"primary": false, "label": "711144"}, {"primary": false, "label": "711158"}, {"primary": false, "label": "710035"}], "ecla_classes": [{"label": "G06F  12/08B2"}], "cpc_classes": [{"label": "G06F  12/0804"}, {"label": "G06F  12/0804"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1998-12-22", "application_date": "1999-12-17", "family_members": [{"ucid": "US-6594732-B1", "titles": [{"lang": "EN", "text": "Computer system with memory system in which cache memory is kept clean"}]}, {"ucid": "JP-2000187616-A", "titles": [{"lang": "JA", "text": "\u30ad\u30e3\u30c3\u30b7\u30e5\u30e9\u30a4\u30f3\u3092\u30af\u30ea\u30fc\u30f3\u306a\u72b6\u614b\u306b\u4fdd\u3064\u30e1\u30e2\u30ea\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "MEMORY SYSTEM FOR KEEPING CACHE LINE CLEAN"}]}]}