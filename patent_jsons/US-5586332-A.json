{"patent_number": "US-5586332-A", "publication_id": 71397114, "family_id": 21888081, "publication_date": "1996-12-17", "titles": [{"lang": "EN", "text": "Power management for low power processors through the use of auto clock-throttling"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA37596012\"><p>A clock throttling mechanism turns off certain processor components to minimize power consumption. The processor detects the issuance of certain bus cycles or the execution of certain instructions which typically cause the processor to be idle for a period of time. Control circuitry detects the existence of the instruction and/or bus cycle and shuts down the clock driving certain processor components during that idle period. The control circuitry then detects the occurrence or upcoming occurrence of an event to which the processor responds and becomes active. At detection of this event, the clock signal input to these components is then restarted such that the processor can continue normal execution.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. A method for minimizing power consumption of a processing component, comprising the steps of:<claim-text>detecting the execution of a predetermined instruction that during the execution of the instruction the processing component is in a wait state for a length of time at least as long as the time it takes to stop and restart the clocks;</claim-text><claim-text>stopping the clock signal input to elements of the processing component when the processing component is to enter a wait state during execution of the predetermined instruction, such that certain elements of the processing component do not operate and consume power;</claim-text><claim-text>detecting the occurrence of a predetermined event indicative that the processing component is to exit the wait state; and</claim-text><claim-text>restarting the clock signal input to the elements of the processing component when the occurrence of the predetermined event is detected thereby reinitiating operation of the certain elements of the processing component such that the processing component resumes normal operation.</claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. The method as set forth in claim 1, wherein the step of detecting the execution of the predetermined instruction comprises the step of monitoring the bus for initiation of predetermined bus cycles determined to cause the processing component to be in a wait state.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. The method as set forth in claim 1, wherein the step of detecting the execution of the predetermined instruction comprises the step of monitoring the types of instructions executed by the processing component to identify those instructions which cause the processing component to enter a wait state.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. The method as set forth in claim 1, wherein the step of stopping the clock signal input stops the clock signal input to the elements of the processing component which do not detect the occurrence of a predetermined event and restart the clock signal input.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. The method as set forth in claim 1, wherein the step of detecting the occurrence of a predetermined event comprises the step of detecting the issuance of a ready signal indicative that data is to be available to the processing component.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. The method as set forth in claim 1, wherein the step of detecting the occurrence of a predetermined event detects that data is available to the processing component.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. The method as set forth in claim 1, wherein the step of detecting the execution of the predetermined instruction comprises the step of detecting the initiation of I/O read/write bus cycles.</claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. The method as set forth in claim 1, wherein the step of detecting the execution of the predetermined instruction comprises the step of detecting the initiation of non-cacheable memory data read cycles.</claim-text></claim>"}, {"num": 9, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. The method as set forth in claim 1, wherein the step of detecting the execution of the predetermined instruction comprises the step of detecting the initiation of the first memory data read of a cache line fill.</claim-text></claim>"}, {"num": 10, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. The method as set forth in claim 1, wherein the step of detecting the execution of the predetermined instruction comprises the step of detecting the initiation of processing component specific bus cycles.</claim-text></claim>"}, {"num": 11, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. The method as set forth in claim 1, wherein the step of detecting the execution of the predetermined instruction comprises the step of detecting processing component stalls during external memory write cycles.</claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim num=\"12\"><claim-text>12. The method as set forth in claim 11, wherein the step of detecting comprises the steps of:<claim-text>determining that a write buffer is full,</claim-text><claim-text>detecting that the external bus is busy with a bus cycle, and</claim-text><claim-text>the instruction executing issues a memory write cycle.</claim-text></claim-text></claim>"}, {"num": 13, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"13\"><claim-text>13. The method as set forth in claim 1, further comprising the step of confirming that a coprocessor is not busy and a cache invalidation bus cycle is not in progress prior to stopping the clock signal input, such that if the coprocessor is busy or a cache invalidation cycle is in progress, the clock signal input is not stopped.</claim-text></claim>"}, {"num": 14, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"14\"><claim-text>14. A processing component comprising:<claim-text>means for executing instructions, said means receiving a clock signal input to drive the means for executing instructions;</claim-text><claim-text>means for detecting the execution of a predetermined instruction, said means for executing waiting during at least a portion of the time required to execute the predetermined instruction;</claim-text><claim-text>means for stopping the clock signal input to drive the means for executing instructions when the means for executing instructions is to wait during execution of the predetermined instruction;</claim-text><claim-text>means for detecting the occurrence of a predetermined event indicative that the processing component is to cease waiting; and</claim-text><claim-text>means for restarting the clock signal input to the processing component when the occurrence of the predetermined event is detected thereby reinitiating the operation of the means for executing instructions such that the processing component resumes normal operation.</claim-text></claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim num=\"15\"><claim-text>15. The processing component as set forth in claim 14, wherein execution of the predetermined instruction causes bus cycles to be initiated by the processing component, said means for detecting the execution of the predetermined instruction comprises bus monitoring means which detects the initiation of predetermined bus cycles which are determined to cause the processing component to be in a wait state.</claim-text></claim>"}, {"num": 16, "parent": 14, "type": "dependent", "paragraph_markup": "<claim num=\"16\"><claim-text>16. The processing component as set forth in claim 14, wherein the means for detecting the execution of the predetermined instruction comprises microcode which monitors the types of instructions executed by the processing component to identify those instructions which cause the processing component to enter a wait state and determines when the means for executing enters a wait state.</claim-text></claim>"}, {"num": 17, "parent": 14, "type": "dependent", "paragraph_markup": "<claim num=\"17\"><claim-text>17. The processing component as set forth in claim 14, wherein the means for detecting the occurrence of a predetermined event comprises means for detecting the receipt of a ready signal indicative that data is to be available to the processing component.</claim-text></claim>"}, {"num": 18, "parent": 14, "type": "dependent", "paragraph_markup": "<claim num=\"18\"><claim-text>18. The processing component as set forth in claim 14, wherein the means for detecting the occurrence of a predetermined event detects that data is available to be received by the processing component.</claim-text></claim>"}, {"num": 19, "parent": 14, "type": "dependent", "paragraph_markup": "<claim num=\"19\"><claim-text>19. The processing component as set forth in claim 14, further comprising a write buffer for writing data to be written to external memory and an external bus connecting the processing component and external memory, said means for detecting the execution of the predetermined instruction comprising,<claim-text>means for detecting processing component stalls during external memory write cycles.</claim-text></claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim num=\"20\"><claim-text>20. The processing component as set forth in claim 19, wherein the means for detecting processing component stalls comprises:<claim-text>means for determining that a write buffer is full,</claim-text><claim-text>means for detecting that the external bus is busy with a bus cycle; and</claim-text><claim-text>means for detecting the issuance of a memory write cycle.</claim-text></claim-text></claim>"}, {"num": 21, "parent": 14, "type": "dependent", "paragraph_markup": "<claim num=\"21\"><claim-text>21. The processing component as set forth in claim 14, further comprising a means for confirming that a coprocessor is not busy and a cache invalidation bus cycle is not in progress prior to stopping the clock signal input, such that if the coprocessor is busy or a cache invalidation cycle is in progress, the clock signal input is not stopped.</claim-text></claim>"}, {"num": 22, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"22\"><claim-text>22. A processor comprising:<claim-text>a central processing unit for executing instructions, said CPU receiving a CPU clock signal input to drive the CPU;</claim-text><claim-text>a clock controller coupled to receive at least one clock signal and output the CPU clock signal, said controller comprising;<claim-text>a first detector for detecting the execution of a predetermined instruction, said CPU waiting during at least a portion of the time required to execute the predetermined instruction,</claim-text><claim-text>logic responsive to the first detector for stopping the CPU clock signal input when the CPU is to wait during execution of the predetermined instruction,</claim-text><claim-text>a second detector which detects the occurrence of a predetermined event indicative that the CPU is to cease waiting, and</claim-text></claim-text><claim-text>logic responsive to the second detector for restarting the clock signal input to the processor when the occurrence of the predetermined event is detected thereby reinitiating the operation of the CPU such that the processor resumes normal operation.</claim-text></claim-text></claim>"}, {"num": 23, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"23\"><claim-text>23. The processor as set forth in claim 22, said clock controller generating a second CPU clock signal, said second CPU clock signal being maintained in an on state.</claim-text></claim>"}, {"num": 24, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"24\"><claim-text>24. The processor as set forth in claim 22, wherein the first detector comprises microcode which monitors the types of instructions executed by the CPU to identify those instructions which cause the CPU to enter a wait state and determines when the CPU enters a wait state.</claim-text></claim>"}, {"num": 25, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"25\"><claim-text>25. The processor as set forth in claim 22, wherein the first detector comprises logic coupled to monitor bus cycles initiated by the CPU which are determined to cause the CPU to be in a wait state.</claim-text></claim>"}, {"num": 26, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"26\"><claim-text>26. The processor as set forth in claim 22, wherein the second detector is coupled to receive a ready signal indicative that data is to be available to the processor.</claim-text></claim>"}, {"num": 27, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"27\"><claim-text>27. The processor as set forth in claim 22, wherein the second detector detects that data is available to be received by the processor.</claim-text></claim>"}, {"num": 28, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"28\"><claim-text>28. The processor as set forth in claim 22, further comprising a write buffer for writing data to be written to external memory and an external bus connecting the processor and external memory, said first detector detecting processor stalls during external memory write cycles.</claim-text></claim>"}, {"num": 29, "parent": 28, "type": "dependent", "paragraph_markup": "<claim num=\"29\"><claim-text>29. The processor as set forth in claim 28, said first detector:<claim-text>determining that a write buffer is full;</claim-text><claim-text>detecting that the external bus is busy with a bus cycle; and</claim-text><claim-text>detecting the issuance of a memory write cycle.</claim-text></claim-text></claim>"}, {"num": 30, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"30\"><claim-text>30. The processor as set forth in claim 22, further comprising logic for confirming that a coprocessor is not busy and a cache invalidation bus cycle is not in progress prior to stopping the clock signal input, such that if the coprocessor is busy or a cache invalidation cycle is in progress, the clock signal input is not stopped.</claim-text></claim>"}, {"num": 31, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"31\"><claim-text>31. A microprocessor system comprising:<claim-text>a bus;</claim-text><claim-text>a central processing unit (CPU) coupled to the bus, said CPU receiving a CPU clock signal input to drive the CPU, said CPU initiating bus cycles on the bus to communicate information with a device, said CPU entering a wait state during the execution of a predetermined instruction comprising communications with the device across the bus;</claim-text><claim-text>at least one device coupled to the bus, said device receiving signals indicative of the bus cycle initiated by the CPU and subsequently issuing signals on the bus to the CPU indicative of a response to bus cycle signals received and;</claim-text><claim-text>a clock controller which controls the CPU clock signal input, said clock controller coupled to the bus detecting the execution of the predetermined instruction and stopping the CPU clock signal when the CPU enters a wait state, said CPU monitoring the bus for issuance of bus cycle signals by the device, said clock controller restarting the CPU clock signal when the device issued bus cycle signals are detected such that the CPU begins normal operation;</claim-text><claim-text>wherein power consumption by the CPU is minimized by stopping the clock when the CPU would be operating in a wait state.</claim-text></claim-text></claim>"}, {"num": 32, "parent": 31, "type": "dependent", "paragraph_markup": "<claim num=\"32\"><claim-text>32. The system as set forth in claim 31, said clock controller further coupled to receive a second clock signal input which drives the clock controller, said second clock signal input being maintained in an on state.</claim-text></claim>"}, {"num": 33, "parent": 31, "type": "dependent", "paragraph_markup": "<claim num=\"33\"><claim-text>33. The system as set forth in claim 31 wherein said clock controller is located on the CPU component.</claim-text></claim>"}, {"num": 34, "parent": 31, "type": "dependent", "paragraph_markup": "<claim num=\"34\"><claim-text>34. The system as set forth in claim 31, wherein said clock controller is located external to the CPU.</claim-text></claim>"}, {"num": 35, "parent": 31, "type": "dependent", "paragraph_markup": "<claim num=\"35\"><claim-text>35. The system as set forth in claim 31, wherein said clock controller comprises microcode which monitors the types of instructions executed by the CPU to identify those instructions which cause the CPU to enter a wait state and determines when the CPU enters a wait state.</claim-text></claim>"}, {"num": 36, "parent": 31, "type": "dependent", "paragraph_markup": "<claim num=\"36\"><claim-text>36. The system as set forth in claim 31, wherein the clock controller comprises logic coupled to monitor bus cycles initiated by the CPU which are determined to cause the CPU to be placed in a wait state.</claim-text></claim>"}, {"num": 37, "parent": 31, "type": "dependent", "paragraph_markup": "<claim num=\"37\"><claim-text>37. The system as set forth in claim 31, wherein the bus signal issued by the device comprises a ready signal indicative that data is to be placed on the bus to be available to the processor.</claim-text></claim>"}, {"num": 38, "parent": 31, "type": "dependent", "paragraph_markup": "<claim num=\"38\"><claim-text>38. The system as set forth in claim 31, wherein the bus signal also issued by the device comprises data placed on the bus to be available to be received by the processor.</claim-text></claim>"}, {"num": 39, "parent": 31, "type": "dependent", "paragraph_markup": "<claim num=\"39\"><claim-text>39. The system as set forth in claim 31, wherein the predetermined instruction comprises I/O read/write bus cycles.</claim-text></claim>"}, {"num": 40, "parent": 31, "type": "dependent", "paragraph_markup": "<claim num=\"40\"><claim-text>40. The system as set forth in claim 31, wherein the predetermined instruction comprises non-cacheable memory data read cycles.</claim-text></claim>"}, {"num": 41, "parent": 31, "type": "dependent", "paragraph_markup": "<claim num=\"41\"><claim-text>41. The system as set forth in claim 31, wherein the predetermined instruction comprises a first memory data read cycle of a cache line fill.</claim-text></claim>"}, {"num": 42, "parent": 31, "type": "dependent", "paragraph_markup": "<claim num=\"42\"><claim-text>42. The system as set forth in claim 31, further comprising external memory coupled to the bus and a write buffer for writing data to be written to external memory, said clock controller detecting processor stalls during external memory write cycles.</claim-text></claim>"}, {"num": 43, "parent": 42, "type": "dependent", "paragraph_markup": "<claim num=\"43\"><claim-text>43. The system as set forth in claim 42, wherein said clock controller;<claim-text>determining that a write buffer is full;</claim-text><claim-text>detecting that the external bus is busy with a bus cycle; and</claim-text><claim-text>detecting the issuance of a memory write cycle.</claim-text></claim-text></claim>"}, {"num": 44, "parent": 31, "type": "dependent", "paragraph_markup": "<claim num=\"44\"><claim-text>44. The system as set forth in claim 31, wherein said clock controller stops the CPU clock signal when the CPU enters a wait state and a coprocessor is confirmed not to be busy performing operations and a cache invalidation bus cycle is not in progress.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES66860153\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates to processors which consume the minimum amount of power. More particularly, the present invention relates to processors which shut down certain components of the processor during predetermined times of system operation.</p><p>2. Art Background</p><p>Computing devices today have become quite small in size. This has led to the popularity of portable computing devices, such as workstations, personal computers, including dedicated controllers and communication equipment. However, as the devices are portable, they require portable power devices to operate. Batteries, which are typically used, increase the weight of the portable device significantly. Therefore, it is desirable to minimize the size of the battery. This may be done a number of ways. One such way is to reduce the power consumption of the computing devices powered by the battery such that a smaller battery may be utilized.</p><h4>SUMMARY OF THE INVENTION</h4><p>The present invention provides a processor and processing system which minimizes power consumption by the processor. The processor detects the issuance of certain bus cycles or the execution of certain instructions which typically cause the processor to be idle for a period of time. Control circuitry detects the existence of the instruction and/or bus cycle and shuts down the clock driving certain processor components during the idle period. The control circuitry then detects the occurrence or upcoming occurrence of an event to which the processor responds and becomes active. At detection of this event, the clock signal input to these components is then restarted such that the processor can continue normal execution. Two clocks are provided to the processor. One clock remains on at all times. This clock drives the elements required to start and stop the second clock. The remainder of the components of the processor is controlled by the second clock which is turned on and off according to the instructions executed by the processor. It has been found that by shutting the clock down to all but the required components during the execution of certain bus cycles, significant power savings is realized.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>The objects, features and advantages of the present invention will become apparent to one skilled in the art from reading the following detailed description in which:</p><p>FIG. 1 is a block diagram illustration of a system which employs the power saving processor of the present invention.</p><p>FIG. 2 is a flow chart illustrating the process of the present invention.</p><p>FIGS. 3a-3d illustrate embodiments of the present invention.</p><p>FIGS. 4a and 4b are tables illustrating potential power savings employing the system of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>In the following description for purposes of explanation numerous details are set forth in order to provide a thorough understanding of the present invention. However, it will be apparent to one skilled in the art that these specific details are not required in order to practice the present invention. In other instances well known electrical structures and circuits are shown in block diagram form in order not to obscure the present invention unnecessarily.</p><p>Referring to FIG. 1, a typical processor system includes a central processing unit (CPU) 10, memory 20 and peripheral devices, such as I/O device 30, connected via a bus 40. The CPU may also have coupled to it a cache 50 for caching certain data to increase performance of the system. It has been realized that the execution of certain instructions, which subsequently are reflected as the issuance of certain bus cycles, occur which idle the CPU for a significant amount of time. Typically the CPU will continue to consume power while waiting for certain events to occur before processing is continued. For example, when a read to memory is performed, the CPU 10 will issue a bus cycle across the bus 40 to memory 20 to retrieve certain data. Once this bus cycle request is issued, the CPU 10 is idle until the reply including the data is sent back from the memory 20. Other cycles may be a I/O device read or write operation which similarly takes a significant amount of time during which the CPU 10 idles.</p><p>As power consumption has recently become an important issue to portable computing, it is critical that devices operate only when needed to minimize the amount of power consumed. Thus, a clock control circuit is introduced which monitors the operations of the CPU and shuts down the clock which drives components of the CPU during the portion of the execution of certain instructions during which the processor is idle.</p><p>An illustrative flowchart of the process is shown in FIG. 2. At step 300, an instruction execution or a bus cycle occurs. If the processor is to be idle during execution of the bus cycle, step 310, the clock is stopped to non-essential components 320 when the idle state is entered. It is preferred that the non-essential components are defined as those components which are not required to shut-down or restart the clock. Once the clock is stopped, step 320, the controller then monitors for the event which indicates that the processor is to exit the idle state and is to be restarted by restarting the clock, steps 330, 340. Once this event is detected, the clock is restarted 350 and normal processing continues. Thus, a method for reducing power consumption and apparatus is provided which does not have impact on performance and requires little modification to the processor.</p><p>FIG. 3a is a simplified block diagram of a microprocessor component such as the i486\u00ae microprocessor, manufactured by Intel Corporation, Santa Clara, Calif. (i486 is a registered trademark of Intel Corporation). In order that the processor may be stopped during execution of instructions, the processor should be static in nature such that the processor maintains its internal state when not operating. This characteristic is found in many processors, including the i486. Depending upon the configuration, the processor 100 may include a variety of components 110, 120, 130, 140, each of which is driven by a clock signal for its operation. In the present invention one dock signal 155, is input to the processor. A dock controller 170 is provided to generate two clock output clock signals CLK1 150, CLK2 160 and to control enabling and disabling of at least one of the clock output signals 150, 160. The output of the clock controller 170 provides the clock signal inputs to the various elements 110, 120, 130, 140.</p><p>It has been determined that a significant amount of time is spent by the CPU waiting for the return of data or a response from devices coupled with the CPU via the bus. For example, if an I/O read operation is to be executed, the CPU issues a bus cycle onto the bus 180 with command and address information regarding the I/O read operation. The CPU 100 enters an idle state, waiting for a response to be returned across the bus 180. To save on power while the CPU is in an idle state, the clock controller 170 determines when such commands are executed and stops the clock to the elements of the CPU.</p><p>In the present embodiment one clock input signal is provided 155 and one or two clock signals 150, 160 are output. The first clock CLK1 150 is turned off by the clock controller during predetermined periods to minimize power consumption and CLK2 160 is kept in an on state to drive those components which cannot be turned off during the idle state of the microprocessor. Thus, the clock controller 170 detects those instructions during which the processor 100 is idle or waiting for a response and turns off the clock CLK1 150 until such time that the CPU will begin execution. More particularly, the dock controller includes logic to detect the execution of certain commands or bus cycles, logic to stop the clock driving the selected components of the CPU 100, logic to detect when the CPU is to exit the idle state and logic to restart the clock so that the CPU again executes in a normal manner.</p><p>Furthermore, this mechanism can be extended to achieve power savings during memory write operations. In this embodiment, the mechanism detects internal stalls which occur during external memory write signals, typically when resources are unavailable. Thus, for example, in the i486 processor, an embodiment incorporating the processor dock is throttled during a memory write operation when the write buffer is full, the external bus is busy with a bus cycle and the instruction executing issues a memory write bus cycle (thereby causing the processor to stall). The clock would stop and be restarted when one or all of the conditions change.</p><p>In one embodiment, the clock controller 170 is located on the processor component. The input clock 155 is input to the component. The clock controller 170 is preferably driven by the input clock or CLK2 160 which remains on at all times. Those elements of the CPU which are used to stop and start the CLK1 150 are also maintained on at all times and therefore are driven by CLK2 160. Although different configurations may have different clock requirements, typically the remainder of the elements of the CPU 100 can be turned off during idle by stopping the clock input signal to those elements. As up to 90% of the power consumption of the CPU is attributed to those elements which can be turned off during idle, a substantial power savings is realized.</p><p>Although the present invention may be implemented in a variety of embodiments, it is preferred that it be implemented in a manner transparent to the system. In one embodiment, the clock controller 170 monitors the bus cycles issued to determined when predetermined bus cycles occur. These predetermined bus cycles indicate that the processor component 100 will be idled for a period of time exceeding the amount of time required to stop and restart the clocks signal input to the components. Thus, for example, the clock controller will detect I/O read cycles (single as well as string operations), I/O write cycles, non-cacheable memory data read cycles, the first memory data read of a cache line fill and processor specific cycles, such as halt and other special cycles. Preferably, the clock should not be stopped for the first cycle of a split cycle as the split cycle logic is still performing some operations. In addition, it is preferable that prior to stopping the clock, it is confirmed that the floating point unit is busy performing operations and a cache invalidation bus cycle is not in progess. Other bus cycles, depending upon the processor and system configuration, may be determined to be one during which the clock signal input is temporarily stopped.</p><p>Alternatively, as shown in FIG. 3b, the clock controller 270 may be located external to the processor component 200 and still control the clock input to the component 200 in the same manner described above by monitoring the bus cycles issued by the processor.</p><p>Referring back to FIG. 3a, in an alternative embodiment, the clock controller detects the execution of predetermined instructions to determine when to stop the clock signal input. Preferably this is performed by the microcode of the processor which monitors the instructions executed. The microcode issues a signal to the clock controller 270 at a predetermined point during execution of one of the predetermined commands to stop the clock signal input while the CPU is in an idle state. For example, immediately after detection of execution of a halt command, the clock signal input is stopped.</p><p>Preferably, the clock controller restarts the clock signal input and therefore the components of CPU prior to the event after which the CPU exits the idle state and continues normal processing. For example, if the CPU is idle during a memory read operation, it is preferred that the dock is restarted just prior to the data being available to the CPU on the bus. In one embodiment, the clock controller detects the event and immediately restarts the bus. However, latency may occur if the clock is not restarted fast enough. For example, data incoming on the bus takes one clock cycle to latch the data prior to the data being available to the CPU. In order to maintain no latency, the clock controller should detect the incoming data and restart the clock within the dock cycle. However, power savings benefits are still realized even if latency is introduced. Thus, the power saving feature may be provided as a switchable option such that a user requiring the power saving feature would incur an additional wait state during the execution of the predetermined instructions. Furthermore, specific instructions and bus cycles can be segregated into groups according to potential latency/no latency, such that clock throttling for specified groups can be selectively enabled and disabled.</p><p>As shown in FIG. 3c, the system may also be implemented in an integrated CPU core. In this embodiment the bus operations and local memory on the component are monitored to determined when to stop and restart the clock. The controller monitors the bus as well as signals to the local memory to determine those cycles in which the processor will be idle for some period of time. In this embodiment an internal ready signal may be utilized to detect when to restart the clock. The internal ready signal is detected during an earlier clock cycle such that sufficient time is provided to restart the clock.</p><p>In another embodiment, as illustrated in FIG. 3d, an external pin, referred to herein as a \"clock throttle pin\" 310 is provided. This pin is accessible by user hardware. If the user pulls the pin, for example, active, the clock signals to most of the CPU core are stopped. The user would subsequently deassert a signal on this pin before continuing normal operation. Preferably an internal mechanism is provided to disable the clock throttle pin based on certain conditions, for example a split cycle, during which it is not preferred to perform clock throttling.</p><p>In this embodiment, the clock mechanism is visible and controllable external to the CPU. Therefore, external chip sets which operate with the CPU or other external logic 315 is needed to control the clock throttling. Furthermore, this embodiment monitors the bus external to the CPU to detect stall conditions during which clock throttling can be performed. Although this mechanism does not monitor for split cycles or other conditions during which it is not desirable to stop the clock, this embodiment can be used to throttle clocks for large portions of other bus cycles, with long wait states which are not typically throttled by an external mechanism, with little or no loss of performance. For example, if access is made to a slow memory or other internal device, by monitoring externally, clock throttling can be extended for additional cycles beyond the external CPU core cycles.</p><p>The power savings is directly proportional to the bus utilization and bus cycle mix. Thus, for example, a system with a 50% bus utilization may have the dock stopped for about 15-25% of the time given an exemplary system in which all I/O cycles on the external bus are assumed to be 5 clock cycles in duration and all other types of cycles, for example DMA, are assumed to be 9 external bus clock cycles in duration. Thus, power savings as shown in FIG. 4a and 4b can be realized. FIG. 4a illustrates power savings for an external bus running at  1/4 of the frequency of the processor bus; FIG. 4b illustrates power savings realized for a system having an external bus operating at the same frequency as the processor bus. Therefore, if a system has a rate of clock throttle of approximately 20%, and assuming 50% power reduction due to clock throttle, an overall active power savings of 10-30% will be realized.</p><p>The invention has been described in conjunction with the preferred embodiment. It is evident that numerous alternatives, modifications, variations and uses will be apparent to those skilled in the art in light of the foregoing description. In particular, it is readily evident that the clock throttling mechanism described can be applied to a variety of components including CPUs and other processors. Furthermore, it is evident that the mechanism is extendible to a multiple processor environment or to a processor with multiple execution units. For example, the bus cycles related to the individual processors to detect stalls are monitored to control the clock inputs to the individual processors.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Sanjay", "last_name": "Jain", "name": ""}, {"first_name": "Deepak J.", "last_name": "Aatresh", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTEL CORPORATION"}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   1/32"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   1/32        20060101A I20051008RMUS"}], "national_classes": [{"primary": true, "label": "713322"}, {"primary": false, "label": "713323"}, {"primary": false, "label": "713321"}], "ecla_classes": [{"label": "G06F   9/30A8P"}, {"label": "Y02B60:12N"}, {"label": "G06F   1/32P5C"}, {"label": "G06F   1/32P5S"}, {"label": "Y02B60:12N2"}, {"label": "Y02B60:12D8"}, {"label": "G06F   1/32P"}, {"label": "G06F   9/38T"}, {"label": "G06F   9/38P2"}], "cpc_classes": [{"label": "G06F   1/3237"}, {"label": "G06F   9/3885"}, {"label": "Y02D  30/50"}, {"label": "G06F   9/30083"}, {"label": "G06F   1/3203"}, {"label": "G06F   1/3287"}, {"label": "G06F   1/3287"}, {"label": "G06F   9/30083"}, {"label": "G06F   9/3869"}, {"label": "G06F   9/3869"}, {"label": "G06F   1/3203"}, {"label": "Y02D  10/00"}, {"label": "Y02D  10/00"}, {"label": "G06F   9/3885"}, {"label": "Y02D  30/50"}, {"label": "G06F   1/3237"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1993-03-24", "application_date": "1993-03-24", "family_members": [{"ucid": "US-5586332-A", "titles": [{"lang": "EN", "text": "Power management for low power processors through the use of auto clock-throttling"}]}]}