{"patent_number": "US-6754791-B1", "publication_id": 73861932, "family_id": 22099704, "publication_date": "2004-06-22", "titles": [{"lang": "EN", "text": "Cache memory system and method for accessing a cache memory having a redundant array without displacing a cache line in a main array"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11698223\" source=\"national office\"><p>A system and method for accessing a cache memory having a redundant array without displacing a cache line in a main array are described.Redundant rows of a cache memory array are used as extra cache lines for the cache memory array. Operations can be performed on these extra cache lines without effecting previous cache line values which have been brought into the cache memory array. These extra cache lines thus provide for temporary cache storage without causing a cache line reloaded into the cache memory array. This selective access of memory without disturbing the current contents of the cache memory array increases system throughput by minimizing the number of times that a cache memory might have to be reloaded.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50683029\"><p>A system and method for accessing a cache memory having a redundant array without displacing a cache line in a main array are described.</p><p>Redundant rows of a cache memory array are used as extra cache lines for the cache memory array. Operations can be performed on these extra cache lines without effecting previous cache line values which have been brought into the cache memory array. These extra cache lines thus provide for temporary cache storage without causing a cache line reloaded into the cache memory array. This selective access of memory without disturbing the current contents of the cache memory array increases system throughput by minimizing the number of times that a cache memory might have to be reloaded.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6754791-B1-CLM-00001\" num=\"1\"><claim-text>1. An improved cache memory system, comprising:</claim-text><claim-text>a plurality of cache lines in a cache; </claim-text><claim-text>at least one redundant unmapped cache line in said cache; and </claim-text><claim-text>means for signaling said cache to access one of said plurality of cache lines or said at least one redundant unmapped cache line, wherein said at least one redundant unmapped cache line is used as a temporary cache location without displacing or overwriting any of said plurality of cache lines such that memory-access time is effectively and efficiently reduced. </claim-text></claim>"}, {"num": 2, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6754791-B1-CLM-00002\" num=\"2\"><claim-text>2. A cache memory having a main array and a redundant array, said redundant array comprising mapped and unmapped cache lines, comprising:</claim-text><claim-text>first access means for accessing said main array; </claim-text><claim-text>second access means for accessing said mapped cache lines; and </claim-text><claim-text>third access means for accessing said unmapped cache lines, wherein said unmapped cache lines are used as temporary cache locations without displacing or overwriting any contents within said main array such that memory-access time is effectively and efficiently reduced. </claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6754791-B1-CLM-00003\" num=\"3\"><claim-text>3. The system of <claim-ref idref=\"US-6754791-B1-CLM-00002\">claim 2</claim-ref> wherein said mapped cache lines are a logical overlay to said main array.</claim-text></claim>"}, {"num": 4, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6754791-B1-CLM-00004\" num=\"4\"><claim-text>4. The system of <claim-ref idref=\"US-6754791-B1-CLM-00002\">claim 2</claim-ref> wherein said unmapped cache line are a logical extension to said main array.</claim-text></claim>"}, {"num": 5, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6754791-B1-CLM-00005\" num=\"5\"><claim-text>5. A method for accessing a cache memory having a main array and a redundant array, said main array having at least one main cache line and said redundant array having at least one redundant unmapped cache line, comprising the steps of:</claim-text><claim-text>generating an address for a memory location of said main array; </claim-text><claim-text>accessing a cache line corresponding to said address; </claim-text><claim-text>generating a signal to access said redundant array; and </claim-text><claim-text>accessing a redundant unmapped cache line in said redundant array. </claim-text></claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6754791-B1-CLM-00006\" num=\"6\"><claim-text>6. A method for accessing a cache memory having a main array and a redundant array, said main array and said redundant array having a plurality of memory locations, comprising the steps of:</claim-text><claim-text>generating an address for a memory location of said main array; </claim-text><claim-text>reading or writing first data into at least one of said plurality of memory locations of said main array; </claim-text><claim-text>generating a signal to access said redundant array; and </claim-text><claim-text>reading or writing second data into said redundant array without displacing said first data. </claim-text></claim>"}, {"num": 7, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6754791-B1-CLM-00007\" num=\"7\"><claim-text>7. A method for accessing a cache memory having a main array and at least one redundant unmapped cache line, said main array having a plurality of memory locations, comprising the steps of:</claim-text><claim-text>generating a signal to access said at least one redundant unmapped cache line; and </claim-text><claim-text>accessing said at least one redundant unmapped cache line without altering contents of said plurality of memory locations. </claim-text></claim>"}, {"num": 8, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6754791-B1-CLM-00008\" num=\"8\"><claim-text>8. A method for accessing a cache memory having a main array and a redundant array, said main array having at least one main cache line and said redundant array having at least one redundant cache line, comprising the steps of:</claim-text><claim-text>generating a signal to access said redundant array; and </claim-text><claim-text>accessing a redundant cache line in said redundant array without displacing said at least one main cache line in said main array. </claim-text></claim>"}, {"num": 9, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6754791-B1-CLM-00009\" num=\"9\"><claim-text>9. A system for accessing a cache memory having a main array and a redundant array, said main array having at least one main cache line and said redundant array having at least one redundant cache line, comprising:</claim-text><claim-text>means for generating an address for a memory location of said main array; </claim-text><claim-text>means for accessing a cache line corresponding to said address; </claim-text><claim-text>means for generating a signal to access said redundant array; and </claim-text><claim-text>means for accessing a redundant cache line in said redundant array without displacing said at least one main cache line in said main array. </claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6754791-B1-CLM-00010\" num=\"10\"><claim-text>10. A system for accessing a cache memory having a main array and a redundant array, said main array and said redundant array having a plurality of memory locations, comprising:</claim-text><claim-text>means for generating an address for a memory location of said main array; </claim-text><claim-text>means for reading or writing first data into at least one of said memory locations of said main array; </claim-text><claim-text>means for generating a signal to access said redundant array; and </claim-text><claim-text>means for reading or writing second data into said redundant array without displacing said first data. </claim-text></claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6754791-B1-CLM-00011\" num=\"11\"><claim-text>11. A system for accessing a cache memory having a main array and at least one redundant unmapped cache line, said main array having a plurality of memory locations, comprising:</claim-text><claim-text>means for generating a signal to access said at least one redundant unmapped cache line; and </claim-text><claim-text>means for accessing said at least on redundant unmapped cache line without altering contents of said plurality of memory locations. </claim-text></claim>"}, {"num": 12, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6754791-B1-CLM-00012\" num=\"12\"><claim-text>12. A system for accessing a cache memory having a main array and a redundant array, said main array having at least one main cache line and said redundant array having at least one redundant cache line, comprising:</claim-text><claim-text>means for generating a signal to access said redundant array; and </claim-text><claim-text>means for accessing a redundant cache line in said redundant array without displacing said at least one main cache line in said main array. </claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6754791-B1-CLM-00013\" num=\"13\"><claim-text>13. A system for accessing a cache memory having a main array and a redundant unmapped array, said main array and said redundant array having a plurality of memory locations, comprising:</claim-text><claim-text>a central processing unit coupled to said cache memory; </claim-text><claim-text>a main memory coupled to said cache memory; </claim-text><claim-text>means for generating an address by said central processing unit for a memory location of said main memory; </claim-text><claim-text>means for reading or writing first data into said memory location of said main array; </claim-text><claim-text>means for generating a signal by said central processing unit to access said redundant unmapped array; and </claim-text><claim-text>means for reading or writing second data into said redundant unmapped array without displacing said first data.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54198555\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This is a continuation, of application Ser. No. 08/071,168, filed Jun. 1, 1993 now abandoned.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>TECHNICAL FIELD</h4><p>The present invention relates to data processing systems, and more particularly to memory caches used by such data processing systems.</p><h4>BACKGROUND OF THE INVENTION</h4><p>A cache is a small, fast memory that acts as a buffer between a device that uses a large amount of memory and a large, slower main memory. The cache's purpose is to reduce average memory-access time. Caches are effective because of two properties of software programs: spatial and temporal locality. Spatial locality asserts that because programs are generally composed of subroutines and procedures that execute sequentially, they often use data and instructions whose addresses are proximate. Temporal locality recognizes that since many programs contain loops and manipulate data arranged in lists and arrays, recently used information is more likely to be reused than older information.</p><p>Memory caches are used in a data processing system to improve system performance by maintaining instructions and/or data that are statistically likely to be used by a microprocessor or execution unit within such data processing system. Such likelihood of use is generally found to exist with instructions/data in close proximity to the currently executing instruction or currently accessed data. Referring to FIG. 1, high speed memory cache <b>11</b> is used to quickly provide such instructions or data to the microprocessor or CPU (execution unit) <b>9</b>, and thus to minimize delays that would be introduced if the processor were required to access slower main memory <b>13</b>. This slower main memory could be such things as dynamic RAM, a read only memory (ROM), an electrical, magnetic or optical disk or diskette, or any other type of volatile or non-volatile storage device known in the art.</p><p>The contents of a memory cache must be periodically replenished with instructions/data from main memory. The rate of data transfer between a cache and main memory can be greatly increased by using block data transfers to move information between them. Cache memory is typically organized into lines of data, with each line comprising a plurality of bytes or words of data. A line is used so that groups of bytes/words are transferred to/from cache instead of a single byte/word. For example, each cache line could have 32, 64 or 128 bytes of data. With a 32 byte cache line, 32 bytes can be fetched using a single block data transfer from the main memory each time a cache miss occurs.</p><p>A cache miss occurs whenever the cache does not contain an instruction or data needed by the CPU. When a cache miss occurs, the present cache line is reloaded from the slower memory/storage device with the requested value and n\u22121 bytes/words of instructions/data that immediately follow such requested value, where n is the size of the cache line.</p><p>However, at times it would be advantageous to fetch a line from memory for certain load/store operations without displacing or overwriting a line presently in the cache. This requirement for non-displacement could occur, for example, when performing matrix operations on data contained in a cache. If a cache miss occurs when accessing non-matrix data, it would be advantageous to not disturb the existing matrix data while accessing this non-matrix data value. This requirement for non-displacement could also occur if it is known that the line to be loaded may not be used again for a long time (e.g. updating a page frame table), or if only one word needs to be read from memory infrequently. Presently known systems do not allow for selective memory access which can preempt a cache line reload.</p><h4>SUMMARY OF THE INVENTION</h4><p>It is therefore an object of the present invention to provide an improved data processing system.</p><p>It is a further object of the present invention to provide for improved performance in a data processing system.</p><p>It is yet a further object of the present invention to provide an improved cache in a data processing system.</p><p>It is still a further object of the present invention to minimize the number of cache line reloads required in a data processing system.</p><p>It is yet another object of the present invention to selectively access memory while preempting a cache line reload.</p><p>An additional line is provided within the data cache by using one of the redundant rows of the storage array. An input signal for the storage array indicates when this additional line is accessed. All operations which can be performed on the other rows of a cache array can also be performed for this additional line.</p><p>If array set associativity is considered, then more than one line can be placed into a row. For example, with 4-way set associativity a total of four additional lines can be brought into the additional row. Using such an array redundant row to provide the extra line of cache line is superior to traditional methods of expanding a cache to include more lines. These traditional methods required the addition of registers, multiplexors and control logic that correspond to the additional cache line to be added. By using an array redundant row as an additional cache line, the amount of physical space taken, and resulting wiring congestion, is minimized.</p><p>A one-way set associative array will be described-herein for ease in understanding, but there is nothing to preclude extending it to M-way and thus allowing for more \u201cadditional lines\u201d.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 shows a data processing cache and control system</p><p>FIG. 2 shows the overall array block and control interfaces of a cache.</p><p>FIG. 3 shows the array control logic of the array block for one additional redundant unmapped row.</p><p>FIG. 4 shows the array control logic of the array block for two additional redundant unmapped rows.</p><p>FIG. 5 depicts an array row having plural lines when set associativity is used.</p><p>FIG. 6 shows a 1-way set associative cache organization.</p><p>FIG. 7 shows an M-way set associative cache organization.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</h4><p>The data cache main array described herein contains 8 rows. Each row contains a 256-byte line of data. An additional line(s) is provided from the redundant row section of the cache chip and operations performed on this additional line(s) without affection the contents of the main array rows. Although the term row is used, it is not meant to be limited to any particular physical orientation. Memory organized in columns, ;diagonals, or any other type of physical orientation could similarly use the techniques described herein. Row is merely meant to mean a plurality of memory locations that can be accessed or operated upon using a single operation such as read, write, flush, etc.</p><p>FIG. 2 depicts a memory cache <b>11</b> of the preferred embodiment. The main array <b>10</b> contains three address lines <b>12</b> which can address a total of eight rows. The redundant rows <b>14</b> are typically used in the event that one of the main array's rows are faulty. If a failure is determined in the main array, then one of the spare/redundant rows <b>14</b> is used to bypass the faulty row in the main array <b>10</b> during the manufacturing process. The rows containing the bad bits are disabled, typically by blowing fuse links, and the redundant rows are enabled to take their place. To be able to substitute a spare/redundant row for one in the main array, the spare/redundant row must have the same logical appearance as the row it replaces. Thus, the spare/redundant row <b>14</b> is logically overlayed when mapping the spare/redundant row to the logical location of the main array's faulty row or column. This redundant replacement is commonly known in industry, as exemplified by U.S. Pat. No. 4,630,241 and pending U.S. Pat. application Ser. No. 731,487, filed Jul. 17, 1991 now U.S. Pat. No. 5,297,094, entitled \u201cIntegrated Circuit Memory Device with Redundant Rows\u201d. (and having a European counterpart patent application EP 523,996-A1), both hereby incorporated by reference.</p><p>Array control logic <b>18</b> (more fully described below with reference to FIG. 3) is implemented so that the redundant row <b>14</b> has the same logical function as any other row within the main array <b>10</b>. Since the redundant row <b>14</b> has the same logical appearance as a main array row, it can be made to appear as an \u201cadditional row\u201d to the main array. Thus, redundant rows which have not been mapped as substitutions for faulty rows can be used as additional rows/cache lines, thereby providing a logical extension to the main array. These redundant unmapped cache lines <b>14</b> can then be used as temporary cache locations without displacing or overwriting the cache's main array contents.</p><p>An \u201cadditional row\u201d input signal is provided at <b>16</b>. As will be later described, this signal <b>16</b> is generated by the cache controller and set depending upon whether the requested line is in the main array <b>10</b> or outside the main array and in the redundant row area <b>14</b> (bypassing the main array). This signal can also be thought of as the \u201chigh-order\u201d address bit for the array. If the signal is set to a logical \u201c0\u201d, then the access is to the main array; whereas, if the signal is set to a logical \u201c1\u201d the \u201cadditional row\u201d is accessed.</p><p>FIG. 3 depicts the array control logic <b>18</b>, comprising array address decoder <b>20</b> and the array interface <b>22</b>. The array address decoder is extended to handle the additional row signal <b>16</b>. This extension is accomplished by logically AND-ing at <b>24</b> the outputs of the array address decoder <b>20</b> with the additional row signal <b>16</b>, which is generated by the cache controller. This additional row signal is inverted at <b>26</b> prior to the AND operation at <b>24</b>. The outputs of the AND operation, shown at <b>23</b>, <b>25</b> and <b>27</b>, are signals used to access/enable the respective rows (<b>0</b>-<b>7</b>) in the main array <b>10</b>. The additional row signal <b>16</b> is used to access/enable the additional unmapped row in the redundant rows <b>14</b> portion of the cache <b>11</b>.</p><p>The cache controller <b>18</b> must be told when it is to place a line in the \u201cadditional row\u201d of the redundant row area. This is accomplished by allocating a bit within all CPU instructions which can cause a reload from memory (i.e. load, store, zero line) to the cache. For example a 10 bit instruction may look like that shown in Table 1, where bit <b>5</b> is used for accessing the additional row.</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"offset\" colwidth=\"21pt\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"56pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"49pt\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"35pt\"></colspec><colspec align=\"center\" colname=\"4\" colwidth=\"56pt\"></colspec><thead><row><entry></entry><entry nameend=\"4\" namest=\"offset\" rowsep=\"1\">TABLE 1</entry></row><row><entry></entry><entry align=\"center\" nameend=\"4\" namest=\"offset\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry><entry>Load instruction:</entry><entry>LD</entry><entry>Addit.row</entry><entry>Address</entry></row><row><entry></entry><entry></entry><entry>1011</entry><entry>1</entry><entry>11110</entry></row><row><entry></entry><entry align=\"center\" nameend=\"4\" namest=\"offset\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>A programmer writing an application program (or an intelligent compiler or operating system which is managing this selective cache) sets this bit to \u201c1\u201d to indicate that the line coming from memory should be placed into the additional row. Otherwise, if the bit is \u201c0\u201d the line is to be placed in the main array <b>10</b>. CPU <b>9</b> (of FIG. 1) interprets this bit in the opcode, and signals the control section of the cache accordingly, as describe above.</p><p>This bit's value is then stored along with the line's address in the tag table as shown below in Table 2.</p><p><tables id=\"TABLE-US-00002\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 2</entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>TAG TABLE ENTRY</entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"offset\" colwidth=\"35pt\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"49pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"133pt\"></colspec><tbody valign=\"top\"><row><entry></entry><entry>Additional row</entry><entry>line's memory address</entry></row><row><entry></entry><entry>0 or 1</entry><entry>xxxxx</entry></row><row><entry></entry><entry align=\"center\" nameend=\"2\" namest=\"offset\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>Whenever a \u201ccache hit\u201d occurs for this line's address, the \u201cadditional row\u201d bit previously stored in the tag table is sent from the controller along with the corresponding address bits to the cache. If the \u201ccache line\u201d needs to be stored back to memory, the same cache addressing scheme is used (i.e. the additional row bit is sent with the address to indicate which line to access). The above described scenario is applicable whether an execution unit store/load is occurring, or a cache reload/storeback is occurring, as no extra provisions are required to handle the \u201cAdditional Row\u201d versus the Main Array operations.</p><p>Note that in the above scenario the programmer only has to identify initially if the line is to be placed in the additional row and doesn't require any further monitoring or actions on his part.</p><p>If more \u201cadditional rows\u201d are designed into the array then nothing precludes their being accessed by the controller. In order to accommodate a second \u201cadditional row\u201d the following changes are made.</p><p>A \u201c2nd additional line\u201d address bit is allocated within the instruction, in a manner similar to that described above with reference to Table 1. The tag table (of Table 2) is widened by 1 bit to accommodate this new line. The use of an \u201cAdditional Row Signal\u201d to indicate when to use the redundant row area is still maintained, however. If the \u201cAdditional Row Signal\u201d is active or enabled, the access will still be to the redundant rows. If the \u201c2nd additional row\u201d signal is a logical \u201c0\u201d, the additional row 0 is accessed, while if the signal is a logical \u201c1\u201d, the additional row <b>1</b> is accessed.</p><p>The additional row signal <b>16</b> of FIG. 3 is expanded to that as shown in FIG. 4. A \u201c2nd additional row\u201d signal is provided at <b>30</b>. This signal <b>30</b> is inverted at <b>32</b>, and then logically AND-ed at <b>34</b> with the additional row signal <b>16</b>. The output of the AND <b>34</b> is a signal <b>38</b> used to access/enable additional unmapped row <b>0</b> of rendundant rows <b>14</b>. In a similar manner, the \u201c2nd additional row\u201d signal <b>30</b> is logically AND-ed at <b>36</b> with the additional row signal <b>16</b>. The output of the AND <b>36</b> is a signal <b>40</b> used to access/enable additional unmapped row <b>1</b> of redundant rows <b>14</b>.</p><p>The number of additional rows can be expanded further, but in this case it is preferable to start encoding the 2nd, 3rd, . . . etc. address bits and their corresponding signals, using traditional methods such as using a 2-to-4 way or 3-to-8 way encoder, to reduce the logical overhead. This may be accomplished using traditional techniques known in the art.</p><p>For an M-way set associative array, a row would contain M lines, as shown at <b>42</b> in FIG. <b>5</b>. Therefore, more than one \u201cadditional\u201d line can be brought into the redundant row if set associativity is used. Although set associativity is generally known in the art, a simple example will show how the present invention co-exists with set associativity.</p><p>Referring to FIG. 6, an array <b>44</b> is made up of Y rows at <b>46</b> with each row containing X bytes at <b>48</b>. In order to access a given byte, a row address (<b>1</b>-Y) and a byte address (<b>1</b>-X) must be specified. If a line is defined to be an entire row, then its length will be X bytes. For this case, a line and row would have the same meaning.</p><p>If set associativity is used, than the array <b>44</b> is divided into additional groupings based upon how many sets S are chosen, as shown in FIG. <b>7</b>. The width of a set is X/S bytes (where X is the total byte length for a row), and this value becomes the new line length. Therefore, an array row with S sets will contain S lines. In order to access a given byte, a row address, set number, and a byte address within the set must be specified by the cache controller. Since a redundant row has the same characteristics (i.e. width and addressing) as a row in the main array, the redundant row has the same set associativity scheme as well. Therefore, using the redundant row to store additional line(s) will similarly extend to set associativity, and the redundant unmapped row is able to store or otherwise maintain S lines using the same techniques as described above for 1-way set associativity.</p><p>While the invention has been shown and described with reference to particular embodiments thereof, it will be understood by those skilled in the art that the foregoing and other changes in form and detail may be made therein without departing from the spirit and scope of the invention.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "George Maria", "last_name": "Braceras", "name": ""}, {"first_name": "Lawrence Carey", "last_name": "Howell, Jr.", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTERNATIONAL BUSINESS MACHINES CORPORATION"}], "ipc_classes": [{"primary": true, "label": "G06F  12/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMJP"}, {"label": "G06F   9/38        20060101A I20060722RMEP"}], "national_classes": [{"primary": true, "label": "711159"}, {"primary": false, "label": "711118"}, {"primary": false, "label": "711E12018"}, {"primary": false, "label": "712E09047"}, {"primary": false, "label": "711E12017"}, {"primary": false, "label": "711133"}], "ecla_classes": [{"label": "G06F   9/38D2"}, {"label": "G06F  12/08B10"}, {"label": "G06F  12/08B"}], "cpc_classes": [{"label": "G06F   9/383"}, {"label": "G06F  12/0864"}, {"label": "G06F  12/0864"}, {"label": "G06F  12/0802"}, {"label": "G06F   9/383"}, {"label": "G06F  12/0802"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1993-06-01", "application_date": "1996-02-09", "family_members": [{"ucid": "JP-H06348596-A", "titles": [{"lang": "JA", "text": "\u30ad\u30e3\u30c3\u30b7\u30e5\u30fb\u30e1\u30e2\u30ea\u30fb\u30b7\u30b9\u30c6\u30e0\u4e26\u3073\u306b\u30ad\u30e3\u30c3\u30b7\u30e5\u30fb\u30e1\u30e2\u30ea\u30fb\u30a2\u30af\u30bb\u30b9\u65b9\u6cd5\u53ca\u3073\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "CACHE MEMORY SYSTEM AND METHOD AND SYSTEM FOR CACHE MEMORY ACCESS"}]}, {"ucid": "US-6754791-B1", "titles": [{"lang": "EN", "text": "Cache memory system and method for accessing a cache memory having a redundant array without displacing a cache line in a main array"}]}, {"ucid": "JP-3181001-B2", "titles": [{"lang": "JA", "text": "\u30ad\u30e3\u30c3\u30b7\u30e5\u30fb\u30e1\u30e2\u30ea\u30fb\u30b7\u30b9\u30c6\u30e0\u4e26\u3073\u306b\u30ad\u30e3\u30c3\u30b7\u30e5\u30fb\u30e1\u30e2\u30ea\u30fb\u30a2\u30af\u30bb\u30b9\u65b9\u6cd5\u53ca\u3073\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "Cache memory system and cache memory access method and system"}]}]}