{"patent_number": "US-7051329-B1", "publication_id": 74682192, "family_id": 23880128, "publication_date": "2006-05-23", "titles": [{"lang": "EN", "text": "Method and apparatus for managing resources in a multithreaded processor"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50979946\"><p num=\"p-0001\">The present invention provides a method and apparatus for managing resources in a multithreaded processor. In one embodiment, a resource is partitioned into a number of portions based upon a number of threads being executed concurrently. Resource allocation for each thread is performed in its respective portion of the resource.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00001\" num=\"00001\">\n<claim-text>1. A processor comprising:\n<claim-text>an instruction delivery engine to store and fetch instructions to be executed by the processor from a plurality of threads based upon a current processing mode; and </claim-text>\n<claim-text>an allocator to receive instructions from the instruction delivery engine and to perform allocation in a processor resource required for the execution of the instructions based upon the current processing mode, wherein the allocator, \n<claim-text>if the current processing mode is single threading, \n<claim-text>assigns all of the processor resource to one of the plurality of threads that is active, allocates an amount of entries for the instructions from the one of the plurality of threads in the processor resource if the processor resource has sufficient available entries, and </claim-text>\n<claim-text>activates at least one stall signal if the processor resource does not have sufficient available entries; and, </claim-text>\n</claim-text>\n<claim-text>if the current processing mode is multithreading, \n<claim-text>assigns a portion of the processor resource, to each of the plurality of threads running concurrently, </claim-text>\n<claim-text>allocates an amount of entries for the instructions from each respective thread in a respective portion of the processor resource if the respective portion has sufficient available entries, and </claim-text>\n<claim-text>activates at least one stall signal if the respective portion does not have sufficient available entries. </claim-text>\n</claim-text>\n</claim-text>\n</claim-text>\n</claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00002\" num=\"00002\">\n<claim-text>2. The processor of <claim-ref idref=\"CLM-00001\">claim 1</claim-ref> wherein the instruction delivery engine uses the at least one stall signal to perform its corresponding function.</claim-text>\n</claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00003\" num=\"00003\">\n<claim-text>3. The processor of <claim-ref idref=\"CLM-00002\">claim 2</claim-ref> wherein the instruction delivery engine re-fetches stalled instructions in the respective thread to the allocator if the at least one stall signal is activated.</claim-text>\n</claim>"}, {"num": 4, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00004\" num=\"00004\">\n<claim-text>4. The processor of <claim-ref idref=\"CLM-00002\">claim 2</claim-ref> wherein the instruction delivery engine fetches a subsequent instruction from another thread to the allocator if the at least one stall signal for the respective thread is activated and said another thread is not stalled.</claim-text>\n</claim>"}, {"num": 5, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00005\" num=\"00005\">\n<claim-text>5. The processor of <claim-ref idref=\"CLM-00002\">claim 2</claim-ref> wherein the instruction delivery engine fetches an invalid instruction to the allocator if the stall signal for the respective thread is activated.</claim-text>\n</claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00006\" num=\"00006\">\n<claim-text>6. A method for allocating processor resources by a processor, the method comprising:\n<claim-text>fetching instructions to be executed by the processor from one or more threads based upon a current Processing mode; and, </claim-text>\n<claim-text>performing allocation in a processor resource required for the execution of the instructions based upon the current processing mode, wherein performing allocation includes, \n<claim-text>if the current processing mode is single threading, \n<claim-text>assigning all of the processor resource to one of the plurality of threads that is active, </claim-text>\n<claim-text>allocating an amount of entries for the instructions from the one of the plurality of threads in the processor resource if the processor resource has sufficient available entries, and </claim-text>\n<claim-text>activating at least one stall signal if the processor resource does not have sufficient available entries; and, </claim-text>\n</claim-text>\n<claim-text>if the current processing mode is multithreading, \n<claim-text>assigning a portion of the processor resource to each of the plurality of threads running concurrently, </claim-text>\n<claim-text>allocating an amount of entries for the instructions from each respective thread in a respective portion of the processor resource if the respective portion has sufficient available entries, and </claim-text>\n<claim-text>activating at least one stall signal if the respective portion does not have sufficient available entries. </claim-text>\n</claim-text>\n</claim-text>\n</claim-text>\n</claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00007\" num=\"00007\">\n<claim-text>7. The method of <claim-ref idref=\"CLM-00006\">claim 6</claim-ref> further comprising using the at least one stall signal to perform corresponding functions by the instruction delivery engine.</claim-text>\n</claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00008\" num=\"00008\">\n<claim-text>8. The method of <claim-ref idref=\"CLM-00007\">claim 7</claim-ref> further comprising re-fetching stalled instructions in the respective thread to the allocator if the at least one stall signal is activated.</claim-text>\n</claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00009\" num=\"00009\">\n<claim-text>9. The method of <claim-ref idref=\"CLM-00007\">claim 7</claim-ref> further comprising fetching a subsequent instruction from another thread to the allocator if the at least one stall signal for the respective thread is activated and said another thread is not stalled.</claim-text>\n</claim>"}, {"num": 10, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00010\" num=\"00010\">\n<claim-text>10. The method of <claim-ref idref=\"CLM-00007\">claim 7</claim-ref> further comprising fetching an invalid instruction to the allocator if the stall signal for the respective thread is activated.</claim-text>\n</claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00011\" num=\"00011\">\n<claim-text>11. A processor comprising:\n<claim-text>means for fetching instructions to be executed by the processor from one or more threads based upon a current processing mode; </claim-text>\n<claim-text>means for performing allocation in a processor resource required for the execution of the instructions based upon the current processing mode; </claim-text>\n<claim-text>means that are operative if the current processing mode is single threading for \n<claim-text>assigning all of the processor resource to one of the plurality of threads that is active, </claim-text>\n<claim-text>allocating an amount of entries for the instructions from the one of the plurality of threads in the processor resource if the processor resource has sufficient available entries, and </claim-text>\n<claim-text>activating at least one stall signal if the processor resource does not have sufficient available entries; and, </claim-text>\n</claim-text>\n<claim-text>means that are operative if the current processing mode is multithreading for \n<claim-text>assigning a portion of the processor resource to each of the plurality of threads running concurrently, </claim-text>\n<claim-text>allocating an amount of entries for the instructions from each respective thread in a respective portion of the processor resource if the respective portion has sufficient available entries, and </claim-text>\n<claim-text>activating at least one stall signal if the respective portion does not have sufficient available entries. </claim-text>\n</claim-text>\n</claim-text>\n</claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00012\" num=\"00012\">\n<claim-text>12. The processor of <claim-ref idref=\"CLM-00011\">claim 11</claim-ref> further comprising means for using the at least one stall signal to perform corresponding functions by the instruction delivery engine.</claim-text>\n</claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00013\" num=\"00013\">\n<claim-text>13. The processor of <claim-ref idref=\"CLM-00012\">claim 12</claim-ref> further comprising means for re-fetching stalled instructions in the respective thread to the allocator if the at least one stall signal is activated.</claim-text>\n</claim>"}, {"num": 14, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00014\" num=\"00014\">\n<claim-text>14. The processor of <claim-ref idref=\"CLM-00012\">claim 12</claim-ref> further comprising means for fetching a subsequent instruction from another thread to the allocator if the at least one stall signal for the respective thread is activated and said another thread is not stalled.</claim-text>\n</claim>"}, {"num": 15, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00015\" num=\"00015\">\n<claim-text>15. The processor of <claim-ref idref=\"CLM-00012\">claim 12</claim-ref> further comprising means for fetching an invalid instruction to the allocator if the stall signal for the respective thread is activated.</claim-text>\n</claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES16039885\">\n<?RELAPP description=\"Other Patent Relations\" end=\"lead\"?>\n<p num=\"p-0002\">This application is a continuation-in-part of application Ser. No. 09/458,544, filed Dec. 9, 1999, now U.S. Pat. No. 6,496,925.</p>\n<?RELAPP description=\"Other Patent Relations\" end=\"tail\"?>\n<?BRFSUM description=\"Brief Summary\" end=\"lead\"?>\n<h4>FIELD OF THE INVENTION</h4>\n<p num=\"p-0003\">The present invention relates generally to the field of multithreaded processing. More specifically, the present invention relates to a method and apparatus for managing resources in a multithreaded processor.</p>\n<h4>BACKGROUND OF THE INVENTION</h4>\n<p num=\"p-0004\">Various multithreaded processor designs have been considered in recent times to further improve the performance of processors, especially to provide for a more effective utilization of various processor resources. By executing multiple threads in parallel, the various processor resources are more fully utilized which in turn enhances the overall performance of the processor. For example, if some of the processor resources are idle due to a stall condition or other delay associated with the execution of a particular thread, these resources can be utilized to process another thread. A stall condition or other delay in the processing of a particular thread may happen due to a number of events that can occur in the processor pipeline including, for instance, a cache miss or a branch misprediction. Consequently, without multithreading capabilities, various available resources within the processor would have been idle due to a long-latency operation, for example, a memory access operation to retrieve the necessary data from main memory, that is needed to resolve the cache miss condition.</p>\n<p num=\"p-0005\">Furthermore, multithreaded programs and applications have become more common due to the support provided for multithreading programming by a number of popular operating systems such as the Windows NT\u00ae and UNIX operating systems. Multithreaded applications are particularly attractive in the area of multimedia processing.</p>\n<p num=\"p-0006\">Multithreaded processors may generally be classified as fine or coarse grained designs, based upon the particular thread interleaving or switching scheme employed within the respective processor. In general, fine grained multithreaded designs support multiple active threads within a processor and typically interleave two different threads on a cycle-by-cycle basis. Coarse grained multithreaded designs, on the other hand, typically interleave the instructions of different threads on the occurrence of some long-latency event, such as a cache miss. A coarse multithreaded design is discussed in Eickmayer, R., Johnson, R. et al. \u201cEvaluation of Multithreaded Uniprocessors for Commercial Application Environments\u201d, <i>The </i>23<sup>rd </sup><i>Annual International Symposium on Computer Architecture</i>, pp. 203-212, May 1996. The distinctions between fine and coarse designs are further discussed in Laudon, J., Gupta, A. \u201cArchitectural and Implementation Tradeoffs in the Design of Multiple-Context Processors\u201d, <i>Multithreaded Computer Architectures: A Summary of the State of the Art</i>, edited by R. A. lannuci et al., pp. 167-200, Kluwer Academic Publishers, Norwell, Mass., 1994.</p>\n<p num=\"p-0007\">While multithreaded designs based on interleaved schemes are generally advantageous over single threaded designs, they still have their own limitations and shortcomings. In the fine grained multithreaded designs which interleaves two different threads on a cycle-by-cycle basis, there are limitations on the applications due to the fact that each thread cannot make progress in every cycle. A thread is limited to a single instruction in the pipeline to eliminate the possibility of pipeline dependencies. To tolerate memory latency, a thread is prevented from issuing its next instruction until the memory operation is completed. However, limiting a thread to a single instruction in the pipeline causes some constraints. First, a large number of threads would be needed to fully utilize the processor. Second, the performance of a single thread is poor because a thread could at best issue a new instruction every cycle. While coarse grained multithreaded designs have some advantages over the fine multithreaded designs, they also have their shortcomings. First, the cost of thread switching is high because the decision to switch is made late in the pipeline which can cause partially executed instructions in the pipeline from the switching thread to be squashed. Second, because of the high cost of thread switching, multiple threads cannot be used to tolerate short latencies.</p>\n<h4>SUMMARY OF THE INVENTION</h4>\n<p num=\"p-0008\">The present invention provides a method and apparatus for managing resources in a multithreaded processor. In one embodiment, a resource is partitioned into a number of portions based upon a number of threads being executed concurrently. Resource allocation for each thread is performed in its respective portion of the resource. The partitioning is dynamic and changes as the number of active threads changes. If only one thread is active, then all of the resource is devoted to that thread. If all threads are active, then the resource is fully partitioned.</p>\n<?BRFSUM description=\"Brief Summary\" end=\"tail\"?>\n<?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?>\n<description-of-drawings>\n<h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4>\n<p num=\"p-0009\">The features and advantages of the present invention will be more fully understood by reference to the accompanying drawings, in which:</p>\n<p num=\"p-0010\"><figref idrefs=\"DRAWINGS\">FIG. 1</figref> is a block diagram of one embodiment of a processor pipeline;</p>\n<p num=\"p-0011\"><figref idrefs=\"DRAWINGS\">FIG. 2</figref> shows a block diagram of one embodiment of a processor architecture in which the teachings of present invention are implemented;</p>\n<p num=\"p-0012\"><figref idrefs=\"DRAWINGS\">FIG. 3</figref> shows a block diagram of one embodiment of a processor unit that implements the teachings of the present invention;</p>\n<p num=\"p-0013\"><figref idrefs=\"DRAWINGS\">FIGS. 4</figref><i>a </i>illustrates a structure of one embodiment of a circular queue in a single threading mode;</p>\n<p num=\"p-0014\"><figref idrefs=\"DRAWINGS\">FIG. 4</figref><i>b </i>illustrates a structure of one embodiment of a circular queue in a multithreading mode;</p>\n<p num=\"p-0015\"><figref idrefs=\"DRAWINGS\">FIG. 5</figref> is a high level flow diagram of one embodiment of a method for managing resources in a multithreaded processor;</p>\n<p num=\"p-0016\"><figref idrefs=\"DRAWINGS\">FIG. 6</figref> shows a high level flow chart of one embodiment of a method for performing resource allocation in a multithreaded processor;</p>\n<p num=\"p-0017\"><figref idrefs=\"DRAWINGS\">FIG. 7</figref> is a flow diagram of one embodiment of a method for performing resource allocation between two threads in a multithreaded processor;</p>\n<p num=\"p-0018\"><figref idrefs=\"DRAWINGS\">FIG. 8</figref> is a flow chart of another embodiment of a method for performing resource allocation between two threads in a multithreaded processor;</p>\n<p num=\"p-0019\"><figref idrefs=\"DRAWINGS\">FIG. 9</figref> is a flow chart of another embodiment of a method for performing resource allocation between two threads in a multithreaded processor;</p>\n<p num=\"p-0020\"><figref idrefs=\"DRAWINGS\">FIG. 10</figref> illustrates a high level flow chart of one embodiment of a method for performing resource allocation in a multithreaded processor running in a single threading mode;</p>\n<p num=\"p-0021\"><figref idrefs=\"DRAWINGS\">FIG. 11</figref> is a flow diagram of one embodiment of a method for performing resource allocation for two threads in a parallel structure;</p>\n<p num=\"p-0022\"><figref idrefs=\"DRAWINGS\">FIG. 12</figref> is a flow diagram of one embodiment of a method for performing resource allocation for two threads in a multiplexing manner;</p>\n<p num=\"p-0023\"><figref idrefs=\"DRAWINGS\">FIG. 13</figref> illustrates a flow diagram of one embodiment of a method for performing stall computation for two threads in parallel and resource allocation in multiplexed manner;</p>\n<p num=\"p-0024\"><figref idrefs=\"DRAWINGS\">FIG. 14</figref> is a detailed flow diagram for performing resource allocation for one of the two threads;</p>\n<p num=\"p-0025\"><figref idrefs=\"DRAWINGS\">FIG. 15</figref> is a detailed flow diagram for performing resource allocation for the other of the two threads;</p>\n<p num=\"p-0026\"><figref idrefs=\"DRAWINGS\">FIG. 16</figref> is a block diagram of one embodiment of an apparatus for performing stall computation and generating a stall signal;</p>\n<p num=\"p-0027\"><figref idrefs=\"DRAWINGS\">FIG. 17</figref> is a block diagram of another embodiment of an apparatus for updating the value of a stall pointer; and</p>\n<p num=\"p-0028\"><figref idrefs=\"DRAWINGS\">FIG. 18</figref> is a block diagram of one embodiment of an apparatus for updating an allocation pointer.</p>\n</description-of-drawings>\n<?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?>\n<?DETDESC description=\"Detailed Description\" end=\"lead\"?>\n<h4>DETAILED DESCRIPTION</h4>\n<p num=\"p-0029\">In the following detailed description numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it will be appreciated by one skilled in the art that the present invention may be practiced without these specific details.</p>\n<p num=\"p-0030\">In the discussion below, the teachings of the present invention are utilized to implement a method and an apparatus for managing various processor resources used for the execution of multiple threads in a multithreaded processor. The various resources are partitioned according to a partitioning scheme based upon the number of threads that are executed concurrently. The partitioning is dynamic and changes as the number of active threads changes. If only one thread is active, then all of the resources are devoted to that thread. If all threads are active, then the resources are fully partitioned. For illustrative and explanation purposes only, the present invention is described with respect to a switching scheme between a single threading environment and a multithreading environment in which two threads are executed concurrently. However, the teachings of the present invention should not be limited to two threads and should be applicable to any multithreading environment in which more than two threads are executed concurrently. The teachings of the present invention are equally applicable to any switching scheme between an M-threaded environment to an N-threaded environment where M can be greater or less than N (e.g., switching from a 4-threaded environment to a 2-threaded environment, switching from a 2-threaded environment to a 5-threaded environment, etc.). In one embodiment, when two threads are executed in a multithreading mode, each resource is partitioned into two portions. One of the two portions is reserved for the execution of one thread and the other portion is reserved for the execution of the other thread. If there are insufficient resources to accommodate the execution of instructions within one particular thread, then a stall signal is generated to stall further feeding of instructions from that particular thread down the processor pipeline until enough resources become available. The teachings of the present invention are applicable to any multithreaded processor that is designed to process multiple threads (e.g., two or more threads) concurrently. However, the teachings of the present invention are not limited to multithreaded processors and can be applied to any processor and/or machine in which resources are shared between tasks or processes.</p>\n<p num=\"p-0031\"><figref idrefs=\"DRAWINGS\">FIG. 1</figref> is a block diagram of one embodiment of a processor pipeline within which the present invention may be implemented. For the purposes of the present specification, the term \u201cprocessor\u201d refers to any machine that is capable of executing a sequence of instructions and shall be taken to include, but not be limited to, general purpose microprocessors, special purpose microprocessors, graphics controllers, audio processors, video processors, multi-media controllers and microcontrollers. The processor pipeline <b>100</b> includes various processing stages beginning with a fetch stage <b>110</b>. At this stage, instructions are retrieved and fed into the pipeline <b>100</b>. For example, a macroinstruction may be retrieved from a cache memory that is integral within the processor or closely associated therewith, or may be retrieved from an external memory unit via a system bus. The instructions retrieved at the fetch stage <b>110</b> are then delivered to a decode stage <b>120</b> where the instructions or macroinstructions are decoded into microinstructions or micro-operations for execution by the processor. At an allocate stage <b>130</b>, processor resources necessary for the execution of the microinstructions are allocated. The next stage in the pipeline is a rename stage <b>140</b> where references to external or logical registers are converted into internal or physical register references to eliminate dependencies caused by register reuse. At a schedule/dispatch stage <b>150</b>, each microinstruction is scheduled and dispatched to an execution unit. The microinstructions are then executed at an execute stage <b>160</b>. After execution, the microinstructions are then retired at a retire stage <b>170</b>.</p>\n<p num=\"p-0032\">In one embodiment, the various stages described above can be organized into three phases. The first phase can be referred to as an in-order front end including the fetch stage <b>110</b>, decode stage <b>120</b>, allocate stage <b>130</b>, and rename stage <b>140</b>. During the in-order front end phase, the instructions proceed through the pipeline <b>100</b> in their original program order. The second phase can be referred to as the out-of-order execution phase including the schedule/dispatch stage <b>150</b> and the execute stage <b>160</b>. During this phase, each instruction may be scheduled, dispatched and executed as soon as its data dependencies are resolved and the execution unit is available, regardless of its sequential position in the original program. The third phase, referred to as the in-order retirement phase which includes the retire stage <b>170</b> in which instructions are retired in their original, sequential program order to preserve the integrity and semantics of the program, and to provide a precise interrupt model.</p>\n<p num=\"p-0033\"><figref idrefs=\"DRAWINGS\">FIG. 2</figref> is a block diagram of one embodiment of a processor, in the form of a general-purpose microprocessor <b>200</b>, in which the present invention may be implemented. The microprocessor <b>200</b> described below is a multithreaded (MT) processor and capable of processing multiple instruction threads simultaneously. However, the teachings of the present invention described below are fully applicable to other processors that process multiple instruction threads in an interleaved manner and also to single thread processors which have the capabilities to process multiple instructions either in parallel or in an interleaved manner. In one embodiment, the microprocessor <b>200</b> may be an Intel Architecture (IA) microprocessor that is capable of executing an Intel Architecture instruction set.</p>\n<p num=\"p-0034\">The microprocessor <b>200</b> comprises an in-order front end, an out-of-order execution core and an in-order retirement back end. The microprocessor <b>200</b> includes a bus interface unit <b>202</b> which functions as an interface between the microprocessor <b>200</b> and other components (e.g., main memory unit) of a computer system within which the microprocessor <b>200</b> may be implemented. The bus interface unit <b>202</b> couples the microprocessor <b>200</b> to a processor bus (not shown) via which data and control information are transferred between the microprocessor <b>200</b> and other system components (not shown). The bus interface unit <b>202</b> includes Front Side Bus (FSB) logic <b>204</b> that controls and facilitates communications over the processor bus. The bus interface unit <b>202</b> also includes a bus queue <b>206</b> that is used to provide a buffering function with respect to the communications over the processor bus. The bus interface unit <b>202</b> receives bus requests <b>208</b> from a memory execution unit <b>212</b>. The bus interface unit <b>202</b> also sends snoops or bus returns to the memory execution unit <b>212</b>.</p>\n<p num=\"p-0035\">The memory execution unit <b>212</b> is structured and configured to function as a local memory within the microprocessor <b>200</b>. The memory execution unit <b>212</b> includes a unified data and instruction cache <b>214</b>, a data Translation Lookaside Buffer (TLB) <b>216</b>, and a memory ordering logic <b>218</b>. The memory execution unit <b>212</b> receives instruction fetch requests <b>220</b> from a microinstruction translation engine (MITE) <b>224</b> and provides raw instructions <b>225</b> to the MITE <b>224</b>. The MITE <b>224</b> decodes the raw instructions <b>225</b> received from the memory execution unit <b>212</b> into a corresponding set of microinstructions, also referred to as micro-operations. Decoded microinstructions <b>226</b> are sent by the MITE <b>224</b> to a trace delivery engine (TDE) <b>230</b>.</p>\n<p num=\"p-0036\">The TDE <b>230</b> functions as a microinstruction cache and is the primary source of microinstructions for a downstream execution unit <b>270</b>. The TDE <b>230</b> includes a trace cache <b>232</b>, a trace branch predictor (BTB) <b>234</b>, a micro-code sequencer <b>236</b>, and a micro-operation (uop) queue <b>238</b>. By having a microinstruction caching function within the processor pipeline, the TDE <b>230</b> and specifically the trace cache <b>232</b> can leverage the work done by the MITE <b>224</b> to provide a relatively high microinstruction bandwidth. In one embodiment, the trace cache <b>232</b> may comprise a <b>256</b> entry, 8 way set associate memory. The term \u201ctrace\u201d, in one embodiment, refers to a sequence of microinstructions stored as entries in the trace cache <b>232</b> with each entry having pointers to preceding and proceeding microinstructions in the trace. Therefore, the trace cache <b>232</b> can facilitate high-performance sequencing in that the address of the next entry to be accessed to obtain a subsequent microinstruction is known before a current access is completed. The trace cache branch predictor <b>234</b> provides local branch predictions with respect to traces within the trace cache <b>232</b>. The trace cache <b>232</b> and the microcode sequencer <b>236</b> provide microinstructions to the micro-op queue <b>238</b>.</p>\n<p num=\"p-0037\">The microinstructions are then fed from the micro-op queue <b>238</b> to a cluster (also referred to as the Rename, Reservation Station, Replay, and Retirement or RRRR cluster) <b>240</b>. The RRRR cluster <b>240</b>, in one embodiment, is responsible for controlling the flow of the microinstructions received from the TDE <b>230</b> through the rest of the microprocessor <b>200</b>. The functions performed by the RRRR cluster <b>240</b> include allocating the resources used for the execution of the microinstructions received from TDE <b>230</b>; converting references to external or logical registers into internal or physical register references; scheduling and dispatching the microinstructions for execution to an execution unit <b>270</b>; providing those microinstructions that need to be re-executed to the execution unit <b>270</b>; and retiring those microinstructions that have completed execution and are ready for retirement. The structure and operation of the RRRR cluster <b>240</b> are described in more detail below. In the event that the resources are insufficient or unavailable to process a microinstruction or a set of microinstructions, the RRRR cluster <b>240</b> will assert a stall signal <b>282</b> that is propagated to the TDE <b>230</b>. The stall signal <b>282</b> is then updated and sent by the TDE <b>230</b> to the MITE <b>224</b>.</p>\n<p num=\"p-0038\">The microinstructions that are ready for execution are dispatched from the RRRR cluster <b>240</b> to the execution unit <b>270</b>. In one embodiment, the execution unit <b>270</b> includes a floating point execution engine <b>274</b>, an integer execution engine <b>276</b>, and a level <b>0</b> data cache <b>278</b>. In one embodiment in which the microprocessor <b>200</b> executes the IA<b>32</b> instruction set.</p>\n<p num=\"p-0039\"><figref idrefs=\"DRAWINGS\">FIG. 3</figref> shows a block diagram of one embodiment of the RRRR cluster <b>240</b> described in <figref idrefs=\"DRAWINGS\">FIG. 2</figref> above. The RRRR cluster <b>240</b> as shown in <figref idrefs=\"DRAWINGS\">FIG. 3</figref> includes a register allocation table (RAT) <b>301</b>, an allocator and free-list manager (ALF) <b>311</b>, an instruction queue (IQ) <b>321</b>, a reorder buffer (ROB) <b>331</b>, a scheduler and scoreboard unit (SSU) <b>341</b>, and a checker and replay unit (CRU) <b>351</b>.</p>\n<p num=\"p-0040\">In the present embodiment, the TDE <b>230</b> delivers the microinstructions (UOPs) to both the ALF <b>311</b> and the RAT <b>301</b>. The ALF <b>311</b> is responsible for allocating most of the resources needed for the execution of the UOPs received from the TDE <b>230</b>. The ALF <b>311</b> includes a free-list manager structure (FLM) <b>315</b> that is used to maintain a history of register allocation. The RAT (also referred to as register renamer) <b>301</b> renames the logical registers specified in each UOP to the appropriate physical register pointers to remove the dependencies caused by register reuse. Once the ALF <b>311</b> and the RAT <b>301</b> have completed their corresponding functions, the UOPs are sent to the IQ <b>321</b> for temporary holding prior to being dispatched for execution by the SSU <b>341</b>. In the embodiment shown in <figref idrefs=\"DRAWINGS\">FIG. 3</figref>, the IQ <b>321</b> is responsible for providing the information about each UOP to the SSU <b>341</b> so that the SSU <b>341</b> can dispatch the respective UOP to the proper execution unit based on data dependency. In one embodiment, the IQ <b>321</b> includes a memory instruction address queue (MIAQ) <b>323</b>, a general instruction address queue (GIAQ) <b>325</b>, and an instruction data queue (IDQ) <b>327</b>. In one embodiment, the MIAQ <b>323</b> and the GIAQ <b>325</b> are used to hold and feed certain time-critical information to the SSU <b>341</b> as quickly as needed. The time-critical information include the UOP's sources and destinations, UOP latency, etc. Depending on the type of input UOP, the ALF <b>311</b> determines whether the MIAQ <b>323</b> or the GIAQ <b>325</b> will be used to hold the time-critical information for the respective input UOP. The MIAQ <b>323</b> is used for memory UOPs (i.e., UOPs that require memory access). The GIAQ <b>325</b> is used for non-memory UOPs (i.e., UOPs that do not require memory access). The IDQ <b>327</b> is used to hold the less time-critical information such as the opcode and immediate data.</p>\n<p num=\"p-0041\">When a UOP's sources are ready and an execution unit is available, the SSU <b>341</b> schedules and dispatches the UOP for execution. There are instances when some UOPs may produce incorrect data, for example due to a level <b>0</b> data cache miss. If a particular UOP produces incorrect data or uses incorrect data in its execution, the CRU <b>351</b> will be informed of the need for this particular UOP to be re-executed or replayed until the correct results are obtained. The checker of the CRU <b>351</b> examines each UOP after its execution to determine whether the respective UOP needs to be re-executed. If so, the replay manager of the CRU <b>351</b> is responsible for re-dispatching the respective UOP to the appropriate execution unit for re-execution. If the checker determines that a particular UOP does not need to be re-executed, that particular UOP will be sent to the ROB <b>331</b> for retirement.</p>\n<p num=\"p-0042\">The ROB <b>331</b> is responsible for retiring each UOP in its original logical program order once its execution has been completed and it is ready for retirement (i.e. no replay). In addition, the ROB <b>331</b> is responsible for handling internal and external events. Examples of internal events include exceptions signaled by the write back of various UOPs such as floating point denormal assist or other events signaled by UOPs that need to be handled by the microcode (e.g., assists). External events include interrupts, page fault, SMI requests, etc. In one embodiment, the ROB <b>331</b> is the unit responsible for ensuring that all events are serviced in accordance with the architectural requirements of the microprocessor. There are several conditions like events, interrupts, halt, reset, etc. that will cause the machine to change mode or to switch between MT and ST configuration. Whenever the ROB <b>331</b> detects such a condition, it asserts a signal or a set of signals (referred to as CRNuke herein) which causes all the UOPs being processed but not retired or committed to be flushed. The ROB <b>331</b> then provides the TDE <b>230</b> with the address of the microinstruction from which to start sequencing UOPs to handle the event. For example, if the memory cluster detects a page fault exception on a load UOP, it will transmit a signal to the ROB <b>331</b> to alert the ROB <b>331</b> of this event. When the ROB <b>331</b> reaches this load UOP, it will assert the signal CRNuke and not commit any state for any of the UOPs including the load UOP and those following it. The ROB <b>331</b> will then send the appropriate information to the TDE <b>230</b> to start sequencing UOPs to service the page fault exception.</p>\n<p num=\"p-0043\">In one embodiment, the ROB <b>331</b> is responsible for detecting and controlling transitions of the machine from single thread mode to multi-thread mode and back. It performs its corresponding function by detecting certain events which can be either internal or external and asserting CRNuke to the rest of the machine and also asserting signals to communicate the new state of the machine. The rest of the machine reacts to the CRNuke signal and the new state signals to enter or exit MT mode or ST mode.</p>\n<p num=\"p-0044\">In one embodiment, the resources that are allocated by the ALF <b>311</b> for the execution of the incoming UOPs include the following:</p>\n<p num=\"p-0045\">1. Sequence number given to each UOP to track the original logical program order of the respective UOP. In one embodiment, the sequence number given to each UOP within a particular thread is unique with respect to other UOPs within that particular thread. The sequence number is used for the in-order retirement of the UOPs once their executions are completed. The sequence number of each UOP is also used in the event that the input UOPs are to be executed in-order.</p>\n<p num=\"p-0046\">2. Entry in the Free List Manager (FLM) <b>315</b> given to each UOP to allow the rename history of the respective UOP to be tracked and recovered in case there is problem with the execution of a particular UOP and it needs to be re-executed.</p>\n<p num=\"p-0047\">3. Entry in the Reorder Buffer (ROB) <b>331</b> given to each UOP to allow the respective UOP to be retired in-order once its execution is completed successfully and the UOP is ready to be retired.</p>\n<p num=\"p-0048\">4. Entry in the physical register file given to each UOP to store the operand data needed for the execution of the respective UOP and the result produced therefrom.</p>\n<p num=\"p-0049\">5. Entry in the Load Buffer given to each UOP that needs to receive data from the MEU <b>212</b> (also referred to as the memory execution cluster).</p>\n<p num=\"p-0050\">6. Entry in the Store Buffer given to each UOP that is to produce some data to be stored in the memory execution cluster.</p>\n<p num=\"p-0051\">7. Entry in the IDQ <b>327</b> given to each UOP to hold the instruction information before the respective UOP is dispatched by the SSU <b>341</b> to the execution unit <b>270</b>.</p>\n<p num=\"p-0052\">8. Entry in the MIAQ <b>323</b> given to each memory UOP or entry in the GIAQ <b>325</b> given to each non-memory UOP to hold the time-critical information for the respective UOP before it is dispatched by the SSU <b>341</b> to the execution unit <b>270</b>.</p>\n<p num=\"p-0053\">In one embodiment, the ALF <b>311</b> is responsible for determining which resources are required for the execution of an input UOP received from the TDE <b>230</b> and how much of required resources need to be allocated for the respective UOP. For example, the ALF <b>311</b>, upon receiving a UOP from the TDE <b>230</b>, will determine whether a load buffer entry is needed and will allocate the appropriate load buffer entry for the respective UOP if there is an entry available in the load buffer. If no entry is available, the ALF <b>311</b> will generate a stall signal <b>282</b> as shown in <figref idrefs=\"DRAWINGS\">FIG. 2</figref> to inform the TDE <b>230</b> and other units within the processor that the incoming UOP cannot be allocated and certain units within the processor, for example the TDE <b>230</b>, need to stall until the stall conditions are cleared. In one embodiment, the ALF <b>311</b> provides the appropriate allocation information (e.g. allocation pointers) to other units within the RRRR cluster <b>240</b> including the IQ <b>321</b>, the RAT <b>301</b>, the ROB <b>331</b> and other units outside of the RRRR cluster <b>240</b>, for example the MEU <b>212</b> (FIG. <b>2</b>).</p>\n<p num=\"p-0054\">In one embodiment, the ALF <b>311</b> uses certain information maintained by other units such as a set of pointers referred to as tail pointers to determine, with respect to a particular resource such as a load buffer, the amount of free entries available for allocation. The ALF <b>311</b> also receives other signals such as clear signals due to branch misprediction (e.g., JEClear and CRClear) that are used to determine whether to generate a stall signal.</p>\n<p num=\"p-0055\">In one embodiment, the microprocessor <b>200</b> can operate in either a single thread (ST) mode or a multithread (MT) mode based upon a control input signal. In one embodiment, the control input signal indicating whether the microprocessor <b>200</b> is to operate in ST or MT mode is provided by the operating system. As explained above, the ALF unit <b>311</b>, in the present embodiment, is responsible for allocating most of the processor resources that are used for the execution of a particular UOP in a particular thread. The various resources allocated by the ALF unit <b>311</b> include the ROB <b>331</b>, the FLM <b>315</b>, the MIAQ <b>323</b>, the GIAQ <b>325</b>, the IDQ <b>327</b>,.the load buffer (LB) (not shown), the store buffer (SB) (not shown), and the physical register file entries that are required by the input UOPs. Each of the resources mentioned above contains a predetermined number of resource elements or entries that are to be allocated based upon the need of the respective UOPs and the availability of those resource elements or entries. In one embodiment, for example, the ROB <b>331</b> contains 126 entries, the FLM <b>315</b> contains 126 entries, the IDQ <b>327</b> contains 126 entries, the GIAQ <b>325</b> contains 32 entries, the MIAQ <b>323</b> contains 32 entries, the load buffer contains 48 entries, the store buffer contains 24 entries, and the physical register file contains 127 entries.</p>\n<p num=\"p-0056\">In the discussion that follows, it is assumed that there are two threads, thread <b>0</b> (T<b>0</b>) and thread <b>1</b> (T<b>1</b>) that can be executed concurrently by the microprocessor <b>200</b> in MT mode or executed individually in ST mode. However, the teachings of the present invention should not be limited to two threads and everything discussed herein equally applies to a processing environment in which more than two threads are executed concurrently. In addition, the discussion below is focused on the resource computation and allocation performed by the ALF unit <b>311</b> with respect to one exemplary queue, referred to hereinafter as Q, that is configured to operate as a circular queue or buffer. However, the teachings of the present invention is equally applicable to any other processor resource or any other data structure including, but not limited to, a non-circular queue structure, a linked-list structure, an array structure, a tree structure, etc.</p>\n<p num=\"p-0057\">In ST mode or ST configuration, each processor resource used in the execution of the UOPs is allocated to the \u201cworking\u201d thread, either thread <b>0</b> or thread <b>1</b>. The working thread is the particular thread to which the current set of UOPs received from the TDE <b>230</b> belong with respect to the current processing period. In one embodiment, the TDE <b>230</b> supplies as many as three valid UOPs per a processing clock cycle. AU valid UOPs in each clock cycle are tagged with one thread bit indicating the particular thread to which the respective allocation clock belongs. The thread bit is used to identify which of the two threads is the current working thread. In addition, the TDE <b>230</b> is responsible for supplying the correct valid bits for the set of UOPs that the TDE <b>230</b> delivers to the RRRR cluster <b>240</b>. Each UOP received from the TDE <b>230</b> therefore is tagged with a valid bit indicating whether the respective UOP is a valid UOP. When the TDE <b>230</b> has no valid UOPs to be allocated, the TDE <b>230</b> is responsible for driving the valid bits to invalid status. The UOPs within each thread are delivered by the TDE <b>230</b> to the RRRR cluster <b>240</b> in their original sequential program order.</p>\n<p num=\"p-0058\">In MT mode or MT configuration, each of the queues or buffers used for the execution of the UOPs is partitioned into two portions, one portion is to be used for thread <b>0</b> and the other portion is used for thread <b>1</b>. In one embodiment, the two portions are sized equally so that each thread is given the same number of queue or buffer entries. In one embodiment, the physical registers are a common resource to be shared by thread <b>0</b> and thread <b>1</b> on a first come, first served basis and there is no partition of the physical registers between the two threads.</p>\n<p num=\"p-0059\">In one embodiment, the queues or buffers to be allocated are configured as circular queues or circular buffers. Accordingly, once the end of a queue or a buffer is reached, allocation for subsequent UOPs will wrap around and start at the beginning of the queue or buffer. The wrap around operation with respect to a circular queue or buffer is described in greater detail below in conjunction with the various operations performed by the ALF <b>311</b> in doing resource computation and resource allocation for each resource.</p>\n<p num=\"p-0060\">In one embodiment, the ALF <b>311</b> utilizes a separate set of pointers for each thread with respect to each resource in order to perform the resource computation and allocation for each thread. As such, there are two separate sets of pointers associated with each resource. Each set of pointers includes a head pointer, a tail pointer, and a stall pointer. The head pointer is used for the allocation of the queue entries. For example, if the head pointer for a particular queue points to entry <b>1</b> in that queue, then entry <b>1</b> is the entry to be allocated for the respective UOP. Once entry <b>1</b> is allocated, the head pointer is advanced to the next entry in the queue, entry <b>2</b>. The tail pointer is used for the deallocation of queue entries. For example, if the tail pointer for a particular queue points to entry <b>1</b> in that queue, then entry <b>1</b> is the entry to be freed once the execution of the respective UOP is completed. Once entry <b>1</b> is deallocated or freed up, the tail pointer is advanced to the next entry to be deallocated, entry <b>2</b>. The stall pointer is used to determine whether there are enough free queue entries to accommodate the next allocation. For example, if the stall pointer for a particular queue points to entry <b>3</b> and the incoming UOPs require three entries for their allocation, then the stall pointer will point to entry <b>6</b> if there is enough room in the queue to allocate three entries for the input UOPs. In one embodiment, the value of the stall pointer is compared with the value of the tail pointer to determine whether there is enough room for the required allocation.</p>\n<p num=\"p-0061\">In one embodiment, the allocation policy used for the ROB <b>331</b>, FLM <b>315</b>, and IDQ <b>327</b> is a block allocation of three. Accordingly, if there is any valid UOP in the set of three input UOPs then 3 entries in those queues will be used even if not all of the inputs UOPs are valid. The allocation policy with respect to the GIAQ <b>325</b>, MIAQ <b>323</b>, load buffer, and store buffer is based upon the actual requirements of the input UOPs. Accordingly, entries in those queues will be allocated only if the input UOPs require them.</p>\n<p num=\"p-0062\"><figref idrefs=\"DRAWINGS\">FIGS. 4</figref><i>a </i>and <b>4</b><i>b </i>illustrate an example of a circular queue Q containing a predetermined number of entries, for example 16, that is used for the allocation of the working thread in ST mode and for the allocation of both threads <b>0</b> and <b>1</b> in MT mode. In ST mode, depending upon which thread is the working thread, either the thread <b>0</b> or thread <b>1</b> pointers are used for the resource computation and allocation with respect to Q. In MT mode, two sets of pointers are used. Referring to <figref idrefs=\"DRAWINGS\">FIG. 4</figref><i>a</i>, it is assumed that thread <b>0</b> is the working thread in ST mode. The circular queue Q contains 16 entries, entry <b>0</b> through entry <b>15</b>. Since thread <b>0</b> is the working thread, the set of pointers used for the allocation in this case is the thread <b>0</b> set of pointers: T<b>0</b>_TAIL_PTR, T<b>0</b>_HEAD_PTR, and T<b>0</b>_STALL_PTR. Since the entire queue is assigned to the working thread in ST mode, the end of queue in this case points to entry <b>15</b> in the queue. Since the queue Q is circular, the T<b>0</b>_TAIL_PTR, T<b>0</b>_HEAD_PTR, and T<b>0</b>_STALL_PTR will wrap around when they are advanced past entry <b>15</b> in the queue. In ST mode, the allocation in the exemplary queue Q is performed serially starting from entry <b>0</b>. Since the pointers can wrap around, it is necessary to keep track of the wrap around situation so that the resource computation and resource allocation with respect to Q can be performed correctly. In one embodiment, a wrap bit is used to keep track of the wrap around situation with respect to each pointer. At the start of thread <b>0</b> execution or in response to a break event as described above, the thread <b>0</b> pointers and their associated wrap bits for Q are initialized to their appropriate values assuming that thread <b>0</b> is the working thread. In one embodiment, T<b>0</b>_TAIL_PTR, T<b>0</b>_READ_PTR, and T<b>0</b>_STALL_PTR are initialized to point to the first entry, i.e. entry <b>0</b>, in the queue Q and their corresponding wrap bits are set to 0, to indicate that the queue Q is empty at this stage. As entries for the input UOPs are being allocated, the T<b>0</b>_HEAD_PTR is updated to reflect the allocations made. Similarly, as entries in the queue are being freed up or deallocated, the T<b>0</b>_TAIL_PTR is updated accordingly to reflect the deallocations made. The T<b>0</b>_STALL_PTR is used to compute whether there are sufficient available entries in the queue to accommodate the input UOPs. The value of the wrap bit for each pointer is toggled between 0 and 1 each time that particular pointer is advanced past the end of queue, i.e. entry <b>15</b>.</p>\n<p num=\"p-0063\"><figref idrefs=\"DRAWINGS\">FIG. 4</figref><i>b </i>illustrates an exemplary queue Q containing 16 entries that are to be allocated for thread <b>0</b> and thread <b>1</b> in MT mode. One portion of the queue, entries <b>0</b>-<b>7</b>, is reserved for thread <b>0</b> allocation while the other portion of the queue, entries <b>8</b>-<b>15</b>, is reserved for thread <b>1</b> allocation. Accordingly, thread <b>0</b> end of queue (T<b>0</b>_EOQ) points to entry <b>7</b> and thread <b>1</b> end of queue (T<b>1</b>_EOQ) points to entry <b>15</b>. One set of pointers (T<b>0</b>_TAIL_PTR, T<b>0</b>_HEAD_PTR, T<b>0</b>_STALL_PTR) is used for resource computation and allocation with respect to the portion reserved for thread <b>0</b> and another set of pointers (T<b>1</b>_TAIL_PTR, T<b>1</b>_HEAD_PTR, T<b>1</b>_STALL_PTR) is used for the resource computation and allocation with respect to the portion reserved for thread <b>1</b>. At the start of MT execution mode, the respective pointers for thread <b>0</b> and thread <b>1</b> are initialized to their corresponding values based upon the partitioning scheme implemented. In this example, since the queue is partitioned into two equal portions, T<b>0</b> pointers are initialized to point to the beginning of the queue, i.e. entry <b>0</b>, and the T<b>1</b> pointers are initialized to point to the middle of the queue, i.e., entry <b>8</b>. The corresponding wrap bits for both thread <b>0</b> and thread <b>1</b> pointers are also initialized accordingly, for example to <b>0</b>. In this example, both portions of the queue Q are configured to be circular. Accordingly, T<b>0</b> pointers will wrap around to entry <b>0</b> as they are advanced past entry <b>7</b>. Similarly, T<b>1</b> pointers will wrap around to entry <b>8</b> as they are advanced past entry <b>15</b>. A separate wrap bit is used to keep track of the wrap around situation for each pointer of each thread with respect to its respective portion of the queue. For example, the value of the wrap bit for each thread <b>0</b> pointer (T<b>0</b>_WBIT) is toggled each time that particular thread <b>0</b> pointer is advanced past entry <b>7</b>. Similarly, the value of the wrap bit for each thread <b>1</b> pointer (T<b>1</b>_WBIT) is toggled each time that particular thread <b>1</b> pointer is advanced past entry <b>15</b>. The values of T<b>0</b>_TAIL_PTR, T<b>0</b>_STALL_PTR and the corresponding wrap bits for T<b>0</b>_TAIL_PTR and T<b>0</b>_STALL_PTR are used to determine the number of entries available in T<b>0</b> portion of the queue for thread <b>0</b> allocation. Similarly, the values of T<b>1</b>_TAIL_PTR, T<b>1</b>_STALL_PTR and the corresponding wrap bits for these two pointers are used to determine the number of entries available in T<b>1</b> portion of the queue for thread <b>1</b> allocation.</p>\n<p num=\"p-0064\">In the present embodiment, if the required resources are not available to execute the input UOPs within a particular thread, the ALF unit <b>311</b> will generate a stall signal with respect to that particular thread to inform the TDE <b>230</b> and other units within the microprocessor that they need to stall until the stall conditions are cleared. In one embodiment, stalling means that the ALF <b>311</b> and the RAT <b>301</b> will not get any new valid UOPs to allocate and therefore no new valid UOPs will be transferred to the rest of the processor down the pipeline. In addition, the TDE <b>230</b> needs to stop fetching new UOPs because the last set of UOPs that were fetched cannot be allocated due to the stall condition caused by insufficient resources. Since there are two threads, thread <b>0</b> and thread <b>1</b>, that can be executed concurrently, either thread <b>0</b> or thread <b>1</b> or both threads can be stalled due to insufficient resources. Accordingly, there are two separate stall signals, one for each thread, that can be activated by the ALF <b>311</b> if there are insufficient resources to satisfy the resource requirements of the input UOPs. The thread <b>0</b> stall signal, referred to as ALSTALLT<b>0</b>, is activated by the ALF <b>311</b> if there are not enough resources to allocate the input UOPs in thread <b>0</b>. Likewise, the thread <b>1</b> stall signal, referred to as ALSTALLT<b>1</b>, is activated by the ALF <b>311</b> if there are not enough resources to allocate the input UOPs in thread <b>1</b>.</p>\n<p num=\"p-0065\">In one embodiment, the ALSTALL signals for both threads <b>0</b> and <b>1</b> are determined in every clock if the processor is running in MT mode. In ST mode, there is only one ALSTALL signal. It can be either ALSTALLT<b>0</b> or ALSTALLT<b>1</b> based upon the working thread. In MT mode, when only ALSTALLT<b>0</b> is asserted, the TDE <b>230</b> can drive one of the following to the RRRR cluster: (1) valid UOPs from thread <b>1</b>; (2) invalid UOPs; or (3) the stalled UOPs from thread <b>0</b>. Similarly, if only ALSTALLT<b>1</b> is asserted, the TDE <b>230</b> can drive to the RRRR cluster either valid UOPs from thread <b>0</b>, invalid UOPs, or the stalled UOPs from thread <b>1</b>. When both ALSTALLT<b>0</b> and ALSTALLT<b>1</b> are asserted, the TDE <b>230</b> can drive either the stalled UOPs from thread <b>0</b>, the stalled UOPs from thread <b>1</b>, or invalid UOPs. In one embodiment, the earliest that the ALF <b>311</b> will be able to allocate the stalled UOPs is two clocks after the stall signal corresponding to that thread becomes inactive. In order for the ALF <b>311</b> to allocate in two clocks, the TDE <b>230</b> needs to drive the stalled UOPs on the last clock that the stall signal corresponding to that thread is still active.</p>\n<p num=\"p-0066\">In one embodiment, to enable the stall computation, an additional clock is added to the RRRR interface with the TDE. The first clock is used to perform the stall computation and the allocation is done in the next clock if there is no stall. The stall is computed for a set of three UOPs every medium clock. As mentioned above, actual resource computation and allocation is done with respect to the GIAQ <b>325</b>, MIAQ <b>323</b>, load buffer, and store buffer while block computation and allocation is done with respect to the FLM <b>315</b>, ROB <b>331</b>, and the IDQ <b>327</b>. As discussed above, the stall signal for a particular thread will be activated if there are insufficient entries in one or more of the resources to allocate for the input UOPs.</p>\n<p num=\"p-0067\">In one embodiment, there is a separate stall block computation for each thread. In one embodiment, when the processor is running in MT mode, the stall computation for thread <b>0</b> and the stall computation for thread <b>1</b> are performed in parallel in every clock even though there is only one thread to be allocated in each clock.</p>\n<p num=\"p-0068\"><figref idrefs=\"DRAWINGS\">FIG. 5</figref> illustrates a high level flow diagram of one embodiment of a method <b>500</b> for managing various resources in the multithreaded processor <b>200</b>. In one embodiment, a control signal indicating the corresponding execution mode is set to a first value, for example 0, to indicate that the single threading mode is active and set to a second value, for example 1, to indicate that the multithreading mode is active. In one embodiment, the processor <b>200</b> waits for the state recovery to complete before it can transition from one execution mode to another execution mode. Whenever the ROB <b>331</b> detects an event condition, it asserts the signal CRNuke which causes all the UOPs being processed but not yet retired or committed to be flushed.</p>\n<p num=\"p-0069\">With continuing reference to <figref idrefs=\"DRAWINGS\">FIG. 5</figref>, the method <b>500</b> starts at <b>501</b>. At decision block <b>505</b>, the method <b>500</b> proceeds to block <b>509</b> if an event has been detected. Otherwise it proceeds to block <b>541</b>. In one embodiment, an event can be an internal or external event or a condition detected by the ROB <b>331</b> which then generates a CRNuke signal as described above. In one embodiment, one or more signals are generated to indicate that state recovery is complete. One example of such a signal is that after the state in the RAT <b>311</b> is recovered and all physical registers are freed then a state recovery done signal is asserted. When all such state recovery done signals are asserted then the state recovery is considered complete. At decision block <b>509</b>, the method <b>500</b> proceeds to block <b>513</b> if the state recovery is completed. At block <b>513</b>, the thread active bits are latched. The method <b>500</b> then proceeds from block <b>513</b> to decision block <b>517</b> to determine whether the processor is to run in MT or ST mode. The method <b>500</b> then proceeds to block <b>521</b> if MT mode is indicated and to block <b>531</b> if ST mode is indicated. At block <b>521</b>, the allocation pointers for both threads <b>0</b> and <b>1</b> are initialized according to a predetermined MT scheme. At block <b>531</b>, the allocation pointers for the working thread are initialized according to a predetermined ST scheme. The method then proceeds from either block <b>521</b> or block <b>531</b> to block <b>541</b> to perform the resource allocation task according to either the ST scheme or MT scheme. The method then loops back from block <b>541</b> to block <b>505</b>.</p>\n<p num=\"p-0070\"><figref idrefs=\"DRAWINGS\">FIG. 6</figref> shows a high level block diagram of a resource allocation process <b>600</b> performed at block <b>541</b> in FIG. <b>5</b>. The process starts at block <b>601</b> and proceeds to block <b>605</b>. At decision block <b>605</b>, the process proceeds to block <b>611</b> to perform resource allocation in MT mode if MT mode is indicated. Otherwise, it proceeds to block <b>621</b> to perform resource allocation in ST mode. The process then proceeds to end at block <b>691</b>.</p>\n<p num=\"p-0071\"><figref idrefs=\"DRAWINGS\">FIG. 7</figref> is a high level flow diagram of one embodiment of a resource allocation process in MT mode <b>700</b> performed at block <b>611</b> in FIG. <b>6</b>. In this embodiment, the allocation process is performed in parallel for both thread <b>0</b> and thread <b>1</b>. The process starts at block <b>701</b> and proceeds in parallel to both blocks <b>705</b> and <b>715</b> to perform stall computation for thread <b>0</b> and thread <b>1</b>, respectively. The stall computation for thread <b>0</b> and thread <b>1</b> will be discussed in more detail below. The process then proceeds in parallel from blocks <b>705</b> and <b>715</b> to blocks <b>707</b> and <b>717</b>, respectively. At decision block <b>707</b>, the process proceeds to block <b>709</b> if T<b>0</b> is not stalled. Otherwise the process proceeds to end at block <b>791</b>. At decision block <b>717</b>, the process proceeds to block <b>719</b> if T<b>1</b> is not stalled. Otherwise the process proceeds to end at block <b>791</b>. At block <b>709</b>, resource allocation for thread <b>0</b> is performed. At block <b>719</b>, resource allocation for thread <b>1</b> is performed. The resource allocation performed at blocks <b>709</b> and <b>719</b> will be described in more detail below. The process then proceeds to end at block <b>791</b>.</p>\n<p num=\"p-0072\"><figref idrefs=\"DRAWINGS\">FIG. 8</figref> illustrates a high level flow diagram of another embodiment of an MT resource allocation process <b>800</b> performed at block <b>611</b> in FIG. <b>6</b>. In this embodiment, both the stall computation and the resource allocation for each of the two threads <b>0</b> and <b>1</b> are performed in a multiplexed manner based upon the thread ID associated with the input UOPs received from the TDE <b>230</b>. The process begins at block <b>801</b> and proceeds to decision block <b>805</b>. At decision block <b>805</b>, the process proceeds to block <b>811</b> if the UOPs received from the TDE come from thread <b>0</b>. Otherwise, the process proceeds to block <b>821</b>. As described above, in one embodiment, each UOP received from the TDE <b>230</b> is tagged with a thread bit indicating the particular thread to which it belongs. In one embodiment where there are two threads being executed concurrently in the MT mode, the thread bit is set to one value, for example 0, to indicate that the respective UOP is in thread <b>0</b> and set to another value, for example 1, to indicate that the respective UOP is in thread <b>1</b>. At block <b>811</b>, stall computation for thread <b>0</b> is performed to determine whether there are sufficient resources to execute the input UOPs from thread <b>0</b>. The process then proceeds from block <b>811</b> to decision block <b>815</b>. At decision block <b>815</b>, the process proceeds to block <b>819</b> to perform resource allocation for the respective UOP if there are sufficient resources available. Otherwise the process proceeds to end at block <b>891</b>. Referring back to block <b>821</b>, stall computation for thread <b>1</b> is performed in this block to determine whether there are sufficient resources to execute the input UOPs from thread <b>1</b>. The process then proceeds from block <b>821</b> to decision block <b>825</b>. At decision block <b>825</b>, the process proceeds to block <b>829</b> to allocate the necessary resources for the respective UOPs if there are sufficient resources available. Otherwise, the process proceeds to end at block <b>891</b>. The process then proceeds from either block <b>819</b> or block <b>829</b> to end at block <b>891</b>.</p>\n<p num=\"p-0073\"><figref idrefs=\"DRAWINGS\">FIG. 9</figref> is a high level flow diagram of another embodiment of an MT resource allocation process <b>900</b> performed at block <b>611</b> in FIG. <b>6</b>. In this embodiment, the stall computations for thread <b>0</b> and thread <b>1</b> are performed in parallel while the resource allocations for thread <b>0</b> and thread <b>1</b> are multiplexed. The process starts at block <b>901</b> and proceeds to perform the stall computation for thread <b>0</b> and thread <b>1</b> in parallel at block <b>905</b> and block <b>909</b>, respectively. The process then proceeds from blocks <b>905</b> and <b>909</b> to decision block <b>913</b> to determine whether the input UOPs received in the current clock cycle belong to thread <b>0</b> or thread <b>1</b>. As described above, each input UOP received from the TDE <b>230</b> is tagged with a tag bit indicating the corresponding thread to which the respective UOP belongs. The process then proceeds from decision block <b>913</b> to block <b>915</b> if the respective UOP belongs to thread <b>0</b>, otherwise it proceeds to block <b>917</b>. At decision block <b>915</b>, the process proceeds to block <b>921</b> to perform resource allocation for thread <b>0</b> if thread <b>0</b> is not stalled. Otherwise, the process proceeds to end at block <b>991</b>. At decision block <b>917</b>, the process proceeds to block <b>931</b> to perform resource allocation for thread <b>1</b> if thread <b>1</b> is not stalled. Otherwise the process proceeds to end at block <b>991</b>. The process then proceeds from either block <b>921</b> or <b>931</b> to end at block <b>991</b>. In one embodiment, both the resource computation and the resource allocation tasks are performed in the same clock cycle. In another embodiment, the stall computation for each thread is performed in one clock cycle while the resource computation for the working thread is performed in the next clock cycle.</p>\n<p num=\"p-0074\"><figref idrefs=\"DRAWINGS\">FIG. 10</figref> shows a high level flow diagram of one embodiment of an ST resource allocation process <b>1000</b> performed at block <b>621</b> in FIG. <b>6</b>. As discussed above, in the ST running mode, there is only one thread being executed and it is considered the working thread. The process begins at block <b>1001</b> and proceeds to decision block <b>1005</b>. At decision block <b>1005</b>, the process proceeds to block <b>1011</b> if the working thread is thread <b>0</b> or to block <b>1021</b> if the working thread is thread <b>1</b>. As mentioned above, a thread active bit is maintained with respect to each thread being executed to indicate whether that particular thread is being active. In ST mode, either thread <b>0</b> or thread <b>1</b> is the working thread. In one embodiment, a separate thread active bit is maintained for each thread and is set to a first value to indicate that it is active and set to a second value otherwise. At block <b>1011</b>, stall computation is performed with respect to thread <b>0</b> to determine whether there are sufficient resources to execute the input UOPs received from the TDE <b>230</b>. The process then proceeds from block <b>1011</b> to decision block <b>1013</b>. At decision block <b>1013</b>, the process proceeds to block <b>1015</b> to allocate the necessary resources for the respective thread <b>0</b> UOPs if the thread <b>0</b> stall signal is inactive. Otherwise, the process proceeds from decision block <b>1013</b> to end at block <b>1091</b>. Referring back to decision block <b>1005</b>, the process proceeds to block <b>1021</b> if the working thread is thread <b>1</b>. At block <b>1021</b>, stall computation is performed with respect to thread <b>1</b> to determine whether there are sufficient resources to execute the input thread <b>1</b> UOPs received from the TDE <b>230</b>. At decision block <b>1023</b>, the process proceeds to block <b>1025</b> to allocate the necessary resources for the execution of the input thread <b>1</b> UOPs if the thread <b>1</b> stall signal is inactive. Otherwise, the process proceeds to end at block <b>1091</b>. As discussed above, in the ST mode, the resources are allocated to the active or working thread, either thread <b>0</b> or thread <b>1</b>. If it is determined that there are insufficient resources to execute the input UOPs for the working thread fetched from the TDE <b>230</b>, the ALF <b>311</b> generates the appropriate stall signal for the working thread, either thread <b>0</b> or thread <b>1</b>, to inform the TDE <b>230</b> and other units within the microprocessor that the coming UOPs cannot be executed. In this case, the TDE <b>230</b> needs to stall further fetching of UOPs to the RRRR <b>300</b> until the conditions that cause the stall are cleared.</p>\n<p num=\"p-0075\"><figref idrefs=\"DRAWINGS\">FIG. 11</figref> illustrates a more detailed flow diagram of one embodiment of the MT parallel resource allocation process described in <figref idrefs=\"DRAWINGS\">FIG. 7</figref> above. As discussed above, in this embodiment, both the stall computation and resource allocation for thread <b>0</b> and thread <b>1</b> are performed in parallel. The process begins at block <b>1101</b> and proceeds in parallel to both blocks <b>1105</b> and <b>1155</b>. At decision block <b>1105</b>, the process continues to block <b>1110</b> if the input UOPs for thread <b>0</b> are valid. Otherwise, the process proceeds to end at block <b>1191</b> with respect to thread <b>0</b>. At decision block <b>1155</b>, the process proceeds to block <b>1160</b> if the input UOPs for thread <b>1</b> are valid. Otherwise the process proceeds to end at block <b>1191</b> with respect to thread <b>1</b>. As discussed above, in one embodiment, each UOP received from the TDE <b>230</b> is supplied with a valid bit indicating whether that particular UOP is valid. The TDE <b>230</b> is responsible for supplying the correct valid bits for the UOPs that it fetches to the RRRR cluster <b>300</b>. At blocks <b>1110</b> and <b>1160</b>, the ALF unit <b>311</b> determines the resources needed for the execution of thread <b>0</b> UOPs and thread <b>1</b> UOPs, respectively. The process then proceeds from block <b>1110</b> to block <b>1115</b> and from block <b>1160</b> to block <b>1165</b>. At block <b>1115</b>, the amount of resources available for thread <b>0</b> execution is determined. At block <b>1165</b>, the amount of resources available for thread <b>1</b> execution is determined. The process then continues from blocks <b>1115</b> and <b>1165</b> to blocks <b>1120</b> and <b>1170</b>, respectively. At decision block <b>1120</b>, the process proceeds to block <b>1125</b> to activate the stall signal for thread <b>0</b> if there are insufficient resources available to execute the input UOPs from thread <b>0</b>. Otherwise, the process proceeds to block <b>1130</b> to allocate the required resources for the execution of the input thread <b>0</b> UOPs. The process then continues from block <b>1130</b> to block <b>1135</b> to update the resource allocation pointers for thread <b>0</b> to keep track of the amount of resources allocated in block <b>1130</b>. The process then proceeds from either block <b>1125</b> or block <b>1135</b> to end at block <b>1191</b>. Referring back to block <b>1165</b>, the process proceeds from block <b>1165</b> to block <b>1170</b>. At decision block <b>1170</b>, the process proceeds to block <b>1175</b> to activate the stall signal for thread <b>1</b> if there are insufficient resources to handle the execution of thread <b>1</b> UOPs. Otherwise the process continues to block <b>1180</b> to allocate the necessary resources for thread <b>1</b> UOPs. The process then proceeds from block <b>1180</b> to block <b>1185</b> to update the resource allocation pointers for thread <b>1</b> to keep track of the amount of resources allocated in block <b>1180</b>. The process then proceeds from either block <b>1175</b> or block <b>1185</b> to end at block <b>1191</b>.</p>\n<p num=\"p-0076\"><figref idrefs=\"DRAWINGS\">FIG. 12</figref> shows a more detailed flow diagram of one embodiment of the MT resource allocation process described in <figref idrefs=\"DRAWINGS\">FIG. 8</figref> above. In this embodiment, both the resource computation and resource allocation for thread <b>0</b> and thread <b>1</b> are multiplexed. The process starts at block <b>1201</b> and proceeds to decision block <b>1205</b>. At decision block <b>1205</b>, the process continues to block <b>1209</b> if the input UOPs are valid. Otherwise the process proceeds to end at block <b>1291</b>. At decision block <b>1209</b>, the process proceeds to block <b>1213</b> to select the appropriate pointers for thread <b>0</b> if thread <b>0</b> is the current working thread. Otherwise, the process proceeds to block <b>1217</b> to select the appropriate thread <b>1</b> pointers. The process then proceeds from either block <b>1213</b> or block <b>1217</b> to block <b>1221</b> to determine the amount of resources required to execute the input UOPs for the current working thread. The process then continues to block <b>1225</b> to determine the amount of available resources for the working thread using the appropriate pointers selected. At decision block <b>1229</b>, the process proceeds to block <b>1233</b> to activate the stall signal for the current working thread, either thread <b>0</b> or thread <b>1</b>, if there are not enough resources to handle the execution of the input UOPs for the working thread. If there are enough resources available, the process proceeds from decision block <b>1229</b> to block <b>1237</b> to allocate the required resources for the current input UOPs. Resource allocation pointers for the current working thread are then updated accordingly at block <b>1241</b> to keep track of the amount of resources allocated to the working thread. The process then proceeds from either block <b>1233</b> or block <b>1241</b> to end at block <b>1291</b>.</p>\n<p num=\"p-0077\"><figref idrefs=\"DRAWINGS\">FIG. 13</figref> illustrates a more detailed flow diagram of one embodiment of the MT resource allocation process described in <figref idrefs=\"DRAWINGS\">FIG. 9</figref> above. In this embodiment, the resource stall computation for both thread <b>0</b> and thread <b>1</b> are done in parallel but the resource allocation is only performed for the current working thread, i.e., resource allocation for thread <b>0</b> and thread <b>1</b> is multiplexed.</p>\n<p num=\"p-0078\">The process begins at block <b>1301</b> and proceeds in parallel to both blocks <b>1305</b> and <b>1325</b>. At decision block <b>1305</b>, the process proceeds to end at block <b>1391</b> if the T<b>0</b> input UOPs are invalid. Otherwise it proceeds to block <b>1309</b> to determine the resources required for the execution of the T<b>0</b> input UOPs. The process then continues to block <b>1313</b> to determine the amount of resources available for thread <b>0</b> execution. At decision block <b>1317</b>, the process proceeds to block <b>1321</b> to activate the stall signal for thread <b>0</b> if there are insufficient resources to handle the execution of the T<b>0</b> input UOPs. Otherwise the process proceeds to decision block <b>1351</b>. Referring back to decision block <b>1325</b>, the process proceeds to end at block <b>1391</b> if the T<b>1</b> input UOPs are invalid. Otherwise it proceeds to block <b>1329</b> to determine the resources required for the execution of the T<b>1</b> input UOPs. The process then continues to block <b>1333</b> to determine the amount of resources available for thread <b>1</b> execution. At decision block <b>1337</b>, the process proceeds to block <b>1341</b> to activate the stall signal for thread <b>1</b> if there are insufficient resources to handle the execution of the T<b>1</b> input UOPs. Otherwise the process proceeds to decision block <b>1351</b>. At decision block <b>1351</b>, the process proceeds to block <b>1355</b> to select the appropriate thread <b>0</b> pointers if thread <b>0</b> is the current working thread, otherwise the process proceeds to block <b>1359</b> to select the appropriate thread <b>1</b> pointers. The process then continues to block <b>1361</b> from either block <b>1355</b> or block <b>1359</b>. At decision block <b>1361</b>, the process proceeds to end if the stall signal for the current working thread is activated, otherwise it proceeds to allocate the necessary resources for the current working thread, either thread <b>0</b> or thread <b>1</b>, at block <b>1371</b>. The process then proceeds from block <b>1371</b> to block <b>1381</b> to update the appropriate allocation pointers for the current working thread. The process then proceeds to end at block <b>1391</b>.</p>\n<p num=\"p-0079\"><figref idrefs=\"DRAWINGS\">FIG. 14</figref> shows a flow diagram of one embodiment of the resource computation and resource allocation process for thread <b>0</b> according to the teachings of the present invention.</p>\n<p num=\"p-0080\">As described above, in order to perform the resource computation and resource allocation for each thread, the ALF <b>311</b> utilizes and maintains a separate set of pointers for each respective thread. For each resource, the ALF <b>311</b> maintains a set of pointers including a head pointer, a tail pointer, and a stall pointer for each thread to compute the amount of available entries in the resource and to allocate the appropriate entries in the resource as required for the execution of each UOP within each thread. In the discussion that follows, the process is discussed with respect to a particular queue, for example, the instruction queue as one of the resources needed for the execution of a particular UOP within thread <b>0</b> even though everything discussed herein is equally applicable to the resource computation and resource allocation with respect to other resources. As discussed above, in ST mode, each resource is wholly dedicated to serving the working thread, either thread <b>0</b> or thread <b>1</b>. In MT mode, each resource is partitioned into two portions. One portion is reserved for thread <b>0</b> while the other portion is reserved for thread <b>1</b>. In one embodiment, the lower or first half of the queue is reserved for use by thread <b>0</b> and the upper or second half of the queue is reserved for use by thread <b>1</b>. Accordingly, there are two sets of pointers that are used to perform the resource computation and resource allocation for each resource with respect to thread <b>0</b> and thread <b>1</b>. In the present example, assuming that the size of the queue is Q, and the first entry in the queue is 0, then the end of the queue (EOQ) is designated as Q\u22121 in ST mode. In MT mode, with respect to thread <b>0</b> the beginning of queue is 0 and the end of queue is Q/2\u22121, whereas for thread <b>1</b> the beginning of queue is Q/2 and the end of queue is Q\u22121. It should be understood and appreciated by one skilled in the art that the teachings of the present invention should not in anyway be limited to the equal partitioning of the queue or resource. The teachings of the present invention are applicable to any other schemes or ways of resource partition (e.g., unequal partition). For example, a resource can be partitioned into two or more unequal portions based on various factors or criteria including, but are not limited to, the number of threads being executed concurrently, the capacity of the resource, the relative processing priority of each thread, etc. As an example, a resource can be partitioned into two unequal portions in which \u00bc of the resource is reserved for one thread (e.g., Q/4) and \u00be of the resource is reserved for another thread (3Q/4).</p>\n<p num=\"p-0081\">Continuing with the present discussion with respect to thread <b>0</b> resource computation and allocation process, it should be noted, as explained above, that after the CRNuke signal is asserted and the event is done with respect to thread <b>0</b> and thread <b>1</b>, the associated pointers for each resource are initialized to the appropriate values depending on whether the processor is to run in ST mode or MT mode. In ST mode, either the set of pointers for thread <b>0</b> or the set of pointers for thread <b>1</b> are initialized depending on whether thread <b>0</b> or thread <b>1</b> is the working thread. For example, if thread <b>0</b> is the working thread in ST mode, then T<b>0</b>_HEAD_PTR, T<b>0</b>_TAIL_PTR, and T<b>0</b>_STALL_PTR are initialized to <b>0</b> and the end of queue value is Q\u22121 where Q is the size of the particular resource to be allocated for the execution of thread <b>0</b> UOPs. Similarly, when thread <b>1</b> is the working thread in ST mode, T<b>1</b>_HEAD_PTR, T<b>1</b>_TAIL_PTR, and T<b>1</b>_STALL_PTR are initialized to <b>0</b> and the end of queue value with respect to thread <b>1</b> is also Q\u22121. In ST mode, the whole resource is to be reserved for the working thread. In MT mode, however, the queue or the resource is partitioned into two equal portions and the sets of pointers for thread <b>0</b> and thread <b>1</b> are set to the appropriate corresponding values. For example, in MT mode, T<b>0</b>_HEAD_PTR, T<b>0</b>_TAIL_PTR, and T<b>0</b>_STALL_PTR are set to <b>0</b> after NUKE whereas T<b>1</b>_HEAD_PTR, T<b>1</b>_TAIL_PTR, and T<b>1</b>_STALL_PTR are set to Q/2 after NUKE. The end of queue with respect to thread <b>0</b> in MT mode is Q/2\u22121 while the end of queue with respect to thread <b>1</b> is Q\u22121. By setting the pointers for thread <b>0</b> and thread <b>1</b> to their corresponding values as described above, the resource or queue to be allocated is partitioned into two equal portions. In one embodiment, each queue or buffer to be allocated is configured as a circular queue or circular buffer. As such, when the pointers for each thread with respect to a particular queue or buffer are advanced past their respective end of queue, these pointers are wrapped around. A wrap bit is used to keep track of the wrap around situation with respect to each pointer of each thread. The wrap bit for each pointer of each thread is set to a first value at the start to indicate that the corresponding pointer has not been wrapped around. The value of the wrap bit for each pointer is toggled when that particular pointer is advanced past its corresponding end of queue. For example, if T<b>0</b>_STALL_PTR or T<b>0</b>_TAIL_PTR for a particular queue is advanced past Q\u22121 in ST mode or Q/2\u22121 in MT mode, then the wrap bit for T<b>0</b>_STALL_PTR or the wrap bit for T<b>0</b>_TAIL_PTR with respect to that particular queue is toggled. This wrap bit for each pointer is used in the stall computation for each resource, as described in more detail below. Again, it should be understood and appreciated by one skilled in the art that the teachings of the present invention should not in anyway be limited to the equal partitioning of the queue or resource. The teachings of the present invention are applicable to any other schemes or ways of resource partition (e.g., unequal partition). For example, a resource can be partitioned into two or more unequal portions based on various factors or criteria including, but are not limited to, the number of threads being executed concurrently, the capacity of the resource, the relative processing priority of each thread, etc. As an example, a resource can be partitioned into two unequal portions in which \u00bc of the resource is reserved for one thread (e.g., Q/4) and \u00be of the resource is reserved for another thread (3Q/4).</p>\n<p num=\"p-0082\">Referring back to <figref idrefs=\"DRAWINGS\">FIG. 14</figref>, the process begins at block <b>1401</b> and proceeds to block <b>1405</b> to set the T<b>0</b>_PREV_STALL_PTR to be equal to the current T<b>0</b>_STALL_PTR. At decision block <b>1409</b>, the process proceeds to block <b>1413</b> to select Q/2\u22121 as the end of queue value if the processor is running in MT mode. Otherwise, the process proceeds to block <b>1417</b> to select Q\u22121 as the end of queue value. The process then continues from either block <b>1413</b> or block <b>1417</b> to block <b>1421</b> to compute the number of entries needed for this set of input UOPs. The process proceeds to block <b>1425</b> to compute the new value for the T<b>0</b>_STALL_PTR. In one embodiment, the T<b>0</b>_STALL_PTR is incremented by the number of entries computed in block <b>1421</b> to obtain the new value for T<b>0</b>_STALL_PTR. For example, T<b>0</b>_STALL_PTR=T<b>0</b>_STALL_PTR+R_CNT where R_CNT is the number of entries needed that is computed in block <b>1421</b>. At decision block <b>1433</b>, the process proceeds to block <b>1437</b> to wrap around the new T<b>0</b>_STALL_PTR and toggle the corresponding wrap bit if it advances past the respective EOQ. Otherwise the process continues to block <b>1439</b>. As discussed above, since the queue to be allocated here is configured as a circular queue, once the T<b>0</b>_STALL_PTR advances past the EOQ it needs to be wrapped around and the corresponding wrap bit needs to be toggled accordingly. For example, if the T<b>0</b>_STALL_PTR=EOQ then the T<b>0</b>_STALL_PTR is wrapped around to 0, which is the start of the respective portion of the queue reserved for thread <b>0</b>. If the T<b>0</b>_STALL_PTR=EOQ+1, then the T<b>0</b>_STALL_PTR is wrapped around to 1, which is the start of the respective portion of the queue plus 1, and so on. The process then proceeds from block <b>1437</b> to block <b>1439</b>. At block <b>1439</b>, the T<b>0</b>_STALL_PTR is compared with T<b>0</b>_TAIL_PTR taken into consideration the values of the wrap bits associated with T<b>0</b>_STALL_PTR and T<b>0</b>_TAIL_PTR to determine whether there are enough free entries in the queue to allocate the entries required. In one embodiment, if the wrap bit for T<b>0</b>_STALL_PTR is 1, the wrap bit for T<b>0</b>_TAIL_PTR is 0, and the T<b>0</b>_STALL_PTR is greater than the T<b>0</b>_TAIL_PTR then there is not enough room in the queue to allocate the require entries for thread <b>0</b>. If there is not enough room to allocate the required entries or if T<b>0</b>_CLEAR is activated then the process proceeds to block <b>1447</b> to activate the stall signal for thread <b>0</b>, T<b>0</b>_STALL (also referred to as ALstallT<b>0</b>). Otherwise the process proceeds to block <b>1443</b> to deactivate the stall signal for thread <b>0</b>. The process then proceeds from either block <b>1443</b> or block <b>1447</b> to block <b>1451</b>. At decision block <b>1451</b>, if T<b>0</b>_STALL is not active then the process proceeds to block <b>1455</b> to allocate the required entries in the queue and update the T<b>0</b>_HEAD_PTR to reflect the allocation made. Otherwise the process proceeds to block <b>1459</b> to restore the previous value of the T<b>0</b>_STALL_PTR in preparation for the next round of resource computation and allocation for thread <b>0</b>. The process then proceeds from either block <b>1455</b> or block <b>1459</b> to end at block <b>1491</b>.</p>\n<p num=\"p-0083\">It should be noted that while the process is described in a sequential manner, many of the tasks performed by the process do not need to be done sequentially and can be done in parallel or in a different order provided that there is no logical dependencies between those tasks.</p>\n<p num=\"p-0084\"><figref idrefs=\"DRAWINGS\">FIG. 15</figref> shows a flow diagram of one embodiment of the resource computation and resource allocation process for thread <b>1</b> according to the teachings of the present invention.</p>\n<p num=\"p-0085\">As explained above, after the CRNuke signal is asserted and the Nuke event is done with respect to thread <b>0</b> and thread <b>1</b>, the associated pointers for each resource are initialized to the appropriate values depending on whether the processor is to run in ST mode or MT mode.</p>\n<p num=\"p-0086\">The process begins at block <b>1501</b> and proceeds to block <b>1505</b> to set the T<b>1</b>_PREV_STALL_PTR to be equal to the current T<b>1</b>_STALL_PTR. The process then proceeds to block <b>1509</b> to select Q\u22121 as the end of queue value for thread <b>1</b>. The process then continues to block <b>1521</b> to compute the number of entries needed for this set of input UOPs. The process proceeds to block <b>1525</b> to compute the new value for the T<b>1</b>_STALL_PTR. In one embodiment, the T<b>1</b>_STALL_PTR is incremented by the number of entries computed in block <b>1521</b> to obtain the new value for T<b>1</b>_STALL_PTR. For example, T<b>1</b>_STALL_PTR=T<b>1</b>_STALL_PTR+R_CNT where R_CNT is the number of entries needed that is computed in block <b>1521</b>. At decision block <b>1533</b>, the process proceeds to block <b>1537</b>, if T<b>1</b>_STALL_PTR advances past the corresponding EOQ. Otherwise the process continues to block <b>1539</b>. Since the queue to be allocated here is configured as a circular queue, once the T<b>1</b>_STALL_PTR advances past the EOQ it needs to be wrapped around and its corresponding wrap bit needs to be toggled accordingly. For example, if the T<b>1</b>_STALL_PTR=EOQ then the T<b>1</b>_STALL_PTR is wrapped around to Q/2, which is the start of the corresponding portion of the queue reserved for thread <b>1</b>. If the T<b>1</b>_STALL_PTR=EOQ+1, then the T<b>1</b>_STALL_PTR is wrapped around to Q/2+1, which is the start of the corresponding portion of the queue plus 1, and so on. The process then proceeds from block <b>1537</b> to block <b>1539</b>. At block <b>1539</b>, the T<b>1</b>_STALL_PTR is compared with T<b>1</b>_TAIL_PTR taken into consideration the values of their corresponding wrap bits to determine whether there are enough free entries in the queue to allocate the entries required. In one embodiment, if the wrap bit for T<b>1</b>_STALL_PTR is 1, the wrap bit for T<b>1</b>_TAIL_PTR is 0 and the T<b>1</b>_STALL_PTR is greater than the T<b>1</b>_TAIL_PTR then there is not enough room in the queue to allocate the require entries for thread <b>1</b>. If there is not enough room in the queue to allocate the required entries or if the T<b>1</b>_CLEAR signal is activated, the process proceeds to block <b>1547</b> to activate the stall signal for thread <b>1</b>, T<b>1</b>_STALL (also referred to as ALstallT<b>1</b>). Otherwise the process proceeds to block <b>1543</b> to deactivate the stall signal for thread <b>1</b>. The process then proceeds from either block <b>1543</b> or block <b>1547</b> to block <b>1551</b>. At decision block <b>1551</b>, if T<b>1</b>_STALL is not active then the process proceeds to block <b>1555</b> to allocate the required entries in the queue and update the T<b>1</b>_HEAD_PTR to reflect the allocation made. Otherwise the process proceeds to block <b>1559</b> to restore the previous value of the T<b>1</b>_STALL_PTR in preparation for the next round of resource computation and allocation for thread <b>1</b>. The process then proceeds from either block <b>1555</b> or block <b>1559</b> to end at block <b>1591</b>.</p>\n<p num=\"p-0087\">It should be noted that while the process is described in a sequential manner, many of the tasks performed by the process do not need to be done sequentially and can be done in parallel or in a different order provided that there is no logical dependencies between those tasks.</p>\n<p num=\"p-0088\"><figref idrefs=\"DRAWINGS\">FIG. 16</figref> shows a block diagram of one embodiment of an apparatus for performing the stall computation for thread <b>0</b> and thread <b>1</b>. In this embodiment, the stall computation for both thread <b>0</b> and thread <b>1</b> are done in parallel in every clock cycle even though resource allocation is performed for one thread at a time. In the discussion that follows, thread <b>0</b> will also be referred to as the blue thread and thread <b>1</b> will also be referred to as the red thread. Accordingly, various operations or pointers associated with thread <b>0</b> will also be referred to as the \u201cblue\u201d operations or \u201cblue\u201d pointers, for example T<b>0</b>_STALL_PTR will also be referred to as the BLUESTALLPTR. Similarly, various operations or pointers associated with thread <b>1</b> will also be referred to as the \u201cred\u201d operations or \u201cred\u201d pointers, for example T<b>1</b>_STALL_PTR will also be referred to as the REDSTALLPTR. In addition, the discussion below will focus on the operations and computations with respect to thread <b>0</b> (the blue thread) although everything discussed herein equally applies to the other thread (thread <b>1</b> or the red thread).</p>\n<p num=\"p-0089\">In one embodiment, the stall computation unit shown in <figref idrefs=\"DRAWINGS\">FIG. 16</figref> can contain several logical blocks that operate together to perform the stall computation with respect to a particular thread, e.g., thread <b>0</b>, and to activate the appropriate stall signal if certain conditions are satisfied. These logical blocks include: a first block that performs UOP decoding and counting to determine the number of entries required in a particular resource to execute the input UOPs; a second block that computes the available entries in the resource; a third block that contains stall conditions related to CRClear or CRNuke conditions that are driven from state machines; a fourth block that performs stall pointer computation that needs to be evaluated and used in the stall computation in the next clock. A detailed description of the fourth block is provided below with respect to FIG. <b>17</b>. In this embodiment, as mentioned above, the stall computation for both thread <b>0</b> and thread <b>1</b> are done in parallel in every clock cycle even though resource allocation is performed for one thread at a time.</p>\n<p num=\"p-0090\">Referring again to <figref idrefs=\"DRAWINGS\">FIG. 16</figref>, a set of three input UOPs and their corresponding valid bits <b>1607</b> are inputted into a basic decode logic <b>1613</b>. The basic decode logic <b>1613</b> decodes the input UOPs and provides the decoded information to a counting logic <b>1617</b> that counts the number of entries required based upon the types of the input UOPs. The outputs from the counting logic <b>1617</b> are then latched by the latching device <b>1621</b> which provides the appropriate select signals to the selector <b>1637</b> based upon the number of entries required as determined by the counting logic <b>1617</b>. As shown in <figref idrefs=\"DRAWINGS\">FIG. 16</figref>, the three inputs C<b>0</b>, C<b>1</b>, and C<b>2</b> of the latching device <b>1621</b> are set as follows by the counting logic <b>1617</b>: C<b>0</b> is set to 1 if there is exactly one entry required; C<b>1</b> is set to 1 if there are exactly two entries required; and C<b>2</b> is set to 1 if there are exactly three entries required.</p>\n<p num=\"p-0091\">Referring again to <figref idrefs=\"DRAWINGS\">FIG. 16</figref>, the second block, also referred to as the resource availability block, computes the number of available entries in the resource as follows. Since the three input UOPs <b>1607</b> may require up to three entries in the resource for their execution, there are three different scenarios that need to be considered. The first scenario is that the number of entries required by the input UOPs is one and the resource has at least one free entry to allocate which is sufficient. The second scenario is that the number of entries required by the input UOPs is two and the resource has at least two free entries to allocate which is sufficient. The third scenario is that the number of entries required is three and the resource has at least three free entries to allocate which is sufficient. Accordingly, the subtract logic <b>1631</b>, subtract logic <b>1633</b>, and the subtract logic <b>1635</b> are performed in parallel to compare three different values of the stall pointer with the value of the tail pointer taken into consideration the values of the wrap bits associated with these two pointers to determine the resource availability with respect to the three scenarios described above. The values of the wrap bits need to be considered because the resource is structured as a circular queue in this example, as described above. The subtract logic <b>1631</b> compares the value of the current stall pointer plus one (StallPtr+1) with the value of the tail pointer <b>1629</b>, taken into consideration the values of the corresponding wrap bits. The output of the subtract logic <b>1631</b> is set to low if there is at least one free entry in the resource to allocate. If there are no free entries in the resource, then the output of the subtract logic <b>1631</b> is set to high. Similarly, the output of the subtract logic <b>1633</b> is set to low if there are at least two free entries in the resource to allocate and is set to high otherwise. Likewise, the output of the subtract logic <b>1635</b> is set to low if there are at least three free entries in the resource to allocate and set to high otherwise. The outputs from the subtract logic <b>1631</b>, subtract logic <b>1633</b>, and the subtract logic <b>1635</b> are then inputted into the selector <b>1637</b>. The selector <b>1637</b> selects either the output from subtract logic <b>1631</b>, the output from the subtract logic <b>1633</b>, or the output from the subtract logic <b>1635</b>, depending on the select input signals from the latching device <b>1621</b>. If the input UOPs require only one entry, then C<b>0</b> is set to high which causes the selector <b>1637</b> to select the output from the subtract logic <b>1631</b>. If the input UOPs require only two entries, then C<b>1</b> is set to high which causes the selector <b>1637</b> to select the output from the subtract logic <b>1633</b>. If the input UOPs require three entries, then C<b>2</b> is set to high which causes the selector <b>1637</b> to select the output from the subtract logic <b>1635</b>. If no entry is required by the input UOPs, then C<b>0</b>, C<b>1</b>, and C<b>2</b> are all set to low which causes the selector <b>1637</b> to select a low value as its output. The selector <b>1637</b>, based upon the select signals representing the number of entries required by the input UOPs and the signals representing the number of entries available in the resource, generates a corresponding signal indicating whether the resource has sufficient available entries. As an example, assuming that the input UOPs require only one entry. In this case, the counting logic <b>1617</b> will set the C<b>0</b> input of the latching device <b>1621</b> which will cause the selector <b>1637</b> to select the output from the subtract logic <b>1631</b>. In this case, there can be two possible outcomes depending on whether the resource has at least one free entry to allocate. As described above, if the resource has at least one free entry then the output of the subtract logic <b>1631</b> is set to low, otherwise it is set to high. If the output of the subtract logic <b>1631</b> is set to low, there is at least one free entry in the resource and that is sufficient because the input UOPs only require one entry in this example. If the output of the subtract logic <b>1631</b> is set to high, the resource is full and the required entry cannot be allocated in this example, which is a stall condition. As shown in <figref idrefs=\"DRAWINGS\">FIG. 16</figref>, the output of the selector is inputted into the OR gate <b>1651</b>. The output of the selector <b>1637</b> represents a stall condition due to insufficient. resource. Accordingly, if the output of the selector <b>1637</b> is set to high, the stall signal for thread <b>0</b> will be activated.</p>\n<p num=\"p-0092\">As described above, the third block contains other stall conditions such as CRClear and CRNuke conditions. The signals representing CRClear conditions <b>1643</b>, <b>1645</b>, and the CRNuke condition <b>1647</b> are also inputted into the OR gate <b>1651</b>. In addition, the signals representing resource stall computations with respect to other resources are also inputted into the OR gate <b>1651</b>. Accordingly, the stall signal for thread <b>0</b> will be activated if any one of the input signals to the OR gate <b>1651</b> is set.</p>\n<p num=\"p-0093\"><figref idrefs=\"DRAWINGS\">FIG. 17</figref> is a block diagram of one embodiment of an apparatus for updating the value of the stall pointer for thread <b>0</b> (the blue thread) based upon various conditions discussed below. Everything discussed herein is equally applicable to thread <b>1</b> (the red thread) stall pointer update functionality. In this embodiment, there are three stall pointers that are maintained for each queue: one stall pointer for thread <b>0</b> (the blue stall pointer), one stall pointer for thread <b>1</b> (the red stall pointer), and one stall pointer for the working thread. In one embodiment, it is assumed in every clock that the machine would not stall and so the next stall pointer to be used for the stall computation would be set as if the allocation were done successfully. If stall is in fact activated, the stall pointer will be restored back to its previous value to reflect that no allocation is made in the last clock.</p>\n<p num=\"p-0094\">As shown in <figref idrefs=\"DRAWINGS\">FIG. 17</figref>, the new value of the stall pointer for thread <b>0</b> (also referred to as T<b>0</b>_STALL_PTR or BlueStallPtr) <b>1791</b> can be set or updated to different values by the selector <b>1781</b> based upon the select signals <b>1777</b> and <b>1779</b>. Basically, the value of the BlueStaUlPtr is updated based on three different scenarios according to the values of the select signals <b>1777</b> and <b>1779</b>. In the first scenario, the selector <b>1781</b> will select, as the BlueStallPtr <b>1791</b>, the output of the selector <b>1767</b> if the second select signal <b>1779</b> is set. The select signal <b>1779</b> is set according to the Nuke Done signal <b>1701</b>. In this case, when the Nuke Done signal <b>1701</b> is set, the BlueStallPtr <b>1791</b> is initialized to its appropriate starting value, which is zero in either ST mode or MT mode. As described above, thread <b>0</b> pointers and thread <b>1</b> pointers are initialized to point to their corresponding portions of the queue based upon whether the current processing mode is ST or MT. For example, if the current processing mode is ST, the end of queue with respect to thread <b>0</b> (the blue thread) will be set to Q\u22121 by the selector <b>1733</b>. If the current processing mode is MT, the end of queue with respect to thread <b>0</b> (the blue thread) will be set to Q/2\u22121 by the selector <b>1733</b>.</p>\n<p num=\"p-0095\">In the second scenario, the selector <b>1781</b> will select the value of the previous stall pointer for thread <b>0</b> (PrevStallPtr) <b>1711</b> as the value for the BlueStallPtr <b>1791</b> if the first select signal <b>1777</b> is set and the second select signal <b>1779</b> is not set. Therefore, in this scenario, the BlueStallPtr <b>1791</b> is restored back to its previous value if the Nuke Done signal is not set and any of the following stall conditions is present: Clear Blue, WaitFlash Blue, Stall Blue, Stall Blue+1, etc. All of these different stall conditions are input to the OR gate <b>1723</b> the output of which is used as the select signal <b>1777</b>. As explained above, once it is determined that the stall signal is active, the stall pointer needs to be restored back to its previous stall value to reflect the fact that no allocation was made in the last clock.</p>\n<p num=\"p-0096\">In the third scenario, the selector <b>1781</b> will select the output of the selector <b>1771</b> as the new value for the BlueStallPtr <b>1791</b> if both select signals <b>1777</b> and <b>1779</b> are not set, i.e., if there is no nuke event and none of the stall conditions for thread <b>0</b> is present. In this case, if the blue thread is the current working thread, then the BlueStallPtr <b>1791</b> will be incremented by a value corresponding to the number of required entries to be allocated, assuming that the queue has sufficient available entries to allocate the number of entries required by the input UOPs. Since the queue in this example is circular, the BlueStallPtr may be wrapped around if it advances past the end of its corresponding portion in the queue. Since the input UOPs may require from 0 to 3 entries in the queue for their execution, the StallPtr <b>1719</b> which represents the current value of the BlueStallPtr <b>1791</b> may be advanced by 0, 1, 2, or 3. To enable fast computation for the new value of the BlueStallPtr <b>1791</b>, the four possible different values of the StallPtr <b>1719</b> are computed separately and compared against the appropriate value of the blue thread end of queue (EOQ) in parallel to determine whether wrapping around is needed. The selector <b>1737</b> will select either <b>0</b> or StallPtr+1 depending on whether StaRPtr+1 is greater than the EOQ. If the StallPtr+1 is not greater than EOQ, then there is no wrap around. If the StallPtr+1 is greater than EOQ, then it is wrapped around to point to 0, the beginning of the queue. Similarly, the selector <b>1739</b> will select either 0, 1, or StallPtr+2 depending on whether StallPtr+2 is greater than the EOQ. If StallPtr+2 is not greater than the EOQ, then there is no wrap around. If StallPtr+2 goes past the EOQ by 1, then it is wrapped around to point to 0, the beginning of the queue. If the StallPtr+2 goes past the queue by 2, then it is wrapped around to point to 1. Likewise, the selector <b>1741</b> will select either 0, 1, 2, or StallPtr+3 depending on whether the StallPtr+3 is greater than the EOQ. The outputs of the selectors <b>1737</b>, <b>1739</b>, and <b>1741</b> are then inputted to the selector <b>1771</b>. The selector <b>1771</b> will select either the unchanged value of the StallPtr, the output of the selector <b>1737</b>, the output of the selector <b>1739</b>, or the output of the selector <b>1741</b>, based upon the select signal provided by the latching device <b>1749</b>. Accordingly, if the input UOPs <b>1721</b> require no entry in the queue, then the current value (unchanged) of the StallPtr <b>1719</b> will be selected as the new value for the BlueStallPtr <b>1791</b>. If the input UOPs require <b>1</b> entry, then either StallPtr+1 or its corresponding wrapped around value will be selected as the new value for BlueStallPtr <b>1791</b>. If the input UOPs require <b>2</b> entries, then either StallPtr+2 or its corresponding wrapped around value will be selected as the new value for the BlueStallPtr <b>1791</b>. Finally, if the input UOPs require <b>3</b> entries, then either StallPtr+3 or its corresponding wrapped around value will be selected as the new value for the BlueStallPtr <b>1791</b>.</p>\n<p num=\"p-0097\">In summary, the new value for the BlueStallPtr <b>1791</b> is updated as follows for the three different scenarios described above:</p>\n<p num=\"h-0006\">Scenario 1: When NUKE DONE signal is asserted indicating that the Nuke event is done.</p>\n<p num=\"p-0098\">\n</p><ul>\n<li id=\"ul0001-0001\" num=\"0000\">\n<ul>\n<li id=\"ul0002-0001\" num=\"0097\">BlueStallPtr=0\n<br/>\nScenario 2: When NUKE DONE is not asserted and at least one stall condition (e.g., stall due to insufficient resource, stall due to CRClear, etc.) is present with respect to the blue thread.\n</li>\n<li id=\"ul0002-0002\" num=\"0098\">BlueStallPtr=PrevStallPtr\n<br/>\nScenario 3: When NUKE DONE is not asserted and there is no stall condition present with respect to the blue thread.\n</li>\n<li id=\"ul0002-0003\" num=\"0099\">If StallPtr+R_CNT is not greater than the EOQ for the blue thread then\n        <ul><li id=\"ul0003-0001\" num=\"0100\">BlueStallPtr=StallPtr+R_CNT else</li><li id=\"ul0003-0002\" num=\"0101\">BlueStallPtr=Wrap-Around(StallPtr+R_CNT)</li></ul>\n</li>\n<li id=\"ul0002-0004\" num=\"0102\">where R_CNT is the number of entries required by the input UOPs.</li>\n</ul>\n</li>\n</ul>\n<p num=\"p-0099\"><figref idrefs=\"DRAWINGS\">FIG. 18</figref> shows a block diagram of one embodiment of an apparatus for updating the allocation pointer used to allocate the required entries for the working thread. In one embodiment, as described above, only one thread can allocate in any given clock cycle even though stall computations are performed for both threads in every clock cycle. Therefore, the head pointers associated with a particular thread can be advanced or updated only in the clock cycle in which resource allocation is performed for that particular thread. The head pointers for a particular thread, for example thread <b>0</b>, will not be advanced in the clock cycle in which either CRClear signal or any other stall condition is asserted with respect to that particular thread to reflect that no allocation is made in that clock cycle. On CRNuke, after the state in the RAT <b>301</b> has been recovered for both threads and all marbles for both threads have been freed, the head pointers will be updated to point back to the appropriate locations in the queue based on the processing mode after CRNuke is done. If the new processing mode or new configuration is ST, then either the head pointers for thread <b>0</b> or the head pointers for thread <b>1</b> will be updated to point to the beginning of the queues, depending on whether thread <b>0</b> or thread <b>1</b> is the working thread in the ST mode. If the new processing mode is MT, then the head pointers for both threads <b>0</b> and <b>1</b> will be updated. In this case, the head pointers for thread <b>0</b> will be updated to point to the beginning of the queues whereas the head pointers for thread <b>1</b> will be updated to point to the middle of the queues.</p>\n<p num=\"p-0100\">In one embodiment, there are three head pointers associated with each resource or queue: one head pointer for thread <b>0</b> (also referred to as T<b>0</b>_HEAD_PTR or BlueHead), one head pointer for thread <b>1</b> (also referred to as T<b>1</b>_HEAD_PTR or Redhead), and one head pointer to be used for the current working thread (referred to as HEAD_PTR or Head Ptr). In one embodiment, a thread bit indicating the current working thread will be used in addition to the working head pointer to select the appropriate entries in the queue to be allocated for the input UOPs.</p>\n<p num=\"p-0101\">Referring to <figref idrefs=\"DRAWINGS\">FIG. 18</figref>, the new value for the Head Ptr <b>1891</b> can be set or updated to different values based on different scenarios according to the current allocation thread ID <b>1801</b> and the current stall thread ID <b>1851</b>. The current allocation thread ID <b>1801</b> is used to indicate the particular thread being allocated in the current clock cycle, i.e., the working thread. The current stall thread ID <b>1851</b> is used to indicate the particular thread that will be allocated in the next clock cycle since stall computation is computed ahead of the allocation. The allocation thread ID <b>1801</b> and the stall thread ID <b>1851</b> are inputted to a mutual exclusion logic <b>1871</b> which generates the appropriate select signals for the selector <b>1881</b> according to the values of the allocation thread ID <b>1801</b> and the stall thread ID <b>1851</b>. If both the allocation thread ID <b>1801</b> and the stall thread ID <b>1851</b> have the same values (e.g., both indicate blue or both indicate red), then the selector <b>1881</b> will select the output of the selector <b>1855</b> as the new value for the Head Ptr <b>1891</b>. If the allocation thread ID <b>1801</b> is red and the stall thread ID <b>1851</b> is blue, then the value of the head pointer for the blue thread (i.e., the BlueHead) <b>1860</b> will be selected as the new Head Ptr <b>1891</b>. If the allocation thread ID is blue and the stall thread ID is red, then the value of the head pointer for the red thread (i.e., the RedHead) <b>1865</b> will be selected as the new Head Ptr <b>1891</b>. The selector <b>1855</b> selects, as its output, either the output of the selector <b>1840</b>, the output of the selector <b>1845</b>, or the current value of the Head Ptr <b>1891</b>, based on the select signals that are generated by the AND gate <b>1830</b> and the OR gate <b>1835</b>. The two inputs to the AND gate <b>1830</b> are the two signals indicating that Nuke is done for the blue thread and Nuke is done for the red thread. Thus, the output of the AND gate is only set if both of these signals are asserted, i.e., nuke is done for both threads. There are four inputs to the OR gate <b>1835</b>. Accordingly, the output of the OR gate <b>1835</b> is set if any of its four inputs is set. The four inputs to the OR gate <b>1835</b> represent the different stall conditions for either the blue thread or the red thread which are selected accordingly by the selector <b>1825</b> based on the allocation thread ID <b>1801</b>.</p>\n<p num=\"p-0102\">Referring again to the selector <b>1855</b>, there are three different scenarios that can occur based on the select signals from the AND gate <b>1830</b> and the OR gate <b>1835</b>. In the first scenario, if the output of the AND gate <b>1830</b> is set then the output of the selector <b>1845</b> is selected as the output of the selector <b>1855</b>. In this case, the new value for the Head Ptr <b>1891</b> will be initialized to 0 or Q/2 depending on the current processing mode as indicated by the ST/MT signal <b>1822</b> and the allocation thread. In the second scenario, if the output of the AND gate <b>1830</b> is not set and the output of the OR gate <b>1835</b> is set, then the value of the Head Ptr <b>1891</b> is not updated. This is the case where the allocating thread is being stalled and therefore no allocation is made. Accordingly, the Head Ptr is not updated to reflect the fact that no allocation is made in the current clock cycle due to a stall condition.</p>\n<p num=\"p-0103\">In the third scenario, if both the outputs of the AND gate <b>1830</b> and the OR gate <b>1835</b> are not set, then the output of the selector <b>1840</b> will be selected as the new value for the Head Ptr <b>1891</b>. This is the case where there is no nuke event and there is no stall condition present and therefore the current Head Ptr <b>1891</b> needs to be advanced by a corresponding value to reflect the number of entries allocated in this clock cycle. Since the queue in this example is circular, if the value of the Head Ptr <b>1891</b> plus the count value <b>1808</b> is greater than the end of queue then it will be wrapped around. The selector <b>1840</b> will select as its output either the output of the adder <b>1826</b> or its corresponding wrap around value based on the result of the comparison generated by the compare logic <b>1827</b>. The output of the selector <b>1840</b> will then be selected as the new value for the Head Ptr <b>1891</b>.</p>\n<p num=\"p-0104\">The invention has been described in conjunction with the preferred embodiment. It is evident that numerous alternatives, modifications, variations and uses will be appreciated by those skilled in the art in fight of the foregoing description.</p>\n<?DETDESC description=\"Detailed Description\" end=\"tail\"?>\n</description>"}], "inventors": [{"first_name": "Darrell D.", "last_name": "Boggs", "name": ""}, {"first_name": "Shlomit", "last_name": "Weiss", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTEL CORPORATION"}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/318       20060101A I20060722RMEP"}, {"label": "G06F   9/46        20060101AFI20060523BHUS"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}, {"label": "G06F   9/30        20060101A I20080531RMEP"}], "national_classes": [{"primary": true, "label": "718104"}, {"primary": false, "label": "712E09071"}, {"primary": false, "label": "712E09027"}, {"primary": false, "label": "712E09035"}, {"primary": false, "label": "712E09053"}, {"primary": false, "label": "714100"}], "ecla_classes": [{"label": "G06F   9/38T6C"}, {"label": "G06F   9/30R5C"}, {"label": "G06F   9/38E4"}], "cpc_classes": [{"label": "G06F   9/30189"}, {"label": "G06F   9/5061"}, {"label": "G06F   9/30123"}, {"label": "G06F   9/3851"}, {"label": "G06F   9/3891"}, {"label": "G06F   9/5061"}, {"label": "G06F   9/3891"}, {"label": "G06F2209/507"}, {"label": "G06F2209/507"}, {"label": "G06F   9/3851"}, {"label": "G06F   9/30123"}, {"label": "G06F   9/30189"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1999-12-28", "application_date": "1999-12-28", "family_members": [{"ucid": "AU-1797201-A", "titles": [{"lang": "EN", "text": "Method and apparatus for managing resources in a multithreaded processor"}]}, {"ucid": "TW-554287-B", "titles": [{"lang": "EN", "text": "Method and apparatus for managing resources in a multithreaded processor"}]}, {"ucid": "HK-1047990-A1", "titles": [{"lang": "EN", "text": "Method and apparatus for managing resources in a multithreaded processor."}]}, {"ucid": "DE-10085363-T0", "titles": []}, {"ucid": "WO-2001048599-A1", "titles": [{"lang": "EN", "text": "METHOD AND APPARATUS FOR MANAGING RESOURCES IN A MULTITHREADED PROCESSOR"}, {"lang": "FR", "text": "PROCEDE ET DISPOSITIF DE GESTION DES RESSOURCES DANS UN PROCESSEUR MULTIFILIERE"}]}, {"ucid": "US-7051329-B1", "titles": [{"lang": "EN", "text": "Method and apparatus for managing resources in a multithreaded processor"}]}, {"ucid": "DE-10085363-B4", "titles": [{"lang": "EN", "text": "Method and device for managing resources in a multithreaded processor"}, {"lang": "DE", "text": "Verfahren und Einrichtung zum Verwalten von Ressourcen in einem Multithreaded-Prozessor"}]}, {"ucid": "DE-10085363-T1", "titles": [{"lang": "EN", "text": "Method and device for managing resources in a multithreaded processor"}, {"lang": "DE", "text": "Verfahren und Einrichtung zum Verwalten von Ressourcen in einem Multithreaded-Prozessor"}]}, {"ucid": "GB-2375202-A", "titles": [{"lang": "EN", "text": "Method and apparatus for managing resources in a multithreaded processor"}]}, {"ucid": "GB-2375202-B", "titles": [{"lang": "EN", "text": "Method and apparatus for managing resources in a multithreaded processor"}]}, {"ucid": "GB-0215189-D0", "titles": [{"lang": "EN", "text": "Method and apparatus for managing resources in a multithreaded processor"}]}]}