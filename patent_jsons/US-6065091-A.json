{"patent_number": "US-6065091-A", "publication_id": 72305504, "family_id": 25347893, "publication_date": "2000-05-16", "titles": [{"lang": "EN", "text": "Translation look-aside buffer slice circuit and method of operation"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11006835\" source=\"national office\"><p>For use in an x-86 processor having a physically-addressable cache and an associated translation look-aside buffer (primary TLB) that stores corresponding logical and physical addresses for addressing the cache, a circuit for increasing a retrieval speed of a line from the cache. In one embodiment, the circuit comprises: 1) a TLB slice, located proximate the cache, that contains copies of portions of the physical addresses stored in the primary TLB and returns one of the portions as a function of a portion of a logical address supplied thereto; and 2) a decoder, coupled to the TLB slice, that decodes the one of the portions to yield multiplexer selection signals, the TLB slice and the decoder cooperating to increase the retrieval speed by avoiding logic circuitry interposed between the primary TLB and the cache.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA38069814\"><p>For use in an x-86 processor having a physically-addressable cache and an associated translation look-aside buffer (primary TLB) that stores corresponding logical and physical addresses for addressing the cache, a circuit for increasing a retrieval speed of a line from the cache. In one embodiment, the circuit comprises: 1) a TLB slice, located proximate the cache, that contains copies of portions of the physical addresses stored in the primary TLB and returns one of the portions as a function of a portion of a logical address supplied thereto; and 2) a decoder, coupled to the TLB slice, that decodes the one of the portions to yield multiplexer selection signals, the TLB slice and the decoder cooperating to increase the retrieval speed by avoiding logic circuitry interposed between the primary TLB and the cache.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. For use in a processor having a physically-addressable cache and an associated translation look-aside buffer (primary TLB) that stores corresponding logical and physical addresses for addressing said cache, a circuit for increasing a retrieval speed of a line from said cache, comprising:<claim-text>a TLB slice, located substantially closer to said cache than is said primary TLB, that contains a copy of a portions of said physical addresses stored in said primary TLB and returns one of said portions as a function of a portion of a logical address supplied thereto; and</claim-text><claim-text>a decoder, coupled to said TLB slice, that decodes said one of said portions to yield multiplexer selection signals, said TLB slice and said decoder cooperating to increase said retrieval speed by avoiding logic circuitry interposed between said primary TLB and said cache.</claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. The circuit as recited in claim 1 wherein said TLB slice contains address bits A12 and A13 of said each of said physical addresses.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. The circuit as recited in claim 1 wherein said cache is a multi-way cache and said TLB slice is replicated for each way of said cache.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. The circuit as recited in claim 1 wherein said cache is divided into segments and said multiplexer selection signals are employed to select one of said segments.</claim-text></claim>"}, {"num": 5, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. For use in a processor having a physically-addressable cache and an associated translation look-aside buffer (primary TLB) that stores corresponding logical and physical addresses for addressing said cache, a circuit for increasing a retrieval speed of a line from said cache, comprising:<claim-text>means, located substantially closer to said cache than is said primary TLB for containing a copy of a portions of said physical addresses stored in said primary TLB, said containing means returning one of said portions as a function of a portion of a logical address supplied thereto; and</claim-text><claim-text>decoding means, coupled to said TLB slice, for decoding said one of said portions to yield multiplexer selection signals thereby to increase said retrieval speed by avoiding logic circuitry interposed between said primary TLB and said cache.</claim-text></claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. The circuit as recited in claim 5 wherein said containing means contains address bits A12 and A13 of said each of said physical addresses.</claim-text></claim>"}, {"num": 7, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. The circuit as recited in claim 5 wherein said cache is a multi-way cache and said containing means is replicated for each way of said cache.</claim-text></claim>"}, {"num": 8, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. The circuit as recited in claim 5 wherein said cache is divided into segments and said multiplexer selection signals are employed to select one of said segments.</claim-text></claim>"}, {"num": 9, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. For use in a processor having a physically-addressable cache and an associated translation look-aside buffer (primary TLB) that stores corresponding logical and physical addresses for addressing said cache, a method of increasing a retrieval speed of a line from said cache, comprising the steps of:<claim-text>copying portions of said physical addresses stored in said primary TLB into a TLB slice located substantially closer to said cache than is said primary TLB;</claim-text><claim-text>supplying a portion of a logical address to said TLB slice;</claim-text><claim-text>returning, from said TLB slice, one of said portions as a function thereof; and</claim-text><claim-text>decoding said one of said portions to yield multiplexer selection signals thereby to increase said retrieval speed by avoiding logic circuitry interposed between said primary TLB and said cache.</claim-text></claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. The method as recited in claim 9 wherein said step of copying comprises the step of copying address bits A12 and A13 of said each of said physical addresses.</claim-text></claim>"}, {"num": 11, "parent": 9, "type": "dependent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. The method as recited in claim 9 wherein said cache is a multi-way cache and said TLB slice is replicated for each way of said cache.</claim-text></claim>"}, {"num": 12, "parent": 9, "type": "dependent", "paragraph_markup": "<claim num=\"12\"><claim-text>12. The method as recited in claim 9 wherein said cache is divided into segments, said method further comprising the step of employing said multiplexer selection signals to select one of said segments.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"13\"><claim-text>13. A computer system, comprising:<claim-text>(a) a pipelined processor having at least one execution pipeline for executing instructions, said execution pipeline including ID (decode), AC (address calculation), and EX (execution) processing stages;</claim-text><claim-text>(b) system memory for storing data or instructions;</claim-text><claim-text>(c) a cache for storing portions of said data or ones of said instructions;</claim-text><claim-text>(d) a translation look-aside buffer (primary TLB) for translating logical addresses to physical addresses to address said cache;</claim-text><claim-text>(e) said processor including fetch logic that fetches said portions of said data or said ones of said instructions from said system memory and stores said portions in said cache; and</claim-text><claim-text>(f) said processor further including a circuit for increasing a retrieval speed of a line from said cache, including:<claim-text>(i) a TLB slice, located substantially closer to said cache than is said primary TLB, that contains a copy of a portions of said physical addresses stored in said primary TLB and returns one of said portions as a function of a portion of a logical address supplied thereto, and</claim-text><claim-text>(ii) a decoder, coupled to said TLB slice, that decodes said one of said portions to yield multiplexer selection signals, said TLB slice and said decoder cooperating to increase said retrieval speed by avoiding logic circuitry interposed between said primary TLB and said cache.</claim-text></claim-text></claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"14\"><claim-text>14. The system as recited in claim 13 wherein said TLB slice contains address bits A12 and A13 of said each of said physical addresses.</claim-text></claim>"}, {"num": 15, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"15\"><claim-text>15. The system as recited in claim 13 wherein said cache is a multi-way cache and said TLB slice is replicated for each way of said cache.</claim-text></claim>"}, {"num": 16, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"16\"><claim-text>16. The system as recited in claim 13 wherein said cache is divided into segments and said multiplexer selection signals are employed to select one of said segments.</claim-text></claim>"}, {"num": 17, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"17\"><claim-text>17. A method of operating a computer system, comprising the steps of:<claim-text>(a) applying power to a pipelined processor having at least one execution pipeline for executing instructions, said execution pipeline including ID (decode), AC (address calculation), and EX (execution) processing stages;</claim-text><claim-text>(b) storing data and instructions in system memory;</claim-text><claim-text>(c) fetching said data or said instructions from said system memory into a cache;</claim-text><claim-text>(d) addressing said cache with a translation look-aside buffer (primary TLB) containing logical and physical addresses; and</claim-text><claim-text>(e) executing said instructions in said processor, said processor further including a circuit for increasing a retrieval speed of a line from said cache, including:<claim-text>(i) a TLB slice, located substantially closer to said cache than is said primary TLB, that contains a copy of a portions of said physical addresses stored in said primary TLB and returns one of said portions as a function of a portion of a logical address supplied thereto, and</claim-text><claim-text>(ii) a decoder, coupled to said TLB slice, that decodes said one of said portions to yield multiplexer selection signals, said TLB slice and said decoder cooperating to increase said retrieval speed by avoiding logic circuitry interposed between said primary TLB and said cache.</claim-text></claim-text></claim-text></claim>"}, {"num": 18, "parent": 17, "type": "dependent", "paragraph_markup": "<claim num=\"18\"><claim-text>18. The method as recited in claim 17 wherein said TLB slice contains address bits A12 and A13 of said each of said physical addresses.</claim-text></claim>"}, {"num": 19, "parent": 17, "type": "dependent", "paragraph_markup": "<claim num=\"19\"><claim-text>19. The method as recited in claim 17 wherein said cache is a multi-way cache and said TLB slice is replicated for each way of said cache.</claim-text></claim>"}, {"num": 20, "parent": 17, "type": "dependent", "paragraph_markup": "<claim num=\"20\"><claim-text>20. The method as recited in claim 17 wherein said cache is divided into segments and said multiplexer selection signals are employed to select one of said segments.</claim-text></claim>"}, {"num": 21, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"21\"><claim-text>21. For use in a processor having a physically-addressable cache and an associated translation look-aside buffer (primary TLB) that stores corresponding logical and physical addresses for addressing said cache, a circuit for increasing a retrieval speed of a line from said cache, comprising:<claim-text>a TLB slice, located substantially closer to said cache than is said primary TLB, that contains sets of multiplexer selection bits that are a function of portions of said physical addresses stored in said primary TLB and returns one of said sets as a function of a portion of a logical address supplied thereto; and</claim-text><claim-text>a decoder, coupled to said TLB slice, that decodes said portions of said physical addresses stored in said primary TLB to generate said multiplexer selection bits for storage in said TLB slice, said TLB slice increasing said retrieval speed by avoiding logic circuitry interposed between said primary TLB and said cache.</claim-text></claim-text></claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim num=\"22\"><claim-text>22. The circuit as recited in claim 21 wherein said portions of said physical addresses stored in said primary TLB include address bits A12 and A13.</claim-text></claim>"}, {"num": 23, "parent": 21, "type": "dependent", "paragraph_markup": "<claim num=\"23\"><claim-text>23. The circuit as recited in claim 21 wherein said cache is a multi-way cache and said TLB slice is replicated for each way of said cache.</claim-text></claim>"}, {"num": 24, "parent": 21, "type": "dependent", "paragraph_markup": "<claim num=\"24\"><claim-text>24. The circuit as recited in claim 21 wherein said cache is divided into segments and said multiplexer selection signals are employed to select one of said segments.</claim-text></claim>"}, {"num": 25, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"25\"><claim-text>25. For use in a processor having a physically-addressable cache and an associated translation look-aside buffer (primary TLB) that stores corresponding logical and physical addresses for addressing said cache, a circuit for increasing a retrieval speed of a line from said cache, comprising:<claim-text>means, located substantially closer to said cache than is said primary TLB, for containing sets of multiplexer selection bits that are a function of portions of said physical addresses stored in said primary TLB, said containing means returning one of said sets as a function of a portion of a logical address supplied thereto; and</claim-text><claim-text>means, coupled to said containing means, for decoding said portions of said physical addresses stored in said primary TLB to generate said multiplexer selection bits for storage in said containing means thereby increasing said retrieval speed by avoiding logic circuitry interposed between said primary TLB and said cache.</claim-text></claim-text></claim>"}, {"num": 26, "parent": 25, "type": "dependent", "paragraph_markup": "<claim num=\"26\"><claim-text>26. The circuit as recited in claim 25 wherein said portions of said physical addresses stored in said primary TLB include address bits A12 and A13.</claim-text></claim>"}, {"num": 27, "parent": 25, "type": "dependent", "paragraph_markup": "<claim num=\"27\"><claim-text>27. The circuit as recited in claim 25 wherein said cache is a multi-way cache and said containing means is replicated for each way of said cache.</claim-text></claim>"}, {"num": 28, "parent": 25, "type": "dependent", "paragraph_markup": "<claim num=\"28\"><claim-text>28. The circuit as recited in claim 25 wherein said cache is divided into segments and said multiplexer selection signals are employed to select one of said segments.</claim-text></claim>"}, {"num": 29, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"29\"><claim-text>29. For use in a processor having a physically-addressable cache and an associated translation look-aside buffer (primary TLB) that stores corresponding logical and physical addresses for addressing said cache, a method of increasing a retrieval speed of a line from said cache, comprising the steps of:<claim-text>decoding portions of said physical addresses stored in said primary TLB;</claim-text><claim-text>generating sets of multiplexer selection bits for storage in a TLB slice located substantially closer to said cache than is said primary TLB, from said portions of said physical addresses; and</claim-text><claim-text>returning, from said TLB slice, one of said sets as a function of a portion of a logical address supplied thereto thereby to increase said retrieval speed by avoiding logic circuitry interposed between said primary TLB and said cache.</claim-text></claim-text></claim>"}, {"num": 30, "parent": 29, "type": "dependent", "paragraph_markup": "<claim num=\"30\"><claim-text>30. The method as recited in claim 29 wherein said step of decoding comprises the step of decoding address bits A12 and A13 of said each of said physical addresses.</claim-text></claim>"}, {"num": 31, "parent": 29, "type": "dependent", "paragraph_markup": "<claim num=\"31\"><claim-text>31. The method as recited in claim 29 wherein said cache is a multi-way cache and said TLB slice is replicated for each way of said cache.</claim-text></claim>"}, {"num": 32, "parent": 29, "type": "dependent", "paragraph_markup": "<claim num=\"32\"><claim-text>32. The method as recited in claim 29 wherein said cache is divided into segments, said method further comprising the step of employing said multiplexer selection signals to select one of said segments.</claim-text></claim>"}, {"num": 33, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"33\"><claim-text>33. A computer system, comprising:<claim-text>(a) a pipelined processor having at least one execution pipeline for executing instructions, said execution pipeline including ID (decode), AC (address calculation), and EX (execution) processing stages;</claim-text><claim-text>(b) system memory for storing data or instructions;</claim-text><claim-text>(c) a cache for storing portions of said data or ones of said instructions;</claim-text><claim-text>(d) a translation look-aside buffer (primary TLB) for translating logical addresses to physical addresses to address said cache;</claim-text><claim-text>(e) said processor including fetch logic that fetches said portions of said data or said ones of said instructions from said system memory and stores said portions in said cache; and</claim-text><claim-text>(f) said processor further including a circuit for increasing a retrieval speed of a line from said cache, including:<claim-text>(i) a TLB slice, located substantially closer to said cache than is said primary TLB, that contains sets of multiplexer selection bits that are a function of portions of said physical addresses stored in said primary TLB and returns one of said sets as a function of a portion of a logical address supplied thereto, and</claim-text><claim-text>(ii) a decoder, coupled to said TLB slice, that decodes said portions of said physical addresses stored in said primary TLB to generate said multiplexer selection bits for storage in said TLB slice, said TLB slice increasing said retrieval speed by avoiding logic circuitry interposed between said primary TLB and said cache.</claim-text></claim-text></claim-text></claim>"}, {"num": 34, "parent": 33, "type": "dependent", "paragraph_markup": "<claim num=\"34\"><claim-text>34. The system as recited in claim 33 wherein said portions of said physical addresses stored in said primary TLB include address bits A12 and A13.</claim-text></claim>"}, {"num": 35, "parent": 33, "type": "dependent", "paragraph_markup": "<claim num=\"35\"><claim-text>35. The system as recited in claim 33 wherein said cache is a multi-way cache and said TLB slice is replicated for each way of said cache.</claim-text></claim>"}, {"num": 36, "parent": 33, "type": "dependent", "paragraph_markup": "<claim num=\"36\"><claim-text>36. The system as recited in claim 33 wherein said cache is divided into segments and said multiplexer selection signals are employed to select one of said segments.</claim-text></claim>"}, {"num": 37, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"37\"><claim-text>37. A method of operating a computer system, comprising the steps of:<claim-text>(a) applying power to a pipelined processor having at least one execution pipeline for executing instructions, said execution pipeline including ID (decode), AC (address calculation), and EX (execution) processing stages;</claim-text><claim-text>(b) storing data and instructions in system memory;</claim-text><claim-text>(c) fetching said data or said instructions from said system memory into a cache;</claim-text><claim-text>(d) addressing said cache with a translation look-aside buffer (primary TLB) containing logical and physical addresses; and</claim-text><claim-text>(e) executing said instructions in said processor, said processor further including a circuit for increasing a retrieval speed of a line from said cache, including:<claim-text>(i) a TLB slice, located substantially closer to said cache than is said primary TLB, that contains sets of multiplexer selection bits that are a function of portions of said physical addresses stored in said primary TLB and returns one of said sets as a function of a portion of a logical address supplied thereto, and</claim-text><claim-text>(ii) a decoder, coupled to said TLB slice, that decodes said portions of said physical addresses stored in said primary TLB to generate said multiplexer selection bits for storage in said TLB slice, said TLB slice increasing said retrieval speed by avoiding logic circuitry interposed between said primary TLB and said cache.</claim-text></claim-text></claim-text></claim>"}, {"num": 38, "parent": 37, "type": "dependent", "paragraph_markup": "<claim num=\"38\"><claim-text>38. The method as recited in claim 37 wherein said portions of said physical addresses stored in said primary TLB include address bits A12 and A13.</claim-text></claim>"}, {"num": 39, "parent": 37, "type": "dependent", "paragraph_markup": "<claim num=\"39\"><claim-text>39. The method as recited in claim 37 wherein said cache is a multi-way cache and said TLB slice is replicated for each way of said cache.</claim-text></claim>"}, {"num": 40, "parent": 37, "type": "dependent", "paragraph_markup": "<claim num=\"40\"><claim-text>40. The method as recited in claim 37 wherein said cache is divided into segments and said multiplexer selection signals are employed to select one of said segments.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES318025275\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>TECHNICAL FIELD OF THE INVENTION</h4><p>The present invention is directed, in general, to microprocessors and, more specifically, to microprocessors that implement cache memories employing a translation look-aside buffer (TLB) slice to retrieve cached data.</p><h4>CROSS-REFERENCE TO RELATED APPLICATIONS</h4><p>The present invention is related to that disclosed in:</p><p>1. U.S. patent application Ser. No. 08/865,664 (Attorney Docket No. CYRX-0297), entitled \"CACHE CIRCUIT WITH PROGRAMMABLE SIZING AND METHOD OF OPERATION\" and filed concurrently herewith;</p><p>2. U.S. patent application Ser. No. 08/866,441 (Attorney Docket No. CYRX-0300), entitled \"SHADOW TRANSLATION LOOK-ASIDE BUFFER AND METHOD OF OPERATION\" and filed concurrently herewith; and</p><p>3. U.S. patent application Ser. No. 08/866,691 (Attorney Docket No. CYRX-0302), entitled \"HIT DETERMINATION CIRCUIT FOR SELECTING A DATA SET BASED ON MISS DETERMINATIONS IN OTHER DATA SETS AND METHOD OF OPERATION\" and filed concurrently herewith.</p><p>Each reference is commonly assigned with the present invention and is incorporated herein by reference for all purposes.</p><h4>BACKGROUND OF THE INVENTION</h4><p>The ever-growing requirement for high performance computers demands that state-of-the-art microprocessors execute instructions in the minimum amount of time. Over the years, efforts to increase microprocessor speeds have followed different approaches. One approach is to increase the speed of the clock that drives the processor. As the clock rate increases, however, the processor's power consumption and temperature also increase. Increased power consumption increases electrical costs and depletes batteries in portable computers more rapidly, while high circuit temperatures may damage the processor. Furthermore, processor clock speed may not increase beyond a threshold physical speed at which signals may traverse the processor. Simply stated, there is a practical maximum to the clock speed that is acceptable to conventional processors.</p><p>An alternate approach to improving processor speeds is to reduce the number of clock cycles required to perform a given instruction. Under this approach, instructions will execute faster and overall processor \"throughput\" will thereby increase, even if the clock speed remains the same. One technique for increasing processor throughput is pipelining, which calls for the processor to be divided into separate processing stages (collectively termed a \"pipeline\"). Instructions are processed in an \"assembly line\" fashion in the processing stages. Each processing stage is optimized to perform a particular processing function, thereby causing the processor as a whole to become faster.</p><p>\"Superpipelining\" extends the pipelining concept further by allowing the simultaneous processing of multiple instructions in the pipeline. Consider, for example, a processor in which each instruction executes in six stages, each stage requiring a single clock cycle to perform its function. Six separate instructions can be processed simultaneously in the pipeline, with the processing of one instruction completed during each clock cycle. Therefore, the instruction throughput of an N stage pipelined architecture is, in theory, N times greater than the throughput of a non-pipelined architecture capable of completing only one instruction every N clock cycles.</p><p>Another technique for increasing overall processor speed is \"superscalar\" processing. Superscalar processing calls for multiple instructions to be processed per clock cycle. Assuming that instructions are independent of one another (i.e., the execution of an instruction does not depend upon the execution of any other instruction), processor throughput is increased in proportion to the number of instructions processed per clock cycle (\"degree of scalability\"). If, for example, a particular processor architecture is superscalar to degree three (i.e., three instructions are processed during each clock cycle), the instruction throughput of the processor is theoretically tripled.</p><p>One of the most frequently employed techniques for increasing overall processor throughput is to minimize the number of cache misses and to minimize the cache access time in a processor that implements a cache memory. There is a wealth of information describing cache memories and the general theory of operation of cache memories is widely understood. This is particularly true of cache memories implemented in x86 microprocessor architectures. A cache memory is a small but very fast memory that holds a limited number of instructions and data for use by the processor. The lower the cache access time, the faster the processor can run. Also, the lower the cache miss rate, the less often the processor is stalled while the requested data is retrieved from main memory and the higher the processor throughput is. Many techniques have been employed to reduce the access time of cache memories. However, the cache access time is still limited by the rate at which data can be examined in, and retrieved from, the SRAM circuits that are internal to a conventional cache memory. This is in part due to the rate at which the translation look-aside buffer (TLB) translates logical memory addresses into physical memory addresses.</p><p>Therefore, there is a need in the art for improved cache memories that maximize processor throughput. More particularly, there is a need in the art for improved cache memories having a reduced access time. There also is a need for improved cache memories that are not limited by the rate at which data can be examined and retrieved from the SRAM circuits in the cache memories. Finally, there is a need in the art for cache memories implementing an improved TLB that more rapidly translates logical memory addresses into physical memory addresses.</p><h4>SUMMARY OF THE INVENTION</h4><p>To address the above-discussed deficiencies of the prior art, the present invention provides, for use in an x-86 processor having a physically-addressable cache and an associated translation look-aside buffer (primary TLB) that stores corresponding logical and physical addresses for addressing the cache, a circuit for increasing a retrieval speed of a line from the cache, comprising: 1) a TLB slice, located proximate the cache, that contains copies of portions of the physical addresses stored in the primary TLB and returns one of the portions as a function of a portion of a logical address supplied thereto; and 2) a decoder, coupled to the TLB slice, that decodes the one of the portions to yield multiplexer selection signals, the TLB slice and the decoder cooperating to increase the retrieval speed by avoiding logic circuitry interposed between the primary TLB and the cache.</p><p>The present invention therefore introduces the broad concept of using a smaller and faster TLB slice which contains a subset of the information in the primary TLB to more quickly generate line selection signals for use in the cache.</p><p>In one embodiment of the present invention, the TLB slice contains address bits A12 and A13 of each of the physical addresses.</p><p>In another embodiment of the present invention, the cache is a multi-way cache and the TLB slice is replicated for each way of the cache.</p><p>In another embodiment of the present invention, the cache is divided into segments and the multiplexer selection signals are employed to select one of the segments.</p><p>The foregoing has outlined, rather broadly, preferred and alternative features of the present invention so that those skilled in the art may better understand the detailed description of the invention that follows. Additional features of the invention will be described hereinafter that form the subject of the claims of the invention. Those skilled in the art should appreciate that they can readily use the disclosed conception and specific embodiment as a basis for designing or modifying other structures for carrying out the same purposes of the present invention. Those skilled in the art should also realize that such equivalent constructions do not depart from the spirit and scope of the invention in its broadest form.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>For a more complete understanding of the present invention, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:</p><p>FIG. 1 is a block diagram of an exemplary system employing a processor in accordance with the principles of the present invention;</p><p>FIG. 2 is a more detailed block diagram of the processor depicted in FIG. 1, which employs cache line locking in accordance with the principles of the present invention;</p><p>FIG. 3 is a more detailed block diagram of the pipelined stages of the Integer Unit depicted in FIG. 2;</p><p>FIGS. 4A and 4B depict a preferred system register set, comprising registers not generally visible to application programmers and typically employed by operating systems and memory management programs;</p><p>FIG. 5 depicts an exemplary cache unit in accordance with the principles of the present invention;</p><p>FIG. 6 depicts the exemplary L1 cache in FIG. 2 in greater detail;</p><p>FIG. 7 depicts an improved L1 cache divided into sectors according to one embodiment of the present invention;</p><p>FIG. 8 depicts a conventional L1 TLB for translating linear addresses for the L1 cache;</p><p>FIG. 9 depicts a conventional L2 TLB for translating linear addresses for the external L2 cache;</p><p>FIG. 10 depicts an improved tag array in the L1 cache, wherein a shadow L1 TLB is integrated into the sectors of the tag array, according to one embodiment of the present invention;</p><p>FIG. 11 illustrates an L1 TLB slice according to one embodiment of the present invention; and</p><p>FIG. 12 illustrates an L1 TLB slice according to another embodiment of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION</h4><p>The detailed description of the preferred embodiment for the present invention is organized as follows:</p><p>1. Exemplary Computing System</p><p>2. Exemplary Processor</p><p>2.1 Core</p><p>2.1.1 The Integer Unit</p><p>2.1.2 Out-of-Order Processing</p><p>2.1.3 Pipeline Selection</p><p>2.1.4 Register Renaming</p><p>2.1.5 Data Forwarding</p><p>2.1.5.1 Operand Forwarding</p><p>2.1.5.2 Result Forwarding</p><p>2.1.6 Data Bypassing</p><p>2.1.7 Branch Control</p><p>2.1.8 Speculative Execution</p><p>2.1.9 System Register Set</p><p>2.1.9.1 Model Specific Registers</p><p>2.1.9.2 Debug Registers</p><p>2.1.9.3 Test Registers</p><p>2.1.10 The Floating Point Unit</p><p>2.2 Cache Unit</p><p>This organizational table, and the corresponding headings used in this detailed description, are provided for convenient reference and are not intended to limit the scope of the present invention. It should be understood that while the preferred embodiment is described below with respect to x86 computer architecture, it has general applicability to any architecture. Certain terms related to x86 computer architecture (such as register names, signal nomenclature, etc.), which are known to practitioners in the field of processor design, are not discussed in detail in order not to obscure the disclosure.</p><p>Moreover, certain structural details, which will be readily apparent to those skilled in the art, having the benefit of the description herein, have been illustrated in the drawings by readily understandable block representations and state/flow diagrams that show and describe details that are pertinent to the present invention. These illustrations do not necessarily represent the physical arrangement of the exemplary system, but are primarily intended to illustrate the major structural components in convenient functional groups, so that the present invention may be more readily understood. It is to be understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the present invention.</p><h4>1. EXEMPLARY COMPUTING SYSTEM</h4><p>FIG. 1 is a block diagram of an exemplary computer system 10 employing a processor in accordance with the principles of the present invention. The exemplary computer system 10 comprises a system circuit board (a.k.a. motherboard) 100 and various peripherals and peripheral interfaces. Motherboard 100 comprises a processor 200 and memory subsystem 400 inter-coupled by a processor P-Bus (sometimes referred to as a CPU or local Bus). System logic circuitry interfaces the processor 200 to three conventional peripheral buses namely: X-Bus, PCI-Bus, and ISA-Bus. For the exemplary computer system, the P-Bus is compliant with the so-called \"P55C socket.\"</p><p>System logic circuitry comprises a system chipset 601 and a datapath chipset 602 (sometimes referred to as a North-Bridge and South-Bridge, respectively), as well as an external clock source 604 that provides an external clock input to the processor 200 and a system clock signal to the remainder of the motherboard 100. The external clock source 604 may take on many forms without departing from the scope of the present invention, including a digital or analog phase-locked loop or delay line loop circuitry. The exact details are not necessary for understanding the present invention.</p><p>Processor 200 and the memory subsystem 400 reside on the P-Bus. The only other direct connections to the P-Bus are the system chipset 601 and the datapath chipset 602. According to the exemplary division of system logic functions, the system chipset 601 interfaces to a conventional 32-bit PCI-Bus, while the datapath chipset 602 interfaces to the 16-bit ISA-Bus and the internal 8-bit X-Bus. In alternative embodiments, a special Advanced Graphics Port (AGP) may provide an interface between the P-Bus and a graphics accelerator.</p><p>Processor 200 is coupled over the P-Bus to L2 (level 2) cache 404 and through data buffers 406 to system memory 402 (DRAM). The system chipset 601 includes control circuitry for the P-Bus, system memory 402, and the L2 cache 404. The datapath chipset 602 also interfaces to the conventional X-Bus. The X-Bus is an internal 8-bit bus that couples to the BIOS ROM 702 and the real-time clock (RTC) 704. In addition, the X-Bus connects to a conventional 8-bit keyboard controller 706.</p><p>The system and datapath chipsets 601 and 602 provide interface control for the 16-bit ISA-Bus and the 32-bit PCI-Bus. The ISA-Bus maintains compatibility with industry standard peripherals via ISA-compliant peripheral card slots 710. The PCI-Bus provides a higher performance peripheral interface via PCI-compliant peripheral card slots 810 for selected peripherals, such as a video/graphics card 802 and a storage controller 804 (which may be included as part of the system chipset 601) for interfacing to mass storage 906.</p><p>The motherboard 100 is coupled to external peripherals 900, such as keyboard 902, display 904, and mass storage 906 through the PCI-, ISA-, and X-Buses. Network and modem interconnections are provided as ISA cards, but it is to be understood that they could also be provided as PCI cards.</p><h4>2. EXEMPLARY PROCESSOR</h4><p>FIG. 2 is a more detailed block diagram of the processor 200 depicted in FIG. 1, which employs cache line locking in accordance with the principles of the present invention. It is to be understood that other forms of the processor 200 may be utilized and other modifications can be made without departing from the scope and spirit of the present invention. The processor 200 consists of four major functional blocks, namely: 1) core 202, 2) cache unit 204, 3) memory management unit (MMU) 206, and 4) bus interface unit (BIU) 208.</p><h4>2.1 CORE</h4><p>The core 202 comprises a super-pipelined integer unit (IU) 215, a branch target buffer (BTB) 220, and a floating point unit (FPU) 225. The cache unit 204 comprises a 64 Kbyte unified L1 cache 245 that stores the most recently used data and instruction code and a 256 byte instruction line cache 240 that only stores instruction code. The MMU 206 preferably comprises two translation look-aside buffers (TLBs): a main level one (L1) TLB 230 and a larger level two (L2) TLB 235. The L1 TLB 230 is preferably direct mapped and has 16 entries, each entry holding one line of 42 bits. The L2 TLB 235 is preferably 6-way associative and has 384 entries to hold 384 lines.</p><p>The MMU 206 translates linear (or logical) addresses supplied by the IU 215 into physical addresses, including addresses based on paging, for use by the unified L1 cache 245 and for transmission through the BIU 208. Memory management procedures are preferably x86 compatible, adhering to standard paging mechanisms. The Page Table Entry (PTE) is stored in either the unified L1 cache in the Cache Unit 204, the L2 cache 404, or in system memory 404.</p><p>The Bus Interface Unit (BIU) provides the P-Bus interface. During a memory cycle, a memory location is selected through the address lines (A31-A3 and BE7#-BE0#) on the P-Bus. Data is passed to/from memory through the data lines (D63-D0) on the P-Bus.</p><p>The core 202 requests instructions from the cache unit 204. The received integer instructions are decoded by either the X-processing pipeline or Y-processing pipeline within the super-pipelined IU 215. If the instruction is a multimedia extension or FPU instruction, the instruction is passed to the FPU 225 for processing. As required, data is fetched from the 64 Kbyte unified L1 cache 245. If the data is not in the unified L1 cache 245, the data is accessed via the BIU 208 from either the L2 cache 404 or system memory 402.</p><h4>2.1.1 THE INTEGER UNIT</h4><p>FIG. 3 is a more detailed block diagram of the pipelined stages of the integer unit 215 depicted in FIG. 2. Parallel instruction execution is provided by two seven-stage integer pipelines, referred to as the X-pipeline and the Y-pipeline. Each of the X- and Y-pipelines can process several instructions simultaneously. The IU 215 comprises the following pipeline stages: Instruction Fetch (IF) 301, Instruction Decode 1 (ID1) 302, Instruction Decode 2 (ID2) 303, Address Calculation 1 (AC1) 304, Address Calculation 2 (AC2) 305, Execution 306, and Write-Back 307.</p><p>The IF 301 stage, shared by both the X- and Y-pipelines, fetches 16 bytes of code from the cache unit 204 in a single clock cycle. Within the IF 301 stage, the code stream is checked for any branch instructions that could affect normal program sequencing. If an unconditional or conditional branch is detected, branch prediction logic within the IF 301 stage generates a predicted target address for the instruction. The IF 301 stage then begins fetching instructions at the predicted address.</p><p>The super-pipelined Instruction Decode stage comprise the ID1 302 substage and ID2 303 substage. ID1, shared by both X- and Y-pipelines, evaluates the code stream provided by the IF 301 stage and determines the number of bytes in each instruction. Up to two instructions per clock are delivered to the ID2 substages, one in each pipeline.</p><p>The ID2 303 substage decodes instructions and sends the decoded instructions to either the X- or Y-pipeline for execution. The particular pipeline is chosen, based on which instructions are already in each pipeline and how fast they are expected to flow through the remaining pipe-line stages.</p><p>The Address Calculation stage comprises the AC1 304 sub-stage and the AC2 305 substage. If the instruction refers to a memory operand, the AC1 substage calculates a linear memory address for the instruction. The AC2 substage performs any required memory management functions, cache accesses, and register file accesses. If a floating point instruction is detected by the AC2 substage, the instruction is sent to the FPU 225 for processing. The Execution 306 stage executes instructions using the operands provided by the address calculation stage. The Write-Back 307 stage stores execution results either to a register file within the IU 215 or to a write buffer in the cache control unit.</p><h4>2.1.2 OUT-OF-ORDER PROCESSING</h4><p>If an instruction executes faster than the previous instruction in the other pipeline, the instructions may complete out of order. All instructions are processed in order, up to the Execution 306 stage. While in the Execution 306 and Write-Back 307 stages, instructions may be completed out of order. If there is a data dependency between two instructions, hardware interlocks are enforced to ensure correct program execution. Even though instructions may complete out of order, exceptions and writes resulting from the instructions are always issued in program order.</p><h4>2.1.3 PIPELINE SELECTION</h4><p>In most cases, instructions are processed in either pipeline and without pairing constraints on the instructions. However, certain instructions are preferably processed only in the X-pipeline, such as branch, floating point, and exclusive instructions. Branch and floating point instructions may be paired with a second instruction in the Y-pipeline. Exclusive instructions (e.g., protected mode segment loads, special control, debug, and test register accesses, string instructions, multiply and divide, I/O port accesses, push all and pop all, and inter-segment jumps, calls, and returns), which typically require multiple memory accesses, are preferably not paired with instructions in the Y-pipeline. Although exclusive instructions are not paired, hardware from both pipelines is used to accelerate instruction completion.</p><p>When two instructions that are executing in parallel require access to the same data or register, one of the following types of data dependencies may occur: Read-After-Write (RAW), Write-After-Read (WAR), and Write-After-Write (WAW). Data dependencies typically force serial execution of instructions. However, the processor 200 employs register renaming, data forwarding, and data bypassing mechanisms that allow parallel execution of instructions containing data dependencies.</p><h4>2.1.4 REGISTER RENAMING</h4><p>The processor 200 includes a register file containing 32 physical general purpose registers, each of which can be temporarily assigned as one of the general purpose registers defined by the x86 architecture (EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP). For each register write operation, a new physical register is selected to allow previous data to be retained temporarily--effectively removing WAW and WAR dependencies. The programmer does not have to consider register renaming, since register renaming is completely transparent to both the operating system and application software.</p><p>A WAR dependency exists when the first in a pair of instructions reads a logical register, and the second instruction writes to the same logical register. This type of dependency is illustrated by the pair of instructions shown below. In this and the following examples the original instruction order is shown in parentheses.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nX-PIPELINE          Y-PIPELINE                                            \n______________________________________                                    \n(1) MOV BX,AX       (2) ADD AX,CX                                         \nBX\u2190AX          AX\u2190AX\u2190CX                                    \n______________________________________                                    \n</pre><p>In the absence of register renaming, the ADD instruction in the Y-pipeline would have to be stalled to allow the MOV instruction in the X-pipeline to read the AX register. The processor 200, however, can avoid the Y-pipeline stall, as shown below in Table 1. As each instruction executes, the results are placed in new physical registers to avoid the possibility of overwriting a logical register value and to allow the two instructions to complete in parallel (or out of order) rather than in sequence.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 1                                                     \n______________________________________                                    \nRegister Renaming with WAR Dependency                                     \n        Physical Register                                                 \n        Contents                                                          \nInstruction                                                               \n        Reg0   Reg1   Reg2 Reg3 Reg4 Pipe Action                          \n______________________________________                                    \n(Initial)                                                                 \n        AX     BX     CX                                                  \nMOV     AX            CX   BX        X    Reg3\u2190Reg0                  \nBX,AX                                                                     \nADD AX,               CX   BX   AX   Y    Reg4\u2190Reg0+                 \nCX                                        Reg2                            \n______________________________________                                    \n</pre><p>The representations of the MOV and ADD instructions in the final column of Table 1 are completely independent.</p><p>A WAW dependency occurs when two consecutive instructions perform write operations to the same logical register. This type of dependency is illustrated by the pair of instructions shown below:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nX-PIPELINE         Y-PIPELINE                                             \n______________________________________                                    \n(1) ADD, AX, BX    (2) MOV AX, [mem]                                      \nAX\u2190AX+BX      AX\u2190[mem]                                          \n______________________________________                                    \n</pre><p>Without register renaming, the MOV instruction in the Y-pipeline would have to be stalled to guarantee that the ADD instruction in the X-pipeline would first write its results to the AX register. The processor 200, however, can avoid the Y-pipeline stall, as shown below in Table 2. The contents of the AX and BX registers are placed in physical registers. As each instruction executes, the results are placed in new physical registers to avoid the possibility of overwriting a logical register value and to allow the two instructions to complete in parallel (or out of order) rather than in sequence. All subsequent reads of the logical register AX will refer to Reg3, the result of the MOV instruction.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 2                                                     \n______________________________________                                    \nRegister Renaming with WAW Dependency                                     \n         Physical Register                                                \n         Contents                                                         \nInstruction                                                               \n         Reg0   Reg1   Reg2 Reg3 Pipe Action                              \n______________________________________                                    \n(Initial)                                                                 \n         AX     BX                                                        \nADD AX,BX       BX     AX        X    Reg2\u2190Reg0+Reg1                 \nMOV AX,         BX          AX   Y    Reg3\u2190[mem]                     \n[mem]                                                                     \n______________________________________                                    \n</pre><h4>2.1.5 DATA FORWARDING</h4><p>The processor 200 uses two types of data forwarding in conjunction with register renaming to eliminate RAW dependencies, namely, operand forwarding and result forwarding. Operand forwarding takes place when the first in a pair of instructions performs a move from register or memory, and the data that is read by the first instruction is required by the second instruction. The processor performs the read operation and makes the data read available to both instructions simultaneously. Result forwarding takes place when the first in a pair of instructions performs an operation (such as an ADD) and the result is required by the second instruction to perform a move to a register or memory. The processor 200 performs the required operation and stores the results of the operation to the destination of both instructions simultaneously.</p><h4>2.1.5.1 OPERAND FORWARDING</h4><p>A RAW dependency occurs when the first in a pair of instructions performs a write, and the second instruction reads the same register. This type of dependency is illustrated by the pair of instructions shown below in the X- and Y-pipelines:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nX-PIPELINE           Y-PIPELINE                                           \n______________________________________                                    \n(1) MOV AX, [mem]    (2) ADD BX,AX                                        \nAX\u2190[mem]        BX\u2190AX+BX                                        \n______________________________________                                    \n</pre><p>The processor 200, however, can avoid the Y-pipeline stall, as shown below in Table 3. Operand forwarding allows simultaneous execution of both instructions by first reading memory and then making the results available to both pipelines in parallel. Operand forwarding can only occur if the first instruction does not modify its source data. In other words, the instruction is a move type instruction (for example, MOV, POP, LEA). Operand forwarding occurs for both register and memory operands. The size of the first instruction destination and the second instruction source must match.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 3                                                     \n______________________________________                                    \nExample of Operand Forwarding                                             \n        Physical Register Contents                                        \nInstruction                                                               \n        Reg0   Reg1   Reg2 Reg3 Pipe Action                               \n______________________________________                                    \n(Initial)                                                                 \n        AX     BX                                                         \nMOV AX,        BX     AX        X    Reg2\u2190Reg2+[mem]                 \n[mem]                                                                     \nMOV AX,               AX   BX   Y    Reg3\u2190[mem]+Reg1                 \n[mem]                                                                     \n______________________________________                                    \n</pre><h4>2.1.5.2 RESULT FORWARDING</h4><p>A RAW dependency can occur when the first in a pair of instructions performs a write, and the second instruction reads the same register. This dependency is illustrated by the pair of instructions in the X- and Y-pipelines, as shown below:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nX-PIPELINE         Y-PIPELINE                                             \n______________________________________                                    \n(1) ADD AX,BX      (2) MOV [mem],AX                                       \nAX\u2190AX+BX      [mem]\u2190AX                                          \n______________________________________                                    \n</pre><p>The processor 200, however, can use result forwarding to avoid the Y-pipeline stall, as shown below in Table 4. Instead of transferring the contents of the AX register to memory, the result of the previous ADD instruction (Reg0+Reg1) is written directly to memory, thereby saving a clock cycle. The second instruction must be a move instruction and the destination of the second instruction may be either a register or memory.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 4                                                     \n______________________________________                                    \nResult Forwarding Example                                                 \n          Physical Register Contents                                      \nInstruction                                                               \n          Reg0    Reg1   Reg2 Pipe Action                                 \n______________________________________                                    \n(Initial) AX      BX                                                      \nADD AX,BX         BX     AX   X    Reg2\u2190Reg0+Reg1                    \nMOV [mem],AX      BX     AX   Y    [mem]\u2190Reg0+Reg1                   \n______________________________________                                    \n</pre><h4>2.1.6 DATA BYPASSING</h4><p>In addition to register renaming and data forwarding, the processor 200 provides a third data dependency-resolution technique called data bypassing. Data bypassing reduces the performance penalty of those memory data RAW dependencies that cannot be eliminated by data forwarding. Data bypassing is provided when the first in a pair of instructions writes to memory and the second instruction reads the same data from memory. The processor retains the data from the first instruction and passes it to the second instruction, thereby eliminating a memory read cycle. Data bypassing only occurs for cacheable memory locations.</p><p>A RAW dependency occurs when the first in a pair of instructions performs a write to memory and the second instruction reads the same memory location. This dependency is illustrated by the pair of instructions in the X- and Y-pipelines, as shown below.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nX-PIPELINE          Y-PIPELINE                                            \n______________________________________                                    \n(1) ADD [mem],AX    (2) SUB BX, [mem]                                     \n[mem]\u2190[mem]+AX BX\u2190BX-[mem]                                      \n______________________________________                                    \n</pre><p>The processor 200 can use data bypassing to stall the Y-pipeline for only one clock cycle by eliminating the Y-pipeline's memory read cycle, as shown below in Table 5. Instead of reading memory in the Y-pipeline, the result of the previous instruction ([mem]+Reg0) is used to subtract from Reg1, thereby saving a memory access cycle.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 5                                                     \n______________________________________                                    \nExample of Data Bypassing                                                 \n        Physical Register Contents                                        \nInstruction                                                               \n        Reg0   Reg1   Reg2 Pipe Action                                    \n______________________________________                                    \n(Initial)                                                                 \n        AX     BX                                                         \nADD [mem],                                                                \n        AX     BX          X    [mem]\u2190[mem]+Reg0                     \nAX                                                                        \nSUB BX, AX            BX   Y    Reg2\u2190Reg1-{[mem]+Reg0}               \n[mem]                                                                     \n______________________________________                                    \n</pre><h4>2.1.7 BRANCH CONTROL</h4><p>Programmers have found through simulation and experimentation that branch instructions occur on average every four to six instructions in x86-compatible programs. The processor 200 minimizes performance degradation and latency of branch instructions through the use of branch prediction and speculative execution. The processor 200 uses a 512-entry, 4-way set associative Branch Target Buffer (BTB) 220 to store branch target addresses and a 1024-entry branch history table. During the fetch stage, the instruction stream is checked for the presence of branch instructions. If an unconditional branch instruction is encountered, the processor 200 accesses the BTB 220 to check for the branch instruction's target address. If the branch instruction's target address is found in the BTB 220, the processor 200 begins fetching at the target address specified by the BTB 220.</p><p>In case of conditional branches, the BTB 220 also provides history information to indicate whether the branch is more likely to be taken or not taken. If the conditional branch instruction is found in the BTB 220, the processor 200 begins fetching instructions at the predicted target address. If the conditional branch misses in the BTB 220, the processor 200 predicts that the branch will not be taken, and instruction fetching continues with the next sequential instruction. The decision to fetch the taken or not taken target address is preferably, although not necessarily, based on a four-state branch prediction algorithm.</p><p>Once fetched, a conditional branch instruction is first decoded and then dispatched to the X-pipeline only. The conditional branch instruction proceeds through the X-pipeline and is then resolved in either the Execution 306 stage or the Write-Back 307 stage. The conditional branch is resolved in the Execution 306 stage if the instruction responsible for setting the condition codes is completed prior to the execution of the branch. If the instruction that sets the condition codes is executed in parallel with the branch, the conditional branch instruction is resolved in the Write-Back 307 stage.</p><p>Correctly predicted branch instructions execute in a single core clock cycle. If resolution of a branch indicates that a misprediction has occurred, the processor 200 flushes the pipeline and starts fetching from the correct target address. The processor 200 preferably prefetches both the predicted and the non-predicted path for each conditional branch, thereby eliminating the cache access cycle on a misprediction. If the branch is resolved in the Execution 306 stage, the resulting misprediction latency is four clock cycles. If the branch is resolved in the Write-Back 307 stage, the latency is five clock cycles.</p><p>Since the target address of return (RET) instructions is dynamic rather than static, the processor 200 caches target addresses for RET instructions in an eight-entry return stack rather than in the BTB 220. The return address is pushed on the return stack during a CALL instruction and popped during the corresponding RET instruction.</p><h4>2.1.8 SPECULATIVE EXECUTION</h4><p>The processor 200 is capable of speculative execution following a floating point instruction or predicted branch. Speculative execution allows the X- and Y-pipelines to continuously execute instructions following a branch without stalling the pipelines waiting for branch resolution. As will be described below, the same mechanism is used to execute floating point instructions in parallel with integer instructions. The processor 200 is capable of up to four levels of speculation (i.e., combinations of four conditional branches and floating point operations). After generating the fetch address using branch prediction, the processor 200 checkpoints the machine state (registers, flags, and processor environment), increments the speculation level counter, and begins operating on the predicted instruction stream.</p><p>Once the branch instruction is resolved, the processor 200 decreases the speculation level. For a correctly predicted branch, the status of the checkpointed resources is cleared. For a branch misprediction, the processor 200 generates the correct fetch address and uses the checkpointed values to restore the machine state in a single clock. In order to maintain compatibility, writes that result from speculatively executed instructions are not permitted to update the cache or external memory until the appropriate branch is resolved. Speculative execution continues until one of the following conditions occurs: 1) a branch or floating point operation is decoded and the speculation level is already at four; 2) an exception or a fault occurs; 3) the write buffers are full; or 4) an attempt is made to modify a non-checkpointed resource (i.e., segment registers, system flags).</p><h4>2.1.9 SYSTEM REGISTER SET</h4><p>Registers are broadly grouped into two sets, namely: 1) the application register set comprising registers frequently used by application programs, and 2) the system register set comprising registers typically reserved for use by operating system programs. The application register set preferably includes general purpose registers, segment registers, a flag register, and an instruction pointer register. The system register set preferably includes control registers, system address registers, debug registers, configuration registers, and test registers. In order not to obscure the invention, only relevant portions of the system register set will be further described. Those skilled in the art may easily obtain additional descriptions of the application register set by referring to publications such as \"The Cyrix 6\u00d786 Microprocessor Data Book,\" Order No. 94175-00, August 1995, herein incorporated by reference.</p><p>FIGS. 4A and 4B depict a preferred system register set 400, comprising registers not generally visible to application programmers and typically employed by operating systems and memory management programs. The control registers, CR0-CR4, control certain aspects of the processor 200 such as paging, coprocessor functions, and segment protection. The debug registers, DR0-DR7, provide debugging facilities to enable the use of data access break-points and code execution breakpoints. The test registers, TR3-TR7, provide a mechanism to test the contents of both the cache unit 204 and the Translation Look-Aside Buffers, TLB 230 and TLB 235. The configuration control registers, CCR0-CCR7, are used to configure the processor 200's on-chip cache operations, power management features, and System Management Mode, as well as provide information on device type and revision.</p><p>The address region registers, ARR0-ARR7, are used to specify the location and size for the eight address regions. Attributes for each address region are specified in the region control registers, RCR0-RCR7. ARR7 and RCR7 are used to define system main memory and differ from ARR0-ARR6 and RCR0-RCR6. With non-cacheable regions defined on-chip, the processor 200 eliminates data dependencies and resource conflicts in its execution pipelines. If KEN# is active for accesses to regions defined as non-cacheable by the RCRs, the region is not cached.</p><p>A register index, is used to select one of three bytes in each ARRx. The starting address of the ARRx address region, selected by the START ADDRESS field, must be on a block size boundary. For example, a 128 Kbyte block is allowed to have a starting address of 0 Kbytes, 128 Kbytes, 256 Kbytes, and so on.</p><p>The region control registers, RCR0-RCR7, specify the attributes associated with the ARRx address regions. Cacheability, weak locking, write gathering, and cache-write-through policies can be activated or deactivated using the attribute bits defined in the region control registers.</p><h4>2.1.9.1 MODEL SPECIFIC REGISTERS</h4><p>The processor 200 preferably comprises at least four model specific registers (MSRs). The MSRs can be read using the RDMSR instruction. During a register read, the contents of the particular MSR, specified by the ECX register, is loaded into the EDX:EAX registers. The MSR can be written using the WRMSR instruction. During a MSR write the contents of EDX:EAX are loaded into the MSR specified in the register.</p><h4>2.1.9.2 DEBUG REGISTERS</h4><p>At least six debug registers, DR0-DR3, DR6 and DR7, support debugging on the processor 200. Memory addresses loaded in the debug registers, referred to as \"breakpoints,\" generate a debug exception when a memory access of the specified type occurs to the specified address. A data breakpoint can be specified for a particular kind of memory access, such as a read or a write. Code breakpoints can also be set allowing debug exceptions to occur whenever a given code access (execution) occurs. The size of the debug target can be set to 1, 2, or 4 bytes. The debug registers are accessed via MOV instructions, which can be executed only at privilege level 0. The Debug Address Registers (DR0-DR3) each contain the linear address for one of four possible breakpoints. Each breakpoint is further specified by bits in the Debug Control Register (DR7). For each breakpoint address in DR0-DR3, there are corresponding fields L, R/W, and LEN in DR7 that specify the type of memory access associated with the breakpoint.</p><p>The R/W field can be used to specify instruction execution as well as data access break-points. Instruction execution breakpoints are always taken before execution of the instruction that matches the breakpoint.</p><p>The Debug Status Register (DR6) reflects conditions that were in effect at the time the debug exception occurred. The contents of the DR6 register are not automatically cleared by the processor 200 after a debug exception occurs and, therefore, should be cleared by software at the appropriate time. Code execution breakpoints may also be generated by placing the breakpoint instruction (INT 3) at the location where control is to be regained. Additionally, the single-step feature may be enabled by setting the TF flat in the EFLAGS register. This causes the processor to perform a debug exception after the execution of every instruction.</p><h4>2.1.9.3 TEST REGISTERS</h4><p>The test registers can be used to test the unified L1 cache 245, the L1 TLB 230, and the L2 TLB 235. Test registers TR3, TR4, and TR5 are used to test the unified L1 cache 245 and TR6 and TR7 are used to test the L1 TLB 230 and the L2 TLB 235. Use of these test registers is described in more detail below.</p><h4>2.1.10 FLOATING POINT UNIT</h4><p>The floating point unit (FPU) 225 processes floating point and multimedia extension instructions and is preferably x87 instruction set compatible, adhering to the IEEE-754 standard. Floating point instructions may execute in parallel with integer instructions. Integer instructions may complete out-of-order with respect to the FPU instructions. The processor 200 maintains x86 compatibility by signaling exceptions and issuing write cycles in program order. Floating point instructions are preferably dispatched to the X-pipeline in the IU 215. The address calculation stage of the X-pipeline checks for memory management exceptions and accesses memory operands used by the FPU 225. If no exceptions are detected, the state of the processor 200 is check-pointed and, during AC2, floating point instructions are dispatched to a FPU instruction queue. The processor 200 can then complete subsequent integer instructions speculatively and out-of-order relative to the FPU instruction and relative to any potential FPU exceptions which may occur.</p><p>As additional FPU instructions enter the pipeline, the processor 200 can preferably dispatch four or more FPU instructions to the FPU instruction queue. The processor 200 continues executing speculatively and out-of-order, relative to the FPU queue, until one of the conditions that causes speculative execution to halt is encountered. As the FPU 225 completes instructions, the speculation level decreases and the check-pointed resources are available for reuse in subsequent operations. The FPU 225 preferably has a set of six or more write buffers to prevent stalls due to speculative writes.</p><h4>2.2 CACHE UNIT</h4><p>FIG. 5 depicts an exemplary cache unit 204 in accordance with the principles of the present invention. Those skilled in the art will readily understand that other organizations, sizes and associativities for the cache unit 204 are possible, for which the principles of the present invention may be practiced without departing from the scope of the invention. The cache unit 204 comprises a unified L1 cache 245 and an instruction line cache 240. The unified L1 cache 245 is the primary data cache and secondary instruction cache. The unified Li cache 245 is preferably, although not exclusively, 64 Kbytes in size and four-way set-associative with a 32 byte line size (2048 lines total).</p><p>The instruction line cache 240 is the primary instruction cache, provides a high speed instruction stream to the IU 215, and is preferably, though not exclusively, 256 bytes in size and fully associative. The instruction line cache 240 is filled from the unified L1 cache 245 through the data bus. Fetches from the IU 215 that hit in the instruction line cache 240 do not access the unified L1 cache 245. If an instruction line cache miss occurs, the instruction line data from the unified L1 cache 245 is transferred simultaneously to the instruction line cache 240 and the IU 215. The instruction line cache 240 uses a pseudo-LRU replacement algorithm. To ensure proper operation in the case of self-modifying code, any writes to the unified L1 cache 245 are checked against the contents of the instruction line cache 240. If a hit occurs in the instruction line cache 240, the appropriate line is invalidated.</p><p>FIG. 6 depicts the exemplary L1 cache 245 in FIG. 2 in greater detail. It is recalled that the exemplary L1 cache 245 preferably contains 64 Kbytes of data subdivided into 2048 cache lines of 32 bytes each. The L1 cache 245 is also organized as 512 sets, Sets 0-511, that are divided into four ways, Ways 0-3. Blocks 601-604 in L1 cache 245 comprise Ways 0-3, respectively. Ways 1-3, shown in dotted outline, are functionally equivalent to Way 0. This being the case, only Way 0 need be discussed to explain cache hits and cache misses and the retrieval of data from L1 cache 245.</p><p>Each set consists of eight entries: an address tag and a 32-byte cache line from each of the four ways. For example, if address bits A(13:5) are 000000000, Set 0 is being addressed and, in all four ways, a corresponding 32-byte line in data array 605 and a corresponding address tag in tag array 610 are accessed.</p><p>Twenty seven physical address bits, A(31:5), are needed to fetch data from the L1 cache 245. Since data are written to, and read from, the L1 cache 245 in entire 32-byte cache lines, the five least significant address bits, A(4:0), are not used. Address bits A(4:0) may be used to address individual bytes within a cache line.</p><p>Data must be fetched from the L1 cache 245 (and the external L2 cache 404) using physical addresses. Therefore, address translation is necessary. As explained above, address calculation proceeds in two steps, AC1 and AC2. The lowest twelve (12) address bits, A(11:0), are the page offset and are the same in both the linear and physical addresses. These bits do not require translation. The upper twenty bits, A(31:12), of the linear (or logical) address identify the required 4096 byte page and require translation. Since address bits A(11:0) do not require translation, they are available during AC1 for accessing data in L1 cache 245. Address bits A(31:12) are translated during AC2 and translated bits A12 and A13 become available last.</p><p>The linear (or logical) addresses are translated into physical addresses in a TLB (such as the TLB 230 or TLB 235 of FIG. 2). In one embodiment of the present invention, two TLBs are implemented: a 16 entry direct mapped L1 TLB 230 and a 384 entry 6-way associative L2 TLB 235 (again, both of FIG. 2). Each TLB compares some of linear address bits A(31:12) of the current linear address to linear address bits previously stored in the TLB. If a match is found, the corresponding physical address is output from the TLB to the L1 cache 245 and/or the L2 cache 404.</p><p>Address bits A(13:5) select a 32-byte line in data array 605 and an address tag in tag array 610 simultaneously in each of the four ways (eight entries total). When a cache line is written into data array 605, the tag address A(31:14), which is a physical address, is simultaneously stored in one of the 512 locations in tag array 610, as determined by the address bits A(13:5). Thus, when address bits A(13:5) are applied to tag array 610, the stored value of tag address A(31:14) is sent to comparator 615 for comparison with address bits A(31:14) of the current physical address. At the same time, the 32 bytes in the data array 605 corresponding to A(13:5) are applied to one of the channels of multiplexer 620.</p><p>If the address bits A(31:14) are the same, a cache hit has occurred and one (and only one) of the enable signals, WAY 0 HIT, WAY 1 HIT, WAY 2 HIT, or WAY 3 HIT, will go high for the corresponding way. This will, in turn, select the correct channel of multiplexer 620 (which forms a part of sector selection circuitry) and output a corresponding one of the 32-byte lines of data, referred to generically as WAY 0 DATA, WAY 1 DATA, WAY 2 DATA, or WAY 3 DATA.</p><p>It is noted that two address bits, A13 and A12, must be translated in order to select the correct set in each way. Thus, a first delay is caused by the translation of A13 and A12. A second delay is incurred after translation while the correct set is being selected in tag array 610 (i.e., before the tag address A(31:14) settles at the output of tag array 610). When the tag address A(31:14) is finally valid at the output of tag array 610, another delay is incurred while the tag array 610 output is compared in comparator 615 to the current memory address A(31:14).</p><p>The present invention improves the rate at which data may be accessed in each of the ways of L1 cache 245 by dividing the L1 cache 245 (and Ways 0-3) into sectors corresponding to predetermined values of A13 and A12. The untranslated physical bits A(11:5), which are available early in AC1, are used to select a set in each sector of the L1 cache 245. The multiple selected sets from the same way are then multiplexed at the data output of the way. The translated physical address bits A13 and A12 control the output multiplexer in each way and thereby select the correct data set (i.e., cache line) to be output from the way. Thus, the speed of the way is more closely related to the rate at which A13 and A12 can be translated, and is not limited by the speed of the tag array 610 and comparator 615.</p><p>FIG. 7 depicts an improved L1 cache 245 divided into sectors according to one embodiment of the present invention. Once again, Way 0 (block 601) needs to be shown, since Ways 1-3 are functionally equivalent to Way 0. Tag array 610 and data array 605 are subdivided into four sectors, 0-3, according to the values of A(13:12). When data is written to L1 cache 245, the cache line is stored in a selected one of Data Sectors 0-3 in data array 605 and the tag address A(31:12) is stored in a selected one of Tag Sectors 0-3 of tag array 610. For example, if bits A(13:12) of the translated physical address are 00, the tag address A(31:12) is written into Tag Sector 0 and the corresponding 32-byte cache line is written into Data Sector 0 of data array 605. Similarly, if bits A(13:12) of the translated physical address are 01, 10, or 11, cache lines are written into Data Sectors 1, 2 or 3, respectively, and tag addresses are written into Tag Sectors 1, 2 or 3, respectively.</p><p>During a read operation, the address bits A(11:5), which do not need to be translated and are available during AC1, are applied to each of the four sectors. Thus, a set is addressed in each of the four sectors. The four corresponding cache lines are output to multiplexer 701 (which forms a part of sector selection circuitry). At the same time, the tag address bits A(31:12) are output from the selected set in each tag sector to a respective first input channel on a respective one of comparators 702-705. The second input channel on each of comparators 702-705 is connected to the address bits A(31:12) of the translated physical address.</p><p>The address bits A(11:5) are the only bits required to access the caches lines in each of Data Sectors 0-3 and the tag address bits A(31:12) in each of Tag Sectors 0-3. Since address bits A(11:5) do not need translation, they are available during AC1. Therefore, the caches lines from Data Sectors 0-3 are available at the inputs of multiplexer 701 before address bits A13 and A12 are translated. Similarly, the tag address bits A(31:12) from Tag Sectors 0-3 are available at the inputs of comparators 702-705 before address bits A13 and A12 are translated.</p><p>The address bits A(11:5) can have values only between 0 and 127, thereby addressing any one of 128 possible sets per sector. Nonetheless, the sets in FIG. 7 are shown numbered sequentially from Set 0 to Set 511 across sector boundaries. This is done only for the purpose of illustration. The number of each set shown in FIG. 7 reflects the \"offset\" value of A13 and A12. For example, Set 0 and Set 384 are both enabled by the set address A(11:5)=0000000. However, Set 384 is only accessed (written to) when A(13:12)=11 and Set 0 is only accessed (written to) when A(13:12)=00.</p><p>When address bits A13 and A12 are translated during AC2, A13 and A12 immediately select the corresponding channel of multiplexer 701 and the corresponding cache line is output to multiplexer 620. At the same time, translated address bits A(31:12) are applied to comparators 702-705 and, if they match one of the four tag addresses output from the tag sectors, an output line of one of the comparators 702-705 will go high (i.e., a cache hit has occurred). Advantageously, since the A12 and A13 bits from each Tag Sector are always different, only one comparator will go high at time. This allow the outputs to be connected together to form a wired-OR gate. The wired-OR output of comparators 702-705 forms one of the selects, WAY 0 HIT-WAY 3 HIT, on multiplexer 620.</p><p>As the above description shows, cache lines are output from each way faster because translated address bits A13 and A12 are no longer needed to retrieve the cache line from the data array 605 or retrieve the tag address from the tag array 610. Instead, the translated bits A13 and A12 are used to select a channel in multiplexer 620. This is much faster than selecting a 32-byte cache line from data array 605, which is essentially a (comparatively slow) RAM device. Additionally, the tag addresses are output from the Tag Sectors 0-3 during AC1 and are available for comparison even before the translated physical address bits A(31:12) are sent to comparators 702-705. It is therefore not necessary to wait for the value of the selected tag address to settle and become valid at the tag array 610 output after translation of A13 and A12, because A13 and A12 are no longer required to select a tag address. Hence, the speed of the L1 cache 245 is now closer to the speed at which the address can be translated to a physical address.</p><p>In a preferred embodiment of the present invention, the values of A13 and A12 assigned to the sectors in the L1 cache 245 may be programmed under the control of the cache unit 204. For example, the physical locations of Sets 0-127 may be programmed to hold tag addresses ending with A(13:12)=00 (Tag Sector 0), A(13:12)=01 (Tag Sector 1), A(13:12)=10 (Tag Sector 2), or A(13:12)=11 (Tag Sector 3). This advantageously allows a processor with a defective cache sector to be salvaged, at the cost of a smaller cache size. For example, if faults are found in Set 50 in Data Sector 0 and in Set 200 in Data Sector 1, Data Sector 3 and Data Sector 4 may be redesignated as Data Sector 0 and Data Sector 1, respectively, according to the value of tag address bit A13. The dysfunctional circuitry used by the old Data Sectors 0 and 1 is no longer accessed and the L1 cache 245 becomes a 32 Kbyte 4-way set associative cache. If three sectors are found to be defective, the remaining good sector is still usable and may contain any value of A13 and A12. The L1 cache 245 then becomes a 16 Kbyte 4-way set associative cache.</p><p>This redesignation may occur in the factory before sale of the processor 200 in a computer. The processor 200 could then be sold with a less powerful (i.e., smaller) cache at a lower price. In a preferred embodiment, the redesignation of sectors may also occur when a cache error is detected during a self test routine, such as when a computer is booted up. The computer maps out the defective sectors in the cache and continues to run with the smaller cache. Ideally, a warning message is displayed on the monitor warning of the cache fault(s).</p><p>The redesignation of sectors in the L1 cache 245 may be accomplished by reprogramming switch positions in the data paths that write cache lines into data array 605 and tag address bits A(31:12) into tag array 610. For example, in an initial configuration, cache lines and tags are switched to Sector 3 when A(13:12)=11, to Sector 2 when A(13:12)=10, to Sector 1 when A(13:12)=01, and to Sector 0 when A(13:12)=00 during a cache write operation. If one or both of Sectors 3 and 4 becomes defective, the switching paths may be reconfigured such that cache lines and tags are switched to Sector 1 when A12=1 and to Sector 0 when A12=0 during a write operation. During a read operation, address line A13 is held at 0 on multiplexer 701 so that only Sectors 0 and 1 are selected, depending on the value of A12. The value of A13 in Tag Sectors 0 and 1 may have values of either 0 or 1, however.</p><p>In one embodiment of the present invention, the rate at which data may be accessed in each of the ways of the L1 cache 245 is further improved by providing a shadow L1 look-aside translation buffer (TLB). The shadow L1 TLB holds the same tag addresses as the primary L1 TLB 230, but provides translated physical addresses to the L1 cache 245 much more rapidly because it is an integral part of the cache. Before describing the shadow L1 TLB in detail, the operation of the L1 TLB 230 and the L2 TLB 235 will be discussed.</p><p>FIG. 8 depicts a conventional L1 TLB 230 for translating linear addresses for the L1 cache 245. L1 TLB 230 is a 16-entry direct mapped buffer that receives linear address A(31:12) from the core 202 of the processor 200. Linear address A(31:12) identifies the current 4096 byte page in memory. Four linear address bits A(15:12) select one of the sixteen (16) page table entries in L1 TLB 230. Each page table entry comprises a linear address in the Tag field 810 array and a corresponding physical address in the Data field 805 array. Each page table entry also comprises a number of access bits, such as V (valid), U/S (user/supervisor), R/W (read/write), D (dirty), etc.</p><p>When A(15:12) selects an entry in the L1 TLB 230, Tag field 810 outputs the tag address bits A(31:16) stored in the entry to one of the input channels of comparator 815. The other input channel of comparator 815 receives linear address bits A(31:16) of the current memory address. If the bits are the same, a TLB \"hit\" has occurred (i.e., the memory page identified by linear address A(31:12) matches the linear address of a memory page previously stored in the Tag field 810). The signal L1 TLB HIT goes high, thereby signaling the L1 cache 245 that a valid physical address is being sent to the L1 cache 245.</p><p>At the same time that the linear address bits are being compared, linear address bits A(15:12) select the physical address bits A(31:12) in Data field 805 that correspond to the stored tag address in Tag field 810. Data field 805 outputs the selected physical address A(31:12) to L1 cache 245 so that the physical address may immediately be used by L1 cache 245 when L1 TLB HIT goes high.</p><p>If the tag address A(31:16) in Tag field 810 does not match the current linear address A(31:16), an L1 TLB \"miss\" has occurred and the physical address A(31:12) output by the L1 TLB 230 is ignored by L1 cache 245. After an L1 TLB miss, the L2 TLB 235 is examined to determine if the L2 TLB 235 contains the linear address A(31:12). If the L2 TLB 235 does contain the linear address A(31:12), then an L2 TLB \"hit\" has occurred, the entire entry in the L2 TLB 235 is transferred to the L1 TLB 230, thereby updating the L1 TLB 230 with the \"missed\" linear address, physical address and access bits. At the same time, the physical address A(31:12) retrieved from the L2 TLB 235 and an L2 TLB HIT signal are sent to the L1 cache 245, so that processing may continue.</p><p>If the L2 TLB 235 does not contain the linear address A(31:12), then an L2 TLB \"miss\" has occurred, the entire entry in the L2 TLB 235 is transferred to the L1 TLB 230, thereby updating the L1 TLB 230 with the \"missed\" linear address, physical address and access bits. This means that the requested data must be retrieved from system memory 402. The linear address A(31:12) is translated by the MMU 206 and the data retrieved from system memory 402 is written back to the L1 cache 245, the L2 cache 404 the L1 TLB 230 and the L2 TLB 235, thereby updating the L1 TLB 230 and the L2 TLB 235 with the \"missed\" linear address, physical address and access bits.</p><p>FIG. 9 depicts conventional L2 TLB 235 for translating linear addresses for the external L2 cache 402. L2 TLB 235 is a 384-entry 6-way set associative buffer that receives linear address A(31:12) from the core 202 of the processor 200. The L2 TLB 235 is organized as 64 sets, Sets 0-63, that are divided into six ways, Ways 0-5. Blocks 911-916 in the L2 TLB 235 comprise Ways 0-5, respectively. Ways 1-5, shown in dotted outline, are functionally equivalent to Way 0. This being the case, only Way 0 need be discussed to further explain the operation of the L2 TLB 235.</p><p>Each set consists of twelve entries: a linear address tag in Tag field 910 and a corresponding physical address in Data field 905 from each of the six ways. The sets also contain access bits associated with the entries. The access bits may be ignored for this discussion), such as V (valid), U/S (user/supervisor), R/W (read/write), D (dirty), etc. Linear address bits A(17:12) are used to select the sets. For example, if address bits A(17:12) are 000000, Set 0 is being accessed and, in all four ways, a corresponding physical address A(31:12) in Data field 905 and a corresponding linear tag address A(31:18) tag in Tag field 910 are accessed.</p><p>When A(15:12) selects an entry in the Tag field 910, Tag field 910 outputs the tag address bits A(31:18) stored in the entry to one of the input channels of comparator 920. The other input channel of comparator 920 receives linear address bits A(31:18) of the current memory address. If the bits are the same, an L2 TLB \"hit\" has occurred (i.e., the memory page identified by linear address A(31:12) matches the linear address of a memory page previously stored in the Tag field 910). The comparator 920 output generates the signal, WAY 0 HIT, which indicates a \"hit\".</p><p>At the same time that the linear address bits are being compared, linear address bits A(17:12) select the physical address A(31:12) in Data field 905 that corresponds to the stored tag address in Tag field 910. Data field 905 outputs the selected physical address A(31:12) to one of the input channels of multiplexer 925. If a hit occurs in any of the six ways, one of the six enable signals, WAY 0 HIT-WAY 5 HIT, goes high for the corresponding way. This, in turn, selects the correct channel of multiplexer 925 and outputs a corresponding one of the physical addresses A(31:12). As noted above, if an L2 TLB \"miss\" occurs, the data must be retrieved from system memory 402.</p><p>It is apparent from the foregoing that the speed at which the L1 TLB 230 provides a translated physical address to the L1 cache 245 directly affects the access time of the L1 cache 245. Unfortunately, the data paths between the L1 TLB 230 and the L1 cache 245 are lengthy and drive a large number of gates, including intermediate multiplexers used to route the physical address A(31:12) to other functional units in the processor 200. This means that the physical address A(31:12) bits are comparatively slow in reaching the L1 cache 245, causing a concomitant delay in accessing data in the L1 cache 245.</p><p>In one embodiment of the present invention, the time delay in transferring a physical address A(31:12) to, and then reading data from, the L1 cache 245 is reduced by providing a \"shadow\" translation look-aside buffer located proximate the L1 cache 245. The shadow TLB contains identical copies of the sixteen physical addresses in the L1 TLB 230, but does not contain, and does not require, either the linear tag addresses or the access bits in the L1 TLB 230. For the purpose of clarity in explaining below the operation of the shadow TLB, the L1 TLB 230 may from time to time be referred to as the \"primary\" L1 TLB.</p><p>FIG. 10 depicts an improved tag array 610 in the L1 cache 245, wherein a shadow L1 TLB 1005 is integrated into the sectors of the tag array 610, according to one embodiment of the present invention. In the illustrated embodiment, the shadow L1 TLB 1005 is bifurcated in order to minimize the length of lead lines from different tag sectors in tag array 610. One portion of the shadow L1 TLB 1005 and comparators 702 and 703 are disposed proximate (and perhaps between) the physical address A(31:12) outputs of Tag Sector 3 and Tag Sector 2. The other portion of the shadow L1 TLB 1005 and comparators 704 and 705 are disposed proximate (and perhaps between) the physical address A(31:12) outputs of Tag Sector 1 and Tag Sector 0.</p><p>The address translation operation of shadow L1 TLB 1005 is simpler than the address translation operation of the primary L1 TLB 230. Linear address bits A(15:12) are received into the shadow L1 TLB 1005 (and therefore into the L1 cache 245) and select one of sixteen entries in the data field of the shadow L1 TLB 1005. The physical address A(31:12) in the selected entry is immediately output to the four comparators 702-705. The shadow L1 TLB 1005 does not contain a tag field and tag address comparators similar to those in the primary L1 TLB 230.</p><p>If the physical address A(31:12) selected by A(15:12) is wrong, then it is also wrong in the primary L1 TLB 230, since both L1 TLB's contain identical physical addresses A(31:12). If physical address A(31:12) is wrong in the \"primary\" L1 TLB 230, then a \"miss\" has occurred in both the L1 TLB 230 and the L1 cache 245. The physical address A(31:12) is ignored after an L1 cache 245 miss. Therefore, no harm is done in not performing a tag address comparison in the shadow L1 TLB 1005.</p><p>The L1 cache 245 no longer needs to wait to receive the translated physical address A(31:12) from the primary L1 TLB 230. As FIG. 10 shows, the L1 cache 245 now requires only sixteen address bits: physical address A(11:5), which does not require translation and is available early in AC1, and linear address bits A(15:12), which are also available early in AC1. The shadow L1 TLB 1005 output the physical address bits A(31:12) much more rapidly than they can be translated in, and transferred from, the primary L1 TLB 230. When the physical address bits A(31:12) are output by the shadow L1 TLB 1005, the tag array 610 in L1 cache 245 compares the physical address bits A(31:12) to the tag address A(31:12) as described above in connection with FIGS. 6 and 7. The untranslated address A(11:5) selects tag addresses in all four tags sectors of the tag array 610 and the four selected tag addresses A(31:12) are compared by comparators 702-705 to the output of the shadow L1 TLB 1005. The output of the four comparators are connected to each other to form a wired-OR gate. The wired-OR outputs from the comparators in all four ways of the L1 cache 245 are used as multiplexer channel selects for multiplexer 620.</p><p>The data array 605 and the multiplexer 701 in FIG. 7 are not show in FIG. 10 because they are not affected by the shadow L1 TLB 1005. However, the earlier availability of translated physical address A(31:12) from the shadow L1 TLB 1005 means that the comparators 702-705 more quickly generate a \"hit\" signal for each of Ways 0-3 (i.e., WAY 0 HIT-WAY 3 HIT). Also, the earlier availability of translated physical address bits A13 and A12 means that a cache line from data array 605 in each way is more quickly selected by multiplexer 701 (i.e., WAY 0 DATA-WAY 3 DATA). This means that both the channel data and the channel select signals for multiplexer 620 are available to output data from the L1 cache 245 onto the data bus.</p><p>The operation of the shadow L1 TLB 1005 has been explained in connection with an L1 cache 245 that is partitioned into sectors. However, those skilled in the art will recognize that the shadow L1 TLB 1005 described above may readily be implemented in a non-partitioned L1 cache and still provide faster translation of the higher order address bits A(31:12) than a conventional \"primary\" L1 translation look-aside buffer.</p><p>It is also apparent from the foregoing that the speed at which the linear address bits A12 and A13 are translated into physical address bits A12 and A13 by the L1 TLB 230 directly affects the access time of the L1 cache 245. It is recalled that translated physical address bits A12 and A13 are used to control multiplexer 701, which selects one 32-byte cache line from one of the four sectors in each of the four ways in the L1 cache 245. The sooner that translated address bits A12 and A13 are available at multiplexer 701, the sooner that the selected cache line may be output from the way to multiplexer 620. Translated physical address bits A12 and A13 normally become available from the outputs of the data field 805 in the L1 TLB 230 during AC2, along with translated physical address bits A(31:14).</p><p>Unfortunately, the speed at which the L1 TLB 230 can translate address bits A12 and A13 is comparatively slow. The L1 TLB 230 is essentially a RAM device that contains 16 entries (Sets 0-15). The entries are subdivided into the data field 805, the tag field 810 and numerous access bits, so that each entry contains over 40 bits. The L1 TLB 230 therefore requires comparatively long bit lines and somewhat complex row/column selection circuitry. The RAM cells in the L1 TLB 230 are also synchronous and a selected data location must await the next clock edge before being output from the data field 805. In sum, the speed at which physical address bits A12 and A13 (as well as A(31:14)) are made available at the output of the L1 TLB 230 is slowed by the size of the RAM structure in the L1 TLB 230.</p><p>The present invention further improves the operation of the L1 cache 245 by providing an L1 TLB slice that is used to store a separate copy of the physical address bits A12 and A13. The L1 TLB slice is essentially an asynchronous RAM that is much smaller, and consequently much faster, than the primary L1 TLB 230. Like the primary L1 TLB 230, the L1 TLB slice receives the untranslated linear address bits A(15:12) during AC1 and uses the linear address bits A(15:12) to select (or index into) one of sixteen entries in the L1 TLB slice. The entries contain only A13 and A12. Thus, the translated physical address bits A12 and A13 are available during AC1, rather than during AC2, and the selection signals for multiplexer 701 are also available that much sooner.</p><p>FIG. 11 depicts an L1 TLB slice 1101 according to a first embodiment of the present invention. The L1 TLB slice 1101 is shown disposed in Way 0 (reference numeral 601), shown in dotted outline, of the L1 cache 245, also shown in dotted outline. In the first embodiment (and some other embodiments) of the present invention, a single L1 TLB slice may be implemented that provides translated address bits A12 and A13 for all of the ways in the L1 cache 245. In other embodiments, a separate L1 TLB slice may be implemented in each way.</p><p>When a physical address is written into the L1 TLB 230 after an L1 TLB \"miss,\" the A12 and A13 bits are simultaneously written to the L1 TLB slice 1101, so that the L1 TLB 230 and the L1 TLB slice 1101 contain identical A12 and A13 bits. In L1 TLB implementations where the translated A12 and A13 bits are provided to other functional units in the processor 200 at the same time as the translated A(31:14) bits, redundant copies of physical address bits A12 and A13 may continue to be stored in the entries in data field 605 of the primary L1 TLB 230. In other L1 TLB implementations where the translated A12 and A13 bits need not be provided to other functional units in the processor 200 at the same time as the translated A(31:14) bits, physical address bits A12 and A13 may be eliminated from the entries in data field 605 of the primary L1 TLB 230. This advantageously reduces the size, and increases the speed, of the primary L1 TLB 230.</p><p>When the untranslated linear address bits A(15:12) select an entry in the L1 TLB slice 1101, physical address bits A13 and A12 are output from the L1 TLB slice 1101 to a 2-to-4 decoder 1102.</p><p>The outputs of the decoder 1102 are the multiplexer selection lines, S0-S3. In some embodiments, decoder 1102 may be an integral part of the multiplexer 701. Thus, a 32-byte cache line is selected from one of the four sectors, Data Sectors 0-3, in Way 0 of the L1 cache 245 and is output during AC1 to the multiplexer 620. Each of Ways 1-3 also outputs a 32-byte cache line to the multiplexer 620.</p><p>It is noted that the values (00-11) of the two bits A12 and A13 entirely determine the values of the multiplexer selection bits S0-S3. This allows yet another improvement to be made to the operation of the L1 cache 245. A preferred embodiment of the present invention provides an L1 TLB slice that stores the values of the selection bits S0-S3 corresponding to the values of the physical address bits A12 and A13, rather than storing the actual physical address bits A12 and A13. Although this slightly increase the size and complexity of the L1 TLB slice, these increases are more than offset by the speed increase gained by omitting the delay induced by the decoder 1102 by the decoding A13 and A12 upon a fill-after-miss of the L1 TLB 230 instead of every time the L1 TLB slice is accessed.</p><p>FIG. 12 depicts an L1 TLB slice 1201 according to a second (and preferred) embodiment of the present invention. Once again, the L1 TLB slice 1201 is shown disposed in Way 0 (reference numeral 601), shown in dotted outline, of the L1 cache 245, also shown in dotted outline. As before, a single L1 TLB slice may be implemented that provides translated address bits A12 and A13 for all of the ways in the L1 cache 245, or a separate L1 TLB slice may be implemented in each way.</p><p>When a physical address is written into the L1 TLB 230 after an L1 TLB \"miss\", the A12 and A13 bits are not written to the L1 TLB slice 1201. Instead, A12 and A13 are decoded in a 2-to-4 decoder; and, (similar to decoder 1102) and the output of the decoder, multiplexer selection bits S0-S3 are simultaneously written to the L1 TLB slice 1201 thereby incurring the decoding delay by decoding A13 and A12 and storing S0-S3 in the L1 TLB slice 1201 only upon a TLB fill-after-miss. The L1 TLB slice 1201 now contains four bits in each of its sixteen entries, rather than two bits.</p><p>When the untranslated linear address bits A(15:12) select an entry in the L1 TLB slice 1201, selection bits S0-S3 are output from the L1 TLB slice 1201 to multiplexer 701. Thus, a 32-byte cache line is selected from one of the four sectors, Data Sectors 0-3, in Way 0 of the L1 cache 245 and is output during AC1 to the multiplexer 620. As before, each of Ways 1-3 also outputs a 32-byte cache line to multiplexer 620.</p><p>Although the present invention has been described in detail, those skilled in the art should understand that they can make various changes, substitutions and alterations herein without departing from the spirit and scope of the invention in its broadest form.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Daniel W.", "last_name": "Green", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "VIA-CYRIX, INC."}, {"first_name": "", "last_name": "VIA-CYRIX, INC", "name": ""}, {"first_name": "", "last_name": "NATIONAL SEMICONDUCTOR CORP", "name": ""}, {"first_name": "", "last_name": "CYRIX CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/08"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/10        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711003"}, {"primary": false, "label": "711128"}, {"primary": false, "label": "711207"}, {"primary": false, "label": "711122"}, {"primary": false, "label": "36504916"}, {"primary": false, "label": "711E12063"}, {"primary": false, "label": "711211"}], "ecla_classes": [{"label": "G06F  12/10L4P"}], "cpc_classes": [{"label": "G06F  12/1054"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1997-05-30", "application_date": "1997-05-30", "family_members": [{"ucid": "US-6065091-A", "titles": [{"lang": "EN", "text": "Translation look-aside buffer slice circuit and method of operation"}]}]}