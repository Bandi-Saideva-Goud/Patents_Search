{"patent_number": "US-6647464-B2", "publication_id": 73602051, "family_id": 24019062, "publication_date": "2003-11-11", "titles": [{"lang": "EN", "text": "System and method utilizing speculative cache access for improved performance"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50574541\"><p>A system and method are disclosed which provide a cache structure that allows early access to the cache structure's data. A cache design is disclosed that, in response to receiving a memory access request, begins an access to a cache level's data before a determination has been made as to whether a true hit has been achieved for such cache level. That is, a cache design is disclosed that enables cache data to be speculatively accessed before a determination is made as to whether a memory address required to satisfy a received memory access request is truly present in the cache. In a preferred embodiment, the cache is implemented to make a determination as to whether a memory address required to satisfy a received memory access request is truly present in the cache structure (i.e., whether a \u201ctrue\u201d cache hit is achieved). Although, such a determination is not made before the cache data begins to be accessed. Rather, in a preferred embodiment, a determination of whether a true cache hit is achieved in the cache structure is performed in parallel with the access of the cache structure's data. Therefore, a preferred embodiment implements a parallel path by beginning the cache data access while a determination is being made as to whether a true cache hit has been achieved. Thus, the cache data is retrieved early from the cache structure and is available in a timely manner for use by a requesting execution unit.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00001\" num=\"1\"><claim-text>1. A method of accessing cache, said method comprising the steps of:</claim-text><claim-text>inputting a memory access request into a multi-level cache, wherein each level of said multi-level cache comprises a data array; and </claim-text><claim-text>starting an access of data arrays of multiple levels of said multi-level cache in parallel without having first determined whether a memory address required to satisfy said memory access request is truly present in any of said multiple levels of said multi-level cache, wherein said starting comprises beginning an access of a tag array of a level of said multi-level cache before decoding an entire physical address for said memory access request for said level. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00002\" num=\"2\"><claim-text>2. A The method of <claim-ref idref=\"US-6647464-B2-CLM-00001\">claim 1</claim-ref> wherein said memory access request is a data read request.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00003\" num=\"3\"><claim-text>3. The method of <claim-ref idref=\"US-6647464-B2-CLM-00001\">claim 1</claim-ref> wherein said determining whether a memory address required to satisfy said memory access request is truly present in any of said multiple levels of said multi-level cache comprises the steps of:</claim-text><claim-text>determining whether a tag match is achieved for any of said multiple levels of said multi-level cache; and </claim-text><claim-text>if determined that a tag match is achieved for a level of said multiple levels, then determining whether a MESI protocol indicates that said tag match is a valid tag match, wherein only if said tag match is a valid tag match is it determined that said memory address required to satisfy said memory access request is truly present in any of said multiple levels of said multi-level cache. </claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00004\" num=\"4\"><claim-text>4. The method of <claim-ref idref=\"US-6647464-B2-CLM-00001\">claim 1</claim-ref> further comprising the step of:</claim-text><claim-text>determining whether the memory address required to satisfy said memory access request is truly present in a level of said multi-level cache. </claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00005\" num=\"5\"><claim-text>5. The method of <claim-ref idref=\"US-6647464-B2-CLM-00004\">claim 4</claim-ref> further comprising the step of:</claim-text><claim-text>determining whether the memory address required to satisfy said memory access request is truly present in a level of said multi-level cache in parallel with said starting an access of said data arrays. </claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00006\" num=\"6\"><claim-text>6. The method of <claim-ref idref=\"US-6647464-B2-CLM-00001\">claim 1</claim-ref> wherein said multi-level cache is partitioned into multiple ways.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00007\" num=\"7\"><claim-text>7. The method of <claim-ref idref=\"US-6647464-B2-CLM-00001\">claim 1</claim-ref> wherein said starting an access comprises beginning a decode of a physical address to be accessed in said data array.</claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00008\" num=\"8\"><claim-text>8. The method of <claim-ref idref=\"US-6647464-B2-CLM-00001\">claim 1</claim-ref> wherein said starting an access comprises inputting at least a portion of a physical address to decode circuitry associated with said data array.</claim-text></claim>"}, {"num": 9, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00009\" num=\"9\"><claim-text>9. A method of accessing a cache, said method comprising the steps of:</claim-text><claim-text>inputting a memory access request into a cache structure; </claim-text><claim-text>first receiving a virtual address for said memory access request in a TLB, wherein said TLB begins translation of said received virtual address to a physical address and wherein at least one bit of said virtual address is the same for said physical address; </claim-text><claim-text>then in parallel with said TLB translating said received virtual address to a physical address, beginning an access of said cache structure's tags using at least one of said at least one bit of said virtual address that is the same for said physical address; </claim-text><claim-text>once a physical address is output by said TLB, beginning a decode of at least part of said physical address to access said cache structure's data array(s); and </claim-text><claim-text>in parallel with said decode, using MESI protocol to verify that a true tag hit is achieved for said cache structure. </claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00010\" num=\"10\"><claim-text>10. A computer system comprising:</claim-text><claim-text>at least one processor that executes instructions; </claim-text><claim-text>multi-level cache structure accessible by said at least one processor to satisfy memory access requests, wherein each level of said multi-level cache structure comprises a data array and corresponding decode circuitry for said data array and wherein said multi-level cache structure is configured to receive into decode circuitry of a level of said multi-level cache structure at least a portion of a memory address for a received memory access request without first determining whether a memory address required to satisfy said received memory access request is truly present in said data array of said level of said multi-level cache structure; and </claim-text><claim-text>wherein said level of said multi-level cache structure comprises tag match circuitry operable to determine whether a tag hit is achieved for said memory address in said level, and wherein said tag match circuitry is configured to receive at least part of said memory address before said decode circuitry of said level decodes said memory address. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00011\" num=\"11\"><claim-text>11. The computer system of <claim-ref idref=\"US-6647464-B2-CLM-00010\">claim 10</claim-ref> wherein said multi-level cache structure further comprises:</claim-text><claim-text>a TLB that receives a virtual address for said memory access request and outputs a corresponding physical address. </claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00012\" num=\"12\"><claim-text>12. The computer system of <claim-ref idref=\"US-6647464-B2-CLM-00011\">claim 11</claim-ref> wherein said decode circuitry decodes at least a portion of a physical address output by said TLB to determine a physical address to access in said data array.</claim-text></claim>"}, {"num": 13, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00013\" num=\"13\"><claim-text>13. The computer system of <claim-ref idref=\"US-6647464-B2-CLM-00010\">claim 10</claim-ref> wherein said level of said multi-level cache structure further comprises MESI circuitry that determines whether said tag hit is a true tag hit wherein said level of said multi-level cache is implemented such that said decode circuitry of said level begins executing before said MESI circuitry determines whether said tag hit is a true tag hit.</claim-text></claim>"}, {"num": 14, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00014\" num=\"14\"><claim-text>14. The computer system of <claim-ref idref=\"US-6647464-B2-CLM-00010\">claim 10</claim-ref> wherein said received memory access request is a data read request.</claim-text></claim>"}, {"num": 15, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00015\" num=\"15\"><claim-text>15. The computer system of <claim-ref idref=\"US-6647464-B2-CLM-00010\">claim 10</claim-ref> wherein said decode circuitry of said level receives said at least a portion of said memory address in parallel with execution of said tag match circuitry.</claim-text></claim>"}, {"num": 16, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00016\" num=\"16\"><claim-text>16. A multi-level cache structure that is accessible to at least one computer processor to satisfy memory access requests for instructions being executed by said at least one computer processor, said multi-level cache structure comprising:</claim-text><claim-text>a data array for each level of said multi-level cache structure; </claim-text><claim-text>means for receiving a memory access request from at least one processor; </claim-text><claim-text>means for beginning decode of a memory address for a received memory access request for multiple levels of said multi-level cache structure's data arrays in parallel without having first determined whether a memory address required to satisfy said received memory access request is truly present in said multi-level cache structure; and </claim-text><claim-text>means for determining whether said memory address required to satisfy said received memory access request is truly present in a level of said multi-level cache, wherein said means for beginning decode begins said decode for said level in parallel with execution of the determining means. </claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00017\" num=\"17\"><claim-text>17. The multi-level cache structure of <claim-ref idref=\"US-6647464-B2-CLM-00016\">claim 16</claim-ref> wherein said received memory access request is a data read request.</claim-text></claim>"}, {"num": 18, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00018\" num=\"18\"><claim-text>18. The multi-level cache structure of <claim-ref idref=\"US-6647464-B2-CLM-00016\">claim 16</claim-ref> wherein said receiving means comprises a TLB that translates a virtual address for said memory access request into a physical address, and wherein said beginning means comprises decode circuitry that decodes at least a portion of a physical address output by said TLB.</claim-text></claim>"}, {"num": 19, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00019\" num=\"19\"><claim-text>19. A method of accessing a cache, the method comprising:</claim-text><claim-text>receiving at a cache a virtual address for a memory access request, wherein a portion of the virtual address corresponds to a first portion of a physical address of said cache; and </claim-text><claim-text>inputting said portion of said virtual address that corresponds to said first portion of said physical address to a tag array for said cache before determining an entire physical address. </claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00020\" num=\"20\"><claim-text>20. The method of <claim-ref idref=\"US-6647464-B2-CLM-00019\">claim 19</claim-ref> further comprising:</claim-text><claim-text>inputting said virtual address to a TLB to determine said entire physical address in parallel with said inputting said portion of said virtual address to said tag array. </claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00021\" num=\"21\"><claim-text>21. The method of <claim-ref idref=\"US-6647464-B2-CLM-00020\">claim 20</claim-ref> further comprising:</claim-text><claim-text>said TLB outputting said entire physical address. </claim-text></claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00022\" num=\"22\"><claim-text>22. The method of <claim-ref idref=\"US-6647464-B2-CLM-00021\">claim 21</claim-ref> further comprising:</claim-text><claim-text>inputting to said tag array a portion of said entire physical address output by said TLB that when combined with said first portion of said physical address forms said entire physical address. </claim-text></claim>"}, {"num": 23, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00023\" num=\"23\"><claim-text>23. The method of <claim-ref idref=\"US-6647464-B2-CLM-00021\">claim 21</claim-ref> further comprising:</claim-text><claim-text>inputting at least a portion of said entire physical address to decode circuitry for a data array before determining whether said data array is capable of satisfying said memory access request. </claim-text></claim>"}, {"num": 24, "parent": 23, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00024\" num=\"24\"><claim-text>24. The method of <claim-ref idref=\"US-6647464-B2-CLM-00023\">claim 23</claim-ref> wherein said determining whether said data array is capable of satisfying said memory access request comprises determining whether a tag hit is achieved for the data array in said tag array.</claim-text></claim>"}, {"num": 25, "parent": 24, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00025\" num=\"25\"><claim-text>25. The method of <claim-ref idref=\"US-6647464-B2-CLM-00024\">claim 24</claim-ref> wherein said determining whether said data array is capable of satisfying said memory access request further comprises using MESI circuitry to determine whether a tag hit achieved for the data array in said tag array is a true tag hit.</claim-text></claim>"}, {"num": 26, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00026\" num=\"26\"><claim-text>26. The method of <claim-ref idref=\"US-6647464-B2-CLM-00019\">claim 19</claim-ref> wherein said cache comprises a multi-level cache.</claim-text></claim>"}, {"num": 27, "parent": 26, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00027\" num=\"27\"><claim-text>27. The method of <claim-ref idref=\"US-6647464-B2-CLM-00026\">claim 26</claim-ref> wherein each level of said multi-level cache comprises a data array and a corresponding tag array.</claim-text></claim>"}, {"num": 28, "parent": 27, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00028\" num=\"28\"><claim-text>28. The method of <claim-ref idref=\"US-6647464-B2-CLM-00027\">claim 27</claim-ref> further comprising:</claim-text><claim-text>inputting said portion of said virtual address that corresponds to said first portion of said physical address to tag arrays for multiple levels of said multi-level cache before determining an entire physical address. </claim-text></claim>"}, {"num": 29, "parent": 27, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00029\" num=\"29\"><claim-text>29. The method of <claim-ref idref=\"US-6647464-B2-CLM-00027\">claim 27</claim-ref> further comprising:</claim-text><claim-text>inputting at least a portion of said entire physical address to decode circuitry for data arrays of multiple levels of said multi-level cache in parallel, before determining whether any of said data arrays of said multiple levels are capable of satisfying said memory access request. </claim-text></claim>"}, {"num": 30, "parent": 29, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00030\" num=\"30\"><claim-text>30. The method of <claim-ref idref=\"US-6647464-B2-CLM-00029\">claim 29</claim-ref> wherein said determining whether any of said data arrays of said multiple levels are capable of satisfying said memory access request comprises determining whether a tag hit is achieved in said tag arrays for any of said multiple levels.</claim-text></claim>"}, {"num": 31, "parent": 30, "type": "dependent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00031\" num=\"31\"><claim-text>31. The method of <claim-ref idref=\"US-6647464-B2-CLM-00030\">claim 30</claim-ref> wherein said determining whether any of said data arrays of said multiple levels are capable of satisfying said memory access request further comprises using MESI circuitry to determine whether a tag hit achieved in said tag arrays is a true tag hit.</claim-text></claim>"}, {"num": 32, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6647464-B2-CLM-00032\" num=\"32\"><claim-text>32. A computer system comprising:</claim-text><claim-text>at least one processor that executes instructions synchronous with a clock; </claim-text><claim-text>multi-level cache structure accessible by said at least one processor to satisfy memory access requests; </claim-text><claim-text>said multi-level cache structure comprising a TLB that receives a virtual address for a memory access request and outputs a corresponding physical address, a data array structure that is capable of being accessed to satisfy said memory access request, decode circuitry that decodes at least a portion of a physical address output by said TLB to determine a physical address to access in said data array structure, tag match circuitry that determines whether a tag hit is achieved for said multi-level cache structure for said memory access request, and MESI circuitry that determines whether said tag hit is a true tag hit; and </claim-text><claim-text>wherein said multi-level cache is implemented such that said decode circuitry begins executing in a same cycle of said clock that said MESI circuitry is executing for determining whether said tag hit is a true tag hit.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54013272\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><h4>RELATED APPLICATIONS</h4><p>This application is related to co-pending and commonly assigned patent application Ser. No. 09/501,396 entitled \u201cMETHOD AND SYSTEM FOR EARLY TAG ACCESSES FOR LOWER-LEVEL CACHES IN PARALLEL WITH FIRST-LEVEL CACHE,\u201d filed Feb. 9, 2000; and co-filed and commonly assigned patent application Ser. No. 09/507,241 entitled \u201cMETHOD AND SYSTEM FOR PROVIDING A HIGH BANDWIDTH CACHE THAT ENABLES SIMULTANEOUS READS AND WRITES WITHIN THE CACHE,\u201d the disclosures of which are hereby incorporated herein by reference.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>TECHNICAL FIELD</h4><p>This invention relates in general to cache accesses in a processor, and in specific to a system and method for speculatively accessing data in a cache before verifying a tag hit for such cache.</p><h4>BACKGROUND</h4><p>Computer systems may employ a multi-level hierarchy of memory, with relatively fast, expensive but limited-capacity memory at the highest level of the hierarchy and proceeding to relatively slower, lower cost but higher-capacity memory at the lowest level of the hierarchy. The hierarchy may include a small fast memory called a cache, either physically integrated within a processor or mounted physically close to the processor for speed. The computer system may employ separate instruction caches and data caches. In addition, the computer system may use multiple levels of caches. The use of a cache is generally transparent to a computer program at the instruction level and can thus be added to a computer architecture without changing the instruction set or requiring modification to existing programs.</p><p>Computer processors typically include cache for storing data. When executing an instruction that requires access to memory (e.g., read from or write to memory), a processor typically accesses cache in an attempt to satisfy the instruction. Of course, it is desirable to have the cache implemented in a manner that allows the processor to access the cache in an efficient manner. That is, it is desirable to have the cache implemented in a manner such that the processor is capable of accessing the cache (i.e., reading from or writing to the cache) quickly so that the processor may be capable of executing instructions quickly.</p><p>Prior art cache designs for computer processors typically require \u201ccontrol data\u201d to be available before a cache data access begins. Such \u201ccontrol data\u201d indicates whether a desired address (i.e., an address required for a memory access request) is contained within the cache. Accordingly, prior art caches are typically implemented in a serial fashion, wherein upon the cache receiving a memory access request, control data is obtained for the request, and thereafter if the control data indicates that the desired address is contained within the cache, the cache's data array is accessed to satisfy the memory access request.</p><p>Thus, prior art cache designs typically generate control data indicating whether a true cache \u201chit\u201d has been achieved for a level of cache, and only after a true cache hit has been achieved is the cache data actually accessed to satisfy the memory access request. A true cache \u201chit\u201d occurs when a processor requests an item from a cache and the item is actually present in the cache. A cache \u201cmiss\u201d occurs when a processor requests an item from a cache and the item is not present in the cache. The control data indicating whether a \u201ctrue\u201d cache hit has been achieved for a level of cache typically comprises a tag match signal. The tag match signal indicates whether a match was made for a requested address in the tags of a cache level. However, such a tag match signal alone does not indicate whether a true cache hit has been achieved.</p><p>As an example, in a multi-processor system, a tag match may be achieved for a cache level, but the particular cache line for which the match was achieved may be invalid. For instance, the particular cache line may be invalid because another processor has snooped out that particular cache line. Accordingly, in multi-processor systems a MESI signal is also typically utilized to indicate whether a line in cache is \u201cModified and Exclusive, Shared, or Invalid.\u201d Therefore, the control data that indicates whether a true cache hit has been achieved for a level of cache typically comprises a MESI signal, as well as the tag match signal. Only if a tag match is found for a level of cache and the MESI protocol indicates that such tag match is valid, does the control data indicate that a true cache hit has been achieved. In view of the above, in prior art cache designs a determination is first made as to whether a tag match is found for a level of cache, and then a determination is made as to whether the MESI protocol indicates that a tag match is valid. Thereafter, if a determination has been made that a true tag hit has been achieved, access begins to the actual cache data requested.</p><p>Typically, in multi-level cache designs, the first level of cache (i.e., L<b>0</b>) is first accessed to determine whether a true cache hit for a memory access request is achieved. If a true cache hit is not achieved for the first level of cache, then a determination is made for the second level of cache (i.e., L<b>1</b>), and so on, until the memory access request is satisfied by a level of cache. If the requested address is not found in any of the cache levels, the processor then sends a request to the system's main memory in an attempt to satisfy the request. In many processor designs, the time required to access an item for a true cache hit is one of the primary limiters for the clock rate of the processor if the designer is seeking a single-cycle cache access time. In other designs, the cache access time may be multiple cycles, but the performance of a processor can be improved in most cases when the cache access time in cycles is reduced. Therefore, optimization of access time for cache hits is critical for the performance of the computer system.</p><p>Turning to FIG. 1, an example of a typical cache design of the prior art is shown. Typically, when an instruction requires access to a particular address, a virtual address is provided from the processor to the cache system. As is well-known in the art, such virtual address typically contains an index field and a virtual page number field. The virtual address is input into a translation look-aside buffer (\u201cTLB\u201d) <b>10</b>. TLB <b>10</b> is a common component of modern cache architectures that is well known in the art. TLB <b>10</b> provides a translation from the received virtual address to a physical address. Within a computer system, the virtual address space is typically much larger than the physical address space. The physical address space is the actual, physical memory address of a computer system, which includes cache, main memory, a hard drive, and anything else that the computer can access to retrieve data. Thus, for a computer system to be capable of accessing all of the physical address space, a complete physical mapping from virtual addresses to physical addresses is typically provided.</p><p>Once the received virtual address is translated into a physical address by the TLB <b>10</b>, the index field of such physical address is input into the cache level's tag(s) <b>12</b>, which may be duplicated N times for N \u201cways\u201d of associativity. As used herein, the term \u201cway\u201d refers to a partition of the cache. For example, the cache of a system may be partitioned into any number of ways. Caches are commonly partitioned into four ways. The physical address index is also input to the cache level's data array(s) <b>16</b>, which may also be duplicated N times for N ways of associativity.</p><p>From the cache level's tag(s) <b>12</b>, a way tag match signal is generated for each way. The way tag match signal indicates whether a match for the physical address was made within the cache level's tag(s) <b>12</b>. As discussed above, in multi-processor systems, a MESI protocol is typically utilized to indicate whether a line in cache is modified and exclusive, shared, or invalid. Accordingly, in such multi-processor systems the MESI protocol is combined with the way tag match signal to indicate whether a \u201ctrue\u201d tag hit has been achieved for a level of cache. Thus, in multi-processor systems a true tag hit is achieved when both a tag match is found for tag(s) <b>12</b> and the MESI protocol indicates that such tag match is a valid match. Accordingly, in FIG. 1, MESI circuitry <b>14</b> is utilized to calculate a \u201ctrue\u201d tag hit signal to determine whether a true tag hit has been achieved for that level of cache. Once it is determined from the MESI <b>14</b> that a \u201ctrue\u201d tag hit has been achieved for that level of cache, then that cache level's data array(s) <b>16</b>, which may also be duplicated N times for N ways of associativity, are accessed to satisfy the received memory access request. More specifically, the true tag hit signal may be used to control a multiplexer (\u201cMUX\u201d) <b>18</b> to select the appropriate data array way to output data to satisfy the received memory access request. The selected data from data array(s) <b>16</b> is output to the chip's core <b>20</b>, which is the particular execution unit (e.g., an integer execution unit or floating point execution unit) that issued the memory access request to the cache.</p><p>In view of the above, prior art caches are typically implemented in a serial fashion, wherein the physical address is first determined, then whether a tag match is achieved for the requested physical address within a particular level of cache is determined, then whether a \u201ctrue\u201d cache hit is achieved within the particular level of cache is determined, and finally the data array(s) for the particular level of cache are accessed if a \u201ctrue\u201d cache hit has been achieved. Thus, even though prior art caches determine the physical address relatively early, the cache's data is not accessed until it has been determined whether a \u201ctrue\u201d cache hit has been achieved for the cache. Such a serial access of cache data is disadvantageous in that it is slow. Such a serial cache implementation generally adds one to two clock cycles of data access latency because the cache tags and MESI must first complete to determine whether a valid hit has been achieved for the cache before beginning the data access. Thus, such a serial access of cache data requires an undesirably long time to access the cache data. Therefore, serial cache designs of the prior art increase latency in retrieving data from cache, which slows the execution unit within the core of a chip. That is, while an execution unit is awaiting data from cache, it is stalled, which results in a net lower performance for a system's processor.</p><h4>SUMMARY OF THE INVENTION</h4><p>In view of the above, a desire exists for a cache design that allows for cache data to be accessed in a timely manner. That is, a desire exists for a cache design that decreases the latency in retrieving data from cache that is present in prior art cache designs. A further desire exists for a cache design that allows for cache data to be accessed in a timely manner, while still verifying that a true tag hit has been achieved for the cache in order to ensure that the appropriate data is being accessed to satisfy a memory access request. Accordingly, a desire exists for a cache design that allows for cache data to be accessed quickly, thereby reducing the number of stalls required in the execution units requesting memory access and enhancing the overall performance the system.</p><p>These and other objects, features and technical advantages are achieved by a system and method which provide a cache design that, in response to receiving a memory access request, begins an access to a cache level's data before a determination has been made as to whether a true hit has been achieved for the cache level. That is, a system and method are provided which enable cache data to be speculatively accessed before a determination is made as to whether a memory address required to satisfy a memory access request is truly present in the cache.</p><p>In a preferred embodiment, a cache structure is provided that receives memory access requests from at least one processor of a computer system. In response to receiving such a memory access request, the cache structure begins an access of its data array(s) in an attempt to satisfy the received request, without first determining whether a memory address required to satisfy the received memory access request is truly present in the cache structure. In a most preferred embodiment, such a cache structure is a level of a multi-level cache implemented for a computer system.</p><p>In a preferred embodiment, the cache is implemented such that a determination is made as to whether a memory address required to satisfy a received memory access request is truly present in the cache structure. That is, a preferred embodiment determines whether a true cache hit is achieved in the cache structure for a received memory access request. Although, such a determination is not made before the cache data begins to be accessed. Rather, in a preferred embodiment, a determination of whether a true cache hit is achieved in the cache structure is performed in parallel with the access of the cache structure's data for a received memory access request. That is, a preferred embodiment determines whether a tag match is achieved for the cache structure's tags and whether a MESI protocol verifies that an achieved tag match is a valid match in parallel with accessing the cache structure's data array(s). Therefore, rather than the serial path of prior art cache designs in which a tag match is first determined, then a match is verified with a MESI protocol, then the cache data is accessed to satisfy a received memory access request, a preferred embodiment implements a parallel path by beginning the cache data access while a determination is being made as to whether a true cache hit has been achieved. Thus, the cache data is retrieved early from the cache structure and is available in a timely manner for use by a requesting execution unit, once it is determined that a true cache hit has been achieved for the cache structure.</p><p>In a preferred embodiment, the data access is begun before determining whether a true cache hit is achieved only for memory access requests that are data read requests. Thus, for \u201cwrite\u201d requests a preferred embodiment first determines whether a true cache hit is achieved before beginning the requested write.</p><p>It should be appreciated that a technical advantage of one aspect of the present invention is that a cache structure is implemented to allow for faster access of the cache structure's data by beginning the data access before it is determined whether a true cache hit is achieved for the cache structure. Accordingly, the cache design allows for cache data to be accessed in a timely manner. A further technical advantage of one aspect of the present invention is that a cache structure is implemented that allows for cache data to be accessed in a timely manner, while still verifying that a true tag hit has been achieved for the cache in order to ensure that the appropriate data is being accessed to satisfy a received memory access request. Yet a further technical advantage of one aspect of the present invention is that a cache structure is implemented such that the cache structure's data is accessed in parallel with determining whether a true cache hit is achieved for the cache structure, thereby decreasing the latency in retrieving data from cache that is present in prior art cache designs. That is, a cache structure is implemented that allows for cache data to be accessed quickly, thereby reducing the number of stalls required in the execution units requesting memory access and enhancing the overall performance of the system.</p><p>The foregoing has outlined rather broadly the features and technical advantages of the present invention in order that the detailed description of the invention that follows may be better understood. Additional features and advantages of the invention will be described hereinafter which form the subject of the claims of the invention. It should be appreciated by those skilled in the art that the conception and specific embodiment disclosed may be readily utilized as a basis for modifying or designing other structures for carrying out the same purposes of the present invention. It should also be realized by those skilled in the art that such equivalent constructions do not depart from the spirit and scope of the invention as set forth in the appended claims.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWING</h4><p>For a more complete understanding of the present invention, and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawing, in which:</p><p>FIG. 1 shows a typical cache design of the prior art, which determines whether a \u201ctrue\u201d tag hit is achieved for a cache level and then accesses the cache data in series;</p><p>FIG. 2 shows a preferred embodiment for a cache design of the present invention;</p><p>FIG. 3 shows a TLB implemented in a preferred embodiment;</p><p>FIG. 4 shows circuitry implemented for a cache tag access of a preferred embodiment; and</p><p>FIG. 5 shows circuitry implemented in a preferred embodiment to indicate whether a true cache hit is achieved for the cache level.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION</h4><p>Turning to FIG. 2, a preferred embodiment of the present invention is shown. As shown, execution of a preferred embodiment of a cache design <b>200</b> is illustrated in conjunction with a clock signal <b>40</b> to illustrate the execution flow through various pipe stages. Generally, a \u201cpipe stage\u201d is an individual clock cycle that is utilized for the occurrence of certain event(s) of a memory access. Because the use of pipe stages is well-known in the art, it will not be discussed in any greater detail herein. FIG. 2 illustrates a preferred embodiment implemented for level L<b>1</b> of cache. However, it should be understood that such design may be implemented for any level of cache and is not intended to be limited solely to L<b>1</b>. In the REG <b>0</b> pipe stage, level L<b>1</b> of cache <b>200</b> receives a virtual address for a memory access request from cache level L<b>0</b>, which is input to a translation look-aside buffer (\u201cTLB\u201d) <b>10</b> at the beginning of the L<b>0</b>M pipe stage. In the first clock phase (the clock high phase) of L<b>0</b>M, TLB <b>10</b> translates the received virtual address into a physical address. As discussed above, TLB <b>10</b> is a common component of modern cache architectures that is well known in the art. Turning briefly to FIG. 3, a preferred implementation for TLB <b>10</b> is illustrated. As shown in FIG. 3, in a preferred embodiment, a 64 bit virtual address (VA[<b>63</b>:<b>0</b>]) is received by TLB <b>10</b>, and a 45 bit physical address (PA[<b>44</b>:<b>0</b>]) is output by TLB <b>10</b>. Although, in alternative embodiments, any number of bits may be utilized for the virtual address and physical address. As illustrated in FIG. 3, TLB <b>10</b> receives a virtual address (VA[<b>63</b>:<b>0</b>]) and translates such virtual address into a physical address (PA[<b>44</b>:<b>0</b>]).</p><p>In most cache architectures, the lower address bits of the virtual address and the physical address match. As shown in FIG. 3, in a preferred embodiment, the lower twelve bits of the virtual address (VA[<b>11</b>:<b>0</b>]) match the lower twelve bits of the physical address (PA[<b>11</b>:<b>0</b>]). Although, in alternative embodiments, any number of bits of the virtual address and physical address may match. Because the lower twelve bits of the virtual address and physical address match in a preferred embodiment, TLB <b>10</b> translates the non-matching bits of the virtual address (VA[<b>63</b>:<b>12</b>]) into the appropriate physical address PA[<b>44</b>:<b>12</b>]. That is, TLB <b>10</b> performs a look-up to determine the mapping for the received virtual address. Generally, there exists only one mapping in TLB <b>10</b> for the received virtual address. Because PA[<b>11</b>:<b>0</b>] corresponds to VA[<b>11</b>:<b>0</b>] and TLB <b>10</b> translates VA[<b>63</b>:<b>12</b>] into PA[<b>44</b>:<b>12</b>], the entire physical address PA[<b>44</b>:<b>0</b>] is determined and output by TLB <b>10</b>.</p><p>Turning back to FIG. 2, in the second clock phase (the clock low phase) of the L<b>0</b>M pipe stage, the cache level's tag(s) are accessed, illustrated as L<b>1</b> Tag access <b>12</b> (cache level one tag access). L<b>1</b> Tag access <b>12</b> functions to access the cache level's tag(s) and determine a way tag match for the memory access request. Turning briefly to FIG. 4, a preferred embodiment for L<b>1</b> Tag access <b>12</b> is shown in greater detail. In a preferred embodiment, the physical address bits are utilized for the tag access as soon as such physical address bits are known. As discussed above, in a preferred embodiment, the lower twelve bits of the physical address (PA[<b>11</b>:<b>0</b>]) are the same as the lower twelve bits of the virtual address (VA[<b>11</b>:<b>0</b>]). Thus, those bits do not require a TLB translation. Therefore, the lower twelve bits of the physical address (PA[<b>11</b>:<b>0</b>]) are known very early. That is, the lower twelve bits of the physical address (PA[<b>11</b>:<b>0</b>]) are known a whole cycle earlier than the entire physical address (PA[<b>44</b>:<b>0</b>]) because the lower twelve bits are known as soon as the virtual address is received. A preferred embodiment utilizes this known data by starting the L<b>1</b> tag access path <b>12</b> early.</p><p>TLB <b>10</b> typically requires approximately one cycle to complete. In the second half of that cycle (the clock low phase), access to the cache's tag(s) begins, in a preferred embodiment. As shown in FIG. 4, physical address bits PA[<b>11</b>:<b>7</b>] are input to decode circuitry <b>402</b>. Although, in alternative embodiments, any of the known physical address bits may be utilized for such decode. Decode circuitry <b>402</b> decodes the physical address bits PA[<b>11</b>:<b>7</b>] to determine the physical address required for the received memory access request, and then the word lines are fired. Once the word lines are fired, the tag(s) <b>404</b> are read out. In a preferred embodiment, the tags <b>404</b> are duplicated 8 times for 8 ways of associativity. Thus, in a preferred embodiment, when the word lines are fired, eight different tags are read out of tags <b>404</b>. Of course, in alternative embodiments, any number of ways may be implemented for the cache.</p><p>As shown in FIG. 4, the decoding of PA[<b>11</b>:<b>7</b>] and reading out of tags <b>404</b> are performed in the L<b>0</b>M pipe stage. Thus, while TLB <b>10</b> is still completing, access of the L<b>1</b> cache tags <b>404</b> is started, in a preferred embodiment. Accordingly, in a preferred embodiment, the TLB access and the cache tag access are performed in parallel. It will be recalled that prior art cache designs typically access the TLB and cache tags in series. That is, prior art cache designs typically first access the TLB and then begin the access to the cache tags only after completing the TLB. Thus, a preferred embodiment reduces the latency involved in determining whether a tag match is achieved by accessing the cache level's tag(s) early.</p><p>In the L<b>0</b>M pipe stage, a tag is read out for each way. Therefore, in a preferred embodiment, eight tags (way tag <b>0</b> through way tag <b>7</b>) are read out in the L<b>0</b>M pipe stage. In a preferred embodiment, the tags are held to the L<b>0</b>D pipe stage. In the L<b>0</b>D pipe stage, TLB <b>10</b> has completed its translation and therefore the desired physical address PA[<b>44</b>:<b>0</b>] is known. That is, in the L<b>0</b>D pipe stage TLB <b>10</b> has completed its mapping of the virtual address to determine the bits of the physical address that were initially unknown (PA[<b>44</b>:<b>12</b>]). In a preferred embodiment, bits [<b>14</b>:<b>12</b>] of the physical address (i.e., PA[<b>14</b>:<b>12</b>]) are utilized in the L<b>0</b>D pipe stage to select one of the eight tags read out of the tag array <b>404</b> in the L<b>0</b>M pipe stage. In alternative embodiments, any of the bits of the physical address that result from the mapping of the TLB <b>10</b> (e.g., any of the PA[<b>44</b>:<b>12</b>] bits) may be utilized to select one of the tags read out in the L<b>0</b>M pipe stage. In a preferred embodiment, the eight tags read out of the tag array <b>404</b> are input to a MUX <b>406</b>, and the PA[<b>14</b>:<b>12</b>] bits are utilized to control MUX <b>406</b>. Thus, the PA[<b>14</b>:<b>12</b>] bits are utilized to select the appropriate way tag to be output by MUX <b>406</b>.</p><p>Thus, in the L<b>0</b>D pipe stage, a way tag match signal is generated from MUX <b>406</b>. It should be understood that this is not a \u201ctrue\u201d tag hit signal because the MESI information has not been combined with the match signal at this point. Rather, the tag access <b>12</b> generates strictly a way tag match signal. Turning back to FIG. 2, it is shown that in the first phase (the clock high phase) of L<b>0</b>D, L<b>1</b> Tag access <b>12</b> is completing the tag match path, as discussed above with reference to FIG. <b>4</b>. In parallel with L<b>1</b> Tag access <b>12</b> completing, the first phase (the clock high phase) of L<b>0</b>D is utilized to drive the physical address data from TLB <b>10</b> out to the cache data array(s). Thus, in a preferred embodiment, the cache level's data array(s) begin to be accessed for an address before it is determined whether a \u201ctrue\u201d cache hit is achieved for the cache level. It will be recalled that prior art cache designs typically determine whether a true cache hit is achieved for a cache level and then begin access to the cache level's data array(s) in series. That is, prior art cache designs typically first determine whether a true cache hit is achieved for a level of cache, and begin an access of the cache level's data array(s) only after it has been determined that a true cache hit has been achieved. Thus, a preferred embodiment reduces the latency involved in accessing the cache level's data by speculatively accessing the data early.</p><p>More specifically, in a preferred embodiment, TLB <b>10</b> outputs a physical address in the second phase (the clock low phase) of L<b>0</b>M. In a preferred embodiment, bits [<b>14</b>:<b>8</b>] of the physical address are input to a MUX <b>14</b>. Although, in alternative embodiments, any of the bits of the physical address may be utilized. In a most preferred embodiment, a 256 K-byte cache is implemented, which is banked into 16 banks having 128 lines per bank. Thus, in a most preferred embodiment, bits [<b>14</b>:<b>8</b>] of the physical address may be decoded to identify any of the 128 lines of a bank. Also, in a most preferred embodiment, bits [<b>7</b>:<b>4</b>] of the physical address are decoded to select to which bank an access is to be issued. Because these bits of the physical address are known early (e.g., they are known when the virtual address is received), the bank to be accessed can be selected early. Thus, a preferred embodiment enables the control circuitry to be set up early, thereby increasing the efficiency in accessing the memory. Of course, in alternative embodiments, any size cache may be implemented. Additionally, in alternative embodiments, any number of banks (i.e., from no banks to N banks) may be implemented for the cache. Generally, it is desirable to have the highest possible number of banks implemented for the cache.</p><p>As shown in FIG. 2, PA[<b>14</b>:<b>8</b>] of the output of TLB <b>10</b> is input to a dynamic MUX <b>14</b> in the second phase (the clock low phase) of LOM. Then in the first phase (the clock high phase) of the L<b>0</b>D pipe stage, MUX <b>14</b> outputs the PA[<b>14</b>:<b>8</b>], which is input to decode circuitry <b>18</b>. Accordingly, in a preferred embodiment, the decode circuitry <b>18</b> begins its decode for the data array(s) <b>20</b> in parallel with the tag match being determined in the L<b>1</b> Tag access <b>12</b> in the first phase (the clock high phase) of L<b>0</b>D. As decode circuitry <b>18</b> is decoding PA[<b>14</b>:<b>8</b>], tag match data from the L<b>1</b> Tag access <b>12</b> completes at the end of the first phase (the clock high phase) of L<b>0</b>D. Such tag match data from the L<b>1</b> Tag access <b>12</b> is input to a dynamic MUX <b>16</b>, which outputs such tag match data in the second phase of L<b>0</b>D (the clock low phase). Therefore, MUX <b>16</b> is used in a preferred embodiment to select the appropriate bank for a way tag match. More specifically, PA[<b>7</b>:<b>4</b>] controls the operation of MUX <b>16</b> to route the way tag match to the appropriate bank. MUX <b>16</b> of a preferred embodiment is controlled by PA[<b>7</b>:<b>4</b>] to route the physical addresses to the appropriate bank. In the first phase (the clock high phase) of L<b>0</b>W, the decode circuitry <b>18</b> has completed and the access of the data array <b>20</b> begins for the decoded address. That is, in the first phase of L<b>0</b>W, the physical address decode is available from decode circuitry <b>18</b>, and the word lines are fired causing eight ways of data to be read out of the data array <b>20</b> according to such decoded physical address. Accordingly, in the first phase of L<b>0</b>W the data arrays are speculatively accessed before a determination as to whether a true tag hit has been achieved for the L<b>1</b> cache.</p><p>Then later in the first phase of the L<b>0</b>W pipe stage, the way select is input from way select circuitry <b>22</b> into the data array(s) <b>20</b>. Such way select data is received later because it has the additional half-cycle access through the tags in the L<b>1</b> Tag access <b>12</b>. Therefore, in a preferred embodiment, the way select data is not received by the data array <b>20</b> until the end of the first phase (the clock high phase) of the L<b>0</b>W pipe stage. Only one of the eight ways of the cache will be high, and circuitry, such as a MUX (not shown), is utilized to select the data line read out of the cache data array <b>20</b> for the way that is high. That is, one of the eight data lines read out of the cache data array <b>20</b> is selected based on the way select signal from way select circuitry <b>22</b>, and such selected data is sent to the requesting execution unit. For instance, a dynamic MUX <b>24</b> may be implemented to deliver the selected data at the first phase (the clock high phase) of the L<b>1</b>D pipe stage to the requesting execution unit. For example, MUX <b>24</b> may output the selected data to the requesting floating point unit <b>26</b>, L<b>0</b>I instruction unit <b>28</b>, or the L<b>0</b>D integer execution unit <b>30</b>.</p><p>In a preferred embodiment, a determination is made as to whether a true cache hit is achieved for the cache level. Thus, even though the access to the cache level's data array(s) begins before a determination is made as to whether a true cache hit is achieved for the cache level, such determination is later made. Turning now to FIG. 5, a preferred embodiment for determining whether a true cache hit is achieved for a cache level is shown. As shown, the L<b>1</b>T access <b>12</b> is completed in the first phase (the clock high phase) of the L<b>0</b>D pipe stage. In a preferred embodiment, the way tag match data output by L<b>1</b>T access <b>12</b> is combined with MESI signal <b>50</b> in the second phase (the clock low phase) of L<b>0</b>D. Thus, in a preferred embodiment, a true hit/miss signal is generated in the second phase of L<b>0</b>D by combining the MESI information with the tag match. The true hit/miss signal is input to the L<b>1</b> data arrays <b>20</b> in the LOW pipe stage. Additionally, an \u201copcode\u201d valid signal is input to the L<b>1</b> data arrays <b>20</b>, which indicates whether the received instruction was a valid operation. In a preferred embodiment, the opcode valid signal is combined with the true hit/miss signal to produce a valid access signal, which is then sent out to the requesting execution unit via MUX <b>24</b> in the first phase of L<b>1</b>D. For example, MUX <b>24</b> may send the valid access signal to a floating point unit <b>26</b>, L<b>0</b>I instruction unit <b>28</b>, or L<b>0</b>D integer execution unit <b>30</b>. Such valid access signal indicates to the execution units that the data, which began to be accessed in L<b>0</b>D, is actually valid.</p><p>It should be understood that in a most preferred embodiment, the speculative cache data access as described herein is implemented only for a load path. That is, in a most preferred embodiment, the speculative cache data access is utilized only for received memory access requests desiring to read data from cache. Thus, for a most preferred embodiment, a determination of whether a true hit has been achieved for the cache level is made before accessing the cache level's data for a store path (i.e., for a received memory access request desiring to write data to cache). Reads may be performed speculatively with only a risk of wasting power by accessing a cache level's data and determining that the cache level missed (i.e., that the requested address is not in the cache level). However, if a write is performed speculatively, then the cache's data may be corrupted if a miss occurs. Accordingly, a most preferred embodiment reduces the latency required for accessing cache data to satisfy a received data read request.</p><p>Additionally, in a most preferred embodiment, multiple levels of a multi-level cache may be accessed in parallel. For example, in a most preferred embodiment, the physical address from the TLB <b>10</b> may be sent to the L<b>2</b> cache to begin the access of the L<b>2</b> cache data array(s) in parallel with the L<b>1</b> cache data array(s) <b>20</b> in the L<b>0</b>D pipe stage. For example, the cache may be implemented so as to access multiple levels in parallel in the manner disclosed in U.S. patent application Ser. No. 09/501,396 entitled \u201cMETHOD AND SYSTEM FOR EARLY TAG ACCESSES FOR LOWER-LEVEL CACHES IN PARALLEL WITH FIRST-LEVEL CACHE,\u201d the disclosure of which is hereby incorporated herein by reference. Thus, in a most preferred embodiment, the cache may be implemented to hedge its bets, such that if the L<b>1</b> cache misses, an access has already begun to the L<b>2</b> cache. If the L<b>1</b> hits, then a signal may be sent to the L<b>2</b> cache, causing the L<b>2</b> cache to abort its data access.</p><p>In a most preferred embodiment, the banking implementation described in the U.S. patent application Ser. No. 09/507,241 entitled \u201cMETHOD AND SYSTEM FOR PROVIDING A HIGH BANDWIDTH CACHE THAT ENABLES SIMULTANEOUS READS AND WRITES WITHIN THE CACHE,\u201d the disclosure of which is hereby incorporated herein by reference, may be implemented in this architecture to allow for increased bank width utilization. That is, the increased bandwidth disclosed in \u201cMETHOD AND SYSTEM FOR PROVIDING A HIGH BANDWIDTH CACHE THAT ENABLES SIMULTANEOUS READS AND WRITES WITHIN THE CACHE\u201d may be implemented with the speculative cache data access design disclosed herein to further increase the system's performance.</p><p>As discussed above, in a preferred embodiment, an eight-way associative cache is implemented. However, it should be understood that various embodiments may be implemented having any number of ways, and any such implementation is intended to be within the scope of the present invention. Furthermore, it should be understood that no time penalty is inflicted by performing the speculative data access of a preferred embodiment. That is, in a preferred embodiment data is speculatively read out early with no time penalty inflicted if a miss occurs. If a miss occurs in the path of a preferred embodiment, a miss would have also occurred in the serial path of the prior art, but in the serial path the execution units would not be notified of such miss as soon. It should also be understood that a cache structure of the present invention may be implemented within any type of computer system having a processor, including but not limited to a personal computer (PC), laptop computer, and personal data assistant (e.g., a Palmtop PC).</p><p>Although the present invention and its advantages have been described in detail, it should be understood that various changes, substitutions and alterations can be made herein without departing from the spirit and scope of the invention as defined by the appended claims. Moreover, the scope of the present application is not intended to be limited to the particular embodiments of the process, machine, manufacture, composition of matter, means, methods and steps described in the specification. As one of ordinary skill in the art will readily appreciate from the disclosure of the present invention, processes, machines, manufacture, compositions of matter, means, methods, or steps, presently existing or later to be developed that perform substantially the same function or achieve substantially the same result as the corresponding embodiments described herein may be utilized according to the present invention. Accordingly, the appended claims are intended to include within their scope such processes, machines, manufacture, compositions of matter, means, methods, or steps.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Reid James", "last_name": "Riedlinger", "name": ""}, {"first_name": "Dean A.", "last_name": "Mulla", "name": ""}, {"first_name": "Tom", "last_name": "Grutkowski", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "HEWLETT-PACKARD DEVELOPMENT COMPANY, L.P."}, {"first_name": "", "last_name": "HEWLETT PACKARD ENTERPRISE DEVELOPMENT LP", "name": ""}, {"first_name": "", "last_name": "HEWLETT-PACKARD DEVELOPMENT COMPANY, L.P.", "name": ""}, {"first_name": "", "last_name": "HEWLETT-PACKARD COMPANY", "name": ""}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMFR"}], "national_classes": [{"primary": true, "label": "711122"}, {"primary": false, "label": "711120"}, {"primary": false, "label": "711E12049"}, {"primary": false, "label": "711141"}, {"primary": false, "label": "711118"}, {"primary": false, "label": "711204"}, {"primary": false, "label": "711119"}, {"primary": false, "label": "711206"}, {"primary": false, "label": "711137"}], "ecla_classes": [{"label": "G06F  12/08B6P"}], "cpc_classes": [{"label": "G06F  12/0855"}, {"label": "G06F  12/0855"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "2000-02-18", "application_date": "2000-02-18", "family_members": [{"ucid": "FR-2805368-A1", "titles": [{"lang": "EN", "text": "SYSTEM AND METHOD UTILIZING SPECEMATIVE ACCELERATION TO ANTEMEMOIRE FOR IMPROVED PERFORMANCE"}, {"lang": "FR", "text": "SYSTEME ET PROCEDE UTILISANT L'ACCES SPECULATIF A L'ANTEMEMOIRE POUR DES PERFORMANCES AMELIOREES"}]}, {"ucid": "FR-2805368-B1", "titles": [{"lang": "FR", "text": "SYSTEME ET PROCEDE UTILISANT L'ACCES SPECULATIF A L'ANTEMEMOIRE POUR DES PERFORMANCES AMELIOREES"}, {"lang": "EN", "text": "SYSTEM AND METHOD UTILIZING SPECEMATIVE ACCELERATION TO ANTEMEMOIRE FOR IMPROVED PERFORMANCE"}]}, {"ucid": "US-6647464-B2", "titles": [{"lang": "EN", "text": "System and method utilizing speculative cache access for improved performance"}]}, {"ucid": "US-20020169929-A1", "titles": [{"lang": "EN", "text": "System and method utilizing speculative cache access for improved performance"}]}]}