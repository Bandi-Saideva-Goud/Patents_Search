{"patent_number": "US-6282706-B1", "publication_id": 72770283, "family_id": 21803138, "publication_date": "2001-08-28", "titles": [{"lang": "EN", "text": "Cache optimization for programming loops"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11230341\" source=\"national office\"><p>A cache memory architecture 50, which may be, for example, a set associative cache memory, has a cache controller (52) with an internal register for storing the address of the active line currently latched in the output buffer of the high speed cache data array (56) which stores the cached data values from the main memory. If a memory access request specifies an address which would be contained in the active line, the cache look-up mechanisms are disabled and the data is taken from the output buffer. The efficiency of the cache can be increased by linking a program to memory such that the number of cache lines used by one or more program loops are minimized.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72604524\"><p>A cache memory architecture <b>50</b>, which may be, for example, a set associative cache memory, has a cache controller (<b>52</b>) with an internal register for storing the address of the active line currently latched in the output buffer of the high speed cache data array (<b>56</b>) which stores the cached data values from the main memory. If a memory access request specifies an address which would be contained in the active line, the cache look-up mechanisms are disabled and the data is taken from the output buffer. The efficiency of the cache can be increased by linking a program to memory such that the number of cache lines used by one or more program loops are minimized.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00001\" num=\"1\"><claim-text>1. A method of executing a program in a processing circuit including a main memory and a cache memory, said cache memory comprising a plurality of data lines, each data line storing a plurality of data words, comprising the steps of:</claim-text><claim-text>identifying one or more programming loops within compiled code for the program; </claim-text><claim-text>linking the program to said main memory, such that a minimum number of cache lines are used to store each programming loop. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00002\" num=\"2\"><claim-text>2. The method of claim <b>1</b> wherein said step of identifying one or more programming loops comprises the step of evaluating said compiled code for looping constructs.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00003\" num=\"3\"><claim-text>3. The method of claim <b>1</b> wherein said step of identifying one or more programming loops comprises the step of identifying labels in information associated with the compiled code.</claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00004\" num=\"4\"><claim-text>4. The method of claim <b>3</b> wherein said information comprises header information in a common object file format (COFF) header.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00005\" num=\"5\"><claim-text>5. The method of claim <b>1</b> wherein said linking step comprises the step of moving an identified programming loop to start at a memory location associated with a first word in a cache line.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00006\" num=\"6\"><claim-text>6. The method of claim <b>1</b> and further comprising the step of prioritizing programming loops.</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00007\" num=\"7\"><claim-text>7. The method of claim <b>6</b> wherein said prioritizing is based on the number of times a programming loop is repeated.</claim-text></claim>"}, {"num": 8, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00008\" num=\"8\"><claim-text>8. A processing device comprising:</claim-text><claim-text>a main memory; </claim-text><claim-text>a cache memory coupled to said main memory; </claim-text><claim-text>a processor for identifying program loops in compiled code for a program and linking said program loops to said main memory such that said program loops are stored in said cache memory in a minimum number of cache memory lines. </claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00009\" num=\"9\"><claim-text>9. The processing device of claim <b>8</b> wherein said processor identifies one or more programming loops by evaluating said compiled code for looping constructs.</claim-text></claim>"}, {"num": 10, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00010\" num=\"10\"><claim-text>10. The processing device of claim <b>8</b> wherein said processor identifies one or more programming loops by identifying labels in information associated with the code.</claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00011\" num=\"11\"><claim-text>11. The processing device of claim <b>10</b> wherein said information comprises header information in a common object file format (COFF) header.</claim-text></claim>"}, {"num": 12, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00012\" num=\"12\"><claim-text>12. The processing device of claim <b>8</b> wherein said processor links program loops to memory by linking an identified programming loop to start at a memory location associated with a first word in a cache line.</claim-text></claim>"}, {"num": 13, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00013\" num=\"13\"><claim-text>13. The processing device of claim <b>8</b> wherein said processor prioritizes programming loops to determine which programming loops will be moved to another location in memory.</claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00014\" num=\"14\"><claim-text>14. The processing device of claim <b>13</b> wherein said prioritizing is based on the number of times a programming loop is repeated.</claim-text></claim>"}, {"num": 15, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00015\" num=\"15\"><claim-text>15. The processing device of claim <b>8</b> wherein said processor comprises a first processor and further comprising a second processor for executing the programming loop after linking by said first processor.</claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00016\" num=\"16\"><claim-text>16. The processing device of claim <b>15</b> wherein said second processor comprises a digital signal processor.</claim-text></claim>"}, {"num": 17, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00017\" num=\"17\"><claim-text>17. The processing device of claim <b>15</b> and wherein said first processor accesses non-compiled code and generates unlinked compiled code for the second processor from which the program loops are identified.</claim-text></claim>"}, {"num": 18, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00018\" num=\"18\"><claim-text>18. The processing device of claim <b>17</b> wherein said first processor generates unlinked compiled code from a portable non-compiled code.</claim-text></claim>"}, {"num": 19, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00019\" num=\"19\"><claim-text>19. The processing device of claim <b>17</b> wherein said portable non-compiled code is JAVA.</claim-text></claim>"}, {"num": 20, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6282706-B1-CLM-00020\" num=\"20\"><claim-text>20. A processing device comprising:</claim-text><claim-text>a main memory; </claim-text><claim-text>a digital signal processor having an associated cache; </claim-text><claim-text>a cache memory coupled to said main memory; and </claim-text><claim-text>a general processor for generating unlinked compiled code for said digital signal processor from a portable non-compiled program code, for identifying programming loops in said unlinked compiled code and for linking said program loops to said main memory such that said program loops are stored in said cache memory associated with the digital signal processor in a minimum number of cache memory lines.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54715359\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>CROSS-REFERENCE TO RELATED APPLICATIONS</h4><p>This application is related U.S. Ser. No. 08/995,600 entitled \u201cMobile Communication System with Cross Compiler and Cross Linker\u201d to Woolsey et al, U.S. Ser. No. 08/995,597, entitled Method and Apparatus for Providing Downloadable Functionality to an Embedded Coprocessor\u201cto Brewer, U.S. Ser. No. 08/995,603, entitled Method and Apparatus for Extending Security Model to Native Code\u201d to Brewer, and U.S. Ser. No. 08/995,606, entitled \u201cMobile Information Services Platform\u201d to McMahon et al, all filed on Dec. 22,1997 and incorporated by reference herein.</p><h4>STATEMENT OF FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT</h4><p>Not Applicable</p><h4>BACKGROUND OF THE INVENTION</h4><p>1. Technical Field</p><p>This invention relates in general to electronic devices and, more particularly, to a method and apparatus for increasing the efficiency of a cache memory.</p><p>2. Description of the Related Art</p><p>Most modern day processing devices utilize a cache memory to increase processing speed. A cache memory acts as an intermediary between a processing circuit, such as a general purpose processor or a digital signal processor, and a memory bank, typically a dynamic random access memory (DRAM). The cache memory, typically a static random access memory (SRAM), is generally significantly smaller than the main memory bank (in terms of storage capacity), but significantly faster. The cache memory retains a portion of the data in the memory bank. When the processor accesses data, the cache memory is checked first to see if the data resides in the cache; if so, a \u201ccache hit\u201d ensues and data is taken from the cache memory which can supply the data at high speed responsive to the memory access request. On the other hand, if the data does not reside in the cache; if so, a \u201ccache miss\u201d ensues and data is taken from the memory bank. After a cache miss, the processor will generally be forced to wait for several clock cycles while the data is retrieved from the memory bank.</p><p>Cache architectures often have hit rates in the 90-95% rates, depending upon the application. The actual efficiency depends upon a number of factors, including the caching scheme employed, the size of the cache, and the application being run by the processor. Cache memories thus allow slower, less expensive, memory to store a large amount of data, while storing the portion of the data most likely to be accessed in the high speed cache memory.</p><p>While caches have significantly increased the speed at which data can be retrieved from the memory bank, cache architectures themselves can be slow relative to the capabilities of high speed processors. Further, a cache memory dissipates significant amounts of power, which is a particular concern to mobile electronic devices. Therefore, a need has arisen for a high speed, low power, cache architecture.</p><h4>BRIEF SUMMARY OF THE INVENTION</h4><p>In the present invention, a method and apparatus for executing a program in a processing circuit is shown, where the processing circuit includes a main memory and a cache memory and the cache memory comprises a plurality of data lines, each data line storing a plurality of data words. One or more programming loops are identified within the program. The loops are linked to the main memory such that a minimum number of cache lines are used to store the programming loops.</p><p>The present invention provides significant advantages over the prior art. First, significant amounts of energy can be saved by reducing tag searches and data array accesses by minimizing cache lines. Second, the speed can be significantly enhanced by reducing memory accesses. Third, cache misses can be reduced.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS</h4><p>For a more complete understanding of the present invention, and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:</p><p>FIG. 1 illustrates a perspective view of a smartphone;</p><p>FIG. 2 illustrates a block diagram of an mobile electronic device architecture which could be used in the smartphone of FIG. 1 or other mobile electronic devices;</p><p>FIG. 3 illustrates a block diagram of a cache architecture which could be used in the mobile electronic device architecture of FIG. <b>2</b> and in other processing devices; and</p><p>FIG. 4 illustrates a flow diagram describing the operation of the cache architecture of FIG. <b>3</b>.</p><p>FIG. 5 illustrates an example of a functional block diagram of the platform of FIG. 1;</p><p>FIG. 6 illustrates a functional block diagram of dynamic cross compiling and dynamic cross linking functions;</p><p>FIGS. 7<i>a-b </i>illustrate a example of optimization of a seven word loop for a cache architecture using four word cache lines;</p><p>FIGS. 8<i>a-b </i>illustrate a example of optimization of a four word loop for a cache architecture using four word cache lines; and</p><p>FIG. 9 illustrates a flow chart describing optimization of a cache line using a linking subsystem.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>The present invention is best understood in relation to FIGS. 1-9 of the drawings, like numerals being used for like elements of the various drawings.</p><p>FIG. 1 illustrate a Smartphone <b>2</b> which combines the ability for wireless transmission of voice and data along with processing capabilities similar to a personal digital assistant (PDA) or mobile computer. Smartphone <b>2</b> includes a display <b>4</b>, speaker <b>6</b>, keyboard <b>7</b> and microphone <b>8</b>.</p><p>FIG. 2 illustrates an exemplary embodiment of a general wireless data platform architecture, which could be used for example, in the implementation of Smartphone <b>2</b>, a PDA, or other mobile electronic device. The wireless data platform <b>10</b> includes a general purpose (Host) processor <b>12</b> coupled to bus structure <b>14</b>, including data bus <b>14</b><i>a</i>, address bus <b>14</b><i>b </i>and control bus <b>14</b><i>c</i>. One or more DSPs (or other coprocessors) <b>16</b>, including the core processor <b>16</b><i>a </i>and the peripheral interface <b>16</b><i>b</i>, are coupled to bus <b>14</b> and to memory and traffic controller <b>18</b>, which includes a DSP cache memory <b>18</b><i>a</i>, a CPU cache <b>18</b><i>b</i>, and a MMU (memory management unit) <b>18</b><i>c</i>. A hardware accelerator circuit <b>20</b> (for accelerating a portable language such as JAVA) and a video and LCD controller <b>22</b> are also coupled to the memory and traffic controller <b>18</b>. The output of the video and LCD controller is coupled to display <b>4</b>.</p><p>Memory &amp; traffic controller <b>18</b> is coupled to bus <b>14</b> and to the main memory <b>26</b>, shown as an SDRAM (synchronous dynamic random access memory). Bus <b>14</b> is also connected to I/O controller <b>28</b>, interface <b>30</b>, and RAM/ ROM <b>32</b>. A plurality of devices could be coupled to the wireless data platform <b>10</b>, such as smartcard <b>34</b>, keyboard <b>36</b>, mouse <b>38</b>, or one or more serial ports <b>40</b>, such as a USB (universal serial bus) port or an RS232 serial port. Interface <b>30</b> can couple to a flash memory card <b>42</b> and/or a DRAM card <b>44</b>. The peripheral interface <b>16</b><i>b </i>can couple the DSP <b>16</b> to a DAC (digital to analog converter) <b>46</b>, a network interface <b>48</b> or to other devices.</p><p>In the preferred embodiment, the wireless data platform <b>10</b> of FIG. 2 utilizes both a general purpose processor <b>12</b> and a DSP <b>16</b>. Unlike current devices in which the DSP <b>16</b> is dedicated to specific fixed functions, the DSP <b>16</b> of FIG. 2 can be used for any number of functions. This allows the user to derive the full benefit of the DSP <b>16</b>.</p><p>One main area in which the DSP <b>16</b> can be used is in connection with the man-machine interface (MMI). Importantly, functions like speech recognition, image and video compression and decompression, data encryption, text-to-speech conversion, and so on, can be performed much more efficiently using the DSP <b>16</b>. The present architecture allows new functions and enhancements to be easily added to wireless data platform <b>10</b>.</p><p>It should be noted that the wireless data platform <b>10</b> is a general block diagram and many modifications could be made. For example, FIG. 2 illustrates separate DSP and processor caches <b>18</b><i>a </i>and <b>18</b><i>b </i>As would be known to one skilled in the art, a unified cache could also be used in an alternative embodiment. Further, the hardware acceleration circuit <b>20</b> is an optional item. Such devices speed the execution of languages such as JAVA; however, the circuit is not necessary for operation of the device. Further, although the illustrated embodiment shows a single DSP, multiple DSPs (or other coprocessors) could be coupled to the buses.</p><p>FIG. 3 illustrates a cache architecture <b>50</b> which can greatly increase the efficiency and speed of a cache memory. While this cache architecture is specifically shown for the instruction cache, it should be noted that the cache architecture <b>50</b> could be used for a data cache or a unified data/instruction cache (with minor modifications) as well. Further, this cache architecture could be used in conjunction with any processing device which would benefit from a cache memory, including smartphones, PDAs, palmtop computers, notebook computers, desktop computers and so on.</p><p>In the cache architecture <b>50</b>, a cache controller <b>52</b> receives a memory address, in this case a 32-bit instruction address, IA[<b>31</b>:<b>2</b>], where \u201c[<b>31</b>:<b>2</b>]\u201d indicates that the cache controller is receiving bits \u201c<b>2</b>\u201d through \u201c<b>31</b>\u201d of the 32-bit address. The 32-bit address corresponds to an addressable memory space of 2<sup>32</sup>=4 Gigabytes or 1 Gigawords (where a word is set to four bytes). The cache controller <b>52</b> is coupled to a tag array <b>54</b> and a data array <b>56</b>. The illustrated cache architecture is arranged as a two-way set associative cache; therefore, both the tag array and the data array have two memory planes, <b>54</b><i>a-b </i>and <b>56</b><i>a-b</i>, respectively. In the illustrated embodiment, each plane <b>54</b><i>a-b </i>of the tag array is arranged as a 512\u00d720 memory array. The outputs of planes <b>54</b><i>a </i>and <b>54</b><i>b </i>are output to respective comparators <b>57</b><i>a </i>and <b>57</b><i>b</i>. IA[<b>31</b>:<b>13</b>] are also coupled to both comparators <b>57</b><i>a </i>and <b>57</b><i>b</i>. Each comparator <b>57</b><i>a </i>and <b>57</b><i>b </i>generates a one-bit output, combined to form a two-bit HIT signal. The tag array <b>54</b> is an asynchronous dual port memory where Q is the output data bus, AR is the address read bus, D is the input data bus and AW is the address write bus. The IA[<b>12</b>:<b>4</b>] signal is connected to AR.</p><p>Similarly, each plane <b>56</b><i>a-b </i>of the data array is arranged as 512\u00d7128. Each of the 128-bit lines is addressable as four words by bits IA[<b>12</b>:<b>4</b>]. Each word in a line is addressable individually by IA[<b>3</b>:<b>2</b>]. The output of each data array <b>56</b> is coupled to multiplexer <b>58</b>, along with the output of a main memory SD[<b>31</b>:<b>0</b>] (which provides the data in the instance HIT=\u201c00\u201d). The multiplexer <b>58</b> is shown as a 9:1 multiplexer which selects between four 32-bit words from the first plane of tag memory <b>56</b><i>a</i>, four 32-bit words from the second plane of tag memory <b>56</b><i>b </i>and one 32-bit word from the main memory. The output of multiplexer <b>58</b> is controlled by IA[<b>3</b>:<b>2</b>] (which indicates the selected word in the line), the 2-bit HIT signal (which indicates which plane <b>56</b><i>a </i>or <b>56</b><i>b </i>had the hit) from the comparators <b>57</b> an the fill-line signal (which indicates that the word comes from the main memory due to a miss). Following a miss, words are presented to the processor on the fly. Thus, if a miss accesses the first word of a line, the processor does not need to wait until the end of the line load.</p><p>In addition, a least recent unit (LRU) <b>60</b> and valid bit arrays <b>62</b><i>a-b </i>are coupled to the tag array <b>54</b>.</p><p>Cache controller <b>52</b> has an internal register <b>64</b>, which stores the address of the \u201cactive\u201d line, which is the line of data available in the output buffer of the data array <b>56</b> (IA_R[<b>32</b>:<b>2</b>]). The cache controller <b>52</b> outputs a disable signal if the requested address is equal to the address in register <b>64</b> (i.e., IA[<b>31</b>:<b>2</b>]=IA_R[<b>32</b>:<b>2</b>]). This aspect will be discussed in greater detail hereinbelow.</p><p>It should be noted that the particular structure of the cache <b>50</b> (i.e, two-way set associative), sizes of the tag and data arrays, and of the instruction address are for illustrative purposes only.</p><p>In a set associative cache, each memory location in the main memory (the \u201cmain memory\u201d is the memory whose data is cached by the cache architecture) corresponds to an address in the data array. Since the data array is generally much smaller than the main memory, each address in the data array is mapped to many addresses in the main memory. Data from a specific memory address can exist in any one of the sets of the associative cache.</p><p>The operation of a set associative cache is well known in the art and is summarized herein below for a read operation. When an address IA[<b>31</b>:<b>0</b>] is received for a memory access, IA[<b>12</b>:<b>4</b>] are used as an address into each plane <b>54</b><i>a </i>and <b>54</b><i>b </i>of the tag array <b>54</b>. Each plane of the tag array <b>54</b> outputs high order bits A[<b>31</b>:<b>13</b>] responsive to the address. A[<b>31</b>:<b>13</b>] identify which address in the main memory currently has its data stored in the respective plane <b>54</b><i>a-b</i>. A[<b>31</b>:<b>13</b>] from each plane <b>54</b><i>a </i>and <b>54</b><i>b </i>is compared in respective comparator <b>57</b><i>a </i>and <b>57</b><i>b </i>with the high order bits of the current address IA[<b>31</b>:<b>13</b>]. If the high order addresses match in one of the planes (a cache hit), then the data for that memory address can be retrieved from the corresponding data array; if there is no match (a cache miss), the data must be retrieved from the main memory. Each memory address in the tag memory has a corresponding valid bit. These bits indicate whether the data at the corresponding location in the cache is valid. The LRU <b>60</b> determines which set is updated after a cache miss.</p><p>The cache architecture <b>50</b> includes a disable feature which can significantly improve the efficiency of the operation of the cache. The incoming address IA[<b>31</b>:<b>4</b>] is compared with the corresponding bits of the address of the active line (i.e., the address of the data currently available in the embedded latches of the memory output buffer). If these addresses are equal, the steps of accessing the tag array <b>54</b> and data array <b>56</b> can be eliminated, since it is known that the requested data is currently ready for output through the multiplexer <b>58</b>. IA[<b>3</b>:<b>2</b>] provide the information to the multiplexer <b>58</b> to retrieve the desired word from the active line.</p><p>It should be noted that, in the illustrated embodiment, the output buffers of the tag arrays provide the storage device for maintaining the data of the active line; alternatively, an external memory could be provided, such as an input buffer on the multiplexer <b>58</b>, to store the active line.</p><p>A flow chart describing operation of the cache architecture <b>50</b> is shown in FIG. <b>4</b>. In block <b>70</b>, an address (IA) is received for a data read access. The relevant bits of IA (bits [<b>31</b>:<b>4</b>] in the illustrated example) are compared to the corresponding bits of the address of the active line in the output buffer of the memory in block <b>72</b>. If the bits do not match in decision block <b>74</b>, i.e., the requested data is not stored in the output buffer of the data array <b>56</b> of the cache memory, then the tag arrays <b>54</b><i>a-b </i>are accessed with the appropriate bits in block <b>76</b>. The outputs of the tag arrays <b>54</b> are compared with the high order bits of the IA address to determine if there is a cache hit in blocks <b>78</b> and <b>80</b>. If there no hit or if the valid bit indicates that the data is dirty, then the data is retrieved from main memory in block <b>82</b> and the data and tag arrays are updated to store the data from main memory in the cache. Multiplexer <b>55</b> selectively switches between the IA[<b>12</b>:<b>4</b>] signal and the IA_R[<b>12</b>:<b>4</b>] signal. After a cache miss, IA_R is used to keep the address stable for the duration of the line load from main memory, since IA can point to an address outside the range of the line before the line is completely loaded. IA_R[<b>31</b>:<b>13</b>] (coupled to D) and IA_R[<b>12</b>:<b>4</b>] (coupled to AW) are used to update the tag array after a miss.</p><p>If there is a hit in decision block <b>80</b>, then, in block <b>84</b>, the line of memory which includes the requested data is retrieved from data array <b>56</b>, responsive to the low order address bits IA[<b>12</b>:<b>4</b>]. This line is latched into the output buffer and the address of the active line is updated in the active line register <b>64</b> in block <b>86</b>. The word addressed by IA[<b>31</b>:<b>2</b>] is then passed through the multiplexer <b>58</b> responsive to the IA[<b>3</b>:<b>2</b>] bits and the HIT signal in block <b>88</b>.</p><p>On the other hand, if the IA address points to data which is part of the active line in block <b>74</b>, then the disable (DIS) signal is set in block <b>90</b>. This signal stops the tag array and data array access and causes the data to be taken from the active line currently stored in the output buffer of the memory array. Consequently, when DIS is enabled, steps <b>76</b>-<b>86</b> can be bypassed. Therefore, the energy used to access the tag array <b>54</b> and the data array <b>56</b> is conserved as these systems are disabled.</p><p>The disabling of the cache provides significant advantages. First, many operations can be eliminated when the requested data is available from the active line in the output buffer. For mobile electronic devices, this can lead to significant power savings by reducing memory accesses to the tag and data arrays <b>54</b> and <b>56</b>. Secondly, the data can be immediately taken from the output buffer of the data array for a faster response.</p><p>Since the data array stores multiple words in each line, there is a substantial likelihood that successive reads will be from the same line as instructions are sequentially accessed. Further, if an instruction loop can be contained in a single line in the data array, data from the same active line can be read for many cycles. Therefore, a significant amount of energy and time can be saved by the present invention.</p><p>While the processor is accessing data from the write buffer of the data array <b>56</b>, it can operate much faster than when the data needs to be accessed from the data array. For example, while the data array may be able to produce data at an 80 MHz rate, the processor may be able to read from the write buffer (without an access of the data array <b>56</b>) at a rate of 160 MHz. Assuming an overall cache hit rate of 95%, and a cache line of eight instructions per line, then the following is true:</p><p>95% of the instructions come from the cache:</p><p>95%*\u215e of the time, the processor can run at 160 MHz;</p><p>95%*\u215b of the time, the processor will have a one cycle wait;</p><p>5% of the time, the processor will wait for data from main memory.</p><p>The efficiency can be further improved by increasing the number of instructions per cache line. Assuming an architecture with sixteen instructions per cache line:</p><p>95% of the instructions come from the cache:</p><p>95%*{fraction (15/16)} of the time, the processor can run at 160 MHz;</p><p>95%*{fraction (1/16)} of the time, the processor will have a one cycle wait;</p><p>5% of the time, the processor will wait for data from main memory.</p><p>Accordingly, the cache architecture <b>50</b> allows the processor to work at speeds greater than those achievable by the cache itself.</p><p>FIG. 5 illustrates a functional software architecture for a wireless data platform <b>10</b> which can increase the efficiency of the cache architecture <b>50</b>. This software architecture is described in greater detail in conjunction with and U.S. Ser. No. 08/995,606, entitled \u201cMobile Information Services Platform\u201d to McMahon et al, filed Dec. 22, 1997, which is incorporated by reference herein. This block diagram presumes the use of JAVA; it should be noted that languages other than JAVA could be used as well. Functionally, the software is divided into two groups, Host processor software and DSP software. The Host software includes one or more applets <b>100</b>. The DSP API class <b>102</b> is a JAVA API package for JAVA applications or applets to access the functionality of the DSP API <b>110</b> and Host DSP Interface Layer <b>112</b>. A JAVA virtual machine (VM) <b>104</b> interprets the applets. The JAVA native interface <b>106</b> is the method which the JAVA VM executes host processor or platform specific code. Native tasks <b>108</b> are non-JAVA programs which can be executed by the Host processor <b>12</b> without using the JAVA native interface. The DSP API <b>110</b>, described in greater detail hereinbelow, is an API (application program interface) used the Host <b>12</b> to call to make use of the capabilities of the DSP <b>16</b>. The Host-DSP Interface Layer <b>112</b> provides an API for the Host <b>12</b> and DSP <b>16</b> to communicate with each other, with other tasks, or other hardware using channels via the Host-DSP Communication Protocol. The DSP device driver <b>114</b> is the Host based device driver for the Host RTOS <b>116</b> (real time operating system) to communicate with the DSP <b>16</b>. The Host RTOS <b>116</b> is an operating system, such as NUCLEUS PLUS by Accelerated Technology Incorporated. Alternatively a non-real time operating system, such as WINDOWS CE by Microsoft Corporation, could be used. The DSP Library <b>118</b> contains programs stored for execution on the DSP <b>16</b>.</p><p>On the DSP side, one or more tasks <b>120</b> can be stored in memory for execution by the DSP <b>16</b>. As described below, the tasks can be moved in and out of the memory as desired, such that the functionality of the DSP is dynamic, rather than static. The Host-DSP Interface layer <b>122</b> on the DSP side performs the same function as the Host-DSP Interface layer <b>112</b> on the Host side, namely it allows the Host <b>12</b> and DSP <b>16</b> to communicate. The DSP RTOS <b>124</b> is the operating system for the DSP processor. The Host Device driver <b>126</b> is a DSP based device driver for the DSP RTOS <b>124</b> to communicate with the Host <b>12</b>. The Host-DSP Interface <b>130</b> couples the DSP <b>16</b> and Host <b>12</b>.</p><p>In operation, the software architecture shown in FIG. 5 uses the DSP <b>16</b> as a variable function device, rather than a fixed function device as in the prior art. Accordingly, the DSP functions can be downloaded to the mobile device incorporating the architecture of FIG. 5 to allow the DSP <b>16</b> to perform various signal processing functions for the Host <b>12</b>.</p><p>The DSP Library <b>118</b> contains the blocks of code that can be downloaded to the DSP <b>16</b> for execution. Each block of code will be previously unlinked, or relocatably linked as a library, so that the dynamic cross linker can resolve all address references. Each code block will also include information about the block's requirements for DSP MIPS (millions of instructions per second), priority, time slice quantum, and memory. The format for the code block header is shown in Table 1. The program memory and data memory sizes are approximations to give the Host <b>12</b> a quick check on whether the DSP can support the task's memory requirements. If there appears to be sufficient space, the dynamic cross linker can then attempt to link and load the code. It should be noted that the dynamic cross linker could still fail, due to page alignment and contiguity requirements. In the preferred embodiment, the code is in a version <b>2</b> COFF file format.</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE 1</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Code Block Header.</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"119PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">Data Type</entry><entry morerows=\"0\" valign=\"top\">Field Name</entry><entry morerows=\"0\" valign=\"top\">Description</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">U16</entry><entry morerows=\"0\" valign=\"top\">Processor</entry><entry morerows=\"0\" valign=\"top\">The target processor type.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_DSP_Name</entry><entry morerows=\"0\" valign=\"top\">Name</entry><entry morerows=\"0\" valign=\"top\">Task's name.</entry></row><row><entry morerows=\"0\" valign=\"top\">U32</entry><entry morerows=\"0\" valign=\"top\">MIPS</entry><entry morerows=\"0\" valign=\"top\">Worst case MIPS required by the task.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_Size</entry><entry morerows=\"0\" valign=\"top\">ProgSize</entry><entry morerows=\"0\" valign=\"top\">Total program memory size needed.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_Size</entry><entry morerows=\"0\" valign=\"top\">DataSize</entry><entry morerows=\"0\" valign=\"top\">Total data memory size needed.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_Size</entry><entry morerows=\"0\" valign=\"top\">InFrameSize</entry><entry morerows=\"0\" valign=\"top\">Size of a frame in the task's input</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">channel.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_Size</entry><entry morerows=\"0\" valign=\"top\">OutFrameSize</entry><entry morerows=\"0\" valign=\"top\">Size of a frame in the task's output</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">channel.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_Size</entry><entry morerows=\"0\" valign=\"top\">InStrmSize</entry><entry morerows=\"0\" valign=\"top\">Size of the task's input stream FIFO.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_Size</entry><entry morerows=\"0\" valign=\"top\">OutStrmSize</entry><entry morerows=\"0\" valign=\"top\">Size of the task's output stream FIFO.</entry></row><row><entry morerows=\"0\" valign=\"top\">U16</entry><entry morerows=\"0\" valign=\"top\">Priority</entry><entry morerows=\"0\" valign=\"top\">Task's priority.</entry></row><row><entry morerows=\"0\" valign=\"top\">U32</entry><entry morerows=\"0\" valign=\"top\">Quantum</entry><entry morerows=\"0\" valign=\"top\">Task's time slice quantum (number of</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">system ticks).</entry></row><row><entry morerows=\"0\" valign=\"top\">T_Size</entry><entry morerows=\"0\" valign=\"top\">StackReq</entry><entry morerows=\"0\" valign=\"top\">Stack required.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_Size</entry><entry morerows=\"0\" valign=\"top\">CoffSize</entry><entry morerows=\"0\" valign=\"top\">Total size of the COFF file.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_DSP_Ptr</entry><entry morerows=\"0\" valign=\"top\">MsgHandler</entry><entry morerows=\"0\" valign=\"top\">Offset to a message handler entry point</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">for the task.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_DSP_Ptr</entry><entry morerows=\"0\" valign=\"top\">Create</entry><entry morerows=\"0\" valign=\"top\">Offset to a create entry point that is</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">called when the task is created.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_DSP_Ptr</entry><entry morerows=\"0\" valign=\"top\">Start</entry><entry morerows=\"0\" valign=\"top\">Offset to the start of the task's code.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_DSP_Ptr</entry><entry morerows=\"0\" valign=\"top\">Suspend</entry><entry morerows=\"0\" valign=\"top\">Offset to a suspend entry point that</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">is called prior to the task being</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">suspended.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_DSP_Ptr</entry><entry morerows=\"0\" valign=\"top\">Resume</entry><entry morerows=\"0\" valign=\"top\">Offset to a resume entry point that is</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">called prior to the task being resumed.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_DSP_Ptr</entry><entry morerows=\"0\" valign=\"top\">Stop</entry><entry morerows=\"0\" valign=\"top\">Offset to a stop entry point that is</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">called prior to the task being deleted.</entry></row><row><entry morerows=\"0\" valign=\"top\">T_Host_Ptr</entry><entry morerows=\"0\" valign=\"top\">CoffPtr</entry><entry morerows=\"0\" valign=\"top\">Pointer to the location of the COFF</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">data in the DSP Library.</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>A procedure for converting portable (processor independent) code, such as JAVA code, into linked target code is shown in FIG. <b>6</b>. The procedure uses two functions, a dynamic cross compiler <b>140</b> and a dynamic cross linker <b>142</b>. Each function is implemented on the host processor <b>12</b>. The dynamic cross linker is part of the DSP-API in the preferred embodiment. The cross compiler may also be part of the DSP-API.</p><p>The dynamic cross compiler <b>140</b> converts portable code into unlinked, executable target processor code. The dynamic cross linker <b>142</b> converts the unlinked, executable target processor code into linked, executable target processor code. To do so, it must resolve addresses within a block of code, prior to loading on the DSP <b>16</b>. The dynamic cross linker <b>142</b> links the code segments and data segments of the function, allocates the memory on the DSP <b>16</b>, and loads the code and constant data to the DSP <b>16</b>. The functions are referred to as \u201ccross\u201d compiling and \u201ccross\u201d linking, because the functions (compiling and linking) occur on a different processor (i.e., the host processor <b>12</b>) from the target processor which executes the code (i.e., the DSP <b>16</b>).</p><p>The dynamic cross compiler <b>140</b> accepts previously unlinked code loaded on demand by a user or a user agent (such as a browser). The code is processed to either (1) identify \u201ctagged\u201d sections of the code or (2) analyze untagged code segments for suitability of execution on the DSP <b>16</b>. A tagged section of source code could delineate source targetable to a DSP by predetermined markers such as \u201c&lt;start DSP code&gt;\u201d and &lt;end DSP code&gt;\u201d embedded in the source code. If a tagged section is identified either directly or through analysis, a decision is made to either cross compile or not based on the current processing state of the DSP <b>16</b>. If a decision is made to compile, the section of code processed by compiling software that outputs unlinked, executable target processor code, using well known compiling methods. A decision not to compile could be made if for example, the DSP has insufficient available processing capacity (generally stated as available MIPS-million of instructions per second) or insufficient available memory, due to other tasks being executed by the DSP <b>16</b>. The compiled code can be passed to the dynamic cross linker <b>142</b> for immediate use in the DSP <b>16</b>, or could be saved in the DSP library <b>118</b>.</p><p>The dynamic cross linker <b>142</b> accepts previously unlinked code, which is either (1) statically stored in connection with the host processor <b>12</b> or (2) dynamically downloaded to the host processor <b>12</b> over a network connection (including global networks such as the Internet) or (3) dynamically generated by the dynamic cross compiler <b>140</b>. The dynamic cross linker <b>142</b> links the input code for a memory starting address of the DSP <b>16</b> determined at runtime. The memory starting address can be determined from a memory map or memory table stored on and managed by either the host processor <b>12</b> or DSP <b>16</b>. The dynamic cross linker <b>142</b> convert referenced memory locations in the code to actual memory locations in the DSP. These memory locations could include, for example, branch addresses in the code or references to locations of data in the code.</p><p>In the preferred embodiment, the portable code is in a COFF (common object file format) which contains all information about the code, including whether it is linked or unlinked. If it is unlinked, symbol tables define the address which must be changed for linking the code.</p><p>The conversion process described above has several significant advantages over the prior art. First, the dynamic cross compiler <b>140</b> allows run-time decisions to be made about where to execute the downloaded portable code. For example, in a system with multiple target processors (such as two DSPs <b>16</b>), the dynamic cross compiler <b>140</b> could compile the portable code to any one of the target processors based on available resources or capabilities. The dynamic cross linker <b>142</b> provides for linking code to run on a target processor which does not support relocatable code. Since the code is linked at run-time, memory locations in the DSP <b>16</b> (or other target processor) do not need to be reserved, allowing optimum efficiency of use of all computing resources in the device. Because the compiling is accomplished with knowledge of the architecture of the platform <b>10</b>, the compiling can take advantage of processor and platform specific features, such as intelligent cache architectures in one or both processors.</p><p>Thus, the DSP <b>16</b> can have various functions which are changed dynamically to fully use its processing capabilities. For example, the user may wish to load a user interface including voice recognition. At that time, the host processor could download software and dynamically cross compile and cross link the voice recognition software for execution in the DSP <b>16</b>. Alternatively, previously compiled software in the DSP library <b>118</b> could be dynamically cross linked, based on the current status of the DSP <b>16</b>, for execution.</p><p>Additionally, the dynamic cross linker <b>142</b> can link code such that the efficiency of cache architecture <b>50</b> is maximized. FIG. 7<i>a </i>illustrates a problem which can reduce the efficiency of a cache. In FIG. 7<i>a</i>, a seven word program loop is stored in the cache. Once the loop is copied to the data array <b>54</b> from the main memory, the program loop begins at address n+2 of the data array <b>54</b> and ends at address n+8, thus occupying three cache lines. After executing instruction \u201c7\u201d (inst7), the program loops to instruction \u201c1\u201d (inst1). If this loop were executed one hundred times, there would be <b>700</b> cache memory accesses to the data array <b>56</b> for a cache without the disabling capabilities described above and <b>300</b> cache access to the data array <b>56</b> using the disabling circuitry described in connection with FIGS. 3-4.</p><p>As shown if FIG. 7<i>b</i>, the program code of the loop is linked such that the number of cache lines is minimized. In this case, rather than beginning the loop at address n+2, the loop is started at address n+4. While this wastes two memory locations, reduces the number of cache accesses of the data array <b>56</b> to <b>200</b> when the disabling circuitry is used.</p><p>Further, optimizing the location of a programming loop can reduce the number of cache misses. Each time there is a miss, a new block of instructions or data must be transferred from main memory to the cache. When the cache is full, the new block must replace an existing block into the cache. A system that uses less lines to hold the loop, for a given cache size, will therefore reduce the probability of a miss.</p><p>A more dramatic example is shown in FIGS. 8<i>a </i>and <b>8</b><i>b</i>, where a four word loop is shown. In the example of FIG. 8<i>a</i>, where the loop begins at address n+1 and ends at address n+4, two cache lines are used to contain the loop. If this loop were executed one hundred times, the data array would be accessed 400 times if the disabling circuitry were not used and 200 times if the disabling circuitry were used. By contrast, if the program loop was aligned as shown in FIG. 8<i>b</i>, with the loop beginning at address n and ending at position n+3, only one memory access to the data array would be necessary, with all other address requests being serviced by accessing data already stored in the output buffer of the data array <b>56</b> while the DIS signal is active.</p><p>This technique is particularly important in relation to digital signal processors, where loops are often only a few instructions long.</p><p>FIG. 9 illustrates a flow chart which describes an embodiment for linking code in order to optimize the efficiency of the cache architecture <b>56</b>. In block <b>150</b>, a loop is identified. There are a number of ways that the existence of a loop in the code could be determined. First, there a generally only a few looping constructs within a language. These could be readily identified in the compiled code. Second, if the COFF format (or similar format) is used, the information for identifying loops can be included as part of the compiled code.</p><p>In block <b>152</b>, the dynamic linker <b>142</b> determines whether the start of a program loop will need to move to the start of the next cache line for optimization (block <b>154</b>). A loop will need a number of lines equal to N/L (where N is the number of words in the loop and L is the number of words in a line of the data array <b>56</b>) plus an additional line if the remainder of N/L (i.e., N mod L) is not equal to zero. For optimization purposes, if N mod L=0 then the first word of the loop must begin at the first word of the cache line. Otherwise, if N mod L&gt;0, then the loop must begin at or before the L\u2212(N mod L) word position in the data array (where the word positions are ordered as 0,1,2,3 . . . L\u22121). Thus, for example, using a four word cache line as shown in FIG. 3, a six instruction loop would have to begin at least by word position \u201c<b>2</b>\u201d in the cache line, but could also be at position \u201c0\u201d or \u201d position \u201c1\u201d.</p><p>If the start of a program loop would otherwise map to a position in the cache which is not optimal, then the dynamic linker <b>142</b> will map the instruction to a memory location which is associated with the start of the next cache line in block <b>156</b>. On the other hand, if the program loop maps to a position which maintains a minimum number of lines for the loop, then the loop does not need to be moved, and the next program loop can be identified, until all loops have been found.</p><p>Optimizing a loop can result in a memory waste of up to L\u22121 word locations. Thus, it may be desirable to prioritize which loops are optimized. For example, a loop which is only repeated twice may not be worth optimizing if memory conservation is important. Prioritization information may be derived from the code information in the same way as the loops are identified. First, the code will, in many cases, identify the number of times a loop is repeated. Second, priority labels could be included in the COFF (or similar) format to identify which loops should be optimized. Whether to optimize low priority loops could be based, for example, on the available memory.</p><p>This aspect of the present invention provides significant advantages over the prior art. First, significant amounts of energy can be saved by reducing tag searches and data array accesses, as described above. Second, the speed can be significantly enhanced by reducing memory accesses. Third, cache misses can be reduced.</p><p>While the present invention has been described in connection with a cross-linker for optimizing code on a DSP or other coprocessor, it should be noted that the optimization could be used for any processor or coprocessor, wherever an efficient cache system is desired.</p><p>Although the Detailed Description of the invention has been directed to certain exemplary embodiments, various modifications of these embodiments, as well as alternative embodiments, will be suggested to those skilled in the art. The invention encompasses any modifications or alternative embodiments that fall within the scope of the Claims.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Gerard", "last_name": "Chauvel", "name": ""}, {"first_name": "Marion C.", "last_name": "Lineberry", "name": ""}, {"first_name": "Matthew A.", "last_name": "Woolsey", "name": ""}, {"first_name": "Michael", "last_name": "McMahon", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "TEXAS INSTRUMENTS INCORPORATED"}, {"first_name": "", "last_name": "TEXAS INSTRUMENTS INCORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G01F   9/45"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "717150"}, {"primary": false, "label": "703016"}, {"primary": false, "label": "711100"}, {"primary": false, "label": "717162"}, {"primary": false, "label": "711E12043"}, {"primary": false, "label": "703006"}, {"primary": false, "label": "717151"}], "ecla_classes": [{"label": "G06F  12/08B22L"}], "cpc_classes": [{"label": "G06F  12/0897"}, {"label": "G06F  12/0897"}, {"label": "Y02D  10/00"}, {"label": "Y02D  10/00"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1998-02-10", "application_date": "1998-02-10", "family_members": [{"ucid": "US-6282706-B1", "titles": [{"lang": "EN", "text": "Cache optimization for programming loops"}]}]}