{"patent_number": "US-6243732-B1", "publication_id": 72670652, "family_id": 17527831, "publication_date": "2001-06-05", "titles": [{"lang": "EN", "text": "Data processor and data processing system"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72565839\"><p>A data processor includes an arithmetic portion incorporated in a floating point unit, in which the arithmetic portion includes a plurality of multipliers supplied mantissa part of floating point number from respectively different data input signal line group and performing mutual multiplication of supplied mantissa parts, an aligner receiving outputs of respective multipliers and performing alignment shift, an exponent processing portion for generating number of alignment shift of the aligner and an exponent before normalization on the basis of generation an exponent part of the floating point number, a multi-input adder and the exponent before normalization, reducing scale of the circuit and performing inner product operation and the like with the floating point numbers in high speed and high accuracy.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6243732-B1-CLM-00001\" num=\"1\"><claim-text>1. A data processor comprising:</claim-text><claim-text>a central processing unit; and </claim-text><claim-text>a floating point unit, </claim-text><claim-text>wherein said central processing unit and said floating point unit execute instructions in an instruction set, and </claim-text><claim-text>wherein said instruction set includes a command for causing an inner product operation of a vector to be executed by said floating point unit. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6243732-B1-CLM-00002\" num=\"2\"><claim-text>2. A data processor according to claim <b>1</b>, wherein said floating point unit comprises:</claim-text><claim-text>a plurality of multipliers for multiplying a mantissa part of a floating point number; </claim-text><claim-text>an aligner for receiving an output of said multipliers and carrying out an alignment shift on said output; </claim-text><claim-text>an exponent processing portion for generating an exponent prior to a normalization in accordance with an exponent part of said floating point number; </claim-text><claim-text>a multi-input adder for adding an output of said aligner; and </claim-text><claim-text>a normalizing unit for normalizing an output of said multi-input adder and the exponent prior to the normalization. </claim-text></claim>"}, {"num": 3, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6243732-B1-CLM-00003\" num=\"3\"><claim-text>3. A data processing system comprising:</claim-text><claim-text>means for executing a three-dimensional graphic processing using said a data processor, </claim-text><claim-text>wherein said data processor comprises: </claim-text><claim-text>a central processing unit, and </claim-text><claim-text>a floating point unit, </claim-text><claim-text>wherein said central processing unit and said floating point unit execute instructions in an instruction set, and </claim-text><claim-text>wherein said instruction set includes a command for causing an inner product operation of a vector to be executed by said floating point unit. </claim-text></claim>"}, {"num": 4, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6243732-B1-CLM-00004\" num=\"4\"><claim-text>4. A data processor comprising:</claim-text><claim-text>a central processing unit; and </claim-text><claim-text>a floating point unit, </claim-text><claim-text>wherein said central processing unit and said floating point unit executes instructions in an instruction set, and </claim-text><claim-text>wherein said instruction set includes a command for causing an inner product operation of a four-component vector and another four-component vector to be executed by said floating point unit. </claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6243732-B1-CLM-00005\" num=\"5\"><claim-text>5. A data processor according to claim <b>4</b>, wherein said command includes a single instruction for executing the inner product operation.</claim-text></claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6243732-B1-CLM-00006\" num=\"6\"><claim-text>6. A data processor system comprising:</claim-text><claim-text>means for executing a three-dimensional graphic processing using a data processor, </claim-text><claim-text>wherein said data processor comprises: </claim-text><claim-text>a central processing, and </claim-text><claim-text>a floating point unit, </claim-text><claim-text>wherein said central processing unit and said floating point unit execute instructions in an instruction set, and </claim-text><claim-text>wherein said instruction set includes a command for causing an inner product operation of a four-component vector and another four-component vector to be executed by said floating point unit. </claim-text></claim>"}, {"num": 7, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6243732-B1-CLM-00007\" num=\"7\"><claim-text>7. A data processor comprising:</claim-text><claim-text>a central processing unit; and </claim-text><claim-text>a floating point unit, </claim-text><claim-text>wherein said central processing and said floating point unit execute instructions in an instruction set, and </claim-text><claim-text>wherein said instruction set includes a command having a single instruction for causing an inner product operation of a vector to be executed by said floating point unit. </claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6243732-B1-CLM-00008\" num=\"8\"><claim-text>8. a data processor according to claim <b>7</b>, wherein said floating point unit comprises:</claim-text><claim-text>a plurality of multipliers for multiplying a mantissa part of a floating point number; </claim-text><claim-text>an aligner for receiving an output of said multiplier, and carrying out an alignment shift; </claim-text><claim-text>an exponent processor portion for generating an exponent prior to a normalization in accordance with an exponent part of said floating point number; </claim-text><claim-text>a multi-input adder for adding an output of said aligner; and </claim-text><claim-text>a normalizing unit for normalizing an output of said multi-input adder and the exponent prior to the normalization. </claim-text></claim>"}, {"num": 9, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6243732-B1-CLM-00009\" num=\"9\"><claim-text>9. A data processing system comprising:</claim-text><claim-text>means for executing a three-dimensional graphic processing using a data processor, </claim-text><claim-text>wherein said data processor comprises: </claim-text><claim-text>a central processing unit, and </claim-text><claim-text>a floating point unit, </claim-text><claim-text>wherein said central processing unit and said floating point unit execute instructions in an instruction set, and </claim-text><claim-text>wherein said instruction set includes a command having a single instruction for causing an inner product operation of a vector to be executed by said floating point unit.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54555833\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This is a continuation of application Ser. No. 08/950,664, filed Oct. 15, 1997 U.S. Pat. No. 6,038,582.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates to a data processor specialized for inner product operation or matrix operation, and further to a data processing system optimal for three-dimensional graphics control, and relates to a technology effective as applied for a data processor for executing application frequently using floating point number vector or matrix less than or equal to length 4, for example.</p><p>In three-dimensional graphics and so forth, matrix operation employing 4\u00d74 transform matrix for rotation, expansion, contraction, perspective projection and parallel translation and so forth of a graphic pattern may be often utilized, and inner product operation may also be utilized for determining brightness of a light receiving surface, and so forth. Repeating of multiply-add operations is necessary for such matrix operation or inner product operation. Also, in concerning data to be handled in three-dimensional graphics, floating point number has been conventionally used in a high-end system. Even in the field having severe constraint of cost, such as a game machine, handheld PC and so forth, the handling data is shifting from integer to floating point number method. This is because that floating point number facilitates programming and is adapted to higher level process.</p><p>2. Description of the Related Art</p><p>A multiply-add unit is designed to perform operation of (A\u00d7B)+C as single function. For example, \u201cPA-8000 Combines Complexity and Speed\u201d, Microprocessor Report, Vol 8, No. 15, Nov. 14, 1994, pages 6 to 9, there has been disclosed a processor employing the multiply-add unit, in which parallelism of the multiply-add unit has been 2.</p><p>In \u201cNikkei Electronics\u201d (Nikkei PB K.K.) No. 653, Jan. 15, 1996, pages 16 to 17, there has been disclosed a semiconductor integrated circuit, in which three-dimensional drawing function is integrated on one chip. In the disclosed semiconductor integrated circuit, a multiply-add unit performing operation of eight fixed point number data in one cycle, has been incorporated thereinto. Also, there is a disclosure that transformation of coordinates utilizing 4\u00d74 matrix can be processed in two cycles.</p><p>On the other hand, JP-A-64-3734 discloses a multiplier circuit constituted of four multipliers and an adder summing the outputs of four multipliers with matching digits. Since the multiplier circuit is adapted to process multiplication of basic word length and double word length. Therefore, digit matching function is simply specialized for this process and thus, inner product operation of floating point number cannot be performed.</p><p>In JP-A-5-150944, a digital signal processor having a plurality of multiply-add units and means for connecting therebetween has been disclosed. The digital signal processor is adapted for integer.</p><p>Also, JP-A-5-216657 discloses a high speed processor for digital signal processing. There is a disclosure for geometry process employing a multiply-add unit for floating point number by the high speed processor.</p><p>On the other hand, JP-A-5-233228 discloses a floating point arithmetic unit and operation method thereof. There is a disclosure of means for reducing size of a floating point unit. However, since the disclosed system makes a multiplying array into half to use twice, the performance becomes half. Since components other than multiplying array are not reduced the sizes, an area-to-performance ratio of the floating point unit is lowered.</p><p>All of the above set forth have not considered speeding up of 4\u00d74 matrix operation or inner product operation, at all.</p><h4>SUMMARY OF THE INVENTION</h4><p>The inventor has studied for speeding up of matrix operation and inner product operation employing floating point number. According to this, it has been found that since a multiply-add unit of floating point number has large circuit scale, if they are simply arranged in parallel, increasing of the circuit scale becomes significant, and thus, as disclosed in the first publication, \u201cPA-8000 Combines Complexity and Speed\u201d, the possible parallelism is in the extent of two to limit speeding up. On the other hand, in the content of the disclosure of the second publication, \u201cNikkei Electronics\u201d, transformation of coordinates using a 4\u00d74 matrix can be processed in two cycles to achieve speeding up in certain extent. However, for using an integer multiply-add unit having small number of bits, it is inherent to sacrifice precision of operation.</p><p>An object of the present invention is to provide a data processor which can speed up matrix operation and inner product operation employing a floating point number.</p><p>Another object of the present invention is to provide a data processor which can perform matrix operation or inner product operation employing a floating point number at high precision and high speed.</p><p>Typical one of inventions disclosed in the present application will be briefly explained as follow.</p><p>Namely, a data processor comprises an arithmetic portion incorporated in a floating point unit, including a plurality of multipliers supplied mantissa part of floating point number from respectively different data input signal line group and performing mutual multiplication of supplied mantissa parts, an aligner receiving outputs of respective multipliers and performing alignment shift, an exponent processing portion for generating number of alignment shift of the aligner and an exponent before normalization on the basis of generation an exponent part of the floating point number, a multi-input adder for adding the outputs of the aligner, and a normalizer for normalizing the output of the multi-input adder and the exponent before normalization.</p><p>By making multiplication by a plurality of multipliers and addition of the results of multiplication parallel, the data processor can speed up the inner product operation or vector transforming operation. Also, the inner product can be obtained by one parallel multiplication and addition. Also, since the inner product can be derived by multiplication and addition at once to avoid necessity of process, such as rounding, to be executed at every multiply-add operation for two inputs to shorten latency of inner product operation. Furthermore, accuracy of arithmetic operation becomes high. Also, it will not happen to differentiate the results of arithmetic operations as that happen when rounding per every multiply-add operation is repeated. Furthermore since the data processor requires one circuit for normalization and the like, increasing of the circuit scale can be restricted as much as possible while inner product operation and vector transforming operation of floating point can be performed at high speed and with high accuracy.</p><p>In order to efficiently perform process for negative number in parallel multiplication and addition of floating point number, it is preferred that the arithmetic portion further includes a sign processing portion generating a sign with respect to a result of multiplication of each multiplier in response to the sign of floating point number multiplied by each multiplier, the aligner includes a selector selectively outputting the result of alignment shift in inverting or non-inverting manner for selecting an inverted output when the sign of the result of multiplication is negative, and the multi-input adder generates a carry for adding +1 to the output of aligner corresponded to negative sign with respect to the result of multiplication to perform complement process of two for the negative result of multiplication.</p><p>The objective data for arithmetic operation by the arithmetic portion and resultant data of arithmetic operation are temporarily stored in a register file. At this time, in order to enable such process without increasing number of ports of the register and number of bits of a register designation field, the register file is provided a register bank structure so that a plurality of register banks or the registers of single bank are connected to respective input terminals of the multipliers.</p><p>Paying attention for inner product operation, it is preferred to include an inner product operation command for directly deriving the inner product of less than or equal to length 4 in the instruction set of the data processor. The floating point unit further includes a control portion which can decode floating point command defining inner product operation of data expressed by a plurality of components, the control portion decodes the floating point command to provide component of data held in the register file to the arithmetic portion via the signal line group to make the arithmetic portion to calculate the inner product of the provided data to write in the result of inner product operation in the register file.</p><p>Paying attention for matrix transforming operation, it is preferred to incorporate a vector transforming operation command in the instruction set of the data processor. The floating point unit has a control portion which can decode a floating point command defining a matrix operation of data expressed by each of a plurality of components and a transformation matrix, the control portion decodes the floating point command, reads the data component held by the register file and component of the transformation matrix to provide to the arithmetic portion via the signal line group, makes the arithmetic portion to calculate inner product of the provided data, repeatedly executes a series of operation cycle for writing the result of inner product operation in the register file for a plurality of times. At this time, for correct operation even when a source register and a destination register are overlapped, and controls latency of respective arithmetic cycles so that the reading operation of the register file in the final arithmetic cycle to be sequentially executed for a plurality of times becomes earlier than writing timing of the register file of the result of inner product operation in the first arithmetic cycle. Also, at this time, by performing reading out from the register file in both banks, in parallel, and performing register selection control for performing writing in the register file to one of the banks, shorting of number of floating point register can be compensated. Namely, the register file is used by assigning a plurality of operands (transformation matrix, vector data) to a plurality of banks, separately.</p><p>Such a manner of use of the register file is effective for an architecture, in which the register designation filed is limited such as sixteen bit fixed length floating point command, and number of registers is limited, and enables inner product operation and vector transforming operation of floating point in the data processor of the architecture having such limited resource.</p><p>On the other hand, by adding a coefficient table and a feedback circuit of the multiplier in the arithmetic portion, an approximated value of trigonometric function can be obtained by zone division and high order polynomial expansion. By this, sine and cosine to be used in the transformation matrix or so forth can be obtained without significantly increasing the chip area.</p><p>The data processor includes a CPU connected to the address bus and a data bus, and the floating point unit performs floating point processing using sixteen-bit fixed length floating point command. The CPU performs addressing process for obtaining data necessary for execution of floating point processing in the floating point unit. By this, the floating point unit does not require a support high performance addressing mode as that of CPU. Even in this point, sixteen bit fixed length of the floating point command is enabled.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 is a block diagram of one embodiment of a data processor according to the present invention;</p><p>FIG. 2 is an explanatory illustration of a primary register construction of the data processor of FIG. 1;</p><p>FIG. 3 is a block diagram of one embodiment of FPU;</p><p>FIG. 4 is a block diagram of one embodiment of an arithmetic block;</p><p>FIG. 5 is a block diagram of one embodiment of a maximum digit number selecting portion;</p><p>FIG. 6 is a block diagram of one embodiment of a matching selecting portion;</p><p>FIG. 7 is a block diagram of one embodiment of an aligner;</p><p>FIG. 8 is a block diagram of one embodiment of a four-input adder;</p><p>FIG. 9 is an explanatory illustration showing a possibly obtainable values of Cin[<b>0</b>], Cin[<b>1</b>] and Cin[<b>2</b>] with respect to Inv[n] in the four-input adder;</p><p>FIG. 10 is a block diagram showing a detailed construction of a carry save adder array and a carry propagate adder array;</p><p>FIG. 11 is an explanatory illustration of one embodiment of a 4-2 compressor;</p><p>FIG. 12 is a block diagram of one embodiment of a register file;</p><p>FIG. 13 is an explanatory illustration of a construction of respective register groups forming the register file;</p><p>FIG. 14 is an illustration showing a construction of one embodiment of each register circuit in the register group;</p><p>FIG. 15 is an explanatory illustration showing mode of operation of a read port A of the register file;</p><p>FIG. 16 is an explanatory illustration showing mode of operation of a read port B of the register file;</p><p>FIG. 17 is an explanatory illustration showing mode of operation of a read port C of the register file;</p><p>FIG. 18 is an explanatory illustration showing application of an inner product;</p><p>FIG. 19 is a block diagram briefly showing a process according to an inner product operation command;</p><p>FIG. 20 is an explanatory illustration showing one example of a specification for use of a register file in the inner product operation command;</p><p>FIG. 21 is an explanatory illustration generally showing a vector transformation;</p><p>FIG. 22 is a block diagram briefly showing a process according to a vector transformation command;</p><p>FIG. 23 is an explanatory illustration showing one example of specification for use of the register file in a vector transformation operation command;</p><p>FIG. 24 is an explanatory illustration showing a pipeline of a plurality of times of inner product calculation process by one vector transformation command;</p><p>FIG. 25 is an explanatory illustration of specification of a sine-cosine command;</p><p>FIG. 26 is an explanatory illustration of a format of an angle data to be used in the sine-cosine command;</p><p>FIG. 27 is an explanatory illustration showing a relationship between a center value for polynomial approximate and an angle (radian);</p><p>FIG. 28 is a flowchart of an operation process according to the sine-cosine command according to polynomial approximation;</p><p>FIG. 29 is a block diagram in the vicinity of a multiplier added a coefficient table for executing sine-cosine command and a feedback system of the multiplier;</p><p>FIG. 30 is an explanatory illustration showing flow of data in the first step shown by (1) of FIG. 28, by a thick line;</p><p>FIG. 31 is an explanatory illustration showing flow of data in the second step shown by (2) of FIG. 28, by a thick line;</p><p>FIG. 32 is an explanatory illustration showing flow of data in the second step shown by (3) of FIG. 28, by a thick line;</p><p>FIG. 33 is an explanatory illustration showing flow of data in the second step shown by (4) of FIG. 28, by a thick line;</p><p>FIG. 34 is a block diagram briefly showing an operation block <b>22</b> for facilitating understanding of flow of data in operation process upon execution of the inner product operation command or the vector transformation command;</p><p>FIG. 35 is a comparative explanatory illustration showing an example, in which two sets of the multiply-add unit and a circuit for normalizing, obtaining positive number and rounding, are arranged in parallel;</p><p>FIG. 36 is a comparative explanatory illustration showing an example, in which four sets of the multiply-add unit and a circuit for normalizing, obtaining positive number and rounding, are arranged in parallel;</p><p>FIG. 37 is a comparative explanatory illustration showing an example, in which four multiply-add units are arranged in parallel for integer operation;</p><p>FIG. 38 is a block diagram showing one example of a data processing system, to which the data processor is applied; and</p><p>FIG. 39 is a block diagram showing one example of a three-dimensional graphics processing system, to which the data processor is applied.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DESCRIPTION OF THE PREFERRED EMBODIMENT</h4><p>Construction of Data Processor</p><p>FIG. 1 is a block diagram of one embodiment of a data processor according to the present invention. The data processor <b>1</b> shown in FIG. 1 has a 32 bit RISC (Reduced Instruction Set Computer) architecture and executes fixed length 16 bit floating point command. The shown embodiment is particularly effective in application for an equipment built-in control (e.g. video game) requiring sufficient support for three-dimensional graphics.</p><p>The data processor <b>1</b> has a floating point unit <b>2</b>. A floating point number for which the floating point unit performs operation, is a single precision. Also, the data processor <b>1</b> has a central processing unit (CPU) <b>3</b>. This CPU <b>3</b> is an integer unit having performance for processing an integer. CPU <b>3</b> is connected to the floating point unit <b>2</b> via a 32 bit data bus <b>4</b>. CPU <b>3</b> and the floating point unit <b>2</b> takes instruction from an instruction cache unit <b>6</b> via an instruction bus <b>5</b>. An instruction address is provided to the instruction cache unit <b>6</b> from CPU <b>3</b>. A data cache unit <b>7</b> is connected to the data bus <b>4</b> and is supplied a data address from CPU <b>3</b> via a data address bus <b>8</b>. The data cache unit <b>7</b> and the instruction cache unit <b>6</b> have cache controller and cache memory respectively neglected from illustration. The instruction cache control <b>6</b> and the data cache unit <b>7</b> are connected to a bus controller via a cache bus <b>13</b> including a data signal and a control signal. An instruction address for external access caused by cache-miss or so forth in the instruction cache unit <b>6</b>, is applied to a bus controller <b>9</b>. A data address for external access caused by cache-miss or so forth in the data cache unit <b>7</b>, is applied to the bus controller <b>9</b>. According to the instruction address or the data address, the bus controller <b>9</b> initiates an external bus cycle for accessing an external memory connected to an address pin, a data pin or so forth typically illustrated. On the other hand, to the bus controller <b>9</b>, a peripheral circuit <b>10</b>, such as a timer, serial communication interface controller and so forth, is connected via a peripheral bus <b>11</b>. The data processor shown in FIG. 1 is formed on one semiconductor substrate, such as monocrystalline silicon. The floating point unit (hereinafter simply referred to as FPU) requires data or instruction from a memory for floating point process. In the shown embodiment, the FPU <b>2</b> does not have a capability for storing data in a cache memory in the data cache unit <b>7</b> or obtaining data from the cache memory. This is for saving a chip area by avoiding necessity of memory addressing circuit of the FPU <b>2</b>. Accordingly, the FPU <b>2</b> or the floating point instruction is not necessary to support a powerful addressing mode similarly to CPU <b>3</b>, and all of such functions are loaded to CPU <b>3</b>. CPU <b>3</b> performs not only fetching of data from the memory for the FPU <b>2</b> but also fetching of all instructions including floating point instruction for the FPU <b>2</b> from the memory. Instruction is taken both in CPU <b>3</b> and the FPU <b>2</b> and decoded therein. CPU <b>3</b> executes the integer process designated by the instruction when the decoded instruction is instruction for CPU. On the other hand, when the decoded instruction is for FPU. CPU <b>3</b> performs addressing process to be executed in place of the FPU <b>2</b>. When the decoded instruction is an instruction for FPU, the FPU <b>2</b> executes the floating point process designated by the instruction. Also, when the decoded instruction is an instruction for CPU, the FPU <b>2</b> ignores the instruction.</p><p>FIG. 2 shows a major register construction of the data processor. A CPU register has sixteen general purpose registers r<b>0</b> to r<b>15</b> and Kernel bank registers k<b>0</b> to k<b>7</b> corresponding to the former. For example, Kernel bank register k<b>0</b> to k<b>7</b> are used by bank switching control in place of saving in the general purpose registers r<b>0</b> to r<b>7</b> upon occurrence of exception.</p><p>The FPU register has a bank register structure having a front-bank and a back-bank. The front-bank includes sixteen registers f<b>0</b> to f<b>15</b>. The back-bank includes corresponding sixteen registers b<b>0</b> to b<b>15</b>. Which bank of the registers are to be used is determined depending upon a value of a control bit of a control register, for example. In case of the FPU register, the registers in both banks are used as source registers and destination registers when a particular floating point instruction is to be executed. The registers f<b>0</b> to f<b>15</b> are taken as sixteen registers for the floating point number of a single precision format, as eight registers (d<b>0</b>, d<b>2</b>, d<b>4</b>, d<b>8</b>, d<b>10</b>, d<b>12</b>, and d<b>14</b> for the floating point number of double precision format, and as four vector registers (V<b>0</b>, V<b>4</b>, V<b>8</b> and V<b>12</b>) for a vector data having four components, each of which is provided in single precision format.</p><p>A communication register FPU common to the FPU <b>2</b> and CPU <b>3</b> is provided, The register FPU is provided for speeding up transfer of data between CPU <b>3</b> and the FPU <b>2</b>. It should be noted that each register has 32 bit construction.</p><p>Construction of FPU</p><p>In FIG. 3, a block diagram of the FPU <b>2</b> is illustrated. The FPU <b>2</b> is constructed with a transfer block <b>20</b>, a register file <b>21</b>, an arithmetic block <b>22</b> and a control portion <b>23</b>. The arithmetic block <b>22</b> has a construction of a multiply-add unit realizing speeding up of matrix operation or vector operation, discussed in detail. The register file <b>21</b> includes the FPU register discussed in connection with FIG. 2, and has eight read ports A[<b>0</b>], B[<b>0</b>], A[<b>1</b>], B[<b>1</b>], A[<b>2</b>], B[<b>2</b>], A[<b>3</b>] and B[<b>3</b>] for the arithmetic block <b>22</b> and a write port X receiving data from the arithmetic block <b>22</b>. The transfer block <b>20</b> includes a bus driver <b>200</b> supplying data output from each port C of the register file and a selector <b>201</b> selecting an input from the data bus <b>4</b> and an output from the register file <b>21</b> for supplying to a write port Y of the register file <b>21</b>. The control portion <b>23</b> decodes the instruction supplied from the instruction bus <b>5</b>, and controls the transfer block <b>20</b>, the register file <b>21</b> and the arithmetic block <b>22</b> according to result of decoding. Control signals BusDrv and LoadCntl of the bus driver <b>200</b> and the selector <b>201</b> are also generated by the control portion <b>23</b>.</p><p>In FIG. 4, one embodiment of the arithmetic block <b>22</b> is illustrated. The arithmetic block <b>22</b> has signal line groups La<b>0</b>, Lb<b>0</b>, La<b>1</b>, Lb<b>1</b>, La<b>2</b>, Lb<b>2</b>, La<b>3</b> and Lb<b>3</b> (these signal line groups will be also indicated as Lai and Lbi simply) individually connected respectively to the read ports A[<b>0</b>], B[<b>0</b>], A[<b>1</b>], B[<b>1</b>], A[<b>2</b>], B[<b>2</b>], A[<b>3</b>] and B[<b>3</b>] (these read ports are also indicated as A[n] and B[n], simply). To four multipliers <b>220</b><i>a </i>to <b>220</b><i>d</i>, mantissa part of the floating point number is supplied to multiplier factor and a multiplicand, through respective signal line groups Lai and Lbi. The multipliers <b>220</b><i>a </i>to <b>220</b><i>d </i>perform multiplication of the multiplier factor and the multiplicand supplied respectively for outputting products M[<b>0</b>], M[<b>1</b>]. M[<b>2</b>] and M[<b>3</b>] (hereinafter also indicated as M[n], simply). The products M[<b>0</b>], M[<b>1</b>]. M[<b>2</b>] and M[<b>3</b>] are supplied to corresponding aligners <b>221</b><i>a </i>to <b>221</b><i>d. </i></p><p>An exponent part of the floating point number supplied to respective signal line groups Lai and Lbi is supplied to respective adders <b>222</b><i>a </i>to <b>222</b><i>d</i>. A sign part of the floating point number supplied to respective signal line groups Lai and Lbi is supplied to respective exclusive OR gates EOR<b>1</b> to EOR<b>4</b>.</p><p>The adder <b>222</b><i>a </i>to <b>222</b><i>d</i>, a maximum exponent selecting portion and subtractors <b>224</b><i>a </i>to <b>224</b><i>d </i>form an exponent processing portion <b>228</b>. The adders <b>222</b><i>a </i>to <b>222</b><i>d </i>add exponent parts of the floating point numbers corresponded to multiplier factors and the multiplicands to outputs sums E[<b>0</b>], E[<b>1</b>], E[<b>2</b>] and E[<b>3</b>]. The maximum exponent selecting portion <b>223</b> selects maximum one Emax of the sums E[<b>0</b>], E[<b>1</b>], E[<b>2</b>] and E[<b>3</b>] of the exponents. The subtractors <b>224</b><i>a </i>to <b>224</b><i>d </i>subtracts E[<b>0</b>], E[<b>1</b>], E[<b>2</b>] and E[<b>3</b>] from Emax to obtain difference Ediff[<b>0</b>], Ediff[<b>1</b>], Ediff[<b>2</b>] and Ediff[<b>3</b>] (hereinafter also indicated as Ediff[n], simply). The difference Ediff[<b>0</b>], Ediff[<b>1</b>], Ediff[<b>2</b>] and Ediff[<b>3</b>] controls number of alignment shifting by the aligners <b>221</b><i>a </i>to <b>221</b><i>d </i>. Accordingly, outputs MaIn[<b>0</b>], MaIn[<b>1</b>], MaIn[<b>2</b>] and MaIn[<b>3</b>] (hereinafter also indicated as MaIn[n], simply) of respective aligners <b>221</b><i>a </i>to <b>221</b><i>d </i>has a digit position depending upon a maximum exponent Emax. Thus, the exponent part <b>228</b> determines number of alignment shifting of the aligners <b>221</b><i>a </i>to <b>221</b><i>d </i>by the difference Ediff[<b>0</b>], Ediff[<b>1</b>], Ediff[<b>2</b>] and Ediff[<b>3</b>], and, in conjunction therewith, generates the exponent Emax before normalization on the basis of the exponent part of the floating point number.</p><p>The exclusive OR gates EOR<b>1</b> to EOR<b>4</b>, the exclusive OR gates EOR<b>5</b> to EOR<b>8</b> and a matching selecting portion <b>225</b> form a code processing portion. The exclusive OR gates EOR<b>1</b> to EOR<b>4</b> input the sign part of the floating point number corresponded to the multiplier factor and the multiplicand to make judgment of sign of the product of the multiplier factor and the multiplicand. Among sings S[<b>0</b>], S[<b>1</b>], S[<b>2</b>] and S[<b>3</b>] to be judged, one corresponding to Emax is selected as Smax by the matching selecting portion <b>225</b>. Matching of the signs S[<b>0</b>], S[<b>1</b>], S[<b>2</b>] and S[<b>3</b>] with the representative sign Smax is judged by the exclusive OR gates EOR<b>5</b> to EOR<b>8</b>. The judgement results Inv[<b>0</b>], Inv[<b>1</b>], Inv[<b>2</b>] and Inv[<b>3</b>] (hereinafter also indicated as Inv[n], simply) are supplied to corresponding aligners <b>221</b><i>a </i>to <b>221</b><i>d</i>. When logical values of the judgement results Inv[<b>0</b>], Inv[<b>1</b>], Inv[<b>2</b>] and Inv[<b>3</b>] are \u201c1\u201d the aligners <b>221</b><i>a </i>to <b>221</b><i>d </i>inverts the corresponding products M[n] to generate outputs MaIn[n]. This is a preparatory process for transformation of the products M[n] into complements of two. Thus, the code processing portion <b>229</b> generates the sign Smax before normalization and the sign Inv[n] for a results of multiplication of respective multiplier with respect to the code Smax, depending upon sign of the floating point number multiplied by respective multipliers <b>220</b><i>a </i>to <b>220</b><i>d. </i></p><p>The four input adder <b>226</b> inputs outputs MaIn[n] of the aligners <b>221</b><i>a </i>to <b>221</b><i>d </i>in parallel for summing. Upon parallel addition process of four inputs, the sign Inv[n] is supplied. As discussed later in detail, the four input adder <b>226</b> performs process for adding +1 to the least significant bit of the output MaIn[n], for which preparatory process for obtaining complement of two is performed.</p><p>An output Macm of the four input adder <b>226</b> is supplied to a circuit <b>227</b> for normalization, obtaining positive number and rounding. This circuit performs normalization and obtaining positive number on the basis of exponent Emax before normalization, the output Macm of addition and the sign Smax for performing rounding adapting to single precision floating point number format to obtain the floating point number by performing rounding. The floating point number thus obtained is taken as a result of multiply-add operation of A[<b>0</b>]\u00b7B[<b>0</b>]+A[<b>1</b>]\u00b7B[<b>1</b>]+A[<b>2</b>]\u00b7B[<b>2</b>]+A[<b>3</b>]\u00b7B[<b>3</b>].</p><p>FIG. 5 shows one example of the maximum exponent selecting portion <b>223</b>. By comparison of E[<b>1</b>] and E[<b>0</b>] by a comparator <b>2230</b>, greater one is selected by a selector <b>2231</b>. Similarly, E[<b>3</b>] and E[<b>2</b>] are compared by a comparator <b>2232</b> so that greater one is selected by a selector <b>2233</b>. Those selected by both selectors are compared by a comparator <b>2234</b> so that greater one is selected by a selector <b>2235</b>. The output of the selector <b>2235</b> is taken as the exponent Emax before normalization.</p><p>FIG. 6 shows one example of the matching selecting portion. A selector <b>2250</b> selects S[<b>1</b>] or S[<b>0</b>]. A selector <b>2251</b> selects S[<b>3</b>] or S[<b>2</b>]. A selector selects an output of the selector <b>2250</b> and an output of the selector <b>2251</b>. Selection control signals of the selectors <b>2250</b> to <b>2252</b> are taken as a resultant signal MaxCntl of comparison of the comparators <b>2230</b>, <b>2232</b> and <b>2234</b>. By this, the sign part of the floating point number associated with the selected exponent as Emax is selected as sign Smax before normalization.</p><p>FIG. 7 shows one embodiment of the aligner <b>221</b><i>a </i>(<b>221</b><i>b </i>to <b>221</b><i>d</i>). A shifter <b>2210</b> inputs M[n] and is controlled the number of alignment shift (shifting bit number) by Ediff[n]. An output of the shifter <b>2210</b> is inverted by an inverter <b>2211</b>. The output of the inverter <b>2211</b> and the output of the shifter <b>2210</b> is selected by a selector <b>2212</b> by Inv[n], and the selected value is taken as MaIn[n].</p><p>FIG. 8 shows one embodiment of a four input adder <b>226</b>. The four input adder <b>226</b> has a circuit type, in which a sum (sum output) without carry and a carry (carry output) are derived separately by a carry save adder array <b>2260</b> and propagation of carry is delayed up to a timing where a final sum is obtained by a carry propagate adder <b>2261</b>. The sum Macm obtained by the four input adder <b>226</b> can potentially increased for two bits relative to number of bits of the input at the maximum. The product MaIn[n] to be input to the four input adder <b>226</b> is supplied to the carry save adder array <b>226</b> with preliminary two bit sign expansion.</p><p>In FIG. 8, a post process for deriving complement of two is performed with three bits of carry signals Cin[<b>0</b>], Cin[<b>1</b>:] and Cin[<b>2</b>]. As can be clear from the foregoing explanation, the sign selecting portion <b>225</b> selects any one of S[n]. Therefore, at least one among Inv[n] is always set at logical value \u201c0\u201d. Accordingly, objective for deriving complements of two should be three or less among MaIn[n]. This can be detected by an OR gate <b>2262</b>, an OR gate <b>2263</b>, and AND\u00b7OR gate <b>2264</b>. In FIG. 9, possible values of Cin[<b>0</b>], Cin[<b>1</b>] and Cin[<b>2</b>] with respect to the value of Inv[n]. As can be clear from this, Cin[<b>2</b>] is set at a logical value \u201c1\u201d when a logical value of at least one of Inv[<b>2</b>] and Inv[<b>3</b>] is \u201c1\u201dCin[<b>1</b>] is set at a logical value \u201c1\u201d when a logical value of at least one of Inv[<b>1</b>] and Inv[<b>0</b>] is \u201c1\u201d, and Cin[<b>0</b>] is set at a logical value \u201c1\u201d when a logical values of both of Inv[<b>1</b>] and Inv[<b>0</b>] or Inv[<b>2</b>] and Inv[<b>3</b>] is \u201c1\u201d.</p><p>In FIG. 10, one embodiment of detailed logical construction of the carry save adder <b>2260</b> and the carry propagate adder <b>2261</b> are illustrated. While there is not particular limitation, the carry save adder <b>2260</b> is constructed with a plurality of 4-2 compressors (4-2COMP) <b>2265</b>. Respective 4-2 compressor <b>2265</b> has five inputs (I<b>1</b> to I<b>4</b>, Ci) and three outputs (S, C, Co) as exemplary illustrated in (A) of FIG. <b>11</b>. The carry output Co is connected to a carry input Ci of the upper bit, the 4-2 compressor <b>2265</b> adds four bits I<b>1</b> to I<b>4</b>. S is a summing output, C is a carry output caused by addition. In the 4-2 compressor <b>2265</b>, Co does not depend on Ci. Nominally, carry transfer is not performed. For example, one 4-2 compressor <b>2265</b> may be constructed with two full adders, as exemplarily shown in (B) of FIG. <b>11</b>. The full adder is not specified but may be constructed with employing three multiplexers as exemplarily illustrated in (C). It should be noted that as a publication disclosing the 4-2 compressor, there is \u201chigh speed 54\u00d754 bit Multiplier Applied with Path Transistor Multiplexer\u201d, Technical Report of IEICE, ICD 94-135, DSP94-91 (October, 1994), Singaku Giho (the Institute of Electronics, Information and Communication Engineers), pp 73 to 79.</p><p>In FIG. 10, to respective of 4-2 compressors <b>2265</b>, bits at the corresponding digit positions in the aligner outputs MaIn[<b>0</b>] to MaIn[<b>3</b>] are supplied per four bits in sequential order from the lower digit. MaIn[<b>0</b>] to MaIn[<b>3</b>] represent the lowermost four bits in MaIn[<b>0</b>] to MaIn[<b>3</b>]. The carry signal Cin[<b>3</b>] is applied to a carry input terminal Ci of the lowermost 4-2 compressor <b>2265</b>. The carry propagate adder <b>2261</b> is constructed with a plurality of full adders <b>2261</b>. The carry output is taken as carry input for upper full adder. One of the adding input of the full adder is the sum output S of the 4-2 compressor <b>2265</b>, and the other adding input is the carry output C of the 4-2 compressor <b>2265</b> arranged at one upper digit. The carry signal Cin[<b>2</b>] is applied as one adding input signal of the lowermost full adder. The carry signal Cin[<b>1</b>] is applied as the carry input signal for the lowermost full adder.</p><p>FIG. 12 shows a block diagram showing one example of the register file. FIG. 13 shows a construction of each register group forming the register file, and FIG. 14 shows a construction of each register circuit of the register group.</p><p>The register file <b>21</b> is not particularly specified but have four register groups FR-Gr.[<b>0</b>] to FR-Gr.[<b>3</b>] as shown in FIG. <b>12</b> and four register circuits FR[m], FR[m+4], FR[m+8] and FR[m+12] shown in FIG. <b>13</b>. In FIG. 13, m is an integer of 0 to 3. As shown in FIG. 14, respective register circuit has a pair of registers FRJ[n] and FRK[n] for forming the front-bank and the back-bank. In FIG. 14, n is an integer of 0 to 15. Commanding for writing operation for the registers FRJ[n] and FRK[n] is given by a signal Write[n]. Any one of the registers as objective for writing is selected by a signal Bank. Correspondence of the registers FRJ[n] and FRK[n] and terminals P[n] and Q[n] can be mutually switched by selectors SL<b>1</b> and SL<b>2</b> by the signal Bank. In one register group shown in FIG. 13, terminals P[m], P[m+4], P[m+8] and P[m+12] of four register circuits can be connected to a terminal R[m] by selecting one of these by the selector SL<b>3</b> in response to two bit signal ReadA, and similarly, to a terminal B[m] by selecting one of these by the selector SL<b>4</b> in response to two bit signal ReadB. Terminals Q[m], Q[m+4], Q[m+8] and Q[m+12] of the register group are selected per register group by selectors SL<b>5</b> to SL<b>8</b> controlled by the signal ReadA. The outputs of the selectors SL<b>5</b>, SL<b>6</b>, SL<b>7</b> and SL<b>8</b> and outputs R[<b>3</b>], R[<b>2</b>], R[<b>1</b>] and R[<b>0</b>] of respective register groups are selected by selectors SL<b>9</b>, SL<b>10</b>, SL<b>11</b> and SL<b>12</b> controlled by a signal ReadType, and selected outputs are output to read ports A[<b>3</b>], A[<b>2</b>], A[<b>1</b>] and A[<b>0</b>]. Accordingly, from the read ports A[<b>3</b>], A[<b>2</b>], A[<b>1</b>] and A[<b>0</b>], data is read per one in parallel from four floating point registers per register group, as shown in FIG. <b>15</b>. Alternatively, data is read per one from each group in parallel. On the other hand, outputs B[<b>3</b>], B[<b>2</b>], B[<b>1</b>] and B[<b>0</b>] of respective register group are taken as outputs B[<b>3</b>], B[<b>2</b>], B[<b>1</b>] and B[<b>0</b>] as they are. As shown in FIG. 16, data is read from each register group per one in parallel. To the read port C, one of the outputs B[<b>3</b>], B[<b>2</b>], B[<b>1</b>] and B[<b>0</b>] of respective register groups selected by the selector SL<b>13</b> according to a signal ReadC is connected. Accordingly, as shown in FIG. 17, the register is arbitrarily selected depending upon the condition of the signals ReadB and ReadC for reading out from a port C. An input from the write ports X and Y can be selected by a selector SL as controlled by the signal WriteType.</p><p>Inner Product Operation</p><p>Discussion will be given with respect to inner product operation using the FPU <b>2</b>. For example, the inner product can be used for deriving a brightness of a surface when a light is irradiated on a specific surface in a three-dimensional space, as shown in FIG. <b>18</b>. The FPU <b>2</b> can derive an inner product i of a vector V<b>1</b> (=[X<b>1</b>, Y<b>1</b>, Z<b>1</b>, W<b>1</b>]) and V<b>2</b> (=[X<b>2</b>, Y<b>2</b>, Z<b>2</b>, W<b>2</b>]) by one inner product operation command ft pr Vn, Vm of floating point (also referred to as inner product operation command, simply).</p><p>Process of inner product operation command is briefly illustrated in FIG. <b>19</b>. For example, it is assumed that [X<b>1</b>, Y<b>1</b>, Z<b>1</b>, W<b>1</b>] is loaded in the vector register V<b>0</b> of the register file <b>21</b> and [X<b>2</b>, Y<b>2</b>, Z<b>2</b>, W<b>2</b>] is loaded in V<b>4</b>. When the inner product operation command is decoded by the control portion <b>23</b>, read operation of the register file is controlled to supply X<b>1</b> and X<b>2</b> to the multiplier <b>220</b><i>a</i>, Y<b>1</b> and Y<b>2</b> to the multiplier <b>220</b><i>b</i>, Z<b>1</b> and Z<b>2</b> to the multiplier <b>220</b><i>c </i>and W<b>1</b> and W<b>2</b> to the multiplier <b>220</b><i>d</i>, in parallel, respectively. While the exponent processing portion, sign processing portion and so forth are neglected from illustration, results of parallel multiplication are added by the four input adder <b>226</b> through inversion, shifting and so forth by the aligner, and then normalization and so forth is performed by resultant sum to obtain the inner product. Obtained inner product is overwritten through the port X holding the value of W<b>1</b> in the vector register V<b>0</b>. Thus, inner product operation of the floating point can be performed in parallel for speeding up inner product operation.</p><p>FIG. 20 shows one example of specification concerning use of the register file in the foregoing inner product operation command. Namely, a result of inner product operation of vectors V[m] and V[n] is stored in the floating point register FR[n+3]. Components of the vector [n] are loaded to the floating point registers FR[n], FR[n+1], FR[n+2] and FR[n+3]. Here, n is any one of 0, 4, 8 and 12. It should be appreciated that FR[n] corresponds to the register fn of the front-bank. In view of structure of the register file <b>21</b>, the register FR[n] is assigned to the register FRJ[n] when the control signal Bank=0, and to the register FRK[n] when the control signal Bank=1. In this specification, the vector data V[n] is stored in the registers FRJ[<b>0</b>], FRJ[<b>1</b>], FRJ[<b>2</b>] and FRJ[<b>3</b>] designated the output from the port A by Bank=0 and ReadA=0, and the vector data V[m] is stored in the registers FRJ[<b>4</b>], FRJ[<b>5</b>], FRJ[<b>6</b>] and FRJ[<b>7</b>] designated the output from the port B by Bank=0 and ReadB=1, for example, then, foregoing inner product operation can be performed by applying eight component data necessary for inner product operation of V[n] and V[m], in parallel. Upon operation, in practice, is designated by reading the register or by a register designation field of the inner product operation command. For designation by the register designation field, 4 bits is used for designation of a source register and a destination register.</p><p>Vector Transforming Operation</p><p>Next, discussion will be given in connection with a vector transforming operation employing FPU <b>2</b>. Known four row and four column of transformation matrix may express transformation of translation, rotation, expansion and perceptive and so forth. BY a product of the transformation matrix and the vector, vector transformation expressed by the transformation matrix can be obtained. The vector transforming operation is generally expressed as shown in FIG. 21. A is the transformation matrix, P is data to be an objective for transformation, and P\u2032 is data after transformation. Such vector transformation can be obtained by one floating point vector transforming operation command (also referred to as vector transforming operation command, simply) ftrv back, Vn.</p><p>Process according to the vector transforming operation command is briefly illustrated in FIG. <b>22</b>. For example, the transformation matrix is arranged in sixteen registers in the back-bank. Then, the vector data [Xi, Yi, Zi, Wi] is stored in the register forming the front-bank.</p><p>The process according to the vector transforming operation command is substantially equivalent to a process sequentially repeating inner product operation for four times. Namely, process of calculation of [Xi, Yi, Zi, Wi]\u00d7[a<b>11</b>, a<b>12</b>, a<b>13</b>, a<b>14</b>] to write the result in Xi region, calculation of [Xi, Yi, Zi, Wi]\u00d7[a<b>21</b>, a<b>22</b>, a<b>23</b>, a<b>24</b>] to write the result in Yi region, calculation of [Xi, Yi, Zi, Wi]\u00d7[a<b>31</b>, a<b>32</b>, a<b>33</b>, a<b>34</b>] to write the result in Zi region, and calculation of [Xi, Yi, Zi, Wi]\u00d7[a<b>41</b>, a<b>42</b>, a<b>43</b>, a<b>44</b>] to write the result in Wi region, are executed sequentially. Respective process is substantially the same as the inner product calculation process.</p><p>Once the vector transforming operation command is decoded by the control portion <b>23</b>, the data for performing the first inner product calculation process are supplied in parallel to the multipliers <b>220</b><i>a </i>to <b>220</b><i>d </i>or so forth from the register file <b>21</b>. Similarly, the exponent processing portion and the sign processing portion and so forth are neglected from illustration in FIG. <b>22</b>. Results of multiplication in parallel are added by the four input adder <b>226</b> via shifting, inversion and so forth by the aligner to perform normalization or so forth for the result of addition to obtain the inner product. The obtained inner product is written in the register holding Xi. Such processes are repeated with sequentially switching read objective register and write objective register of the register file. Thus, by sequentially repeating the inner product process of the floating point for four times, result of vector transformation can be obtained at high speed.</p><p>FIG. 23 shows one embodiment of specification concerning use of the register file in the vector transforming operation command. Namely, a product of vector V[n] and transformation matrix is overwritten in the register V[n]. The components of the vector V[n] are loaded to the floating point registers FR[n], FR[n+1], FR[n+2] and FR[n+3]. here, n is any one of 0, 4, 8 and 12. Also, it should be appreciated that FR[n] corresponds to the register fn of the front-bank. The transformation matrix is stored in the registers FB[<b>0</b>] to FB[<b>15</b>] (register corresponding to b<b>0</b> to b<b>15</b> of FIG. <b>2</b>). In view of construction of the register file <b>21</b>, the register FB[n] is assigned to the register FRK[n] when the control signal Bank=0, and to the register FRJ[n] when the control signal Bank=1.</p><p>In this specification, the transformation matrix</p><p>Matrix is output in parallel from the port A in the condition of ReadType=1, in FIG. 15, and the vector V[n] is output in parallel from the port B. For example, in the initial inner product operation, referred to FIG. 15, since ReadType=1, Bank=1 and ReadA=0, the first line of the transformation matrix Matrix is output from the port A based on FRJ[<b>0</b>], FRJ[<b>4</b>], FRJ[<b>8</b>] and FRJ[<b>12</b>]. In conjunction therewith, since Bank=1 and ReadB=0, on the basis of FRK[<b>0</b>], FRK[<b>1</b>], FRK[<b>2</b>] and FRK[<b>3</b>], the transformation objective vector [Xi, Yi, Zi, Wi] is output from the port B. In subsequent three times of inner product operation, at every occasion, selection of ReadA may be varied as 1, 2, 3. The read objective register from the B port is the same in four times of inner product operation.</p><p>A plurality of times of inner product calculation process according to one vector conversion command, is performed by a pipeline process as shown in FIG. <b>24</b>. Namely, four pipeline processes are executed by one command. One pipe of the inner product calculation process is consisted of a register read stage RR, a first arithmetic stage F<b>1</b>, a second arithmetic stage F<b>2</b>, a third arithmetic stage F<b>3</b>, a register write stage RW and not illustrated instruction fetch stage. The instruction fetch stage is naturally arranged before the register read stage RR. On the other hand, the register read stage RR includes an instruction decoding process. In the shown embodiment, arithmetic operation from multiplication to normalization is performed through three arithmetic stages. The process to be executed in the pipeline of (1) of FIG. 24, is to perform the inner product operation of (FB[<b>0</b>], FB[<b>4</b>], FB[<b>8</b>], FB[<b>12</b>])\u00d7V[n] for writing the result to the register FR[n]. The arithmetic operation to be executed in the pipeline of (2) is to perform the inner product operation of (FB[<b>1</b>], FB[<b>5</b>], FB[<b>9</b>], FB[<b>13</b>])\u00d7V[n] for writing the result to the register FR[n+1]. The arithmetic operation to be executed in the pipeline of (3) is to perform the inner product operation of (FB[<b>2</b>], FB[<b>6</b>], FB[<b>10</b>], FB[<b>14</b>])\u00d7V[n] for writing the result to the register FR[n+2]. The arithmetic operation to be executed in the pipeline of (3) is to perform the inner product operation of (FB[<b>3</b>], FB[<b>7</b>], FB[<b>11</b>], FB[<b>15</b>])\u00d7V[n] for writing the result to the register FR[n+3]. The destination registers FR[n], FR[n+1], FR[n+2] and FR[n+3] are also the source registers of V[n].</p><p>At this time, in a sequence of four times of inner product calculation process, the register write RW in the leading pipeline (1) is performed after register read RR in the final pipeline (4). In other words, a sequence of arithmetic cycle of the inner product operation by reading from the component of V[n] and the component of the transformation matrix, and writing the result of the inner product in the register file, is sequentially executed for a plurality of times. In the final arithmetic cycle to be executed a plurality of times sequentially, latency of respective arithmetic cycles is controlled so that the reading operation of the register file becomes faster than writing timing of the result of the inner product operation in the register file. Accordingly, even when the source register and the destination register are the same register, writing is not performed until reading of all data from the source register is completed to undesirably loss the data V[n].</p><p>Even if the source register and the destination register in the vector transforming operation are the same, operation is not interfered.</p><p>Since the vector data of before and after transformation are arranged in the same register, generation of program frequently using the vector transformation process is facilitated. On the other hand, in the vector transformation operation in the three-dimensional graphics or so forth, the vector transformation operation is performed for a plurality of vectors or points. At this time, if the data before and after transformation are arranged in the same register, and by loading four vector data in the sixteen floating point registers forming the front-bank, the vector transformation command is sequentially executed for four times, sequentially. Namely, number of times of loading of the arithmetic operation objective data for the sixteen floating point register or storing operation of the resultant data of arithmetic operation to the memory, can be reduced. In contrast to this, when data before and after transformation are stored in separate registers, since eight floating point register is occupied in execution of one vector transformation command, frequency of loading of the arithmetic operation objective data or storing operation of the resultant data of arithmetic operation becomes high. In this sense, capability of making the source register and the destination register of the vector data in the vector transformation operation common, is useful in speeding up of the vector transformation operation in the limited number of registers.</p><p>Sine Cosine Operation In the arithmetic block <b>22</b>, by adding the coefficient table or feedback circuit of the multiplier to the hardware for inner product operation, trigonometric functions or approximated value of a square root can be derived by zone division and development of high order polynomial expression. For example, the transformation matrix includes sine and cosine upon rotational transformation. When a data table of sine and cosine is established with respect to all of necessary angles, increasing of chip area cannot be ignored.</p><p>Here, discussion will be given for deriving of approximated value of sine and cosine utilizing the arithmetic block <b>22</b>. The FPU added toe construction discussed later, executes sine cosine command for calculating sine and cosine in parallel by one command. The specification of the sine cosine command is to calculate a value of sine with respect to the angle data loaded to the floating point register FR[<b>0</b>] to write the result in the register FR[n], and similarly, to calculate cosine with respect to the angle data loaded in the register FR[<b>0</b>] to write the result in the register FR[n+1], as shown in FIG. <b>25</b>.</p><p>FIG. 26 shows a format of the angle data. The angle data expressed rotation speed by a32-bit fixed point number taking a boundary between upper 16 bits and lower 16 bits of one floating point register as the fixed decimal point position. Across the decimal point position, the upper sixteen bits represents the rotation speed (integer), and the lower sixteen bits across the decimal point defines one turn with division into the sixteenth power of two. Particularly, among lower sixteen bits, upper two bits represents a quadrant, in which an angle specified by the data of sixteen bits below decimal point. In such angle format, for example 360\u00b0 is represented by 1.0 and the bit pattern of the sexadecimal number is \u201c00010000\u201d.</p><p>The sine cosine command obtains sine and cosine with respect to the angle data of the foregoing angle format by polynomial approximation according to Tayler expansion. FIG. 28 shows a method of arithmetic operation therefor.</p><p>The foregoing polynomial approximation is for calculating values of sine and cosine corresponding to the angle data by dividing sixteen bits below decimal point of the angle data into a center value x and a difference value dx with respect to the center value. Only values of sine and cosine with respect to the center value x required for polynomial approximation are held in a form of a table. The center value x is assumed as a value derived by counting a fraction over one as one and disregarding the rest of the least significant bit of seven bits below decimal point of the register FR[<b>0</b>]. A relationship between the center value and the angle (radian) is exemplarily illustration in FIG. <b>27</b>. The difference dx is a value derived by sign expansion of ten bits from the least significant bit of the register FR[<b>0</b>]. Since Tayler expansion is employed in the polynomial approximation, coefficients of respective terms are provided for expressing the angle by radian. In FIG. 28, S<b>1</b> to S<b>12</b> show contents of arithmetic process employing the multiplier <b>220</b><i>a </i>(FMO), the multiplier <b>220</b><i>b </i>(FM<b>1</b>), the multiplier <b>220</b><i>c </i>(FM<b>2</b>), the multiplier <b>220</b><i>d </i>(FM<b>3</b>) and the four input adder <b>226</b> by expressions. In S<b>9</b>, an approximated value of sign is derived by the polynomial approximate expression (polynomial approximate expression is shown in FIG. <b>28</b>). In S<b>12</b>, an approximated value of cosine is derived by the polynomial approximate expression (the polynomial approximate expression is shown in FIG. <b>28</b>).</p><p>Arithmetic operation in S<b>1</b> to S<b>12</b> will be processed in pipeline shown in (1) to (4). As set forth above, the upper two bits among lower sixteen bits of the angle data represents a quadrant, in which the angle specified by the data of sixteen bits below decimal point. Accordingly, the control portion controls sign reversal of the results of arithmetic operation in S<b>10</b> and S<b>12</b> by polynomial approximation and selection of the register FR[n] or FR[n+1] to store the result of arithmetic operation, depending upon result of decoding of upper two bits (according to quadrant, in which the angle specified by the angle data) so that the values of sine and cosine are stored in the register FR[n] or FR[n+1] assigned depending upon the quadrant. Reversing operation and register selecting operation per quadrant is illustrated in FIG. <b>28</b>.</p><p>FIG. 29 shows a block diagram in the vicinity of the multiplier added a coefficient table and a feedback system for the multiplier for executing the sine cosine command. Base of the circuit of FIG. 29 is the arithmetic block of FIG. <b>4</b>. With respect to the arithmetic block <b>22</b> of FIG. 4, the circuit is merely differentiated in addition of eight bit and six bit sign expander <b>300</b>, a coefficient table <b>301</b> and selectors <b>302</b> to <b>312</b>. The angle data of the register FR[<b>0</b>] is applied from the port B[<b>0</b>].</p><p>The eight bit and six bit sign expander <b>300</b> is a circuit for generating the difference dx from least 20 bits of the register FR[<b>0</b>]. The coefficient table <b>301</b> holes either one of data of sine or cosine depending upon the center value shown in FIG. 27 to output data of sine and cosine of the angle designated by lower five bit in the lower sixteen bits of the angle data. The upper two bits of the lower sixteen bits of the angle data is supplied to the control portion. The control portion thus controls selective reversal of the adding output by the four input adder and selection of the register FR[n] or FR[n+1] to store the adding result, according to the value of the two bits. It should be noted that when the coefficient table has sine data, the cosine may be derived with making reference to the table with an angle subtracting the angle of the center value x from \u03c0/2. It is also possible to have both of data of sine and cosine in the coefficient table.</p><p>FIG. 30 shows flow of data in the first step shown in (1) of FIG. 28, by the thick line. FIG. 31 shows flow of data in the second step shown in (2) of FIG. 28, by the thick line. In these figures, while the result of multiplication of the multiplier (FMO) <b>220</b><i>a </i>is fed back to the selectors <b>308</b> and <b>311</b>, only bits below the decimal point is fed back (setting upper bit to zero) to obtain the effect of +1. FIG. 32 shows flow of data in the second step shown in (3) of FIG. 28, by the thick line. FIG. 33 shows flow of data in the second step shown in (4) of FIG. 28, by the thick line. When the result of arithmetic operation is used twice in FIGS. 32 and 33, updating of input latch of the multiplier is restricted to hole the value. Control of the arithmetic operation shown in FIGS. 30 to <b>32</b> is performed by the control portion which decodes the sine cosine command.</p><p>Superiority of Data Processor <b>1</b></p><p>As set forth above, the arithmetic block <b>22</b> of the FPU <b>2</b> applies eight floating point numbers to four multipliers <b>220</b><i>a </i>to <b>220</b><i>d </i>for parallel operation upon execution of one command, such as inner product operation command, vector transformation operation command, and adds the results of multiplication there of by one four input adder <b>226</b> to obtain the result of arithmetic operation. Normalization, obtaining positive number and rounding for the output of the four input adder <b>226</b> is performed by one circuit <b>227</b>. In FIG. 34, general construction of the arithmetic block <b>22</b> is illustrated for facilitating understanding of flow of data in the arithmetic process.</p><p>In FIG. 35, a comparative example to the foregoing arithmetic block <b>22</b> is illustrated. This is constructed by providing two sets of the multiply-add units for a pair of floating point number and the circuits for normalization, obtaining positive number and rounding. In FIG. 36, another comparative example for the foregoing arithmetic block <b>22</b>, in which four sets of the multiply-add units for a pair of floating point number and the circuits for normalization, obtaining positive number and rounding are provided, is illustrated. Either comparative examples are constructed by simply arranging a plurality of sets of the multiply-add units and the circuits for normalization, obtaining positive number and rounding. Accordingly, when one inner product of 4\u00d74 is to be calculated, it is not sufficient to simply operate the circuits for multiply-add operation, normalization, obtaining positive number and rounding in parallel. Control in consideration of correlation with respect to respective result of arithmetic operation is required separately. Normally, the inner product may be derived by repeated operation for four times by multiply-add unit and the circuit for normalization, obtaining positive number and rounding. In case of vector transforming operation, further greater number of arithmetic cycles become necessary. A plurality of sets of circuits for multiply-add operation, for normalization, obtaining positive number and rounding are operated in parallel for inner product operation for different objects or other floating point number command, by instruction executing method, such as pipeline. In this sense, the circuit construction shown in FIGS. 35 and 36 is characterized in the point for improving performance of arithmetic process of various floating point number command in average.</p><p>When the arithmetic block is employed, number of substantial arithmetic cycles for the inner product operation or vector transformation operation can be reduced. Namely, speeding up of the inner product operation or the vector transformation operation can be realized. Thus, construction of the arithmetic block <b>22</b> is specialized for speeding up of the inner product operation and the vector transformation operation. On the other hand, since the inner product can be obtained by one parallel multiplication and addition, process for performing rounding per every multiply-add operation for two inputs, becomes unnecessary. By this, latency of the inner product operation can be shortened and accuracy of arithmetic operation becomes high. Also, it may not happen to cause a difference in result of arithmetic operation in different order of arithmetic operation as in the case where rounding is repeated at every multiply-add operation for two inputs.</p><p>On the other hand, the circuit for normalization, obtaining positive number and rounding may have equivalent circuit scale as that of the multiply-add unit. Therefore, in the construction where a plurality of sets of the circuits for multiply-add operation, normalization, obtaining positive number and rounding are simply arranged in parallel as shown in FIGS. 35 and 36, increasing of chip area for parallel processing in relation to improvement of performance of arithmetic operation in average to be achieved by parallel processing, becomes significantly large. In view of this, it has been considered that two is reasonable as number of the circuits for multiply-add operation, normalization, obtaining positive number and rounding to be arranged in parallel. It should be realistic to arrange for multiply-add units in parallel as shown in FIG. 37, in case of only for the arithmetic operation of integer. However, in case of arithmetic operation of integer, since number of digits of data is limited, accuracy of arithmetic operation becomes lower than that of the floating point operation. The arithmetic block <b>22</b> of FIG. 34 is required to have one circuit <b>227</b> for normalization, obtaining positive number and rounding. Accordingly, increasing of the circuit scale can be minimized with realizing speeding up of the inner product operation and the vector transformation operation of floating point.</p><p>The floating point number command of the data processor <b>1</b> has a fixed length of sixteen bits. Therefore, an address designation field in the floating point number command is limited, and number of the floating point registers is sixteen. Under such constraint, the floating point register is constructed with a register file <b>21</b> of the register bank structure having the back-bank and the front-bank. At this time, since sixteen registers are occupied for storing the whole transformation matrix, the specification of instruction for using both of the front-bank and the back-bank is employed for the vector transforming operation command. As set forth above, the transformation matrix is arranged in the back-bank and the vector data is arranged in the front-bank. By this, under constraint of resource of bit number of the floating point command and number of registers, high speed execution of the vector transforming operation command can be assured.</p><p>On the other hand, in execution of the vector transforming operation command, a series of four times of inner product calculation process is pipelined so that the register write RW in the leading pipeline (1) is executed after the register read RW in the last pipeline (4). Accordingly, even when the source register and the destination register are the common register, the vector data as the object for arithmetic operation will never lost unwantedly. Thus, when vector transformation for a plurality of vectors or points is performed sequentially, if the data before and after transformation are arranged in the same register, the vector transformation command can be sequentially executed for four times by loading four vector data to the sixteen floating point registers forming the front-bank. Thus, occurrence of such loading of the objective data for arithmetic operation for the sixteen floating point register and storing operation of the resultant data of the arithmetic operation, can be reduced. In this sense, capability of making the source register and the destination register of the vector data in the vector transforming operation in common, is useful in speeding up of vector transforming operation under limited number of registers.</p><p>On the other hand, the transformation matrix may includes sine and cosine in rotational transformation. To have the data table <b>301</b> of sine and cosine for all necessary angles, increasing of chip area for this cannot be ignored. Since the arithmetic block <b>22</b> includes four multipliers, the approximated values of trigonometric function and square root can be derived by zone division and high order polynomial expansion by adding the coefficient table <b>301</b> and the feedback circuit of the multiplier. By this, sine and cosine can be derived without increasing chip area. Particularly, since there is a similarity in expansion expression of polynomial approximation of sine and cosine, values of sine and cosine are simultaneously (in parallel) calculated utilizing this so that the values of sine and cosine can be obtained at high speed in comparison with the case where they are derived individually.</p><p>FIG. 38 shows a block diagram of a data processing system applied such data processor.</p><p>In FIG. 38, <b>1</b> denotes the data processor, <b>401</b> denotes a dynamic random-access-memory (DRAM), <b>402</b> denotes a DRAM control portion performing address multiplexing control or refresh control for DRAM <b>401</b>, and <b>403</b> denotes an SRAM. SRAM <b>403</b> is used as work area of the data processor <b>1</b> or a temporary storage region of data. The reference numeral <b>404</b> denotes ROM holding OS (Operating System) or the like of the data processor <b>1</b>. The reference numeral <b>405</b> denotes a peripheral device control portion, to which an external storage device <b>406</b> and a keyboard <b>407</b> are connected typically. The reference numeral <b>408</b> denotes a display controller having a frame buffer <b>409</b> or a not shown drawing and display control logic circuit, to perform drawing control and display control for a display <b>410</b>. The reference numeral <b>411</b> denotes a power source circuit, and <b>412</b> denotes a bus as illustrated as representation. The data processor <b>1</b> can execute inner product operation, vector transforming operation and so forth of floating point, frequently used in three-dimensional graphics process, at high speed. Furthermore, since the foregoing effect can be obtained under the resource where the number of bits of the floating point instruction and number of registers are limited, a cost of the data processor <b>1</b> can be low. Accordingly, the data processing system of FIG. 38 can lower the cost of the system and perform three-dimensional graphic process at high accuracy and high speed. Accordingly, the data processing system superior in a game machine, handheld PC or so forth which has severe constraint in the cost and not ignoble demand for higher performance and higher speed.</p><p>FIG. 39 is a three-dimensional graphics processing system, in which a rendering co-processor <b>413</b> is added to the data processing system of FIG. <b>38</b>. The three-dimensional graphic process is consisted of a geometry processing and rendering processing. Since the data processor <b>1</b> can process the inner product operation, the vector transforming operation or the like, which is frequently used particularly in geometry process, at high speed, high accuracy and high speed three-dimensional graphics process can be performed by adding the rendering co-processor <b>413</b> to the data processing system shown in FIG. <b>38</b>. Needless to say, it is possible to construct the three-dimensional processing system even by making CPU in the data processor <b>1</b> to perform the rendering process instead of providing the rendering processor <b>413</b>, in the three-dimensional graphics process of FIG. <b>39</b>.</p><p>While the embodiments of the present invention made by the inventor has been specifically discussed hereinabove, the present invention should not be limited to the specific embodiments. Of course, various modifications are possible as long as not departing from the principle of the invention.</p><p>For example, while it is not discussed in FIG. 1, the data processor may include other functional block, such as memory management or so forth. Also, the data processor may employ a super scalar architecture. For example, in case where two pipes are provided, the vector transforming operation command is executed by one pipe, and loading of the vector data necessary for the vector transforming operation command from the memory to the register file or storing of the result of the vector transforming operation from the register file to the memory can be done by the other pipe.</p><p>Also, number of parallel arranged multiplier can be more than or equal to four. Furthermore, the construction of the exponent processing portion and the sign processing portion and the construction of the four input adder are not limited to the foregoing construction and can be modified arbitrarily.</p><p>Also, application of the data processor of the present invention is not limited to control of the game machine, the handheld PC or so forth, and the data processor can be widely applied for built-in control of various equipment's.</p><p>The effect to be attained by the typical one of the inventions disclosed in the present invention will be discussed as follow.</p><p>Namely, the data processor can realize speeding up of the inner product operation, the vector transforming operation in floating point.</p><p>Since the data processor is required to provide one circuit for normalization or so forth, it becomes possible to realize speeding up of inner product operation or vector transforming operation of floating point with restricting increasing of the circuit scale as least as possible.</p><p>In the vector transforming operation command, command specification to use both of the front-bank and the back-bank is employed to assure high speed execution of the vector transforming operation command even under constraint of resource of number of bits and number of register in the floating point command.</p><p>On the other hand, in execution of the vector transforming operation command, a series of four times of inner product calculation process controls latency of each inner product process so that the register write in the leading inner product calculation process is executed after register read in the last inner product calculation process. Therefore, even when the source register and the destination register is common register, the vector data to be the object for arithmetic operation may not be lost unwantedly. By this, number of occurrence of loading of the objective data for arithmetic operation for the floating point register and storing operation of the resultant data of arithmetic operation can be reduced to be useful for speeding up of the vector transforming operation under limited number of registers.</p><p>On the other hand, by adding the coefficient table or the feedback circuit of the multiplier to the arithmetic portion, the approximated value of trigonometric function is derived by zone division and high-order polynomial expansion. Thus, sine and cosine to be used for transformation matrix or so forth can be obtained without significantly increasing the chip area.</p><p>The data processor can execute inner product operation, the vector transforming operation or so forth of floating point which is frequently used for three-dimensional graphics process, can be executed at high speed under the resource of limited number of bits of floating point command and number of registers. The data processing system applied the data processor, can restrict the cost of the system with executing three-dimensional graphics process at high accuracy and high speed. Accordingly, the data processing system superior in a game machine, handheld PC or so forth which has severe constraint in the cost and not ignoble demand for higher performance and higher speed.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Fumio", "last_name": "Arakawa", "name": ""}, {"first_name": "Norio", "last_name": "Nakagawa", "name": ""}, {"first_name": "Tetsuya", "last_name": "Yamada", "name": ""}, {"first_name": "Yonetaro", "last_name": "Totsuka", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "HITACHI, LTD."}, {"first_name": "", "last_name": "RENESAS ELECTRONICS CORPORATION", "name": ""}, {"first_name": "", "last_name": "RENESAS ELECTRONICS CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   7/32"}, {"primary": false, "label": "G06F   7/42"}, {"primary": false, "label": "G06F   7/38"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   7/53        20060101ALI20060310RMJP"}, {"label": "G06F   7/487       20060101ALI20060310RMJP"}, {"label": "G06F   7/38        20060101ALI20060310RMJP"}, {"label": "G06T   1/20        20060101ALI20060310RMJP"}, {"label": "G06F  17/10        20060101ALI20060310RMJP"}, {"label": "G06F   9/302       20060101A I20051008RMEP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}, {"label": "G06F   7/544       20060101A I20051008RMEP"}, {"label": "G06F   7/548       20060101A I20051008RMEP"}, {"label": "G06F   7/509       20060101A I20070721RMEP"}, {"label": "G06F   7/50        20060101A I20051008RMEP"}, {"label": "G06F   9/30        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "708520"}, {"primary": false, "label": "712E09017"}, {"primary": false, "label": "708501"}, {"primary": false, "label": "708507"}, {"primary": false, "label": "708505"}, {"primary": false, "label": "712E09069"}, {"primary": false, "label": "712E09027"}], "ecla_classes": [{"label": "G06F   9/30A1A"}, {"label": "G06F   9/30R5"}, {"label": "G06F   9/38T4"}, {"label": "G06F   9/30A1P"}, {"label": "G06F   9/38S"}, {"label": "G06F   9/30R5D"}, {"label": "G06F   9/30R4C"}, {"label": "S06F7:483"}, {"label": "G06F   7/548"}, {"label": "G06F   7/544A"}, {"label": "G06F   7/509"}], "cpc_classes": [{"label": "G06F   9/30014"}, {"label": "G06F   9/30112"}, {"label": "G06F   7/5443"}, {"label": "G06F   7/509"}, {"label": "G06F   9/3887"}, {"label": "G06F   9/3012"}, {"label": "G06F   9/3885"}, {"label": "G06F   9/3013"}, {"label": "G06F   7/483"}, {"label": "G06F   9/30036"}, {"label": "G06F   7/548"}, {"label": "G06F   9/30036"}, {"label": "G06F   7/548"}, {"label": "G06F   9/3013"}, {"label": "G06F   7/483"}, {"label": "G06F   9/30112"}, {"label": "G06F   9/3012"}, {"label": "G06F   9/3887"}, {"label": "G06F   9/30014"}, {"label": "G06F   9/3885"}, {"label": "G06F   7/509"}, {"label": "G06F  17/16"}, {"label": "G06F   7/5443"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1996-10-16", "application_date": "2000-01-07", "family_members": [{"ucid": "US-6327605-B2", "titles": [{"lang": "EN", "text": "Data processor and data processing system"}]}, {"ucid": "US-6038582-A", "titles": [{"lang": "EN", "text": "Data processor and data processing system"}]}, {"ucid": "JP-3790307-B2", "titles": [{"lang": "JA", "text": "\u30c7\u30fc\u30bf\u30d7\u30ed\u30bb\u30c3\u30b5\u53ca\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "Data processor and data processing system"}]}, {"ucid": "TW-405093-B", "titles": [{"lang": "EN", "text": "Data processor and data processing system"}]}, {"ucid": "KR-100526315-B1", "titles": [{"lang": "KO", "text": "\ub370\uc774\ud0c0\ud504\ub85c\uc138\uc11c\ubc0f\ub370\uc774\ud0c0\ucc98\ub9ac\uc2dc\uc2a4\ud15c"}, {"lang": "EN", "text": "Data processor and data processing system"}]}, {"ucid": "KR-19980032693-A", "titles": [{"lang": "EN", "text": "Data processor and data processing system"}, {"lang": "KO", "text": "\ub370\uc774\ud0c0\ud504\ub85c\uc138\uc11c \ubc0f \ub370\uc774\ud0c0\ucc98\ub9ac\uc2dc\uc2a4\ud15c"}]}, {"ucid": "US-20010011291-A1", "titles": [{"lang": "EN", "text": "Data processor and data processing system"}]}, {"ucid": "US-6243732-B1", "titles": [{"lang": "EN", "text": "Data processor and data processing system"}]}, {"ucid": "JP-H10124484-A", "titles": [{"lang": "JA", "text": "\u30c7\u30fc\u30bf\u30d7\u30ed\u30bb\u30c3\u30b5\u53ca\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "DATA PROCESSOR AND DATA PROCESSING SYSTEM"}]}]}