{"patent_number": "US-6457118-B1", "publication_id": 73156961, "family_id": 23625217, "publication_date": "2002-09-24", "titles": [{"lang": "EN", "text": "Method and system for selecting and using source operands in computer system instructions"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11403664\" source=\"national office\"><p>According to the present invention, techniques for setting selected operand fields in pipelined architectures are provided. Methods and systems for efficiently selecting operand fields according to the present invention can be operative on a variety of computer architectures, including RISC architectures.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50383114\"><p>According to the present invention, techniques for setting selected operand fields in pipelined architectures are provided. Methods and systems for efficiently selecting operand fields according to the present invention can be operative on a variety of computer architectures, including RISC architectures.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00001\" num=\"1\"><claim-text>1. A method for performing dependency checking on instructions in a pipeline of a computer system, said pipeline containing a first instruction and subsequent instructions, said instructions comprising an opcode, a first source operand and a second source operand, said instructions comprising monadic instructions and dyadic instructions, said monadic instructions having an opcode that operates only on the first source operand, said dyadic instructions having an opcode that operates on the first source operand and the second source operand, said method comprising:</claim-text><claim-text>determining if said first instruction comprises a monadic instruction; </claim-text><claim-text>if said first instruction comprises a monadic instruction, replacing said second source operand with a token; and </claim-text><claim-text>detecting any dependencies between operands in said first instruction and operands in said subsequent instructions in said pipeline. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00002\" num=\"2\"><claim-text>2. The method of <claim-ref idref=\"US-6457118-B1-CLM-00001\">claim 1</claim-ref> wherein said detecting further comprises:</claim-text><claim-text>performing dyadic dependency checking for said monadic instructions and said dyadic instructions. </claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00003\" num=\"3\"><claim-text>3. The method of <claim-ref idref=\"US-6457118-B1-CLM-00001\">claim 1</claim-ref> wherein said token further comprises said first operand.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00004\" num=\"4\"><claim-text>4. The method of <claim-ref idref=\"US-6457118-B1-CLM-00001\">claim 1</claim-ref> further comprising:</claim-text><claim-text>detecting whether said first instruction comprises a floating point instruction; </claim-text><claim-text>if said first instruction comprises a floating point instruction, using said first operand as said token; otherwise using an integer value as said token. </claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00005\" num=\"5\"><claim-text>5. The method of <claim-ref idref=\"US-6457118-B1-CLM-00004\">claim 4</claim-ref> further comprising:</claim-text><claim-text>detecting if a third operand comprises an integer value; and </claim-text><claim-text>if a third operand comprises an integer value, providing a pre-fetch signal to the cache. </claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00006\" num=\"6\"><claim-text>6. The method of <claim-ref idref=\"US-6457118-B1-CLM-00001\">claim 1</claim-ref> wherein said instructions comprise RISC instructions.</claim-text></claim>"}, {"num": 7, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00007\" num=\"7\"><claim-text>7. A computer system for executing instructions, said instructions comprising a first instruction and subsequent instructions, said instructions comprising an opcode, a first operand and subsequent operands, said instructions comprising monadic instructions and dyadic instructions, said monadic instructions having an opcode that operates only on a first operand, said dyadic instructions having an opcode that operates on a first operand and a second operand, said system comprising:</claim-text><claim-text>a memory, said memory holding said instructions; </claim-text><claim-text>a processor, said processor operative to execute said instructions; </claim-text><claim-text>a pipeline, said pipeline unit operative to control processing by said processor of said instructions retrieved from said memory; wherein said pipeline unit is operatively disposed to: </claim-text><claim-text>determine if said first instruction comprises a monadic instruction; </claim-text><claim-text>if said first instruction comprises a monadic instruction, replace said subsequent source operands with a token; and </claim-text><claim-text>detect any dependencies between operands in said first instruction and operands in said subsequent instructions in said pipeline. </claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00008\" num=\"8\"><claim-text>8. The system of <claim-ref idref=\"US-6457118-B1-CLM-00007\">claim 7</claim-ref> wherein said detecting further comprises:</claim-text><claim-text>performing dyadic dependency checking for said monadic instructions and said dyadic instructions. </claim-text></claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00009\" num=\"9\"><claim-text>9. The system of <claim-ref idref=\"US-6457118-B1-CLM-00007\">claim 7</claim-ref> wherein said token further comprises said first operand.</claim-text></claim>"}, {"num": 10, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00010\" num=\"10\"><claim-text>10. The system of <claim-ref idref=\"US-6457118-B1-CLM-00007\">claim 7</claim-ref>, wherein said pipeline unit is further operative to:</claim-text><claim-text>detect whether said first instruction comprises a floating point instruction; </claim-text><claim-text>if said first instruction comprises a floating point instruction, use said subsequent source operands as said token; otherwise use an integer value as said token. </claim-text></claim>"}, {"num": 11, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00011\" num=\"11\"><claim-text>11. The system of <claim-ref idref=\"US-6457118-B1-CLM-00007\">claim 7</claim-ref> wherein said instructions comprise RISC instructions.</claim-text></claim>"}, {"num": 12, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00012\" num=\"12\"><claim-text>12. The system of <claim-ref idref=\"US-6457118-B1-CLM-00007\">claim 7</claim-ref> further comprising:</claim-text><claim-text>a 64-bit register which is read-only and returns all zeros. </claim-text></claim>"}, {"num": 13, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00013\" num=\"13\"><claim-text>13. The system of <claim-ref idref=\"US-6457118-B1-CLM-00007\">claim 7</claim-ref> wherein said processor is a 64-bit computer processor for executing the instruction stored in memory; wherein said executing comprises one data field using said 64-bit register.</claim-text></claim>"}, {"num": 14, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00014\" num=\"14\"><claim-text>14. The computer system of <claim-ref idref=\"US-6457118-B1-CLM-00012\">claim 12</claim-ref> wherein said pipeline unit marks said 64-bit register if said 64-bit register is a destination register in said instruction.</claim-text></claim>"}, {"num": 15, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00015\" num=\"15\"><claim-text>15. A method for performing dependency checking on computer instructions in a pipeline of a computer system comprising:</claim-text><claim-text>determining if a first computer instruction, comprising an opcode and a plurality of source operands, has the opcode operating on only a first source operand; </claim-text><claim-text>replacing a unused operand with the first source operand; and </claim-text><claim-text>detecting any dependencies between the operands in the first computer instruction and operands in another computer instruction in the pipeline by performing dyadic dependency checking using the unused operand and first source operand. </claim-text></claim>"}, {"num": 16, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6457118-B1-CLM-00016\" num=\"16\"><claim-text>16. A method for performing dependency checking on computer instructions in a pipeline of a computer system comprising:</claim-text><claim-text>determining if a first computer instruction, comprising an opcode and a plurality of source operands, has the opcode operating on only a first source operand; </claim-text><claim-text>replacing a unused operand with a special operand, wherein the special operand references a read-only register comprising zeros; and </claim-text><claim-text>detecting any dependencies between the operands in the first computer instruction and operands in another computer instruction in the pipeline by performing dyadic dependency checking using the unused operand and first source operand.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53638895\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>CROSS-REFERENCES TO RELATED APPLICATIONS</h4><p>The following applications, including this one, are being filed concurrently, and the disclosure of the other applications are incorporated by reference into this application in their entirety for all purposes:</p><p>U.S. patent application Ser. No. 09/410,633, entitled \u201cAN INTEGER INSTRUCTION SET ARCHITECTURE AND IMPLEMENTATION\u201d;</p><p>U.S. patent application Ser. No. 09/690,340, entitled \u201cA METHOD FOR LOADING AND STORING DATA IN A COMPUTER SYSTEM\u201d;</p><p>U.S. patent application Ser. No. 09/411,600, entitled \u201cA FLOATING POINT INSTRUCTION SET ARCHITECTURE AND IMPLEMENTATION\u201d.</p><p>U.S. patent application Ser. No. 09,410,675, entitled \u201cA METHOD FOR ENCODING COMPUTER INSTRUCTION DATA FIELD\u201d.</p><h4>BACKGROUND OF THE INVENTION</h4><p>The present invention relates generally to computer instruction set architectures, and particularly to the setting of selected operand fields.</p><p>In the past decade RISC (Reduced Instruction Set Computer) architectures, in which each instruction is ideally performed in a single operational cycle, have become popular. RISC architecture computers present several advantages over standard architecture computers. For instance, RISC instruction sets are capable of much higher data processing speeds due to their ability to perform frequent operations in shorter periods of time. The RISC devices began with 16-bit instruction sets, and grew to 32-bit instruction set architectures.</p><p>Pipelining techniques have been used in conjunction with RISC architectures to increase data throughput. Pipelining brought the need for data dependency checking; where the output of one instruction is the expected input into a following instruction. In some cases, instructions are divided into monadic (single source) and dyadic (dual source) instructions, each having its own unique dependency logic.</p><p>In addition to the complexities introduced by pipelining, applications have also contributed to the increasing complexity of RISC architectures. Frequently used constants, such as zero, can be set in different places from different sources.</p><p>Thus there is need for simplifying dependency logic without adding additional complexities to the hardware. In addition, there is a need to have a centralized, known source for zero to simplify the use of this frequently accessed constant.</p><h4>SUMMARY OF THE INVENTION</h4><p>According to the present invention, techniques for setting selected operand fields in pipelined architectures are provided. Methods and systems for efficiently selecting operand fields according to the present invention can be operative on a variety of computer architectures, including RISC architectures.</p><p>In a specific embodiment, the present invention provides a method for performing dependency checking on computer instructions in a pipeline of a computer system including determining if a first computer instruction has an opcode operating on only a first source operand. The computer instruction can have an opcode and a plurality of source operands, for example. Next, additional source operands can be replaced with the first source operand or the constant zero operand. Dependencies can be detected between the operands in the computer instruction and operands in other computer instructions in the pipeline. In a present embodiment, detecting can use the dyadic dependency checking for monadic instructions.</p><p>In another embodiment, the present invention provides a computer system for executing a computer instruction in a pipeline. The system can include a memory containing the computer instruction. The computer instruction can have a plurality of data fields, for example. A register that can return all zeros and a computer processor for executing the computer instruction stored in memory can also be part of the computer system. In a presently preferable embodiment, the register can be a 64-bit read only register, for example. The computer system can place one operand into the register while executing the computer instruction, for example.</p><p>Numerous advantages are provided by select embodiments according to the present invention. Embodiments can provide for setting selected operand fields in pipelined instructions for select computer architectures. In some embodiments, dependency checking for pipelined instructions can be provided. Many embodiments can be operable with RISC type computer architectures. Select embodiments can provide a standard hardware source for frequently used constant values and the like.</p><p>These and other advantages and features of the present invention will become apparent to those skilled in this art upon a reading of the following detailed description, which should be taken in conjunction with the accompanying drawings.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 illustrates a simplified block diagram of a representative top level partitioning of a core in a specific embodiment of the present invention;</p><p>FIG. 2 illustrates a simplified block diagram of a representative Instruction Flow Unit in a specific embodiment of the present invention;</p><p>FIG. 3 illustrates a simplified diagram of a representative computer instruction format in a specific embodiment of the present invention;</p><p>FIG. 4A illustrates a simplified diagram of a representative pipeline with no data dependency between instructions in a specific embodiment according to the present invention;</p><p>FIG. 4B illustrates a simplified diagram of a representative pipeline with data dependencies in a specific embodiment of the present invention; and</p><p>FIG. 4C illustrates a simplified diagram of a representative pipeline with data dependencies causing a stall in a specific embodiment of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DESCRIPTION OF THE SPECIFIC EMBODIMENTS</h4><p>Embodiments according to the present invention can provide techniques for setting selected operand fields in pipelined architectures. Methods and systems for efficiently selecting operand fields according to the present invention can be operative on a variety of computer architectures, including RISC architectures.</p><p>In a specific embodiment, the present invention may be implemented in a CPU having a core unit which may include six units and a detachable Floating-Point Unit (FPU). FIG. 1 illustrates simplified block diagram of a representative top level partitioning of a core of the present invention. This diagram is merely an example which should not limit the scope of the claims herein. One of ordinary skill in the art would recognize many other variations, alternatives, and modifications. Table 1 describes some of the functions of the units illustrated in core <b>100</b> of FIG. <b>1</b>.</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"49pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35pt\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"133pt\"></colspec><thead><row><entry nameend=\"3\" namest=\"1\" rowsep=\"1\">TABLE 1</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Unit</entry><entry>Acronym</entry><entry>Description</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry>S5 Core 200</entry><entry>S5</entry><entry>Top level core block</entry></row><row><entry>Bus interface</entry><entry>BIU</entry><entry>Controls bus access to external modules</entry></row><row><entry>unit 205</entry><entry></entry><entry>such as peripheral modules and external</entry></row><row><entry></entry><entry></entry><entry>memory interface.</entry></row><row><entry>Instruction</entry><entry>IFU</entry><entry>The front end of the CPU pipe: fetch,</entry></row><row><entry>Flow Unit</entry><entry></entry><entry>decode, issue &amp; branch. Also contains mode</entry></row><row><entry>210</entry><entry></entry><entry>B emulation.</entry></row><row><entry>Instruction</entry><entry>IMU</entry><entry>Handles all integer and multimedia</entry></row><row><entry>multimedia</entry><entry></entry><entry>instructions. The main CPU datapath.</entry></row><row><entry>unit 220</entry></row><row><entry>Instruction</entry><entry>ICU</entry><entry>Comprises the Instruction Cache and the</entry></row><row><entry>cache Unit</entry><entry></entry><entry>Instruction Translation Lookaside Buffer</entry></row><row><entry>230</entry><entry></entry><entry>(TLB)</entry></row><row><entry>Load Store</entry><entry>LSU</entry><entry>Handles all memory instructions and Data</entry></row><row><entry>Unit 240</entry><entry></entry><entry>cache control.</entry></row><row><entry>Data cache</entry><entry>DCU</entry><entry>Comprises the Data Cache and the Data</entry></row><row><entry>Unit 250</entry><entry></entry><entry>Translation Lookaside Buffer (TLB)</entry></row><row><entry>Floating Point</entry><entry>FPU</entry><entry>Detachable Floating point unit (not shown</entry></row><row><entry>Unit 265</entry><entry></entry><entry>in FIG. 1).</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>FIG. 2 illustrates a simplified block diagram of an Instruction Fetch Unit (IFU) <b>210</b> in a specific embodiment of the present invention. This diagram is merely an example which should not limit the scope of the claims herein. One of ordinary skill in the art would recognize many other variations, alternatives, and modifications. FIG. 2 illustrates instructions entering a Fetch Unit (FE) <b>242</b> from an Instruction Cache Unit (ICU) <b>130</b>. A Decoder (DEC) <b>244</b> can identify logical locations of the source and destination operands. Logical locations can include general-purpose register, floating-point register, target address register, control register, embedded immediate constant, the PC, and the like. Decoder <b>244</b> can pass its identification information to a Pipeline Control Unit (PPC) <b>246</b> that can select the proper source operands from the instructions. The Pipeline Control Unit <b>246</b> can also monitor the execution of the instruction through other stages of the instruction pipeline. PPC <b>246</b> can ensure that instructions are executed smoothly and correctly, for example. Instructions may be held in the decode stage until all the source operands are ready or can be ready when needed for execution of the instruction. An Operand File (OF) <b>248</b> can comprise source registers, i.e., General Purpose Registers (GPR's). Further reference may be had to Appendix 1 for a detailed description of a specific embodiment of IFU <b>210</b>.</p><p>FIG. 3 illustrates a simplified diagram of a representative example computer instruction format <b>260</b> in a specific embodiment of the present invention. This diagram is merely an example which should not limit the scope of the claims herein. One of ordinary skill in the art would recognize many other variations, alternatives, and modifications. Instruction format <b>260</b> is an example of a dyadic instruction including an opcode <b>262</b>, a register source<b>1</b><b>264</b>, a register source<b>2</b><b>268</b>, and a destination register <b>270</b>. Optionally, an extension <b>266</b> to opcode <b>262</b> and reserved bits <b>272</b> may be provided. In alternative embodiments, source<b>2</b><b>268</b> can be replaced by a 6-bit immediate address. Extension <b>266</b> and source<b>2</b><b>268</b> can be replaced with a 10-bit immediate address. Source<b>1</b><b>264</b>, extension <b>266</b>, and source<b>2</b><b>268</b> can be replaced with a 16-bit immediate address. FIG. 3 also illustrates a general purpose register <b>63</b> (GPR<b>63</b>) <b>280</b> which can be a read-only register storing value zero. Any of the source registers <b>264</b>, <b>268</b> or the destination register <b>270</b> can be set to GPR<b>63</b>.</p><p>In a specific embodiment of the present invention, there are two general categories of instructions: the floating-point instructions (or FP instructions) and the rest integer, multimedia, load/store, flow-control instructions (or simply integer instructions). The former operates on floating-point registers, which do not have a constant register, while the later operates on, among others, the general-purpose registers, which has a constant-zero register R<b>63</b>. For FP instructions, all un-used 2nd source operand specifiers, i.e., the contents of the field in the instruction identifying the 2nd source register, may be encoded the same as the 1st source operand specifier so that a generic dependency checking logic can be used to detect instruction dependencies without knowing whether the instruction is monadic or dyadic. For integer instructions, all un-used 2nd source operand specifiers may be encoded as binary \u201c<b>63</b>.\u201d This is because R<b>63</b> as a constant register has no read-after-write dependency. There can be no writing into R<b>63</b> and then reading from it. Since this property is true for both monadic and dyadic instructions, forcing all un-used 2nd operand specifiers to be encoded as <b>63</b> allows us to use a generic dependency checker on the integer side to check for read-after-write dependencies.</p><p>In one representative example, general purpose register <b>63</b> (GPR<b>63</b>) is used by the instruction PTABS. The PTABS instruction, Table 2, gives a target address specified by the source register Rn. The target address is stored in the target address register TRa. The reserved bits <b>20</b>-<b>25</b> may be implemented as \u201c111111\u201d or <b>63</b>. Thus the hardware for a dyadic dependency checker for read-after write dependencies may be used on PTABS, a monadic instruction.</p><p><tables id=\"TABLE-US-00002\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 2</entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry><chemistry id=\"CHEM-US-00001\"><attachments><attachment attachment-type=\"cdx\" file=\"US06457118-20020924-C00001.CDX\" idref=\"CHEMCDX-00001\"></attachment><attachment attachment-type=\"mol\" file=\"US06457118-20020924-C00001.MOL\" idref=\"CHEMMOL-00001\"></attachment></attachments></chemistry></entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>In another representative example, general purpose register <b>63</b> (GPR<b>63</b>) is used by the instruction GETTR. This instruction sign-extends a 32-bit target register (TR) into a 64-bit value. Table 3 illustrates a format for a GETTR instruction in a particular embodiment according to the present invention. Execution of a GETTR instruction, moves the value held in a target address register TR<sub>b </sub>into a general register R<sub>d</sub>. The value returned by GETTR ensures that any unimplemented high-order bits of the source target register are seen as sign extensions of the highest implemented bit. Table 3 illustrates a machine code representation of the instruction, followed by an assembly language mnemonic. Next is shown the functional algorithm, which may be implemented in software, hardware, or both.</p><p><tables id=\"TABLE-US-00003\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 3</entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry><chemistry id=\"CHEM-US-00002\"><attachments><attachment attachment-type=\"cdx\" file=\"US06457118-20020924-C00002.CDX\" idref=\"CHEMCDX-00002\"></attachment><attachment attachment-type=\"mol\" file=\"US06457118-20020924-C00002.MOL\" idref=\"CHEMMOL-00002\"></attachment></attachments></chemistry></entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>Table 3 illustrates an implementation of the GETTR instruction described in Table 2. In the specific embodiment of Table 3, the GETTR instruction is implemented as an ADD.L with the 2nd operand (Rn=63) being 0 to get the sign-extension. During execution of the ADD.L instruction, the low 32 bits of Rm are added to the low 32 bits of Rn. The sign-extended 32-bit result can be stored in Rd. Thus by having the 2nd source operand specifier, Rn, encoded as <b>63</b>, the 32-bit sign-extension operation for a monadic instruction, such as GETTR, can be implemented with the same circuit that implements the addition then sign-extension operation for a dyadic instruction, such as ADD.L.</p><p><tables id=\"TABLE-US-00004\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 4</entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry><chemistry id=\"CHEM-US-00003\"><attachments><attachment attachment-type=\"cdx\" file=\"US06457118-20020924-C00003.CDX\" idref=\"CHEMCDX-00003\"></attachment><attachment attachment-type=\"mol\" file=\"US06457118-20020924-C00003.MOL\" idref=\"CHEMMOL-00003\"></attachment></attachments></chemistry></entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>In some embodiments, GPR<b>63</b> can be a read-only register always having all zeroes stored in it. During hazard detection, PPC <b>246</b> can check if the current instruction has R<b>63</b> as a destination. If this is the case, PPC <b>246</b> marks the instruction as a non-valid destination. In this way, subsequent instructions may never find hazards on Register <b>63</b> and it is read from the register file. This may be further explained, since R<b>63</b> is a constant register, designating R<b>63</b> as the target register can not (i) change the value of R<b>63</b>, and (ii) cause dependencies from subsequent instructions that use R<b>63</b> as a source operand. The specific embodiment of the architecture takes advantage of this property and uses it to provide a prefetch hint to the cache. For example, when a Load instruction is decoded, the IFU checks if the target register is R<b>63</b> (this logic already exists for the dependency checking). If the target register is R<b>63</b>, the LSU is informed that this is a cache hint and the result will not be used so that the LSU does not need to stall the pipeline if the operand can not be found in the cache. In addition, the LSU will not raise any exception if the load address is bad. Since R<b>63</b> can not be written into, the load (into R<b>63</b>) will proceed down the pipeline like a NOP except that the cache control is informed to load the operand into the cache if it is not already there.</p><p>FIG. 4A shows a pipeline with no data dependency between instructions op<b>1</b><b>310</b>, op<b>2</b><b>314</b>, and op<b>3</b><b>318</b>. This diagram is merely an example which should not limit the scope of the claims herein. One of ordinary skill in the art would recognize many other variations, alternatives, and modifications. FIG. 4A illustrates instruction op<b>1</b><b>310</b> having an opcode, op<b>1</b>, followed by, R<b>1</b>, a position of the first source register (<b>264</b> in FIG. <b>3</b>), R<b>2</b>, the position of the second source register (<b>268</b> in FIG. <b>3</b>), and R<b>3</b>, the position of the destination register (<b>270</b> in FIG. <b>3</b>). The execution timeline <b>312</b> illustrates the execution cycle for instruction <b>310</b> having op<b>1</b>. Execution timeline <b>312</b> has a decode stage, D, and a write stage, W. There are three execution stages in <b>312</b>, E<b>1</b>, E<b>2</b>, and E<b>3</b>. The next instruction <b>314</b> is executed as shown by execution timeline <b>316</b>. Comparing execution timeline <b>316</b> with execution timeline <b>312</b>, it can be seen that instruction <b>314</b> can be decoded, D of <b>316</b>, while instruction <b>310</b> is in execution stage E<b>1</b> of <b>312</b>. The arrangement of decode stages (D) in execution timelines <b>312</b>, <b>316</b> and <b>320</b> illustrates that a new instruction can be decoded in times i, i+1, and i+2, where each vertical arrangement of blocks in execution timelines <b>312</b>, <b>316</b> and <b>320</b>, represents the same time cycle. For example at time \u201ci+1\u201d <b>322</b>, execution cycle <b>312</b> is in the E<b>1</b> stage and execution cycle <b>316</b> is in the D stage.</p><p>FIG. 4B illustrates simplified diagram of a representative pipeline with data dependencies in a specific embodiment of the present invention. This diagram is merely an example which should not limit the scope of the claims herein. One of ordinary skill in the art would recognize many other variations, alternatives, and modifications. FIG. 4B illustrates a first instruction <b>330</b> having an opcode op<b>4</b> and a destination register R<b>3</b>. Destination register R<b>3</b> is used as a source in subsequent instruction <b>334</b>, having opcode op<b>5</b>. If the destination data can be produced in one cycle for instruction <b>330</b> (op<b>4</b>), then execution timeline <b>332</b> shows that at E<b>1</b>, the data is available to the decode cycle, D, of execution timeline <b>336</b> for subsequent instruction <b>334</b>. Similarly, the result of instruction <b>334</b> (op<b>5</b>) is produced by execution stage E<b>1</b> depicted by execution timeline <b>336</b>. This result is passed to decode stage D, of instruction <b>338</b> (op<b>6</b>) illustrated by execution timeline <b>340</b>.</p><p>FIG. 4C illustrates a simplified diagram of a representative pipeline with data dependencies causing a stall in a specific embodiment of the present invention. This diagram is merely an example which should not limit the scope of the claims herein. One of ordinary skill in the art would recognize many other variations, alternatives, and modifications. In this example, instruction <b>350</b> (op<b>7</b>) takes two execution cycles E<b>1</b>, E<b>2</b> after decode stage D, as illustrated by execution timeline <b>352</b>. The R<b>3</b> result of instruction <b>350</b> is used as an input to instruction <b>354</b> (op<b>8</b>). Therefore, the PPC \u201cstalls\u201d one cycle <b>358</b> in execution timeline <b>356</b>, in order to obtain the correct value of R<b>3</b> from processing of instruction <b>350</b> (op<b>7</b>). As instruction <b>360</b> (op<b>6</b>) uses result R<b>6</b> of instruction <b>354</b> (op<b>8</b>), processing of this instruction is also delayed, as indicated by execution timeline <b>362</b>. Thus, in order to prevent a hazard, there may be a data dependency check between the result register R<b>3</b> of instruction <b>350</b> (op<b>7</b>) and the two input source registers R<b>3</b> and R<b>5</b> of instruction <b>354</b> (op<b>8</b>). Both sources from instruction <b>354</b> (op<b>8</b>) may need to be checked, as both source values are required to compute the result R<b>6</b> of the instruction.</p><p>In a specific embodiment of the present invention, monadic instructions may have a format such as format of <b>260</b> of FIG. 3, with one source register <b>264</b> or <b>268</b> left unused. If the unused source register were set to be equal to the used source register, then the dependency pipeline diagram illustrated in FIG. 4C could be used. There would not be a need for a separate monadic dependency checking circuit.</p><p>An example of a monadic instruction with a dyadic format in a specific embodiment of the present invention is the FABS.D instruction. Table 5 illustrates instruction FABS.D, which computes the absolute value of a double-precision floating-point number. It reads the value of DRg, clears its sign bit and stores the result in DRf. The second source register is represented by reserved bits <b>10</b>-<b>15</b> or \u201cr1.\u201d</p><p><tables id=\"TABLE-US-00005\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 5</entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry><chemistry id=\"CHEM-US-00004\"><attachments><attachment attachment-type=\"cdx\" file=\"US06457118-20020924-C00004.CDX\" idref=\"CHEMCDX-00004\"></attachment><attachment attachment-type=\"mol\" file=\"US06457118-20020924-C00004.MOL\" idref=\"CHEMMOL-00004\"></attachment></attachments></chemistry></entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>Thus setting \u201cr1\u201d in the above instruction to the value of the used source register, DRg, in FABS.D, would allow use of the dyadic dependency checking as described hereinabove with reference to FIG. <b>4</b>C.</p><p>Another advantage of the replicated source operand in a monadic instruction may be that this gives more flexibility to the design. In a typical design there will be source operand buses that pass through the pipeline. The replicated source operand allows that source to be accessed on either the source<b>1</b> or source<b>2</b> bus to best suit the design. This leads to more flexibility in the physical layout of the design (it may be more physically convenient to take the operand from one bus rather than the other). Also, if the two buses are not equally utilized (i.e., one is loaded more heavily than the other), then the replicated source operand allows the less loaded bus to be used, hence equalizing their loading.</p><h4>CONCLUSION</h4><p>In the foregoing specification, the invention has been described with reference to specific exemplary embodiments thereof. Other embodiments will be apparent to those of ordinary skill in the art. For example, the instructions may be 16 or 64 or 128 bits or more in length, there may be three source operands of which only one is used (hence copied into the other operands), or the pipeline may contain more or less than three stages. Thus it is evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the appended claims and their full scope of equivalents.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Chih-Jui", "last_name": "Peng", "name": ""}, {"first_name": "Glenn Ashley", "last_name": "Farrall", "name": ""}, {"first_name": "Sivaram", "last_name": "Krishnan", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "HITACHI LTD"}, {"first_name": "", "last_name": "TESSERA ADVANCED TECHNOLOGIES, INC", "name": ""}, {"first_name": "", "last_name": "IBIQUITY DIGITAL CORPORATION", "name": ""}, {"first_name": "", "last_name": "INVENSAS BONDING TECHNOLOGIES, INC. (F/K/A ZIPTRONIX, INC.)", "name": ""}, {"first_name": "", "last_name": "FOTONATION CORPORATION (F/K/A DIGITALOPTICS CORPORATION AND F/K/A DIGITALOPTICS CORPORATION MEMS)", "name": ""}, {"first_name": "", "last_name": "TESSERA, INC.", "name": ""}, {"first_name": "", "last_name": "DTS, INC.", "name": ""}, {"first_name": "", "last_name": "INVENSAS CORPORATION", "name": ""}, {"first_name": "", "last_name": "DTS LLC", "name": ""}, {"first_name": "", "last_name": "PHORUS, INC.", "name": ""}, {"first_name": "", "last_name": "ROYAL BANK OF CANADA, AS COLLATERAL AGENT", "name": ""}, {"first_name": "", "last_name": "TESSERA ADVANCED TECHNOLOGIES, INC.", "name": ""}, {"first_name": "", "last_name": "RENESAS ELECTRONICS CORPORATION", "name": ""}, {"first_name": "", "last_name": "HITACHI LTD.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/38"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/30        20060101A I20051008RMEP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712226"}, {"primary": false, "label": "712E09024"}, {"primary": false, "label": "712213"}, {"primary": false, "label": "712216"}, {"primary": false, "label": "712E0903"}, {"primary": false, "label": "712208"}, {"primary": false, "label": "712E09049"}, {"primary": false, "label": "712E09047"}], "ecla_classes": [{"label": "G06F   9/38E1"}, {"label": "G06F   9/30T4T"}, {"label": "G06F   9/30T4"}, {"label": "G06F   9/30R2"}, {"label": "G06F   9/38E"}, {"label": "G06F   9/38D2"}], "cpc_classes": [{"label": "G06F   9/3838"}, {"label": "G06F   9/3836"}, {"label": "G06F   9/383"}, {"label": "G06F   9/3016"}, {"label": "G06F   9/30101"}, {"label": "G06F   9/30167"}, {"label": "G06F   9/3838"}, {"label": "G06F   9/30167"}, {"label": "G06F   9/383"}, {"label": "G06F   9/3836"}, {"label": "G06F   9/30101"}, {"label": "G06F   9/3016"}, {"label": "G06F   9/38"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1999-10-01", "application_date": "1999-10-01", "family_members": [{"ucid": "TW-569140-B", "titles": [{"lang": "EN", "text": "A method and system for selecting and using source operands in computer system instructions"}]}, {"ucid": "US-6457118-B1", "titles": [{"lang": "EN", "text": "Method and system for selecting and using source operands in computer system instructions"}]}, {"ucid": "KR-20010050812-A", "titles": [{"lang": "KO", "text": "\ucef4\ud4e8\ud130 \uc2dc\uc2a4\ud15c \uba85\ub839\ub4e4\uc758 \uc18c\uc2a4 \uc5f0\uc0b0\uc218\ub4e4\uc744 \uc120\ud0dd\ud558\uace0\uc0ac\uc6a9\ud558\uae30 \uc704\ud55c \ubc29\ubc95 \ubc0f \uc2dc\uc2a4\ud15c"}, {"lang": "EN", "text": "A METHOD AND SYSTEM FOR SELECTING AND USING SOURCE OPERANDS IN COMPUTER SYSTEM INSTRUCTIONS"}]}, {"ucid": "JP-2001142706-A", "titles": [{"lang": "JA", "text": "\u547d\u4ee4\u4e0a\u3067\u306e\u4f9d\u5b58\u6027\u30c1\u30a7\u30c3\u30af\u306e\u5b9f\u884c\u65b9\u6cd5\u3068\u547d\u4ee4\u5b9f\u884c\u7528\u306e\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "METHOD FOR CHECKING DEPENDENCE ON INSTRUCTION AND COMPUTER SYSTEM FOR INSTRUCTION EXECUTION"}]}]}