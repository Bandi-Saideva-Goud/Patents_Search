{"patent_number": "US-6560694-B1", "publication_id": 73405067, "family_id": 23921391, "publication_date": "2003-05-06", "titles": [{"lang": "EN", "text": "Double prefix overrides to provide 16-bit operand size in a 32/64 operating mode"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50488955\"><p>A processor supports an operating mode in which the default address size is greater than 32 bits and the default operand size is 32 bits. The default address size may be nominally indicated as 64 bits, although various embodiments of the processor may implement any address size which exceeds 32 bits, up to and including 64 bits, in the operating mode. The operating mode may be established by placing an enable indication in a control register into an enabled state and by setting a first operating mode indication and a second operating mode indication in a segment descriptor to predefined states. Additionally, a first instruction prefix may be coded into an instruction to override the default operand size to a first non-default operand size (e.g. 64 bits). Furthermore, a second instruction prefix may be coded into an instruction in addition to the first instruction prefix to override the default operand size to a second non-default operand size (e.g. 16 bits). Thus operand sizes of 64, 32, and 16 bits may be used when desired.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00001\" num=\"1\"><claim-text>1. A processor comprising:</claim-text><claim-text>an execution core configured to execute a first instruction having a first instruction prefix and a second instruction prefix, wherein a combination of said first instruction prefix and said second instruction prefix specifies that a default operand size of said processor be overridden with a first operand size, and wherein said execution core is configured to execute a second instruction including said first instruction prefix but not including said second instruction prefix, and wherein inclusion of said first instruction prefix but not said second instruction prefix specifies that said default operand size be overridden by a second operand size different from said first operand size. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00002\" num=\"2\"><claim-text>2. The processor as recited in <claim-ref idref=\"US-6560694-B1-CLM-00001\">claim 1</claim-ref> wherein said default operand size is 32 bits.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00003\" num=\"3\"><claim-text>3. The processor as recited in <claim-ref idref=\"US-6560694-B1-CLM-00002\">claim 2</claim-ref> wherein said second operand size is 64 bits.</claim-text></claim>"}, {"num": 4, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00004\" num=\"4\"><claim-text>4. The processor as recited in <claim-ref idref=\"US-6560694-B1-CLM-00002\">claim 2</claim-ref> wherein said first operand size is 16 bits.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00005\" num=\"5\"><claim-text>5. The processor as recited in <claim-ref idref=\"US-6560694-B1-CLM-00001\">claim 1</claim-ref> wherein said execution core is configured to execute a third instruction including said first instruction prefix, said second instruction prefix, and a third instruction prefix, and wherein a combination of said first instruction prefix and said second instruction prefix specifies that said default operand size be overridden by said first operand size, and wherein said third instruction prefix is ignored by said execution core.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00006\" num=\"6\"><claim-text>6. The processor as recited in <claim-ref idref=\"US-6560694-B1-CLM-00001\">claim 1</claim-ref> wherein said first instruction prefix is a first encoding and said second instruction prefix is said first encoding.</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00007\" num=\"7\"><claim-text>7. The processor as recited in <claim-ref idref=\"US-6560694-B1-CLM-00006\">claim 6</claim-ref> wherein each of said first instruction prefix and said second instruction prefix is a byte.</claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00008\" num=\"8\"><claim-text>8. The processor as recited in <claim-ref idref=\"US-6560694-B1-CLM-00001\">claim 1</claim-ref> further comprising:</claim-text><claim-text>a segment register configured to store operating mode information; and </claim-text><claim-text>a control register configured to store an enable indication, wherein said processor is configured to establish said default operand size responsive to said operating mode information and said enable indication. </claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00009\" num=\"9\"><claim-text>9. The processor as recited in <claim-ref idref=\"US-6560694-B1-CLM-00008\">claim 8</claim-ref> wherein said operating mode information comprises a first operating mode indication and a second operating mode indication.</claim-text></claim>"}, {"num": 10, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00010\" num=\"10\"><claim-text>10. The processor as recited in <claim-ref idref=\"US-6560694-B1-CLM-00001\">claim 1</claim-ref> wherein said execution core is configured to fetch a first operand of said first operand size for said first instruction.</claim-text></claim>"}, {"num": 11, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00011\" num=\"11\"><claim-text>11. The processor as recited in <claim-ref idref=\"US-6560694-B1-CLM-00001\">claim 1</claim-ref> wherein said execution core is configured to modify a portion of a destination register of said first instruction, said portion being equal to said first operand size.</claim-text></claim>"}, {"num": 12, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00012\" num=\"12\"><claim-text>12. The processor as recited in <claim-ref idref=\"US-6560694-B1-CLM-00001\">claim 1</claim-ref> wherein said execution core is configured to operate upon operands of said first operand size.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00013\" num=\"13\"><claim-text>13. A method comprising:</claim-text><claim-text>executing a first instruction which includes a first instruction prefix and a second instruction prefix, wherein a combination of said first instruction prefix and said second instruction prefix specifies that a default operand size of a processor be overridden with a first operand size; </claim-text><claim-text>overriding said default operand size with said first operand size during said executing; and </claim-text><claim-text>executing a second instruction which includes said first instruction prefix but not said second instruction prefix, wherein inclusion of said first instruction prefix and not said second instruction prefix specifies that said default operand size of said processor be overridden with a second operand size different from said first operand size. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00014\" num=\"14\"><claim-text>14. The method as recited in <claim-ref idref=\"US-6560694-B1-CLM-00013\">claim 13</claim-ref> wherein said default operand size is 32 bits.</claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00015\" num=\"15\"><claim-text>15. The method as recited in <claim-ref idref=\"US-6560694-B1-CLM-00014\">claim 14</claim-ref> wherein said second operand size is 64 bits.</claim-text></claim>"}, {"num": 16, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00016\" num=\"16\"><claim-text>16. The method as recited in <claim-ref idref=\"US-6560694-B1-CLM-00014\">claim 14</claim-ref> wherein said first operand size is 16 bits.</claim-text></claim>"}, {"num": 17, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00017\" num=\"17\"><claim-text>17. The method as recited in <claim-ref idref=\"US-6560694-B1-CLM-00013\">claim 13</claim-ref> further comprising:</claim-text><claim-text>executing a third instruction which includes said first instruction prefix, said second instruction prefix, and a third instruction prefix, wherein a combination of said first instruction prefix and said second instruction prefix specifies that said default operand size of said processor be overridden with said first operand size, and wherein inclusion of said third instruction prefix is ignored. </claim-text></claim>"}, {"num": 18, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00018\" num=\"18\"><claim-text>18. The method as recited in <claim-ref idref=\"US-6560694-B1-CLM-00013\">claim 13</claim-ref> further comprising establishing said default operand size responsive to an enable indication in a control register of said processor and further responsive to operating mode information stored in a segment register.</claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00019\" num=\"19\"><claim-text>19. The method as recited in <claim-ref idref=\"US-6560694-B1-CLM-00018\">claim 18</claim-ref> wherein said operating mode information includes a first operating mode indication and a second operating mode indication.</claim-text></claim>"}, {"num": 20, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00020\" num=\"20\"><claim-text>20. A computer system comprising:</claim-text><claim-text>a processor comprising an execution core configured to execute a first instruction having a first instruction prefix and a second instruction prefix, wherein a combination of said first instruction prefix and said second instruction prefix specifies that a default operand size of said processor be overridden with a first operand size, and wherein said execution core is configured to execute a second instruction including said first instruction prefix but not including said second instruction prefix, and wherein inclusion of said first instruction prefix but not said second instruction prefix specifies that said default operand size be overridden by a second operand size different from said first operand size; and </claim-text><claim-text>an input/output (I/O) device coupled to the processor and configured to communicate between said processor and another computer system. </claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6560694-B1-CLM-00021\" num=\"21\"><claim-text>21. The computer system as recited in <claim-ref idref=\"US-6560694-B1-CLM-00020\">claim 20</claim-ref> wherein the I/O device comprises a modem.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53919833\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention is related to the field of processors and, more particularly, to address and operand sizes in processors.</p><p>2. Description of the Related Art</p><p>The x86 architecture (also known as the IA-32 architecture) has enjoyed widespread acceptance and success in the marketplace. Accordingly, it is advantageous to design processors according to the x86 architecture. Such processors may benefit from the large body of software written to the x86 architecture (since such processors may execute the software and thus computer systems employing the processors may enjoy increased acceptance in the market due to the large amount of available software).</p><p>As computer systems have continued to evolve, 64 bit address size (and sometimes operand size) has become desirable. A larger address size allows for programs having a larger memory footprint (the amount of memory occupied by the instructions in the program and the data operated upon by the program) to operate within the memory space. A larger operand size allows for operating upon larger operands, or for more precision in operands. More powerful applications and/or operating systems may be possible using 64 bit address and/or operand sizes.</p><p>Unfortunately, the x86 architecture is limited to a maximum 32 bit operand size and 32 bit address size. The operand size refers to the number of bits operated upon by the processor (e.g. the number of bits in a source or destination operand). The address size refers to the number of bits in an address generated by the processor. Thus, processors employing the x86 architecture may not serve the needs of applications which may benefit from 64 bit address or operand sizes.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by a processor as described herein. The processor supports an operating mode in which the default address size is greater than 32 bits and the default operand size is 32 bits. The default address size may be nominally indicated as 64 bits, although various embodiments of the processor may implement any address size which exceeds 32 bits, up to and including 64 bits, in the operating mode. The operating mode may be established by placing an enable indication in a control register into an enabled state and by setting a first operating mode indication and a second operating mode indication in a segment descriptor to predefined states. Additionally, a first instruction prefix may be coded into an instruction to override the default operand size to a first non-default operand size (e.g. 64 bits). Furthermore, a second instruction prefix may be coded into an instruction in addition to the first instruction prefix to override the default operand size to a second non-default operand size (e.g. 16 bits). Thus, operand sizes of 64, 32, and 16 bits may be used when desired.</p><p>Broadly speaking, a processor comprising an execution core is contemplated. The execution core is configured to execute a first instruction having a first instruction prefix and a second instruction prefix, wherein a combination of the first instruction prefix and the second instruction prefix specifies that a default operand size of the processor be overridden with a first operand size. Additionally, a computer system is contemplated including the processor and an input/output (I/O) device configured to communicate between the computer system and another computer system to which the I/O device is couplable.</p><p>Moreover, a method is contemplated. A first instruction which includes a first instruction prefix and a second instruction prefix is executed. A combination of the first instruction prefix and the second instruction prefix specifies that a default operand size of a processor be overridden with a first operand size. The default operand size is overridden by the first operand size during execution of the first instruction.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of one embodiment of a processor.</p><p>FIG. 2 is a block diagram of one embodiment of a segment descriptor for 32/64 mode.</p><p>FIG. 3 is a block diagram of one embodiment of a segment descriptor for compatibility mode.</p><p>FIG. 4 is a block diagram of operation in compatibility mode and in legacy mode according to one embodiment of the processor shown in FIG. <b>1</b>.</p><p>FIG. 5 is a table illustrating one embodiment of operating modes as a function of segment descriptor and control register values.</p><p>FIG. 6 is a table illustrating one embodiment of the use of instruction prefixes to override default operating modes.</p><p>FIG. 7 is a block diagram of one embodiment of a register.</p><p>FIG. 8 is a diagram illustrating one embodiment of a global descriptor table and a local descriptor table.</p><p>FIG. 9 is a block diagram of one embodiment of a 32/64 call gate descriptor.</p><p>FIG. 10 is a block diagram of an instruction format.</p><p>FIG. 11 is a block diagram of one embodiment of a computer system including the processor shown in FIG. <b>1</b>.</p><p>FIG. 12 is a block diagram of another embodiment of a computer system including the processor shown in FIG. <b>1</b>.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</h4><p>Turning now to FIG. 1, a block diagram illustrating one embodiment of a processor <b>10</b> is shown. Other embodiments are possible and contemplated. In the embodiment of FIG. 1, processor <b>10</b> includes an instruction cache <b>12</b>, an execution core <b>14</b>, a data cache <b>16</b>, an external interface unit <b>18</b>, a memory management unit (MMU) <b>20</b>, and a register file <b>22</b>. In the illustrated embodiment, MMU <b>20</b> includes a set of segment registers <b>24</b>, a first control register <b>26</b>, a second control register <b>28</b>, a local descriptor table register (LDTR) <b>30</b>, and a global descriptor table register (GDTR) <b>32</b>. Instruction cache <b>12</b> is coupled to external interface unit <b>18</b>, execution core <b>14</b>, and MMU <b>20</b>. Execution core <b>14</b> is further coupled to MMU <b>20</b>, register file <b>22</b>, and data cache <b>16</b>. Data cache <b>16</b> is further coupled to MMU <b>20</b> and external interface unit <b>18</b>. External interface unit <b>18</b> is further coupled to MMU <b>20</b> and to an external interface.</p><p>Generally speaking, processor <b>10</b> employs a processor architecture compatible with the x86 architecture and including additional architectural features to support 64 bit processing. Processor <b>10</b> is configured to establish an operating mode in response to information stored in a code segment descriptor corresponding to the currently executing code and further in response to one or more enable indications stored in one or more control registers. As used herein, an \u201coperating mode\u201d specifies default values for various programmably selectable processor attributes. For example, the operating mode may specify a default operand size and a default address size. The default operand size specifies the number of bits in an operand of an instruction, unless an instruction's encoding overrides the default. The default address size specifies the number of bits in an address of a memory operand of an instruction, unless an instruction's encoding overrides the default. The default address size specifies the size of at least the virtual address of memory operands, and may also specify the size of the physical address. Alternatively, the size of the physical address may be independent of the default address size and may instead be dependent on the LME bit described below (e.g. the physical address may be 32 bits if the LME bit is clear and an implementation-dependent size greater than 32 bits and less than 64 bits if the LME bit is set) or on another control bit (e.g. the physical address extension bit, or PAE bit, in another control register). As used herein, a \u201cvirtual address\u201d is an address generated prior to translation through an address translation mechanism (e.g. a paging mechanism) to a \u201cphysical address\u201d, which is the address actually used to access a memory. Additionally, as used herein, a \u201csegment descriptor\u201d is a data structure created by software and used by the processor to define access control and status for a segment of memory. A \u201csegment descriptor table\u201d is a table in memory having multiple entries, each entry capable of storing a segment descriptor.</p><p>In the illustrated embodiment, MMU <b>20</b> generates an operating mode and conveys the operating mode to execution core <b>14</b>. Execution core <b>14</b> executes instructions using the operating mode. More particularly, execution core <b>14</b> may fetch operands having the default operand size from register file <b>22</b> or memory (through data cache <b>16</b>, if the memory operands are cacheable and hit therein, or through external interface unit <b>18</b> if the memory operands are noncacheable or miss data cache <b>16</b>) unless a particular instruction's encoding overrides the default operand size, in which case the overriding operand size is used. Execution core <b>14</b> updates destination operands having the default operand size unless a particular instruction's encoding overrides the default operand size, in which case the overriding operand size is used (e.g. execution core <b>14</b> may modify only a portion of the destination register, the portion being specified by the operand size). Similarly, execution core <b>14</b> generates addresses of memory operands, wherein the addresses have the default address size unless a particular instruction's encoding overrides the default address size, in which case the overriding address size is used. In other embodiments, the information used to generate the operating mode may be shadowed locally in the portions of processor <b>10</b> which use the operating mode (e.g. execution core <b>14</b>), and the operating mode may be determined from the local shadow copies.</p><p>As mentioned above, MMU <b>20</b> generates the operating mode responsive to a code segment descriptor corresponding to the code being executed and further responsive to one or more values in control registers. Information from the code segment descriptor is stored in one of the segment registers <b>24</b> (a register referred to as CS, or code segment). Additionally, control register <b>26</b> stores an enable indication (LME) which is used to enable an operating mode in which the default address size is greater than 32 bits (\u201c32/64 mode\u201d) as well as certain compatibility modes for the 32 bit and 16 bit operating modes. The default operand size may be 32 bits in 32/64 mode, but instructions may override the default 32 bit operand size with a 64 bit operand size when desired. If the LME indication is in an enabled state, then 32/64 mode may be used in addition to 32 bit and 16 bit modes. If the LME indication is in a disabled state, then 32/64 mode is disabled. In one embodiment, the default address size in 32/64 mode may be implementation-dependent but may be any value up to and including 64 bits. Furthermore, the size of the virtual address may differ in a given implementation from the size of the physical address in that implementation.</p><p>It is noted that enable indications may be described herein as bits with the enabled state being the set state of the bit and the disabled state being the cleared state of the bit. However, other encodings are possible, including encodings in which multiple bits are used and encodings in which the enabled state is the clear state and the disabled state is the set state. Accordingly, the remainder of this description may refer to the LME indication in control register <b>26</b> as the LME bit, with the enabled state being set and the disabled state being clear. However, other encodings of the LME indication are contemplated, as set forth above.</p><p>Segment registers <b>24</b> store information from the segment descriptors currently being used by the code being executed by processor <b>10</b>. As mentioned above, CS is one of segment registers <b>24</b> and specifies the code segment of memory. The code segment stores the code being executed. Other segment registers may define various data segments (e.g. a stack data segment defined by the SS segment register, and up to four data segments defined by the DS, ES, FS, and GS segment registers). FIG. 1 illustrates the contents of an exemplary segment register <b>24</b>A, including a selector field <b>24</b>AA and a descriptor field <b>24</b>AB. Selector field <b>24</b>AA is loaded with a segment selector to activate a particular segment in response to certain segment load instructions executed by execution core <b>14</b>. The segment selector identifies the segment descriptor in a segment descriptor table in memory. More particularly, processor <b>10</b> may employ two segment descriptor tables: a local descriptor table and a global descriptor table. The base address of the local descriptor table is stored in the LDTR <b>30</b>. Similarly, the base address of the global descriptor table is stored in GDTR <b>32</b>. A bit within the segment selector (the table indicator bit) selects the descriptor table, and the remainder of the segment selector is used as an index into the selected table. When an instruction loads a segment selector into one of segment registers <b>24</b>, MMU <b>20</b> reads the corresponding segment descriptor from the selected segment descriptor table and stores information from the segment descriptor into the segment descriptor field (e.g. segment descriptor field <b>24</b>AB for segment register <b>24</b>A). The information stored in the segment descriptor field may comprise any suitable subset of the segment descriptor, including all of the segment descriptor, if desired. Additionally, other information derived from the segment descriptor or other sources may be stored in the segment descriptor field, if desired. For example, an embodiment may decode the operating mode indications from the code segment descriptor and store the decoded value rather than the original values of the operating mode indications. If an instruction causes CS to be loaded with a segment selector, the code segment may change and thus the operating mode of processor <b>10</b> may change. Segment descriptor tables are described in more detail below.</p><p>In one embodiment, only the CS segment register is used in 32/64 mode. The data segment registers are ignored. In 16 and 32 bit modes, the code segment and data segments may be active. Furthermore, a second enable indication (PE) in control register <b>28</b> may affect the operation of MMU <b>20</b>. The PE enable indication may be used to enable protected mode, in which segmentation and/or paging address translation mechanisms may be used. If the PE enable indication is in the disabled state, segmentation and paging mechanisms are disabled and processor <b>10</b> is in \u201creal mode\u201d (in which addresses generated by execution core <b>14</b> are physical addresses). Similar to the LME indication, the PE indication may be a bit in which the enabled state is the bit being set and the disabled state is the bit being clear. However, other embodiments are contemplated as described above.</p><p>It is noted that MMU <b>20</b> may employ additional hardware mechanisms, as desired. For example, MMU <b>20</b> may include paging hardware to implement paging address translation from virtual addresses to physical addresses. The paging hardware may include a translation lookaside buffer (TLB) to store page translations.</p><p>It is noted that control registers <b>26</b> and <b>28</b> may be implemented as architected control registers (e.g. control register <b>26</b> may be CR<b>4</b> and control register <b>28</b> may be CR<b>0</b>). Alternatively, one or both of the control registers may be implemented as model specific registers to allow for other uses of the architected control registers without interfering with 32/64 mode.</p><p>Generally, instruction cache <b>12</b> is a high speed cache memory for storing instruction bytes. Execution core <b>14</b> fetches instructions from instruction cache <b>12</b> for execution. Instruction cache <b>12</b> may employ any suitable cache organization, including direct-mapped, set associative, and fully associative configurations. If an instruction fetch misses in instruction cache <b>12</b>, instruction cache <b>12</b> may communicate with external interface unit <b>18</b> to fill the missing cache line into instruction cache <b>12</b>. Additionally, instruction cache <b>12</b> may communicate with MMU <b>20</b> to receive physical address translations for virtual addresses fetched from instruction cache <b>12</b>.</p><p>Execution core <b>14</b> executes the instructions fetched from instruction cache <b>12</b>. Execution core <b>14</b> fetches register operands from register file <b>22</b> and updates destination operand registers in register file <b>22</b>. The size of the register operands is controlled by the operating mode and any overrides of the operating mode for a particular instruction. Viewed in another way, execution core <b>14</b> operates upon operands of the operand size for that instruction (e.g. reading, updating, etc.). Similarly, execution core <b>14</b> fetches memory operands from data cache <b>16</b> and updates destination memory locations in data cache <b>16</b>, subject to the cacheability of the memory operands and hitting in data cache <b>16</b>. The size of the memory operands is similarly controlled by the operating mode and any overrides of the operating mode for a particular instruction. Furthermore, the size of the addresses of the memory operands generated by execution core <b>14</b> is controlled by the operating mode and any overrides of the operating mode for a particular instruction.</p><p>Execution core <b>14</b> may employ any suitable construction. For example, execution core <b>14</b> may be a superpipelined core, a superscalar core, or a combination thereof. Execution core <b>14</b> may employ out of order speculative execution or in order execution, according to design choice.</p><p>Register file <b>22</b> may include 64 bit registers which may be accessed as 64 bit, 32 bit, 16 bit, or 8 bit registers as indicated by the operating mode of processor <b>10</b> and any overrides for a particular instruction. The register format for one embodiment is described below with respect to FIG. <b>7</b>. The registers included in register file <b>22</b> may include the LEAX, LEBX, LECX, LEDX, LEDI, LESI, LESP, and LEBP registers. Register file <b>22</b> may further include the LEIP register. Alternatively, execution core <b>14</b> may employ a form of register renaming in which any register within register file <b>22</b> may be mapped to an architected register. The number of registers in register file <b>22</b> may be implementation dependent for such an embodiment.</p><p>Data cache <b>16</b> is a high speed cache memory configured to store data. Data cache <b>16</b> may employ any suitable cache organization, including direct-mapped, set associative, and fully associative configurations. If a data fetch or update misses in data cache <b>16</b>, data cache <b>16</b> may communicate with external interface unit <b>18</b> to fill the missing cache line into data cache <b>16</b>. Additionally, if data cache <b>16</b> employs a writeback caching policy, updated cache lines which are being cast out of data cache <b>16</b> may be communicated to external interface unit <b>18</b> to be written back to memory. Data cache <b>16</b> may communicate with MMU <b>20</b> to receive physical address translations for virtual addresses presented to data cache <b>16</b>.</p><p>External interface unit <b>18</b> communicates with portions of the system external to processor <b>10</b>. External interface unit <b>18</b> may communicate cache lines for instruction cache <b>12</b> and data cache <b>16</b> as described above, and may communicate with MMU <b>20</b> as well. For example, external interface unit <b>18</b> may access the segment descriptor tables and/or paging tables on behalf of MMU <b>20</b>.</p><p>It is noted that processor <b>10</b> may include an integrated level 2 (L2) cache, if desired. Furthermore, external interface unit <b>18</b> may be configured to communicate with a backside cache in addition to communicating with the system.</p><p>Turning now to FIG. 2, a block diagram of one embodiment of a code segment descriptor <b>40</b> for 32/64 mode is shown. Other embodiments are possible and contemplated. In the embodiment of FIG. 2, code segment descriptor <b>40</b> comprises <b>8</b> bytes with the most significant 4 bytes illustrated above the least significant 4 bytes. The most significant four bytes are stored at a numerically larger address than the least significant four bytes. The most significant bit of each group of four bytes is illustrated as bit <b>31</b> in FIG. 2 (and FIG. 3 below), and the least significant bit is illustrated as bit <b>0</b>. Short vertical lines within the four bytes delimit each bit, and the long vertical lines delimit a bit but also delimit a field (both in FIG. <b>2</b> and in FIG. <b>3</b>).</p><p>Unlike the 32 bit and 16 bit code segment descriptors illustrated in FIG. 3 below, code segment descriptor <b>40</b> does not include a base address or limit. Processor <b>10</b> employs a flat virtual address space for 32/64 mode (rather than the segmented linear address space employed in 32/64 mode). Accordingly, the portions of code segment descriptor <b>40</b> which would otherwise store the base address and limit are reserved in segment descriptor <b>40</b>. It is noted that a virtual address provided through segmentation may also be referred to herein as a \u201clinear address\u201d. The term \u201cvirtual address\u201d encompasses any address which is translated through a translation mechanism to a physical address actually used to address memory, including linear addresses and other virtual addresses generated in non-segmented architectures.</p><p>Segment descriptor <b>40</b> includes a D bit <b>42</b>, an L bit <b>44</b> (set to one for a 32/64 mode code segment), an available bit (AVL) <b>46</b>, a present (P) bit <b>48</b>, a descriptor privilege level (DPL) <b>50</b>, and a type field <b>52</b>. D bit <b>42</b> and L bit <b>44</b> are used to determine the operating mode of processor <b>10</b>, as illustrated in FIG. 5 below. AVL bit <b>46</b> is available for use by system software (e.g. the operating system). P bit <b>48</b> is used to indicate whether or not the segment is present in memory. If P bit <b>48</b> is set, the segment is present and code may be fetched from the segment. If P bit <b>48</b> is clear, the segment is not present and an exception is generated to load the segment into memory (e.g. from disk storage or through a network connection). The DPL indicates the privilege level of the segment. Processor <b>10</b> employs four privilege levels (encoded as 0 through 3 in the DPL field, with level 0 being the most privileged level). Certain instructions and processor resources (e.g. configuration and control registers) are only executable or accessible at the more privileged levels, and attempts to execute these instructions or access these resources at the lower privilege levels result in an exception. When information from code segment <b>40</b> is loaded into the CS segment register, the DPL becomes the current privilege level (CPL) of processor <b>10</b>. Type field <b>52</b> encodes the type of segment. For code segments, the most significant bit two bits of type field <b>52</b> may be set (the most significant bit distinguishing a code or data segment from a system segment, and the second most significant bit distinguishing a code segment from a data segment), and the remaining bits may encode additional segment type information (e.g. execute only, execute and read, or execute and read only, conforming, and whether or not the code segment has been accessed).</p><p>It is noted that, while several indications in the code segment descriptor are described as bits, with set and clear values having defined meanings, other embodiments may employ the opposite encodings and may use multiple bits, as desired. Thus, for example, the D bit <b>42</b> and the L bit <b>44</b> may each be an example of an operating mode indication which may be one or more bits as desired, similar to the discussion of enable indications above.</p><p>Turning now to FIG. 3, a block diagram of one embodiment of a code segment descriptor <b>54</b> for 32 and 16 bit compatibility mode is shown. Other embodiments are possible and contemplated. As with the embodiment of FIG. 2, code segment descriptor <b>54</b> comprises 8 bytes with the most significant 4 bytes illustrated above the least significant 4 bytes.</p><p>Code segment descriptor <b>54</b> includes D bit <b>42</b>, L bit <b>44</b>, AVL bit <b>46</b>, P bit <b>48</b>, DPL <b>50</b>, and type field <b>52</b> similar to the above description of code segment descriptor <b>40</b>. Additionally, code segment descriptor <b>54</b> includes a base address field (reference numerals <b>56</b>A, <b>56</b>B, and <b>56</b>C), a limit field (reference numerals <b>57</b>A and <b>57</b>B) and a G bit <b>58</b>. The base address field stores a base address which is added to the logical fetch address (stored in the LEIP register) to form the linear address of an instruction, which may then optionally be translated to a physical address through a paging translation mechanism. The limit field stores a segment limit which defines the size of the segment. Attempts to access a byte at an address greater than the sum of the base address and the segment limit are disallowed and cause an exception. G bit <b>58</b> determines the scaling of the segment limit field. If G bit <b>58</b> is set the limit is scaled to 4K byte pages (e.g. 12 least significant zeros are appended to the limit in the limit field). If G bit <b>58</b> is clear, the limit is used as is.</p><p>It is noted that code segment descriptors for 32 and 16 bit modes when 32/64 mode is not enabled via the LME bit in control register <b>26</b> may be similar to code segment descriptor <b>54</b>, except the L bit is reserved and defined to be zero. It is further noted that, in 32 and 16 bit modes (both compatibility mode with the LME bit set and modes with the LME bit clear) according to one embodiment, data segments are used as well. Data segment descriptors may be similar to code segment descriptor <b>54</b>, except that the D bit <b>42</b> is defined to indicate the upper bound of the segment or to define the default stack size (for stack segments).</p><p>Turning next to FIG. 4, a diagram illustrating exemplary uses of the LME bit in control register <b>26</b> and the compatibility modes to allow for a high degree of flexibility in implementing the 32/64 mode and the 32 and 16 bit modes is shown. A box <b>60</b> illustrates exemplary operation when the LME bit is set, and a box <b>62</b> illustrates exemplary operation when the LME bit is clear.</p><p>As illustrated in box <b>60</b>, the compatibility modes supported when the LME bit is set may allow for a 64 bit operating system (i.e. an operating system designed to take advantage of the virtual and physical address spaces in excess of 32 bits and/or data operands of 64 bits) to operate with a 32 bit application program (i.e. an application program written using 32 bit operand and address sizes). The code segment for the operating system may be defined by the 32/64 mode code segment descriptor <b>40</b> illustrated in FIG. 2, and thus the L bit may be set. Accordingly, the operating system may take advantage of the expanded virtual address space and physical address space for the operating system code and the data structures maintained by the operating system (including, e.g. the segment descriptor tables and the paging translation tables). The operating system may also use the 64 bit data type defined in 32/64 mode using instruction encodings which override the default 32 bit operand size. Furthermore, the operating system may launch a 32 bit application program by establishing one or more 32 bit compatibility mode segment descriptors (L bit cleared, D bit set, e.g. segment descriptor <b>54</b> shown in FIG. 2) in the segment descriptor table and branching into one of the compatibility mode segments. Similarly, the operating system may launch a 16 bit application program by establishing one or more 16 bit compatibility mode segment descriptors (L bit cleared, D bit cleared, e.g. segment descriptor <b>54</b> shown in FIG. 2) in the segment descriptor table and branching into one of the compatibility mode segments. Accordingly, a 64 bit operating system may retain the ability to execute existing 32 bit and 16 bit application programs in the compatibility mode. A particular application program may be ported to 32/64 mode if the expanded capabilities are desired for that program, or may remain 32 bit or 16 bit.</p><p>While processor <b>10</b> is executing the 32 bit application program, the operating mode of processor <b>10</b> is 32 bit. Thus, the application program may generally execute in the same fashion as it does in 32 bit mode with the LME bit clear (e.g. when the operating system is a 32 bit operating system as well). However, the application program may call an operating system service, experience an exception, or terminate. In each of these cases, processor <b>10</b> may return to executing operating system code (as illustrated by arrow <b>64</b> in FIG. <b>4</b>). Since the operating system code operates in 32/64 mode, the address of the operating system service routine, exception handler, etc. may exceed 32 bits. Thus, processor <b>10</b> may need to generate an address greater than 32 bits prior to returning to the operating system code. The LME bit provides processor <b>10</b> with an indication that the operating system may be operating in 32/64 mode even though the current operating mode is 32 bit, and thus processor <b>10</b> may provide the larger address space for operating system calls and exceptions.</p><p>In one embodiment, exceptions are handled using interrupt segment descriptors stored in an interrupt segment descriptor table. If the LME bit is set, the interrupt segment descriptors may be 16 byte entries which include a 64 bit address of the operating system routine which handles the exception. If the LME bit is clear, the interrupt segment descriptors may be eight byte entries which include a 32 bit address. Accordingly, processor <b>10</b> accesses the interrupt descriptor table responsive to the LME indication (i.e. reading a 16 byte entry if the LME bit is set and reading an eight byte entry if the LME bit is clear). Therefore, exceptions may be handled by the 64 bit operating system even though the application program is executing in 32 bit compatibility mode. Furthermore, processor <b>10</b> supports a 32 bit (or 16 bit) operating system if the LME bit is clear.</p><p>Similarly, the call mechanisms within processor <b>10</b> may operate in different fashions based on the state of the LME bit. Since the operating system typically executes at a higher privilege level than the application program, transfers from the application program to the operating system are carefully controlled to ensure that the application program is only able to execute permitted operating system routines. More generally, changes in privilege level are carefully controlled. In one embodiment, processor <b>10</b> may support at least two mechanisms for performing operating system calls. One method may be through a call gate in the segment descriptor tables (described in more detail below). Another method may be the SYSCALL instruction supported by processor <b>10</b>, which uses a model specific register as the source of the address of the operating system routine. Updating the model specific registers is a privileged operation, and thus only code executing at a higher privilege level (e.g. operating system code) may establish the address in the model specific register used by the SYSCALL instruction. For the SYSCALL method, a second model specific register may be defined to store the most significant 32 bits of the address of the operating system routine. Thus, if the LME bit is set, the address may be read from the two model specific registers. If the LME bit is clear, the address may be read from the model specific register storing the least significant 32 bits. Alternatively, the model specific register used by the SYSCALL instruction may be expanded to 64 bits and the address may be 32 bits (the least significant 32 bits of the model specific register) or 64 bits based on the state of the LME bit.</p><p>As illustrated above, having the LME bit set may allow for processor <b>10</b> to operate in a system in which the operating system is 64 bit and one or more application programs are not 64 bit (e.g. 32 bit as shown or 16 bit, which operates in a similar fashion to the above description). Additionally, as illustrated by box <b>62</b>, having the LME bit clear may allow for processor <b>10</b> to operate in 32 bit or 16 bit modes compatible with the x86 architecture. As described above, the mechanisms for handling exceptions and operating system calls are designed to handle the LME bit being set or clear, and thus the 32 bit and 16 bit modes may operate unmodified, even though processor <b>10</b> is capable of operating in 32/64 mode. Furthermore, by providing the x86 compatible 16 and 32 bit modes when the LME bit is clear, (and ignoring the L bit, which is reserved in these modes) processor <b>10</b> may operate in a system in which the L bit is defined for some other purpose than for 32/64 mode and may still support 32/64 mode if the LME bit is set. Accordingly, a system employing a 32 bit operating system and 32 bit or 16 bit application programs may employ processor <b>10</b>. Subsequently, the system could be upgraded to a 64 bit operating system without having to change processor <b>10</b>.</p><p>Not illustrated in FIG. 4 is a 64 bit operating system and a 64 bit application program operating with the LME bit set. The mechanisms for calling operating system routines described above for the 64 bit operating system and 32 bit application program may apply equally to the 64 bit application program as well. Additionally, call gates which support 64 bits of offset are supported (as will be described in more detail below).</p><p>Turning next to FIG. 5, a table <b>70</b> is shown illustrating the states of the LME bit, the L bit in the code segment descriptor, and the D bit in the code segment descriptor and the corresponding operating mode of processor <b>10</b> according to one embodiment of processor <b>10</b>. Other embodiments are possible and contemplated. As table <b>70</b> illustrates, if the LME bit is clear, then the L bit is reserved (and defined to be zero). However, processor <b>10</b> may treat the L bit as a don't care if the LME bit is clear. Thus, the x86 compatible 16 bit and 32 bit modes may be provided by processor <b>10</b> if the LME bit is clear. If the LME bit is set and the L bit in the code segment is clear, then a compatibility operating mode is established by processor <b>10</b> and the D bit selects 16 bit or 32 bit mode. If the LME bit and the L bit are set and the D bit is clear, 32/64 mode is selected for processor <b>10</b>. Finally, the mode which would be selected if the LME, L and D bits are all set is reserved.</p><p>As mentioned above and illustrated in FIG. 6 below, the 32/64 operating mode includes a default address size in excess of 32 bits (implementation dependent but up to 64 bits) and a default operand size of 32 bits. The default operand size of 32 bits may be overridden to 64 bits via a particular instruction's encoding. The default operand size of 32 bits is selected to minimize average instruction length (since overriding to 64 bits involves including an instruction prefix in the instruction encoding which may increase the instruction length) for programs in which 32 bits are sufficient for many of the data manipulations performed by the program. For such programs (which may be a substantial number of the programs currently in existence), moving to a 64 bit operand size may actually reduce the execution performance achieved by the program (i.e. increased execution time). In part, this reduction may be attributable to the doubling in size in memory of the data structures used by the program when 64 bit values are stored. If 32 bits is sufficient, these data structures would store 32 bit values, Thus, the number of bytes accessed when the data structure is accessed increases if 64 bit values are used where 32 bit values would be sufficient, and the increased memory bandwidth (and increased cache space occupied by each value) may cause increased execution time. Accordingly, 32 bits is selected as the default operand size and the default may be overridden via the encoding of a particular instruction.</p><p>Turning next to FIG. 6, a table <b>72</b> is shown illustrating one embodiment of the use of instruction prefixes to override the operating mode for a particular instruction. Other embodiments are possible and contemplated. Execution core <b>14</b> determines the address size and operand size for a particular instruction according to table <b>72</b>. In particular for the embodiment illustrated in FIG. 6, an instruction prefix byte (the address size override prefix byte) may be used to override the default address size and another instruction prefix byte (the operand size override prefix byte) may be used to override the default operand size. The address size override prefix byte is encoded as <b>67</b> (in hexadecimal) and the operand size override prefix byte is encoded as <b>66</b> (in hexadecimal). The number of override prefixes in the particular instruction forms the columns of the table. The rows of the table indicate the operand size and address size of the particular instruction, based on the operating mode and the number of override prefixes in the corresponding column. The number of override prefixes refers to the number of override prefixes of the corresponding type (e.g. address size rows are the address size based on the number of address size override prefixes and operand size rows are the operand size based on the number of operand size override prefixes).</p><p>The column labeled \u201c0\u201d for the number of override prefixes illustrates the default operand size and address size for each operating mode. It is noted that the 32 bit and 16 bit mode rows refer to both the compatibility modes (LME set) and the standard modes (LME clear). Furthermore, while the default address size is 64 bits in 32/64 mode, the actual number of address bits may be implementation dependent, as discussed above.</p><p>The inclusion of one address size override prefix in 32/64 bit mode changes the address size from 64 bit (which may be less than 64 bits for a given implementation but is greater than 32 bits) to 32 bit, as shown in table <b>72</b>. Additionally, the inclusion of one operand size override prefix in 32/64 bit mode changes the operand size from 32 bit to 64 bit. It may be desirable to provide for a 16 bit operand as well (e.g. to support the short integer data type in the \u201cC\u201d programming language). Accordingly, the inclusion of two operand size override prefixes in 32/64 mode selects an operand size of 16 bits. The inclusion of more than two operand size override prefixes results in the same operand size as the inclusion of two operand size override prefixes. In other words, execution core <b>14</b> may ignore the operand size override prefixes in excess of two. Similarly, the inclusion of more than one address size override prefix results in the same address size as the inclusion of one address size override prefix. In other words, execution core <b>14</b> may ignore the address size override prefixes in excess of one.</p><p>For the 32 bit modes, the inclusion of one override prefix toggles the default 32 bit size to 16 bit, and the inclusion of more than one override prefix has the same effect as the inclusion of one override prefix. Similarly, for 16 bit modes, the inclusion of one override prefix toggles the default 16 bit size to 32 bit, and the inclusion of more than one override prefix has the same effect as the inclusion of one override prefix.</p><p>Turning now to FIG. 7, a diagram illustrating one embodiment of the LEAX register <b>74</b> is shown. Other registers within register file <b>22</b> may be similar. Other embodiments are possible and contemplated. In the embodiment of FIG. 7, register <b>74</b> includes 64 bits, with the most significant bit labeled as bit <b>63</b> and the least significant bit labeled as bit <b>0</b>. FIG. 7 illustrates the portions of the LEAX register accessed based upon the operand size of an instruction (if the A register is selected as an operand). More particularly, the entirety of register <b>74</b> is accessed if the operand size is 64 bits (as illustrated by the brace labeled \u201cLEAX\u201d in FIG. <b>7</b>). If the operand size is 32 bits, bits <b>31</b>:<b>0</b> of register <b>74</b> are accessed (as illustrated by the brace labeled \u201cEAX\u201d in FIG. <b>7</b>). If the operand size is 16 bits, bits <b>16</b>:<b>0</b> of the register are accessed (as illustrated by the brace labeled \u201cAX\u201d in FIG. <b>7</b>). The above operand sizes may be selected based on the operating mode and the inclusion of any override prefixes. However, certain instruction opcodes are defined which access an eight bit register (AH or AL in FIG. <b>7</b>).</p><p>Turning next to FIG. 8, a block diagram is shown illustrating one embodiment of a global descriptor table <b>80</b> and a local descriptor table <b>82</b>. Other embodiments are possible and contemplated. As illustrated in FIG. <b>8</b> and mentioned above, the base address of global descriptor table <b>80</b> is provided by GDTR <b>32</b> and the base address of local descriptor table <b>82</b> is provided by LDTR <b>30</b>. Accordingly, to support placing global descriptor table <b>80</b> and local descriptor table <b>82</b> arbitrarily within the virtual address space, GDTR <b>32</b> and LDTR <b>30</b> may store 64 bit base addresses. If the LME bit is clear, the least significant 32 bits of the base address may be used to locate the descriptor tables.</p><p>Both global descriptor table <b>80</b> and local descriptor table <b>82</b> are configured to store segment descriptors of various types. For example, 32/64 mode code segment descriptors <b>84</b>, <b>86</b>, and <b>90</b> and compatibility mode descriptors <b>92</b> and <b>94</b> are illustrated in FIG. <b>8</b>. Each of descriptors <b>84</b>-<b>94</b> occupies an entry in the corresponding descriptor table, where an entry is capable of storing one segment descriptor (e.g. 8 bytes for the embodiments illustrated in FIGS. <b>2</b> and <b>3</b>). Another type of descriptor in global descriptor table <b>80</b> is a local descriptor table descriptor <b>96</b>, which defines a system segment for the local descriptor table <b>82</b> and provides the base address stored in LDTR <b>30</b>. LDTR <b>30</b> is initialized using an LLDT instruction having as an operand a segment selector locating descriptor <b>96</b> in global descriptor table <b>80</b>. Global descriptor table <b>80</b> may store multiple LDT descriptors locating different local descriptor tables, if desired. Since the LDT descriptor <b>96</b> may store a 64 bit offset if the LME bit is set, LDT descriptor <b>96</b> may occupy two entries in global descriptor table <b>80</b>. If the LME bit is clear, LDT descriptor <b>96</b> may occupy a single entry in global descriptor table <b>80</b>. Similarly, each task may have a task state segment (TSS) descriptor in one of descriptor tables <b>80</b> and <b>82</b> to store certain information related to the task. Accordingly, a TSS descriptor may occupy two entries to allow for TSS information to be stored anywhere in the 64 bit address space.</p><p>The local and global descriptor tables may also store a call gate descriptor. For example, FIG. 8 illustrates call gate descriptors <b>100</b>, <b>102</b>, and <b>104</b>. Call gate descriptors support a 64 bit offset as well, and thus may occupy two entries in the corresponding descriptor table as well. An exemplary 32/64 call gate descriptor is illustrated in FIG. 9 below.</p><p>By maintaining the segment descriptor tables <b>80</b> and <b>82</b> at 8 bytes and using two entries for descriptors which include 64 bit offsets, descriptors for 16 and 32 bit modes may be stored in the same tables as the descriptors which include 64 bit offsets. Thus, applications operating in compatibility modes may have appropriate descriptors in the same segment descriptor tables as the 64 bit operating systems.</p><p>Generally, call gates are used to manage the transition between a code segment having a lesser privilege level and a code segment have a greater privilege level (e.g. an application program calling an operating system routine). The lesser privileged code includes a call or other branch instruction specifying, as a target, a segment selector (and an offset into the segment, which is ignored in this case). The segment selector identifies a call gate descriptor within the descriptor tables, which includes a minimum privilege level required to execute the greater privilege level code. When processor <b>10</b> executes the call or other branch instruction, processor <b>10</b> indexes the descriptor tables with the segment selector and locates the call gate. If the current privilege level of processor <b>10</b> and the requester privilege level (which is part of the segment selector, and may be used to lower the current privilege level for privilege checking purposes) both reflect sufficient privilege (e.g. the privilege levels are numerically less than or equal to the minimum privilege level in the call gate descriptor), then the call may proceed. The call gate descriptor includes a segment selector for the target segment (the code segment having the greater privilege level) and the offset within the target segment at which code fetching is to begin. Processor <b>10</b> extracts the segment selector and the offset from the call gate descriptor and reads the target segment descriptor to begin fetching the code having the greater privilege level. On the other hand, if either the current privilege level or the requester privilege level is a lesser privilege level than the minimum privilege level in the call gate descriptor (e.g. either the current or requestor privilege level is numerically greater than the minimum privilege level), processor <b>10</b> signals an exception after accessing the call gate descriptor and without accessing the target descriptor. Thus, access to code executing at greater privilege levels is carefully controlled.</p><p>As mentioned above, the call gate descriptor includes a target segment selector and offset within the segment. The reference to the target segment descriptor is illustrated in FIG. 8 as an arrow from a call gate descriptor to another descriptor. For example, call gate descriptor <b>100</b> references mode descriptor <b>90</b>; call gate descriptor <b>102</b> references 32/64 mode descriptor <b>86</b>, and call gate descriptor <b>104</b> references 32/64 mode descriptor <b>84</b>. As FIG. 8 illustrates, a call gate descriptor may be stored in either descriptor table and may reference a descriptor in the other table or in the same table. Furthermore, a call gate descriptor may reference either a 32/64 mode descriptor or a compatibility mode descriptor.</p><p>Generally, when processor <b>10</b> reads a descriptor from one of the descriptor tables using a segment selector, one descriptor table entry is read. However, if the LME bit is set and processor <b>10</b> detects that the entry is a call gate descriptor, an LDT descriptor, or a TSS descriptor, processor <b>10</b> reads the next succeeding entry in the table to obtain the remainder of the descriptor. Accordingly, call gate descriptors, LDT descriptors, and TSS descriptors may coexist in a table with compatibility mode descriptors (or standard mode descriptors) which are of a different size, without redefining the size of the table entries nor how the table is managed for descriptors which occupy one entry. Furthermore, since the second portion of the call gate descriptor, the LDT descriptor, and the TSS descriptor may be accessed as a segment descriptor, the portion of the descriptor which would be the type field of a descriptor in the second portion is set to an invalid type when the descriptor is stored into the descriptor table, as shown below in FIG. <b>9</b>. Alternatively, processor <b>10</b> may read two consecutive entries from a descriptor table each time a descriptor table read is performed, and the second entry may be used if the first entry is a call gate, LDT descriptor type, or TSS descriptor type.</p><p>It is noted that code operating in any operating mode (32/64 mode, 32 bit compatibility mode, or 16 bit compatibility mode) may reference a call gate descriptor when the LME bit is set. Thus, a 32 or 16 bit application may call an operating system routine even if the address of the routine is outside the 32 bit or 16 bit address space using the call gate mechanism. Additionally, a call gate descriptor may reference a code segment having any operating mode. The operating system may ensure that the most significant 32 bits of the offset in the call gate are zero (for a 32 bit target segment) or the most significant 48 bits of the offset in the call gate are zero (for a 16 bit target segment).</p><p>Turning now to FIG. 9, a block diagram of one embodiment of a call gate descriptor <b>120</b> is shown. Other embodiments are possible and contemplated. Similar to FIGS. 2 and 3, the most significant bytes are illustrated above the least significant bytes. The most significant bit of each group of four bytes is illustrated as bit <b>31</b> and the least significant bit is illustrated as bit <b>0</b>. Short vertical lines within the four bytes delimit each bit, and the long vertical lines delimit a bit but also delimit a field. As mentioned above, a call gate descriptor occupies two entries in a descriptor table. The horizontal dashed line in FIG. 9 divides call gate descriptor <b>120</b> into an upper portion (above the line) and a lower portion (below the line). The lower portion is stored in the entry indexed by the call gate's segment selector, and the upper portion is stored in the next succeeding entry.</p><p>Call gate descriptor <b>120</b> includes a target segment selector (field <b>122</b>), an offset (fields <b>124</b>A, <b>124</b>B, and <b>124</b>C), a present (P) bit <b>126</b>, a descriptor privilege level (DPL) <b>128</b>, a type field <b>130</b>, and a pseudo-type field <b>132</b>. The P bit is similar to P bit <b>48</b> described above. The target segment selector identifies an entry within one of the descriptor tables at which the target segment descriptor (having the greater privilege level) is stored. The offset identifies the address at which code fetching is to begin. In 32/64 mode, since the code segment has no base address and flat linear addressing is used, the offset is the address at which code fetching begins. In other modes, the offset is added to the segment base defined by the target segment descriptor to generate the address at which code fetching begins. As mentioned above, the offset may comprise 64 bits in the present embodiment.</p><p>DPL <b>128</b> stores the minimum privilege level of the calling routine must have (both in the current privilege level and the requested privilege level) which may successfully pass through the call gate and execute the called routine at the privilege level specified in the target segment descriptor.</p><p>Type field <b>130</b> is coded to a call gate descriptor type. In one embodiment, this type is coded as the 32 bit call gate type defined in the x86 architecture. Alternatively, other encodings may be used. Finally, pseudo-type field <b>132</b> is coded to an invalid type (e.g. zero) to ensure that if a segment selector identifying the segment table entry storing the upper half of call gate descriptor <b>120</b> is presented, then an exception will be signalled by processor <b>10</b>.</p><p>It is noted that: the lower half of LDT descriptor <b>96</b> may be similar to the 32 bit LDT descriptor and the upper half of LDT descriptor <b>96</b> may be similar to the upper half of call gate descriptor <b>120</b>.</p><p>Turning next to FIG. 10, a block diagram of an instruction format <b>140</b> for instructions executed by processor <b>10</b> is shown. Other embodiments are possible and contemplated. In the embodiment of FIG. 10, instruction format <b>140</b> includes a prefix field <b>142</b>, an opcode field <b>144</b>, a mod RIM (register/memory) field <b>146</b>, an SIB (scale index base) field <b>148</b>, a displacement field <b>150</b>, and an immediate field <b>152</b>. Each of the fields except for the opcode field <b>144</b> are optional. Thus, instruction format <b>140</b> may define a variable length instruction.</p><p>Prefix field <b>142</b> is used for any instruction prefixes for the instruction. As described above, an operand size override prefix and an address size override prefix may be encoded into an instruction to override the operating mode of processor <b>10</b>. These override prefixes are included in prefix field <b>142</b>. As noted above, the operand size override prefix and address size override prefix may each by bytes included within prefix field <b>142</b>.</p><p>Opcode field <b>144</b> includes the opcode of the instruction (i.e. which instruction in the instruction set is being executed). For some instructions, operands may be specified within opcode field <b>144</b>. For other instructions, a portion of the opcode may be included within mod R/M field <b>146</b>. Furthermore, certain opcodes specify an eight bit or 16 bit register as an operand. Thus opcode encodings may serve to override the defaults indicated by the operating mode of processor <b>10</b> as well.</p><p>Mod R/M field <b>146</b> and SIB field <b>148</b> indicate operands of the instruction. Displacement field <b>150</b> includes any displacement information, and immediate field <b>152</b> includes an immediate operand.</p><p>Computer Systems</p><p>Turning now to FIG. 11, a block diagram of one embodiment of a computer system <b>200</b> including processor <b>10</b> coupled to a variety of system components through a bus bridge <b>202</b> is shown. Other embodiments are possible and contemplated. In the depicted system, a main memory <b>204</b> is coupled to bus bridge <b>202</b> through a memory bus <b>206</b>, and a graphics controller <b>208</b> is coupled to bus bridge <b>202</b> through an AGP bus <b>210</b>. Finally, a plurality of PCI devices <b>212</b>A-<b>212</b>B are coupled to bus bridge <b>202</b> through a PCI bus <b>214</b>. A secondary bus bridge <b>216</b> may further be provided to accommodate an electrical interface to one or more EISA or ISA devices <b>218</b> through an EISA/ISA bus <b>220</b>. Processor <b>10</b> is coupled to bus bridge <b>202</b> through a CPU bus <b>224</b> and to an optional L2 cache <b>228</b>. Together, CPU bus <b>224</b> and the interface to L2 cache <b>228</b> may comprise an external interface to which external interface unit <b>18</b> may couple.</p><p>Bus bridge <b>202</b> provides an interface between processor <b>10</b>, main memory <b>204</b>, graphics controller <b>208</b>, and devices attached to PCI bus <b>214</b>. When an operation is received from one of the devices connected to bus bridge <b>202</b>, bus bridge <b>202</b> identifies the target of the operation (e.g. a particular device or, in the case of PCI bus <b>214</b>, that the target is on PCI bus <b>214</b>). Bus bridge <b>202</b> routes the operation to the targeted device. Bus bridge <b>202</b> generally translates an operation from the protocol used by the source device or bus to the protocol used by the target device or bus.</p><p>In addition to providing an interface to an ISA/EISA bus for PCI bus <b>214</b>, secondary bus bridge <b>216</b> may further incorporate additional functionality, as desired. An input/output controller (not shown), either external from or integrated with secondary bus bridge <b>216</b>, may also be included within computer system <b>200</b> to provide operational support for a keyboard and mouse <b>222</b> and for various serial and parallel ports, as desired. An external cache unit (not shown) may further be coupled to CPU bus <b>224</b> between processor <b>10</b> and bus bridge <b>202</b> in other embodiments. Alternatively, the external cache may be coupled to bus bridge <b>202</b> and cache control logic for the external cache may be integrated into bus bridge <b>202</b>. L2 cache <b>228</b> is further shown in a backside configuration to processor <b>10</b>. It is noted that L2 cache <b>228</b> may be separate from processor <b>10</b>, integrated into a cartridge (e.g. slot <b>1</b> or slot A) with processor <b>10</b>, or even integrated onto a semiconductor substrate with processor <b>10</b>.</p><p>Main memory <b>204</b> is a memory in which application programs are stored and from which processor <b>10</b> primarily executes. A suitable main memory <b>204</b> comprises DRAM (Dynamic Random Access Memory). For example, a plurality of banks of SDRAM (Synchronous DRAM) or Ram bus DRAM (RDRAM) may be suitable.</p><p>PCI devices <b>212</b>A-<b>212</b>B are illustrative of a variety of peripheral devices such as, for example, network interface cards, video accelerators, audio cards, hard or floppy disk drives or drive controllers, SCSI (Small Computer Systems Interface) adapters and telephony cards. Similarly, ISA device <b>218</b> is illustrative of various types of peripheral devices, such as a modem, a sound card, and a variety of data acquisition cards such as GPIB or field bus interface cards.</p><p>Graphics controller <b>208</b> is provided to control the rendering of text and images on a display <b>226</b>. Graphics controller <b>208</b> may embody a typical graphics accelerator generally known in the art to render three-dimensional data structures which can be effectively shifted into and from main memory <b>204</b>. Graphics controller <b>208</b> may therefore be a master of AGP bus <b>210</b> in that it can request and receive access to a target interface within bus bridge <b>202</b> to thereby obtain access to main memory <b>204</b>. A dedicated graphics bus accommodates rapid retrieval of data from main memory <b>204</b>. For certain operations, graphics controller <b>208</b> may further be configured to generate PCI protocol transactions on AGP bus <b>210</b>. The AGP interface of bus bridge <b>202</b> may thus include functionality to support both AGP protocol transactions as well as PCI protocol target and initiator transactions. Display <b>226</b> is any electronic display upon which an image or text can be presented. A suitable display <b>226</b> includes a cathode ray tube (\u201cCRT\u201d), a liquid crystal display (\u201cLCD\u201d), etc.</p><p>It is noted that, while the AGP, PCI, and ISA or EISA buses have been used as examples in the above. description, any bus architectures may be substituted as desired. It is further noted that computer system <b>200</b> may be a multiprocessing computer system including additional processors (e.g. processor <b>10</b><i>a </i>shown as an optional component of computer system <b>200</b>). Processor <b>10</b><i>a </i>may be similar to processor <b>10</b>. More particularly, processor <b>10</b><i>a </i>may be an identical copy of processor <b>10</b>. Processor <b>10</b><i>a </i>may be connected to bus bridge <b>202</b> via an independent bus (as shown in FIG. 11) or may share CPU bus <b>224</b> with processor <b>10</b>. Furthermore, processor <b>10</b><i>a </i>may be coupled to an optional L2 cache <b>228</b><i>a </i>similar to L2 cache <b>228</b>.</p><p>Turning now to FIG. 12, another embodiment of a computer system <b>300</b> is shown. Other embodiments are possible and contemplated. In the embodiment of FIG. 12, computer system <b>300</b> includes several processing nodes <b>312</b>A, <b>312</b>B, <b>312</b>C, and <b>312</b>D. Each processing node is coupled to a respective memory <b>314</b>A-<b>314</b>D via a memory controller <b>316</b>A-<b>316</b>D included within each respective processing node <b>312</b>A-<b>312</b>D. Additionally, processing nodes <b>312</b>A-<b>312</b>D include interface logic used to communicate between the processing nodes <b>312</b>A-<b>312</b>D. For example, processing node <b>312</b>A includes interface logic <b>318</b>A for communicating with processing node <b>312</b>B, interface logic <b>318</b>B for communicating with processing node <b>312</b>C, and a third interface logic <b>318</b>C for communicating with yet another processing node (not shown). Similarly, processing node <b>312</b>B includes interface logic <b>318</b>D, <b>318</b>E, and <b>318</b>F; processing node <b>312</b>C includes interface logic <b>318</b>G, <b>318</b>H, and <b>318</b>I; and processing node <b>312</b>D includes interface logic <b>318</b>J, <b>318</b>K, and <b>318</b>L. Processing node <b>312</b>D is coupled to communicate with a plurality of input/output devices (e.g. devices <b>320</b>A-<b>320</b>B in a daisy chain configuration) via interface logic <b>318</b>L. Other processing nodes may communicate with other I/O devices in a similar fashion.</p><p>Processing nodes <b>312</b>A-<b>312</b>D implement a packet-based link for inter-processing node communication. In the present embodiment, the link is implemented as sets of unidirectional lines (e.g. lines <b>324</b>A are used to transmit packets from processing node <b>312</b>A to processing node <b>312</b>B and lines <b>324</b>B are used to transmit packets from processing node <b>312</b>B to processing node <b>312</b>A). Other sets of lines <b>324</b>C-<b>324</b>H are used to transmit packets between other processing nodes as illustrated in FIG. <b>12</b>. Generally, each set of lines <b>324</b> may include one or more data lines, one or more clock lines corresponding to the data lines, and one or more control lines indicating the type of packet being conveyed. The link may be operated in a cache coherent fashion for communication between processing nodes or in a noncoherent fashion for communication between a processing node and an I/O device (or a bus bridge to an I/O bus of conventional construction such as the PCI bus or ISA bus). Furthermore, the link may be operated in a non-coherent fashion using a daisy-chain structure between I/O devices as shown. It is noted that a packet to be transmitted from one processing node to another may pass through one or more intermediate nodes. For example, a packet transmitted by processing node <b>312</b>A to processing node <b>312</b>D may pass through either processing node <b>312</b>B or processing node <b>312</b>C as shown in FIG. <b>12</b>. Any suitable routing algorithm may be used. Other embodiments of computer system <b>300</b> may include more or fewer processing nodes then the embodiment shown in FIG. <b>12</b>.</p><p>Generally, the packets may be transmitted as one or more bit times on the lines <b>324</b> between nodes. A bit time may be the rising or falling edge of the clock signal on the corresponding clock lines. The packets may include command packets for initiating transactions, probe packets for maintaining cache coherency, and response packets from responding to probes and commands.</p><p>Processing nodes <b>312</b>A-<b>312</b>D, in addition to a memory controller and interface logic, may include one or more processors. Broadly speaking, a processing node comprises at least one processor and may optionally include a memory controller for communicating with a memory and other logic as desired. More particularly, each processing node <b>312</b>A-<b>312</b>D may comprise one or more copies of processor <b>10</b>. External interface unit <b>18</b> may includes the interface logic <b>318</b> within the node, as well as the memory controller <b>316</b>.</p><p>Memories <b>314</b>A-<b>314</b>D may comprise any suitable memory devices. For example, a memory <b>314</b>A-<b>314</b>D may comprise one or more RAMBUS DRAMs (RDRAMs), synchronous DRAMs (SDRAMs), static RAM, etc. The address space of computer system <b>300</b> is divided among memories <b>314</b>A-<b>314</b>D. Each processing node <b>312</b>A-<b>312</b>D may include a memory map used to determine which addresses are mapped to which memories <b>314</b>A-<b>314</b>D, and hence to which processing node <b>312</b>A-<b>312</b>D a memory request for a particular address should be routed. In one embodiment, the coherency point for an address within computer system <b>300</b> is the memory controller <b>316</b>A-<b>316</b>D coupled to the memory storing bytes corresponding to the address. In other words, the memory controller <b>316</b>A-<b>316</b>D is responsible for ensuring that each memory access to the corresponding memory <b>314</b>A-<b>314</b>D occurs in a cache coherent fashion. Memory controllers <b>316</b>A-<b>316</b>D may comprise control circuitry for interfacing to memories <b>314</b>A-<b>314</b>D. Additionally, memory controllers <b>316</b>A-<b>316</b>D may include request queues for queuing memory requests.</p><p>Generally, interface logic <b>318</b>A-<b>318</b>L may comprise a variety of buffers for receiving packets from the link and for buffering packets to be transmitted upon the link. Computer system <b>300</b> may employ any suitable flow control mechanism for transmitting packets. For example, in one embodiment, each interface logic <b>318</b> stores a count of the number of each type of buffer within the receiver at the other end of the link to which that interface logic is connected. The interface logic does not transmit a packet unless the receiving interface logic has a free buffer to store the packet. As a receiving buffer is freed by routing a packet onward, the receiving interface logic transmits a message to the sending interface logic to indicate that the buffer has been freed. Such a mechanism may be referred to as a \u201ccoupon-based\u201d system.</p><p>I/O devices <b>320</b>A-<b>320</b>B may be any suitable I/O devices. For example, I/O devices <b>320</b>A-<b>320</b>B may include network interface cards, video accelerators, audio cards, hard or floppy disk drives or drive controllers, SCSI (Small Computer Systems Interface) adapters and telephony cards, modems, sound cards, and a variety of data acquisition cards such as GPIB or field bus interface cards.</p><p>Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Kevin J.", "last_name": "McGrath", "name": ""}, {"first_name": "James B.", "last_name": "Keller", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}, {"first_name": "", "last_name": "ADVANCED MICRO DEVICES, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/355"}, {"primary": false, "label": "G06F   9/34"}, {"primary": false, "label": "G06F   9/40"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/40        20060101A I20051110RMUS"}, {"label": "G06F   9/318       20060101A I20070721RMEP"}, {"label": "G06F   9/355       20060101A I20070721RMEP"}, {"label": "G06F   9/34        20060101A I20051110RMEP"}], "national_classes": [{"primary": true, "label": "712210"}, {"primary": false, "label": "711220"}, {"primary": false, "label": "712E09035"}, {"primary": false, "label": "711208"}, {"primary": false, "label": "712E09041"}, {"primary": false, "label": "712213"}, {"primary": false, "label": "711212"}], "ecla_classes": [{"label": "G06F   9/34X"}, {"label": "G06F   9/30X4"}, {"label": "G06F   9/30X2"}], "cpc_classes": [{"label": "G06F   9/30189"}, {"label": "G06F   9/30185"}, {"label": "G06F   9/30189"}, {"label": "G06F   9/342"}, {"label": "G06F   9/342"}, {"label": "G06F   9/30185"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "2000-01-14", "application_date": "2000-01-14", "family_members": [{"ucid": "US-6560694-B1", "titles": [{"lang": "EN", "text": "Double prefix overrides to provide 16-bit operand size in a 32/64 operating mode"}]}]}