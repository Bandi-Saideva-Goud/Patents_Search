{"patent_number": "US-5097409-A", "publication_id": 70430424, "family_id": 27395882, "publication_date": "1992-03-17", "titles": [{"lang": "EN", "text": "Multi-processor system with cache memories"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA37107104\"><p>A system having a CPU, a main memory and a bus. A cache memory couples the CPU to the bus and is provided with circuitry to indicate the status of a data unit stored within the cache memory. One status indication indicates whether the contents of a storage position have been modified (dirty) since those contents were received from main memory. Another status indication indicates whether the contents of the storage position exist within another cache memory (shared). Each cache includes a bus monitor that monitors bus transactions. When data is read from system memory by a first cache a second cache determines if the data is shared. If yes, the second cache asserts a bus hold line and determines if the shared data is dirty. If yes, the second cache drives the corresponding data to the bus for storage within the first cache. For a system memory write, the second cache latches the data and determines if the data is shared. If yes, the second cache replaces its copy of the data with that latched from the bus. As such, no cache \"valid\" status bits are required in that each cache is assured of having the most current version of data.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. A data processing system comprising:<claim-text>at least first and second central processing units;</claim-text><claim-text>main memory means;</claim-text><claim-text>bus means coupled to said central processing units and to said main memory means;</claim-text><claim-text>a cache memory means coupled between each central processing unit and said bus means for storing data units received from said main memory means in addressable storage positions, all said data units being valid and accessible; each of said cache memory means including</claim-text><claim-text>status means coupled to each said data unit storage position for indicating whether a data unit stored therein has been modified since the data unit was received from said main memory means such that the data unit may differ from that stored in the main memory means, and for indicating whether the data unit stored therein may be present in another cache memory means; and</claim-text><claim-text>control means, including bus monitor means coupled to said bus means for monitoring the transfer of data units thereon between at least another one of said central processing units and said main memory means, for maximizing the usefulness of data units stored in the cache memory means by assuring that each said stored data unit is representative of the most current data, said control means including means, responsive to the operation of said bus monitor means, for replacing a stored data unit with a more current data unit being written to said main memory means from another one of said central processing units; and wherein</claim-text><claim-text>said control means further includes means, responsive to (a) an instruction from an associated central processing unit to modify a data unit, and (b) to a miss indication from a cache tag store means, and (c) to an indication from said status means that a data unit at a location to be used to store the modified data unit has itself not been modified; to cause (1) a data unit in said memory means which corresponds in address to the data unit to be modified to be read into said cache memory means and stored at the location, and (2) to modify the read-in data unit, and (3) to cause the status means to indicate that the read-in data unit has been modified, and (4) in response to an indication from said status means that the modified data unit may be present in another cache memory means, to transmit the modified data unit to said main memory means via said bus means, and to cause the status means to indicate that the read-in data unit has not been modified.</claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. The invention as defined in claim 1 wherein each data unit storage position in said main memory means has a physical address and each said physical address is employed to access and identify a storage position in each said cache memory means, the combination further comprising:<claim-text>a first cache tag store having a plurality of cache tag storage positions, each position associated with a data unit storage position in a cache memory means, for storing a first subset of the physical address of a data unit stored in a data unit storage position in said cache memory means, said cache tag store being addressable by a second subset of the physical address of said stored data unit.</claim-text></claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. The invention of claim 2 and further comprising:<claim-text>means for entering a data unit received from said central processing unit into said cache memory means at a data unit storage position indicated by said second subset of said physical address associated with said data unit; wherein said control means is responsive to an indication by said status means that said entered data unit may be present in another cache memory means, to transmit said entered data to said main memory means for storage at its physical address therein.</claim-text></claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. The invention of claim 3 wherein said control means further includes means, responsive to said transmission of said entered data unit to said main memory means, for modifying said status means to indicate that said entered data unit in said data storage position in said cache memory means does not differ from the data unit stored in said main memory means at a corresponding physical address.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. The invention as defined in claim 1 wherein said status means comprises:<claim-text>a first storage means corresponding to each data unit address in said cache memory means for indicating whether a data unit stored therein is \"dirty\", in that it differs from the data unit stored at a corresponding physical address in said main memory means; and</claim-text><claim-text>an additional storage means corresponding to each data unit address in said cache memory means for indicating whether a data unit stored therein is \"shared\", in that it may also be stored in another cache memory means.</claim-text></claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. The invention as claimed in claim 1 wherein said cache memory means is the sole means for transferring data units from an associated central processing unit to said main memory means and vice versa.</claim-text></claim>"}, {"num": 7, "parent": 2, "type": "dependent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. The invention as defined in claim 2 wherein said first subset of said physical address is termed a cache tag and said second subset of said physical address is termed a cache address, said cache tag store being operative upon receipt of a cache address to read out the cache tag stored at said cache address for comparison with the tag associated with said received cache address and, if a comparison occurs, said cache memory means further including means to access the data unit stored at said cache address.</claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. The invention as defined in claim 7 and further including:<claim-text>a second cache tag store means for storing identical data to that stored in said first cache tag store; and</claim-text><claim-text>means, responsive to a receipt of a cache address from said bus means, to search said second cache tag store to determine if the cache tag, stored at said cache address therein matches said received cache address.</claim-text></claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. The invention as defined in claim 8 wherein said control means further includes means, responsive to the operation of said bus monitor means, for providing to said second cache tag store means said cache address and cache tag of said data units being written to or read from said main memory means.</claim-text></claim>"}, {"num": 10, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. A data processing system as set forth in claim 5 wherein said control means further comprises:<claim-text>means for generating a multi-data unit read from said main memory means; and</claim-text><claim-text>means for inhibiting a transfer of individual ones of the data units, read from said main memory means in response to the multi-data unit read, to a data unit storage location in said cache memory means, said inhibiting means being coupled to said first storage means of said status means and responsive thereto for transferring data units into data unit storage locations that have not been modified.</claim-text></claim-text></claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. A data processing system comprising:<claim-text>first and second central processing units;</claim-text><claim-text>bus means;</claim-text><claim-text>main memory means coupled to said bus means;</claim-text><claim-text>first and second cache memory means an individual one of which is coupled between one of said central processing units and said bus means for storing valid data units in addressable storage positions;<claim-text>each of said cache memory means comprising:</claim-text></claim-text><claim-text>cache tag store means coupled to the associated central processor unit and responsive to a received data unit address to indicate a hit if the addressed data unit is present in its associated cache memory means or a miss if said addressed data unit is not present in its associated cache memory means;</claim-text><claim-text>status means coupled to each said data unit storage position in said cache memory means for providing: a dirty indication if the contents of said data unit storage position have been modified since said contents were received from said main memory means; a not dirty indication if said contents have not been so modified; a shared indication that said contents may be present in another cache memory means; and a not shared indication that said contents are not present in another cache memory means; and</claim-text><claim-text>control means, coupled to said status means and to said cache tag store means, said control means including bus monitor means coupled to said bus means for monitoring the transfer of data units thereon between at least said other one of said cache memory means and said main memory means, said control means including means, responsive to the operation of said bus monitor means and to a shared indication from said status means, for replacing a stored data unit with a more current data unit being written to said main memory means from said other one of said cache memory means; wherein</claim-text><claim-text>said control means is responsive to (a) an instruction from its associated central processing unit to write a new data unit to said cache memory means and (b) a hit indication for said new data unit from said cache tag store means and (c) a shared indication for said new data unit from said status means; for updating said cache memory means with said new data unit and additionally causing said new data unit to be stored into said main memory means via said bus means.</claim-text></claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim num=\"12\"><claim-text>12. The invention as defined in claim 11 wherein said control means is responsive to (a) a request for a data unit from the associated central processing unit and (b) a miss indication from said cache tag store means and (c) a dirty indication from said status means; to (1) assert a hold signal on said bus means, (2) transmit said data request to said main memory means, (3) to cause the dirty entry in said cache memory means to be entered into said main memory means, (4) to reset said dirty indication to not dirty and (5) to store said requested data unit to said cache memory means.</claim-text></claim>"}, {"num": 13, "parent": 11, "type": "dependent", "paragraph_markup": "<claim num=\"13\"><claim-text>13. The invention as defined in claim 11 wherein said bus means includes a circuit for providing a shared signal upon said bus means that is indicative of shared or not shared for a data unit being transferred over said bus means, and wherein said status means is coupled to and responsive to said shared signal on said bus means to set its shared, not shared indications for said data unit in accordance with a state of the shared signal on said bus means circuit.</claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"14\"><claim-text>14. The invention as defined in claim 13 wherein said bus means includes a hold circuit for providing a hold signal on said bus means, the hold signal being coupled to said control means of each of said cache memory means, said hold signal, when set, causing said control means to hold its operations pending receipt of additional data units.</claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim num=\"15\"><claim-text>15. The invention as defined in claim 14 wherein said control means is further responsive to (a) the sensing of a data unit being returned on said bus means to a non-associated central processing unit from said main memory means and (b) a hit indication for said sensed data unit from the cache tag store means associated with said control means; for (1) setting said bus means hold circuit and (2) examining the dirty indication for said sensed data unit from the status means associated with said control means and (3) transmitting said data unit from its associated cache memory means onto said bus means if a dirty indication is found.</claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim num=\"16\"><claim-text>16. The invention as defined in claim 15 wherein said control means additionally sets said bus means circuit to indicate \"shared\" for said data unit being transmitted onto said bus means.</claim-text></claim>"}, {"num": 17, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"17\"><claim-text>17. The invention as defined in claim 13 wherein said control means is responsive to (a) an instruction from its associated central processing unit to write a new data unit to said cache memory means and (b) to a miss indication for said new data unit from said cache tag store means and (c) a dirty indication from said status means; to cause (1) the data unit in said cache memory means, which gave rise to said dirty indication, to be written to said main memory means and (2) a data unit in said main memory means which corresponds in address to said new data unit to be read from said main memory means and stored into said cache memory means (3) to modify said stored data unit to reflect said new data unit and (4) to set the dirty indication for the modified data unit.</claim-text></claim>"}, {"num": 18, "parent": 17, "type": "dependent", "paragraph_markup": "<claim num=\"18\"><claim-text>18. The invention as defined in claim 17 wherein said control means, in response to a shared signal from said bus means circuit, additionally transmits said new data unit to said main memory means via said bus means and resets the dirty indication to indicate not dirty.</claim-text></claim>"}, {"num": 19, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"19\"><claim-text>19. The invention as defined in claim 13 wherein said control means is responsive to (a) an instruction from its associated central processing unit to write a new data unit to said cache memory means and (b) to a miss indication from said cache tag store means and (c) a not dirty indication from said status means; to cause (1) a data unit in said main memory which corresponds in address to said new data unit to be read into said cache memory means and (2) said data unit to be modified to reflect said new data unit and (3) to set the dirty indication for the modified data unit.</claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim num=\"20\"><claim-text>20. The invention as defined in claim 19 wherein said control means, in response to a shared signal from said bus means circuit, additionally transmits said new data unit to said main memory means via said bus means and resets the dirty indication to indicate not dirty.</claim-text></claim>"}, {"num": 21, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"21\"><claim-text>21. For use in a data processing system having bus means for coupling together bus agents, a bus agent comprising:<claim-text>cache memory means coupled between a central processing unit and said bus means for storing data units received from a main memory means in addressable data unit storage locations; and</claim-text><claim-text>control means coupled to said cache memory means for assuring that each stored data unit is representative of the most current data, when said data unit is called for by said central processing unit, said control means including means, coupled to said bus means, for monitoring bus activity thereon and further including means, responsive to a data unit being written to said main memory means over said bus means by another bus agent, for determining if a corresponding data unit is stored within the cache memory means, and, if it is so determined, for replacing the corresponding stored data unit with the data unit being written to said memory means over said bus means, wherein said control means includes first status means for indicating if individual ones of said stored data units are stored by another bus agent, the bus agent further comprising:</claim-text><claim-text>means for storing a data unit received from said central processing unit into said cache memory means at a data unit storage location, and wherein said control means further includes means, responsive to said first status means indicating that said received data unit has a main memory address corresponding to that of a data unit stored by another bus agent, to cause said received data unit to also be transmitted to said main memory means over said bus means.</claim-text></claim-text></claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim num=\"22\"><claim-text>22. A bus agent as set forth in claim 21 wherein said control means further includes second status means for indicating if data stored at an individual one of the data unit storage locations has been modified since being stored, said control means further including means, responsive to said transmission of said data unit to said main memory means, to cause said second status means to indicate that a corresponding data unit stored at a data unit storage location has not been modified.</claim-text></claim>"}, {"num": 23, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"23\"><claim-text>23. A bus agent as set forth in claim 22 wherein said control means further comprises:<claim-text>means for generating a multi-data unit read from said main memory means; and</claim-text><claim-text>means for inhibiting a transfer of individual ones of the data units, read from said main memory means in response to the multi-data unit read, to a data unit storage location in said cache memory means, said inhibiting means being coupled to said second status means and responsive thereto for transferring data units into data unit storage locations that have not been modified.</claim-text></claim-text></claim>"}, {"num": 24, "parent": 21, "type": "dependent", "paragraph_markup": "<claim num=\"24\"><claim-text>24. A bus agent as set forth in claim 21 wherein said control means further includes means, responsive to said monitoring means detecting a read of a data unit by a second bus agent from the main memory means, for determining if the data unit being read is commonly stored within the cache memory means and, if so, for determining if the commonly stored data unit has been modified since being stored within the cache memory means, the control means further comprising means, responsive to the operation of the determining means, for transmitting a commonly stored and modified data unit from the cache memory means to the bus means for reception by the second bus agent.</claim-text></claim>"}, {"num": 25, "parent": 24, "type": "dependent", "paragraph_markup": "<claim num=\"25\"><claim-text>25. A bus agent as set forth in claim 24 wherein the control means further includes means, responsive to the operation of the transmitting means, for asserting a bus means signal for indicating to the second bus agent that the transmitted data unit is commonly stored.</claim-text></claim>"}, {"num": 26, "parent": 24, "type": "dependent", "paragraph_markup": "<claim num=\"26\"><claim-text>26. A bus agent as set forth in claim 24 wherein the control means further includes means, responsive to the operation of the determining means, for asserting a bus means signal for indicating to the second bus agent that the bus agent may transmit a data unit that is commonly stored.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES66173296\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This is a continuation of copending application(s) Ser. No. 07/508,027 filed on Apr. 11, 1990, now abandoned, which is a divisional of application Ser. No. 07/213,556 filed on June 30, 1988 (now U.S. Pat. No. 4,939,641 issued on July 3, 1990).</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>FIELD OF THE INVENTION</h4><p>This invention relates to multi-processor computing systems which employ cache memories and more particularly to means and methods for maintaining data integrity therein.</p><h4>BACKGROUND OF THE INVENTION</h4><p>The use of high speed, small capacity cache memory systems is well known. While there are a variety of cache memory systems, several of the better known are termed \"write through\" caches and \"write back\" caches. In a write through cache, data is written into main memory at the same time it is written into the cache. Thus, the cache always contains identical data to that stored in main memory and data integrity (coherency) is maintained throughout the system. The problem with write through architecture is that it creates an excessive amount of bus traffic, in that a write to main memory occurs every time there is a write to the write through cache. A positive aspect of this architecture is that it is always known where the most updated data resides, i.e., everywhere.</p><p>In an architecture employing a write back cache, the amount of traffic on the bus is significantly reduced. Initially, data is written into the write back cache from main memory and is then used by the central processing unit (CPU) for operations. When the CPU writes the data back into the cache and assuming it has been modified, a \"dirty\" bit is set to indicate that the data is now unique to that cache and is different from that which resides in main memory. In such a cache, in general, no immediate effort is made to write the revised data into the main memory to maintain data integrity. Obviously then, it is the dirty bit which is critical to the maintenance of data coherence. So long as a write back cache is utilized with only one processor, data management is straight forward. However, when more than one central processor uses the same main memory, data management problems multiply.</p><p>In such systems, there is often more than one cache memory present. Each entry position in a cache is provided with a valid/invalid bit. If a CPU sees that another cache is writing to memory and finds that its cache contains an identical data address, it invalidates its own cache entry rather than updating it. Thus, when a CPU accesses its cache at that particular data address, it finds an invalid entry and is redirected to main memory, a time consuming process.</p><p>It is therefore an object of this invention to maintain data integrity in a multi-processor/cache environment without requiring excessive accesses to main memory.</p><p>It is another object of this invention to enable a number of CPU's to access data via their associated cache memories with each processor knowing that it is always accessing the most updated data.</p><p>It is still another object of this invention to provide a multi-processor system employing write back caches wherein main memory accesses are minimized while simultaneously maintaining data integrity throughout the system.</p><p>It is a further object of this invention to provide a cache memory system wherein the use of valid/invalid data indicators are avoided.</p><h4>SUMMARY OF THE INVENTION</h4><p>A multi-processing system is described wherein at least two CPU's, a main memory means and a bus means are provided. Cache memory means are employed to couple each CPU to the bus means and are further provided with means to indicate the status of a data unit stored within the cache memory means. One status indication tells whether the contents of a storage position have been modified since those contents were received from main memory and another indicates whether the contents of the storage position may be present in another cache memory means. Control means are provided to assure that when a data unit from a CPU is received and stored in the CPU's associated cache memory means, which data unit is indicated as being also stored in a cache memory means associated with another CPU, such CPU data unit is also written into main memory means. During that process, other cache memory means monitors the bus means and updates its corresponding data unit. Bus monitor means are provided for each cache memory means and monitor all writes to main memory and reads from main memory to aid in the assurance of system-wide data integrity.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 shows both the address and data formats for the data processing system embodying the invention.</p><p>FIGS. 2a and 2b, in combination, illustrate a high level block diagram of the invention.</p><p>FIG. 3 is a decision tree indicating the sequence of events which occur during a CPU read request to memory.</p><p>FIG. 4 is a decision tree indicating the sequence of events initiated when a non-requesting CPU/cache monitors on the system bus a data return to a read-requestor.</p><p>FIG. 5 is a decision tree indicating the sequence of events which occur during a CPU write to memory.</p><p>FIG. 6 is a decision tree which indicates the sequence of events which occur when a non-requesting CPU/cache monitors a write to memory by a write requestor.</p><p>FIG. 7 is a flow chart indicating the sequence of events which occurs when a non-requesting CPU/cache monitors a multi-word read from memory to a requesting CPU/cache.</p><p>FIG. 8 is a flow chart illustrating a multi word data read from memory.</p><p>FIG. 9 is a flow chart illustrating the arbitration which occurs between caches on a data return.</p><p>FIGS. 10a, 10b and 10c are timing diagrams useful in understanding the invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>The data processing system of this invention employs address and data formats shown in FIG. 1. A byte comprises 8 bits and a word 4 bytes. Each position in memory is adapted to store two words (\"double word\") and is addressable at the byte level. Any byte may be individually addressed, read and/or written as can any combination of bytes, words and double words. Normally, unless otherwise instructed, data transfers in this system comprise double words.</p><p>With respect to address formats, 28 bits are actively used and comprise a physical address in main memory where a subset of data (e.g. a byte) is to be found. Portions of the physical address are employed to access and identify positions within a write-back cache memory. Each cache uses 12 bits of the physical address, (i.e., bits 4-16) to identify a data word and those 12 bits are called the tag. Another portion of the physical address, i.e., bits 17-28, is employed to provide an address to a storage position within the cache memory (called the cache address). Thus, while the cache address references a storage position within the cache memory, the tag identifies data actually stored at that storage position.</p><p>An access into a cache memory commences with the arrival of a physical address from the CPU. The cache employs the cache address to access one of its memory positions. Subsequently, the tag portion of the received physical address is compared with the tag portion of the data stored at the cache address to determine if there is a match, thus indicating that a \"hit\" has occurred and the proper data to be either accessed, written over or otherwise altered or utilized is the data actually designated by the physical address. If no match is found, (i.e., a \"miss\") the typical response of the system is to generate a read request to main memory for the requested data.</p><p>As above stated, the data format, is two words in length, with each word being 32 bits and comprising 4 eight bit bytes. There are also parity bits associated therewith but these are not relevant to a discussion of this invention.</p><p>It should be kept in mind during the following description, that the invention maintains data integrity by assuring that cache data is always the most up-to-date in the system. Thus, there never is a \"valid\" or \"invalid\" indication with respect to any cache data as it is always assured that if data is provided by a cache, that it invariably is valid (i.e. most up-to-date).</p><p>By contrast, cache systems which employ valid and invalid indicators unnecessarily multiply the number of cache misses which occur when an invalid data unit is addressed. In such systems, a valid data unit is fetched, placed in the cache and then provided to the requestor. This invention avoids those unnecessary memory cycles; avoids the need for any directory or other listing of valid and invalid data and avoids any requirement that its memory controller keep records of cache operations.</p><p>In the cache memories of this invention, indications are associated with each cache data word of its state of modification (if any) since being accessed from main memory, (e.g. \"dirty\" or \"not dirty\") and whether it also may reside in another cache store (e.g. \"shared\" or \"not shared\"). These indications enable the system to continuously update the cache data words and assures that they are updated when they are called for. Even in the case where a cache store is found not to have the requested data, if such data is resident in another cache store, provisions are made for its immediate transfer to the requested cache store.</p><p>The invention further avoids the necessity for the provision of special procedures when more than one CPU wishes to simultaneously modify bytes in a single word. This invention accomplishes such modifications during the normal course of its operations.</p><p>Since, by definition, data in the caches of this system is the most up-to-date, when system operation is initiated, each of the caches must be filled with data. This is accomplished by arbitrarily selecting data from main memory and writing it into each cache store, it being remembered, that at system start-up, main memory data is considered most up-to-date. The system then commences further operations as described hereinafter.</p><p>Turning to FIG. 2, a high level block diagram is shown of a multi processor system that includes at least two CPU's 10 and 12. Each CPU typically operates with a virtual addressing system; however, when internal CPU and memory operations are carried out, the virtual addresses are converted to physical addresses which indicate the actual address positions within main memory 14 where the data designated by the address is stored. The address conversion occurs in address translators 16 and 16' with the resulting physical address being passed via multiplexors 18 and 18' to physical address registers 20 and 20'. As each of the CPU's, along with their associated cache memory systems, are identical, CPU 10 will hereinafter be described in detail with it being understood that CPU 12 is identical and is numbered in an identical manner with prime numbers.</p><p>The portion of the physical address resident in physical address register 20 which corresponds to the cache is (i.e. bits 17-28) fed via cable 22 to cache bus 24. Also connected to cache bus 24 is cache data store 26, cache tag store 28, \"dirty\" bit store 30, \"shared\" bit store 32 and bus monitor cache tag store 54. A cable 27 provides for direct entry of data from CPU 10 to cache data store 26. Cache data store 26 is typically a 32K byte memory that is 4K lines deep by 64 bits wide (8 bytes). Each line of this cache stores a double word. Cache tag store 28 is typically 4K lines deep by 13 bits wide and stores the tag portion of the physical address, which tag defines the address where the corresponding data is stored in cache data store 26. It should be remembered that each double word of data has associated with it a physical address which is indicative of the position in main memory 14 where that double word is stored. Thus, each line of cache tag store 28 corresponds in position to a data storage address in cache data store 26 and contains the tag portion of the physical address associated with the data stored at such cache data store address.</p><p>Dirty bit register 30 and shared bit register 32 are each also 4K lines deep. A \"1\" bit on any line of dirty bit register 30 indicates that data in the corresponding line of cache data store 26 is more up to date than data in the corresponding storage location in main memory 14. A \"0\" setting on any line of dirty bit register 30 indicates that the corresponding entry in cache data store 26 is the same as that appearing at that location in main memory (with one exception to be hereinafter described). A bit set to 1 on any line of shared bit register 32 indicates that another cache in the system might contain the same entry. A bit set to 0 on any line of shared bit register 32 indicates that no other cache has the same entry.</p><p>Referring back to physical address register 28, cable 34 accesses the tag portion (bits 4-16) of the physical address and presents it to comparator 36. Cable 38 from cache tag store 28 also presents to comparator 36 a selected tag stored therein. If a comparison occurs, indicating that the tags are identical (a hit), a signal is sent via line 39 to cache controller 40.</p><p>While cache controller 40 and other operational and control entities, are, for illustration purposes, shown as independent entities, it should be understood that their functions, to be hereinafter described, may be incorporated into a CPU and not appear as totally independent entities.</p><p>Cables 42 and 44 provide to cache controller 40 the cache address bits from cache bus 24 and the complete physical address from register 20, respectively. Lines 43 and 45 respectively provide the means for setting and reading out to cache controller 40, the dirty and shared bits respectively. Cache controller 40 also provides signals via cable 42 to cache bus 24 which control the read in and read out of data from cache data store 26, cache tag store 28, dirty bit register 30, shared bit register 32 and bus monitor cache tag store 54.</p><p>Communications between the main elements of the system shown in FIG. 2 occur on system bus 42. In actuality, system bus 42 is comprised of 3 separate bus systems, i.e., data bus 102, address bus 104 and control bus 106. Control bus 106 is in turn comprised of main control lines 53, shared line 55 (which is connected to all cache controllers), bus lock line 59 (which is monitored by all units connected to system bus 42) and hold lines 57 and 57'. Hold line 57 emanates from cache controller 40 and hold line 57' emanates from cache controller 40. Both hold lines 57 and 57' are monitored by all units connected to system bus 42.</p><p>Each hold line 57, 57' and lock line 59 performs somewhat similar functions (i.e. exclusion of others from the system bus). When a cache controller asserts its hold line, all other potential users of the system bus are kept off the bus until the hold line is released. For instance (as will hereinafter be described in detail), it will sometimes be the case that a cache controller, in monitoring the system bus 42, will detect that a more recent version of the data being returned to another requestor is also present in its own cache store. In such case the monitoring cache controller will set its hold line which indicates to the data requestor, that more data may be coming and not to release its connection to the system bus. Thus the hold line effectively prevents any subsequent independent transaction from occurring until the data requestor is assured of having received the most updated data available.</p><p>With respect to bus lock line 59, an entity connected to the bus must request access to it and is granted that access only after the system assures that no other entity having higher priority is queued up and waiting with a similar request. Once an entity is granted access to bus lock line 59 and asserts it, only the asserting entity and memory control unit 54 have access to the system bus. Thus when the asserting entity issues a read request, memory control unit 54 can respond without fear of any other entity having an opportunity to access the main memory and to change the requested data. When the particular operation or operations are concluded, bus lock line 59 is released and becomes available to any other requesting entity.</p><p>Data bus 102 carries data between all main subsystems (e.g. between the cache memory systems and main memory 14). Each cache memory is provided with a data bus interface 50 which provides access to and from data bus 102. In a like manner, address bus 104 is accessed by each cache memory via an address bus interface 52. Control bus 106 is connected via cable 49 to cache controller 40 and provides the necessary traffic pathways for various system control signals. Each of busses 102, 104 and 106 is also connected to memory control unit 54 which manages all main memory operations. Each of busses 102, 104 and 106 further connected to I/O interfaces 61 which control all transfers between connected input/output devices and the various system busses; and to system control interface unit 63 which provides system initialization control and diagnostics.</p><p>An important portion of each cache memory for assuring data integrity, is bus monitor cache tag store 54. Bus monitor cache tag store 54 is identical in structure to cache tag store 28 and contains an identical set of tags as are contained in cache tag store 28.</p><p>When address bus interface 52 monitors a physical address on address bus 104, it transmits that address via cable 56 to external address register 58. Output cable 60 from external address register 58 carries the cache address portion of the monitored physical address and causes the memory line corresponding thereto in bus monitor cache tag store 54 to be read out via cable 62 to comparator 64. The other input to comparator 64 occurs on cable 66 and is the tag portion of the physical address stored in external address register 58. An equivalency indication from comparator 64 is fed via line 67 to cache controller 40. Another input to cache controller 40 is provided via cables 56 and 68 which carry the full physical address monitored by address bus interface 52. Cache controller 40 controls the operations of address bus interface 52 and data bus interface 50 via signals emplaced on lines 70 and 72. Data bus interface 50 operates in much the same manner as address bus interface 52, however it captures data appearing on data bus 102 and provides it upon command via cable 51 to cache data store 26.</p><p>Referring now to FIG. 3 (in conjunction with FIG. 2), a decision tree is illustrated showing operations which occur when CPU 10 issues a read request to main memory 14. Under such circumstances, CPU 10 issues its read request via cable 80 to cache controller 40. Previously, the physical address of the data requested to be read from memory was inserted by CPU 10 into physical address register 20. Cache controller 40 then causes the tag portion of physical address register 20 to be compared against the tags stored in cache tag register 28. If a match is found by comparator 36, a signal is provided by line 38 to cache controller 40 indicating \"hit\". If cache controller 40 detects no \"hit\" signal within a predetermined time period, it assumes that a \"miss\" signal has been generated and that corresponding data is not present in cache data store 26. Similarly, the cache address residing in physical address register 20 causes the dirty and shared status bits to be read out via lines 43 and 45 to cache controller 40. Thusly, cache controller 40 knows whether the data being sought is present in cache data store 26 (hit or miss); whether it is dirty or not; and whether it is shared or not.</p><p>As shown in FIG. 3, the top four branches of the decision tree all assume that the data being sought is present in cache data store 26. In such case, it is irrelevant whether it is dirty or not, or shared or not shared and cache controller 40 causes cache data store 26 to read out the requested data via cable 27 to CPU 10.</p><p>If, on the other hand, cache controller 40 detects that the requested data is not in cache data store 26 (a miss), and that the data stored at the addressed location in cache data store 26 is both dirty and shared, a series of operations are then undertaken. Initially, cache controller 40 issues a main memory read request to memory control unit 54 indicating data is required from the physical address location stored in physical address register 20. Memory control unit 54 then accesses the requested data from the physical address in main memory 14 and provides it via data bus 102 to data bus interface 50. Before that data may be written into cache data store 26, the unwanted data presently stored at that address within cache data store 26 must be saved. Since the unwanted data is \"dirty\", it is written back into main memory 14 via cable 51 and data bus interface 50. In that way, the data in main memory 14 is updated to correspond to the unwanted dirty data presently residing in the addressed position of cache data store 26. The dirty bit corresponding to that address is then reset to zero and data bus interface 50 is commanded to write the requested data (now held in data bus interface 50) into cache data store 26 at the cache address indicated by physical address 20. Simultaneously, the tag portion of the requested data is entered into cache tag store 28 and bus monitor cache tag store 54. The shared bit corresponding thereto in shared bit store 32 is then updated in accordance with the \"bus shared\" signal appearing on control bus 106. (the operation of which will be described hereinbelow.) Subsequently, the data newly entered into cache data store 26 is read back to CPU 10 via cable 27.</p><p>Each cache controller continuously monitors system bus 42 for two types of operations: (a) a data write to main memory 14 and (b) a data return from main memory 14 to fill a read request. The monitoring is independent of where the read or write request originates (e.g. a cache/CPU, a system bus interface, a system control interface, an I/O interface). It is this continuous monitoring which greatly assists the system to maintain data integrity.</p><p>Returning to FIG. 2, if it is assumed that cache controller 40 issues a data read signal onto control bus 106, that signal is sensed by cache controller 40' which instructs address bus interface 52' to latch the address to be subsequently placed onto address bus 46. Address bus interface 52' latches the requested physical address from the address bus and places it into external address register 58'. There, its tag portion is utilized to determine if bus monitor cache tag store 54' has a tag which compares with the address tag portion just inserted into external address register 58'. If a compare occurs, cache controller 40' sets a \"hold\" signal onto its hold line in control bus 106 which, in essence, tells cache controller 40 that more data is potentially on the way and not to release its system bus connection. Cache controller 40' further determines whether the corresponding data in cache data store 26' is dirty or not. If it is found to be dirty, it then causes the addressed \"dirty\" data in cache data store 26' to be placed onto data bus 102. Data bus interface 50 captures that data and feeds it to cache data store 26 for storage. Additionally, cache controller 40' sets a \"bus shared\" line on control bus 106 which indicates that the newly stored data in cache data store 26 is present in more than one location. (Obviously, if cache controller 40' had found that its data was not dirty, then no transmission to cache data store 26 would have been necessary as the data in cache data store 26' would have been identical to that being read from main memory 14).</p><p>When cache controller 40' sets the \"bus shared\" line to the one state, cache controller 40 also sets a shared bit in shared register 32 (which corresponds to the data just read into cache data store 26) to the one state.</p><p>Assuming now that data is to be read from a cache data store into main memory 14, such a data transfer is, as aforestated, monitored by non-associated cache controllers. (i.e., those controllers which control cache data stores other than the cache data store from which data is being read). Thus, if cache controller 40' senses a write command generated by cache controller 40 onto control bus 48, it instructs address bus interface 52' and data bus interface 50' to latch the address and data being written to main memory 14. Subsequently, a tag comparison is performed to determine if any of the tags in bus monitor cache tag store 54' are equal to the tag stored in address bus interface 52'. If so, then cache controller 40' instructs data bus interface 50' to update cache data store 26' with the new data.</p><p>Returning now to FIG. 3, the decision tree shown therein indicates that on a CPU read request, if a \"cache miss\", \"dirty\" and \"not shared\" sequence of findings occur, the operation is the same as when \"shared\" data is found. In other words whether the data is shared or not shared is irrelevant to the sequence of operations.</p><p>If however, a cache miss occurs and the data is found to be not dirty, (and shared or not shared) the sequence of operations is altered. In such a case, a main memory read request is generated by cache controller 40 to memory control unit 54 and the main memory data is written into cache data store 26. Since data at the addressed position of cache data store 26 is \"not dirty\" there is no need to update the identical data appearing in main memory 14. The \"bus shared\" line is then sampled and the shared bit is set in accordance with whether another cache controller, in response to the read request appearing on the control bus, has set the shared line to indicate that it too has the same data. Finally, the contents of cache data store 26 are read to CPU 10.</p><p>Turning now to FIG. 4, the decision tree shown therein will be helpful in understanding the operation of the system when a data return indication is monitored on the system bus by a non-requesting cache controller. As above stated, each cache controller monitors the control bus for both data reads from main memory and writes to main memory. In the instance shown in FIG. 4, it is assumed that a read from main memory 14 has been requested by cache controller 40 and that a data return response thereto has been monitored by cache controller 40'. As aforestated, cache controller 40' causes the physical address of the data being accessed to be latched in address bus interface 52'. It then determines if a cache \"hit\" occurs; whether the data is dirty or not dirty and whether it is shared or not shared. If the conditions hit, dirty and shared are found, cache controller 40' sets its hold line on control bus 106 and instructs cache data store 26' to write its stored data onto data bus 102 where it is picked up and stored in cache data store 26 by data bus interface 50. Cache controller 40' also sets the shared line on control bus 106 equal to one, assuming the requestor of the data is a central processing unit.</p><p>If in the case discussed above, cache controller 40' finds that the data indication in shared bit register 32' is \"not shared\", the process is much the same as in the shared condition however shared bit register 32' is set to one to properly indicate the shared state of the data in cache data store 26'.</p><p>If a cache hit is found but the data in cache data store 26' is found to be \"not dirty\", the following actions occur. If the data is found to be shared, cache controller 40' sets the bus shared line to a one, assuming the requestor is a central processing unit. If the data is found to be \"not shared\" the bus shared signal is also set to a one and the shared bit associated with the respective data line in cache data store 26' is set to one indicating that the data stored therein is, in fact, shared. Here again, it is assumed the requestor is a central processing unit. As is obvious, if there is a cache miss in this procedure, no actions are required.</p><p>The timing diagrams of FIGS. 10a, 10b and 10c illustrate various types of bus transactions.</p><p>FIG. 10a shows a byte/word/double write immediately followed by the Command-ID and address portion of a double (64 bit) read followed by an MCU data return of the requested double word.</p><p>FIG. 10b demonstrates the use of both the lock and hold lines for a cache fetch/write back. That case corresponds to when a cache fetch is issued, a miss occurs and dirty data is resident in the addressed position. Thus the dirty data must be written back to main memory prior to the requested data from main memory being written into the cache store. The associated cache controller is shown asserting both its hold line and the lock line and sending command ID to MCU 54 for an octal word read. The asserted hold line prevents MCU 54 from writing into the cache store until it has been released and the asserted lock line prevents another bus connection from using the bus during this sequence. Subsequent to the write back, and release of both the hold and lock lines, MCU 54 is free to write the requested four double words to the cache store.</p><p>FIG. 10c demonstrates another use of the hold line. A bus connection is shown requesting a double word read and the MCU 54 returning the requested double word. The caches latch the address of the double word, and do directory look-ups in the following cycle. If a dirty match is found by a cache, that cache asserts hold shortly before the end of the cycle. The hold line prevents other connections from using the bus until the write-back cache re-transmits the double word along with its address and thereafter releases. The retransmission is indicated by the assertion of a bus valid signal on the system bus.</p><p>Turning now to FIG. 5, the procedures followed when a write to memory command is received from a CPU will be described. In such a case, the initial operation is much the same as when a read request is received, i.e., the physical address accompanying the write command is analyzed to determine whether the data sought to be written is either present or not present in cache data store 26 (a hit or a miss). If a hit occurs and it is found that the data is dirty and shared, cache controller 40 causes cache data store 26 and cache tag store 28 to store the respective data and tag bits. However, since it was found that the CPU is writing to a shared location, invariably, a write through action occurs to main memory 14. Thus the data, in addition to being written into cache data store 26, is also written to main memory 14 via a write command placed on control bus 106.</p><p>Assuming the shared data is still resident in cache data store 26', the write through is sensed by cache controller 40' which determines that its cache data store 26' includes data having the same tag. Cache controller 40' then instructs data bus interface 50' to update that data position with the data being written from cache data store 26 to main memory 14. (which has been captured by address bus and data bus interfaces 52' and 50' respectively). This assures that each of the cache data stores has the most updated information. Since the main memory data and the cache data stores now contain the same information, the dirty bit is reset to 0.</p><p>If it is found that the data being written to main memory is not shared, all that is required is that the cache data store 26 be updated. Note that the dirty bit remains equal to one as the data still is not the same as that stored in main memory 14, as no write through to main memory has occurred.</p><p>If there is a cache hit and not dirty and shared indications are found, the operation is identical to that for the \"cache hit\", \"dirty\", and \"shared\". If the data is found to be not shared, then the cache is updated and the dirty bit is again set to one as the data in cache data store 26 differs from the data stored at the same memory position in main memory 14.</p><p>IF a CPU write to memory command is received and a cache miss is found but with a dirty indication for the data already stored in the particular addressed position within cache data store 26, then a considerably more complex set of steps take place. This is irrespective of whether the data is shared or not shared. First, the main memory read request is transmitted to memory control unit 54 by cache controller 40. Then, the dirty entry in cache data store 26 is written into main memory 14. The actual data being sought to be modified is written from main memory 14 back into cache data store 26 and the cache tag store and bus monitor cache tag store are updated. The new data on cache data store 26 is then updated by the act of CPU 10 overwriting new data in the same data position. (It should be recalled that the system retains the capability to selectively overwrite a full double word, single word or any combination of bytes.) Since a write to memory signal was sensed on control bus 106, if another cache controller finds that it too has, in its associated cache data store, the data being accessed, it will set the \"bus shared\" line on control bus 106 indicating shared data. The bus shared signal is sensed by cache controller 40 and the shared bit in shared bit register 32 is set to one. Furthermore, the data recently written into cache data store 26 by CPU 10 is also written through into main memory 14 and thus is sensed by cache controller 40' so that it may modify its associated cache data store. The dirty bit is then reset to 0 in dirty bit register 30. Obviously, if the bus shared signal is equal to 0, there is no need to write through the CPU entry to main memory 14. As shown by the lower branches of the decision tree in FIG. 5, the operations are the same whether the data is initially indicated as being shared or not shared.</p><p>If, in response to a CPU write signal, cache miss, not dirty and shared (or not shared) indications are found, the operation is much the same as wit the \"dirty\" instance, however, there is no need to update main memory with the \"not dirty\" entry as it contains the same data.</p><p>Turning now to FIG. 6, the decision tree shown therein illustrates the various system actions in response to a write to memory being sensed on the system bus. If the non-requesting CPU/cache system finds that the data being written to memory from another CPU/cache system or I/O interface is found in its associated cache data store, and it is indicated as being shared, then it merely updates its cache to coincide with the new data being written to memory. In the not shared cases indicated for a cache hit, there is an error state sensed if the same data is found in a cache data store which is being written to memory from another cache data store. In all cases, the cache data store is updated in accordance with the data being written to memory.</p><p>What has been discussed to this point has involved, in the main, double word accesses from memory and double word writes to memory. As illustrated in FIG. 1 however, the data format employed by the system shown in FIG. 2 includes two, 4 byte words per line of cache data storage. In many instances, it is not only of interest to read or write both data words, but it is also beneficial to read or write multiples of double words in a single operation without having to perform individual stores or writes for each double word. This is particularly useful when accessing or writing instruction sets or operating on long character strings.</p><p>To handle multi-double word operations, a status register is provided. Thus, as shown in FIG. 2, each of cache controllers 40 and 40' is provided with multi word status registers 90 and 90' respectively. These status registers are employed during multi word transfers.</p><p>Referring to FIG. 7, a flow diagram is illustrated which illustrates the occurrences when a multi word data transfer appears on system bus 42 and is monitored by a cache controller other than the one which issued the multi word read request. Each cache controller continuously monitors the system bus for a multi word transfer. During a data return, a cache controller may detect that a data word being transferred has the same tag as a tag stored in its associated bus monitor cache tag store. The cache controller sets in its associated multi word transfer register a one bit in a position which corresponds to the address of the cache tag which evidenced the hit indication. Similarly the cache controller upon detecting the first \"hit\" in multi-word transfer, sets its bus hold control line which notifies the cache controller receiving the data that it should expect additional data.</p><p>The cache controller continues to monitor the system bus until the multi-word transfer has ended. At such time (assuming that cache controller 40' has been monitoring the bus), multi word register 90' has stored therein a series of zeros and ones, with the ones in positions corresponding to addresses of the cache tags where a hit indication occurred.</p><p>The cache controller then addresses its tag store at the address indicated by the first hit. If the data stored at that address is indicated as dirty, it is transmitted to the data requestor. If the data is found to be not dirty, the next address is accessed and the process repeated until all addresses corresponding to positions of the multi-word transfer register with one bits, have been examined.</p><p>Subsequently, cache controller 40' causes the data which is dirty and corresponds to the ones in multi word transfer register 90', to be transmitted to the interface units associated with the cache controller 40 for storage in cache data store 26.</p><p>Turning now to FIG. 8, a flow diagram illustrating an N multi-word data read from memory is illustrated. Initially, a CPU requests a multi word data read from its associated cache. e.g. CPU 10 issues to cache controller 40 via line 80 a multi word data request. However, the initial cache tag requested is found not to be contained in cache data store 26 (a miss). Controller 40 then issues a multi word instruction request to memory control unit 54. Before the actual data transfer occurs the memory position to receive the first double word in cache tag store 26 is addressed. The dirty bit corresponding to the data presently at that address is examined to see if it is set to a one. If it is not, it does not need to be written back to main memory and a corresponding status bit in multi word transfer register remains at 0 indicating that that position may be overwritten. If it is set to one, it must be written back to main memory for update purposes before it may be overwritten.</p><p>After either a write back or a finding that a write back is not necessary, the cache tag store is addressed. If there is a hit, a corresponding status bit in multi word transfer register 90 is set equal to one. Subsequently, until N tag store addresses have occurred, the process repeats itself until all N double words have been examined. Then, controller 40 allows a data return from memory control unit 54 which reads out the N words onto data bus 102 where they are captured by data bus interface 50. Multi word transfer register 90 then comes into play and controls which positions in cache data store 26 are updated. (i.e., only positions corresponding to the positions of multi word register 90 which are set to 0). In this manner, not only is the dirty data written back to main memory and main memory completely updated, but also that data received from main memory 14, which is not most current, is inhibited from being stored in the cache data store.</p><p>Under certain circumstances, conflicts may occur between cache memories. One such conflict may arise during a data return from main memory to a requestor which is monitored by two or more caches. If those caches register hits for the data unit (or units) being returned from main memory, each will set its respective hold line before it has had a chance to examine the dirty status for data at the monitored address. To prevent a conflict, the procedure shown in FIG. 9 is employed. In sum, each cache controller determines if the others hold line was set on a previous clock cycle. If so the earlier set hold line dominates. If both hold lines were set during the same clock cycle, then the cache controller associated with the CPU bearing the lower identification number takes precedence.</p><p>It is to be understood that the above described embodiments of the invention are illustrative only and that modifications throughout may occur to those skilled in the art. Accordingly, this invention is not to be regarded as limited to the embodiments disclosed herein, but is to be limited as defined by the appended claims.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Martin J.", "last_name": "Schwartz", "name": ""}, {"first_name": "Robert D.", "last_name": "Becker", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "WANG LABORATORIES, INC."}, {"first_name": "", "last_name": "SAMSUNG ELECTRONICS CO., LTD.", "name": ""}, {"first_name": "", "last_name": "BT COMMERICAL CORPORATION", "name": ""}, {"first_name": "", "last_name": "BT COMMERCIAL CORPORATION (AS AGENT)", "name": ""}, {"first_name": "", "last_name": "WANG LABORATORIES, INC.", "name": ""}, {"first_name": "", "last_name": "CONGRESS FINANCIAL CORPORATION (NEW ENGLAND)", "name": ""}], "ipc_classes": [{"primary": true, "label": "B06F  12/12"}, {"primary": false, "label": "B06F  13/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711145"}, {"primary": false, "label": "711130"}, {"primary": false, "label": "711119"}, {"primary": false, "label": "711E12034"}], "ecla_classes": [{"label": "G06F  12/08B4P4B"}], "cpc_classes": [{"label": "G06F  12/0833"}, {"label": "G06F  12/0833"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1988-06-30", "application_date": "1991-06-18", "family_members": [{"ucid": "US-5097409-A", "titles": [{"lang": "EN", "text": "Multi-processor system with cache memories"}]}]}