{"patent_number": "US-7237093-B1", "publication_id": 75281513, "family_id": 38198027, "publication_date": "2007-06-26", "titles": [{"lang": "EN", "text": "Instruction fetching system in a multithreaded processor utilizing cache miss predictions to fetch instructions from multiple hardware streams"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA51167500\"><p num=\"p-0001\">In a multi-streaming processor having a memory cache, a system for fetching instructions from individual ones of multiple streams to an instruction pipeline is provided, comprising a fetch algorithm for selecting from which stream to fetch an instruction, and a hit/miss predictor for forecasting whether a load instruction will hit or miss the cache. The prediction by the hit-miss predictor is used by the fetch algorithm in determining from which stream to fetch. A hit prediction results in a next instruction being fetched from the same stream as the instruction tested by the hit/miss predictor, while a miss prediction results in the next instruction being fetched from a different stream, if any. The predictor is also used to determine which instructions to dispatch to functional units.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00001\" num=\"00001\"><claim-text>1. In a processor having multiple hardware streams supporting multiple data threads, and a data cache, a system for fetching instructions from one to P of the multiple hardware streams to a pipeline, where P is less than the number of multiple hardware streams, the system comprising:\n<claim-text>multiple hit/miss predictors, each associated with a corresponding one of the multiple hardware streams, said each configured to forecast whether corresponding instructions from said corresponding one of the multiple hardware streams will hit or miss the data cache, wherein said multiple hit/miss predictors forecast whether said corresponding instructions from said corresponding one of the multiple hardware streams will hit or miss the data cache prior to when said corresponding instructions enter into a dispatch stage in the pipeline;</claim-text>\n<claim-text>a fetch stage, coupled to said multiple hit/miss predictors, configured to simultaneously fetch every cycle, the instructions from the one to P of the multiple hardware streams to the pipeline, and configured to select, on a cycle-by-cycle basis, the one to P of the multiple hardware streams from which to fetch the instructions; and</claim-text>\n<claim-text>an instruction scheduler, coupled to said fetch stage, for managing access for the multiple hardware streams to a set of functional resources for processing instructions from the multiple hardware streams, wherein at any point in time, said instruction scheduler manages access for a given one of the multiple hardware streams according to a priority record, regardless of any priority associated with the multiple data threads.</claim-text>\n</claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00002\" num=\"00002\"><claim-text>2. The system as recited in <claim-ref idref=\"CLM-00001\">claim 1</claim-ref>, wherein a hit prediction precipitates no change in the fetching of the instructions.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00003\" num=\"00003\"><claim-text>3. The system as recited in <claim-ref idref=\"CLM-00001\">claim 1</claim-ref>, wherein a miss prediction results in switching the fetching to different ones of the multiple hardware streams.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00004\" num=\"00004\"><claim-text>4. The system as recited in <claim-ref idref=\"CLM-00001\">claim 1</claim-ref>, wherein said each of said multiple hit/miss predictors generates a confidence level value, and said confidence level value is used by said fetch algorithm to select the P of the multiple hardware streams.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00005\" num=\"00005\"><claim-text>5. The system as recited in <claim-ref idref=\"CLM-00001\">claim 1</claim-ref>, wherein said multiple hit/miss predictors further operate at a dispatch level to optimize the dispatch of consumer instructions by predicting latency of data.</claim-text></claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00006\" num=\"00006\"><claim-text>6. A processor having multiple hardware streams supporting multiple data threads, the processor comprising:\n<claim-text>a data cache, comprising a plurality of levels;</claim-text>\n<claim-text>multiple hit/miss predictors, each associated with a corresponding one of the multiple hardware streams, said each configured to forecast whether corresponding instructions from said corresponding one of the multiple hardware streams will hit or miss said data cache, wherein said multiple hit/miss predictors forecast whether said corresponding instructions from said corresponding one of the multiple hardware streams will hit or miss said data cache prior to when said corresponding instructions enter into a dispatch stage in a pipeline of the processor, said each of said multiple hit/miss predictors comprising:\n<claim-text>a plurality of hit/miss predictors, each configured to forecast whether said corresponding instructions from said corresponding one of the multiple hardware streams will hit or miss one or more of said levels;</claim-text>\n</claim-text>\n<claim-text>a fetch stage, coupled to said multiple hit/miss predictors, for simultaneously fetching every cycle, instructions from one to P of the multiple hardware streams, wherein P is less than the number of the multiple hardware streams, and configured to select, on a cycle-by-cycle basis, said one to P of the multiple hardware streams from which to fetch said instructions, wherein said fetch stage selects said one to P of the multiple hardware streams based upon whether said corresponding instructions from said corresponding one of the multiple hardware streams will hit or miss said one or more of said levels; and</claim-text>\n<claim-text>an instruction scheduler, coupled to said fetch stage, for managing access for the multiple hardware streams to a set of functional resources for processing instructions from the multiple hardware streams, wherein at any point in time, said instruction scheduler manages access for a given one of the multiple hardware streams according to a priority record, regardless of any priority associated with the multiple data threads.</claim-text>\n</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00007\" num=\"00007\"><claim-text>7. The processor as recited in <claim-ref idref=\"CLM-00006\">claim 6</claim-ref>, wherein a hit prediction precipitates no change in the fetching of said instructions.</claim-text></claim>"}, {"num": 8, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00008\" num=\"00008\"><claim-text>8. The processor as recited in <claim-ref idref=\"CLM-00006\">claim 6</claim-ref>, wherein a miss prediction results in switching the fetching to different ones of the multiple hardware streams.</claim-text></claim>"}, {"num": 9, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00009\" num=\"00009\"><claim-text>9. The processor as recited in <claim-ref idref=\"CLM-00006\">claim 6</claim-ref>, wherein said each of said multiple hit/miss predictors generates a confidence level value, and said confidence level value is used by said fetch stage to select said one to P of the multiple hardware streams.</claim-text></claim>"}, {"num": 10, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00010\" num=\"00010\"><claim-text>10. The processor as recited in <claim-ref idref=\"CLM-00006\">claim 6</claim-ref>, wherein said multiple hit/miss predictors further operate at a dispatch level to optimize the dispatch of consumer instructions by predicting latency of data.</claim-text></claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00011\" num=\"00011\"><claim-text>11. In a processor having multiple hardware streams supporting multiple data threads, and a data cache, a method for simultaneously fetching instructions every cycle from one to P of the multiple hardware streams to a pipeline, where P is less than the number of the multiple hardware streams, the method comprising:\n<claim-text>for each of the multiple hardware streams, making a hit/miss prediction by a corresponding one of associated hit/miss predictors as to whether corresponding instructions for the each of the multiple hardware streams previously fetched will hit or miss the data cache, wherein said making is performed prior to when the corresponding instructions enter into a dispatch stage in the pipeline; and</claim-text>\n<claim-text>selecting, on a cycle-by-cycle basis, the one to P of the multiple hardware streams from which to fetch the instructions; and</claim-text>\n<claim-text>managing access for the multiple hardware streams to a set of functional resources for processing instructions from the multiple hardware streams, wherein at any point in time, said managing for a given one of the multiple hardware streams is accomplished according to a priority record, regardless of any priority associated with the multiple data threads.</claim-text>\n</claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00012\" num=\"00012\"><claim-text>12. The method as recited in <claim-ref idref=\"CLM-00011\">claim 11</claim-ref>, wherein said making comprises:\n<claim-text>generating a confidence level value, and employing the confidence level to select the one to P of the multiple hardware streams.</claim-text>\n</claim-text></claim>"}, {"num": 13, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00013\" num=\"00013\"><claim-text>13. The method as recited in <claim-ref idref=\"CLM-00011\">claim 11</claim-ref>, further comprising:\n<claim-text>further operating the multiple hit/miss predictors at a dispatch level to optimize the dispatch of consumer instructions by predicting latency of data.</claim-text>\n</claim-text></claim>"}, {"num": 14, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00014\" num=\"00014\"><claim-text>14. The system as recited in <claim-ref idref=\"CLM-00001\">claim 1</claim-ref>, wherein the processor comprises a fine-grained multistreaming processor that concurrently executes the instructions from the multiple hardware streams.</claim-text></claim>"}, {"num": 15, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00015\" num=\"00015\"><claim-text>15. The system as recited in <claim-ref idref=\"CLM-00001\">claim 1</claim-ref>, wherein the data cache comprises:\n<claim-text>a first level and a second level, and wherein said each of said multiple hit/miss predictors comprises:\n<claim-text>a first hit/miss predictor, configured to forecast whether said corresponding instructions from said corresponding one of the multiple hardware streams will hit or miss said first level; and</claim-text>\n<claim-text>a second hit/miss predictor, configured to forecast whether said corresponding instructions from said corresponding one of the multiple hardware streams will hit or miss said second level;</claim-text>\n</claim-text>\n<claim-text>wherein said fetch stage selects the one to P of the multiple hardware streams based upon whether said corresponding instructions from said corresponding one of the multiple hardware streams will hit or miss said second level.</claim-text>\n</claim-text></claim>"}, {"num": 16, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00016\" num=\"00016\"><claim-text>16. The system as recited in <claim-ref idref=\"CLM-00001\">claim 1</claim-ref>, wherein the processor comprises a network processor, and wherein said each of said multiple hit/miss predictors employs a flow number to which a packet belongs to forecast whether said corresponding instructions from said corresponding one of the multiple hardware streams will hit or miss the data cache.</claim-text></claim>"}, {"num": 17, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00017\" num=\"00017\"><claim-text>17. The processor as recited in <claim-ref idref=\"CLM-00006\">claim 6</claim-ref>, wherein the processor comprises a network processor, and wherein said each of said multiple hit/miss predictors employs a flow number to which a packet belongs to forecast whether said corresponding instructions from said corresponding one of the multiple hardware streams will hit or miss the data cache.</claim-text></claim>"}, {"num": 18, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00018\" num=\"00018\"><claim-text>18. The method as recited in <claim-ref idref=\"CLM-00011\">claim 11</claim-ref>, wherein said selecting comprises:\n<claim-text>switching the fetching to a different one to P of the multiple hardware streams.</claim-text>\n</claim-text></claim>"}, {"num": 19, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00019\" num=\"00019\"><claim-text>19. The method as recited in <claim-ref idref=\"CLM-00011\">claim 11</claim-ref>, wherein the data cache comprises a first level and a second level, and wherein said making comprises:\n<claim-text>first forecasting whether said corresponding instructions from the corresponding one of the multiple hardware streams will hit or miss the first level; and</claim-text>\n<claim-text>second forecasting whether the corresponding instructions from the corresponding one of the multiple hardware streams will hit or miss the second level; and</claim-text>\n<claim-text>wherein said selecting comprises:\n<claim-text>choosing the one to P of the multiple hardware streams based upon whether the corresponding instructions from the corresponding one of the multiple hardware streams will hit or miss the second level.</claim-text>\n</claim-text>\n</claim-text></claim>"}, {"num": 20, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00020\" num=\"00020\"><claim-text>20. The method as recited in <claim-ref idref=\"CLM-00011\">claim 11</claim-ref>, wherein said making comprises:\n<claim-text>employing a flow number to which a packet belongs to forecast whether the corresponding instructions from the corresponding one of the multiple hardware streams will hit or miss the data cache.</claim-text>\n</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES16251241\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><h4>CROSS REFERENCE TO RELATED DOCUMENTS</h4><p num=\"p-0002\">The present application is a continuation-in-part (CIP) of prior patent applications Ser. No. 09/216, 017, filed Dec. 16, 1998 now U.S. Pat. No. 6,477,562, Ser. No. 09/240,012, filed Jan. 27, 1999 now U.S. Pat. No. 6,292,888, Ser. No. 09/273,810, filed Mar. 22, 1999 now U.S. Pat. No. 6,389,449, and Ser. No. 09/312,302 filed May 14, 1999 now U.S. Pat. No. 7,020,879, all four of which are incorporated herein in their entirety by reference.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>FIELD OF THE INVENTION</h4><p num=\"p-0003\">The present invention is in the area of microprocessors, and pertains more particularly to structure and function of simultaneous multithreaded processors.</p><h4>BACKGROUND OF THE INVENTION</h4><p num=\"p-0004\">Multi-streaming processors capable of processing multiple threads are known in the art, and have been the subject of considerable research and development. The present invention takes notice of the prior work in this field, and builds upon that work, bringing new and non-obvious improvements in apparatus and methods to the art.</p><p num=\"p-0005\">For purposes of definition, this specification regards a stream in reference to a processing system as a hardware capability of the processor for supporting and processing an instruction thread. A thread is the actual software running within a stream. For example, a multi-streaming processor implemented as a CPU for operating a desktop computer may simultaneously process threads from two or more applications, such as a word processing program and an object-oriented drawing program. As another example, a multi-streaming-capable processor may operate a machine without regular human direction, such as a router in a packet switched network. In a router, for example, there may be one or more threads for processing and forwarding data packets on the network, another for quality-of-service (QoS) negotiation with other routers and servers connected to the network and another for maintaining routing tables and the like. The maximum capability of any multi-streaming processor to process multiple concurrent threads remains fixed at the number of hardware streams the processor supports.</p><p num=\"p-0006\">A multi-streaming processor operating a single thread runs as a single-stream processor with unused streams idle. For purposes of discussion, a stream is considered on active stream at all times the stream supports a thread, and otherwise inactive. As in various related cases listed under the cross-reference section, and in papers provided by IDS, which were included with at least one of the cross-referenced applications, superscalar processors are also known in the art. This term refers to processors that have multiples of one or more types of functional units, and an ability to issue concurrent instructions to multiple functional units. Most central processing units (CPUs) built today have more than a single functional unit of each type, and are thus superscalar processors by this definition. Some have many such units, including, for example, multiple floating point units, integer units, logic units, load/store units and so forth. Multi-streaming superscalar processors are known in the art as well.</p><p num=\"p-0007\">State-of-the-art processors typically employ pipelining, whether the processor is a single streaming processor, or a dynamic multi-streaming processor. As is known in the art, pipelining is a technique in which multiple instructions are queued in steps leading to execution, thus speeding up instruction execution. Most processors pipeline instruction execution, so instructions take several steps until they are executed. A brief description of typical stages in a RISC architecture is listed immediately below:\n</p><ul><li id=\"ul0001-0001\" num=\"0000\"><ul><li id=\"ul0002-0001\" num=\"0007\">a) Fetch stage: instructions are fetched from memory</li><li id=\"ul0002-0002\" num=\"0008\">b) Decode stage: instructions are decoded</li><li id=\"ul0002-0003\" num=\"0009\">c) Read/Dispatch stage: source operands are read from register file</li><li id=\"ul0002-0004\" num=\"0010\">d) Execute stage: operations are executed, an address is calculated or a branch is resolved</li><li id=\"ul0002-0005\" num=\"0011\">e) Access stage: data is accessed</li><li id=\"ul0002-0006\" num=\"0012\">f) Write stage: the result is written in a register</li></ul></li></ul>\n<p num=\"p-0008\">Pipeline stages take a single clock cycle, so the cycle must be long enough to allow for the slowest operation. The present invention is related to the fact that there are situations in pipelining when instructions cannot be executed. Such events are called hazards in the art. Commonly, there are three types of hazards:\n</p><ul><li id=\"ul0003-0001\" num=\"0000\"><ul><li id=\"ul0004-0001\" num=\"0014\">a) Structural</li><li id=\"ul0004-0002\" num=\"0015\">b) Data</li><li id=\"ul0004-0003\" num=\"0016\">c) Control</li></ul></li></ul>\n<p num=\"p-0009\">A structural hazard means that there are not adequate resources (e.g., functional units) to support the combination of instructions to be executed in the same clock cycle. A data hazard arises when an instruction depends on the result of one or more previous instructions not resolved. Forwarding or bypassing techniques are commonly used to reduce the impact of data hazards. A control hazard arises from the pipelining of branches and other instructions that change the program counter (PC). In this case the pipeline may be stalled until the branch is resolved.</p><p num=\"p-0010\">Stalling on branches has a dramatic impact onto processor performance (measured in instructions executed per cycle or IPC). The longer the pipelines and the wider the superscalar, the more substantial is the negative impact. Since the cost of stalls is quite high, it is common in the art to predict the outcome of branches. Branch predictors predict branches as either taken or untaken and the target address. Branch predictors may be either static or dynamic. Dynamic branch predictors may change prediction for a given branch during program execution.</p><p num=\"p-0011\">A typical approach to branch prediction is to keep a history for each branch, and then to use the past to predict the future. For example, if a given branch has always been taken in the past, there is a high probability that the same branch will be taken again in the future. On the other hand, if the branch was taken 2 times, not taken 5 times, taken again once, and so forth, the prediction made will have a low confidence level. When the prediction is wrong, the pipeline must be flushed, and the pipeline control must ensure that the instructions following the wrongly guessed branch are discarded, and must restart the pipeline from the proper target address. This is a costly operation.</p><p num=\"p-0012\">Multistreaming processor architectures may be either fine-grained or coarse-grained. Coarse-grained multistreaming processors typically have multiple contexts, which are used to cover long latencies arising, for example, due to cache misses. Only a single thread is executing at a given time. In contrast, fine-grained multistreaming technologies such as Dynamic Multi-Streaming (DMS), which is a development of XStream Logic, Inc., with which the present inventors are associated, allow true multi-tasking or multistreaming in a single processor, concurrently executing instructions from multiple distinct threads or tasks. DMS processors implement multiple sets of CPU registers or hardware contexts to support this style of execution.</p><p num=\"p-0013\">Increasing the relative amount of instruction level parallelism (ILP) for a processor reduces data and control hazards, so applications can exploit increasing number of functional units during peak levels of parallelism, and Dynamic Multi-Streaming (DMS) hardware and techniques within today's general-purpose superscalar processors significantly improves performance by increasing the amount of ILP, and more evenly distributing it within workload. There are still occasions, however, for degraded performance due to poor selection in fetching and dispatching instructions in a DMS processor.</p><p num=\"p-0014\">What is clearly needed is improved methods and apparatus for utilizing hit/miss prediction in pipelines in dynamic multi-streaming processors, particularly at the point of fetch and dispatch operations.</p><h4>SUMMARY OF THE INVENTION</h4><p num=\"p-0015\">In a preferred embodiment of the present invention, in a multi-streaming processor having a data cache, a system for fetching instructions from individual ones of the multiple streams to a pipeline is provided, comprising a fetch algorithm for selecting from which stream to fetch instructions, and a hit/miss predictor for forecasting whether instructions will hit or miss the data cache. The prediction by the hit-miss predictor is used by the fetch algorithm in determining from which stream to fetch.</p><p num=\"p-0016\">In preferred embodiments a hit prediction precipitates no change in the fetching process, while a miss prediction results in switching fetching to a different stream. In some cases the hit-miss predictor determines a hit probability, and the probability is used by the fetch algorithm in determining from where to fetch next instructions. In some other embodiments the forecast of the hit/miss predictor is also used by a dispatch algorithm in selecting instructions from the pipeline to dispatch to functional units.</p><p num=\"p-0017\">In another aspect of the invention a multi-streaming processor is provided, comprising a data cache, a fetch algorithm for selecting from which stream to fetch instructions, and a hit/miss predictor for predicting whether instructions will hit or miss the cache. A prediction by the hit-miss predictor is used by the fetch algorithm in determining from which stream to fetch.</p><p num=\"p-0018\">In preferred embodiments of the invention a hit prediction precipitates no change in the fetching process, while a miss prediction results in switching fetching to a different stream. In some embodiments the hit-miss predictor determines a hit probability, and the probability is used by the fetch algorithm in determining from where to fetch instructions.</p><p num=\"p-0019\">In some embodiments the forecast of the hit/miss predictor is also used by a dispatch algorithm in selecting instructions from the pipeline to dispatch to functional units.</p><p num=\"p-0020\">In yet another aspect of the invention, in a multi-streaming processor having a data cache, a method for fetching instructions from individual ones of multiple streams as instruction sources to a pipeline is provided, comprising the steps of (a) making a hit/miss prediction by a predictor as to whether instructions previously fetched will hit or miss the data cache; and (b) if the prediction is a miss, altering the source of the fetch. In some embodiments the hit-miss predictor determines a hit probability, and the probability is used in determining fetch source. In other embodiments the forecast of the hit/miss predictor is also used by a dispatch algorithm in selecting instructions to dispatch to functional units.</p><p num=\"p-0021\">In embodiments of the invention taught in enabling detail below, for the first time a prediction technique is brought to the process of fetching and dispatching instruction in multistreaming processors.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><description-of-drawings><h4>BRIEF DESCRIPTION OF THE DRAWING FIGURES</h4><p num=\"p-0022\"><figref idrefs=\"DRAWINGS\">FIG. 1</figref><i>a </i>is a simplified diagram of a pipeline in an embodiment of the present invention.</p><p num=\"p-0023\"><figref idrefs=\"DRAWINGS\">FIG. 1</figref><i>b </i>shows the pipeline of <figref idrefs=\"DRAWINGS\">FIG. 1</figref><i>a </i>after a cycle.</p><p num=\"p-0024\"><figref idrefs=\"DRAWINGS\">FIG. 1</figref><i>c </i>shows the pipeline of <figref idrefs=\"DRAWINGS\">FIGS. 1</figref><i>a </i>and <b>1</b><i>b </i>after another cycle.</p><p num=\"p-0025\"><figref idrefs=\"DRAWINGS\">FIG. 1</figref><i>d </i>shows the pipeline of <figref idrefs=\"DRAWINGS\">FIGS. 1</figref><i>a, </i><b>1</b><i>b </i>and <b>1</b><i>c </i>after yet another cycle.</p><p num=\"p-0026\"><figref idrefs=\"DRAWINGS\">FIG. 2</figref> is a schematic diagram associating predictors with streams in an embodiment of the present invention.</p><p num=\"p-0027\"><figref idrefs=\"DRAWINGS\">FIG. 3</figref> is a schematic showing predictors for different levels in cache.</p><p num=\"p-0028\"><figref idrefs=\"DRAWINGS\">FIG. 4</figref> is a schematic illustrating benefits of the technique in embodiments of the invention</p></description-of-drawings><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DESCRIPTION OF THE PREFERRED EMBODIMENTS</h4><p num=\"p-0029\"><figref idrefs=\"DRAWINGS\">FIG. 1</figref><i>a </i>is a simplified diagram of a pipeline in a dynamic, multi-streaming (DMS) processor according to an embodiment of the present invention. In this simplified view the pipeline has seven stages, which are fetch, decode, read, dispatch, execute, access and write. These are the same as described in the background section above, except for the separation of read and dispatch in <figref idrefs=\"DRAWINGS\">FIG. 1</figref><i>a </i>to illustrate the functions. Dispatch is important in the present invention in that the present invention adds intelligence to Dispatch, improving the performance of the processor. The fetch stage in the pipeline fetches instructions into the pipeline from the multiple streams, and in an embodiment of the present invention is capable of selective fetching.</p><p num=\"p-0030\">Although there is no requirement in operating processors that there be instructions at each stage of a pipeline, it is often true that this is the case, and the inventors choose to illustrate each stage as occupied by a single instruction to avoid confusion in description. In many cases there will be a plurality of instructions at various stages, or none at all.</p><p num=\"p-0031\">In <figref idrefs=\"DRAWINGS\">FIG. 1</figref><i>a </i>the instructions in the pipeline are arbitrarily indicated as instructions A through G, at successive stages in the pipeline at one point in time. <figref idrefs=\"DRAWINGS\">FIG. 1</figref><i>b </i>shows the pipeline of <figref idrefs=\"DRAWINGS\">FIG. 1</figref><i>a </i>one cycle later. Note that instruction A has moved from fetch to decode, and the other instructions shown in <figref idrefs=\"DRAWINGS\">FIG. 1</figref><i>a </i>have moved one stage forward as well. Also, a new instruction, H, has entered the pipeline at the fetch stage.</p><p num=\"p-0032\"><figref idrefs=\"DRAWINGS\">FIG. 1</figref><i>c </i>shows the same pipeline one cycle later. All instructions have moved forward one further stage, and a new instruction I has entered the pipeline at the fetch stage. <figref idrefs=\"DRAWINGS\">FIG. 1</figref><i>d </i>shows the same pipeline after yet another cycle, at which point in time the instructions have moved forward yet again, and yet another instruction J has entered the pipeline.</p><p num=\"p-0033\">Note that after the fourth cycle, instruction A has moved from fetch to dispatch. Assume for the sake of this example that instruction A is a load instruction for loading a data value from cache. If this is the case, there will be some probability as to whether the particular data is in cache or not. In the art this is known as the hit/miss probability. If the data is in the cache, the system scores a hit. If not, the system scores a miss.</p><p num=\"p-0034\">The combination of hit/miss probability for load operations with pipelined architecture has significance for processor efficiency, because, in the conventional case the general sequence of instructions in the pipeline will be from a single thread, and will typically be related in that many instructions following a load instruction may depend upon the result of whatever instruction is to use the data loaded. That is, until the resolution of whatever instruction is to use the data loaded, many following instructions cannot be executed, except in some cases, on a speculative basis.</p><p num=\"p-0035\">Conventional processors simply assume a hit when a load instruction enters a pipeline. If the load is a miss, however, once the load instruction is executed, then it may take a number of cycles for the needed data, not in cache, to be loaded from memory. And, unfortunately, the miss will not be apparent until the load instruction is dispatched and executed. The following instructions have to stall until the data is loaded and the instruction(s) depending on the data are executed.</p><p num=\"p-0036\">The present inventors provide apparatus and method for reducing the impact of data cache misses in multithreaded architectures. The technique consists of predicting, for each of the threads running in the multiple streams of the DMS, whether the next access to the data cache will result in a miss. If this is the case, then (generally):\n</p><ul><li id=\"ul0005-0001\" num=\"0000\"><ul><li id=\"ul0006-0001\" num=\"0045\">The stream can be given a lower priority when deciding, in the fetch stage, from which stream to fetch, and</li><li id=\"ul0006-0002\" num=\"0046\">The dependent instructions of the instruction that accesses the data cache can be more efficiently dispatched to the functional units (FU's) in the dispatch stage.</li></ul></li></ul>\n<p num=\"p-0037\">This new apparatus and technique improves the performance of a multistreaming processor in the fetching and dispatching of instructions.</p><p num=\"h-0007\">Fetch</p><p num=\"p-0038\">The new technique takes advantage of the fact that, in a DMS processor, as instructions are fetched to the pipeline from individual ones of the streams, there is freedom in choosing a fetching policy or algorithm that will select, on a cycle-by-cycle basis, from which stream instructions are to be fetched.</p><p num=\"p-0039\">In a multistreaming architecture, without the technique proposed here, a typical event that causes a thread switch is a data cache miss. Since the required data may take several cycles to be available (the exact number depending on where the data really resides in the memory hierarchy of the processor), the thread that missed the data cache may be switched out since the dependent instructions of the instruction that missed most likely will not execute due to the dependencies on the data. Thus, more work can be done by fetching and executing instructions from another thread. In this case, the instructions following the one that missed, and that have already been fetched, will need to be flushed out, thus degrading the performance of the processor with respect to the case in which useful instructions had been fetched.</p><p num=\"p-0040\">If the fact that an instruction will miss the data cache could be known early in the process the fetching of instructions that might eventually be flushed may be avoided by fetching, instead of the instructions following the instruction that missed the data cache, instructions from another stream, improving the likelihood that the fetched instructions may be quickly executed. Thus, a fetching algorithm, in an embodiment of the present invention, may take into account, for all the streams, the predictions on whether the next access will miss the data cache, and fetch from the stream running a thread that is most likely to have its instructions executed and committed.</p><p num=\"p-0041\">There already exist in the art a variety of implementations for hit-miss predictors. The goal, however, is always the same: to predict with the highest accuracy both the hits and misses to the data cache. Moreover, a desirable property of such a predictor is to be able to predict the next access to the data cache as soon as possible so that fewer instructions (that would eventually be flushed out) will enter the pipeline.</p><p num=\"p-0042\">The technique taught herein can be improved by associating a confidence level to the prediction. The predictor, in one embodiment of the invention, operating at the fetch stage, in addition to predicting also generates this confidence level value. The confidence level helps the fetching algorithm, for example, in cases in which two or more predictors predicted a miss in the data cache and one is selected to be switched out. In this case, the stream with higher confidence level will be selected.</p><p num=\"p-0043\"><figref idrefs=\"DRAWINGS\">FIG. 2</figref> is a schematic diagram of a fetching algorithm in a multistreaming architecture. The multistreaming architecture corresponds to a processor having multiple hardware streams STREAM <b>1</b>-STREAM S supporting multiple data threads and a data cache (not shown). The schematic diagram shows a system according to the present invention for fetching instructions from one to P of the multiple hardware streams STREAM <b>1</b>-STREAM S, where P is less than the number of multiple hardware streams STREAM <b>1</b>-STREAM S. The diagram shows multiple hit/miss predictors PRED <b>1</b>-PRED S, each associated with a corresponding one of the multiple hardware streams STREAM <b>1</b>-STREAM S, and each configured to forecast whether corresponding instructions from the corresponding one of the multiple hardware streams STREAM <b>1</b>-STREAM S will hit or miss the data cache, where the multiple hit/miss predictors PRED <b>1</b>-PRED S forecast whether the corresponding instructions from the corresponding one of the multiple hardware streams will hit or miss the data cache prior to when the corresponding instructions enter into a dispatch stage (not shown) in the pipeline. The diagram also shows a fetch stage that is coupled to the multiple hit/miss predictors PRED <b>1</b>-PRED S. The fetch stage is configured to simultaneously fetch every cycle, the instructions from the one to P of the multiple hardware streams STREAM <b>1</b>-STREAM S to the pipeline. The fetch stage is additionally configured to select, on a cycle-by-cycle basis, the one to P of the multiple hardware streams STREAM <b>1</b>-STREAM S from which to fetch the instructions. The diagram also depicts an instruction scheduler that is coupled to the fetch stage. The instruction scheduler manages access for the multiple hardware streams STREAM <b>1</b>-STREAM S to a set of functional resources (not shown) for processing instructions from the multiple hardware streams STREAM <b>1</b>-STREAM S, where at any point in time, said instruction scheduler manages access for a given one of the multiple hardware streams STREAM <b>1</b>-STREAM S according to a priority record within a priority file, regardless of any priority associated with the multiple data threads. The fetch stage includes a fetch algorithm. The algorithm decides from which stream(s) STREAM <b>1</b>-STREAM S to fetch based on cache hit/miss predictors associated to each of the streams STREAM <b>1</b>-STREAM S. In <figref idrefs=\"DRAWINGS\">FIG. 2</figref> a predictor PRED <b>1</b>-PRED Sis associated with streams <b>1</b>, <b>2</b>, and so on through stream S. Thus, theoretically, instructions from up to S streams STREAM <b>1</b>-STREAM S (S being the maximum number of streams STREAM <b>1</b>-STREAM S supported by the multistreaming architecture) can be simultaneously fetched every cycle. In reality, however, the fetching algorithm might be restricted to fetch instructions from P streams (P&lt;S) due to implementation restrictions (for example, availability of instruction cache ports). Moreover, the fetching algorithm might select from which streams to fetch based on other information (for example, confidence on the branch predication of each stream, thread priorities, state of the pipeline, etc.)</p><p num=\"p-0044\">So far, we have mentioned predictors of hit/miss for the data cache. Note that the data cache might be implemented for performance reasons in different levels (the first level\u2014L<b>1</b>\u2014being the closest to the processor core). In alternative embodiments of the invention different hit/miss predictors may exist for each of the data cache levels.</p><p num=\"p-0045\">The fetching algorithm in alternative embodiments of the present invention may base selection of instructions to be fetched on the prediction for the second level\u2014L<b>2</b>\u2014of data cache since, in most processor systems, a miss in the second level of cache is very costly in number of cycles (whereas the penalty of a miss in the L<b>1</b> is comparatively relatively small).</p><p num=\"h-0008\">Dispatch</p><p num=\"p-0046\">The technique of having a data cache hit/miss predictor is also useful in the process of deciding, at the dispatch stage in the pipeline, which instructions are to be extracted from the instruction queue (if any) and sent to the functional units (FUs) for execution.</p><p num=\"p-0047\">In current art, when an instruction (henceforth called a producer) generates a read access to the data cache, the latency of the result is not known until the data cache is accessed and the hit/miss outcome is determined. The dispatch of a dependent instruction (henceforth termed a consumer) on the data generated by the producer can follow two policies:\n</p><ul><li id=\"ul0007-0001\" num=\"0000\"><ul><li id=\"ul0008-0001\" num=\"0058\">a) Dispatch the instruction only when it is guaranteed that the data will be available.</li><li id=\"ul0008-0002\" num=\"0059\">b) Dispatch the instruction assuming that the producer will hit in the first level of the data cache.</li></ul></li></ul>\n<p num=\"p-0048\">Policy (b), then, dispatches the consumer instruction speculatively (a hit is always assumed for the producer instruction since the hit ratio in a cache is usually very high). If the consumer instruction arrives to the FU and the data is still not available, the instruction has to either stall at the FU or be rescheduled for dispatch in a later cycle (this option will allow other non-dependent instructions to be dispatched to the FU). In any case, both options degrade the performance of the processor.</p><p num=\"p-0049\">Policy (a) provides the lowest performance since the consumer instruction might be unnecessarily stalled before it is dispatched. The consumer instruction will be dispatched as soon as the producer hits in the data cache or, in case it misses, when the missing data arrives from the next level of memory hierarchy. On the other hand, this policy provides the simplest implementation, since no re-scheduling will occur.</p><p num=\"p-0050\">In an embodiment of the present invention a hit/miss predictor enhances the performance of policy (b) by predicting whether the producer will hit in the data cache. Thus, the consumer instructions of a producer that is predicted to miss in the data cache will be dispatched following policy (a). If the producer instruction is predicted to hit, then the dispatch policy is (b). In this case, however, the re-scheduling logic is still needed in case the predictor is incorrect. Only in the case in which the prediction is a hit but the real outcome is a miss, the consumer instructions will need to be either stalled at the FUs or re-scheduled.</p><p num=\"p-0051\">In general, the hit/miss predictor operating at the dispatch level optimizes the dispatch of consumer instructions by predicting the latency of the data. If a hit in the L<b>1</b> is predicted, the latency of the data is predicted to be the latency of the L<b>1</b> cache. If a miss is predicted, the predicted latency of the data depends on whether more levels of cache exist and on whether a hit/miss predictor exists for each of these levels. If, for example, two levels of cache exist and the hit/miss outcome of the L<b>2</b> is also predicted, the predicted latency of the data is computed as shown in <figref idrefs=\"DRAWINGS\">FIG. 3</figref> (Note: the necessary cycles, if any, to bring the data from the output of the cache to the input of the functional unit where the consumer will be executed need to be added to the predicted latency of the data).</p><p num=\"p-0052\">The benefits of a hit/miss predictor for dispatch logic are not restricted to multistreaming processors only, but in a multistreaming processor where the technique has larger benefits than in a conventional (single-streaming) processor architecture. In a conventional processor having a data hit/miss predictor, when a data cache miss is predicted, no instructions (in case of an in-order dispatch engine), or only those that do not depend on the missing data (in case of an out-of-order dispatch engine) can execute. In any case, the processor resources might be idle for several cycles until the missing data is available. In multistreaming processors those idle cycles can be used to execute other instructions from other threads since they do not depend on the missing data. Thus, for a multistreaming processor, the benefits of a data cache hit/miss predictor are twofold as shown in <figref idrefs=\"DRAWINGS\">FIG. 4</figref>.</p><p num=\"p-0053\">In alternative embodiments of the invention the prediction can be done differently at the fetch and dispatch stages (i.e. using different information on which to base the prediction and/or using a different prediction algorithm). As an example, the prediction at the dispatch stage could use the program counter (PC) address of the consumer instruction (since the instruction has already been decoded and its PC is known) and could follow an algorithm similar to the prediction schemes used in branch prediction. The prediction at the fetch stage may use another type of address (cache line, for example) or other non-address information.</p><p num=\"p-0054\">The prediction algorithm in different embodiments may vary depending on the workload that the processor has to efficiently support. For traditional applications, like Windows programs or SPEC benchmarks, similar algorithms to those used in branch prediction may produce the desired prediction accuracy in both hits and misses. For other types of workloads, like packet processing applications in network processors, the predictors can take advantage of additional information, like the flow number to which the packet being processed belongs (the data cache accesses performed by the processing of the first packet(s) of a new flow most likely will miss).</p><p num=\"p-0055\">It will be apparent to the skilled artisan that there are many alterations that might be made in the embodiments of the invention taught herein without departing from the spirit and scope of the invention. The hit-miss predictors may be implemented in various ways, for example, and different actions may be taken based on assigned probabilities. Further, the predictors may be used at different levels in a pipeline. For example, a predictor may have input from a decode stage, and output to a fetch algorithm. Further, the mechanisms to accomplish different embodiments of the invention may be implemented typically in either hardware or software. There are similarly many other alterations that may be made within the spirit and scope of the invention. The invention should be accorded the scope of the claims below.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Enric", "last_name": "Musoll", "name": ""}, {"first_name": "Mario", "last_name": "Nemirovsky", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "MIPS TECHNOLOGIES, INC."}, {"first_name": "", "last_name": "ARM FINANCE OVERSEAS LIMITED", "name": ""}, {"first_name": "", "last_name": "BRIDGE CROSSING, LLC", "name": ""}, {"first_name": "", "last_name": "MIPS TECHNOLOGIES, INC.", "name": ""}, {"first_name": "", "last_name": "JEFFERIES FINANCE LLC, AS COLLATERAL AGENT", "name": ""}, {"first_name": "", "last_name": "MIPS TECHNOLOGIES, INC.", "name": ""}, {"first_name": "", "last_name": "CLEARWATER NETWORKS, INC.", "name": ""}, {"first_name": "", "last_name": "XSTREAM LOGIC, INC.", "name": ""}], "ipc_classes": [], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/30        20060101AFI20070626BHUS"}], "national_classes": [{"primary": true, "label": "712205"}, {"primary": false, "label": "712E09051"}, {"primary": false, "label": "712E09053"}], "ecla_classes": [{"label": "G06F   9/38E4"}, {"label": "G06F   9/38E2D"}], "cpc_classes": [{"label": "G06F   9/3844"}, {"label": "G06F   9/3802"}, {"label": "G06F   9/3844"}, {"label": "G06F   9/3851"}, {"label": "G06F   9/3802"}, {"label": "G06F   9/3851"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1998-12-16", "application_date": "2000-06-16", "family_members": [{"ucid": "US-7237093-B1", "titles": [{"lang": "EN", "text": "Instruction fetching system in a multithreaded processor utilizing cache miss predictions to fetch instructions from multiple hardware streams"}]}]}