{"patent_number": "US-6237087-B1", "publication_id": 72677731, "family_id": 22593123, "publication_date": "2001-05-22", "titles": [{"lang": "EN", "text": "Method and apparatus for speeding sequential access of a set-associative cache"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72559330\"><p>An embodiment of the invention is directed at a method for accessing a cache by detecting a branch instruction having an address and containing a first set of bits representing a displacement value, and generating a modified instruction containing a second set of bits representing a combination based on the first set of bits and the address.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00001\" num=\"1\"><claim-text>1. A method comprising:</claim-text><claim-text>detecting a branch instruction having an address and containing a first set of bits representing a displacement value; and </claim-text><claim-text>generating a modified instruction containing a second set of bits representing a combination based on said first set of bits and said address. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00002\" num=\"2\"><claim-text>2. A method as in claim <b>1</b> further comprising:</claim-text><claim-text>storing said modified instruction in a cache. </claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00003\" num=\"3\"><claim-text>3. A method as in claim <b>2</b> wherein the second set of bits represents the addition of a low order portion of said address to a low order portion of said displacement value to obtain a modified displacement value.</claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00004\" num=\"4\"><claim-text>4. A method as in claim <b>3</b> further comprising:</claim-text><claim-text>including a carry bit from said addition as part of said modified instruction. </claim-text></claim>"}, {"num": 5, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00005\" num=\"5\"><claim-text>5. A method as in claim <b>3</b> further comprising:</claim-text><claim-text>retrieving said modified instruction from said cache and adding a high order portion of said address to a high order portion of said modified displacement value. </claim-text></claim>"}, {"num": 6, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00006\" num=\"6\"><claim-text>6. A method as in claim <b>3</b> further comprising:</claim-text><claim-text>accessing said cache to retrieve said modified instruction, wherein the generation of said modified instruction occurs concurrently with accessing said cache. </claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00007\" num=\"7\"><claim-text>7. A method as in claim <b>1</b> wherein said displacement value is positive.</claim-text></claim>"}, {"num": 8, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00008\" num=\"8\"><claim-text>8. A method as in claim <b>2</b> wherein a size of said displacement value is greater than or equal to the number of bits required to access the cache.</claim-text></claim>"}, {"num": 9, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00009\" num=\"9\"><claim-text>9. A method as in claim <b>2</b> wherein a size of said displacement value is less than the number of bits required to access said cache.</claim-text></claim>"}, {"num": 10, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00010\" num=\"10\"><claim-text>10. A method as in claim <b>1</b> wherein said branch instruction is a PC-relative branch.</claim-text></claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00011\" num=\"11\"><claim-text>11. A processor comprising:</claim-text><claim-text>a cache; </claim-text><claim-text>an instruction modification unit to modify an instruction by combining a plurality of the low order bits of an instruction's displacement value with a plurality of the low order bits of an instruction's address, and to store a resulting modified instruction in the cache; </claim-text><claim-text>a first register to store an upper portion of an instruction pointer, and coupled to access the cache; </claim-text><claim-text>a decoder coupled to an output of the cache, to provide a first group of bits representing a plurality of high order bits of a modified instruction's displacement value stored in the cache; </claim-text><claim-text>an adder coupled to an output of the decoder and the output of the first register, to combine the first group of bits with the contents of the first register. </claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00012\" num=\"12\"><claim-text>12. The processor of claim <b>11</b> wherein the instruction's displacement value is positive.</claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00013\" num=\"13\"><claim-text>13. The processor of claim <b>12</b> wherein the instruction's displacement size is greater than or equal to the number of bits required to address the cache.</claim-text></claim>"}, {"num": 14, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00014\" num=\"14\"><claim-text>14. The processor of claim <b>12</b> wherein the instruction's displacement size is less than the number of bits required to address the cache.</claim-text></claim>"}, {"num": 15, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00015\" num=\"15\"><claim-text>15. The processor of claim <b>11</b> further comprising:</claim-text><claim-text>logic coupled to the instruction modification unit to detect branch instructions from among other types of instructions. </claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00016\" num=\"16\"><claim-text>16. The processor of claim <b>15</b> wherein the branch detection logic can detect PC-relative branch instructions.</claim-text></claim>"}, {"num": 17, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00017\" num=\"17\"><claim-text>17. The processor of claim <b>11</b> further comprising:</claim-text><claim-text>a second register to store a lower portion of the instruction pointer, and coupled to access the cache; </claim-text><claim-text>a first incrementer having an input coupled to the output of said first register; </claim-text><claim-text>a first selector having inputs coupled to the first incrementer and the adder, and having an output coupled to the first register, such that a content of the first register is replaced by its incremented value or by the addition of a content of the first register and a plurality of high order bits of the modified instruction's displacement value; </claim-text><claim-text>a second incrementer having an input coupled to the output of said second register; </claim-text><claim-text>a second selector having an input coupled to the second incrementer, another input coupled to said decoder to receive a second group of bits, representing some low order bits of the modified instruction's displacement value, and an output coupled to said second register, such that a content of the second register is replaced by its incremented value or by a plurality of low order bits of the modified instruction's displacement value. </claim-text></claim>"}, {"num": 18, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6237087-B1-CLM-00018\" num=\"18\"><claim-text>18. The processor of claim <b>11</b> wherein:</claim-text><claim-text>said cache contains set selection logic with an input coupled to said first register and hit detection logic with an input coupled to said second register.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54548685\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention is related to the field of use of caches. More particularly, this invention is directed to a method and apparatus for speeding sequential access of a set-associative cache in a pipelined processor.</p><p>2. Description of Related Art</p><p>Currently, many processors are implemented with a pipelined architecture. These pipelined processors may also include one or more caches, such as an instruction cache for storing instructions for faster access. In such an architecture, there are distinct steps that an instruction undergoes as it is processed. Typically, these include: (1) loading the instruction from main memory into the instruction cache; (2) fetching the instruction from the instruction cache; (3) decoding the instruction; and (4) executing the instruction.</p><p>One instruction that often needs to be processed is an instruction pointer (IP) relative branch instruction. IP-relative branch instructions are conditional or unconditional branch instructions that compute the target address of the branch (the address of the next instruction to be executed if the branch is taken, also known as the \u201cbranch target\u201d) by adding a value extracted from the branch instruction itself to the address contained in the instruction pointer (which is address of the branch instruction). The IP-relative branch instruction is a common form of branch instruction in many computer instruction sets. In this context, branch instructions may include call and branch-and-link instructions.</p><p>The computation of the target address typically occurs in either the instruction decode step or in a subsequent execution step. FIG. 1 contains a target address computation unit <b>100</b> that illustrates how this processing occurs. Target address computation unit <b>100</b> contains an IP register <b>110</b>; a direct-mapped cache <b>112</b> including a set of cache tags <b>114</b>, cache data <b>116</b> and a hit detection unit <b>117</b>; a decoder <b>118</b>; an adder <b>120</b> for calculating the branch target address; an incrementer <b>122</b> for handling non-branch cases; and a selector <b>124</b> that determines whether the next IP is obtained from incrementer <b>122</b> or adder <b>120</b>. For an IP-relative branch, the circuit shown in FIG. 1 functions by beginning with some number of the less-significant bits (LSb's) of the IP (but not necessarily the least significant bits), sufficient to select one line from the plurality of lines in cache <b>112</b>, being sent to the address inputs of the storage arrays that hold set of cache tags <b>114</b> and cache data <b>116</b>. The remaining more significant bits (MSb's) of the IP are sent to hit detection unit <b>117</b>, where they are compared with the tag of the accessed cache line to determine whether a cache hit occurred (that is, whether the instruction referenced by the IP is contained in cache <b>112</b>).</p><p>Assuming a hit occurred, decoder <b>118</b> determines whether the instruction is a branch instruction and sends the displacement from the instruction word that is read out of cache <b>112</b> to adder <b>120</b>. The displacement is then added to the IP. Assuming the branch is taken, selector <b>124</b>, which is under control of other logic (not shown), routes the output of adder <b>120</b> to IP register <b>110</b>, where it becomes the next IP when the load signal is sent to IP registers <b>110</b>. If the instruction is not a branch instruction or if the instruction contains a branch that is not taken, then the output of incrementer <b>122</b> becomes the next IP.</p><p>FIG. 1 illustrates shows the operation of a typical instruction cache. Two separate processes are involved: the process by which information is placed in the instruction cache, and the process by which information is fetched from the instruction cache. The two arrows coming into the top of cache <b>112</b> represent the process of putting information into cache <b>112</b>. The information consists of an address and the data that is contained in that address in a main memory. Assuming cache <b>112</b> is a simple cache where cache lines are filled all at once, information is placed in the set-associative cache by the following process:</p><p>1) The set that the address belongs to is determined. The set is a function of a group of bits in the address. Generally, these are the least significant bits beyond those bits needed to identify an offset within the cache line, sufficient to address all the sets in the cache. For example, if a cache line is 32 bytes, then 5 bits of address are needed to identify where in the cache line data is, so the sixth bit and up are used to select which set to use. If there are 128 sets (the number of sets is essentially always a power of two) then 7 bits would be needed to select one set. In this example, the sixth through twelfth least significant bits would select which set to use.</p><p>2) A line within that set is chosen. The selection of which line to use can be done via a number of different algorithms, such as Least-Recently-Used, Least-Recently-Written, Circular, or another algorithm that is known by one of ordinary skill in the art. In a direct mapped cache, there is only one line per set, so the selection process is trivial.</p><p>3) The data is written into the selected cache line's data storage, and the more significant bits (those not used in the selection of a byte within a line nor in the selection of which set to use) are placed in the tag for that line.</p><p>One exemplary process of fetching information from cache <b>112</b> proceeds as follows:</p><p>1) The address of the next information desired from cache <b>112</b> is generated. If a branch has not occurred, this is done by incrementing the previous address that was used. If a branch has occurred, then the computed target address of the branch is used. For the type of branches covered by this invention, the branch target address is generated by adding a displacement contained within the instruction to the address of the instruction (or, in some architectures, the address of the next instruction that would have been executed if the branch had not been taken.) The displacement is extracted from the instruction via decoder <b>118</b>. Incrementer <b>122</b>, adder <b>120</b>, selector <b>124</b> and IP Register <b>110</b> of FIG. 1 are used to perform the function of generating the needed address, under the control of logic not shown in the diagram. If another form of branch is possible (such as a return from subroutine, or, a branch to an address specified by a general purpose register), then another input to selector <b>124</b> would be used to route the address generated by that branch into the circuit. This is not shown in the diagram but is obvious to one of ordinary skill in the art.</p><p>2) The bits of the generated address needed to select the set are fed into cache <b>112</b>. In the example given above, these are the sixth through twelfth least significant bits. These bits select the lines belonging to one set, all of which then drive their tags and data out.</p><p>3) The tags coming out of the lines are compared to the more significant bits (in the example, the thirteenth least significant bit and all more significant bits) to determine whether a cache hit has occurred. If one of the lines from the set produces a hit, then the needed data is selected from its data using the least significant bits below those used to select the set (the fifth least significant bit and those bits less significant than it).</p><p>4) This fetched data is then fed into decoder <b>118</b>, as described for first step of execution.</p><p>In an address computation unit such as target address computation unit <b>100</b> of FIG. 1, the cache access and the decode/adder stages would often be implemented in separate pipestages. Thus, a target address of a branch instruction is not immediately available at the beginning of the clock cycle after the cycle in which instruction was fetched from cache <b>112</b>. This in turn means that the instruction that would be executed immediately after the branch, if the branch is taken, can not be fetched in the cycle after the branch instruction was fetched. This causes one or more clock cycle during which no new instruction is issued into the execution stages of the pipeline. This problem has been termed a \u201ccontrol hazard\u201d.</p><p>In one attempt to overcome problems such as control hazards, a \u201cbranch-target buffer\u201d may be provided. However, branch-target buffers are generally expensive and complex devices. Thus, branch target buffers generally contain many devices, which also adds cost and complexity to the testing and deployment phases of the integrated circuit.</p><p>A more efficient mechanism for speeding sequential access of a set-associative cache in a pipelined processor is thus desired.</p><h4>SUMMARY</h4><p>An embodiment of the invention is directed at a method for accessing a cache by detecting a branch instruction having an address and containing a first set of bits representing a displacement value, and generating a modified instruction containing a second set of bits representing a combination based on the first set of bits and the address.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 is a block diagram of a prior art target address computation unit.</p><p>FIG. 2 is a diagram of a transformation of an instruction in accordance with one embodiment of the present invention.</p><p>FIG. 3 is a block diagram of the system for speeding sequential access of the cache configured in accordance with one embodiment of the present invention.</p><p>FIG. 4 is a block diagram of the system for speeding sequential access of the cache configured in accordance with another embodiment of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION</h4><p>The described system takes advantage of the fact that the target address of an IP-relative branch may be determined entirely by the instruction itself and the address from which the instruction was fetched. Typically, the information is available within a processor anytime after the instruction has been fetched from main memory and before the instruction is actually loaded into the instruction cache. Therefore, the processor could recognize that a word just loaded from memory was an IP-relative branch. The processor could then pre-compute the target address of that branch using the address of the instruction and whatever portion of the instruction specifies the offset, and then store the pre-computed target address for later use at the same time as it stored the fetched instruction into the instruction cache. One problem that arises is how to provide storage for the pre-computed target address, which in its entirety might be significantly larger than the instruction itself.</p><p>The described system takes advantage of the nature of set-associative caches (which includes direct-mapped caches as those are set-associative caches containing only 1 set), and the reversibility of the target address calculation, to store the necessary portion of the pre-computed target address with only a small increase in the amount of storage needed. The relevant feature of a set-associative cache is that only a part of the address, generally the less-significant bits, is used to determine which line or lines of the cache information will be found in, and which section of the line or lines the desired data might be in. Thus, data may be fetched from a set-associative cache without knowing what some of the more-significant bits of the address are. These more-significant bits are used to confirm whether the data fetched from the cache is the desired data, and not where in the cache from which to fetch the data.</p><p>If enough of the target address of the branch is pre-computed to identify where in the cache the target of the branch might be found, then that information may be fed directly into the cache address lines without needing an addition step. Then, as the access to the cache storage cells is proceeding, an add may be performed that generates the remaining bits of the branch address that are used to determine if the data fetched is really the data desired.</p><p>Assuming that the displacement in the branch instruction contains sufficient bits to completely determine the location(s) in the cache that might hold the instruction at the target address of the branch, then the displacement may be added to the IP of the instruction that contains it before it is stored into the cache, and the result of that addition used to replace the displacement within the cache. However, the addition may produce a carry that must be preserved. Thus, it may be possible to use an otherwise unused bit in the instruction to contain this carry, as shown in FIG. 2; or by using unused opcodes to distinguish, for example, a partly pre-computed branch with a carry from one without. Failing that, extra bits may be added to the instruction cache to store the carry. These bits may be added to every instruction-sized storage unit in the cache, or kept in a separate pre-computed-carry cache, accessed via the branch instruction's IP, to save space.</p><p>FIG. 2 shows an example where the number of bits used in the pre-calculation of a branch target address <b>250</b> contained in a cached instruction <b>252</b> is the same as the number of bits in a displacement <b>210</b> contained in an original instruction <b>212</b>. If there are more bits in displacement <b>210</b> than are needed to access the cache, the upper bits of displacement <b>210</b> can be preserved as-is, and used in the computation of the upper bits of branch target address <b>250</b> while cache access is occurring. FIG. 2 shows the transformation made to original instruction <b>212</b> of the \u201cIP+displacement\u201d form covered by this invention. Some or all of the bits of displacement <b>210</b>, including enough to select a set in the cache and any bits less significant than those, are added to the corresponding bits in address <b>220</b> of original instruction <b>212</b>. If the architecture uses, for example, the address of the next sequential instruction in this calculation, then bits from that address are used instead. Generally the address of the next instruction is equal to the address of the current instruction plus a small fixed offset. In the example given for FIG. 1, the twelfth least significant bit and all less significant bits would be added to the twelfth least significant bit of the address of the instruction. This would produce a 12-bit result and a <b>1</b> bit carry. The 12-bit result is then substituted for the displacement in the instruction, and in the example shown in FIG. 2, an unused bit in cached instruction <b>252</b> is used to store a carry <b>254</b>. The resulting modified instruction is the value stored into the instruction cache.</p><p>It is often the case that the least significant bits in a displacement are assumed to be zero, and are not actually given in the instruction. It is also often the case that a given displacement can have either a positive or negative value. These situations do not significantly alter how the invention operates. How to adapt the invention to these situations is obvious to one of ordinary skill in the art.</p><p>FIG. 3 shows one embodiment of the present invention where two processes are represented: the process of putting information into a cache, and the process of fetching information from the cache. FIG. 3 contains a cache <b>310</b>, a set of cache tags <b>312</b>, a set of cache data <b>314</b>, and a hit detection unit <b>316</b>.</p><p>In the process of putting information into cache <b>310</b>, if the data being stored is recognized as being an IP+displacement branch, it is modified, such as by the process discussed for FIG. <b>2</b>. An instruction modification unit <b>318</b> containing a pre-decoder <b>320</b>, a displacement adder <b>322</b>, a splice unit <b>324</b>, and a select_I unit <b>326</b>, shown at the top of the diagram, performs the modification. If pre-decoder <b>320</b> recognizes the instruction as an IP+displacement branch, the modified form of the instruction is stored into cache <b>310</b>. Otherwise, the unmodified form is stored.</p><p>The process of fetching information from the cache is altered, when compared to FIG. 1, by splitting the address generation portion of that process into two halves that can complete at different times. Those bits needed to select a set within cache <b>310</b> are determined via a fast path, which includes a select_L unit <b>332</b>, an IP reg low unit <b>340</b> to store the lower portion of the IP, and a low incrementer <b>330</b>. This path selects the output of the lower part of an incrementer <b>330</b> if no branch has occurred, or the pre-calculated bits stored into cache <b>310</b> if an IP+displacement branch has been detected. If another form of branch is implemented (such as a return from subroutine, or a branch to an address specified by a general purpose register), then another input to select_L unit <b>332</b> would be used to route the address generated by that branch into the loop. This is not shown in the diagram but is obvious to one of ordinary skill in the art.</p><p>Those bits used in hit detection unit <b>316</b> (the more significant bits) are determined by using a select_M unit <b>344</b> to select either: (1) the output generated by high incrementor <b>334</b>, which contains the bits from the upper part of the incrementer; or (2) the output of MSB adder <b>338</b>, which provides the addition operation of the more significant bits of the displacement to the more significant bits of the appropriate address, taking into account the carry from displacement adder <b>322</b>. The more significant bits of the displacement (labeled \u201cD_MSb's\u201d in FIG. 3) and the carry from the earlier operation of displacement adder <b>322</b> (labeled \u201cC\u201d in FIG. 3) are provided by decoder <b>336</b> from the modified instruction that is stored in cache <b>310</b>. Again, if another form of branch is possible, then another input to select_L unit <b>332</b> may be used to route the address generated by that branch into the loop. This is not shown in the diagram but is obvious to one of ordinary skill in the art.</p><p>The circuit used to compute the more significant bits that are used in the hit calculation takes longer (starting from the moment the branch was fetched from the cache) than the circuit used to obtain the less significant bits used in the set determination, because of the presence of the adder in the former path. However, because hit determination in a set-associative cache does not start until after the tags have been fetched from the cache, some or all of the extra time taken by the add occurs during the cache access, and therefor does not add to the total time that the operation takes.</p><p>Two possible relationships between the displacement size and the number of bits needed to address the cache have been discussed: (1) where the displacement size is equal to the number of bits needed to address the cache; and (2) where the displacement size is greater than the number of bits needed to address the cache. In both of these cases, at most one extra bit per IP-relative branch instruction is required to store the carry since the result of the pre-calculation is stored, instead of some or all of the bits of the displacement.</p><p>In cases where the displacement size is smaller than the number of bits needed to address the cache, more difficulty is encountered. In this case, two options exist: either pre-compute enough bits to address the cache and add additional storage to the cache to make room for these extra bits; or to use only one bit of additional storage (for the carry) and have an incrementer that used this carry to compute the remaining bits needed to access the cache. It is to be noted that this is still be faster than doing the entire add operation.</p><p>FIG. 4 illustrates one embodiment of a circuit that exercises the latter option. It is noted that a further refinement of FIG. 4 would be to split MSB incrementer <b>380</b> and the latches for the MSB's into separate units, one of each that handles those bits needed to address the cache and another of each for those bits used in the hit comparison. This would further speed the operation.</p><p>In some instruction sets, it is possible to mistake a word in the instruction stream for an instruction when it is not an instruction. In this case, it is possible that pre-calculating the addition of the displacement and IP, and substituting it for the displacement, would be inappropriate. In this case, a circuit to reverse the transformation would be needed. This circuit would simply subtract the IP of the instruction word from the pre-calculated value that was substituted for what was thought to be a displacement, and the result would be the original value that had been in that field.</p><p>The embodiment described above requires fewer additional hardware than a traditional branch-target buffer to implement, and requires simpler control circuitry. Moreover, the system may be tied to current branch prediction systems in much the same way as is a branch-target buffer. Note that a branch-target buffer can be used with any kind of branch, whereas the system described above only applied to IP-relative branches. Thus, a processor containing an implementation of the current invention could use the two techniques together by using this invention for IP-relative branches and a mechanism similar to a branch target buffer for all other branches. In such a configuration, in architectures where IP-relative branches account for the majority of branches, the branch target buffer could be considerably smaller without a reduction in performance.</p><p>While the present invention has been particularly described with reference to the various figures, it should be understood that the figures are for illustration only and should not be taken as limiting the scope of the invention. Many changes and modifications may be made to the invention, by one having ordinary skill in the art, without departing from the spirit and scope of the invention.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Dennis M.", "last_name": "O'Connor", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTEL CORPORATION"}, {"first_name": "", "last_name": "MARVELL ASIA PTE, LTD.", "name": ""}, {"first_name": "", "last_name": "CAVIUM INTERNATIONAL", "name": ""}, {"first_name": "", "last_name": "MARVELL INTERNATIONAL LTD.", "name": ""}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/32"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/32        20060101A I20051008RMEP"}, {"label": "G06F   9/318       20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712226"}, {"primary": false, "label": "712E09035"}, {"primary": false, "label": "712240"}, {"primary": false, "label": "712E09075"}, {"primary": false, "label": "712208"}, {"primary": false, "label": "712233"}, {"primary": false, "label": "712237"}, {"primary": false, "label": "712211"}, {"primary": false, "label": "712239"}], "ecla_classes": [{"label": "G06F   9/38C2"}, {"label": "G06F   9/32B3"}, {"label": "G06F   9/34X"}, {"label": "G06F   9/30T4T"}], "cpc_classes": [{"label": "G06F   9/342"}, {"label": "G06F   9/324"}, {"label": "G06F   9/382"}, {"label": "G06F   9/30167"}, {"label": "G06F   9/342"}, {"label": "G06F   9/30167"}, {"label": "G06F   9/324"}, {"label": "G06F   9/382"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1998-09-30", "application_date": "1998-09-30", "family_members": [{"ucid": "US-6237087-B1", "titles": [{"lang": "EN", "text": "Method and apparatus for speeding sequential access of a set-associative cache"}]}]}