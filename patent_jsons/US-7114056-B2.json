{"patent_number": "US-7114056-B2", "publication_id": 74893964, "family_id": 22758540, "publication_date": "2006-09-26", "titles": [{"lang": "EN", "text": "Local and global register partitioning in a VLIW processor"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA51044054\"><p num=\"p-0001\">A Very Long Instruction Word (VLIW) processor having a plurality of functional units includes a multi-ported register file that is divided into a plurality of separate register file segments, each of the register file segments being associated to one of the plurality of functional units. The register file segments are partitioned into local registers and global registers. The global registers are read and written by all functional units. The local registers are read and written only by a functional unit associated with a particular register file segment. The local registers and global registers are addressed using register addresses in an address space that is separately defined for a register file segment/functional unit pair. The global registers are addressed within a selected global register range using the same register addresses for the plurality of register file segment/functional unit pairs. The local registers in a register file segment are addressed using register addresses in a local register range outside the global register range that are assigned within a single register file segment/functional unit pair. Register addresses in the local register range are the same for the plurality of register file segment/functional unit pairs and address registers locally within a register file segment/functional unit pair.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00001\" num=\"00001\">\n<claim-text>1. A processor comprising:\n<claim-text>a plurality of functional units; and</claim-text>\n<claim-text>a register file that is divided into a plurality of register file segments, each coupled to and associated with respective ones of the plurality of functional units, the register file segments each implemented as an addressable array and partitionable into global registers and local registers, the global registers being accessible by the plurality of functional units, the local registers being accessible by the functional unit associated with the register file segment containing the local registers, wherein the number of global registers and the number of local registers are programmably configurable.</claim-text>\n</claim-text>\n</claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00002\" num=\"00002\">\n<claim-text>2. A processor according to <claim-ref idref=\"CLM-00001\">claim 1</claim-ref> wherein:\n<claim-text>the processor is a Very Long Instruction Word (VLIW) processor.</claim-text>\n</claim-text>\n</claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00003\" num=\"00003\">\n<claim-text>3. A processor according to <claim-ref idref=\"CLM-00001\">claim 1</claim-ref> wherein:\n<claim-text>the local registers and global registers are addressed using register addresses in an address space that is defined for a register file segment/functional unit pair.</claim-text>\n</claim-text>\n</claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00004\" num=\"00004\">\n<claim-text>4. A processor according to <claim-ref idref=\"CLM-00001\">claim 1</claim-ref> wherein:\n<claim-text>the register file is a multi-ported register file.</claim-text>\n</claim-text>\n</claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00005\" num=\"00005\">\n<claim-text>5. A processor according to <claim-ref idref=\"CLM-00001\">claim 1</claim-ref> wherein:\n<claim-text>the local registers in a register file segment are addressed using register addresses in a local register range outside the global register range that are assigned within a single register file segment/functional unit pair.</claim-text>\n</claim-text>\n</claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00006\" num=\"00006\">\n<claim-text>6. A processor according to <claim-ref idref=\"CLM-00001\">claim 1</claim-ref> wherein:\n<claim-text>register addresses in the local register range are the same for the plurality of register file segment/functional unit pairs and address registers locally within a register file segment/functional unit pair.</claim-text>\n</claim-text>\n</claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00007\" num=\"00007\">\n<claim-text>7. A processor according to <claim-ref idref=\"CLM-00001\">claim 1</claim-ref> wherein:\n<claim-text>the register file includes M of the register file segments, with each of the M register file segments having N physical registers, the register file segments having a reduced number of read and/or write ports in comparison to an undivided register file.</claim-text>\n</claim-text>\n</claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00008\" num=\"00008\">\n<claim-text>8. A processor according to <claim-ref idref=\"CLM-00007\">claim 7</claim-ref> wherein:\n<claim-text>the register file segments are partitioned into N<sub>G </sub>global and N<sub>L </sub>local register files where N<sub>G </sub>plus N<sub>L</sub>, is equal to N, the register file having N<sub>G</sub>+(M*N<sub>L</sub>) total registers available for the M functional units, the number of address bits for addressing the N<sub>G</sub>+(M*N<sub>L</sub>) total registers being equal to the number of bits B that are used to address N=2<sup>B </sup>registers.</claim-text>\n</claim-text>\n</claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00009\" num=\"00009\">\n<claim-text>9. A processor according to <claim-ref idref=\"CLM-00008\">claim 8</claim-ref> wherein:\n<claim-text>partitioning of the register file is programmable so that the number N<sub>G </sub>of global registers and number N<sub>L </sub>of local registers is selectable and variable.</claim-text>\n</claim-text>\n</claim>"}, {"num": 10, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00010\" num=\"00010\">\n<claim-text>10. A processor according to <claim-ref idref=\"CLM-00001\">claim 1</claim-ref> wherein the register file is a storage array structure having R read ports and W write ports comprising:\n<claim-text>a plurality of storage array storages;</claim-text>\n<claim-text>the storage array storages having a reduced number of read ports so that the total number of read ports for the plurality of storage array storages is R read ports; and</claim-text>\n<claim-text>the storage array storages having W write ports.</claim-text>\n</claim-text>\n</claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00011\" num=\"00011\">\n<claim-text>11. A processor according to <claim-ref idref=\"CLM-00010\">claim 10</claim-ref> wherein:\n<claim-text>the storage array structure is a multi-port structure; and</claim-text>\n<claim-text>the plurality of storage array storages includes four storage array storages each having three read ports and five write ports.</claim-text>\n</claim-text>\n</claim>"}, {"num": 12, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00012\" num=\"00012\">\n<claim-text>12. A processor according to <claim-ref idref=\"CLM-00010\">claim 10</claim-ref> wherein:\n<claim-text>the storage array structure is a multi-port structure; and</claim-text>\n<claim-text>the plurality of storage array storages includes four storage array storages each having three read ports and four write ports.</claim-text>\n</claim-text>\n</claim>"}, {"num": 13, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00013\" num=\"00013\">\n<claim-text>13. A processor according to <claim-ref idref=\"CLM-00010\">claim 10</claim-ref> wherein:\n<claim-text>the writes for the global registers are fully broadcast so that all of the storage array storages are held coherent.</claim-text>\n</claim-text>\n</claim>"}, {"num": 14, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00014\" num=\"00014\">\n<claim-text>14. A processor according to <claim-ref idref=\"CLM-00010\">claim 10</claim-ref> wherein:\n<claim-text>storage array storages include storage cells having a plurality of word lines and a plurality of bit lines, the word lines being formed in one metal layer, the bits lines being formed in a second metal layer.</claim-text>\n</claim-text>\n</claim>"}, {"num": 15, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00015\" num=\"00015\">\n<claim-text>15. A processor comprising:\n<claim-text>a decoder for decoding a very long instruction word including a plurality of sub instructions, the sub instructions being allocated into positions of the instruction word;</claim-text>\n<claim-text>a register file coupled to the decoder and divided into a plurality of register file segments, each register file segment implemented as an addressable array and partitionable into global registers and local registers; and</claim-text>\n<claim-text>a plurality of functional units, each coupled to and associated with respective ones of the register file segments, ones of the plurality of sub instructions being executable upon respective ones of the plurality of functional units, operating upon operands accessible to the register file segment associated with the respective functional unit, the global registers being accessible by the plurality of functional units, the local registers in each register file segment being accessible by the functional unit associated with the register file segment.</claim-text>\n</claim-text>\n</claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00016\" num=\"00016\">\n<claim-text>16. A processor according to <claim-ref idref=\"CLM-00015\">claim 15</claim-ref> wherein: the local registers and global registers are addressed using register addresses in an address space that is defined for a register file segment/functional unit pair.</claim-text>\n</claim>"}, {"num": 17, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00017\" num=\"00017\">\n<claim-text>17. A processor according to <claim-ref idref=\"CLM-00015\">claim 15</claim-ref> wherein: the register file is a multi-ported register file.</claim-text>\n</claim>"}, {"num": 18, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00018\" num=\"00018\">\n<claim-text>18. A processor according to <claim-ref idref=\"CLM-00015\">claim 15</claim-ref> wherein:\n<claim-text>the local registers in a register file segment are addressed using register addresses in a local register range outside the global register range that are assigned within a single register file segment/functional unit pair.</claim-text>\n</claim-text>\n</claim>"}, {"num": 19, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00019\" num=\"00019\">\n<claim-text>19. A processor according to <claim-ref idref=\"CLM-00015\">claim 15</claim-ref> wherein:\n<claim-text>register addresses in the local register range are the same for the plurality of register file segment/functional unit pairs and address registers locally within a register file segment/functional unit pair.</claim-text>\n</claim-text>\n</claim>"}, {"num": 20, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00020\" num=\"00020\">\n<claim-text>20. A processor according to <claim-ref idref=\"CLM-00015\">claim 15</claim-ref> wherein:\n<claim-text>the register file includes M of the register file segments, with each of the M register file segments having N physical registers, the register file segments having a reduced number of read and/or write ports in comparison to an undivided register file.</claim-text>\n</claim-text>\n</claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00021\" num=\"00021\">\n<claim-text>21. A processor according to <claim-ref idref=\"CLM-00020\">claim 20</claim-ref> wherein:\n<claim-text>the register file segments are partitioned into N<sub>G </sub>global and N<sub>L </sub>local register files where N<sub>G </sub>plus N<sub>L </sub>is equal to N, the register file having N<sub>G</sub>+(M*N<sub>L</sub>) total registers available for the M functional units, the number of address bits for addressing the N<sub>G</sub>+(M*N<sub>L</sub>) total registers being equal to the number of bits B that are used to address N=2<sup>B </sup>registers.</claim-text>\n</claim-text>\n</claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00022\" num=\"00022\">\n<claim-text>22. A processor according to <claim-ref idref=\"CLM-00021\">claim 21</claim-ref> wherein:\n<claim-text>partitioning of the register file is programmable so that the number N<sub>G </sub>of global registers and number N<sub>L </sub>of local registers is selectable and variable.</claim-text>\n</claim-text>\n</claim>"}, {"num": 23, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00023\" num=\"00023\">\n<claim-text>23. A method of operating a processor, the processor including a plurality of functional units and a register file divided into a plurality of register file segments, each coupled to and associated with respective ones of the plurality of functional units, the register file segments each implemented as an addressable array, the method comprising:\n<claim-text>partitioning the register file segments into global registers and local registers;</claim-text>\n<claim-text>operating the plurality of functional units;</claim-text>\n<claim-text>accessing the global registers by the plurality of functional units;</claim-text>\n<claim-text>accessing the local registers by the functional unit associated with the register file segment including the local registers; and</claim-text>\n<claim-text>programmably partitioning the register file so that the number of the global registers and the number of the local registers are selectable and variable.</claim-text>\n</claim-text>\n</claim>"}, {"num": 24, "parent": 23, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00024\" num=\"00024\">\n<claim-text>24. A method according to <claim-ref idref=\"CLM-00023\">claim 23</claim-ref> further comprising:\n<claim-text>addressing the local registers and global registers using register addresses in an address space that is defined for a register file segment/functional unit pair.</claim-text>\n</claim-text>\n</claim>"}, {"num": 25, "parent": 23, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00025\" num=\"00025\">\n<claim-text>25. A method according to <claim-ref idref=\"CLM-00023\">claim 23</claim-ref> further comprising:\n<claim-text>addressing the local registers in a register file segment using register addresses in a local register range outside the global register range that are assigned within a single register file segment/functional unit pair.</claim-text>\n</claim-text>\n</claim>"}, {"num": 26, "parent": 23, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00026\" num=\"00026\">\n<claim-text>26. A method according to <claim-ref idref=\"CLM-00023\">claim 23</claim-ref> further comprising:\n<claim-text>addressing the local register range the same for the plurality of register file segment/functional unit pairs and address registers locally within a register file segment/functional unit pair.</claim-text>\n</claim-text>\n</claim>"}, {"num": 27, "parent": 23, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00027\" num=\"00027\">\n<claim-text>27. A method according to <claim-ref idref=\"CLM-00023\">claim 23</claim-ref>, wherein the register file include M of the register file segments, with each of the M register file segments having N physical registers, the register file segments having a reduced number of read and/or write ports in comparison to an undivided register file.</claim-text>\n</claim>"}, {"num": 28, "parent": 27, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00028\" num=\"00028\">\n<claim-text>28. A method according to <claim-ref idref=\"CLM-00027\">claim 27</claim-ref> further comprising:\n<claim-text>partitioning the register file segments into N<sub>G </sub>global and N<sub>L </sub>local register files where N<sub>G </sub>plus N<sub>L </sub>is equal to N; and</claim-text>\n<claim-text>operating the register file having N<sub>G</sub>+(M*N<sub>L</sub>) total registers available for the M functional units, the number of address bits for addressing the N<sub>G</sub>+(M*N<sub>L</sub>) total registers being equal to the number of bits B that are used to address N=2<sup>B </sup>registers.</claim-text>\n</claim-text>\n</claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES16111535\">\n<?BRFSUM description=\"Brief Summary\" end=\"lead\"?>\n<h4>CROSS-REFERENCE TO RELATED APPLICATIONS</h4>\n<p num=\"p-0002\">The present application is related to subject matter disclosed in the following co-pending patent applications:</p>\n<p num=\"p-0003\">U.S. patent application No. 09/204,480, filed Dec. 3, 1998, now U.S. Pat. No. 6,718, 457; U.S. patent application No. 09/204,584, filed Dec. 3, 1998, now U.S. Pat. No. 6,615,338; U.S. patent application No. 09/204,481, filed Dec. 3, 1998, now U.S. Pat. No. 6,343,348; U.S. patent application No. 09/204,536, filed Dec. 3, 1998, now abandoned; U.S. patent application No. 09/204,586, filed Dec. 3, 1998, now U.S. Pat. No. 6,205,543; U.S. patent application No. 09/205,121, filed Dec. 3, 1998, now U.S. Pat. No. 6,321,325; U.S. patent application No. 09/204,781, filed Dec. 3, 1998, now U.S. Pat. No. 6,249,861; U.S. patent application No. 09/204,535, filed Dec. 3, 1998, now U.S. Pat. No. 6,279,100; and U.S. patent application No. 09/204,479, filed Dec. 3, 1998, now pending.</p>\n<h4>BACKGROUND OF THE INVENTION</h4>\n<p num=\"p-0004\">1. Field of the Invention</p>\n<p num=\"p-0005\">The present invention relates to storage or memory in a processor. More specifically, the present invention relates to a storage having local and global access regions for subinstructions in a Very Long Instruction Word (VLIW) processor.</p>\n<p num=\"p-0006\">2. Description of the Related Art</p>\n<p num=\"p-0007\">One technique for improving the performance of processors is parallel execution of multiple instructions to allow the instruction execution rate to exceed the clock rate. Various types of parallel processors have been developed including Very Long Instruction Word (VLIW) processors that use multiple, independent functional units to execute multiple instructions in parallel. VLIW processors package multiple operations into one very long instruction, the multiple operations being determined by sub-instructions that are applied to the independent functional units. An instruction has a set of fields corresponding to each functional unit. Typical bit lengths of a subinstruction commonly range from 16 to 24 bits per functional unit to produce an instruction length often in a range from 112 to 168 bits.</p>\n<p num=\"p-0008\">The multiple functional units are kept busy by maintaining a code sequence with sufficient operations to keep instructions scheduled. A VLIW processor often uses a technique called trace scheduling to maintain scheduling efficiency by unrolling loops and scheduling code across basic function blocks. Trace scheduling also improves efficiency by allowing instructions to move across branch points.</p>\n<p num=\"p-0009\">Limitations of VLIW processing include limited parallelism, limited hardware resources, and a vast increase in code size. A limited amount of parallelism is available in instruction sequences. Unless loops are unrolled a very large number of times, insufficient operations are available to fill the instructions. Limited hardware resources are a problem, not only because of duplication of functional units but more importantly due to a large increase in memory and register file bandwidth. A large number of read and write ports are necessary for accessing the register file, imposing a bandwidth that is difficult to support without a large cost in the size of the register file and degradation in clock speed. As the number of ports increases, the complexity of the memory system further increases. To allow multiple memory accesses in parallel, the memory is divided into multiple banks having different addresses to reduce the likelihood that multiple operations in a single instruction have conflicting accesses that cause the processor to stall since synchrony must be maintained between the functional units.</p>\n<p num=\"p-0010\">Code size is a problem for several reasons. The generation of sufficient operations in a nonbranching code fragment requires substantial unrolling of loops, increasing the code size. Also, instructions that are not full may include unused subinstructions that waste code space, increasing code size. Furthermore, the increase in the size of storages such as the register file increase the number of bits in the instruction for addressing registers in the register file.</p>\n<p num=\"p-0011\">A register file with a large number of registers is often used to increase performance of a VLIW processor. A VLIW processor is typically implemented as a deeply pipelined engine with an \u201cin-order\u201d execution model. To attain a high performance a large number of registers is utilized so that the multiple functional units are busy as often as possible.</p>\n<p num=\"p-0012\">A large register file has several drawbacks. First, as the number of registers that are directly addressable is increased, the number of bits used to specify the multiple registers within the instruction increases proportionally. For a rich instruction set architecture with, for example, four register specifiers, an additional bit for a register specifier effectively costs four bits per subinstruction (one bit per register specifier). For a VLIW word with four to eight subinstructions, sixteen to thirty-two bits are added for instruction encoding. Second, a register file with many registers occupies a large area. Third, a register file with many registers may create critical timing paths and therefore limit the cycle time of the processor.</p>\n<p num=\"p-0013\">What is needed is a technique and processor architecture enhancement that improves the efficiency of instruction coding but still allows access to a large set of architecturally-visible registers.</p>\n<h4>SUMMARY OF THE INVENTION</h4>\n<p num=\"p-0014\">A Very Long Instruction Word (VLIW) processor having a plurality of functional units and includes a multi-ported register file that is divided into a plurality of separate register file segments, each of the register file segments being associated to one of the plurality of functional units. The register file segments are partitioned into local registers and global registers. The global registers are read and written by all functional units. The local registers are read and written only by a functional unit associated with a particular register file segment. The local registers and global registers are addressed using register addresses in an address space that is separately defined for a register file segment/functional unit pair. The global registers are addressed within a selected global register range using the same register addresses for the plurality of register file segment/functional unit pairs. The local registers in a register file segment are addressed using register addresses in a local register range outside the global register range that are assigned within a single register file segment/functional unit pair. Register addresses in the local register range are the same for the plurality of register file segment/functional unit pairs and address registers locally within a register file segment/functional unit pair.</p>\n<p num=\"p-0015\">A VLIW processor utilizes a very long instruction word that includes a plurality of subinstructions. The subinstructions are allocated into positions of the instruction word. The VLIW processor includes a register file that is divided into a plurality of register file segments. The VLIW processor also includes a plurality of functional units, each of which is coupled to and associated with a register file segment of the register file. Each of the subinstructions executes on a particular functional unit, operating upon operands read from and written to a particular register file segment that is associated with the functional unit. The register file segments include a plurality of registers that are partitioned into global registers and local registers. A global register is a register that is accessed by all of the plurality of functional units and is therefore is read and/or written by all functional units. A local register is a register that is only accessible by a particular subinstruction and is only readable and writable by the specific functional unit that executes instructions in the particular subinstruction position.</p>\n<p num=\"p-0016\">A register file includes N physical registers. The N-register register file is duplicated into M register file segments, each having a reduced number of read and/or write ports in comparison to a nonduplicated register file, but each having the same number of physical registers. The register file segments are partitioned into N<sub>G </sub>global and N<sub>L </sub>local register files where N<sub>G </sub>plus N<sub>L </sub>is equal to N. The register file operates equivalently to having N<sub>G</sub>+(M*N<sub>L</sub>) total registers available for the M subinstructions. The number of address bits for addressing the N<sub>G</sub>+(M*N<sub>L</sub>) total registers remains equal to the number of bits B that are used to address N=2<sup>B </sup>registers. The local registers for each of the M register file segments are addressed using the same B-bit values.</p>\n<p num=\"p-0017\">In one example, each of M equal to four register file segments includes N equal to 128 registers. The number N<sub>G </sub>of global registers is set to 96 while the number N<sub>L </sub>of local registers in each register file segment is set to 32. Therefore, the total number of distinct and independent registers is 96+(4*32)=224. The 224 registers are addressed using 7 bits that define an address space from 0\u2013127, rather than the 8 bits that are otherwise required to access 224 registers. In one example, the 96 global registers are addressed using address specifiers <b>0</b>\u2013<b>95</b> in all of the four register file segments. Local registers <b>96</b>\u2013<b>127</b> in a register file segment <b>0</b>, local registers <b>128</b>\u2013<b>159</b> in register file segment <b>1</b>, local registers <b>160</b>\u2013<b>191</b> in register file segment <b>2</b>, and local registers <b>192</b>\u2013<b>223</b> in register file segment <b>3</b> are all addressed using register addresses <b>96</b>\u2013<b>127</b>.</p>\n<p num=\"p-0018\">One address bit is thus saved for each of the four subinstruction positions, a savings of four bits per subinstruction and a savings of 16 bits for a VLIW instruction. The reduction in address bits is highly advantageous in a VLIW processor that includes powerful functional units that execute a large plurality of instructions, each of which is to be encoded in the VLIW instruction word.</p>\n<p num=\"p-0019\">In some embodiments, partitioning of the register file is programmable so that the number N<sub>G </sub>of global registers and number N<sub>L </sub>of local registers is selectable and variable. For example, a register file including four register file segments each having 128 registers may be programmably configured as a flat register file with 128 global registers and 0 local registers with the 128 registers addressed using seven address bits. Alternatively, the four register file segments may be programmably configured, for example, to include 64 global registers and 64 local registers so that the total number of registers is 64+(4*64)=320 registers that are again addressed using 7 bits rather than the 9 bits that would otherwise be required to address 320 registers.</p>\n<?BRFSUM description=\"Brief Summary\" end=\"tail\"?>\n<?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?>\n<description-of-drawings>\n<h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4>\n<p num=\"p-0020\">The features of the described embodiments are specifically set forth in the appended claims. However, embodiments of the invention relating to both structure and method of operation, may best be understood by referring to the following description and accompanying drawings.</p>\n<p num=\"p-0021\"><figref idrefs=\"DRAWINGS\">FIG. 1</figref> is a schematic block diagram illustrating a single integrated circuit chip implementation of a processor in accordance with an embodiment of the present invention.</p>\n<p num=\"p-0022\"><figref idrefs=\"DRAWINGS\">FIG. 2</figref> is a schematic block diagram showing the core of the processor.</p>\n<p num=\"p-0023\"><figref idrefs=\"DRAWINGS\">FIG. 3</figref> is a schematic block diagram that illustrates an embodiment of the split register file that is suitable for usage in the processor.</p>\n<p num=\"p-0024\"><figref idrefs=\"DRAWINGS\">FIG. 4</figref> is a schematic block diagram that shows a logical view of the register file and functional units in the processor.</p>\n<p num=\"p-0025\"><figref idrefs=\"DRAWINGS\">FIGS. 5A</figref>, <b>5</b>B, and <b>5</b>C show a schematic block diagram of a divided or split register file, a high level view of computation elements of a functional unit, and a pictorial view of an instruction format, respectively, which are used to illustrate the difficulty of defining an instruction format with a limited number of instruction bits.</p>\n<p num=\"p-0026\"><figref idrefs=\"DRAWINGS\">FIG. 6</figref> is a schematic block diagram showing a register file for a VLIW processor that includes global and local register partitioning.</p>\n<p num=\"p-0027\"><figref idrefs=\"DRAWINGS\">FIG. 7</figref> illustrates a schematic block diagram of an SRAM array used for the multi-port split register file.</p>\n<p num=\"p-0028\"><figref idrefs=\"DRAWINGS\">FIGS. 8A and 8B</figref> are, respectively, a schematic block diagram and a pictorial diagram that illustrate the register file and a memory array insert of the register file.</p>\n<p num=\"p-0029\"><figref idrefs=\"DRAWINGS\">FIG. 9</figref> is a schematic block diagram showing an arrangement of the register file into the four register file segments.</p>\n<p num=\"p-0030\"><figref idrefs=\"DRAWINGS\">FIG. 10</figref> is a schematic timing diagram that illustrates timing of the processor pipeline.</p>\n</description-of-drawings>\n<?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?>\n<?DETDESC description=\"Detailed Description\" end=\"lead\"?>\n<p num=\"p-0031\">The use of the same reference symbols in different drawings indicates similar or identical items.</p>\n<h4>DESCRIPTION OF THE EMBODIMENT(S)</h4>\n<p num=\"p-0032\">Referring to <figref idrefs=\"DRAWINGS\">FIG. 1</figref>, a schematic block diagram illustrates a single integrated circuit chip implementation of a processor <b>100</b> that includes a memory interface <b>102</b>, a geometry decompressor <b>104</b>, two media processing units <b>110</b> and <b>112</b>, a shared data cache <b>106</b>, and several interface controllers. The interface controllers support an interactive graphics environment with real-time constraints by integrating fundamental components of memory, graphics, and input/output bridge functionality on a single die. The components are mutually linked and closely linked to the processor core with high bandwidth, low-latency communication channels to manage multiple high-bandwidth data streams efficiently and with a low response time. The interface controllers include a an UltraPort Architecture Interconnect (UPA) controller <b>116</b> and a peripheral component interconnect (PCI) controller <b>120</b>. The illustrative memory interface <b>102</b> is a direct Rambus dynamic RAM (DRDRAM) controller. The shared data cache <b>106</b> is a dual-ported storage that is shared among the media processing units <b>110</b> and <b>112</b> with one port allocated to each media processing unit. The data cache <b>106</b> is four-way set associative, follows a write-back protocol, and supports hits in the fill buffer (not shown). The data cache <b>106</b> allows fast data sharing and eliminates the need for a complex, error-prone cache coherency protocol between the media processing units <b>110</b> and <b>112</b>.</p>\n<p num=\"p-0033\">The UPA controller <b>116</b> maintains a duplicate set of cache tags in the system and performs duplicate tag lookup and main memory initiation in parallel pipelines for each coherent transaction. The approach of the UPA controller <b>116</b> attains reduced latency on cache misses and improved utilization of address, datapath, and main memory in comparison to directory-based systems. Directory-based systems maintain coherence states for each data block in main memory and require read-modify-write penalty for every read transaction that reaches main memory. The UPA controller <b>116</b> is a centralized system controller that removes the need to place cache coherence logic on the processor <b>100</b> and DMA devices, thereby simplifying the circuitry.</p>\n<p num=\"p-0034\">The PCI controller <b>120</b> is used as the primary system I/O interface for connecting standard, high-volume, low-cost peripheral devices, although other standard interfaces may also be used. The PCI bus effectively transfers data among high bandwidth peripherals and low bandwidth peripherals, such as CD-ROM players, DVD players, and digital cameras.</p>\n<p num=\"p-0035\">Two media processing units <b>110</b> and <b>112</b> are included in a single integrated circuit chip to support an execution environment exploiting thread level parallelism in which two independent threads can execute simultaneously. The threads may arise from any sources such as the same application, different applications, the operating system, or the runtime environment. Parallelism is exploited at the thread level since parallelism is rare beyond four, or even two, instructions per cycle in general purpose code. For example, the illustrative processor <b>100</b> is an eight-wide machine with eight execution units for executing instructions. A typical \u201cgeneral-purpose\u201d processing code has an instruction level parallelism of about two so that, on average, most (about six) of the eight execution units would be idle at any time. The illustrative processor <b>100</b> employs thread level parallelism and operates on two independent threads, possibly attaining twice the performance of a processor having the same resources and clock rate but utilizing traditional non-thread parallelism.</p>\n<p num=\"p-0036\">Thread level parallelism is particularly useful for Java\u2122 applications which are bound to have multiple threads of execution. Java\u2122 methods including \u201csuspend\u201d, \u201cresume\u201d, \u201csleep\u201d, and the like include effective support for threaded program code. In addition, Java\u2122 class libraries are thread-safe to promote parallelism. (Java\u2122, Sun, Sun Microsystems and the Sun Logo are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries. All SPARC trademarks, including UltraSPARC I and UltraSPARC II, are used under license and are trademarks of SPARC International, Inc. in the United States and other countries. Products bearing SPARC trademarks are based upon an architecture developed by Sun Microsystems, Inc.) Furthermore, the thread model of the processor <b>100</b> supports a dynamic compiler which runs as a separate thread using one media processing unit <b>110</b> while the second media processing unit <b>112</b> is used by the current application. In the illustrative system, the compiler applies optimizations based on \u201con-the-fly\u201d profile feedback information while dynamically modifying the executing code to improve execution on each subsequent run. For example, a \u201cgarbage collector\u201d may be executed on a first media processing unit <b>110</b>, copying objects or gathering pointer information, while the application is executing on the other media processing unit <b>112</b>.</p>\n<p num=\"p-0037\">Although the processor <b>100</b> shown in <figref idrefs=\"DRAWINGS\">FIG. 1</figref> includes two processing units on an integrated circuit chip, the architecture is highly scaleable so that one to several closely-coupled processors may be formed in a message-based coherent architecture and resident on the same die to process multiple threads of execution. Thus, in the processor <b>100</b>, a limitation on the number of processors formed on a single die thus arises from capacity constraints of integrated circuit technology rather than from architectural constraints relating to the interactions and interconnections between processors.</p>\n<p num=\"p-0038\">Referring to <figref idrefs=\"DRAWINGS\">FIG. 2</figref>, a schematic block diagram shows the core of the processor <b>100</b>. The media processing units <b>110</b> and <b>112</b> each include an instruction cache <b>210</b>, an instruction aligner <b>212</b>, an instruction buffer <b>214</b>, a pipeline control unit <b>226</b>, a split register file <b>216</b>, a plurality of execution units, and a load/store unit <b>218</b>. In the illustrative processor <b>100</b>, the media processing units <b>110</b> and <b>112</b> use a plurality of execution units for executing instructions. The execution units for a media processing unit <b>110</b> include three media functional units (MFU) <b>220</b> and one general functional unit (GFU) <b>222</b>. The media functional units <b>220</b> are multiple single-instruction-multiple-datapath (MSIMD) media functional units. Each of the media functional units <b>220</b> is capable of processing parallel 16-bit components. Various parallel 16-bit operations supply the single-instruction-multiple-datapath capability for the processor <b>100</b> including add, multiply-add, shift, compare, and the like. The media functional units <b>220</b> operate in combination as tightly-coupled digital signal processors (DSPs). Each media functional unit <b>220</b> has an separate and individual sub-instruction stream, but all three media functional units <b>220</b> execute synchronously so that the subinstructions progress lock-step through pipeline stages.</p>\n<p num=\"p-0039\">The general functional unit <b>222</b> is a RISC processor capable of executing arithmetic logic unit (ALU) operations, loads and stores, branches, and various specialized and esoteric functions such as parallel power operations, reciprocal square root operations, and many others. The general functional unit <b>222</b> supports less common parallel operations such as the parallel reciprocal square root instruction.</p>\n<p num=\"p-0040\">The illustrative instruction cache <b>210</b> has a 16 Kbyte capacity and includes hardware support to maintain coherence, allowing dynamic optimizations through self-modifying code. Software is used to indicate that the instruction storage is being modified when modifications occur. The 16K capacity is suitable for performing graphic loops, other multimedia tasks or processes, and general-purpose Java\u2122 code. Coherency is maintained by hardware that supports write-through, non-allocating caching. Self-modifying code is supported through explicit use of \u201cstore-to-instruction-space\u201d instructions store 2i. Software uses the store 2i instruction to maintain coherency with the instruction cache <b>210</b> so that the instruction caches <b>210</b> do not have to be snooped on every single store operation issued by the media processing unit <b>110</b>.</p>\n<p num=\"p-0041\">The pipeline control unit <b>226</b> is connected between the instruction buffer <b>214</b> and the functional units and schedules the transfer of instructions to the functional units. The pipeline control unit <b>226</b> also receives status signals from the functional units and the load/store unit <b>218</b> and uses the status signals to perform several control functions. The pipeline control unit <b>226</b> maintains a scoreboard, generates stalls and bypass controls. The pipeline control unit <b>226</b> also generates traps and maintains special registers.</p>\n<p num=\"p-0042\">Each media processing unit <b>110</b> and <b>112</b> includes a split register file <b>216</b>, a single logical register file including <b>128</b> thirty-two bit registers. The split register file <b>216</b> is split into a plurality of register file segments <b>224</b> to form a multi-ported structure that is replicated to reduce the integrated circuit die area and to reduce access time. A separate register file segment <b>224</b> is allocated to each of the media functional units <b>220</b> and the general functional unit <b>222</b>. In the illustrative embodiment, each register file segment <b>224</b> has 128 32-bit registers. The first 96 registers (<b>0</b>\u2013<b>95</b>) in the register file segment <b>224</b> are global registers. All functional units can write to the 96 global registers. The global registers are coherent across all functional units (MFU and GFU) so that any write operation to a global register by any functional unit is broadcast to all register file segments <b>224</b>. Registers <b>96</b>\u2013<b>127</b> in the register file segments <b>224</b> are local registers. Local registers allocated to a functional unit are not accessible or \u201cvisible\u201d to other functional units.</p>\n<p num=\"p-0043\">The media processing units <b>110</b> and <b>112</b> are highly structured computation blocks that execute software-scheduled data computation operations with fixed, deterministic and relatively short instruction latencies, operational characteristics yielding simplification in both function and cycle time. The operational characteristics support multiple instruction issue through a pragmatic very large instruction word (VLIW) approach that avoids hardware interlocks to account for software that does not schedule operations properly. Such hardware interlocks are typically complex, error-prone, and create multiple critical paths. A VLIW instruction word always includes one instruction that executes in the general functional unit (GFU) <b>222</b> and from zero to three instructions that execute in the media functional units (MFU) <b>220</b>. A MFU instruction field within the VLIW instruction word includes an operation code (opcode) field, three source register (or immediate) fields, and one destination register field.</p>\n<p num=\"p-0044\">Instructions are executed in-order in the processor <b>100</b> but loads can finish out-of-order with respect to other instructions and with respect to other loads, allowing loads to be moved up in the instruction stream so that data can be streamed from main memory. The execution model eliminates the usage and overhead resources of an instruction window, reservation stations, a re-order buffer, or other blocks for handling instruction ordering. Elimination of the instruction ordering structures and overhead resources is highly advantageous since the eliminated blocks typically consume a large portion of an integrated circuit die. For example, the eliminated blocks consume about 30% of the die area of a Pentium II processor.</p>\n<p num=\"p-0045\">To avoid software scheduling errors, the media processing units <b>110</b> and <b>112</b> are high-performance but simplified with respect to both compilation and execution. The media processing units <b>110</b> and <b>112</b> are most generally classified as a simple 2-scalar execution engine with full bypassing and hardware interlocks on load operations. The instructions include loads, stores, arithmetic and logic (ALU) instructions, and branch instructions so that scheduling for the processor <b>100</b> is essentially equivalent to scheduling for a simple 2-scalar execution engine for each of the two media processing units <b>110</b> and <b>112</b>.</p>\n<p num=\"p-0046\">The processor <b>100</b> supports full bypasses between the first two execution units within the media processing unit <b>110</b> and <b>112</b> and has a scoreboard in the general functional unit <b>222</b> for load operations so that the compiler does not need to handle nondeterministic latencies due to cache misses. The processor <b>100</b> scoreboards long latency operations that are executed in the general functional unit <b>222</b>, for example a reciprocal square-root operation, to simplify scheduling across execution units. The scoreboard (not shown) operates by tracking a record of an instruction packet or group from the time the instruction enters a functional unit until the instruction is finished and the result becomes available. A VLIW instruction packet contains one GFU instruction and from zero to three MFU instructions. The source and destination registers of all instructions in an incoming VLIW instruction packet are checked against the scoreboard. Any true dependencies or output dependencies stall the entire packet until the result is ready. Use of a scoreboarded result as an operand causes instruction issue to stall for a sufficient number of cycles to allow the result to become available. If the referencing instruction that provokes the stall executes on the general functional unit <b>222</b> or the first media functional unit <b>220</b>, then the stall only endures until the result is available for intra-unit bypass. For the case of a load instruction that hits in the data cache <b>106</b>, the stall may last only one cycle. If the referencing instruction is on the second or third media functional units <b>220</b>, then the stall endures until the result reaches the writeback stage in the pipeline where the result is bypassed in transmission to the split register file <b>216</b>.</p>\n<p num=\"p-0047\">The scoreboard automatically manages load delays that occur during a load hit. In an illustrative embodiment, all loads enter the scoreboard to simplify software scheduling and eliminate NOPs in the instruction stream.</p>\n<p num=\"p-0048\">The scoreboard is used to manage most interlocks between the general functional unit <b>222</b> and the media functional units <b>220</b>. All loads and non-pipelined long-latency operations of the general functional unit <b>222</b> are scoreboarded. The long-latency operations include division idiv,fdiv instructions, reciprocal square root frecsqrt, precsqrt instructions, and power ppower instructions. None of the results of the media functional units <b>220</b> is scoreboarded. Non-scoreboarded results are available to subsequent operations on the functional unit that produces the results following the latency of the instruction.</p>\n<p num=\"p-0049\">The illustrative processor <b>100</b> has a rendering rate of over fifty million triangles per second without accounting for operating system overhead. Therefore, data feeding specifications of the processor <b>100</b> are far beyond the capabilities of cost-effective memory systems. Sufficient data bandwidth is achieved by rendering of compressed geometry using the geometry decompressor <b>104</b>, an on-chip real-time geometry decompression engine. Data geometry is stored in main memory in a compressed format. At render time, the data geometry is fetched and decompressed in real-time on the integrated circuit of the processor <b>100</b>. The geometry decompressor <b>104</b> advantageously saves memory space and memory transfer bandwidth. The compressed geometry uses an optimized generalized mesh structure that explicitly calls out most shared vertices between triangles, allowing the processor <b>100</b> to transform and light most vertices only once. In a typical compressed mesh, the triangle throughput of the transform-and-light stage is increased by a factor of four or more over the throughput for isolated triangles. For example, during processing of triangles, multiple vertices are operated upon in parallel so that the utilization rate of resources is high, achieving effective spatial software pipelining. Thus operations are overlapped in time by operating on several vertices simultaneously, rather than overlapping several loop iterations in time. For other types of applications with high instruction level parallelism, high trip count loops are software-pipelined so that most media functional units <b>220</b> are fully utilized.</p>\n<p num=\"p-0050\">Referring to <figref idrefs=\"DRAWINGS\">FIG. 3</figref>, a schematic block diagram illustrates an embodiment of the split register file <b>216</b> that is suitable for usage in the processor <b>100</b>. The split register file <b>216</b> supplies all operands of processor instructions that execute in the media functional units <b>220</b> and the general functional units <b>222</b> and receives results of the instruction execution from the execution units. The split register file <b>216</b> operates as an interface to the geometry decompressor <b>104</b>. The split register file <b>216</b> is the source and destination of store and load operations, respectively.</p>\n<p num=\"p-0051\">In the illustrative processor <b>100</b>, the split register file <b>216</b> in each of the media processing units <b>110</b> and <b>112</b> has <b>128</b> registers. Graphics processing places a heavy burden on register usage. Therefore, a large number of registers is supplied by the split register file <b>216</b> so that performance is not limited by loads and stores or handling of intermediate results including graphics \u201cfills\u201d and \u201cspills\u201d. The illustrative split register file <b>216</b> includes twelve read ports and five write ports, supplying total data read and write capacity between the central registers of the split register file <b>216</b> and all media functional units <b>220</b>, the general functional unit <b>222</b> and the load/store unit <b>218</b> that is connected to the general functional unit <b>222</b>. The five write ports include one 64-bit write port that is dedicated to load operations. The remaining four write ports are 32 bits wide and are used to write operations of the general functional unit <b>222</b> and the media functional units <b>220</b>.</p>\n<p num=\"p-0052\">Total read and write capacity promotes flexibility and facility in programming both of hand-coded routines and compiler-generated code.</p>\n<p num=\"p-0053\">Large, multiple-ported register files are typically metal-limited so that the register area is proportional with the square of the number of ports. A sixteen port file is roughly proportional in size and speed to a value of 256. The illustrative split register file <b>216</b> is divided into four register file segments <b>310</b>, <b>312</b>, <b>314</b>, and <b>316</b>, each having three read ports and four write ports so that each register file segment has a size and speed proportional to 49 for a total area for the four segments that is proportional to 196. The total area is therefore potentially smaller and faster than a single central register file. Write operations are fully broadcast so that all files are maintained coherent. Logically, the split register file <b>216</b> is no different from a single central register file However, from the perspective of layout efficiency, the split register file <b>216</b> is highly advantageous, allowing for reduced size and improved performance through faster access.</p>\n<p num=\"p-0054\">The new media data that is operated upon by the processor <b>100</b> is typically heavily compressed. Data transfers are communicated in a compressed format from main memory and input/output devices to pins of the processor <b>100</b>, subsequently decompressed on the integrated circuit holding the processor <b>100</b>, and passed to the split register file <b>216</b>.</p>\n<p num=\"p-0055\">Splitting the register file into multiple segments in the split register file <b>216</b> in combination with the character of data accesses in which multiple bytes are transferred to the plurality of execution units concurrently, results in a high utilization rate of the data supplied to the integrated circuit chip and effectively leads to a much higher data bandwidth than is supported on general-purpose processors. The highest data bandwidth requirement is therefore not between the input/output pins and the central processing units, but is rather between the decompressed data source and the remainder of the processor. For graphics processing, the highest data bandwidth requirement is between the geometry decompressor <b>104</b> and the split register file <b>216</b>. For video decompression, the highest data bandwidth requirement is internal to the split register file <b>216</b>. Data transfers between the geometry decompressor <b>104</b> and the split register file <b>216</b> and data transfers between various registers of the split register file <b>216</b> can be wide and run at processor speed, advantageously delivering a large bandwidth. In addition, the split register file <b>216</b> can be multiported which further increases total bandwidth.</p>\n<p num=\"p-0056\">The register file <b>216</b> is a focal point for attaining the very large bandwidth of the processor <b>100</b>. The processor <b>100</b> transfers data using a plurality of data transfer techniques. In one example of a data transfer technique, cacheable data is loaded into the split register file <b>216</b> through normal load operations at a low rate of up to eight bytes per cycle. In another example, streaming data is transferred to the split register file <b>216</b> through group load operations which transfer thirty-two bytes from memory directly into eight consecutive 32-bit registers. For example, the processor <b>100</b> utilizes the streaming data operation to receive compressed video data for decompression.</p>\n<p num=\"p-0057\">Compressed graphics data is received via a direct memory access (DMA) unit in the geometry decompressor <b>104</b>. The compressed graphics data is decompressed by the geometry decompressor <b>104</b> and loaded at a high bandwidth rate into the split register file <b>216</b> via group load operations that are mapped to the geometry decompressor <b>104</b>.</p>\n<p num=\"p-0058\">Load operations are non-blocking and scoreboarded so that a long latency inherent to loads can be hidden by early scheduling.</p>\n<p num=\"p-0059\">General purpose applications often fail to exploit the large register file <b>216</b>. Statistical analysis shows that compilers do not effectively use the large number of registers in the split register file <b>216</b>. However, aggressive in-lining techniques that have traditionally been restricted due to the limited number of registers in conventional systems may be advantageously used in the processor <b>100</b> to exploit the large number of registers in the split register file <b>216</b>. In a software system that exploits the large number of registers in the processor <b>100</b>, the complete set of registers is saved upon the event of a thread (context) switch. When only a few registers of the entire set of registers is used, saving all registers in the full thread switch is wasteful. Waste is avoided in the processor <b>100</b> by supporting individual marking of registers. Octants of the thirty-two registers can be marked as \u201cdirty\u201d if used, and are consequently saved conditionally.</p>\n<p num=\"p-0060\">In various embodiments, the split register file <b>216</b> is leveraged by dedicating fields for globals, trap registers, and the like.</p>\n<p num=\"p-0061\">Referring to <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, a schematic block diagram shows a logical view of the register file <b>216</b> and functional units in the processor <b>100</b>. The physical implementation of the core processor <b>100</b> is simplified by replicating a single functional unit to form the three media functional units <b>220</b>. The media functional units <b>220</b> include circuits that execute various arithmetic and logical operations including general-purpose code, graphics code, and video-image-speech (VIS) processing. VIS processing includes video processing, image processing, digital signal processing (DSP) loops, speech processing, and voice recognition algorithms, for example.</p>\n<p num=\"p-0062\">Referring to <figref idrefs=\"DRAWINGS\">FIGS. 5A</figref>, <b>5</b>B, and <b>5</b>C, a schematic block diagram of a divided or split register file, a high level view of computation elements of a functional unit, and a pictorial view of an instruction format, respectively are used to illustrate the difficulty of defining an instruction format with a limited number of instruction bits. <figref idrefs=\"DRAWINGS\">FIG. 5A</figref> shows a schematic block diagram of a decoder <b>502</b> that decodes four subinstructions of a very long instruction word. Each of the four decoders applies control signals to one of four register file segments <b>510</b>, <b>512</b>, <b>514</b>, and <b>516</b>. Each of the register file segments is coupled to and associated with a functional unit. In the illustrative embodiment, a first register file segment <b>510</b> is coupled to and associated with a general functional unit <b>520</b>. Second, third, and fourth register file segments <b>512</b>, <b>514</b>, and <b>516</b> are respectively coupled to and associated with media functional units <b>522</b>, <b>524</b>, and <b>526</b>.</p>\n<p num=\"p-0063\"><figref idrefs=\"DRAWINGS\">FIG. 5B</figref> shows an example of a VLIW subinstruction, specifically a multiply-add (muladd) instruction and relates execution of the muladd instruction to computation blocks in a functional unit. The muladd instruction specifies four register specifiers designating data that is operated upon by the functional unit. The muladd instruction specifies three source operands R<sub>A</sub>, R<sub>B</sub>, and R<sub>C</sub>, and one destination operand R<sub>D</sub>. The functional unit includes a multiplier <b>530</b> that multiplies the source operands R<sub>A </sub>and R<sub>B </sub>to generate a product. The functional unit also includes an adder <b>532</b> that receives the product from the multiplier <b>530</b> and adds the product and the source operand R<sub>C </sub>to produce a sum that is transferred to the destination register operand R<sub>D</sub>.</p>\n<p num=\"p-0064\">For a register file in which the register file segments include N=2<sup>M </sup>registers, for example, M bits are used to uniquely specify a particular register so that 4*M are needed to uniquely specify the four registers addressed in a single subinstruction.</p>\n<p num=\"p-0065\"><figref idrefs=\"DRAWINGS\">FIG. 5C</figref> depicts a subinstruction storage for instructions such as the muladd instruction. Resource size and speed constraints are imposed on instruction storage so that the number of bits in a subinstruction are limited. The four register specifiers for the subinstruction use nearly the entire capacity of the subinstruction storage. For example, a register file segment that includes 128 bits has registers that are uniquely addressed using seven address bits. Addressing of four registers consumes 7*4=28 bits. For a subinstruction size constrained to 32 bits, only four bits remain for specifying an operation code or other operational information for controlling execution.</p>\n<p num=\"p-0066\">The illustrative VLIW processor partitions the register file into local and global registers to conserve address bits in a very long instruction word to reduce the size of the register file and accelerate access time.</p>\n<p num=\"p-0067\">Referring to <figref idrefs=\"DRAWINGS\">FIG. 6</figref>, a schematic block diagram shows a register file <b>600</b></p>\n<p num=\"p-0068\">Referring to <figref idrefs=\"DRAWINGS\">FIG. 6</figref>, a schematic block diagram shows a register file <b>600</b> for a VLIW processor <b>100</b> that includes global and local register partitioning. The Very Long Instruction Word (VLIW) processor has a plurality of functional units including three media functional units <b>622</b>, <b>624</b>, and <b>626</b>, and a general functional unit <b>620</b>. The processor <b>100</b> also includes a multi-ported register file <b>600</b> that is divided into a plurality of separate register file segments <b>610</b>, <b>612</b>, <b>614</b>, and <b>616</b>, each of the register file segments being associated to one of the plurality of functional units and to a decoder block of decoder <b>602</b>. The register file segments <b>610</b>, <b>612</b>, <b>614</b>, and <b>616</b> are partitioned into local registers and global registers. The global registers are read and written by all functional units <b>620</b>, <b>622</b>, <b>624</b>, and <b>626</b>. The local registers are read and written only by a functional unit associated with a particular register file segment. The local registers and global registers are addressed using register addresses in an address space that is separately defined for a register file segment/functional unit pair including register file segment <b>610</b>/general functional unit <b>620</b>, register file segment <b>612</b>/media functional unit <b>622</b>, register file segment <b>614</b>/media functional unit <b>624</b>, and register file segment <b>616</b>/media functional unit <b>626</b>.</p>\n<p num=\"p-0069\">The global registers are addressed within a selected global register range using the same register addresses for the plurality of register file segment/functional unit pairs, for example, global registers <b>0</b>\u2013<b>95</b>. The local registers in a register file segment are addressed using register addresses in a local register range outside the global register range, for example addresses <b>96</b>\u2013<b>127</b>, that are assigned within a single register file segment/functional unit pair. Register addresses <b>96</b>\u2013<b>127</b> applied to the register file segments in the local register range are the same for the plurality of register file segment/functional unit pairs and address registers locally within a register file segment/functional unit pair. The register specifiers of the local registers, as defined external to processor, do not overlap but instead have distinct and different specifiers. For example, in one embodiment, external to the processor <b>100</b>, the 96 global registers are addressed using address specifiers <b>0</b>\u2013<b>95</b> in all of the four register file segments. Local registers <b>96</b>\u2013<b>127</b> in the register file segment <b>610</b>, local registers <b>128</b>\u2013<b>159</b> in register file segment <b>612</b>, local registers <b>160</b>\u2013<b>191</b> in register file segment <b>614</b>, and local registers <b>192</b>\u2013<b>223</b> in register file segment <b>616</b> are all addressed using register addresses <b>96</b>\u2013<b>127</b>. In this example, the total number of distinct and independent registers is 96+(4*32)=224. The 224 registers are addressed using 7 bits that define an address space from <b>0</b>\u2013<b>127</b>, rather than the 8 bits that are otherwise required to access 224 registers.</p>\n<p num=\"p-0070\">Global and local register partitioning advantageously leverages the information content of register specifier bits in an instruction word by inherently communicating information by position dependence within a VLIW instruction group. The positioning of a register specifier in the instruction word thus communicates addressing information. The additional information allows a compiler or programmer to specify more registers in fewer bits than have been specified conventionally.</p>\n<p num=\"p-0071\">One address bit is thus saved for each of the four subinstruction positions, a savings of four bits per subinstruction and a savings of 16 bits per VLIW instruction. The reduction in address bits is highly advantageous in a VLIW processor that includes powerful functional units that execute a large plurality of instructions, each of which is to be encoded in the VLIW instruction word.</p>\n<p num=\"p-0072\">In general embodiments, the register file <b>600</b> includes N physical registers. The N-register register file <b>600</b> is duplicated into M register file segments <b>610</b>, <b>612</b>, <b>614</b>, and <b>616</b>, each having a reduced number of read and/or write ports in comparison to a nonduplicated register file, but each having the same number of physical registers. The register file segments are partitioned into N<sub>G </sub>global and N<sub>L </sub>local register files where N<sub>G </sub>plus N<sub>L </sub>is equal to N. The register file operates equivalently to having N<sub>G</sub>+(M*N<sub>L</sub>) total registers available for the M functional units. The number of address bits for addressing the N<sub>G</sub>+(M*N<sub>L</sub>) total registers remains equal to the number of bits B that are used to address N=2<sup>B </sup>registers. The local registers for each of the M register file segments are addressed using the same B-bit values.</p>\n<p num=\"p-0073\">In some embodiments, partitioning of the register file <b>600</b> is programmable so that the number N<sub>G </sub>of global registers and number N<sub>L </sub>of local registers is selectable and variable. For example, a register file including four register file segments each having 128 registers may be programmably configured as a flat register file with 128 global registers and 0 local registers with the 128 registers addressed using seven address bits. Alternatively, the four register file segments may be programmably configured, for example, to include 64 global registers and 64 local registers so that the total number of registers is 64+(4*64)=320 registers that are again addressed using 7 bits rather than the 9 bits that would otherwise be required to address 320 registers.</p>\n<p num=\"p-0074\">Referring to <figref idrefs=\"DRAWINGS\">FIG. 7</figref>, a schematic block diagram depicts an embodiment of the multiport register file <b>216</b>. A plurality of read address buses RA<b>1</b> through RAN carry read addresses that are applied to decoder ports <b>816</b>-<b>1</b> through <b>816</b>-N, respectively. Decoder circuits are well known to those of ordinary skill in the art, and any of several implementations could be used as the decoder ports <b>816</b>-<b>1</b> through <b>816</b>-N. When an address is presented to any of decoder ports <b>816</b>-<b>1</b> through <b>816</b>-N, the address is decoded and a read address signal is transmitted by a decoder port <b>816</b> to a register in a memory cell array <b>818</b>. Data from the memory cell array <b>818</b> is output using output data drivers <b>822</b>. Data is transferred to and from the memory cell array <b>818</b> under control of control signals carried on some of the lines of the buses of the plurality of read address buses RA<b>1</b> through RAN.</p>\n<p num=\"p-0075\">Referring to <figref idrefs=\"DRAWINGS\">FIGS. 8A and 8B</figref>, a schematic block diagram and a pictorial diagram, respectively, illustrate the register file <b>216</b> and a memory array insert <b>910</b>. The register file <b>216</b> is connected to a four functional units <b>920</b>, <b>922</b>, <b>924</b>, and <b>926</b> that supply information for performing operations such as arithmetic, logical, graphics, data handling operations and the like. The illustrative register file <b>216</b> has twelve read ports <b>930</b> and four write ports <b>932</b>. The twelve read ports <b>930</b> are illustratively allocated with three ports connected to each of the four functional units. The four write ports <b>932</b> are connected to receive data from all of the four functional units.</p>\n<p num=\"p-0076\">The register file <b>216</b> includes a decoder, as is shown in <figref idrefs=\"DRAWINGS\">FIG. 6</figref>, for each of the sixteen read and write ports. The register file <b>216</b> includes a memory array <b>940</b> that is partially shown in the insert <b>910</b> illustrated in <figref idrefs=\"DRAWINGS\">FIG. 8B</figref> and includes a plurality of word lines <b>944</b> and bit lines <b>946</b>. The word lines <b>944</b> and bit lines <b>946</b> are simply a set of wires that connect transistors (not shown) within the memory array <b>940</b>. The word lines <b>944</b> select registers so that a particular word line selects a register of the register file <b>216</b>. The bit lines <b>946</b> are a second set of wires that connect the transistors in memory array <b>940</b>. Typically, the word lines <b>944</b> and bit lines <b>946</b> are laid out at right angles. In the illustrative embodiment, the word lines <b>944</b> and the bit lines <b>946</b> are constructed of metal laid out in different planes such as a metal <b>2</b> layer for the word lines <b>944</b> and a metal <b>3</b> layer for the bit lines <b>946</b>. In other embodiments, bit lines and word lines may be constructed of other materials, such as polysilicon, or can reside at different levels than are described in the illustrative embodiment, that are known in the art of semiconductor manufacture. In the illustrative example, the word lines <b>944</b> are separated by a distance of about 1 \u03bcm and the bit lines <b>946</b> are separated by approximately 1 \u03bcm. Other circuit dimensions may be constructed for various processes. The illustrative example shows one bit line per port, other embodiments may use multiple bit lines per port.</p>\n<p num=\"p-0077\">When a particular functional unit reads a particular register in the register file <b>216</b>, the functional unit sends an address signal via the read ports <b>930</b> that activates the appropriate word lines to access the register. In a register file having a conventional structure and twelve read ports, each cell, each storing a single bit of information, is connected to twelve word lines to select an address and twelve bit lines to carry data read from the address.</p>\n<p num=\"p-0078\">The four write ports <b>932</b> address registers in the register file using four word lines <b>944</b> and four bit lines <b>946</b> connected to each cell. The four word lines <b>944</b> address a cell and the four bit lines <b>946</b> carry data to the cell.</p>\n<p num=\"p-0079\">Thus, if the illustrative register file <b>216</b> were laid out in a conventional manner with twelve read ports <b>930</b> and four write ports <b>932</b> for a total of sixteen ports and the ports were 1 \u03bcm apart, one memory cell would have an integrated circuit area of 256 \u03bcm<sup>2 </sup>(16\u00d716). The area is proportional to the square of the number of ports.</p>\n<p num=\"p-0080\">The register file <b>216</b> is alternatively implemented to perform single-ended reads and/or single-ended writes utilizing a single bit line per port per cell, or implemented to perform differential reads and/or differential writes using two bit lines per port per cell.</p>\n<p num=\"p-0081\">However, in this embodiment the register file <b>216</b> is not laid out in the conventional manner and instead is split into a plurality of separate and individual register file segments <b>224</b>. Referring to <figref idrefs=\"DRAWINGS\">FIG. 9</figref>, a schematic block diagram shows an arrangement of the register file <b>216</b> into the four register file segments <b>224</b>. The register file <b>216</b> remains operational as a single logical register file in the sense that the four of the register file segments <b>224</b> contain the same number of registers and the same register values as a conventional register file of the same capacity that is not split. The separated register file segments <b>224</b> differ from a register file that is not split through elimination of lines that would otherwise connect ports to the memory cells. Accordingly, each register file segment <b>224</b> has connections to only three of the twelve read ports <b>930</b>, lines connecting a register file segment to the other nine read ports are eliminated. All writes are broadcast so that each of the four register file segments <b>224</b> has connections to all four write ports <b>932</b>. Thus each of the four register file segments <b>224</b> has three read ports and four write ports for a total of seven ports. The individual cells are connected to seven word lines and seven bit lines so that a memory array with a spacing of 1 \u03bcm between lines has an area of approximately 49 \u03bcm<sub>2</sub>. In the illustrative embodiment, the four register file segments <b>224</b> have an area proportional to seven squared. The total area of the four register file segments <b>224</b> is therefore proportional to 49 times 4, a total of 196.</p>\n<p num=\"p-0082\">The split register file thus advantageously reduces the area of the memory array by a ratio of approximately 256/196 (1.3\u00d7 or 30%). The reduction in area further advantageously corresponds to an improvement in speed performance due to a reduction in the length of the word lines <b>944</b> and the bit lines <b>946</b> connecting the array cells that reduces the time for a signal to pass on the lines. The improvement in speed performance is highly advantageous due to strict time budgets that are imposed by the specification of high-performance processors and also to attain a large capacity register file that is operational at high speed. For example, the operation of reading the register file <b>216</b> typically takes place in a single clock cycle. For a processor that executes at 500 MHz, a cycle time of two nanoseconds is imposed for accessing the register file <b>216</b>. Conventional register files typically only have up to about 32 registers in comparison to the 128 registers in the illustrative register file <b>216</b> of the processor <b>100</b>. A register file <b>216</b> that is substantially larger than the register file in conventional processors is highly advantageous in high-performance operations such as video and graphic processing. The reduced size of the register file <b>216</b> is highly useful for complying with time budgets in a large capacity register file.</p>\n<p num=\"p-0083\">In some embodiments, the area of a register file is further reduced by using a special memory cell for the local registers that have write port connections to the functional unit that is locally associated with the register file segment. Thus the local registers are only written by the local functional unit. In the illustrative register file <b>216</b>, the special cell for local registers has only a single write port, reducing the number of word lines to four. The number of bit lines connected to the local registers is also reduced to four, allowing further compactness to the cell.</p>\n<p num=\"p-0084\">Referring to <figref idrefs=\"DRAWINGS\">FIG. 10</figref>, a simplified schematic timing diagram illustrates timing of the processor pipeline <b>1100</b>. The pipeline <b>1100</b> includes nine stages including three initiating stages, a plurality of execution phases, and two terminating stages. The three initiating stages are optimized to include only those operations necessary for decoding instructions so that jump and call instructions, which are pervasive in the Java\u2122 language, execute quickly. Optimization of the initiating stages advantageously facilitates branch prediction since branches, jumps, and calls execute quickly and do not introduce many bubbles.</p>\n<p num=\"p-0085\">The first of the initiating stages is a fetch stage <b>1110</b> during which the processor <b>100</b> fetches instructions from the 16 Kbyte two-way set-associative instruction cache <b>210</b>. The fetched instructions are aligned in the instruction aligner <b>212</b> and forwarded to the instruction buffer <b>214</b> in an align stage <b>1112</b>, a second stage of the initiating stages. The aligning operation properly positions the instructions for storage in a particular segment of the four register file segments <b>310</b>, <b>312</b>, <b>314</b>, and <b>316</b> and for execution in an associated functional unit of the three media functional units <b>220</b> and one general functional unit <b>222</b>. In a third stage, a decoding stage <b>1114</b> of the initiating stages, the fetched and aligned VLIW instruction packet is decoded and the scoreboard (not shown) is read and updated in parallel. The four register file segments <b>310</b>, <b>312</b>, <b>314</b>, and <b>316</b> each holds either floating-point data or integer data. The register files are read in the decoding (D) stage.</p>\n<p num=\"p-0086\">Following the decoding stage <b>1114</b>, the execution stages are performed. The two terminating stages include a trap-handling stage <b>1160</b> and a write-back stage <b>1162</b> during which result data is written-back to the split register file <b>216</b>.</p>\n<p num=\"p-0087\">While the invention has been described with reference to various embodiments, it will be understood that these embodiments are illustrative and that the scope of the invention is not limited to them. Many variations, modifications, additions and improvements of the embodiments described are possible. For example, those skilled in the art will readily implement the steps necessary to provide the structures and methods disclosed herein, and will understand that the process parameters, materials, and dimensions are given by way of example only and can be varied to achieve the desired structure as well as modifications which are within the scope of the invention. Variations and modifications of the embodiments disclosed herein may be made based on the description set forth herein, without departing from the scope and spirit of the invention as set forth in the following claims. For example, the described structure and operating method may be applied to a register file and processor of any suitable size. The register file may be much larger or much smaller than the described 128 registers. The very long instruction word may include any suitable number of subinstructions.</p>\n<p num=\"p-0088\">Similarly, although the illustrative register file has one bit line per port, in other embodiments more bit lines may be allocated for a port. The described word lines and bit lines are formed of a metal. In other examples, other conductive materials such as doped polysilicon may be employed for interconnects. The described register file uses single-ended reads and writes so that a single bit line is employed per bit and per port. In other processors, differential reads and writes with dual-ended sense amplifiers may be used so that two bit lines are allocated per bit and per port, resulting in a bigger pitch. Dual-ended sense amplifiers improve memory fidelity but greatly increase the size of a memory array, imposing a heavy burden on speed performance. Thus the advantages attained by the described register file structure are magnified for a memory using differential reads and writes. The spacing between bit lines and word lines is described to be approximately 1 \u03bcm. In some processors, the spacing may be greater than 1 \u03bcm. In other processors the spacing between lines is less than 1 \u03bcm.</p>\n<?DETDESC description=\"Detailed Description\" end=\"tail\"?>\n</description>"}], "inventors": [{"first_name": "Marc", "last_name": "Tremblay", "name": ""}, {"first_name": "William", "last_name": "Joy", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "SUN MICROSYSTEMS, INC."}, {"first_name": "", "last_name": "Oracle America, Inc.", "name": ""}, {"first_name": "", "last_name": "SUN MICROSYSTEMS, INC.", "name": ""}], "ipc_classes": [], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/30        20060101AFI20060926BHUS"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712208"}, {"primary": false, "label": "711209"}, {"primary": false, "label": "712E09054"}, {"primary": false, "label": "712E09027"}], "ecla_classes": [{"label": "G06F   9/38T6C"}, {"label": "G06F   9/30R5"}, {"label": "G06F   9/38E1"}, {"label": "G06F   9/30R"}, {"label": "G06F   9/38E6"}], "cpc_classes": [{"label": "G06F   9/3838"}, {"label": "G06F   9/3853"}, {"label": "G06F   9/3853"}, {"label": "G06F   9/3012"}, {"label": "G06F   9/3891"}, {"label": "G06F   9/3891"}, {"label": "G06F   9/3012"}, {"label": "G06F   9/3838"}, {"label": "G06F   9/30098"}, {"label": "G06F   9/30098"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1998-12-03", "application_date": "1998-12-03", "family_members": [{"ucid": "US-7437534-B2", "titles": [{"lang": "EN", "text": "Local and global register partitioning technique"}]}, {"ucid": "WO-2000033178-A1", "titles": [{"lang": "EN", "text": "LOCAL AND GLOBAL REGISTER PARTITIONING IN A VLIW PROCESSOR"}, {"lang": "FR", "text": "SEGMENTATION DE REGISTRE LOCAL ET GLOBAL DANS UN PROCESSEUR A VLIW"}]}, {"ucid": "DE-69907955-T2", "titles": [{"lang": "EN", "text": "GLOBAL AND LOCAL REGISTER SEGMENTATION IN A VLIW PROCESSOR"}, {"lang": "DE", "text": "GLOBALE UND LOCALE REGISTERSEGMENTIERUNG IN EINEM VLIW PROZESSOR"}]}, {"ucid": "EP-1137982-B1", "titles": [{"lang": "FR", "text": "LOCALE ET GLOBALE SEGMENTATION DE REGISTRES DANS UN PROCESSEUR A VLIW"}, {"lang": "EN", "text": "LOCAL AND GLOBAL REGISTER PARTITIONING IN A VLIW PROCESSOR"}, {"lang": "DE", "text": "GLOBALE UND LOCALE REGISTERSEGMENTIERUNG IN EINEM VLIW PROZESSOR"}]}, {"ucid": "US-7114056-B2", "titles": [{"lang": "EN", "text": "Local and global register partitioning in a VLIW processor"}]}, {"ucid": "US-20070016758-A1", "titles": [{"lang": "EN", "text": "Local and Global Register Partitioning Technique"}]}, {"ucid": "US-20010042190-A1", "titles": [{"lang": "EN", "text": "LOCAL AND GLOBAL REGISTER PARTITIONING IN A VLIW PROCESSOR"}]}, {"ucid": "DE-69907955-D1", "titles": [{"lang": "EN", "text": "GLOBAL AND LOCAL REGISTER SEGMENTATION IN A VLIW PROCESSOR"}, {"lang": "DE", "text": "GLOBALE UND LOCALE REGISTERSEGMENTIERUNG IN EINEM VLIW PROZESSOR"}]}, {"ucid": "EP-1137982-A1", "titles": [{"lang": "FR", "text": "SEGMENTATION DE REGISTRE LOCAL ET GLOBAL DANS UN PROCESSEUR A VLIW"}, {"lang": "EN", "text": "LOCAL AND GLOBAL REGISTER PARTITIONING IN A VLIW PROCESSOR"}, {"lang": "DE", "text": "GLOBALE UND LOCALE REGISTERSEGMENTIERUNG IN EINEM VLIW PROZESSOR"}]}]}