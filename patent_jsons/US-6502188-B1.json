{"patent_number": "US-6502188-B1", "publication_id": 73251783, "family_id": 23753654, "publication_date": "2002-12-31", "titles": [{"lang": "EN", "text": "Dynamic classification of conditional branches in global history branch prediction"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11444642\" source=\"national office\"><p>A branch prediction unit includes a local branch prediction and a global branch prediction. A global branch prediction utilizes a global history shift register to record the behavior of conditional branches. In some cases, a conditional branch may behave in a static manner, either always being taken or not taken, while resident in an instruction cache. Such static behaving conditional branches do not need a global history for prediction and contend with other conditional branches for global branch history training. By utilizing a dynamic branch classification scheme, branches requiring global history prediction can be identified and static behaving conditional branches may be prevented from polluting the global history. All conditional branches are initially classified as local and do not participate in global history training. Only after two mispredictions are branches recognized as exhibiting dynamic behavior and classified as global. These branches classified as global may then participate in global history training and utilize a global history based branch prediction.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50429124\"><p>A branch prediction unit includes a local branch prediction and a global branch prediction. A global branch prediction utilizes a global history shift register to record the behavior of conditional branches. In some cases, a conditional branch may behave in a static manner, either always being taken or not taken, while resident in an instruction cache. Such static behaving conditional branches do not need a global history for prediction and contend with other conditional branches for global branch history training. By utilizing a dynamic branch classification scheme, branches requiring global history prediction can be identified and static behaving conditional branches may be prevented from polluting the global history. All conditional branches are initially classified as local and do not participate in global history training. Only after two mispredictions are branches recognized as exhibiting dynamic behavior and classified as global. These branches classified as global may then participate in global history training and utilize a global history based branch prediction.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00001\" num=\"1\"><claim-text>1. A branch prediction mechanism comprising:</claim-text><claim-text>a local branch prediction storage coupled to receive a fetch address, wherein said fetch address corresponds to a group of contiguous instruction bytes being fetched from an instruction cache, wherein said local branch prediction storage is configured to convey a local branch prediction; and </claim-text><claim-text>a global branch prediction storage coupled to receive said fetch address and a global history, wherein said fetch address and said global history are combined to form an index, and wherein said index is used to select a global branch prediction from said global branch prediction storage; and </claim-text><claim-text>a branch target storage coupled to receive said fetch address, wherein said target storage is configured to store a branch target address corresponding to said fetch address, wherein said target storage is configured to store a classification indicator corresponding to a branch having said branch target address, and wherein said indicator is initialized to indicate said branch is a local branch, and wherein said indicator is updated to indicate said branch is a global branch in response to detecting a first condition; and </claim-text><claim-text>a selection device configured to select said local branch prediction in response to detecting said indicator indicates said branch is a local branch, and wherein said selection device is configured to select said global branch prediction in response to detecting said indicator indicates said branch is a global branch. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00002\" num=\"2\"><claim-text>2. The branch prediction mechanism of <claim-ref idref=\"US-6502188-B1-CLM-00001\">claim 1</claim-ref>, wherein said local branch prediction comprises a branch selector.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00003\" num=\"3\"><claim-text>3. The branch prediction mechanism of <claim-ref idref=\"US-6502188-B1-CLM-00001\">claim 1</claim-ref>, wherein said global branch prediction comprises a predicted branch direction, wherein said predicted branch direction comprises a two bit saturating counter.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00004\" num=\"4\"><claim-text>4. The branch prediction mechanism of <claim-ref idref=\"US-6502188-B1-CLM-00001\">claim 1</claim-ref>, further comprising a global history shift register configured to store said global history, wherein said global history shift register is configured to record a direction of a conditional branch.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00005\" num=\"5\"><claim-text>5. The branch prediction mechanism of <claim-ref idref=\"US-6502188-B1-CLM-00004\">claim 4</claim-ref>, wherein said recording comprises shifting a bit into said global history shift register, wherein said bit corresponds to a most recently dispatched conditional branch, wherein said bit indicates a predicted direction of said conditional branch, and wherein said global history shift register is updated to reflect the actual behavior of said conditional branch.</claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00006\" num=\"6\"><claim-text>6. The branch prediction mechanism of <claim-ref idref=\"US-6502188-B1-CLM-00005\">claim 5</claim-ref>, further comprising an update logic, wherein said update logic is configured to perform said update in response to detecting a misprediction of said conditional branch.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00007\" num=\"7\"><claim-text>7. The branch prediction mechanism of <claim-ref idref=\"US-6502188-B1-CLM-00001\">claim 1</claim-ref>, wherein a multiple branch indicator associated with said group of contiguous instruction bytes is stored in said local branch prediction storage, wherein said indicator is initialized to indicate no multiple branch condition exists.</claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00008\" num=\"8\"><claim-text>8. The branch prediction mechanism of <claim-ref idref=\"US-6502188-B1-CLM-00007\">claim 7</claim-ref>, wherein said indicator is updated to indicate a multiple branch condition exists, in response to detecting a mispredicted branch, wherein said mispredicted branch is among said group of contiguous instruction bytes, wherein a plurality of branches are detected among said group of contiguous instruction bytes, and wherein a global branch is detected among said plurality of branches, and wherein said global branch is not the last branch in program order of said plurality of branches.</claim-text></claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00009\" num=\"9\"><claim-text>9. The branch prediction mechanism of <claim-ref idref=\"US-6502188-B1-CLM-00007\">claim 7</claim-ref>, wherein a predicted target address for a branch prediction corresponding to said branch instruction is a sequential address, in response to detecting a predicted not taken global branch, wherein said indicator indicates no multiple branch condition exists, and wherein a predicted target address for said branch prediction is an address corresponding to a instruction within said group of instruction immediately following said branch instruction, in response to detecting said branch is a predicted not taken global branch, wherein said indicator indicates a multiple branch condition exists.</claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00010\" num=\"10\"><claim-text>10. A method comprising:</claim-text><claim-text>detecting an instruction is a conditional branch; and </claim-text><claim-text>initializing a local branch prediction corresponding to said conditional branch to indicate said conditional branch is predicted not taken; and </claim-text><claim-text>updating said local branch prediction to indicate said conditional branch is predicted taken, and wherein a branch classification for said conditional branch is initialized to indicate said branch is local, in response to detecting a misprediction of said conditional branch as predicted not taken; </claim-text><claim-text>updating said branch classification to indicate said branch is global, in response to detecting a misprediction of said conditional branch as predicted taken; </claim-text><claim-text>predicting said conditional branch using a local branch prediction in response to detecting said branch prediction indicates not taken; </claim-text><claim-text>predicting said conditional branch using a local branch prediction in response to detecting said conditional branch is classified as local; and </claim-text><claim-text>predicting said conditional branch using a global branch prediction in response to detecting said conditional branch is classified as global. </claim-text></claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00011\" num=\"11\"><claim-text>11. A method comprising:</claim-text><claim-text>detecting an instruction is a conditional branch, and </claim-text><claim-text>initializing a local branch prediction corresponding to said conditional branch to indicate said conditional branch is predicted not taken; and </claim-text><claim-text>updating said local branch prediction to indicate said conditional branch is predicted taken, and wherein a branch classification for said conditional branch is initialized to indicate said branch is local, in response to detecting a r misprediction of said conditional branch as predicted not taken; </claim-text><claim-text>updating said branch classification to indicate said branch is global, in response to detecting a misprediction of said conditional branch as predicted taken; and </claim-text><claim-text>storing a multiple branch indicator associated with a contiguous group of instructions, wherein said indicator is initialized to indicate a multiple branch condition does not exist. </claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00012\" num=\"12\"><claim-text>12. The method of <claim-ref idref=\"US-6502188-B1-CLM-00011\">claim 11</claim-ref>, further comprising updating said indicator to indicate a multiple branch condition exists, in response to detecting a mispredicted branch, wherein said mispredicted branch is among said group of instructions, wherein a plurality of branches are detected among said group of instructions, and wherein a global branch is detected among said plurality of branches, and wherein said global branch is, not the last branch in program order of said plurality of branches.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00013\" num=\"13\"><claim-text>13. A computer system comprising:</claim-text><claim-text>a processor including a branch prediction mechanism, wherein said branch prediction mechanism comprises a local branch prediction storage coupled to receive a fetch address, wherein said fetch address corresponds to a group of contiguous instruction bytes being fetched from an instruction cache, wherein said local branch prediction storage is configured to convey a local branch prediction; and a global branch prediction storage coupled to receive said fetch address and a global history, wherein said fetch address and said global history are combined to form an index, and wherein said index is used to select a global branch prediction from said global branch prediction storage; and a branch target storage coupled to receive said fetch address, wherein said target storage is configured to store a branch target address corresponding to said fetch address, wherein said target storage is configured to store a classification indicator corresponding to a branch having said branch target address, and wherein said indicator is initialized to indicate said branch is a local branch, and wherein said indicator is updated to indicate said branch is a global branch in response to detecting a first condition; and a selection device configured to select said local branch prediction in response to detecting said indicator indicates said branch is a local branch, and wherein said selection device is configured to select said global branch prediction in response to detecting said indicator indicates said branch is a global branch. ; and </claim-text><claim-text>an input/output (I/O) device configured to communicate between said computer system and another computer system to which said I/O device is couplable. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00014\" num=\"14\"><claim-text>14. The computer system as recited in <claim-ref idref=\"US-6502188-B1-CLM-00013\">claim 13</claim-ref> wherein said I/O device is a modem.</claim-text></claim>"}, {"num": 15, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00015\" num=\"15\"><claim-text>15. A method comprising:</claim-text><claim-text>detecting an instruction is a conditional branch; and </claim-text><claim-text>initializing a local branch prediction corresponding to said conditional branch to indicate said conditional branch is predicted not taken; and </claim-text><claim-text>updating said local branch prediction to indicate said conditional branch is predicted taken, and wherein a branch classification for said conditional branch is initialized to indicate said branch is local, in response to detecting a misprediction of said conditional branch as predicted not taken; </claim-text><claim-text>updating said branch classification to indicate said branch is global, in response to detecting a misprediction of said conditional branch as predicted taken; </claim-text><claim-text>selecting a sequential address as a next fetch address in response to detecting a predicted not taken global branch, wherein said indicator indicates no multiple branch condition exists; and </claim-text><claim-text>selecting an address corresponding to an instruction immediately following said branch instruction within said group of instructions, in response to detecting a predicted not taken global branch, wherein said indicator indicates a multiple branch condition exists. </claim-text></claim>"}, {"num": 16, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00016\" num=\"16\"><claim-text>16. A method comprising:</claim-text><claim-text>detecting an instruction is a conditional branch; and </claim-text><claim-text>initializing a local branch prediction corresponding to said conditional branch to indicate said conditional branch is predicted not taken; and </claim-text><claim-text>updating said local branch prediction to indicate said conditional branch is predicted taken, and wherein a branch classification for said conditional branch is initialized to indicate said branch is local, in response to detecting a misprediction of said conditional branch as predicted not taken; </claim-text><claim-text>updating said branch classification to indicate said branch is global, in response to detecting a misprediction of said conditional branch as predicted taken; and </claim-text><claim-text>storing a history of said conditional branch in a global history storage, wherein said global history storage comprises a global history shift register. </claim-text></claim>"}, {"num": 17, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00017\" num=\"17\"><claim-text>17. A method comprising:</claim-text><claim-text>detecting an instruction is a conditional branch; and </claim-text><claim-text>initializing a local branch prediction corresponding to said conditional branch to indicate said conditional branch is predicted not taken; and </claim-text><claim-text>updating said local branch prediction to indicate said conditional branch is predicted taken, and wherein a branch classification for said conditional branch is initialized to indicate said branch is local, in response to detecting a misprediction of said conditional branch as predicted not taken; </claim-text><claim-text>updating said branch classification to indicate said branch is global, in response to detecting a misprediction of said conditional branch as predicted taken; and </claim-text><claim-text>storing a history of said conditional branch in a global history storage, wherein said storing comprises shifting a bit into said global history shift register, wherein said bit corresponds to a most recently dispatched global branch, wherein said bit indicates a predicted direction of said global branch. </claim-text></claim>"}, {"num": 18, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00018\" num=\"18\"><claim-text>18. A method comprising:</claim-text><claim-text>detecting an instruction is a conditional branch; and </claim-text><claim-text>initializing a local branch prediction corresponding to said conditional branch to indicate said conditional branch is predicted not taken; and </claim-text><claim-text>updating said local branch prediction to indicate said conditional branch is predicted taken, and wherein a branch classification for said conditional branch is initialized to indicate said branch is local, in response to detecting a misprediction of said conditional branch as predicted not taken; </claim-text><claim-text>updating said branch classification to indicate said branch is global, in response to detecting a misprediction of said conditional branch as predicted taken; </claim-text><claim-text>storing a history of said conditional branch in a global history storage; and </claim-text><claim-text>updating said history in response to detecting a misprediction of said global branch, wherein said update modifies said global history storage to reflect an actual behavior of said conditional branch. </claim-text></claim>"}, {"num": 19, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6502188-B1-CLM-00019\" num=\"19\"><claim-text>19. A method comprising:</claim-text><claim-text>detecting an instruction is a conditional branch; and </claim-text><claim-text>initializing a local branch prediction corresponding to said conditional branch to indicate said conditional branch is predicted not taken; and </claim-text><claim-text>updating said local branch prediction to indicate said conditional branch is predicted taken, and wherein a branch classification for said conditional branch is initialized to indicate said branch is local, in response to detecting a misprediction of said conditional branch as predicted not taken; </claim-text><claim-text>updating said branch classification to indicate said branch is global, in response to detecting a misprediction of said conditional branch as predicted taken; </claim-text><claim-text>storing said classification indicator in a branch target storage, said storage being coupled to receive a fetch address and store a branch target address corresponding to said fetch address; </claim-text><claim-text>selecting said local branch prediction in response to detecting said indicator indicates said branch is a local branch; and </claim-text><claim-text>selecting a global branch prediction from a global branch prediction storage in response to detecting said indicator indicates said branch is a global branch.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53689319\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention is related to the field of superscalar microprocessors and, more particularly, to the classification of conditional branches in branch prediction.</p><p>2. Description of the Related Art</p><p>Superscalar microprocessors achieve high performance by executing multiple instructions per clock cycle and by choosing the shortest possible clock cycle consistent with the design. As used herein, the term\u201cclock cycle\u201d refers to an interval of time accorded to various stages of an instruction processing pipeline within the microprocessor. Storage devices (e.g. registers and arrays) capture their values according to the clock cycle. For example, a storage device may capture a value according to a rising or falling edge of a clock signal defining the clock cycle. The storage device then stores the value until the subsequent rising or falling edge of the clock signal, respectively. The term \u201cinstruction processing pipeline\u201d is used herein to refer to the logic circuits employed to process instructions in a pipelined fashion. Although the pipeline may be divided into any number of stages at which portions of instruction processing are performed, instruction processing generally comprises fetching the instruction, decoding the instruction, executing the instruction, and storing the execution results in the destination identified by the instruction.</p><p>An important feature of a superscalar microprocessor (and a superpipelined microprocessor as well) is its branch prediction mechanism. The branch prediction mechanism indicates a predicted direction (taken or not taken) for a branch instruction, allowing subsequent instruction fetching to continue within the predicted instruction stream indicated by the branch prediction. A branch instruction is an instruction which causes subsequent instructions to be fetched from one of at least two addresses: a sequential address identifying an instruction stream beginning with instructions which directly follow the branch instruction; and a target address identifying an instruction stream beginning at an arbitrary location in memory. Unconditional branch instructions always branch to the target address, while conditional branch instructions may select either the sequential or the target address based on the outcome of a prior instruction. Instructions from the predicted instruction stream may be speculatively executed prior to execution of the branch instruction, and in any case are placed into the instruction processing pipeline prior to execution of the branch instruction. If the predicted instruction stream is correct, then the number of instructions executed per clock cycle is advantageously increased. However, if the predicted instruction stream is incorrect (i.e. one or more branch instructions are predicted incorrectly), then the instructions from the incorrectly predicted instruction stream are discarded from the instruction processing pipeline and the number of instructions executed per clock cycle is decreased.</p><p>In order to be effective, the branch prediction mechanism must be highly accurate such that the predicted instruction stream is correct as often as possible. Typically, increasing the accuracy of the branch prediction mechanism is achieved by increasing the complexity of the branch prediction mechanism. Among the methods used to predict branches are local branch prediction and global branch prediction. Local branch prediction involves making a prediction based on the behavior of a particular branch the past few times it was executed. Local branch prediction is effective for branches exhibiting repetitive patterns. On the other hand, global branch prediction involves making a branch prediction based on the history of the last few branches to have been executed. Global branch prediction is useful when the behavior of a branch is related to the behavior of the prior executed branches.</p><p>One problem with global branch prediction schemes is they do not account for branches that do not require a global history for prediction. Typically, all conditional branches participate in global history counter training. While some branches may be conditional, they may in fact exhibit static behavior by always being either taken or not taken. Such branches do not need a global history for prediction and contend with other conditional branches for history counter training. Consequently, the global prediction is in effect polluted by the training of branches which behave in a static manner.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by a microprocessor and method as described herein. When a conditional branch is initially detected, it is classified as local and predicted not taken. If the branch is then actually taken, its prediction is changed to taken. If the branch is then actually not taken, its classification is changed to global, uses global branch prediction and participates in global history counter training. Advantageously, branches which exhibit static behavior may not participate in global history counter training. Instead, branches which are not taken may remain classified as local and not taken. Branches which are taken may remain classified as local and taken.</p><p>Broadly speaking, a branch prediction mechanism is contemplated comprising a local branch prediction storage, a global branch prediction storage, a branch target storage and a selection device. The local branch prediction storage receives a fetch address corresponding to a contiguous group of instructions and conveys a local branch prediction. The global branch prediction storage receives a fetch address and a global history which form an index for selecting a global prediction from the global prediction storage. The branch target storage also receives a fetch address is configured to store branch target addresses and classification indicators for classifying branches. This classification indicator is initially set to indicate the branch is local, but may be updated. Finally, a selection device is included for selecting either the local branch prediction or the global branch prediction in response to the classification conveyed by the classification indicator.</p><p>Also contemplated is a method comprising detecting that an instruction is a conditional branch. Upon such detection, a local branch prediction corresponding to the conditional branch is initialized to indicate the branch is predicted not taken. If the branch is then mispredicted, the local branch prediction is updated to indicate the branch is now predicted taken. In addition, the branch is classified as local. Finally, if the branch is again mispredicted, the branch classification is updated to indicate the branch is classified as global.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of one embodiment of a microprocessor.</p><p>FIG. 2 is a flowchart illustrating a branch classification scheme.</p><p>FIG. 3 is a diagram of one embodiment of a branch prediction apparatus included in the microprocessor shown in FIG. <b>1</b>.</p><p>FIGS. 4-7 illustrate updating of a global history shift register.</p><p>FIGS. 8-9 show two embodiments of a group of contiguous bytes of instructions and corresponding branch selectors.</p><p>FIG. 10 is a table showing branch selectors and address encoding.</p><p>FIGS. 11-14 illustrate various end byte encodings for branch selectors.</p><p>FIG. 15 is a table illustrating one embodiment of branch selector encoding.</p><p>FIG. 16 show an embodiment of a group of contiguous bytes of instructions and corresponding branch selectors with an added multiple branch indicator bit.</p><p>FIG. 17 shows a portion of the branch prediction apparatus shown in FIG. 3 used for generating a second fetch.</p><p>FIG. 18 is a block diagram of one embodiment of a computer system including the microprocessor shown in FIG. <b>1</b>.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>Processor Overview</p><p>Turning now to FIG. 1, a block diagram of one embodiment of a processor <b>10</b> is shown. Other embodiments are possible and contemplated. As shown in FIG. 1, processor <b>10</b> includes a prefetch/predecode unit <b>12</b>, a branch prediction unit <b>14</b>, an instruction cache <b>16</b>, an instruction alignment unit <b>18</b>, a plurality of decode units <b>20</b>A-<b>20</b>C, a plurality of reservation stations <b>22</b>A-<b>22</b>C, a plurality of functional units <b>24</b>A-<b>24</b>C, a load/store unit <b>26</b>, a data cache <b>28</b>, a register file <b>30</b>, a reorder buffer <b>32</b>, an MROM unit <b>34</b>, and a bus interface unit <b>37</b>. Elements referred to herein with a particular reference number followed by a letter will be collectively referred to by the reference number alone. For example, decode units <b>20</b>A-<b>20</b>C will be collectively referred to as decode units <b>20</b>.</p><p>Prefetch/predecode unit <b>12</b> is coupled to receive instructions from bus interface unit <b>37</b>, and is further coupled to instruction cache <b>16</b> and branch prediction unit <b>14</b> Similarly, branch prediction unit <b>14</b> is coupled to instruction cache <b>16</b>. Still further, branch prediction unit <b>14</b> is coupled to decode units <b>20</b> and functional units <b>24</b>. Instruction cache <b>16</b> is further coupled to MROM unit <b>34</b> and instruction alignment unit <b>18</b>. Instruction alignment unit <b>18</b> is in turn coupled to decode units <b>20</b>. Each decode unit <b>20</b>A-<b>20</b>C is coupled to load/store unit <b>26</b> and to respective reservation stations <b>22</b>A-<b>22</b>C. Reservation stations <b>22</b>A-<b>22</b>C are further coupled to respective functional units <b>24</b>A-<b>24</b>C. Additionally, decode units <b>20</b> and reservation stations <b>22</b> are coupled to register file <b>30</b> and reorder buffer <b>32</b>. Functional units <b>24</b> are coupled to load/store unit <b>26</b>, register file <b>30</b>, and reorder buffer <b>32</b> as well. Data cache <b>28</b> is coupled to load/store unit <b>26</b> and to bus interface unit <b>37</b>. Bus interface unit <b>37</b> is further coupled to an L<b>2</b> interface to an L<b>2</b> cache and a bus. Finally, MROM unit <b>34</b> is coupled to decode units <b>20</b>.</p><p>Instruction cache <b>16</b> is a high speed cache memory provided to store instructions. Instructions are fetched from instruction cache <b>16</b> and dispatched to decode units <b>20</b>. In one embodiment, instruction cache <b>16</b> is configured to store up to 64 kilobytes of instructions in a 2 way set associative structure having 64 byte lines (a byte comprises 8 binary bits). Alternatively, any other desired configuration and size may be employed. For example, it is noted that instruction cache <b>16</b> may be implemented as a fully associative, set associative, or direct mapped configuration.</p><p>Instructions are stored into instruction cache <b>16</b> by prefetch/predecode unit <b>12</b> Instructions may be prefetched prior to the request thereof from instruction cache <b>16</b> in accordance with a prefetch scheme. A variety of prefetch schemes may be employed by prefetch/predecode unit <b>12</b>. As prefetch/predecode unit <b>12</b> transfers instructions to instruction cache <b>16</b>, prefetch/predecode unit <b>12</b> generates three predecode bits for each byte of the instructions: a start bit, an end bit, and a functional bit. The predecode bits form tags indicative of the boundaries of each instruction. The predecode tags may also convey additional information such as whether a given instruction can be decoded directly by decode units <b>20</b> or whether the instruction is executed by invoking a microcode procedure controlled by MROM unit <b>34</b>, as will be described in greater detail below. Still further, prefetch/predecode unit <b>12</b> may be configured to detect branch instructions and to store branch prediction information corresponding to the branch instructions into branch prediction unit <b>14</b>. Other embodiments may employ any suitable predecode scheme.</p><p>One encoding of the predecode tags for an embodiment of processor <b>10</b> employing a variable byte length instruction set will next be described. A variable byte length instruction set is an instruction set in which different instructions may occupy differing numbers of bytes. An exemplary variable byte length instruction set employed by one embodiment of processor <b>10</b> is the x86 instruction set.</p><p>In the exemplary encoding, if a given byte is the first byte of an instruction, the start bit for that byte is set. If the byte is the last byte of an instruction, the end bit for that byte is set. Instructions which may be directly decoded by decode units <b>20</b> are referred to as \u201cfast path\u201d instructions. The remaining x86 instructions are referred to as MROM instructions, according to one embodiment. For fast path instructions, the functional bit is set for each prefix byte included in the instruction, and cleared for other bytes. Alternatively, for MROM instructions, the functional bit is cleared for each prefix byte and set for other bytes. The type of instruction may be determined by examining the functional bit corresponding to the end byte. If that functional bit is clear, the instruction is a fast path instruction. Conversely, if that functional bit is set, the instruction is an MROM instruction. The opcode of an instruction may thereby be located within an instruction which may be directly decoded by decode units <b>20</b> as the byte associated with the first clear functional bit in the instruction. For example, a fast path instruction including two prefix bytes, a Mod RIM byte, and an immediate byte would have start, end, and functional bits as follows:</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"offset\" colwidth=\"49pt\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"119pt\"></colspec><thead><row><entry></entry><entry align=\"center\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry><entry>Start bits</entry><entry>10000</entry></row><row><entry></entry><entry>End bits</entry><entry>00001</entry></row><row><entry></entry><entry>Functional bits</entry><entry>11000</entry></row><row><entry></entry><entry align=\"center\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>MROM instructions are instructions which are determined to be too complex for decode by decode units <b>20</b>. MROM instructions are executed by invoking MROM unit <b>34</b>. More specifically, when an MROM instruction is encountered, MROM unit <b>34</b> parses and issues the instruction into a subset of defined fast path instructions to effectuate the desired operation. MROM unit <b>34</b> dispatches the subset of fast path instructions to decode units <b>20</b>.</p><p>Processor <b>10</b> employs branch prediction in order to speculatively fetch instructions subsequent to conditional branch instructions. Branch prediction unit <b>14</b> is included to perform branch prediction operations. In one embodiment, branch prediction unit <b>14</b> employs a branch target buffer which caches up to two branch target addresses and corresponding taken/not taken predictions per 16 byte portion of a cache line in instruction cache <b>16</b>. The branch target buffer may, for example, comprise 2048 entries or any other suitable number of entries. Prefetch/predecode unit <b>12</b> determines initial branch targets when a particular line is predecoded. Subsequent updates to the branch targets corresponding to a cache line may occur due to the execution of instructions within the cache line. Instruction cache <b>16</b> provides an indication of the instruction address being fetched, so that branch prediction unit <b>14</b> may determine which branch target addresses to select for forming a branch prediction. Decode units <b>20</b> and functional units <b>24</b> provide update information to branch prediction unit <b>14</b>. Decode units <b>20</b> detect branch instructions which were not predicted by branch prediction unit <b>14</b>. Functional units <b>24</b> execute the branch instructions and determine if the predicted branch direction is incorrect. The branch direction may be \u201ctaken\u201d, in which subsequent instructions are fetched from the target address of the branch instruction. Conversely, the branch direction may be \u201cnot taken\u201d, in which subsequent instructions are fetched from memory locations consecutive to the branch instruction. When a mispredicted branch instruction is detected, instructions subsequent to the mispredicted branch are discarded from the various units of processor <b>10</b>. In an alternative configuration, branch prediction unit <b>14</b> may be coupled to reorder buffer <b>32</b> instead of decode units <b>20</b> and functional units <b>24</b>, and may receive branch misprediction information from reorder buffer <b>32</b>. A variety of suitable branch prediction algorithms may be employed by branch prediction unit <b>14</b>.</p><p>Instructions fetched from instruction cache <b>16</b> are conveyed to instruction alignment unit <b>18</b>. As instructions are fetched from instruction cache <b>16</b>, the corresponding predecode data is scanned to provide information to instruction alignment unit <b>18</b> (and to MROM unit <b>34</b>) regarding the instructions being fetched. Instruction alignment unit <b>18</b> utilizes the scanning data to align an instruction to each of decode units <b>20</b>. In one embodiment, instruction alignment unit <b>18</b> aligns instructions from three sets of eight instruction bytes to decode units <b>20</b>. Decode unit <b>20</b>A receives an instruction which is prior to instructions concurrently received by decode units <b>20</b>B and <b>20</b>C (in program order). Similarly, decode unit <b>20</b>B receives an instruction which is prior to the instruction concurrently received by decode unit <b>20</b>C in program order.</p><p>Decode units <b>20</b> are configured to decode instructions received from instruction alignment unit <b>18</b> Register operand information is detected and routed to register file <b>30</b> and reorder buffer <b>32</b>. Additionally, if the instructions require one or more memory operations to be performed, decode units <b>20</b> dispatch the memory operations to load/store unit <b>26</b>. Each instruction is decoded into a set of control values for functional units <b>24</b>, and these control values are dispatched to reservation stations <b>22</b> along with operand address information and displacement or immediate data which may be included with the instruction. In one particular embodiment, each instruction is decoded into up to two operations which may be separately executed by functional units <b>24</b>A-<b>24</b>C.</p><p>Processor <b>10</b> supports out of order execution, and thus employs reorder buffer <b>32</b> to keep track of the original program sequence for register read and write operations, to implement register renaming, to allow for speculative instruction execution and branch misprediction recovery, and to facilitate precise exceptions. A temporary storage location within reorder buffer <b>32</b> is reserved upon decode of an instruction that involves the update of a register to thereby store speculative register states. If a branch prediction is incorrect, the results of speculatively executed instructions along the mispredicted path can be invalidated in the buffer before they are written to register file <b>30</b>. Similarly, if a particular instruction causes an exception, instructions subsequent to the particular instruction may be discarded. In this manner, exceptions are \u201cprecise\u201d (i.e., instructions subsequent to the particular instruction causing the exception are not completed prior to the exception). It is noted that a particular instruction is speculatively executed if it is executed prior to instructions which precede the particular instruction in program order. Preceding instructions may be a branch instruction or an exception-causing instruction, in which case the speculative results may be discarded by reorder buffer <b>32</b>.</p><p>The instruction control values and immediate or displacement data provided at the outputs of decode units <b>20</b> are routed directly to respective reservation stations <b>22</b>. In one embodiment, each reservation station <b>22</b> is capable of holding instruction information (i.e., instruction control values as well as operand values, operand tags and/or immediate data) for up to five pending instructions awaiting issue to the corresponding functional unit. It is noted that for the embodiment of FIG. 1, each reservation station <b>22</b> is associated with a dedicated functional unit <b>24</b>. Accordingly, three dedicated \u201cissue positions\u201d are formed by reservation stations <b>22</b> and functional units <b>24</b>. In other words, issue position <b>0</b> is formed by reservation station <b>22</b>A and functional unit <b>24</b>A. Instructions aligned and dispatched to reservation station <b>22</b>A are executed by functional unit <b>24</b>A. Similarly, issue position <b>1</b> is formed by reservation station <b>22</b>B and functional unit <b>24</b>B; and issue position <b>2</b> is formed by reservation station <b>22</b>C and functional unit <b>24</b>C.</p><p>Upon decode of a particular instruction, if a required operand is a register location, register address information is routed to reorder buffer <b>32</b> and register file <b>30</b> simultaneously. In one embodiment, reorder buffer <b>32</b> includes a future file which receives operand requests from decode units as well. Those of skill in the art will appreciate that the x86 register file includes eight 32 bit real registers (i.e., typically referred to as EAX, EBX, ECX, EDX, EBP, ESI, EDI and ESP). In embodiments of processor <b>10</b> which employ the x86 processor architecture, register file <b>30</b> comprises storage locations for each of the 32 bit real registers. Additional storage locations may be included within register file <b>30</b> for use by MROM unit <b>34</b>. Reorder buffer <b>32</b> contains temporary storage locations for results which change the contents of these registers to thereby allow out of order execution. A temporary storage location of reorder buffer <b>32</b> is reserved for each instruction which, upon decode, is determined to modify the contents of one of the real registers. Therefore, at various points during execution of a particular program, reorder buffer <b>32</b> may have one or more locations which contain the speculatively executed contents of a given register. If following decode of a given instruction it is determined that reorder buffer <b>32</b> has a previous location or locations assigned to a register used as an operand in the given instruction, the reorder buffer <b>32</b> forwards to the corresponding reservation station either: 1) the value in the most recently assigned location, or 2) a tag for the most recently assigned location if the value has not yet been produced by the functional unit that will eventually execute the previous instruction. If reorder buffer <b>32</b> has a location reserved for a given register, the operand value (or reorder buffer tag) is provided from reorder buffer <b>32</b> rather than from register file <b>30</b>. If there is no location reserved for a required register in reorder buffer <b>32</b>, the value is taken directly from register file <b>30</b>. If the operand corresponds to a memory location, the operand value is provided to the reservation station through load/store unit <b>26</b>.</p><p>In one particular embodiment, reorder buffer <b>32</b> is configured to store and manipulate concurrently decoded instructions as a unit. This configuration will be referred to herein as \u201cline-oriented\u201d. By manipulating several instructions together, the hardware employed within reorder buffer <b>32</b> may be simplified. For example, a line-oriented reorder buffer included in the present embodiment allocates storage sufficient for instruction information pertaining to three instructions (one from each decode unit <b>20</b>) whenever one or more instructions are issued by decode units <b>20</b>. By contrast, a variable amount of storage is allocated in conventional reorder buffers, dependent upon the number of instructions actually dispatched. A comparatively larger number of logic gates may be required to allocate the variable amount of storage. When each of the concurrently decoded instructions has executed, the instruction results are stored into register file <b>30</b> simultaneously. The storage is then free for allocation to another set of concurrently decoded instructions. Additionally, the amount of control logic circuitry employed per instruction is reduced because the control logic is amortized over several concurrently decoded instructions. A reorder buffer tag identifying a particular instruction may be divided into two fields: a line tag and an offset tag. The line tag identifies the set of concurrently decoded instructions including the particular instruction, and the offset tag identifies which instruction within the set corresponds to the particular instruction. It is noted that storing instruction results into register file <b>30</b> and freeing the corresponding storage is referred to as \u201cretiring\u201d the instructions. It is further noted that any reorder buffer configuration may be employed in various embodiments of processor <b>10</b>, including using a future file to store the speculative state of register file <b>30</b>.</p><p>As noted earlier, reservation stations <b>22</b> store instructions until the instructions are executed by the corresponding functional unit <b>24</b>. An instruction is selected for execution if: (i) the operands of the instruction have been provided; and (ii) the operands have not yet been provided for instructions which are within the same reservation station <b>22</b>A-<b>22</b>C and which are prior to the instruction in program order. It is noted that when an instruction is executed by one of the functional units <b>24</b>, the result of that instruction is passed directly to any reservation stations <b>22</b> that are waiting for that result at the same time the result is passed to update reorder buffer <b>32</b> (this technique is commonly referred to as \u201cresult forwarding\u201d). An instruction may be selected for execution and passed to a functional unit <b>24</b>A-<b>24</b>C during the clock cycle that the associated result is forwarded. Reservation stations <b>22</b> route the forwarded result to the functional unit <b>24</b> in this case. In embodiments in which instructions may be decoded into multiple operations to be executed by functional units <b>24</b>, the operations may be scheduled separately from each other.</p><p>In one embodiment, each of the functional units <b>24</b> is configured to perform integer arithmetic operations of addition and subtraction, as well as shifts, rotates, logical operations, and branch operations. The operations are performed in response to the control values decoded for a particular instruction by decode units <b>20</b>. It is noted that a floating point unit (not shown) may also be employed to accommodate floating point operations. The floating point unit may be operated as a coprocessor, receiving instructions from MROM unit <b>34</b> or reorder buffer <b>32</b> and subsequently communicating with reorder buffer <b>32</b> to complete the instructions. Additionally, functional units <b>24</b> may be configured to perform address generation for load and store memory operations performed by load/store unit <b>26</b>. In one particular embodiment, each functional unit <b>24</b> may comprise an address generation unit for generating addresses and an execute unit for performing the remaining functions. The two units may operate independently upon different instructions or operations during a clock cycle.</p><p>Each of the functional units <b>24</b> also provides information regarding the execution of conditional branch instructions to the branch prediction unit <b>14</b>. If a branch prediction was incorrect, branch prediction unit <b>14</b> flushes instructions subsequent to the mispredicted branch that have entered the instruction processing pipeline, and causes fetch of the required instructions from instruction cache <b>16</b> or main memory. It is noted that in such situations, results of instructions in the original program sequence which occur after the mispredicted branch instruction are discarded, including those which were speculatively executed and temporarily stored in load/store unit <b>26</b> and reorder buffer <b>32</b>. It is further noted that branch execution results may be provided by functional units <b>24</b> to reorder buffer <b>32</b>, which may indicate branch mispredictions to functional units <b>24</b></p><p>Results produced by functional units <b>24</b> are sent to reorder buffer <b>32</b> if a register value is being updated, and to load/store unit <b>26</b> if the contents of a memory location are changed. If the result is to be stored in a register, reorder buffer <b>32</b> stores the result in the location reserved for the value of the register when the instruction was decoded. A plurality of result buses <b>38</b> are included for forwarding of results from functional units <b>24</b> and load/store unit <b>26</b>. Result buses <b>38</b> convey the result generated, as well as the reorder buffer tag identifying the instruction being executed.</p><p>Load/store unit <b>26</b> provides an interface between functional units <b>24</b> and data cache <b>28</b>. In one embodiment, load/store unit <b>26</b> is configured with a first load/store buffer having storage locations for data and address information for pending loads or stores which have not accessed data cache <b>28</b> and a second load/store buffer having storage locations for data and address information for loads and stores which have access data cache <b>28</b>. For example, the first buffer may comprise 12 locations and the second buffer may comprise 32 locations. Decode units <b>20</b> arbitrate for access to the load/store unit <b>26</b>. When the first buffer is full, a decode unit must wait until load/store unit <b>26</b> has room for the pending load or store request information. Load/store unit <b>26</b> also performs dependency checking for load memory operations against pending store memory operations to ensure that data coherency is maintained. A memory operation is a transfer of data between processor <b>10</b> and the main memory subsystem. Memory operations may be the result of an instruction which utilizes an operand stored in memory, or may be the result of a load/store instruction which causes the data transfer but no other operation. Additionally, load/store unit <b>26</b> may include a special register storage for special registers such as the segment registers and other registers related to the address translation mechanism defined by the x86 processor architecture.</p><p>Data cache <b>28</b> is a high speed cache memory provided to temporarily store data being transferred between load/store unit <b>26</b> and the main memory subsystem. In one embodiment, data cache <b>28</b> has a capacity of storing up to 64 kilobytes of data in an two way set associative structure. It is understood that data cache <b>28</b> may be implemented in a variety of specific memory configurations, including a set associative configuration, a fully associative configuration, a direct-mapped configuration, and any suitable size of any other configuration.</p><p>In one particular embodiment of processor <b>10</b> employing the x86 processor architecture, instruction cache <b>16</b> and data cache <b>28</b> are linearly addressed and physically tagged. The linear address is formed from the offset specified by the instruction and the base address specified by the segment portion of the x86 address translation mechanism. Linear addresses may optionally be translated to physical addresses for accessing a main memory. The linear to physical translation is specified by the paging portion of the x86 address translation mechanism. The physical address is compared to the physical tags to determine a hit/miss status.</p><p>Bus interface unit <b>37</b> is configured to communicate between processor <b>10</b> and other components in a computer system via a bus. For example, the bus may be compatible with the EV -6 bus developed by Digital Equipment Corporation. Alternatively, any suitable interconnect structure may be used including packet-based, unidirectional or bi-directional links, etc. An optional L<b>2</b> cache interface may be employed as well for interfacing to a level two cache.</p><p>Branch Classification Update</p><p>Turning now to FIG. 2, a flowchart illustrating one embodiment of the basic flow of branch classification and prediction is shown. Other embodiments are possible and are contemplated. In the embodiment of FIG. 2, when a conditional branch is initially detected, an entry is created in a local predictor storage indicating the branch is not taken (block <b>300</b>). Upon execution (block <b>302</b>), if the branch is not taken (decision block <b>304</b>), no update is done. If the branch is taken, the local prediction is updated to taken, a target address is entered in a branch target storage and the branch is classified as local (block <b>306</b>). Upon execution (block <b>308</b>), if the branch is taken (decision block <b>310</b>), no update is done. However, if the branch is not taken, the branch classification is updated to indicate the branch is global (block <b>312</b>) and the classification may remain global until the branch is deleted from the cache due to a cache line replacement.</p><p>FIG. 3 shows a portion of one embodiment of branch prediction unit <b>14</b> is shown. Other embodiments of branch prediction unit <b>14</b> in addition to the portion shown in FIG. 3 are contemplated. As shown in FIG. 3, branch prediction unit <b>14</b> includes global predictor storage <b>205</b>, local predictor storage <b>206</b>, branch target storage <b>208</b>, update logic <b>200</b> and <b>202</b>, global history shift register <b>204</b>, line buffer <b>210</b>, control logic <b>256</b> and multiplexors <b>222</b>, <b>220</b>, <b>212</b>, <b>234</b>, <b>260</b> and <b>214</b>. Global predictor storage <b>205</b>, local predictor storage <b>206</b>, branch target storage <b>208</b> and line buffer <b>210</b> are coupled to a fetch address bus <b>236</b> from fetch address multiplexor <b>222</b>. Global history shift register <b>204</b> is coupled to global predictor storage <b>205</b> and line buffer <b>210</b> via bus <b>234</b>. Update logic <b>200</b> is coupled to global predictor storage <b>205</b>, local predictor storage <b>206</b> and branch target storage <b>208</b>. Line buffer <b>210</b> is coupled to update logic <b>200</b> and <b>202</b> via bus <b>248</b>. In addition, update logic <b>202</b> is coupled to global history shift register <b>204</b> via bus <b>246</b>. Reorder buffer <b>32</b> provides selection control and a redirect address to multiplexor <b>222</b>. Reorder buffer <b>32</b> also provides branch predicted behavior and actual behavior information to update logic <b>200</b> and update logic <b>202</b>. Local predictor storage <b>206</b> provides selection control for multiplexors <b>234</b>, <b>214</b> and <b>212</b>, as well as a local prediction to multiplexor <b>220</b> and control logic <b>256</b>. Multiplexor <b>234</b> provides a target address and global bit upon bus <b>240</b>. The global bit provided on bus <b>240</b> is provided to control logic <b>256</b>. Control logic <b>256</b> serves as selection control to multiplexor <b>220</b> and conveys a control signal to line buffer <b>210</b>. Multiplexor <b>220</b> provides a final branch prediction on bus <b>250</b> which serves as selection control for multiplexor <b>260</b> and is also conveyed to update logic <b>202</b></p><p>In general, the basic operation of the portion of branch prediction unit <b>14</b> shown in FIG. 3 is as follows. A fetch address <b>236</b> is conveyed to line buffer <b>210</b>, local predictor storage <b>206</b> and target array storage <b>208</b> In addition, a portion of the fetch address <b>236</b> is combined with global history <b>234</b> to form an index into global predictor storage <b>205</b>. Global predictor storage <b>205</b> conveys a global prediction <b>238</b>, local predictor storage <b>206</b> convey a local prediction <b>242</b> and target array <b>208</b> conveys a target address corresponding to the received fetch address. Local prediction <b>242</b> selects a target address from multiplexors <b>234</b>, <b>212</b> and <b>214</b> which may be a branch target <b>240</b>, return address <b>230</b> or sequential address <b>232</b>. In addition, local prediction <b>242</b> provides a taken/not taken prediction to multiplexor <b>220</b> and control logic <b>256</b>. Further, branch target <b>240</b> may include a global bit which is conveyed to control logic <b>256</b>. Control logic <b>256</b> then conveys a signal <b>254</b> which selects either the global prediction <b>238</b> or local prediction <b>242</b> from multiplexor <b>220</b>. Control logic <b>256</b> selects the global prediction from multiplexor <b>220</b> if the local prediction indicates taken and the global bit indicates the branch is classified as global. Otherwise, control logic <b>256</b> selects local prediction <b>242</b>. Signal <b>254</b> is also conveyed to line buffer <b>210</b> which stores a global history <b>234</b>, fetch address <b>236</b>, global prediction <b>238</b> and signal <b>254</b>. Line buffer <b>210</b> entry is used to update or repair the branch prediction and global history upon retirement or misprediction. Finally, the final prediction <b>250</b> selected by control logic <b>256</b> selects the next fetch address from multiplexor <b>260</b> which may be either the address conveyed by multiplexor <b>214</b> or a sequential address <b>232</b></p><p>In one embodiment, local predictor storage <b>206</b> may be organized in the same manner as instruction cache <b>16</b>. Data stored in local predictor storage <b>206</b> may consist of lines of storage organized in ways. Further, local predictor storage <b>206</b> may be \u00bc the size of instruction cache <b>16</b>. Additional bits may be stored along with a local prediction in local predictor storage <b>206</b> in order to distinguish entries for multiple fetch addresses which index to the same storage location within local predictor storage <b>206</b>. In one embodiment, global predictor storage <b>205</b> may be configured such that a single storage location provides a prediction for more than one fetch address.</p><p>Local\u2014Not Taken Branches</p><p>As discussed above, prefetch/predecode unit <b>12</b> may be configured to detect branch instructions and to convey branch information corresponding to a branch instruction to branch prediction unit <b>14</b>. When a conditional branch is detected, update logic <b>200</b> may create a corresponding branch prediction entry in local predictor storage <b>206</b> initialized to not taken. In one embodiment, local predictor storage <b>206</b> may store branch selectors for choosing from among a plurality of branch target addresses stored in branch target storage <b>208</b>, a sequential address <b>232</b>, or return stack address <b>230</b>. Further description of branch selectors is discussed below. Upon creating an entry in local predictor storage <b>206</b> for a branch, the predicted direction of the branch is initialized to not taken and the selector is initialized to indicate a sequential address <b>232</b>. In addition, an entry corresponding to a conditional branch is created in line buffer <b>210</b>. A line buffer entry may comprise a global history, fetch address, global prediction and global bit.</p><p>When a branch has a not taken prediction in local predictor storage <b>206</b>, a sequential address <b>232</b> is conveyed from multiplexor <b>212</b> to multiplexor <b>214</b>. In one embodiment a local prediction of not taken may be conveyed as a binary zero. Control logic <b>256</b> then selects the local prediction from multiplexor <b>220</b> as the final prediction <b>250</b>. Final prediction <b>250</b> is conveyed to update logic <b>202</b> which shifts the predicted direction into global history shift register <b>204</b>. Final prediction <b>250</b> controls multiplexor <b>260</b> which gates out the next fetch address. When a local branch prediction entry indicates a branch is predicted not taken, final prediction <b>250</b> indicates the branch is not taken and selects sequential address <b>232</b> from multiplexor <b>260</b> as the next fetch address. On subsequent executions of the branch, prior to the branch prediction entry being deleted from branch prediction unit <b>14</b>, the predicted direction for the branch is not taken and the sequential address <b>232</b> is conveyed as the next fetch address. Upon retirement, the corresponding entry in line buffer <b>210</b> is conveyed to update logic <b>200</b> and update logic <b>202</b> and deleted from line buffer <b>210</b>. When a line buffer entry indicates a branch is classified as local and reorder buffer <b>32</b> indicates the branch was correctly predicted, no update by update logic <b>200</b> or <b>202</b> is performed. However, if the branch was classified as local and mispredicted, the branch prediction corresponding to the mispredicted branch is updated and the global history shift register <b>204</b> is updated as discussed below</p><p>Local\u2014Taken Branches</p><p>Upon retirement or mispredict, reorder buffer <b>32</b> conveys information regarding the behavior of a branch to update logic <b>200</b>. Also, line buffer <b>210</b> conveys a line buffer entry to update logic <b>200</b> and <b>202</b>. When a line buffer branch entry indicates a branch is classified as local and predicted not taken, and reorder buffer <b>32</b> indicates the corresponding branch was mispredicted, update logic <b>200</b> updates the branch prediction entry corresponding to the mispredicted branch. Update logic <b>200</b> updates the branch prediction in local predictor storage <b>206</b> from not taken to taken, enters the branch target address in branch target storage <b>208</b> and sets the branch selector to indicate the corresponding target address. A global bit associated with the stored branch target address is initialized to indicate the branch is classified as local, which may be represented by a binary zero. Further, update logic <b>202</b> updates the contents of global history shift register <b>204</b> to reflect the actual behavior of the mispredicted branch. On subsequent executions of the branch, and prior to the branch prediction entry being deleted from branch prediction unit <b>14</b>, the branch prediction entry indicates a taken prediction and a classification of local. When a branch is predicted taken and classified as local, the corresponding branch selector stored in local predictor storage <b>206</b> selects a target from multiplexors <b>234</b> and <b>212</b>. If the global bit indicates the branch is classified as local, control logic <b>236</b> gates out the local prediction <b>242</b> from multiplexor <b>220</b>. The corresponding target address is then gated out of multiplexors <b>214</b> and <b>260</b> as the fetch address. As before, if the branch is correctly predicted no branch prediction update is required by update logic <b>200</b> or <b>202</b>. On the other hand, if a local predicted taken branch is not taken, the branch prediction entry and global history shift register <b>204</b> are updated.</p><p>Global Branches</p><p>When a branch which is classified as local and predicted taken is mispredicted, update logic <b>200</b> updates the global bit corresponding to the mispredicted branch in branch target array <b>208</b> to indicate the branch is classified as global. In addition, update logic <b>200</b> updates the global prediction entry in global prediction storage <b>204</b> corresponding to the mispredicted branch to indicate the branch is predicted not taken. Also, update logic <b>202</b> updates global history shift register <b>204</b> to indicate the branch was not taken. In one embodiment, global history shift register <b>204</b> tracks the behavior of the last 8 global branches.</p><p>When a global branch is dispatched, fetch address <b>236</b> is conveyed to local predictor storage <b>206</b>, target array <b>208</b> and line buffer <b>210</b>. In addition, the fetch address is combined with the contents of global history shift register <b>204</b> to form an index <b>203</b> which is conveyed to global predictor storage <b>205</b>. The contents of global history shift register <b>204</b> are also conveyed to line buffer <b>210</b> via bus <b>234</b>. In one embodiment, index <b>203</b> is formed by concatenating the four least significant bits of the fetch address <b>236</b> with the contents of global history shift register <b>204</b>. Other methods of forming an index, such as ORing or XORing, are contemplated as well. The index selects an entry in global predictor storage <b>205</b> which is conveyed to line buffer <b>210</b>, update logic <b>202</b> and multiplexor <b>220</b>. The predicted direction of the branch conveyed by global predictor storage <b>204</b> is shifted into the global history shift register <b>204</b> by update logic <b>202</b> For example, a binary one may represent a taken branch and a binary zero may represent a not taken branch. Further, for a branch classified as global, local predictor storage <b>206</b>. indicates the branch is predicted taken and the corresponding branch selector gates out the corresponding target addresses from multiplexor <b>234</b> and multiplexor <b>214</b>. Illustration of updating global history shift register <b>204</b> is discussed in FIGS. 4-7 below. When a global bit indicates a branch is classified as global, control logic <b>256</b> gates out the global branch prediction <b>238</b> as the final prediction <b>250</b>. Final prediction <b>250</b> then selects the next fetch address from multiplexor <b>260</b>. If the global prediction indicates the branch is taken, the target address conveyed from multiplexor <b>214</b> is selected as the next fetch address. If the global prediction indicates the branch is not taken, the sequential address <b>232</b> is selected from multiplexor <b>260</b> as the next fetch address.</p><p>Upon retirement, reorder buffer <b>32</b> conveys branch information to update logic <b>200</b> and update logic <b>202</b>. In addition, line buffer <b>210</b> conveys the corresponding branch information to update logic <b>202</b>. When reorder buffer <b>32</b> indicates a global branch is correctly predicted, update logic <b>200</b> modifies global prediction entry <b>205</b> to indicate the behavior of the branch. In one embodiment, global branch prediction entries comprise a saturating counter. Such a counter may be two bits which are incremented on taken branches and decremented on not taken branches. Such an indicator may be used to indicate a branch is strongly taken, weakly taken, strongly not taken, or weakly not taken. If a global branch is mispredicted, update logic <b>200</b> updates the global prediction entry <b>205</b> to indicate the branch behavior. In addition, upon misprediction update logic <b>202</b> repairs global history shift register <b>204</b> to reflect the actual, rather than the predicted, behavior of the global branch.</p><p>Updating Global History Shift Register</p><p>FIG. 4 shows the contents of global history shift register <b>204</b> before and after a conditional branch is correctly predicted and executed. Shown is an 8 bit shift register at 3 different points in time. Row A indicates a point in time prior to row B, which is prior in time to row C. A taken branch is indicated by a binary one, and a not taken branch is indicated by a binary zero. The arrow on the right indicates values are shifted into the register from the right side with the contents of the register shifting to the left. The leftmost value is shifted out of the register. Row A shows the contents prior to dispatch of a conditional branch. Row B contains the contents after dispatch of a conditional branch. In this case, the conditional branch is predicted taken and a one is shifted into the register. Finally, row C contains the contents after execution of the conditional branch. Because the predicted behavior is correct, no update of the global history shift register <b>204</b> is required after execution of the conditional branch.</p><p>FIG. 5 illustrates the case of a mispredicted branch. In FIG. 5, row A shows the contents of the global history shift register prior to dispatch of a conditional branch. Row B shows the contents of the register after the dispatch of the conditional branch. Here, as in FIG. 4, the conditional branch is predicted taken and a binary one is shifted into the register. Finally, row C shows the contents of the register after misprediction. In this case, the conditional branch was not taken upon execution. Consequently, the global history register is updated by modifying the history bit representing the mispredicted branch from a binary one to a zero.</p><p>FIG. 6 illustrates a mispredicted first conditional branch with a subsequent second conditional branch. Row A shows the contents of global history shift register prior to dispatch of the conditional branches. Row B shows the contents after the first conditional branch has been dispatched and the second conditional branch has been dispatched. In this case, both the first and second conditional branches are predicted taken and two binary ones have been shifted into the register. Upon execution, the first conditional branch is detected to be mispredicted which requires a repair of the global history. Because the mispredicted branch was taken, the second conditional branch represents an erroneous instruction and must be repaired as well. Row C shows the contents of the global history shift register after repair. The state of the register at the time of prediction of the first conditional branch is restored with the history changed from a binary one to a binary zero to reflect the not taken branch. The history of the second conditional branch is no longer present in the history register as it represents an erroneous instruction stream. In this case it was necessary to right-shift the history in the register and restore the history of a branch which was previously left-shifted out.</p><p>FIG. 7 is a second example of a mispredicted first conditional branch with a subsequent second conditional branch. In this case, the first conditional branch is predicted taken and the second conditional branch is predicted not taken. As before, the first branch is mispredicted. Upon repair, the state of the register at the time of dispatch of the first branch is restored with the history changed to reflect the not taken behavior of the first branch. As before, the history of the second branch is no longer present. In each of the above cases, the value being shifted into global history shift register <b>204</b> represents the final branch prediction <b>250</b> or is generated by update logic <b>202</b>. Update logic <b>202</b> generates the appropriate value in response to branch mispredictions.</p><p>Branch Selectors</p><p>Turning now to FIG. 8, a diagram of an exemplary group of contiguous instruction bytes <b>50</b> and a corresponding set of branch selectors <b>52</b> in local predictor storage <b>206</b> are shown. In FIG. 8, each byte within an instruction is illustrated by a short vertical line (e.g. reference number <b>54</b>). Additionally, the vertical lines separating instructions in group <b>50</b> delimit bytes (e.g. reference number <b>56</b>). The instructions shown in FIG. 8 are variable in length, and therefore the instruction set including the instructions shown in FIG. 8 is a variable byte length instruction set. In other words, a first instruction within the variable byte length instruction set may occupy a first number of bytes which is different than a second number of bytes occupied by a second instruction within the instruction set. Other instruction sets may be fixed-length, such that each instruction within the instruction set occupies the same number of bytes as each other instruction.</p><p>As illustrated in FIG. 8, group <b>50</b> includes non-branch instructions IN<b>0</b>-IN<b>5</b> Instructions IN<b>0</b>, IN<b>3</b>, IN<b>4</b>, and IN<b>5</b> are two byte instructions. Instruction IN<b>1</b> is a one byte instruction and instruction IN<b>2</b> is a three byte instruction. Two predicted taken branch instructions PB<b>0</b> and PB<b>1</b> are illustrated as well, each shown as occupying two bytes. It is noted that both non-branch and branch instructions may occupy various numbers of bytes.</p><p>The end byte of each predicted-taken branch PB<b>0</b> and PB<b>1</b> provides a division of group <b>50</b> into three regions: a first region <b>58</b>, a second region <b>60</b>, and a third region <b>62</b> If a fetch address identifying group <b>50</b> is presented, and the offset of the fetch address within the group identifies a byte position within first region <b>58</b>, then the first predicted-taken branch instruction to be encountered is PB<b>0</b> and therefore the branch prediction for PB<b>0</b> is selected by the branch prediction mechanism. Similarly, if the offset of the fetch address identifies a byte within second region <b>60</b>, the appropriate branch prediction is the branch prediction for PB<b>1</b>. Finally, if the offset of the fetch address identifies a byte within third region <b>62</b>, then there is no predicted-taken branch instruction within the group of instruction bytes and subsequent to the identified byte. Therefore, the branch prediction for third region <b>62</b> is sequential. The sequential address identifies the group of instruction bytes which immediately follows group <b>50</b> within main memory.</p><p>As used herein, the offset of an address comprises a number of least significant bits of the address. The number is sufficient to provide different encodings of the bits for each byte within the group of bytes to which the offset relates. For example, group <b>50</b> is 16 bytes. Therefore, four least significant bits of an address within the group form the offset of the address. The remaining bits of the address identify group <b>50</b> from other groups of contiguous instruction bytes within the main memory. Additionally, a number of least significant bits of the remaining bits form an index used by instruction cache <b>16</b> to select a row of storage locations which are eligible for storing group <b>50</b></p><p>Set <b>52</b> is an exemplary set of branch selectors for group <b>50</b>. One branch selector is included for each byte within group <b>50</b>. The branch selectors within set <b>52</b> use the encoding shown in FIG. 20 below. In the example, the branch prediction for PB<b>0</b> is stored as the second of two branch predictions associated with group <b>50</b> (as indicated by a branch selector value of \u201c3\u201d). Therefore, the branch selector for each byte within first region <b>58</b> is set to \u201c3\u201d. Similarly, the branch prediction for PB<b>1</b> is stored as the first of the branch predictions (as indicated by a branch selector value of \u201c2\u201d). Therefore, the branch selector for each byte within second region <b>60</b> is set to \u201c2\u201d. Finally, the sequential branch prediction is indicated by the branch selectors for bytes within third region <b>62</b> by a branch selector encoding of \u201c0\u201d.</p><p>It is noted that, due to the variable byte length nature of the x86 instruction set, a branch instruction may begin within one group of contiguous instruction bytes and end within a second group of contiguous instruction bytes. In such a case, the branch prediction for the branch instruction is stored with the second group of contiguous instruction bytes. Among other things, the bytes of the branch instruction that are stored within the second group of contiguous instruction bytes need to be fetched and dispatched. Forming the branch prediction in the first group of contiguous instruction bytes would cause the bytes of the branch instruction which lie within the second group of instruction bytes not to be fetched.</p><p>Employing a set of branch selectors such as set <b>52</b> allows for a rapid determination of the predicted fetch address ((i.e. by decoding the offset portion of the fetch address and selecting the corresponding selector from set <b>52</b>). However, a large number of branch selectors are stored ((i.e. one for each byte). The amount of branch prediction storage employed for storing the branch selectors would correspondingly be large. Still further, a relatively wide selection device (such as a multiplexor) would be needed to select the branch selector in response to the offset of the fetch address. The wider the selection device, in general, the greater the delay in propagating the selected value through the selection device (e.g. the selected branch selector).</p><p>FIG. 8 illustrates that the branch selector for each byte within a region is the same, and regions are delimited by branch instructions (more particularly, predicted-taken branch instructions). Branch instructions would generally include at least an opcode (identifying the branch instruction within the instruction set employed by microprocessor <b>10</b>) and a displacement to be added to the address of the branch instruction (or the address of the instruction immediately following the branch instruction) to form the branch target address. Therefore, a branch instruction occupies at least two bytes. By taking advantage of this fact, the number of branch selectors stored with respect to a group of contiguous instruction bytes may be reduced.</p><p>For the remainder of this description, the x86 microprocessor architecture will be used as an example. However, the branch selector technique described herein may be employed within any microprocessor architecture, and such embodiments are contemplated. It is noted that, in the x86 microprocessor architecture, a subroutine return instruction is defined (e.g. the RET instruction). The subroutine return instruction specifies that its branch target address is drawn from the top of the stack indicated by the ESP register. Therefore, the RET instruction is a single byte ((i.e. an opcode byte). Handling of the single byte RET instruction with branch selectors taking advantage of the at least two byte per branch instruction general rule is illustrated in more detail below.</p><p>Turning next to FIG. 9, a diagram illustrating group <b>50</b>, regions <b>58</b>, <b>60</b>, and <b>62</b>, and one embodiment of a set of branch selectors <b>70</b> is illustrated. The branch selectors within set <b>70</b> correspond to byte ranges defined within group <b>50</b>. For the example shown in FIG. 14, nine branch selectors are used for a group of 16 contiguous instruction bytes. Set <b>70</b> therefore occupies less storage within a branch prediction storage than set <b>52</b> shown in FIG. 13 occupies, allowing the branch prediction storage to be made smaller. Still further, a narrower selection device may be used to select a branch selector in response to a fetch address. The selected branch selector may be provided more rapidly, and may thereby provide for a higher frequency implementation in which predicted fetch addresses are provided each clock cycle.</p><p>Generally, the largest byte range defined for a given branch selector may be made equal to the shortest branch instruction (excluding the return instruction as described in more detail below). The majority of the byte ranges are selected to be the largest size. However, to handle certain conditions, the embodiment shown in FIG. 9 employs two byte ranges that are smaller than the maximum size. In particular, the initial byte of the group <b>50</b> forms a byte range having a single byte (as explained in more detail below with respect to FIG. <b>11</b>). Since group <b>50</b> is an even number of bytes, the byte range corresponding to the initial byte includes only the initial byte, and the largest byte range is two bytes in this example, another byte range is defined to have a single byte as well. For set <b>70</b>, the byte within group <b>50</b> that is contiguous to the initial byte is selected to be a single byte range. This selection allows for a relatively simple decode of the offset of the fetch address to select a branch selector, as illustrated in FIG. <b>10</b>.</p><p>Since the byte ranges are selected to be no larger than the shortest branch instruction, a branch instruction may begin in one byte range and end in a subsequent byte range. However, at most one branch instruction ends in a particular byte range, even if branch instructions are consecutive within a particular group of contiguous instruction bytes. For the case of a branch instruction that ends within a particular byte range but not at the end of the byte range, the branch selector for that byte range is selected to be the branch selector corresponding to instruction bytes subsequent to the branch instruction.</p><p>For example, the branch selector for byte range <b>72</b> (which includes bytes 3-4, where the initial byte is numbered byte 0) indicates the branch prediction corresponding to predicted branch PB<b>1</b>. The above rule is used because a fetch address within the byte range is not fetching the branch instruction (which begins in the preceding byte range). Therefore, the correct branch prediction is the prediction for the subsequent branch.</p><p>On the other hand, if the branch instruction ends at the last byte within the byte range, the branch selector for the byte range is the branch selector corresponding to the branch instruction (e.g. byte range <b>74</b>). Therefore, if a fetch address specifying predicted branch PB<b>1</b> ((i.e. the offset is within byte range <b>74</b>), then the branch prediction used for the fetch is the branch prediction corresponding to branch PB<b>1</b>.</p><p>Turning now to FIG. 10, a table <b>76</b> is shown corresponding to the selection of byte ranges for branch selectors as illustrated in the example of FIG. <b>9</b>. The row of table <b>76</b> labeled \u201cByte Position\u201d lists the byte positions within group <b>50</b> that correspond to each byte range ((i.e. the offset portion of the address for each byte which is within each byte range). The row labeled \u201cBranch Selector Position\u201d illustrates the branch selector position within the set <b>70</b> of the branch selector corresponding to each byte range. The row labeled \u201cRead Addresses\u201d lists the fetch address offsets (in binary) which are decoded to select the branch selector within the corresponding byte range (in order to form a predicted fetch address for the subsequent clock cycle). An \u201cx\u201d in the read addresses indicates a don't care position. Finally, the row labeled \u201cEncoding Addresses\u201d lists the fetch address offsets (in binary) at which a branch instruction can end and still have the branch selector for that byte range indicate the branch prediction corresponding to that branch instruction. For example, branch selector position <b>2</b> can indicate the branch prediction for a branch instruction that ends at either byte position <b>3</b> or <b>4</b>. More particularly, a branch instruction which ends at byte position <b>2</b> is not represented by the branch selector in branch selector position <b>2</b> (because the branch instruction begins in a different byte range than that associated with branch selector position <b>2</b>, and is therefore not being fetched if the fetch address offset is within the byte range associated with branch selector position <b>2</b>).</p><p>The \u201cRead Addresses\u201d row of table <b>76</b> illustrates that a relatively simple decoding of the fetch address offset can be used to select the appropriate branch selector for that fetch address. The decoding for branch selector positions <b>0</b> and <b>1</b> include each of the fetch address offset bits, but the decoding for the remaining positions may exclude the least significant bit (since it is a don't care). A rapid decode and branch selector selection may be achieved using the allocation of byte ranges illustrated in FIG. <b>14</b>.</p><p>Turning now to FIG. 11, a first example <b>80</b> of branch selectors for the byte ranges shown in FIGS. 9 and 10 is shown. Example <b>80</b> illustrates the use of the byte range including only byte 0 of a group of contiguous instruction bytes. Example <b>80</b> shows an instruction INO ending at byte \u201cE\u201d of a first group of contiguous instruction bytes, a predicted branch PB<b>0</b> extended from byte \u201cF\u201d of the first group to byte 0 of a second group of contiguous instruction bytes which are sequential to the first group, and an instruction IN<b>1</b> beginning at byte \u201c1\u201d of the second group.</p><p>Since branch instruction PB<b>0</b> does not end until byte 0 of the second group, the second group needs to be fetched from instruction cache <b>16</b>. Therefore, the branch selector corresponding to bytes \u201cE\u201d and \u201cF\u201d of the first group indicates sequential, thereby causing the second group to be fetched. The sequential fetch address includes an offset portion set to zero (since bytes immediately subsequent to the last bytes of the first group are being fetched). Therefore, the branch selector corresponding to byte \u201c0\u201d of the second group is selected. The branch selector is coded to select the branch prediction corresponding to branch instruction PB<b>0</b>.</p><p>If a bytes 0 and 1 of the second group formed a byte range similar to the other byte ranges shown in FIGS. 9 and 10, branch instruction PB<b>0</b> would not be predictable. To allow for predictions of branches which extend across groups of instruction bytes, the byte ranges are defined to include a byte range consisting of byte \u201c0\u201d in the present embodiment.</p><p>Turning now to FIG. 12, a second example <b>82</b> of branch selectors for the byte ranges shown in FIGS. 9 and 10 is shown. Example <b>82</b> illustrates a situation in which a predicted branch instruction PB<b>0</b> is followed by a return instruction RET. Branch instruction PB<b>0</b> ends at byte \u201c4\u201d, which is within the byte range corresponding to branch selector position <b>3</b> ((i.e. byte \u201c4\u201d is not the last byte in the byte range). Therefore, the branch selector at branch selector position <b>3</b> does not select the branch prediction for PB<b>0</b>, as noted above regarding a branch instruction which ends within a byte range. The RET instruction does end at the last byte of the byte range. Therefore, the branch selector for branch selector position <b>3</b> indicates the return instruction ((i.e. an encoding of \u201c1\u201d in example <b>82</b>).</p><p>On the other hand, FIG. 13 illustrates an example <b>84</b> in which a return instruction is not predicted. Example <b>84</b> includes a predicted branch instruction PB<b>0</b>, a return instruction RET, and an instruction IN<b>1</b>. Branch instruction PB<b>0</b> ends at the last byte of the byte range corresponding to branch selector position <b>2</b>, and therefore the corresponding branch selector is encoded to select the branch prediction corresponding to branch instruction PB<b>0</b>. The return instruction ends within the byte range corresponding to branch selector position <b>3</b>, and therefore the corresponding branch selector does not indicate the return instruction. In this manner, if instruction IN<b>0</b> is indicated by the fetch address, the return instruction will not be erroneously predicted by the branch selector at branch selector position <b>3</b>. However, if the return instruction is the byte indicated by the fetch address, an incorrect prediction results.</p><p>It is noted that the code sequence shown in example <b>84</b> may be uncommon, because often times temporary variables are popped from the stack just prior to executing a return instruction. Therefore, a predicted taken branch would not often immediately precede a return instruction.</p><p>FIG. 14 illustrates an example <b>86</b> of in which a return instruction may be mispredicted. In example <b>86</b>, a return instruction is followed immediately by a predicted branch instruction PB<b>0</b>. This code sequence may again be infrequent, since the only way to execute branch instruction PB<b>0</b> is to branch directly to the instruction from elsewhere in the code sequence. Also, the return instruction is only mispredicted in example <b>86</b> if branched to directly. If instruction IN<b>0</b> is fetched and executed, the return instruction is correctly predicted.</p><p>Turning next to FIG. 15, a table <b>138</b> illustrating an exemplary branch selector encoding is shown. A binary encoding is listed (most significant bit first), followed by the branch prediction which is selected when the branch selector is encoded with the corresponding value. As table <b>138</b> illustrates, the least significant bit of the branch selector can be used as a selection control for branch prediction multiplexor <b>234</b> and sequential/return multiplexor <b>212</b>. If the least significant bit is clear, then the first branch prediction is selected by branch prediction multiplexor <b>234</b> and the sequential address is selected by sequential/return multiplexor <b>212</b>. On the other hand, the second branch prediction is selected by branch prediction multiplexor <b>234</b> and the return address is selected by sequential/return multiplexor <b>212</b> if the least significant bit is clear. Furthermore, the most significant bit of the branch selector can be used as a selection control for multiplexor <b>214</b>. If the most significant bit is set, the output of branch prediction multiplexor <b>234</b> is selected. If the most significant bit is clear, the output of sequential/return multiplexor <b>212</b> is selected.</p><p>In one embodiment of local predictor storage <b>206</b> and target array storage <b>208</b>, only two branch predictions per line may be made. Consequently, if two branches in a line are currently predicted taken, other branches in the same line must be predicted not taken. Further, in one embodiment only one branch prediction may be made per fetched line of contiguous instruction bytes. In order to enable a second branch prediction for a fetched line of instructions, a bit associated with the line of instructions is included.</p><p>Ordinarily, when there is only a local branch prediction and no global branch prediction, there is no need for a second prediction. In the case of a predicted taken branch where there is no subsequent global prediction which may override the local prediction, the branch will remain predicted taken and the next fetch address will reflect the taken prediction. Consequently, if there is a subsequent branch in the same line, there is no need to predict its behavior because the instruction stream has been redirected before reaching the second branch. On the other hand, if there is a subsequent global prediction which may override the local prediction, it is possible the local prediction of taken may be overridden by a global prediction of not taken. In this situation, a subsequent second branch in the same line will be encountered and it would be more efficient to be able to predict its behavior.</p><p>FIG. 16 shows a branch selector storage as in FIG. 9, with the added M bit <b>1600</b> to indicate a multiple branch condition. Upon entering branch selectors into local predictor storage <b>206</b>, the associated M bit is initialized to indicate a multiple branch condition does not exist. In FIG. 16, two predicted taken branches are shown, PB<b>0</b> and PB<b>1</b>. If PB<b>0</b> is a global branch as indicated by the global bit stored with the corresponding target in target array storage <b>208</b> and the M bit <b>1600</b> is set to indicate a multiple branch condition and PB<b>0</b> is predicted not taken by global predictor <b>205</b>, control logic will force the next fetch address to the address following PB<b>0</b>. This causes a second fetch for the same line at IN<b>2</b> and allows for prediction of the next branch PB<b>1</b>. Advantageously, prediction for the second branch PB<b>1</b> is made possible as further discussed below.</p><p>FIG. 17 shows a portion of one embodiment of branch prediction unit <b>14</b> incorporating a second fetch/prediction apparatus. FIG. 17 corresponds to FIG. 3, with the exception of control logic <b>1700</b> and control logic <b>1702</b>. Control logic <b>1700</b> is coupled to multiplexor <b>260</b> whereby it receives a next fetch address in the manner discussed in FIG. <b>3</b>. Control logic <b>1700</b> is also coupled to receive a signal from control logic <b>256</b>, M bit <b>1704</b>, fetch address <b>236</b> and a global prediction <b>238</b>. Control logic <b>1700</b> conveys a fetch address to multiplexor <b>222</b>. Update logic <b>1702</b> is coupled to line buffer <b>210</b>, prefetch/predecode unit <b>12</b>, global predictor storage <b>205</b>, local predictor storage <b>206</b>, target array <b>208</b> and reorder buffer <b>32</b></p><p>Update logic <b>1702</b> operates generally in the same manner as update logic <b>200</b> shown in FIG. <b>3</b>. However, in addition, update logic <b>1702</b> includes circuitry to update local predictor storage <b>206</b> to indicate groups of instructions with multiple branch conditions as discussed above. Upon mispredict of a branch, update logic <b>1702</b> scans the group of instructions containing the mispredicted branch. If the update logic <b>1702</b> detects two branches in the line and the first branch is classified as global, update logic <b>1702</b> sets the M bit <b>1704</b> associated with the line to indicate a multiple branch condition. On subsequent executions of the first branch, control logic <b>1700</b> selects as the fetch address either the address conveyed by multiplexor <b>260</b> or the address of the instruction immediately following the branch instruction. When an instruction having a branch selector corresponding to the above mentioned first branch is dispatched, control logic <b>1700</b> receives the fetch address, M bit <b>1704</b>, control logic signal <b>256</b> and global prediction. If the branch is classified as global, predicted not taken by global prediction <b>238</b> and the M bit <b>1704</b> indicates a multiple branch condition, control logic <b>1700</b> conveys the address immediately following the first branch instruction as the fetch address. Otherwise, control logic <b>1700</b> conveys the address received from multiplexor <b>260</b> as the next fetch address. Advantageously, multiple branch predictions may be made for a single group of instructions.</p><p>Other embodiments of reorder buffer <b>32</b> may not employ the line oriented structure described above. Instead, individual storage locations may be allocated to each instruction, with tags assigned in numerically increasing order. If a dependency is detected among concurrently dispatched instructions, the relative position of the dependency may be subtracted from the instruction tag to generate the tag of the dependency.</p><p>Turning now to FIG. 18, a block diagram of one embodiment of a computer system <b>1800</b> including processor <b>10</b> coupled to a variety of system components through a bus bridge <b>1802</b> is shown. Other embodiments are possible and contemplated. In the depicted system, a main memory <b>1804</b> is coupled to bus bridge <b>1802</b> through a memory bus <b>1806</b>, and a graphics controller <b>1808</b> is coupled to bus bridge <b>1802</b> through an AGP bus <b>1810</b>. Finally, a plurality of PCI devices <b>1812</b>A-<b>1812</b>B are coupled to bus bridge <b>1802</b> through a PCI bus <b>1814</b>. A secondary bus bridge <b>1816</b> may further be provided to accommodate an electrical interface to one or more EISA or ISA devices <b>1818</b> through an EISA/ISA bus <b>1820</b>. Processor <b>10</b> is coupled to bus bridge <b>1802</b> through a CPU bus <b>1824</b> and to an optional L<b>2</b> cache <b>1828</b>.</p><p>Bus bridge <b>1802</b> provides an interface between processor <b>10</b>, main memory <b>1804</b>, graphics controller <b>1808</b>, and devices attached to PCI bus <b>1814</b>. When an operation is received from one of the devices connected to bus bridge <b>1802</b>, bus bridge <b>1802</b> identifies the target of the operation (e.g. a particular device or, in the case of PCI bus <b>1814</b>, that the target is on PCI bus <b>1814</b>). Bus bridge <b>1802</b> routes the operation to the targeted device. Bus bridge <b>1802</b> generally translates an operation from the protocol used by the source device or bus to the protocol used by the target device or bus.</p><p>In addition to providing an interface to an ISA/EISA bus for PCI bus <b>1814</b>, secondary bus bridge <b>1816</b> may further incorporate additional functionality, as desired. An input/output controller (not shown), either external from or integrated with secondary bus bridge <b>1816</b>, may also be included within computer system <b>1800</b> to provide operational support for a keyboard and mouse <b>1822</b> and for various serial and parallel ports, as desired. An external cache unit (not shown) may further be coupled to CPU bus <b>1824</b> between processor <b>10</b> and bus bridge <b>1802</b> in other embodiments. Alternatively, the external cache may be coupled to bus bridge <b>1802</b> and cache control logic for the external cache may be integrated into bus bridge <b>1802</b>. L<b>2</b> cache <b>1828</b> is further shown in a backside configuration to processor <b>10</b>. It is noted that L<b>2</b> cache <b>1828</b> may be separate from processor <b>10</b>, integrated into a cartridge (e.g. slot <b>1</b> or slot A) with processor <b>10</b>, or even integerated onto a semiconductor substrate with processor <b>10</b></p><p>Main memory <b>1804</b> is a memory in which application programs are stored and from which processor <b>10</b> primarily executes. A suitable main memory <b>1804</b> comprises DRAM (Dynamic Random Access Memory). For example, a plurality of banks of SDRAM (Synchronous DRAM) or Rambus DRAM (RDRAM) may be suitable.</p><p>PCI devices <b>1812</b>A-<b>1812</b>B are illustrative of a variety of peripheral devices such as, for example, network interface cards, video accelerators, audio cards, hard or floppy disk drives or drive controllers, SCSI (Small Computer Systems Interface) adapters and telephony cards. Similarly, ISA device <b>1818</b> is illustrative of various types of peripheral devices, such as a modem, a sound card, and a variety of data acquisition cards such as GPIB or field bus interface cards.</p><p>Graphics controller <b>1808</b> is provided to control the rendering of text and images on a display <b>1826</b>. Graphics controller <b>1808</b> may embody a typical graphics accelerator generally known in the art to render three-dimensional data structures which can be effectively shifted into and from main memory <b>1804</b>. Graphics controller <b>1808</b> may therefore be a master of AGP bus <b>1810</b> in that it can request and receive access to a target interface within bus bridge <b>1802</b> to thereby obtain access to main memory <b>1804</b>. A dedicated graphics bus accommodates rapid retrieval of data from main memory <b>1804</b> For certain operations, graphics controller <b>1808</b> may further be configured to generate PCI protocol transactions on AGP bus <b>1810</b>. The AGP interface of bus bridge <b>1802</b> may thus include functionality to support both AGP protocol transactions as well as PCI protocol target and initiator transactions. Display <b>1826</b> is any electronic display upon which an image or text can be presented. A suitable display <b>1826</b> includes a cathode ray tube (\u201cCRT\u201d), a liquid crystal display (\u201cLCD\u201d), etc.</p><p>It is noted that, while the AGP, PCI, and ISA or EISA buses have been used as examples in the above description, any bus architectures may be substituted as desired. It is further noted that computer system <b>1800</b> may be a multiprocessing computer system including additional processors (e.g. processor <b>10</b><i>a </i>shown as an optional component of computer system <b>1800</b>). Processor <b>10</b><i>a </i>may be similar to processor <b>10</b>. More particularly, processor <b>10</b><i>a </i>may be an identical copy of processor <b>10</b>. Processor <b>10</b><i>a </i>may be connected to bus bridge <b>1802</b> via an independent bus (as shown in FIG. 5) or may share CPU bus <b>1824</b> with processor <b>10</b>. Furthermore, processor <b>10</b><i>a </i>may be coupled to an optional L<b>2</b> cache <b>1828</b><i>a </i>similar to L<b>2</b> cache <b>1828</b>.</p><p>It is noted that the present discussion may refer to the assertion of various signals. As used herein, a signal is \u201casserted\u201d if it conveys a value indicative of a particular condition. Conversely, a signal is \u201cdeasserted\u201d if it conveys a value indicative of a lack of a particular condition. A signal may be defined to be asserted when it conveys a logical zero value or, conversely, when it conveys a logical one value. Additionally, various values have been described as being discarded in the above discussion. A value may be discarded in a number of manners, but generally involves modifying the value such that it is ignored by logic circuitry which receives the value. For example, if the value comprises a bit, the logic state of the value may be inverted to discard the value. If the value is an n-bit value, one of the n-bit encodings may indicate that the value is invalid. Setting the value to the invalid encoding causes the value to be discarded. Additionally, an n-bit value may include a valid bit indicative, when set, that the n-bit value is valid. Resetting the valid bit may comprise discarding the value. Other methods of discarding a value may be used as well.</p><p>Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Gerald D.", "last_name": "Zuraski, Jr.", "name": ""}, {"first_name": "James S.", "last_name": "Roberts", "name": ""}, {"first_name": "Raghuram S.", "last_name": "Tupuri", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}, {"first_name": "", "last_name": "ADVANCED MICRO DEVICES, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/40"}, {"primary": false, "label": "G06F   9/305"}, {"primary": false, "label": "G06F   9/42"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/42        20060101A I20051008RMUS"}, {"label": "G06F   9/38        20060101A I20060722RMEP"}], "national_classes": [{"primary": true, "label": "712234"}, {"primary": false, "label": "712240"}, {"primary": false, "label": "711125"}, {"primary": false, "label": "712E09051"}, {"primary": false, "label": "712207"}, {"primary": false, "label": "712E09083"}, {"primary": false, "label": "712E09049"}, {"primary": false, "label": "712239"}, {"primary": false, "label": "712E09057"}], "ecla_classes": [{"label": "G06F   9/38B2B"}, {"label": "G06F   9/38E2T"}, {"label": "G06F   9/44F1A1"}, {"label": "G06F   9/38E"}], "cpc_classes": [{"label": "G06F   9/4486"}, {"label": "G06F   9/3836"}, {"label": "G06F   9/3857"}, {"label": "G06F   9/3806"}, {"label": "G06F   9/384"}, {"label": "G06F   9/3838"}, {"label": "G06F   9/3848"}, {"label": "G06F   9/3855"}, {"label": "G06F   9/384"}, {"label": "G06F   9/3836"}, {"label": "G06F   9/3857"}, {"label": "G06F   9/4486"}, {"label": "G06F   9/3855"}, {"label": "G06F   9/3848"}, {"label": "G06F   9/3838"}, {"label": "G06F   9/3806"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1999-11-16", "application_date": "1999-11-16", "family_members": [{"ucid": "US-6502188-B1", "titles": [{"lang": "EN", "text": "Dynamic classification of conditional branches in global history branch prediction"}]}]}