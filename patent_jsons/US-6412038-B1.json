{"patent_number": "US-6412038-B1", "publication_id": 73061886, "family_id": 24004370, "publication_date": "2002-06-25", "titles": [{"lang": "EN", "text": "Integral modular cache for a processor"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50337853\"><p>An integral modular cache. One embodiment includes a processor portion and a cache memory portion. The cache memory portion includes an array portion having tag logic and a set portion. The array portion extends along substantially all of a first axis of the processor. Control logic is to receive a cache size indicator and is capable of operating the cache with the one set portion or with additional set portions.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00001\" num=\"1\"><claim-text>1. An integrated circuit comprising:</claim-text><claim-text>a processor portion; </claim-text><claim-text>a cache portion comprising a plurality of banks, each bank having data for a plurality of ways oriented in a first direction and having data path logic occupying only a portion of the width of the bank in the first direction to provide way modularity; </claim-text><claim-text>control logic to operate with a variable number of said plurality of modular array portions in response to a cache size indicator signal. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00002\" num=\"2\"><claim-text>2. The integrated circuit of <claim-ref idref=\"US-6412038-B1-CLM-00001\">claim 1</claim-ref> wherein said cache portion further comprises a plurality of modular set portions.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00003\" num=\"3\"><claim-text>3. The integrated circuit of <claim-ref idref=\"US-6412038-B1-CLM-00002\">claim 2</claim-ref> wherein said control logic comprises variable length tag match logic.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00004\" num=\"4\"><claim-text>4. The integrated circuit of <claim-ref idref=\"US-6412038-B1-CLM-00001\">claim 1</claim-ref> wherein said cache size indicator signal is controlled by a fuse.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00005\" num=\"5\"><claim-text>5. The integrated circuit of <claim-ref idref=\"US-6412038-B1-CLM-00001\">claim 1</claim-ref> wherein said cache further comprises a plurality of signal lines adjacent to an outer edge of said cache portion for interfacing with data lines and at least one hit line from an additional cache portion.</claim-text></claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00006\" num=\"6\"><claim-text>6. A processor comprising:</claim-text><claim-text>a processor portion; </claim-text><claim-text>a cache memory portion comprising: </claim-text><claim-text>an array portion comprising tag logic and a set portion, said array portion extending along substantially all of a first axis of said processor; </claim-text><claim-text>control logic to receive a cache size indicator and capable of operating with said set portion or with additional set portions; </claim-text><claim-text>a plurality of signal lines adjacent to an outer edge of said cache memory portion for interfacing with data lines and at least one hit line from an additional cache memory portion. </claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00007\" num=\"7\"><claim-text>7. The processor of <claim-ref idref=\"US-6412038-B1-CLM-00006\">claim 6</claim-ref> wherein said control logic comprises a variable length tag matching circuit coupled to receive said cache size indicator and to perform tag matching on a variable number of tag bits based on said cache size indicator.</claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00008\" num=\"8\"><claim-text>8. The processor of <claim-ref idref=\"US-6412038-B1-CLM-00007\">claim 7</claim-ref> wherein said variable length tag matching circuit comprises a tag truncation circuit coupled to receive said cache size indicator and to set extra tag bits to a predetermined state when tag updates occur and when tag comparisons occur.</claim-text></claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00009\" num=\"9\"><claim-text>9. The processor of <claim-ref idref=\"US-6412038-B1-CLM-00007\">claim 7</claim-ref> wherein said cache memory portion further comprises:</claim-text><claim-text>a plurality of banks, each bank having data for a plurality of ways oriented in a first direction and having data path logic occupying only a portion of the width of the bank in the first direction to provide way modularity. </claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00010\" num=\"10\"><claim-text>10. The processor of <claim-ref idref=\"US-6412038-B1-CLM-00009\">claim 9</claim-ref> wherein said cache memory portion further comprises:</claim-text><claim-text>a second set portion also extending along substantially all of said first axis, said second set portion connecting to said plurality of signal lines. </claim-text></claim>"}, {"num": 11, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00011\" num=\"11\"><claim-text>11. The processor of <claim-ref idref=\"US-6412038-B1-CLM-00006\">claim 6</claim-ref> wherein said set portion comprises a plurality of ways, and further wherein said control logic is capable of operating with a variable number of ways based on said cache size indicator.</claim-text></claim>"}, {"num": 12, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00012\" num=\"12\"><claim-text>12. The processor of <claim-ref idref=\"US-6412038-B1-CLM-00006\">claim 6</claim-ref> further comprising fused cache size indicator logic that is programmable to generate said cache size indicator.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00013\" num=\"13\"><claim-text>13. An integrated circuit comprising:</claim-text><claim-text>a processor portion; </claim-text><claim-text>a cache portion, said cache portion comprising a plurality of modules, said cache portion extending for substantially all of a first axis of said integrated circuit, one of said plurality of modules comprising: </claim-text><claim-text>a tag portion coupled to receive a cache size indicator signal and to match a variable number of tag bits based on said cache size indicator signal; and </claim-text><claim-text>a plurality of banks, each bank having data for a plurality of ways oriented in a first direction and having data path logic occupying only a portion of the width of the bank in the first direction to provide way modularity. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00014\" num=\"14\"><claim-text>14. The integrated circuit of <claim-ref idref=\"US-6412038-B1-CLM-00013\">claim 13</claim-ref> wherein said tag portion comprises:</claim-text><claim-text>tag truncation logic to set one or more tag bits to a predetermined value. </claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00015\" num=\"15\"><claim-text>15. The integrated circuit of <claim-ref idref=\"US-6412038-B1-CLM-00014\">claim 14</claim-ref> further comprising a multiplexer to select data from a module that generates a hit signal, the control logic limiting choices for the multiplexer depending on the cache size indicator signal.</claim-text></claim>"}, {"num": 16, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6412038-B1-CLM-00016\" num=\"16\"><claim-text>16. The integrated circuit of <claim-ref idref=\"US-6412038-B1-CLM-00014\">claim 14</claim-ref> further comprising:</claim-text><claim-text>at least one fuse; </claim-text><claim-text>cache size logic coupled to said fuse to generate said cache size indicator signal as a function of whether or not said at least one fuse has been blown.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53586873\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND</h4><p>1. Field of the Disclosure</p><p>The present disclosure pertains to the field of cache memories and particularly to the field of cache memories integrated with a data processing component.</p><p>2. Description of Related Art</p><p>Providing a number of cache size options for a product such as a microprocessor having an integrated cache may be highly beneficial. Different cache sizes typically have relatively predictable impacts on performance. Therefore, offering products with different cache sizes advantageously allows one to market the different products at different performance levels.</p><p>Moreover, the different cache sizes typically translate substantially directly into total area required for the integrated circuit die. Accordingly, the price of the die may be partially controlled by choosing the amount of cache memory to include. Unfortunately, typical caches on integrated circuits with other processing logic are not easily resized such that the entire die size can be changed.</p><p>In some prior art systems, system caches remain apart from integrated circuits such as microprocessors. For example, some of the original Pentium\u2122 Processors available from Intel\u00ae Corporation of Santa Clara, Calif. did not include a second level (L2) cache. A separate system cache may have been used, and that cache size could be adjusted by altering the particular cache component plugged into the system and perhaps the control logic used in the system. Later, some Pentium Processors included an L2 cache in a multi-chip module. In these processors, discrete static random access memory (SRAM) chips were included within the same module. Again, by altering the number or size of the SRAM chips, the size of the L2 cache was easily variable.</p><p>Currently, some processors integrate the L2 cache on die. It is expected that L2 and/or other additional such integration will continue in the future. Unfortunately, when a cache (or other memory structure) is integrated onto a single integrated circuit which includes other logic, changing the cache size typically becomes more difficult that merely replacing a module such as a discrete SRAM or a system level cache chip. The control logic for the cache (e.g., sense amps, set and way control logic, tag control logic, and the like) is not inherently divided as is a cache array and therefore may be integrated or synthesized within a region such that portions may not be easily excised. Moreover, a cache control circuit for an integrated cache typically is not designed to operate properly if a portion of the cache array is removed. A prior art cache array typically expects certain responses from the array and would not function properly if portions of the array were removed.</p><p>For example, a prior art processor <b>100</b> is shown in FIG. <b>1</b>. The processor includes a cache <b>110</b> that has cache array(s) <b>130</b> (e.g., data, parity, tag, etc.) which may be organized into various set and way arrangements. Control logic <b>120</b> is a single block that communicates with and controls the array(s) <b>130</b>. Thus, there is no simple manner of removing sets or ways.</p><p>Additionally, the overhead of altering a large integrated circuit is indeed typically quite substantial. For example, integrated circuits are typically produced using a series of optical masks. These masks are generally produced after a product design is complete, validation is performed, and a tapeout process is completed. Any alteration of the actual circuitry involved requires that substantial time consuming validation be again performed. Thus, the unified nature of the control block and/or any logic sharing that requires alteration to change cache sizes may detrimentally increase the time required to implement such a change.</p><p>Moreover, a traditional integrated cache is typically physically placed on a die in a convenient fashion with respect to the other functional blocks. This typically results in a cache being isolated to a portion of any axis of the die. For example, in FIG. 1, the cache occupies only a portion of both of the X and Y axes. A removal of either a set or a way would create a hole in any rectangular die. Thus, removing a portion of the cache would not help reduce costs as the die size would remain the same (assuming traditional rectangular die lines are maintained). In order to easily change the size of the cache, the logic of the entire processor <b>100</b> may need to be rearranged, again requiring time consuming validation steps to be performed. Die re-arrangement also typically alters distances between some signal drivers and receivers, thereby disadvantageously altering timing arrangements between circuits and potentially requiring accommodating modification.</p><p>Thus, size changes for traditional integrated caches may disadvantageously require time consuming circuit changes and validation due to the alteration of control circuitry. Moreover, traditional caches may not be physically situated to allow a straightforward die size alteration in conjunction with a cache size change.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE FIGURES</h4><p>The present invention is illustrated by way of example and not limitation in the figures of the accompanying drawings.</p><p>FIG. 1 illustrates a prior art processor having an integrated cache.</p><p>FIG. 2 illustrates one embodiment of a processor having an integral modular cache with two modules.</p><p>FIG. 3 illustrates one embodiment of an integral modular cache with a variable number of modules.</p><p>FIG. 4 illustrates one embodiment of a technique for separating addresses into sets and ways for an variably sized integral modular cache.</p><p>FIG. 5 illustrates one embodiment of variable length tag matching logic.</p><p>FIG. 6 illustrates one embodiment of a set and way-modular cache.</p><p>FIG. 7 illustrates further details for a bottom half of one embodiment of the cache of FIG. <b>6</b>.</p><p>FIG. 8 illustrates further details for one bank for one embodiment of the cache of FIGS. 6-7.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION</h4><p>The following description provides an integral modular cache for a processor. In the following description, numerous specific details such as numbers of cache modules, sets, ways, signal names, address bits, and logic partitioning/integration choices are set forth in order to provide a more thorough understanding of the present invention. It will be appreciated, however, by one skilled in the art that the invention may be practiced without such specific details. In other instances, control structures and gate level circuits have not been shown in detail in order not to obscure the invention. Those of ordinary skill in the art, with the included descriptions, will be able to implement appropriate logic circuits without undue experimentation.</p><p>Presently disclosed techniques provide a cache memory that allows relatively easy size alterations. A relatively easy alteration involves little or no change in the cache control logic such that not all validation efforts have to be performed again to allow production of the product with the modified cache size. The need for such easily alterable caches is particularly acute, although not solely applicable, in the arena of high integration products where the cache is a portion of a larger die. Described techniques advantageously allow parts with numerous cost and performance price points to be relatively easily produced from a base product.</p><p>FIG. 2 illustrates one embodiment of a processor <b>200</b> having a modular cache <b>210</b>. A modular cache, as discussed herein, is a cache that has portions or modules that are relatively easily removed from the integrated circuit. That is, such portions may be removed without rendering inoperative the remaining cache and control logic portions. The control logic of the modular cache may, however, receive an indication of the existing cache size to ensure proper operation.</p><p>The processor <b>200</b> includes processing logic <b>202</b> and the modular cache <b>210</b>. The processing logic <b>202</b> may process instructions for a general purpose computer system or may perform more specialized processing tasks for appliances or tasks related to networking, communication, or digital signal processing. In the embodiment of FIG. 2, the cache <b>210</b> may be one of two sizes. The cache <b>210</b> may include only a bottom half (sets <b>0</b>-N\u22121), or may include the bottom half and a top half (sets N\u22122N\u22121). The cache size may be selected using a programmable fuse <b>290</b> in conjunction with cache size logic <b>285</b> that generates a cache size indicator on a signal line <b>288</b>. The cache size indicator is provided to variable length tag match logic <b>240</b>.</p><p>The variable length tag match logic <b>240</b> performs tag matching to compare incoming read request addresses against tags stored in a tag array. Depending on the size of the cache, a different number of tag match operations may be performed. For example, in the case where only the bottom half of the cache <b>210</b> is included in the processor <b>200</b>, a number S<sub>0 </sub>of bits may be required to represent the N sets. Thus, the address may be broken down into T tag bits and S<sub>0 </sub>set bits. When the cache <b>210</b> is doubled to include 2N sets, another bit is required to represent the 2N sets. Thus, one less tag bit may be used, and the variable length tag match logic <b>240</b> may disregard one of the tag bits. As is further discussed below, this technique may be extended to support a cache with a variety of different sizes.</p><p>Control logic <b>245</b> is coupled to receive one or more hit signals on signal line(s) <b>242</b>. Hit signals from the upper half may be generated by tag logic <b>270</b>, and hit signals from the lower half may be generated by the variable length tag match logic <b>240</b>. In some embodiments, the tag logic of both the upper and lower half may be identical, making them more modular. In other embodiments, however, it may be possible to simplify the tag logic <b>270</b> of the top half since the top half may not need to perform variable length tag matching in this two-module embodiment.</p><p>Assuming a match occurs in the top half, data may be read from an array <b>265</b> or an array <b>280</b> respectively through multiplexers <b>260</b> and <b>275</b>. The data may be passed along to multiplexers <b>230</b> and <b>250</b> in the bottom half. The cache size indicator may be logically combined with the address bit that is the highest order bit of the set number to select either the top or bottom half of the cache to provide data through multiplexers <b>230</b> or <b>250</b> to a bus <b>217</b>. Thus, if the cache size indicator indicates that only the bottom half of the cache is present in the processor <b>200</b>, the multiplexers <b>230</b> and <b>250</b> do not select the top half. If the cache size indicator indicates that the top half is present in processor <b>200</b>, the multiplexers <b>230</b> and <b>250</b> select the bottom half when data is found in one of sets <b>0</b>-N\u22121 and select the top half when data is found in one of sets N-2N\u22121.</p><p>In alternative embodiments, substitutes for these multiplexing structures may be used. For example, a tri-state structure may be used by each portion of the cache to drive data to the bus <b>217</b>. Such a tri-state implementation may be more amenable to further modular extension to numerous different cache sizes. In either implementation, if a cache access implicates the top half of the range of available sets, data is read from or passed along to the top half of the cache. If the top half of the cache is not present, the location is mapped into the bottom half of the cache.</p><p>Advantageously, this design allows the insertion or removal of the top half of the cache without requiring changes to the control circuitry for the cache. The control circuitry may be operated in either mode simply by changing the cache size indicator signal input to the cache. If the top half is missing, no hits will be received from the top half, and no data will be multiplexed to the bus <b>217</b> from the top half. All locations are mapped to the bottom half when the top half is not present. Since no circuitry redesign is required, a processor with different size caches may be easily produced. The control circuitry need not passed through extensive validation procedures when the cache sizes changed because the control logic is not itself change.</p><p>Additionally, as illustrated in FIG. 2, since the upper module (sets N-2N\u22121) extends across substantially all of the x-axis of the processor <b>200</b>, the removal of this upper module translates directly into a die size reduction. Accordingly, different die sizes with different cache sizes may easily be produced to address different marketing needs. Notably, I/O logic may be provided at the very edges of the integrated circuit die. Therefore, the cache modules may not span an entire axis of the die. The I/O logic, however, may be moved as cache modules are inserted or removed.</p><p>FIG. 3 illustrates one embodiment of a processor having a plurality of different cache modules. In this embodiment, individual modules <b>320</b>, <b>330</b>, and <b>340</b> are part of an N module modular cache. Module <b>320</b> includes an array <b>322</b>, tag logic <b>324</b>, and an array <b>326</b>. Module <b>330</b> includes an array <b>332</b>, tag logic <b>334</b>, and an array <b>336</b>. Likewise, module <b>340</b> includes an array <b>342</b> tag logic <b>344</b>, and an array <b>346</b>. Each module may generate hit signals on a hit bus <b>315</b>. A cache size indicator may be generated on a cache size bus <b>305</b> by control logic <b>312</b>. Each of the arrays from each module may drive a bus <b>307</b> using tri-state logic. The various arrays and tag logic may be rearranged in other embodiments. For example, the arrays for each module may be unified or may be further divided. Additionally, the tag logic may be physically located in positions other than the middle of the x axis of the die.</p><p>The hit bus <b>315</b> may be a single signal line which is aligned in a predetermined physical position on the die. If additional modules are added they may be coupled to the same signal line to indicate when a hit occurs. Alternatively, a set of hit lines may be provided, with some lines remaining unconnected and therefore deasserted when fewer than the maximum number of cache modules are present. Similarly, data buses from the various modules may be physically aligned so that additional modules connect directly to the pre-existing buses. These aligned hit and data paths allow new modules to be added without circuit or signal line rearrangement. Again, obviating the need for signal line or circuit rearrangement reduces the validation procedures required to produce a processor with a different cache size.</p><p>FIGS. 4 and 5 illustrate additional details of variable length tag matching as may be used in some embodiments. As indicated in FIG. 4, an address may have A bits in a particular system. The number of bits needed to represent a cache line is typically fewer than A, and is designated L in the illustrated embodiment. When the smallest cache size is used, S<sub>0 </sub>bits are used to represent the number of sets. Thus, there are 2<sup>S</sup><sub>0 </sub>(<b>2{circumflex over ( )}S</b><sub>0</sub>) sets in the smallest cache size. This leaves L\u2212S<sub>0 </sub>tag bits in the smallest cache size.</p><p>The cache may be multiplied in size by powers of two (1, 2, 4, 8, etc.). Each power of two requires an additional bit to represent the number of sets in the cache. Thus the number of sets, S, increases from S<sub>0</sub>. The number of tag bits accordingly decreases (to L\u2212S) when the cache size is increased. The variable length tag match logic (which may be a content addressable memory (CAM)) thus ignores the (S\u2212S<sub>0</sub>) least significant bits in the tag.</p><p>In one embodiment, a 32-bit address may be used, with bits <b>31</b>:<b>5</b> representing the cache line address (L=27). The cache may be either 256 kilobytes (k) or 128k, with 1024 sets in the former case and 512 in the latter. In this embodiment, there are 9 set bits (S<sub>0</sub>) in 128k mode and 10 set bits in 256k mode. Thus, the tags are respectively 18 and 17 bits long. Set bit <b>14</b> may be used to select a multiplexer between top and bottom modules, and address bit <b>14</b> may be ANDed with a cache size indicator that has an active high value indicating 128k cache size to perform tag truncation. That is, the tag may be Address[<b>31</b>:<b>14</b>] with the Address[<b>14</b>] bit ANDed with a cache size indicator.</p><p>An appropriate variable length tag matching circuit <b>500</b> for a variety of cache sizes is shown in FIG. 5. A tag truncation circuit <b>530</b> receives the cache size indicator on a signal line <b>502</b> and an incoming address on a signal line <b>504</b>. The tag truncation circuit may set (S\u2212S<sub>0</sub>) tag bits to a predetermined value (e.g., logical 0). Thus, a truncated tag is stored in the tag array <b>510</b> when a cache write occurs via tag update path <b>532</b>. Similarly, a truncated tag is compared by a comparator <b>520</b> to the value retrieved from the tag array <b>510</b> when a tag comparison operation is performed. Accordingly, variable length comparisons may be performed using a single tag array and comparison structure by simply changing a cache size indicator input.</p><p>FIGS. 6-8 illustrate an arrangement of data, parity, and tag arrays for one way-modular embodiment. In the embodiment of FIGS. 6-8, the eight ways of the modular cache are interleaved into each sub-array portion. As illustrated in FIG. 6, a component <b>600</b> includes both the top and bottom sets of banks. The top half includes top bank<b>0</b>-top bank<b>7</b>, respectively marked <b>620</b>-<b>0</b>-<b>620</b>-<b>7</b>. The bottom half includes bank<b>0</b>-bank<b>7</b>, respectively marked <b>610</b>-<b>0</b>-<b>610</b>-<b>7</b>. Bank<b>3</b> for both the top and bottom includes parity information.</p><p>The tag information and least recently used (LRU) information in the illustrated embodiment is included in central portion. Tag Banks <b>0</b>-<b>3</b> are respectively provided for the top (<b>650</b>-<b>0</b>-<b>650</b>-<b>3</b>) and for the bottom (<b>630</b>-<b>0</b>-<b>630</b>-<b>3</b>). The top includes LRUBNKTOP <b>660</b> and the bottom includes LRUBNK <b>640</b> to track least recently used information that allows an efficient cache replacement policy to be implemented.</p><p>In the illustrated embodiment, sets <b>512</b>-<b>1024</b> are included in the top half (A[<b>14</b>]=1) and sets <b>0</b>-<b>511</b> are included in the bottom half (A[<b>14</b>]=0). As shown in detail with respect to banks <b>0</b> and <b>7</b>, way data for each of 8 ways is included in each bank. Thus, each bank (of either the top or the bottom, depending on which set is accessed) provides eight bits of data for a cache access. Bank<b>0</b> provides bits <b>7</b>:<b>0</b> (DB[<b>7</b>:<b>0</b>]), bank<b>1</b> provides bits <b>15</b>:<b>8</b> (DB[<b>15</b>:<b>8</b>]), bank<b>2</b> provides bits <b>23</b>:<b>16</b> (DB[<b>23</b>:<b>16</b>]), and so on. The parity bits may be included with bank<b>3</b>.</p><p>As a result of the inclusion of data from each way in each bank, way multiplexer structures may be limited to each bank as illustrated in FIG. <b>7</b>. Thus, as shown in FIG. 7 for the bottom half of the cache, each bank has a write driver (WrDriver) structure and a way multiplexer (WayMux) structure, respectively labeled <b>710</b>-<b>0</b>-<b>710</b>-<b>7</b> and <b>720</b>-<b>0</b>-<b>720</b>-<b>7</b> for banks <b>0</b>-<b>7</b>. A 32-bit interface with data path portions <b>730</b>-<b>0</b>-<b>7307</b> for each of banks <b>0</b>-<b>7</b> provide data to be read from and written to the cache. Additionally, a parity array <b>635</b> is shown associated with bank<b>3</b><b>610</b>-<b>3</b> and a parity data path portion <b>735</b> provides parity bits read from and written to the cache.</p><p>FIG. 8 illustrates additional details for one embodiment of a bank <b>610</b>-N. In the embodiment of FIG. 8, way<b>0</b><b>810</b>-<b>0</b> through way<b>7</b><b>810</b>-<b>7</b> are included in the bank <b>610</b>-N. The ways are organized into groups of two ways (Dway<b>76</b>, Dway<b>54</b>, Dway<b>32</b>, and Dway<b>10</b>). Each group of ways includes a local decoder (LDEC) and a way multiplexer <b>820</b>-<b>0</b>-<b>820</b>-<b>3</b>. Word lines (WLs), a read start indication (Read), a write start indication (Write), and a hit indication are all provided to the array to perform standard cache read and write operations.</p><p>The way multiplexers <b>820</b>-<b>0</b>-<b>820</b>-<b>3</b> receive way select signals (waysel[<b>7</b>:<b>0</b>]) and drive data on a data bus <b>840</b>. The data is bused by two sixteen bit data path portions <b>845</b>-A and <b>845</b>-B. These data path portions may include latches, buffers, and/or merely signal routing. In the case of a read operation, read chunk select signals (Rdchunk[<b>3</b>:<b>0</b>]) determine which data is first driven to the data output bus <b>850</b> (e.g., the most critically needed chunk may be driven first). In the case of a write cycle, the buffers receive data from the data input bus <b>860</b>. The data is written a selected chunk at a time according to write chunk select signals (Wrchunk[<b>3</b>:<b>0</b>]). The data is written from the data path portions <b>845</b>-A and <b>845</b>-B to a bus <b>830</b> from which it may be written to the cache array.</p><p>In one embodiment, the layout of the data path (i.e., <b>845</b>-A, <b>845</b>-B and associated logic) occupies only one half of the width of the bank <b>610</b>-N. This arrangement enables a relatively simple reduction of the cache size by removing one to four of the ways. When ways are removed, control logic is configured (e.g., by cache size indicator signals) to not store data in the missing ways. One to four ways may be removed (from all banks), thereby allowing a the flexibility to change the die size in the Y axis, and making the cache way-modular.</p><p>Thus, an integral modular cache for a processor is disclosed. While certain exemplary embodiments have been described and shown in the accompanying drawings, it is to be understood that such embodiments are merely illustrative of and not restrictive on the broad invention, and that this invention not be limited to the specific constructions and arrangements shown and described, since various other modifications may occur to those ordinarily skilled in the art upon studying this disclosure.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Moty", "last_name": "Mehalel", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTEL CORPORATION"}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/08"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMUS"}], "national_classes": [{"primary": true, "label": "711003"}, {"primary": false, "label": "711128"}, {"primary": false, "label": "711212"}, {"primary": false, "label": "711E12042"}, {"primary": false, "label": "711172"}, {"primary": false, "label": "365051"}], "ecla_classes": [{"label": "S06F212:601"}, {"label": "S06F12:08B10"}, {"label": "G06F  12/08B22D"}], "cpc_classes": [{"label": "G06F2212/601"}, {"label": "G06F  12/0864"}, {"label": "G06F  12/0895"}, {"label": "G06F  12/0895"}, {"label": "G06F  12/0864"}, {"label": "G06F2212/601"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "2000-02-14", "application_date": "2000-02-14", "family_members": [{"ucid": "US-6412038-B1", "titles": [{"lang": "EN", "text": "Integral modular cache for a processor"}]}, {"ucid": "AU-3127101-A", "titles": []}, {"ucid": "AU-2001231271-A1", "titles": [{"lang": "EN", "text": "An integral modular cache for a processor"}]}, {"ucid": "TW-497102-B", "titles": [{"lang": "EN", "text": "An integral modular cache for a processor"}]}, {"ucid": "WO-2001061501-A1", "titles": [{"lang": "FR", "text": "MEMOIRE CACHE MODULAIRE INTEGRALE POUR PROCESSEUR"}, {"lang": "EN", "text": "AN INTEGRAL MODULAR CACHE FOR A PROCESSOR"}]}]}