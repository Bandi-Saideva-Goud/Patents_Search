{"patent_number": "US-6976157-B1", "publication_id": 74475174, "family_id": 35452740, "publication_date": "2005-12-13", "titles": [{"lang": "EN", "text": "Circuits, systems and methods for performing branch predictions by selectively accessing bimodal and fetch-based history tables"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50906407\"><p num=\"p-0001\">Branch prediction circuitry including a bimodal branch history table, a fetch-based branch history table and a selector table is provided. The local branch history table includes a plurality of entries each for storing a prediction value and accessed by selected bits of a branch address. The fetch-based branch history table included a plurality of entries for storing a prediction value and accessed by a pointer generated from selected bits of the branch address and bits from a history register. The selector table includes a plurality of entries each for storing a selection bit and accessed by a pointer generated from selected bits from the branch address and bits from the history register, each selector bit is used for selecting between a prediction value accessed from the local history table and a prediction value accessed from the fetch-based history table.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00001\" num=\"00001\">\n<claim-text>1. A processing system comprising:\n<claim-text>a first branch history table comprising a plurality of bimodally accessed entries for storing a first set of branch prediction bits;</claim-text>\n<claim-text>a second branch history table comprising a plurality of fetch-based accessed entries for storing a second set of branch prediction bits;</claim-text>\n<claim-text>a selector for selecting in response to a selection control bit selected from a set of selection control bits, a bit from a selected one of said sets of bits accessed from said first and second branch history tables; and</claim-text>\n<claim-text>a selector table comprising a plurality of entries for storing said a set of selector bits as a function of a performance history of said first and second sets of branch prediction bits stored in said first and second branch history tables, wherein said each said entry in said tables comprises a 1-bit counter.</claim-text>\n</claim-text>\n</claim>"}, {"num": 2, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00002\" num=\"00002\">\n<claim-text>2. Branch prediction circuitry comprising:\n<claim-text>a bimodal branch history table comprising a plurality of entries each for storing a prediction value and accessed by selected bits of a branch address;</claim-text>\n<claim-text>a fetch-based branch history table comprising a plurality of entries for storing a prediction value and accessed by a pointer generated from selected bits of said branch address and bits from a history register, each entry of the fetch-based branch history table operable for containing bits representing a prediction value for a plurality of branches in a fetch group, wherein each fetch group is represented by a bit in the history register; and</claim-text>\n<claim-text>a selector table comprising a plurality of entries each for storing a plurality of selection bits and accessed by a pointer generated from selected bits from said branch address and bits from said history register, each said selector bit used for selecting between a bimodal prediction value accessed from the bimodal history table and a prediction value accessed from said fetch-based history table.</claim-text>\n</claim-text>\n</claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00003\" num=\"00003\">\n<claim-text>3. The branch prediction circuitry of <claim-ref idref=\"CLM-00002\">claim 2</claim-ref> and further comprising circuitry for updating said bimodal and fetch-based branch history tables operable to:\n<claim-text>set a corresponding entry in each of said bimodal and fetch-based branch history tables to a first value when a branch is taken at branch resolution time; and</claim-text>\n<claim-text>set a corresponding entry in each of said bimodal and fetch-based branch history tables to a second value when a branch is not taken at branch resolution time.</claim-text>\n</claim-text>\n</claim>"}, {"num": 4, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00004\" num=\"00004\">\n<claim-text>4. The branch prediction circuitry of <claim-ref idref=\"CLM-00002\">claim 2</claim-ref> wherein said history register comprises a shift register and said branch prediction circuitry further comprises circuitry for updating said shift register by shifting in a preselected prediction value for each fetch group.</claim-text>\n</claim>"}, {"num": 5, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00005\" num=\"00005\">\n<claim-text>5. The branch prediction circuitry of <claim-ref idref=\"CLM-00002\">claim 2</claim-ref> and further comprising circuitry for updating said selector table operable to:\n<claim-text>update a corresponding bit in a selected entry in said selector table with a first value when a bimodal prediction value from said bimodal branch history table correctly represents a corresponding branch resolution; and</claim-text>\n<claim-text>update a corresponding bit in a selected entry in said selector table with a second value when a fetch-based prediction value from said fetch-based branch history table correctly represents the corresponding branch resolution.</claim-text>\n</claim-text>\n</claim>"}, {"num": 6, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00006\" num=\"00006\">\n<claim-text>6. The branch prediction circuitry of <claim-ref idref=\"CLM-00002\">claim 2</claim-ref> wherein the plurality of selection bits are operable for selecting a first subset of prediction values from the bimodal branch history table and a second subset of prediction values from the fetch-based branch history table.</claim-text>\n</claim>"}, {"num": 7, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00007\" num=\"00007\">\n<claim-text>7. The branch prediction circuitry of <claim-ref idref=\"CLM-00004\">claim 4</claim-ref> wherein said circuitry for updating said selector table is further operable to maintain a value in a selected entry in said selector table when corresponding values from said bimodal and fetch-based branch history tables both correctly represent a corresponding branch resolution, and wherein said circuitry for updating said selector table is further operable to maintain a value in a selected entry in said selector table when neither values from said bimodal and fetch-based branch history tables correctly represent a corresponding branch resolution.</claim-text>\n</claim>"}, {"num": 8, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00008\" num=\"00008\">\n<claim-text>8. The branch prediction circuitry of <claim-ref idref=\"CLM-00004\">claim 4</claim-ref> wherein said circuitry for updating said selector table is further operable to set a value in a selected entry in said selector table to a value associated with said fetch-based table when corresponding values from said bimodal and fetch based branch history tables both do not correctly predict a corresponding branch resolution outcome.</claim-text>\n</claim>"}, {"num": 9, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00009\" num=\"00009\">\n<claim-text>9. A processing system comprising:\n<claim-text>a first branch history table comprising a plurality of bimodally accessed entries, each entry for storing a first set of branch prediction bits;</claim-text>\n<claim-text>a second branch history table comprising a plurality of fetch-based accessed entries each entry for storing a second set of branch prediction bits;</claim-text>\n<claim-text>a selector for selecting, in response to a plurality of selection control bits, a set of prediction bits from a selected one of said sets of bits accessed from said first and second branch history tables; and</claim-text>\n<claim-text>a selector table comprising a plurality of entries, each entry for storing a plurality of selection control bits wherein the selection control bits are set as a function of a performance history of corresponding first and second sets of branch prediction bits stored in said first and second branch history tables.</claim-text>\n</claim-text>\n</claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00010\" num=\"00010\">\n<claim-text>10. The processing system of <claim-ref idref=\"CLM-00009\">claim 9</claim-ref> wherein said entries of said selector table are accessed using fetch-based accessing.</claim-text>\n</claim>"}, {"num": 11, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00011\" num=\"00011\">\n<claim-text>11. The processing system of <claim-ref idref=\"CLM-00009\">claim 9</claim-ref> wherein said each said entry in said tables comprises a 1-bit counter.</claim-text>\n</claim>"}, {"num": 12, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00012\" num=\"00012\">\n<claim-text>12. The processing system of <claim-ref idref=\"CLM-00009\">claim 9</claim-ref> wherein said first and second branch history tables and said selector table form a portion of a branch execution unit.</claim-text>\n</claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00013\" num=\"00013\">\n<claim-text>13. The processing system of <claim-ref idref=\"CLM-00012\">claim 12</claim-ref> wherein said branch execution unit forms a part of a microprocessor.</claim-text>\n</claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00014\" num=\"00014\">\n<claim-text>14. The processing system of <claim-ref idref=\"CLM-00013\">claim 13</claim-ref> and further comprising memory coupled to said microprocessor.</claim-text>\n</claim>"}, {"num": 15, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00015\" num=\"00015\">\n<claim-text>15. A method of performing branch predictions in a processing system including a bimodal branch history table, a fetch-based branch history table and a selector table, the method comprising the substeps of:\n<claim-text>accessing the bimodal branch history table to retrieve a first set of branch prediction bits;</claim-text>\n<claim-text>accessing the fetch-based branch history table to retrieve a set of second branch prediction bits;</claim-text>\n<claim-text>selecting between the first and second sets of branch prediction bits in response to corresponding bits retrieved from the selector table, wherein a sum of a number of bits in the first set of branch prediction bits and a number of bits in the second set of branch prediction bits is not less than a number of instructions in a fetch group; and</claim-text>\n<claim-text>updating the selector table as a function of actual branch resolution.</claim-text>\n</claim-text>\n</claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00016\" num=\"00016\">\n<claim-text>16. The method of <claim-ref idref=\"CLM-00015\">claim 15</claim-ref> wherein said step of updating the selector table comprises the substeps of:\n<claim-text>determining if at least one of the first set of branch prediction bits correctly predicts the corresponding branch resolution outcome;</claim-text>\n<claim-text>updating the corresponding entry in the selector table to a first logic value when the at least one of the first set of prediction bits correctly represents the branch resolution outcome;</claim-text>\n<claim-text>determining if at least one of the second set of branch prediction bits correctly predicts the branch resolution outcome; and</claim-text>\n<claim-text>updating the corresponding entry in the selector table to a second logic value when the at least one of the second set of branch prediction bits correctly represents the branch resolution outcome.</claim-text>\n</claim-text>\n</claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00017\" num=\"00017\">\n<claim-text>17. The method of <claim-ref idref=\"CLM-00016\">claim 16</claim-ref> and further comprising the steps of:\n<claim-text>determining if at least one bit of both the first and second sets of branch history bits correctly predict the branch resolution outcome;</claim-text>\n<claim-text>maintaining the current value of corresponding bits in the corresponding selector table entry when the at least one bit of both the first and second sets of branch prediction bits correctly predict the branch resolution outcome;</claim-text>\n<claim-text>determining if at least one bit of both the first and second sets of branch prediction bits incorrectly predict the branch resolution outcome; and</claim-text>\n<claim-text>maintaining the current value of corresponding bits in the corresponding selector table entry when the at least one bit of both the first and second sets of branch history bits incorrectly predict the branch history outcome.</claim-text>\n</claim-text>\n</claim>"}, {"num": 18, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00018\" num=\"00018\">\n<claim-text>18. The method of <claim-ref idref=\"CLM-00016\">claim 16</claim-ref> and further comprising the steps of:\n<claim-text>determining whether at least one bit of both the first and second sets of branch prediction bits correctly predict the branch resolution outcome;</claim-text>\n<claim-text>maintaining the current value of corresponding bits in the corresponding selector table entry when at the least one bit of both the first and second sets of branch prediction bits correctly predict the branch resolution outcome; and</claim-text>\n<claim-text>updating the current selector table entry to a logic value associated with the fetch-based branch history table when neither of corresponding bits of the first and second sets of branch prediction bits correctly predicts the branch resolution outcome.</claim-text>\n</claim-text>\n</claim>"}, {"num": 19, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00019\" num=\"00019\">\n<claim-text>19. The method of <claim-ref idref=\"CLM-00015\">claim 15</claim-ref> wherein said step of accessing the fetch-based branch history table comprises the substep of generating an address from at least some bits of a branching instruction and bits retrieved from a history register.</claim-text>\n</claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00020\" num=\"00020\">\n<claim-text>20. The method of <claim-ref idref=\"CLM-00019\">claim 19</claim-ref> wherein the history register comprises a shift register.</claim-text>\n</claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00021\" num=\"00021\">\n<claim-text>21. The method of <claim-ref idref=\"CLM-00020\">claim 20</claim-ref> wherein said method further comprises the steps of updating the shift register by shifting in a prediction bit for each fetch group.</claim-text>\n</claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES15957445\">\n<?BRFSUM description=\"Brief Summary\" end=\"lead\"?>\n<h4>CROSS-REFERENCE TO RELATED APPLICATION</h4>\n<p num=\"p-0002\">The present invention is related to the following U.S. Patent Application filed concurrently herewith and hereby incorporated herein by reference:\n</p><ul><li id=\"ul0001-0001\" num=\"0000\"><ul><li id=\"ul0002-0001\" num=\"0002\">Ser. No. 09/434,856 entitled \u201cApparatus and Method for Controlling Link Stack Corruption During Speculative Instruction Branching;\u201d and</li><li id=\"ul0002-0002\" num=\"0003\">Ser. No. 09/434,763 entitled \u201cApparatus and Method for Accessing a Memory Device During Speculative Instruction Branching.\u201d</li></ul></li></ul>\n<h4>TECHNICAL FIELD</h4>\n<p num=\"p-0003\">The present invention relates generally to instruction pipelining in processing systems, and in particular to circuits, systems and methods for performing branch predictions by selectively accessing bimodal and fetch-based branch history tables.</p>\n<h4>BACKGROUND INFORMATION</h4>\n<p num=\"p-0004\">Modern high frequency microprocessors are typically deeply pipelined devices. For efficient instruction execution in the pipelined machines, instructions are fetched and executed speculatively. In other words, a prediction is made about the direction and target of the branch instructions being fetched many cycles before the branch actually gets executed. When the branch is executed, the direction and the target of the branch are determined. If it is determined that the branch has been mispredicted (either its target or its direction), then the branch instruction is completed and all successive instructions are flushed out of the instruction pipeline and new instructions are fetched either from the sequential path of the branch (if the branch is resolved as not taken) or from the target path of the branch (if the branch is resolved as taken).</p>\n<p num=\"p-0005\">Many branch prediction techniques have been developed. For example, in Bimodal Branch Prediction, selected bits from a branch address are used as a pointer to a branch history table. The entries to this table maintain a history as to the number of times a corresponding branch instruction is actually taken during instruction execution versus the number of times that branch instruction is not taken. From this history, a prediction can be made as to the probability that an instruction will be taken during instruction execution and therefore whether a sequential instruction following that branch instruction or the target of the branch instruction should be fetched into the instruction pipeline.</p>\n<p num=\"p-0006\">Other branch prediction techniques include Gobal Branch Prediction, Global Predictor with Index Selection (Gselect) and Global History with Index Sharing (Gshare). Often, execution of a branch instruction will depend on the execution of a previous instruction. Therefore, in these schemes, a global history shift register is used which stores history bits for a given number of previously executed branch instructions. The history bits tag if the corresponding branch was taken or not taken. The entries in the register are then used to address a global branch history table holding prediction values. In Gselect, bits from previously executed instructions are combined with selected bits from the current branch instruction to address the global branch history table. In Gshare, an XOR operation is performed using the register contents and bits from the address of the current cache line to generate the pointer to the table.</p>\n<p num=\"p-0007\">Each of the existing schemes is subject to disadvantages, either in prediction accuracy, amount of hardware (e.g. the number of arrays required for the tables), or speed. Thus, the need has arisen for more efficient methods circuits and methods for performing branch prediction.</p>\n<h4>SUMMARY OF THE INVENTION</h4>\n<p num=\"p-0008\">According to the principles of the present invention, branch prediction circuitry is disclosed which included a bimodal branch history table, a fetch-based branch history table and a selector table is provided. The bimodal branch history table includes a plurality of entries each for storing a prediction value and accessed by selected bits of a branch address. The fetch-based branch history table has a plurality of entries for storing a prediction value and accessed by a pointer generated from selection bits of the branch address and bits from a history register. The selector table comprises a plurality of entries each for storing a selection bit and accessed by a pointer generated from selected bits from the branch address and bits from the history register, each selector bit is used for selecting between a prediction value accessed from the bimodal history table and a prediction value accessed from the fetch-based history table.</p>\n<p num=\"p-0009\">In the preferred embodiments of the present inventive principles, circuitry systems and methods combine bimodal branch prediction with fetch-based branch prediction using only three tables. In addition to minimizing circuitry, the present inventive concepts do not require extensive and/or complicated schemes for accessing these tables, as was required in the prior art.</p>\n<p num=\"p-0010\">The foregoing has outlined rather broadly the features and technical advantages of the present invention in order that the detailed description of the invention that follows may be better understood. Additional features and advantages of the invention will be described hereinafter which form the subject of the claims of the invention.</p>\n<?BRFSUM description=\"Brief Summary\" end=\"tail\"?>\n<?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?>\n<description-of-drawings>\n<h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4>\n<p num=\"p-0011\">For a more complete understanding of the present invention, and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:</p>\n<p num=\"p-0012\"><figref idrefs=\"DRAWINGS\">FIG. 1</figref> is a high level functional block diagram of a representative data processing system suitable for practicing the principles of the present invention;</p>\n<p num=\"p-0013\"><figref idrefs=\"DRAWINGS\">FIG. 2A</figref> is a high level functional block diagram of selected operational blocks within CPU;</p>\n<p num=\"p-0014\"><figref idrefs=\"DRAWINGS\">FIG. 2B</figref> illustrates in further detail a portion of the selected operational blocks of <figref idrefs=\"DRAWINGS\">FIG. 2A</figref>,</p>\n<p num=\"p-0015\"><figref idrefs=\"DRAWINGS\">FIG. 3A</figref> is a high level functional block diagram of a branch prediction circuitry embodying the inventive principles;</p>\n<p num=\"p-0016\"><figref idrefs=\"DRAWINGS\">FIG. 3B</figref> illustrates in further detail a portion of the branch prediction circuitry of <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>;</p>\n<p num=\"p-0017\"><figref idrefs=\"DRAWINGS\">FIG. 4</figref> illustrates in partial schematic form another portion of the branch prediction circuitry of <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>;</p>\n<p num=\"p-0018\"><figref idrefs=\"DRAWINGS\">FIG. 5</figref> illustrates in flowchart form, a methodology for accessing the local and fetch-based branch history tables of <figref idrefs=\"DRAWINGS\">FIG. 3A</figref> in accordance with the principles of the present invention,</p>\n<p num=\"p-0019\"><figref idrefs=\"DRAWINGS\">FIG. 6</figref> (including partial views <figref idrefs=\"DRAWINGS\">FIG. 6A</figref> and <figref idrefs=\"DRAWINGS\">FIG. 6B</figref>) is a flow diagram illustrating a first method of updating the local and fetch-based branch history and selector tables of <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>; and</p>\n<p num=\"p-0020\"><figref idrefs=\"DRAWINGS\">FIG. 7</figref> (including partial views <figref idrefs=\"DRAWINGS\">FIG. 7A</figref> and <figref idrefs=\"DRAWINGS\">FIG. 7B</figref>) is a flow diagram illustrating a second method of updating the local and fetch-based branch history and selector tables of <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>.</p>\n<p num=\"p-0021\"><figref idrefs=\"DRAWINGS\">FIGS. 8A and 8B</figref> illustrate, in flowchart form, a methodology for generating a global history vector (GHV) in accordance with an embodiment of the present invention.</p>\n</description-of-drawings>\n<?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?>\n<?DETDESC description=\"Detailed Description\" end=\"lead\"?>\n<h4>DETAILED DESCRIPTION</h4>\n<p num=\"p-0022\">In the following description, numerous specific details are set forth to provide a thorough understanding of the present invention. It should be noted, however, that those skilled in the art are capable of practicing the present invention without such specific details. In other instances, well-known circuits have been shown in block diagram form in order not to obscure the present invention in unnecessary detail.</p>\n<p num=\"p-0023\">All such variations are intended to be included within the scope of the present invention. It will be recognized that, in the drawings, only those signal lines and processor blocks necessary for the operation of the present invention are shown.</p>\n<p num=\"p-0024\">Referring to the drawings, depicted elements are not necessarily shown to scale, and like or similar elements are designated by the same reference numeral through the several views.</p>\n<p num=\"p-0025\">Referring to <figref idrefs=\"DRAWINGS\">FIG. 1</figref> is a high level functional block diagram of a representative data processing system <b>100</b> suitable for practicing the principles of the present invention. Processing system <b>100</b>, includes a central processing system (CPU) <b>10</b> operating in conjunction with a system bus <b>12</b>. CPU <b>10</b> may be for example, a reduced instruction set computer (RISC), such as an IBM POWERPC\u2122 Processor, or a complex instruction set computer (CISC). System bus <b>12</b> operates in accordance with a standard bus protocol, such as the ISA protocol, compatible with CPU <b>10</b>.</p>\n<p num=\"p-0026\">CPU <b>10</b> operates in conjunction read-only memory (ROM) <b>16</b> and random access memory (RAM) <b>14</b>. Among other things, ROM <b>16</b> supports the basic input output system (BIOS). RAM <b>14</b> includes for example, DRAM (Dynamic Random Access Memory) system memory and SRAM (Static Random Access Memory) external cache.</p>\n<p num=\"p-0027\">I/O Adapter <b>18</b> allows for an interconnection between the devices on system bus <b>12</b> and external peripherals, such as mass storage devices (e.g., a hard drive, floppy drive or CD/ROM drive), or a printer. A peripheral device <b>20</b> is for example, coupled to a peripheral control interface (PCI) bus, and I/O adapter <b>18</b> therefore may be for example PCI bus bridge.</p>\n<p num=\"p-0028\">User interface adapter <b>22</b> couples various user input devices, such as keyboard <b>24</b>, mouse <b>26</b>, touchpad <b>32</b> or speaker <b>28</b> to the processing devices on bus <b>12</b>.</p>\n<p num=\"p-0029\">Display adapter <b>36</b> supports a display <b>38</b> which may be for example a cathode ray tube (CRT), liquid crystal display (LCD) or similar conventional display unit. Display adapter <b>36</b> may include among other things a conventional display controller and frame buffer memory.</p>\n<p num=\"p-0030\">System <b>100</b> can be selectively coupled to a computer or telecommunications network through communications adapter <b>34</b>. Communications adapter <b>34</b> may include for example, a modern for connection to a telecommunications network and/or hardware and software for connecting to a computer network such as a local area network (LAN) or wide area network (WAN).</p>\n<p num=\"p-0031\"><figref idrefs=\"DRAWINGS\">FIG. 2</figref> is a high level functional block diagram of selected operational blocks within CPU <b>10</b>. In the illustrated embodiment, CPU <b>10</b> includes internal instruction cache (I-cache) <b>40</b> and data cache (D-cache) <b>42</b> which are accessible through bus <b>12</b> and bus interface unit <b>44</b> and load/store unit <b>46</b>. In the depicted architecture, CPU <b>10</b> operates on data in response to instructions retrieved from I-cache <b>40</b> through instruction dispatch unit <b>48</b>. In response to dispatch instructions, data retrieved from D-cache <b>42</b> by load/store unit <b>46</b> can be operated upon using either fixed point execution unit <b>50</b> or floating point execution unit <b>52</b>. Instruction branching is controlled by branch/system processing unit <b>54</b>. Branch processing unit <b>54</b> includes a branch information queue (BIQ) <b>56</b>. BIQ <b>56</b> contains a plurality of entries <b>58</b>. An entry <b>58</b> is shown in <figref idrefs=\"DRAWINGS\">FIG. 2B</figref>, in which, entry <b>58</b> has a plurality of fields <b>58</b><i>a</i>\u2013<b>58</b><i>e</i>. Field <b>58</b><i>a </i>holds a branch instruction address, <b>58</b><i>b </i>contains a plurality of bits from a branch history table (BHT), field <b>58</b><i>c </i>holds a global history vector (GHV), field <b>58</b><i>d </i>incorporates a branch prediction value and field <b>58</b><i>e </i>contains a branch position value. Each of fields <b>58</b><i>a</i>\u2013<b>58</b><i>e </i>will be discussed further below, in conjunction with <figref idrefs=\"DRAWINGS\">FIGS. 3A\u20138B</figref>.</p>\n<p num=\"p-0032\"><figref idrefs=\"DRAWINGS\">FIG. 3A</figref> is a diagram illustrating a branch prediction apparatus <b>300</b> in accordance with a preferred embodiment of the present inventive concepts. Apparatus <b>300</b> may be incorporated in branch unit <b>54</b>, <figref idrefs=\"DRAWINGS\">FIG. 2</figref>. According to these concepts, three tables are used for branch prediction, namely, a local branch history table (LBHT) <b>301</b>, a fetch-based branch history table (GBHT) <b>302</b> and a selector table (GSEL) <b>303</b>. In the illustrated embodiment, each table <b>301</b>\u2013<b>303</b> is composed of a preselected number, n, of entries each of which includes a number, p, of 1-bit counters. For purposes of the present discussion, when a given one of the counters in the local or fetch-based branch history tables is set to a Logic <b>1</b>, that counter (entry) will be considered as being set to a taken branch prediction value. Consequently, in this configuration, a counter (entry) storing a Logic <b>0</b> will be considered as storing a branch not-taken-prediction bit. It should be noted however, that in alternate embodiments, the reverse logic may be used without deviating from the inventive concepts.</p>\n<p num=\"p-0033\">Local branch history table <b>301</b> is accessed for obtaining branch predictions using a pointer constituting n bits taken from the current cache line address, in instruction fetch address register (IFAR) <b>304</b> in a conventional fashion. The value of this pointer will be denoted \u201c1bht<sub>\u2014</sub>read<sub>\u2014</sub>addr.\u201d Fetch-based branch history table <b>302</b> is accessed for obtaining branch predictions in a fashion in which n number of bits taken from the current cache line address are bitwise XORed with n number of bits from GHV register <b>306</b>. The value of this pointer will be denoted \u201cgbht<sub>\u2014</sub>read<sub>\u2014</sub>addr.\u201d The process for accessing the history tables will be described in detail in conjunction with <figref idrefs=\"DRAWINGS\">FIG. 5</figref>.</p>\n<p num=\"p-0034\">In the preferred embodiment, the entries of GSEL <b>303</b> are accessed for obtaining predictions using the same pointer generated for the fetch-based branch history table, gbht<sub>\u2014</sub>read<sub>\u2014</sub>addr. The accessed entry from selector table <b>303</b> is then used by selection logic <b>308</b> to select either the local branch prediction values output from LBHT <b>301</b> or the fetch-based branch prediction value accessed from GBHT <b>302</b> for use as the final branch prediction value for determining if the branch is to be taken or not taken. Selection logic <b>308</b> may, in an embodiment of the present invention, be p multiplexers (MUXs), which output the p prediction values to prediction register <b>310</b>. Note that a number q of the prediction values may be from LBHT <b>301</b> and a remaining number p\u2013q may be from GBHT <b>302</b>. Up to p instructions are fetched from memory, including internal memory, such as I-cache <b>40</b>, <figref idrefs=\"DRAWINGS\">FIG. 2</figref>, in one cycle of CPU <b>10</b>. Thus, the number of predictions in an entry accommodates all of the instructions that are fetched in a single cycle, which may be referred to as a fetch group (FG). The numbers, p, of instructions in a fetch group may be eight in an embodiment of the present invention. In the illustrated embodiment, a Logic <b>0</b> accessed from selector table (GSEL) <b>303</b> selects the output from LBHT <b>301</b> while a Logic <b>1</b> selects the output from GBHT <b>302</b>. Generally, selector table <b>303</b> tracks the performance of the local and fetch-based branch history tables for a given branch instruction. The branch history table having the better prediction history for the given branch instruction is then used to perform the current branch prediction.</p>\n<p num=\"p-0035\">The GHV from which the gbht<sub>\u2014</sub>read<sub>\u2014</sub>addr is generated as described above tracks the history of branch instructions as they are fetched and executed. Thus, as branches are executed and resolved, the GHV is updated. GHV logic <b>311</b> updates the GHV and loads it into GHV register <b>306</b>. GHV logic <b>311</b> is described in detail in <figref idrefs=\"DRAWINGS\">FIG. 4</figref>.</p>\n<p num=\"p-0036\">Additionally, the entries in LBHT <b>301</b>, GBHT <b>302</b> and GSEL <b>303</b> must also be updated in response to the execution of branch instructions. The entries are updated by providing information to the appropriate entry in LBHT <b>301</b>, GBHT <b>302</b> and GSEL <b>303</b> for setting or resetting, as appropriate, the p one-bit counters in the corresponding entry, depending on the prediction and the resolution, or actual outcome, of the branch. The information sent to LBHT <b>301</b> may be referred to as \u201c1bht<sub>\u2014</sub>write<sub>\u2014</sub>data\u201d, the update information provided to GBHT <b>302</b> may be referred to as \u201cgbht<sub>\u2014</sub>write<sub>\u2014</sub>data\u201d, and the update information for GSEL <b>303</b> may be referred to \u201cgsel<sub>\u2014</sub>write<sub>\u2014</sub>data.\u201d The values of 1bht<sub>\u2014</sub>write<sub>\u2014</sub>data, gbht<sub>\u2014</sub>write<sub>\u2014</sub>data and gsel<sub>\u2014</sub>write<sub>\u2014</sub>data are generated by counter logic <b>312</b> and loaded, respectively, into LBHT write data register <b>314</b>, GBHT write data register <b>316</b> and GSEL write data register <b>318</b>. Counter logic <b>312</b> generates the values of 1bht<sub>\u2014</sub>write<sub>\u2014</sub>data, gbht<sub>\u2014</sub>write<sub>\u2014</sub>data and gsel<sub>\u2014</sub>write<sub>\u2014</sub>data in response to an actual branch direction determined when the corresponding branch instruction executes, and the predictions, from BIQ field <b>58</b><i>b </i>in the entry <b>57</b> corresponding to the resolved branch instruction. The methodology for generating the values of 1bht<sub>\u2014</sub>write<sub>\u2014</sub>data, gbht<sub>\u2014</sub>write<sub>\u2014</sub>data and gsel<sub>\u2014</sub>write<sub>\u2014</sub>data will be described in detail in conjunction with <figref idrefs=\"DRAWINGS\">FIG. 5</figref>.</p>\n<p num=\"p-0037\">The corresponding entry in the respective one of LBHT <b>301</b>, GBHT <b>302</b> and GSEL <b>303</b> is accessed using an address generated from the branch address, field <b>58</b><i>a</i>, in the corresponding entry <b>58</b> in BIQ <b>56</b>. The address into LBHT <b>301</b>, which may be referred to as \u201c1bht<sub>\u2014</sub>write<sub>\u2014</sub>addr,\u201d constitutes the m-bit branch address in field <b>58</b><i>a</i>. A number, n, of bits of 1bht<sub>\u2014</sub>write<sub>\u2014</sub>addr are used to select the LBHT entry and the remaining, m-n, bits index the counters in the selected entry. Thus, 2<sup>(m-n)</sup>=p. Note that the m-bit branch address may be a portion of the full address of a branch instruction. The address for accessing GBHT <b>302</b> and GSEL <b>303</b>, which may be referred to as \u201cgbht<sub>\u2014</sub>write<sub>\u2014</sub>addr,\u201d is generated by XORing n bits of the branch address from BIQ field <b>58</b><i>a </i>with the GHV value in BIQ field <b>58</b><i>c </i>corresponding to the branch instruction for which the history table entries are being updated. The resulting n bit value is concatenated with the remaining m-n bits of the branch address in field <b>58</b><i>a </i>to form the m-bit value of gbht<sub>\u2014</sub>write<sub>\u2014</sub>addr. The n-bit portion addresses the entry of the GBHT and the (m-n)-bit portion indexes the counters in the entry. In an embodiment of the present invention m\u2022may be fourteen and n may be eleven. The methodology for addressing LBHT <b>301</b>, GBHT <b>302</b> and GSEL <b>303</b>, and updating the entries therein will be further described in conjunction with <figref idrefs=\"DRAWINGS\">FIGS. 6 and 7</figref>.</p>\n<p num=\"p-0038\">Refer now to <figref idrefs=\"DRAWINGS\">FIG. 4</figref> illustrating GHV logic <b>311</b> in further detail. The current value of GHV, which is loaded into GHV register <b>306</b>, <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>, is provided from GHV0 logic <b>402</b>. GHV0 logic <b>402</b> may be a register having a two-way multiplexer input. A first input to the multiplexer portion is coupled to an output of multiplexer (MUX) <b>414</b>. Multiplexer <b>414</b> selects for outputting a GHV value from one of several paths that are rendered active in response to an event, cache miss, branch misprediction, pipeline hold, etc. that may modify the value of one GHV. Each of these paths and the operation of GHV logic <b>311</b> will be described in detail below.</p>\n<p num=\"p-0039\">Depending on the outcome of speculatively fetched instructions a prior state of the GHV may need to be recovered. That is, the GHV may need to be \u201cbacked up\u201d to a previous state. GHV1 logic <b>404</b> and GHV2 logic <b>406</b> operate to hold the GHV2 for one and two prior processor cycles, respectively. GHV1 logic <b>404</b> and GHV2 logic <b>406</b> may also be a register having a two-way multiplexer input. In each of GHV0 logic <b>402</b>, GHV1 logic <b>404</b> and GHV2 logic <b>406</b> the register output is fed back to an input of the multiplexer portion. A second input of GHV1 logic <b>404</b> is fed from the register output of GHV0 logic <b>402</b>. Similarly, a second input of the multiplexer portion of GHV1 logic <b>406</b> is coupled to the output of GHV1 logic <b>404</b>. In the embodiment of GHV logic <b>311</b> illustrated in <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, it is assumed that it takes two processor cycles to scan through a fetch group and determine if any branch in the fetch group has been predicted taken, and if so to determine the target address. It has also been assumed that it takes three cycles to determine if there is a cache miss. If there are more cycles to determine either a taken prediction, or a cache miss, additional GHVx logic stages denoted generically by GHVx, may be incorporated, as would be recognized by an artisan of ordinary skill in the art with taken-prediction path <b>408</b> and cache miss path <b>410</b> tapped off the corresponding GHV<sub>x </sub>logic stage.</p>\n<p num=\"p-0040\">As discussed above, the first input to GHV0 logic <b>402</b> is provided by an output MUX <b>414</b>. MUX <b>414</b> is a five-way multiplexer, the input of which provides a value of the GHV in accordance with each of a set of actions that may cause the GHV to be modified. MUX <b>414</b> selects for the signal on one of the five inputs in response to GHV select logic <b>416</b>. In an embodiment of the present invention GHV logic <b>311</b> may be provided with a two-phase clock signal (not shown in <figref idrefs=\"DRAWINGS\">FIG. 4</figref> for simplicity). Select logic <b>416</b> renders selects <b>409</b>, <b>411</b>, <b>413</b> active on a first predetermined phase of the two-phase clock and the register portions of GHV0 logic <b>402</b>, GHV1 logic <b>404</b> and GHV2 logic <b>406</b> latch data on a second predetermined phase of the two-phase clock. The logic states associated with each of the inputs, denoted cache miss path <b>408</b>, taken-prediction path <b>410</b>, hold path <b>412</b>, misprediction path <b>420</b> and advance path <b>426</b> will now be described. The operation of GHV logic <b>311</b> in rendering each of the inputs active will be described in detail in conjunction with <figref idrefs=\"DRAWINGS\">FIGS. 8A and 8B</figref> where each of the inputs corresponds to a sequence of steps (\u201cpaths\u201d) within the methodology of <figref idrefs=\"DRAWINGS\">FIGS. 8A and 8B</figref>.</p>\n<p num=\"p-0041\">Hold path <b>412</b> is active if the processor holds the instruction pipeline. Processors, such as CPU <b>11</b> in <figref idrefs=\"DRAWINGS\">FIG. 1</figref>, may hold a pipeline if, for example, an instruction issue queue in an execution unit is full. In response, GHV select logic <b>416</b> selects for outputting the signal on hold path <b>412</b>, which is provided by the output of GHV0 logic <b>402</b>. Likewise, GHV0 select <b>413</b> assumes the logic state for selecting the feedback input from the output of GHV0 logic <b>402</b>.</p>\n<p num=\"p-0042\">GHV select logic <b>416</b> selects taken-prediction path <b>410</b> as the active path if a branch in the fetch group is predicted taken. When taken-prediction path <b>410</b> is active, the value of the GHV output by GHV1 logic <b>404</b> is left shifted with the value \u201c1\u201d shifted into the least significant bit (LSB). GHV0 select <b>413</b> assumes a logic state selecting for the input to GHV0 logic <b>402</b> coupled to the output of MUX <b>414</b>. Similarly, GHV1 select <b>411</b> and GHV2 select <b>409</b> assume the logic states for selecting the inputs to the respective one of GHV1 logic <b>404</b> and GHV2 logic <b>406</b> coupled to the output of GHV logic <b>402</b> and the output of GHV1 logic <b>404</b>.</p>\n<p num=\"p-0043\">In the event of a cache miss, cache miss path <b>408</b> becomes active in response to GHV select logic <b>416</b>. GHV2 select <b>409</b> assumes the logic state for selecting the feedback input into GHV2 logic <b>406</b>, and each of GHV0 select <b>413</b> and GHV1 select <b>411</b> assume the logic state for selecting the input of GHV0 logic <b>402</b> coupled to MUX <b>414</b> and the input of GHV1 logic <b>404</b> coupled to the output of GHV logic <b>402</b>, respectively.</p>\n<p num=\"p-0044\">If, on resolution, a branch is mispredicted, misprediction path <b>420</b> becomes the active path for MUX <b>414</b>. Each of GHV0 select <b>413</b>, GHV1 select <b>411</b> and GHV2 select <b>409</b> assumes the logic state for selecting input coupling each of logic <b>402</b>, <b>404</b> and <b>406</b> to the output of its preceding one of MUX <b>414</b>, logic <b>402</b> and logic <b>404</b>, such that the value of the GHV on misprediction path <b>420</b> is loaded into the register portion of each of GHV0 logic <b>402</b>, GHV1 logic <b>404</b>, and GHV2 logic <b>406</b>.</p>\n<p num=\"p-0045\">The value of the GHV on misprediction path <b>420</b> depends on the resolution of the branch, and the position of the mispredicted branch instruction in the fetch group. Misprediction selection logic <b>422</b> selects for one of three inputs in three-way MUX <b>424</b>. If the actual outcome is resolved as not taken, and the resolved branch is not the last instruction in the fetch group, the value of the GHV in BIQ field <b>58</b><i>c</i>, <figref idrefs=\"DRAWINGS\">FIG. 3B</figref> is selected. If, however, the resolved branch is the last instruction in the corresponding fetch group, then the GHV from BIQ field <b>58</b><i>c </i>is left shifted with \u201c0\u201d entered in the LSB thereof. If the mispredicted branch was resolved as taken, MUX <b>424</b> selects for the value of the GHV in BIQ field <b>58</b><i>c </i>left shifted with \u201c1\u201d loaded in the LSB.</p>\n<p num=\"p-0046\">If there is no instruction fetch redirection from one or more branch instructions in the fetch group, or a cache miss, or from an instruction pipeline hold, then the instruction pipeline can advance to the next sequential address from the last instruction in the current fetch group. Advance path <b>426</b> is then active, and the current GHV is left shifted with \u201c0\u201d loaded in the LSB. GHV1 select <b>411</b> selects for the input in GHV1 logic <b>404</b> coupled to the output of GHV logic <b>402</b> and GHV2 select <b>409</b> selects for the input in GHV2 logic <b>406</b> coupled to the output of GHV1 logic <b>404</b>. Likewise, GHV0 select <b>413</b> selects for the output of MUX <b>414</b>.</p>\n<p num=\"p-0047\">The methodologies for generating branch predictions and updating the branch history tables and updating the GHV in accordance with the principles of the present invention may now be described. These methodologies may be executed by the branch prediction circuitry <b>300</b> in <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>. Refer now to <figref idrefs=\"DRAWINGS\">FIG. 5</figref>, illustrating methodology <b>500</b> for generating branch predictions and storing branch information in the BIQ. In step <b>502</b>, the entry in the LBHT pointed to by the value in the IFAR is read. The addressing of entries in LBHT via the IFAR has been discussed hereinabove in conjunction with <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>. In step <b>504</b>, the GBHT and GSEL entries pointed to by the gbht<sub>\u2014</sub>read<sub>\u2014</sub>addr, as also described hereinabove in conjunction with <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>, is read. In step <b>506</b>, the LBHT data is selected in response to the value in the corresponding entry in GSEL <b>303</b>. The branch history table data, either the LBHT data or the GBHT data, may be selected via MUX <b>308</b> in response to the GSEL data. For example, as described above, in an embodiment of the present invention, a Logic <b>0</b> in the corresponding entry in GSEL <b>303</b> selects the output from LBHT <b>301</b> and a Logic <b>1</b> selects the output from GBHT <b>302</b>. In an embodiment of the present invention in accordance with apparatus <b>300</b> of <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>, the LBHT data, the GBHT data, and the GSEL data may be held in respective data registers, for example, LBHT data register <b>320</b>, GBHT data register <b>322</b>, and GSEL data register <b>324</b>. The selected data is stored in a prediction register, such as prediction register <b>310</b>, in step <b>508</b>.</p>\n<p num=\"p-0048\">If, in step <b>510</b>, it is determined that the fetch group contains an unconditional branch, or in response to the predictions in step <b>508</b>, a conditional branch is predicted taken, then in step <b>512</b> a taken-prediction fetch redirection is generated. This redirection may signal GHV select logic <b>416</b>, <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, to select taken-prediction path <b>410</b> as the active path. Then, in step <b>514</b>, for each branch in the fetch group, a BIQ entry is allocated and the branch information is stored in the corresponding fields, such as fields <b>58</b><i>a</i>\u2013<b>58</b><i>e </i>of entry <b>58</b>, <figref idrefs=\"DRAWINGS\">FIG. 2B</figref>.</p>\n<p num=\"p-0049\">Referring now to <figref idrefs=\"DRAWINGS\">FIG. 6</figref>, there is illustrated therein methodology <b>600</b> for writing to the branch history table entries in accordance with an embodiment of the present invention. In step <b>602</b>, it is determined if the branch instruction has been resolved in a current processor cycle. If not, methodology <b>600</b> waits one cycle, in step <b>604</b>. Otherwise, if a branch has been resolved, in step <b>606</b> the branch information is obtained from the corresponding BIQ entry. In step <b>608</b>, the value of 1bht<sub>\u2014</sub>write<sub>\u2014</sub>addr is set to m bits of the branch address from the BIQ, for example from BIQ field <b>58</b><i>a</i>, in a BIQ entry in accordance with entry <b>58</b> of <figref idrefs=\"DRAWINGS\">FIG. 2B</figref>. Similarly, in step <b>610</b>, the value of gbht<sub>\u2014</sub>write<sub>\u2014</sub>addr is set to the XOR of n bits of the branch address and the value of the n-bit GHV from the BIQ entry, for example from field <b>58</b><i>c </i>of BIQ entry <b>58</b> in <figref idrefs=\"DRAWINGS\">FIG. 2B</figref>. The remaining portion of gbht<sub>\u2014</sub>write<sub>\u2014</sub>addr constituting the remaining m-n bits of the m-bit branch address from the corresponding BIQ entry field, as previously described hereinabove in conjunction with <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>, is set in step <b>612</b>. Recall that in an embodiment of the present invention, m may be fourteen and n may be eleven.</p>\n<p num=\"p-0050\">In step <b>616</b>, it is determined if the branch prediction is the actual outcome. If not, in step <b>618</b> a branch misprediction redirect is generated. In response thereto, in an embodiment of the present invention in accordance with apparatus <b>300</b> in <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>, GHV select logic <b>416</b>, <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, and GHV logic <b>311</b> may select misprediction path <b>420</b> as the active path. Additionally, in step <b>618</b> a branch misprediction signal provided to misprediction selection logic <b>422</b>, <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, is asserted. If, however, in step <b>616</b> the prediction and actual outcome are the same, step <b>618</b> is bypassed.</p>\n<p num=\"p-0051\">In step <b>620</b>, it is determined if the prediction from the LBHT is correct, and the prediction from the GBHT incorrect. If so, in step <b>622</b>, the value of gsel<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c0.\u201d Otherwise, in step <b>620</b>, the \u201cNo\u201d branch is followed and in step <b>624</b> it is determined if the GBHT is correct and the LBHT prediction incorrect. If so, in step <b>626</b>, the value of gsel<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c1. \u201d In an embodiment of the present invention, in accordance with methodology <b>600</b> in which, in step <b>622</b> the value of gsel<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c0\u201d and the value, in step <b>626</b>, of gsel<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c1,\u201d MUXs <b>308</b> select data from LBHT data register <b>320</b> in response to a logic state of \u201c0\u201d and select for data from GBHT data register <b>322</b> in response to a logic state of \u201c1.\u201d However, an artisan of ordinary skill in the art would recognize that a complementary embodiment MUXs <b>308</b> may be used in which embodiment a value of \u201c1\u201d would be written in step <b>622</b>, and a value of \u201c0\u201d would be written in step <b>626</b> of methodology <b>600</b>. It would be further understood by an artisan of ordinary skill in the art that such an alternative embodiment would be in the spirit and scope of the present invention.</p>\n<p num=\"p-0052\">After setting the value of gsel<sub>\u2014</sub>write<sub>\u2014</sub>data in either step <b>622</b> or <b>626</b>, the value of gsel<sub>\u2014</sub>write<sub>\u2014</sub>data is written to the entry in GSEL <b>303</b> pointed to by the value of gbht<sub>\u2014</sub>write<sub>\u2014</sub>addr, step <b>628</b>. If, however, in step <b>624</b>, the GBHT prediction is incorrect or the LBHT prediction is correct, that is, the LBHT and GBHT predictions were both correct or both incorrect, wherein step <b>620</b> takes the \u201cNo\u201d branch, steps <b>622</b>, <b>626</b> and <b>628</b> are bypassed, and the corresponding entry in GSEL <b>303</b> is unchanged.</p>\n<p num=\"p-0053\">Next, the entries in the LBHT and GBHT are updated. In step <b>630</b>, it is determined if the branch resolved as taken. If not, 1bht<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c0\u201d and written to the LBHT at the entry pointed to by 1bht<sub>\u2014</sub>write<sub>\u2014</sub>addr, step <b>632</b>. Similarly, the value of gbht<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c0\u201d and written to the GBHT entry pointed to by gbht<sub>\u2014</sub>write<sub>\u2014</sub>addr, step <b>634</b>. Methodology <b>600</b> then returns to step <b>602</b>. If, however, in step <b>630</b>, if the branch was resolved as taken, then, in step <b>636</b>, the value of 1bht<sub>\u2014</sub>data is set to \u201c1\u201d, and written to the LBHT at the address pointed to by 1bht<sub>\u2014</sub>write addr. Likewise, in step <b>638</b>, the value of gbht<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c1\u201d and written to the GBHT at the entry pointed to by gbht<sub>\u2014</sub>write<sub>\u2014</sub>addr; and methodology <b>600</b> returns to step <b>602</b>. It would be understood by an artisan of ordinary skill that a complementary embodiment of the present invention may be implemented in which complementary values of 1bht<sub>\u2014</sub>write<sub>\u2014</sub>data are used in steps <b>632</b>, <b>634</b> and <b>636</b>, <b>638</b>, respectively, and such an embodiment would be within the spirit and scope of the present invention.</p>\n<p num=\"p-0054\">Refer now to <figref idrefs=\"DRAWINGS\">FIG. 7</figref> illustrating methodology <b>700</b> for updating the branch history table entries in accordance with an alternative embodiment of the present invention. In step <b>702</b>, it is determined if the branch instruction has been resolved in the current processor cycle. If not, methodology <b>700</b> waits one cycle, in step <b>704</b>. Otherwise, if a branch has been resolved, in step <b>706</b> the branch information is obtained from the corresponding BIQ entry. In step <b>708</b>, the value of 1bht<sub>\u2014</sub>write<sub>\u2014</sub>addr is set to m bits of the branch address from the BIQ, for example from BIQ field <b>58</b><i>a</i>, in a BIQ entry in accordance with entry <b>58</b> of <figref idrefs=\"DRAWINGS\">FIG. 2B</figref>. Similarly, in step <b>710</b>, the value of gbht<sub>\u2014</sub>write<sub>\u2014</sub>addr is set to the XOR of n bits of the branch address and the value of the n-bit GHV from the BIQ entry for example from field <b>58</b><i>c </i>of BIQ entry <b>58</b> in <figref idrefs=\"DRAWINGS\">FIG. 2B</figref>. The remaining portion of gbht<sub>\u2014</sub>write<sub>\u2014</sub>addr constituting the remaining m-n bits of the m-bit branch address from the corresponding BIQ entry field, as previously described hereinabove in conjunction with <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>, is set in step <b>712</b>. Recall that in an embodiment of the present invention, m may be fourteen and n may be eleven.</p>\n<p num=\"p-0055\">In step <b>716</b>, it is determined if the branch prediction is the actual outcome. If not, in step <b>718</b> a branch misprediction redirect is generated. In response, in an embodiment of the present invention in accordance with mechanism <b>300</b> in <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>, GHV select logic <b>416</b>, <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, and GHV logic <b>311</b> may select misprediction path <b>420</b> as the active path. Additionally, in step <b>718</b> a branch misprediction signal provided misprediction selection logic <b>422</b>, <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, is asserted. If, however, in step <b>716</b> the prediction and actual outcome are the same, step <b>718</b> is bypassed.</p>\n<p num=\"p-0056\">In step <b>720</b>, it is determined if the prediction from the LBHT prediction is correct. If so, in step <b>722</b>, the value of gsel<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c0.\u201d Otherwise, in step <b>720</b>, the \u201cNo\u201d branch is followed and in step <b>724</b> it is determined if the GBHT prediction is correct. If so, in step <b>726</b>, the value of gsel<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c1.\u201d In an embodiment of the present invention, in accordance with methodology <b>700</b> in which, in step <b>722</b> the value of gsel<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c0\u201d and the value, in step <b>726</b>, of gsel<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c1,\u201d MUXs <b>308</b> select data from LBHT data register <b>320</b> in response to a logic state of \u201c0\u201d and select for data from GBHT data register <b>322</b> in response to a logic state of \u201c1. \u201d However, an artisan of ordinary skill in the art would recognize that a complementary embodiment MUXs <b>308</b> may be used in which embodiment a value of \u201c1\u201d would be written in step <b>722</b>, and a value of \u201c0\u201d would be written in step <b>726</b> of methodology <b>700</b>. It would be further understood by an artisan of ordinary skill in the art that such an alternative embodiment would be in the spirit and scope of the present invention. After setting the value of gsel<sub>\u2014</sub>write<sub>\u2014</sub>data in either step <b>722</b> or <b>726</b>, the value of gsel<sub>\u2014</sub>write<sub>\u2014</sub>data is written to the entry in GSEL <b>303</b> pointed to by the value of gbht<sub>\u2014</sub>write<sub>\u2014</sub>addr, step <b>728</b>. If, however, in step <b>724</b>, the GBHT prediction is incorrect or the LBHT prediction is correct, that is, both the LBHT and GBHT predictions were incorrect by virtue of step <b>720</b>, the corresponding entry in GSEL <b>303</b> is unchanged, and step <b>722</b>, <b>726</b> and <b>728</b> are bypassed.</p>\n<p num=\"p-0057\">Next, the entries in the LBHT and GBHT are updated. In step <b>730</b>, it is determined if the branch resolved as taken. If not, 1bht<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c0\u201d and written to the LBHT at the entry pointed to by 1bht<sub>\u2014</sub>write<sub>\u2014</sub>addr, step <b>732</b>. Similarly, the value of gbht write<sub>\u2014</sub>data is set to \u201c0\u201d and written to the GBHT entry pointed to by gbht<sub>\u2014</sub>write<sub>\u2014</sub>addr, step <b>734</b>. Methodology <b>700</b> then returns to step <b>702</b>. If, however, in step <b>730</b>, if the branch was resolved as taken, then, in step <b>736</b>, the value of 1bht<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c1\u201d and written to the LBHT at the address pointed to by 1bht<sub>\u2014</sub>write<sub>\u2014</sub>addr. Likewise, in step <b>738</b>, the value of gbht<sub>\u2014</sub>write<sub>\u2014</sub>data is set to \u201c1\u201d and written to the GBHT at the entry pointed to by gbht<sub>\u2014</sub>write<sub>\u2014</sub>addr, and methodology <b>700</b> returns to step <b>702</b>. Recall, however, as discussed in conjunction with <figref idrefs=\"DRAWINGS\">FIG. 6</figref>, complementary values of 1bht<sub>\u2014</sub>write<sub>\u2014</sub>data and gbht<sub>\u2014</sub>write<sub>\u2014</sub>data may be used in steps <b>732</b>, <b>736</b>, and <b>734</b> and <b>738</b>, respectively.</p>\n<p num=\"p-0058\">Additional alternative embodiments of methodology <b>600</b> may be implemented in which one GSEL, such as GSEL <b>303</b>, <figref idrefs=\"DRAWINGS\">FIG. 3A</figref>, may be updated when both the LBHT and GBHT are correct or when neither is correct. These alternative embodiments are summarized in Table 1, wherein case 1 and case 2 correspond to steps <b>620</b>\u2013<b>628</b> and steps <b>720</b>\u2013<b>728</b> in <figref idrefs=\"DRAWINGS\">FIGS. 6 and 7</figref>, respectively. An artisan of ordinary skill would understand the adaptations of steps <b>620</b>\u2013<b>628</b> or, alternatively, steps <b>720</b>\u2013<b>728</b> to implement the alternative embodiments in cases 3\u20139, Table 1, and would recognize that these alternative embodiments are within the spirit and scope of the present invention.</p>\n<p num=\"p-0059\">\n<tables id=\"TABLE-US-00001\" num=\"00001\">\n<table colsep=\"0\" frame=\"none\" rowsep=\"0\">\n<tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\">\n<colspec align=\"center\" colname=\"1\" colwidth=\"84pt\"></colspec>\n<colspec align=\"left\" colname=\"2\" colwidth=\"77pt\"></colspec>\n<colspec align=\"left\" colname=\"3\" colwidth=\"56pt\"></colspec>\n<thead>\n<row>\n<entry nameend=\"3\" namest=\"1\" rowsep=\"1\">TABLE 1</entry>\n</row>\n<row>\n<entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry>\n</row>\n<row>\n<entry>LBHT prediction correct</entry>\n<entry>GBHT prediction correct</entry>\n<entry>GSEL update</entry>\n</row>\n<row>\n<entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry>\n</row>\n</thead>\n<tbody valign=\"top\">\n<row>\n<entry></entry>\n</row>\n</tbody>\n</tgroup>\n<tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\">\n<colspec align=\"center\" colname=\"1\" colwidth=\"28pt\"></colspec>\n<colspec align=\"left\" colname=\"2\" colwidth=\"56pt\"></colspec>\n<colspec align=\"left\" colname=\"3\" colwidth=\"77pt\"></colspec>\n<colspec align=\"left\" colname=\"4\" colwidth=\"56pt\"></colspec>\n<tbody valign=\"top\">\n<row>\n<entry>1.</entry>\n<entry>Yes</entry>\n<entry>Yes</entry>\n<entry>No change</entry>\n</row>\n<row>\n<entry></entry>\n<entry>No</entry>\n<entry>No</entry>\n<entry>No change</entry>\n</row>\n<row>\n<entry>2.</entry>\n<entry>Yes</entry>\n<entry>Yes</entry>\n<entry>write 0</entry>\n</row>\n<row>\n<entry></entry>\n<entry>No</entry>\n<entry>No</entry>\n<entry>No change</entry>\n</row>\n<row>\n<entry>3.</entry>\n<entry>Yes</entry>\n<entry>Yes</entry>\n<entry>No change</entry>\n</row>\n<row>\n<entry></entry>\n<entry>No</entry>\n<entry>No</entry>\n<entry>write 0</entry>\n</row>\n<row>\n<entry>4.</entry>\n<entry>Yes</entry>\n<entry>Yes</entry>\n<entry>No change</entry>\n</row>\n<row>\n<entry></entry>\n<entry>No</entry>\n<entry>No</entry>\n<entry>write 1</entry>\n</row>\n<row>\n<entry>5.</entry>\n<entry>Yes</entry>\n<entry>Yes</entry>\n<entry>write 0</entry>\n</row>\n<row>\n<entry></entry>\n<entry>No</entry>\n<entry>No</entry>\n<entry>write 0</entry>\n</row>\n<row>\n<entry>6.</entry>\n<entry>Yes</entry>\n<entry>Yes</entry>\n<entry>write 0</entry>\n</row>\n<row>\n<entry></entry>\n<entry>No</entry>\n<entry>No</entry>\n<entry>write 1</entry>\n</row>\n<row>\n<entry>7.</entry>\n<entry>Yes</entry>\n<entry>Yes</entry>\n<entry>write 1</entry>\n</row>\n<row>\n<entry></entry>\n<entry>No</entry>\n<entry>No</entry>\n<entry>No change</entry>\n</row>\n<row>\n<entry>8.</entry>\n<entry>Yes</entry>\n<entry>Yes</entry>\n<entry>write 1</entry>\n</row>\n<row>\n<entry></entry>\n<entry>No</entry>\n<entry>No</entry>\n<entry>write 0</entry>\n</row>\n<row>\n<entry>9.</entry>\n<entry>Yes</entry>\n<entry>Yes</entry>\n<entry>write 1</entry>\n</row>\n<row>\n<entry></entry>\n<entry>No</entry>\n<entry>No</entry>\n<entry>write 1</entry>\n</row>\n<row>\n<entry align=\"center\" nameend=\"4\" namest=\"1\" rowsep=\"1\"></entry>\n</row>\n</tbody>\n</tgroup>\n</table>\n</tables>\n</p>\n<p num=\"p-0060\">The values of the GHV may be updated in accordance with methodology <b>800</b>, illustrated in <figref idrefs=\"DRAWINGS\">FIGS. 8A and 8B</figref>. In step <b>802</b>, the IFAR is set to the address of the current instruction, and in step <b>804</b> the next group of instructions is fetched.</p>\n<p num=\"p-0061\">It is then determined, in step <b>806</b>, whether an instruction fetch redirection has been generated. An instruction fetch redirection may be generated by the processor asserting a pipeline hold, as previously discussed hereinabove in conjunction with <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, or a cache miss. Additionally, a branch misprediction may generate an instruction fetch redirection as, for example, in step <b>618</b> of methodology <b>600</b> in <figref idrefs=\"DRAWINGS\">FIG. 6</figref>.</p>\n<p num=\"p-0062\">If, in step <b>806</b>, an instruction fetch redirection has not occurred, the IFAR is set to the next sequential instruction, step <b>808</b>, and in step <b>810</b> the value in the register portion of GHV1 logic <b>402</b>, <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, denoted GHV1, is copied to the register portion of GHV2 logic <b>406</b> and the value, denoted GHV0, in the register portion of GHV0 logic <b>402</b> is loaded in the register portion of GHV0 logic <b>404</b> to become a new value of GHV1. Additionally, the value of GHV0 in the register portion of GHV0 logic <b>402</b> is left-shifted and the value \u201c0\u201d loaded in the LSB thereof, and latched into the register portion of GHV0 logic <b>402</b>. In an embodiment of the present invention, with GHV logic <b>311</b> in accordance with <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, step <b>810</b> may be performed using GHV select logic <b>416</b>, whereby step <b>810</b> effects advanced path <b>426</b>. Methodology <b>800</b> then returns to step <b>804</b>.</p>\n<p num=\"p-0063\">If, however, in step <b>806</b>, an instruction fetch redirection has been received, it is determined if the redirection is a branch-taken prediction. In an embodiment of the present invention in accordance with methodology <b>500</b>, <figref idrefs=\"DRAWINGS\">FIG. 5</figref>, the branch-taken fetch redirection may be generated as described in step <b>512</b>, <figref idrefs=\"DRAWINGS\">FIG. 5</figref>. If, in step <b>812</b> the fetch redirection is a taken prediction, a \u201c1 \u201d is left-shifted into the value obtained from the register portion of GHV1 logic <b>404</b>, denoted GHV1, and copied into the register portions of GHV0 logic <b>402</b>, GHV1 logic <b>404</b> and GHV2 logic <b>406</b>. In an embodiment of the present invention in accordance with the GHV logic <b>311</b> of <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, step <b>814</b> may be effected by GHV select logic <b>416</b> rendering taken-prediction path <b>410</b> active. Also in step <b>814</b>, the IFAR is set to the branch target address of the branch predicted taken. Methodology <b>800</b> then returns to step <b>804</b>.</p>\n<p num=\"p-0064\">If, however, in step <b>812</b>, a taken-prediction redirection has not been effected, in step <b>816</b>, it is determined if a cache miss has occurred. If so, in step <b>818</b>, the value, in the register portion of GHV2 logic <b>406</b>, denoted GHV2, is loaded into the register portions of GHV0 logic <b>402</b> and GHV1 logic <b>404</b>. In an embodiment of the present invention in accordance with the GHV logic of <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, step <b>820</b> may be performed by GHV select logic <b>416</b> effecting cache miss path <b>408</b> via MUX <b>414</b>, and GHV0 select <b>413</b> selecting for the input of GHV logic <b>402</b> coupled to the output of MUX <b>414</b>, GHV1 select <b>411</b> selecting for the input of GHV1 logic <b>404</b> coupled to the output of GHV0 logic <b>402</b> and GHV2 select <b>409</b> selecting for the feedback input of GHV2 logic <b>406</b>. Then, in step <b>820</b>, the IFAR is backed up by three fetch cycles. That is, a state of the IFAR is returned to the state of the IFAR three fetch cycles earlier than the current cycle. It is assumed, in the embodiment of the present invention in accordance with methodology <b>800</b>, that it takes three fetch cycles to detect a cache miss. In a processor in which detection of a cache miss takes more than three cycles, then, in step <b>820</b>, the IFAR will be backed up by the corresponding number of cycles. Additionally, additional stages of GHVx logic would be incorporated in GHV logic <b>310</b>. <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, as discussed hereinabove. After the IFAR is backed up in step <b>820</b>, methodology <b>800</b> loops until the instructions return from a lower level of a memory hierarchy or a fetch redirection is received, step <b>821</b>. Thereafter, methodology continues to step <b>804</b>.</p>\n<p num=\"p-0065\">If, however, in step <b>816</b> the instruction fetch redirection is not a cache miss, it is determined in step <b>822</b>, if the redirection is a pipeline hold. If so, in step <b>824</b>, the values of GHV0 in the register portion of GHV0 logic <b>402</b>, GHV1 in the register portion of GHV1 logic <b>404</b>, and GHV2 in the register portion of GHV2 logic <b>406</b> are held. In the embodiment of GHV logic <b>310</b> of <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, GHV select logic <b>416</b> effects the hold path <b>412</b> in performing step <b>824</b>. Methodology <b>800</b> then returns to step <b>806</b>.</p>\n<p num=\"p-0066\">If, in step <b>822</b>, the redirection is not a pipeline hold, then the instruction fetch redirection, determined in step <b>806</b> is a branch misprediction, and methodology <b>800</b> proceeds to step <b>828</b>, <figref idrefs=\"DRAWINGS\">FIG. 5B</figref>. In step <b>828</b>, the branch information from the BIQ entry for the mispredicted branch is obtained. In step <b>830</b>, it is determined if the branch resolved as taken. If not, in step <b>832</b>, it is then determined if the position of the mispredicted branch in the fetch group is at the end of the fetch group. If not, in step <b>834</b>, the value of the GHV obtained from the BIQ in step <b>828</b> is loaded into the register portions of GHV0 logic <b>402</b>, GHV1 logic <b>404</b>, and GHV2 logic <b>406</b> as the value of, respectively, GHV0, GHV1, and GHV2. In an embodiment of GHV logic <b>310</b> in accordance with <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, step <b>834</b> may be performed by misprediction selection logic <b>422</b> selecting for input <b>426</b> of MUX <b>424</b>, in response to a branch outcome signal and branch position signal. The branch position signal may be received from BXU field <b>58</b><i>e</i>, <figref idrefs=\"DRAWINGS\">FIG. 3B</figref> in accordance with the branch entry <b>58</b> illustrated therein. The branch outcome signal may be received from BXU <b>53</b> in branch processing unit <b>54</b>, <figref idrefs=\"DRAWINGS\">FIG. 2A</figref>. The branch outcome signal may have a first predetermined value indicating that the branch resolved as taken and a second predetermined value indicating that the branch resolved as not taken. Also, in response to the misprediction, GHV select logic <b>416</b> selects for misprediction path <b>420</b> and GHV0 select <b>413</b>, GHV1 select <b>411</b> and GHV2 select <b>409</b> select for the respective inputs of GHV0 logic <b>402</b>, GHV1 logic <b>404</b> and GHV2 logic <b>406</b> coupled to the corresponding one of the output of MUX <b>414</b> and the outputs of GHV0 logic <b>402</b> and GHV1 logic <b>404</b>.</p>\n<p num=\"p-0067\">Additionally in step <b>834</b>, the IFAR is set to the next sequential address of the branch address received in step <b>828</b>.</p>\n<p num=\"p-0068\">In step <b>836</b>, all instructions after the mispredicted branch are discarded, and in step <b>838</b> the branch history tables are updated. Branch history tables may be updated, in step <b>838</b> in accordance with methodology <b>600</b>, <figref idrefs=\"DRAWINGS\">FIG. 6</figref>, or, in an alternative embodiment of the present invention, methodology <b>700</b>, <figref idrefs=\"DRAWINGS\">FIG. 7</figref>. Methodology <b>800</b> then returns to step <b>804</b>, <figref idrefs=\"DRAWINGS\">FIG. 8A</figref>.</p>\n<p num=\"p-0069\">Returning now to step <b>832</b>, if the mispredicted branch is at the end of the fetch group then, step <b>832</b> proceeds by the \u201cYes\u201d branch to step <b>840</b>. In step <b>840</b>, a \u201c0\u201d is left-shifted into the GHV received from the BIQ in step <b>828</b> and the result loaded into GHV0, GHV1, and GHV2. Step <b>840</b> may be performed in the embodiment of GHV logic <b>310</b> of <figref idrefs=\"DRAWINGS\">FIG. 4</figref> by misprediction selection logic <b>422</b> selecting for input <b>430</b> in MUX <b>424</b>. Additionally, GHV select logic <b>416</b> selects from its prediction path <b>420</b>, as previously described. Additionally, in step <b>840</b>, the IFAR is set to the next sequential address of the branch address as received in step <b>828</b>. Methodology <b>800</b> then proceeds to step <b>836</b>, previously discussed.</p>\n<p num=\"p-0070\">Returning to step <b>830</b>, if the mispredicted branch resolved taken, step <b>830</b> proceeds by the \u201cYes\u201d branch to step <b>842</b>. In step <b>842</b>, a \u201c1\u201d is left-shifted into the GHV received from the BIQ in step <b>828</b>, and the results loaded into GHV0, GHV1, and GHV2. Step <b>842</b> may be performed, in the embodiment of GHV logic <b>310</b> of <figref idrefs=\"DRAWINGS\">FIG. 4</figref> by misprediction selection logic <b>422</b> selecting for input <b>428</b> of MUX <b>434</b>. Additionally, GHV select logic <b>416</b> selects from misprediction path <b>420</b> as previously discussed. Also, in step <b>842</b>, the IFAR is set to the branch target address of the mispredicted branch instruction. Methodology <b>800</b> then proceeds to step <b>836</b> as previously described.</p>\n<p num=\"p-0071\">In this way, branch prediction based on a prediction history is implemented having a constant amount of processing. According to the principles of the present invention, one bit is shifted into the global history vector for each fetch group. The loading of a bit, \u201cone\u201d or a \u201czero,\u201d in the global history vector essentially captures the path the program has taken to reach the branch instruction being predicted, and thereby provides an indication of how the branch will behave (taken or not-taken).</p>\n<p num=\"p-0072\">The following example illustrates the branch prediction mechanism in accordance with the present invention. Consider a sequence of instructions, which may be written in PowerPC\u2122 assembly language as:</p>\n<p num=\"p-0073\"><tables id=\"TABLE-US-00002\" num=\"00002\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"char\" colname=\"1\" colwidth=\"28pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"21pt\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"21pt\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"56pt\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"91pt\"></colspec><thead><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry>(1)</entry><entry>LB00</entry><entry>addic</entry><entry>G0, G2, 0</entry><entry></entry></row><row><entry>(2)</entry><entry>LB01</entry><entry>cmp</entry><entry>00, 0, G0, G1</entry></row><row><entry>(3)</entry><entry></entry><entry>bc</entry><entry>0C, 02, &lt;LB00&gt;</entry><entry>/* Direction toggles;</entry></row><row><entry></entry><entry></entry><entry></entry><entry></entry><entry>executes 63 times; */</entry></row><row><entry>(4)</entry><entry></entry><entry>nop</entry><entry></entry><entry>/* Mispredicts first 5</entry></row><row><entry></entry><entry></entry><entry></entry><entry></entry><entry>times only */</entry></row><row><entry>(5)</entry><entry></entry><entry>nop</entry></row><row><entry>(6)</entry><entry></entry><entry>nop</entry></row><row><entry>(7)</entry><entry></entry><entry>nop</entry></row><row><entry>(8)</entry><entry></entry><entry>nop</entry></row><row><entry>(9)</entry><entry></entry><entry>addic</entry><entry>G0, G1, 0</entry></row><row><entry>(10)</entry><entry></entry><entry>add</entry><entry>G4, G4, G1</entry></row><row><entry>(11)</entry><entry></entry><entry>cmp</entry><entry>00, 0, G4, G5</entry></row><row><entry>(12)</entry><entry></entry><entry>bc</entry><entry>04, 02, &lt;LB01&gt;</entry><entry>/* Loops 32 times;</entry></row><row><entry></entry><entry></entry><entry></entry><entry></entry><entry>mispredicts twice */</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables><br/>\n(PowerPC\u2122 is a trademark of International Business Machines Corp.) Although the code snippet above is written in PowerPC\u2122 assembly, it would be understood by an artisan of ordinary skill in the art that the invention is not limited to the PowerPC\u2122 processor, and, in particular, a similar sequence of operations could be written in an assembly language corresponding to other microprocessor systems. In the above, G<b>0</b>, G<b>1</b>, G<b>2</b>, G<b>4</b>, and G<b>5</b> correspond to five general purpose registers. These are initialized with the exemplary values 0, 1, 2, 0, and 32, respectively. The operations performed by the above example include two branches, the instructions having the mnemonic \u201cbc\u201d. The \u201cnop\u201d (no operation) instructions are introduced to pad out a fetch group corresponding to an embodiment of the present invention in which a fetch group includes eight instructions. If the first branch is not taken, then the next instruction executed is in second fetch group which starts with the ninth instruction above, that is, the second \u201caddic\u201d instruction.\n</p>\n<p num=\"p-0074\">The first instruction moves the value in the register G<b>2</b> into the register G<b>0</b>. The second instruction, denoted by the mnemonic \u201ccmp\u201d compares the value in the register G<b>0</b> with the value in the register G<b>1</b>. In response to the comparison of the contents of the register operands, the \u201ccmp\u201d instruction sets a bit in a selected field, in this case, field 0, in a condition register. If the content of register G<b>0</b> is larger than the content of register G<b>1</b>, a first one of the plurality of bits in the selected field is set. If the contents are equal, a second one of the plurality of bits is set, and if the contents of register G<b>1</b> exceed the contents of register G<b>0</b>, a third one of the plurality of bits in the selected field of the condition register is set. Instruction (<b>3</b>), the first branch, acts in response to the second bit in the selected field of the condition register. If the second bit is set, the branch is taken, otherwise, the branch is not taken and the sequential path is followed. In the above, the first branch instruction toggles, that is, changes direction each time it executes, making prediction difficult.</p>\n<p num=\"p-0075\">Thus, the first time the first branch instruction, the third instruction above, executes, the value in register G<b>1</b> is 1, the initial value, and the value in register G<b>0</b> is two from the previous \u201caddic\u201d instruction, instruction (<b>1</b>). Thus, the \u201ccmp\u201d instruction sets the first bit in the selected field, and instruction (<b>3</b>), the first branch instruction, is not taken, and the sequential path is followed, fetching the next fetch group, which begins with instruction (<b>9</b>), the second \u201caddic\u201d instruction.</p>\n<p num=\"p-0076\">Instructions (<b>9</b>)\u2013(<b>11</b>) constitute a counter that counts up to the value of the contents of register G<b>5</b>, and the second branch, instruction (<b>12</b>), branches to instruction (<b>2</b>) with label \u201cLB01\u201d. On returning to instruction (<b>2</b>), the contents of registers G<b>0</b> and G<b>1</b> are equal by virtue of the second \u201caddic\u201d instruction, instruction (<b>9</b>), which moves the contents of G<b>1</b> to register G<b>0</b>. Because the contents of these registers are equal, the first \u201ccmp\u201d instruction sets the second bit in the selected field of the condition register, and the first \u201cbc\u201d branch instruction, instruction (<b>3</b>), is taken, whereby the flow returns to instruction (<b>1</b>) with label \u201cLB00\u201d. Thus, in each of the iterations through the loop generated by the second fetch group, instructions (<b>9</b>)\u2013(<b>12</b>), the first branch instruction, instruction (<b>3</b>), is executed twice and the direction toggles. In total the first branch instruction, instruction (<b>3</b>), is executed sixty-three times in the instant example in which the contents of register G<b>5</b> equals thirty-two.</p>\n<p num=\"p-0077\">After an initial five mispredicts for the first branch, instruction (<b>3</b>), the path history becomes a repetition of the pattern \u201c011\u201d. (The initial value of register G<b>5</b> of thirty-two is sufficient to ensure that the global history vector settles to a steady state value. However, an artisan of ordinary skill would understand that other exemplary values could have been chosen. At any particular fetch of the first fetch group which includes the first branch, instruction (<b>3</b>), there are two possibilities for the global history vector, in an embodiment of the present invention in which the global history vector includes eleven bits. The history vector may either be \u201c11011011011\u201d or \u201c01101101101\u201d.</p>\n<p num=\"p-0078\">In the two possible sequences of the global history vector, the prediction of the first branch is perfectly predictable in accordance with the principles of the present invention. In the first case, the prediction mechanism will predict not-taken because the mechanism determines that the next value to be shifted into the history vector is \u201czero\u201d. Similarly, in the second case, the mechanism of the present invention predicts \u201ctaken\u201d because the mechanism determines that the next value to be shifted into the history vector is \u201cone\u201d. In other words, the prediction mechanism in accordance with the principles of the present invention recognizes the pattern repetition in the history vector.</p>\n<p num=\"p-0079\">In sum, the present inventive concepts combine a local branch prediction mechanism with a fetch-based branch prediction mechanism while only requiring three tables. The selector table tracks the prediction performance of the fetch-based and bimodal branch history tables. Advantageously, the branch history table providing the better prediction performance can then be used to predict whether a branch instruction will be taken or not taken through the instruction pipelines.</p>\n<p num=\"p-0080\">Although the present invention and its advantages have been described in detail, it should be understood that various changes, substitutions and alterations can be made herein without departing from the spirit and scope of the invention as defined by the appended claims.</p>\n<?DETDESC description=\"Detailed Description\" end=\"tail\"?>\n</description>"}], "inventors": [{"first_name": "Balaram", "last_name": "Sinharoy", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTERNATIONAL BUSINESS MACHINES CORPORATION"}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}, {"first_name": "", "last_name": "INTERNATIONAL BUSINESS MACHINES CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/00        20060101A I20060506RMEP"}], "national_classes": [{"primary": true, "label": "712239"}, {"primary": false, "label": "712237"}, {"primary": false, "label": "717161"}], "ecla_classes": [{"label": "G06F   9/38B2B"}, {"label": "G06F   9/38E2T"}], "cpc_classes": [{"label": "G06F   9/3848"}, {"label": "G06F   9/3806"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1999-11-04", "application_date": "1999-11-04", "family_members": [{"ucid": "US-6976157-B1", "titles": [{"lang": "EN", "text": "Circuits, systems and methods for performing branch predictions by selectively accessing bimodal and fetch-based history tables"}]}]}