{"patent_number": "US-6263423-B1", "publication_id": 72720600, "family_id": 25326342, "publication_date": "2001-07-17", "titles": [{"lang": "EN", "text": "System and method for translating non-native instructions to native instructions for processing on a host processor"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11206500\" source=\"national office\"><p>A system and method for extracting complex, variable length computer instructions from a stream of complex instructions each subdivided into a variable number of instructions bytes, and aligning instruction bytes of individual ones of the complex instructions. The system receives a portion of the stream of complex instructions and extracts a first set of instruction bytes starting with the first instruction bytes, using an extract shifter. The set of instruction bytes are then passed to an align latch where they are aligned and output to a next instruction detector. The next instruction detector determines the end of the first instruction based on said set of instruction bytes. An extract shifter is used to extract and provide the next set of instruction bytes to an align shifter which aligns and outputs the next instruction. The process is then repeated for the remaining instruction bytes in the stream of complex instructions. The isolated complex instructions are decoded into nano-instructions which are processed by a RISC processor core.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72585923\"><p>A system and method for extracting complex, variable length computer instructions from a stream of complex instructions each subdivided into a variable number of instructions bytes, and aligning instruction bytes of individual ones of the complex instructions. The system receives a portion of the stream of complex instructions and extracts a first set of instruction bytes starting with the first instruction bytes, using an extract shifter. The set of instruction bytes are then passed to an align latch where they are aligned and output to a next instruction detector. The next instruction detector determines the end of the first instruction based on said set of instruction bytes. An extract shifter is used to extract and provide the next set of instruction bytes to an align shifter which aligns and outputs the next instruction. The process is then repeated for the remaining instruction bytes in the stream of complex instructions. The isolated complex instructions are decoded into nano-instructions which are processed by a RISC processor core.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00001\" num=\"1\"><claim-text>1. A computer system, comprising:</claim-text><claim-text>a processor; </claim-text><claim-text>a memory; and </claim-text><claim-text>a bus connecting said processor and said memory, </claim-text><claim-text>wherein said processor can translate a stream of non-native instructions to native instructions, said processor including </claim-text><claim-text>a hardware based instruction translator to convert said stream of non-native instructions into native instructions, wherein non-native instructions are converted into less than a predetermined number of native instructions; </claim-text><claim-text>a latch to store at least two groups of said native instructions in at least two intermediate buffers, wherein said at least two intermediate buffers can each store up to said predetermined number of native instructions; and </claim-text><claim-text>a selector to combine a subset of said at least two groups of said native instructions into a final buffer, so as to allow issuing of said subset of said native instructions of said final buffer in said processor, wherein said final buffer has a maximum capacity of said predetermined number of native instructions. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00002\" num=\"2\"><claim-text>2. The computer system according to claim <b>1</b>, wherein at least one of said at least two intermediate buffers can store up to four native instructions at a time.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00003\" num=\"3\"><claim-text>3. The computer system according to claim <b>1</b>, wherein said predetermined number of native instructions is four native instructions.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00004\" num=\"4\"><claim-text>4. The computer system according to claim <b>1</b>, wherein the stream of non-native instructions comprises at least two non-native instructions.</claim-text></claim>"}, {"num": 5, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00005\" num=\"5\"><claim-text>5. A system for translating a stream of non-native instructions for processing on a host processor, comprising:</claim-text><claim-text>a hardware based instruction translator to convert at least two non-native instructions from the stream of non-native instructions into two groups of native instructions, wherein each group of native instructions includes at least one native instruction but less than a predetermined number of native instructions; </claim-text><claim-text>a latch to store each of said two groups of native instructions into one of two intermediate buffers, wherein said two intermediate buffers can store up to said predetermined number of native instructions; and </claim-text><claim-text>a selector to combine contents of said two intermediate buffers of native instructions into a final buffer, so as to allow issuing of native instructions from said final buffer in the host processor, wherein said final buffer has a maximum capacity of said predetermined number of native instructions. </claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00006\" num=\"6\"><claim-text>6. The system according to claim <b>5</b>, wherein at least one of said two intermediate buffers can store up to four native instructions at a time.</claim-text></claim>"}, {"num": 7, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00007\" num=\"7\"><claim-text>7. The system according to claim <b>5</b>, wherein said predetermined number of native instructions is four native instructions.</claim-text></claim>"}, {"num": 8, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00008\" num=\"8\"><claim-text>8. A computer system, comprising:</claim-text><claim-text>an instruction store; </claim-text><claim-text>a superscalar microprocessor for executing instructions obtained from said instruction store; and </claim-text><claim-text>a bus connecting said superscalar microprocessor and said instruction store, </claim-text><claim-text>wherein said superscalar microprocessor includes </claim-text><claim-text>a fetch circuit to fetch a plurality of CISC instructions from said instruction store, the plurality of CISC instructions being in program order; </claim-text><claim-text>a hardware based decoder to decode said CISC instructions into RISC instructions having a RISC instruction sequence; and </claim-text><claim-text>a dispatch circuit to concurrently dispatch more than one of said plurality of RISC instructions decoded by said decoder; and </claim-text><claim-text>an execution unit comprising </claim-text><claim-text>a plurality of functional units, each of said plurality of functional units executing one of said plurality of RISC instructions dispatched by said dispatch circuit out of the RISC instruction sequence, and </claim-text><claim-text>a register file for storing data from said plurality of functional units in a plurality of registers, and </claim-text><claim-text>wherein said register file communicates with said plurality of functional units via a plurality of data routing paths for concurrently providing data to more than one of said functional units and thereby enabling concurrent execution of more than one of said plurality instructions by said plurality of functional units, </claim-text><claim-text>wherein first and second CISC instructions are decoded by said decoder into one or more first RISC instructions and one or more second RISC instructions, respectively, per clock cycle, and </claim-text><claim-text>wherein said execution unit further comprises first and second registers each comprising RISC instruction storage locations, wherein said first RISC instructions and said second RISC instructions are stored in said first register. </claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00009\" num=\"9\"><claim-text>9. The computer system of claim <b>8</b>, wherein each one of said first and second registers comprises four RISC instruction storage locations.</claim-text></claim>"}, {"num": 10, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00010\" num=\"10\"><claim-text>10. The computer system of claim <b>8</b>, further comprising:</claim-text><claim-text>a latch that stores said first RISC instructions and said second RISC instructions in at least two intermediate buffers; and </claim-text><claim-text>a selector that combines a subset of said first RISC instructions and said second RISC instructions into said first register. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00011\" num=\"11\"><claim-text>11. The computer system of claim <b>10</b>, wherein at least one of said at least two intermediate buffers can store up to four RISC instructions at a time.</claim-text></claim>"}, {"num": 12, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00012\" num=\"12\"><claim-text>12. The computer system of claim <b>8</b>, wherein said hardware based decoder decodes said CISC instructions into less than a predetermined number of RISC instructions, said first and second registers storing up to said predetermined number of RISC instructions.</claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00013\" num=\"13\"><claim-text>13. The computer system of claim <b>12</b>, wherein said predetermined number of RISC instructions is four RISC instructions.</claim-text></claim>"}, {"num": 14, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00014\" num=\"14\"><claim-text>14. A computer system, comprising:</claim-text><claim-text>an instruction store; </claim-text><claim-text>a superscalar microprocessor for decoding CISC instructions stored in said instruction unit, said superscalar microprocessor coupled to said instruction store and including </claim-text><claim-text>memory for storing data in a plurality of registers identifiable by register references, said plurality of registers including a predetermined register and a temporary register; </claim-text><claim-text>fetch unit that fetches CISC instructions to be executed, wherein at least one of said CISC instructions includes a register reference; </claim-text><claim-text>a hardware based decoder that decodes said CISC instructions into RISC instructions having a RISC instruction sequence; and </claim-text><claim-text>an execution unit that executes at least two of said RISC instructions concurrently and out of said RISC instruction sequence, said execution unit including a first selector to select said temporary register where the execution of said instruction provides said register reference to select said predetermined register for the storage of data, </claim-text><claim-text>wherein first and second CISC instructions are decoded by said decoder into one or more first RISC instructions and one or more second RISC instructions, respectively, per clock cycle, wherein said execution unit comprises first and second registers each comprising RISC instruction storage locations, wherein said first RISC instructions and said second RISC instructions are stored in said first register. </claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00015\" num=\"15\"><claim-text>15. The computer system of claim <b>14</b>, wherein each one of said first and second registers comprises four RISC instruction storage locations.</claim-text></claim>"}, {"num": 16, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00016\" num=\"16\"><claim-text>16. The computer system of claim <b>14</b>, further comprising:</claim-text><claim-text>a latch that stores said first RISC instructions and said second RISC instructions in at least two intermediate buffers; and </claim-text><claim-text>a second selector that combines a subset of said first RISC instructions and said second RISC instructions into said first register. </claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00017\" num=\"17\"><claim-text>17. The computer system of claim <b>16</b>, wherein at least one of said at least two intermediate buffers can store up to four RISC instructions at a time.</claim-text></claim>"}, {"num": 18, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00018\" num=\"18\"><claim-text>18. The computer system of claim <b>14</b>, wherein said hardware based decoder decodes said CISC instructions into less than a predetermined number of RISC instructions, said first and second registers each storing up to said predetermined number of RISC instructions.</claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6263423-B1-CLM-00019\" num=\"19\"><claim-text>19. The computer system of claim <b>18</b>, wherein said predetermined number of RISC instructions is four RISC instructions.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54602633\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><h4>CROSS-REFERENCE TO RELATED APPLICATIONS</h4><p>This application is a continuation of application Ser. No. 08/784,339, filed Jan. 16, 1997, now allowed, which is a continuation of application Ser. No. 08/460,272, filed Jun. 2, 1995, now U.S. Pat. No. 5,619,666, which is a continuation of application Ser. No. 07/857,599, filed Mar. 31, 1992, now U.S. Pat. No. 5,438,668.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><p>The following are commonly owned, co-pending applications:</p><p>\u201cA ROM With RAM Cell and Cyclic Redundancy Check Circuit\u201d, application Ser. No. 07/802,816, filed Dec. 6, 1992, now abandoned;</p><p>\u201cHigh-Performance, Superscalar-Based Computer System with Out-of-Order Instruction Execution\u201d, application Ser. No. 07/817,810, filed Jan. 8, 1992 now U.S. Pat. No. 5,539,911;</p><p>\u201cHigh-Performance, Superscalar-Based Computer System with Out-of-Order Instruction Execution and Concurrent Results Distribution\u201d, Ser. No. 08/397,016 filed Mar. 1, 1995, now U.S. Pat. No. 5,560,032, which is a file wrapper continuation of application Ser. No. 07/817,809, filed Jan. 8, 1992.</p><p>The disclosures of the above applications are incorporated herein by reference.</p><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The field of the invention generally relates to superscalar RISC microprocessors, more specifically, the invention relates to a CISC to RISC microprocessor instruction alignment unit and decode unit for permitting complex instructions to run on RISC-based hardware.</p><p>2. Related Art</p><p>All complex instruction set computers (CISC computers) which use variable length instructions are faced with the problem of determining the length of each instruction that is encountered in the instruction stream. Instructions are packed into memory as successive bytes of data, so that given the address of an instruction, it is possible to determine the starting address of the next instruction if you know the first instruction's length.</p><p>For a conventional processor, this length determination does not have a significant performance impact compared to other stages in the processing of an instruction stream, such as the actual execution of each instruction. As a result, fairly simple circuits are typically used. Superscalar reduced instruction set computers (RISC computers), on the other hand, can process instructions at a much higher rate, requiring instructions to be extracted from memory much more rapidly to keep up with the parallel execution of multiple instructions. This limiting factor imposed by the rate at which instructions can be extracted from memory is referred to as the Flynn Bottleneck.</p><p>The task of determining the length of each instruction and extracting that instruction from the instruction stream is performed by a function unit called an Instruction Align Unit (IAU). This block must contain decoder logic to determine the instruction length, and a shifter to align the instruction data with the decoder logic.</p><p>For the Intel 80386 microprocessor, the first byte of an instruction can have numerous implications on the overall instruction length, and may require that additional bytes be checked before the final length is known. Furthermore, the additional bytes may specify other additional bytes. It is therefore extremely difficult to quickly determine the length of the X86 instruction because the process is inherently sequential.</p><p>Based on the information provided in the i486\u2122 Programmer's Reference Guide, several conclusions can be drawn regarding alignment unit present in the i486\u2122. The i486\u2122's IAU is designed to look only at the first few bytes of the instruction. In cases where these bytes do not fully specify the length, these initial bytes are extracted and the process is repeated on the remaining bytes. Each iteration of this process requires a full cycle, so it may take several cycles, at worst case, for an instruction to be fully aligned.</p><p>Situations that require additional cycles for the i486\u2122 IAU include the presence of prefixed and escaped (2 byte) opcodes. Both of these are common in i486\u2122 programs. In addition, complex instructions may also comprise displacement and immediate data. The i486\u2122 requires additional time to extract this data.</p><p>An example format for a CISC processor instruction is shown in FIG. <b>1</b>. The example depicts the potential bytes of a variable length i486\u2122 CISC instruction. The instructions are stored in memory on byte boundaries. The minimum length of an instruction is 1 byte, and the maximum length of an instruction, including prefixes, is 15 bytes. The total length of the instruction is determined by the Prefixes Opcode, ModR/M and SIB bytes.</p><h4>SUMMARY OF THE INVENTION</h4><p>The present invention is a subsystem and method of a microprocessor having a superscalar reduced instruction set computer (RISC) processor designed to emulate a complex instruction set computer (CISC), such as an Intel 80\u00d786 microprocessor, or other CISC processors.</p><p>The CISC to RISC translation operation of the present invention involves two basic steps. CISC instructions must first be extracted from the instruction stream, and then decoded to generate nano-instructions that can be processed by the RISC processor. These steps are performed by an Instruction Alignment Unit (IAU) and an Instruction Decode Unit (IDU), respectively.</p><p>The IAU functions to extract individual CISC instructions from the instruction stream by looking at the oldest 23 bytes on instruction data. The IAU extracts 8 continuous bytes starting with any byte in a bottom line of an Instruction FIFO. During each clock phase, the IAU determines the length of the current instruction and uses this information to control two shifters to shift out the current instruction, leaving the next sequential instruction in the stream. The IAU therefore outputs an aligned instruction during each clock phase, for a peak rate of two instructions per cycle. Exceptions to this best case performance are discussed below in sections 2.0 and 2.1.</p><p>After CISC instructions have been extracted from memory, the IDU functions to convert these aligned instructions to equivalent sequences of RISC instructions, called nano-instructions. The IDU looks at each aligned instruction as it is output by the IAU, and decodes it to determine various factors such as the number and type of nano-instruction(s) required, the size of the data operands, and whether or not a memory access is required to complete the aligned instruction. Simple instructions are directly translated by decoder hardware into nano-instructions, while more complex CISC instructions are emulated by subroutines in a special instruction set, called microcode routines, which are then decoded into nano-instructions. This information is collected for two instructions during a complete cycle, and then combined together to form an instruction bucket, containing the nano-instructions corresponding to both source instructions. This bucket is then transferred to an Instructions Execution Unit (IEU) for execution by a RISC processor. The execution of the nano-instruction buckets is outside the scope of the present invention.</p><p>The foregoing and other features and advantages of the invention will be apparent from the following more particular description of preferred embodiments of the invention, as illustrated in the accompanying drawings.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>The invention will be better understood if reference is made to the accompanying drawings in which:</p><p>FIG. 1 shows the data structure format for a conventional CISC instruction.</p><p>FIG. 2 shows a block diagram of the instruction prefetch buffer of the present invention.</p><p>FIG. 3 shows a block diagram of the instruction alignment unit of the present invention.</p><p>FIG. 4 shows a representative flow chart of the instruction extraction and alignment method of the IAU of the present invention.</p><p>FIG. 5 shows a simplified timing diagram associated with the block diagram of FIG. <b>3</b> and the flow chart of FIG. <b>4</b>.</p><p>FIG. 6 is a block diagram of the STACK of the present invention.</p><p>FIG. 7A is a block diagram of the Next Instruction Decoder (NID) of the present invention.</p><p>FIG. 7B is a block diagram of the Remaining Next Instruction Decoder (RNID) of the present invention.</p><p>FIG. 8 is a block diagram of the Immediate Data and Displacement Decoder (IDDD) of the present invention.</p><p>FIG. 9 is a block diagram of a Prefix Decoder (PD) of the present invention.</p><p>FIG. 10 is a block diagram of the PReFiX Number (PRFX_NO) decoder of the present invention.</p><p>FIG. 11 is a block diagram of a nano-instruction bucket of the present invention.</p><p>FIG. 12 is a representative block diagram of the instruction decode unit (IDU) of the present invention.</p><p>FIGS. 13A, <b>13</b>B, <b>13</b>C, <b>13</b>D and <b>13</b>E show instruction bit maps of the present invention.</p><p>FIG. 14 shows an example block diagram of the Instruction Decoder section of the IDDD of the present invention.</p><p>FIG. 15 depicts a representative block and logic diagram of a set of decoders of the Instruction Decoder shown in FIG. <b>14</b>.</p><p>FIG. 16A shows details of a conceptual block diagram of the decode FIFO of the present invention.</p><p>FIG. 16B shows details of a conceptual block diagram of the decode FIFO of the present invention.</p><p>FIG. 16C shows details of a conceptual block diagram of the decode FIFO of the present invention.</p><p>FIG. 17 shows examples of the nano-instruction field formats of the present invention.</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217PT\"></colspec><thead valign=\"bottom\"><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Table of Contents</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"154PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"49PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Detailed Description of the Preferred Embodiments</entry><entry morerows=\"0\" valign=\"top\">\u20028</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1.0 The Instruction Fetch Unit</entry><entry morerows=\"0\" valign=\"top\">\u20028</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">2.0 Instruction Alignment Unit Overview</entry><entry morerows=\"0\" valign=\"top\">\u20029</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">2.1 Instruction Alignment Unit Block Diagrams</entry><entry morerows=\"0\" valign=\"top\">12</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">3.0 Instruction Decode Unit Overview</entry><entry morerows=\"0\" valign=\"top\">33</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">3.1 Microcode Dispatch Logic</entry><entry morerows=\"0\" valign=\"top\">36</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">3.2 Mailboxes</entry><entry morerows=\"0\" valign=\"top\">39</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">3.3 Nano-Instruction Format</entry><entry morerows=\"0\" valign=\"top\">40</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">3.4 Special Instructions</entry><entry morerows=\"0\" valign=\"top\">41</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">3.5 Instruction Decode Unit Block Diagrams</entry><entry morerows=\"0\" valign=\"top\">43</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">4.0 Decoded Instruction FIFO</entry><entry morerows=\"0\" valign=\"top\">54</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</h4><p>A more detailed description of some of the basic concepts discussed in this section is found in a number of references, including Mike Johnson, <i>Superscalar Microprocessor Design </i>(Prentice-Hall, Inc., Englewood Cliffs, N.J., 1991); John L Hennessy et al., <i>Computer Architecture</i>-<i>A Quantitative Approach</i>\u201d (Morgan Kaufmann Publishers, Inc., San Mateo, Calif., 1990); and the <i>i</i>486<i>\u2122 Microprocessor Programmer's Reference Manual </i>and the <i>i</i>486<i>\u2122 Microprocessor Hardware Reference Manual </i>(Order Nos. 240486 and 240552, respectively, Intel Corporation, Santa Clara, Calif., 1990). The disclosures of these publications are incorporated herein by reference.</p><p>1.0 The Instruction Fetch Unit</p><p>An instruction Fetch Unit (IFU) of the present invention is used to fetch instruction bytes from an instruction stream stored in an instruction memory, instruction cache, or the like, and provide the instruction bytes to a decoder section for execution. Instructions to be aligned by the Instruction Alignment Unit are therefore supplied by the IFU. FIG. 2 shows a block diagram of three Instruction Prefetch Buffers <b>200</b> within the IFU, which comprises: a Main instruction BUFfer (MBUF) <b>204</b>, an Emulation instruction BUFfer (EBUF) <b>202</b>, and a Target instruction BUFfer (TBUF) <b>206</b>. The Prefetch Instruction Buffers can load 128 bits (16 bytes) of an instruction stream from an instruction cache in a single cycle. This data is held in one of the three buffers for use by the IAU.</p><p>During normal program execution, the MBUF <b>204</b> is used to supply instruction bytes to the IAU. When conditional control flow (i.e., a conditional branch instruction) is encountered, instructions corresponding to the branch target address are stored in the TBUF <b>206</b> while execution continues from the MBUF <b>204</b>. Once the branch decision is resolved, either the TBUF <b>206</b> is discarded if the branch is not taken, or the TBUF <b>206</b> is transferred to the MBUF if the branch is taken. In either case, execution continues from the MBUF.</p><p>The EBUF <b>202</b> operates in a slightly different way. When emulation mode is entered, whether due to an emulation instruction or an exception, both instruction fetching and execution are transferred to the EBUF <b>202</b>. (Emulation mode and exception handling will both be discussed below in detail.) Execution continues out of the EBUF <b>202</b> as long as the processor is in emulation mode. When the emulation routine finishes, execution is continued from the instruction data remaining in the MBUF <b>204</b>. This eliminates the need to refetch the main instruction data after executing an emulation routine.</p><p>2.0 Instruction Alignment Unit Overview</p><p>An Instruction Alignment Unit subsystem in combination with the present invention uses the RISC strategy of making the common case fast to deal with by using the superior per-cycle instruction throughput of a superscalar processor.</p><p>In the context of the present invention, the term \u201calign\u201d means to position an instruction's bytes so that they can be distinguished from adjacent bytes in the instruction stream for later decoding. The IAU distinguishes the end of the current instruction from the beginning of the next instruction by determining the number of bytes in the current instruction. The IAU then aligns the current instruction so that the least significant byte presented to the IDU is the first byte of the current instruction. Different ordering of the bytes as they are presented to the IDU is also possible.</p><p>The IAU subsystem of the present invention is capable of aligning most common instructions at a rate of two per cycle at all clock rates, and provides the capability of aligning most other instructions at this same rate at reduced clock speeds. Instructions including prefixes require an additional half cycle to align. Immediate data and displacement fields are extracted in parallel, and thus, require no extra time.</p><p>Additionally, the IAU worst-case alignment time is only 2.0 cycles for an instruction, which is less than the time required to align many common instructions in conventional CISC processors. The worst-case occurs when the instruction has one or more prefixes (half cycle total to align), the instruction is from the set that requires a full cycle to determine the length, and the instruction (not including the prefixes) is greater than eight bytes in length (which requires an extra half cycle, thus totaling 2 full cycles).</p><p>This performance is achieved through several architectural features. First, the IAU is designed to perform a complete alignment operation during each phase of the clock by using alternate phase latches and multiplexers in the alignment circuitry. Second, the decode logic divides CISC instructions into two categories based on the number of bits that must be considered to determine each instruction's length: instructions with length specified by a small number of bits are aligned in a single phase (halfcycle), whereas other instructions typically require an additional clock phase. Finally, the IAU extracts up to eight bytes from the instruction stream in a single shift, allowing long instructions (up to 15 bytes for i486\u2122) to be aligned in a small number of shift operations, and most instructions to be aligned with a single shift.</p><p>The following tasks are carried out by the IAU in order to quickly and accurately decode a CISC instruction:</p><p>detect the presence and the length of prefix bytes;</p><p>isolate the Opcode, ModR/M and SIB (scale, index, base) bytes;</p><p>detect the length of inductions (which indicates the location of the next instruction); and</p><p>send the following information to an Instruction Decode Unit (IDU):</p><p>Opcode, eight bits plus 3 optional extension bits. For 2 byte opcodes, the first byte is always 0F hex, so the second byte is sent as the opcode.</p><p>ModR/M byte, SIB byte, and Displacement and Immediate data; and</p><p>Information concerning the number and type of prefixes.</p><p>The opcode byte or bytes specify the operation performed by the instruction. The Mod R/M byte specifies the address form to be used if the instruction refers to an operand in memory. The Mod R/M byte can also refer to a second addressing byte, the SIB (scale, index, base) byte, which may be required to fully specify the addressing form.</p><p>2.1 Instruction Alignment Unit Block Diagrams</p><p>A block diagram of the IAU is shown in FIG. <b>3</b>. The diagram is divided into two sections: a MAIN DATAPATH <b>302</b> (indicated by the dashed line box) and a PREDECODER <b>304</b> (indicated by the dashed line box). Instruction shifting and extraction occurs in the MAIN DATAPATH <b>302</b>, while length determination and datapath control are handled by the PREDECODER <b>304</b>.</p><p>The MAIN DATAPATH <b>302</b> comprises several shifters, latches and multiplexers. An EXTRACT SHIFTER <b>306</b> receives instruction data arranged in bytes from the IFU. Two buses (shown generally at <b>303</b>) IFI<b>0</b>b_Bus[<b>127</b>:<b>0</b>] and IFI<b>1</b>b_Bus[<b>55</b>:<b>0</b>] represent instruction data outputs of the IFU. The IFU updates this instruction information in response to requests from the IAU on an ADVance BUFfer REQuest (ADVBUFREQ) line <b>308</b>. Generation of the ADVBUFREQ signal will be discussed below. Eight bytes of data, corresponding to the current instruction, are output from the EXTRACT SHIFTER and are sent to an ALIGN SHIFTER <b>310</b> on a bus <b>307</b>. The ALIGN SHIFTER holds a total of 16 bytes of instruction data and can shift up to 8 bytes per phase. The ALIGN SHIFTER is used to separate prefixes from their instruction if they are detected by shifting them out. The ALIGN SHIFTER is also used to align the instruction to its lower order bytes and shift-out the entire instruction after it has been aligned.</p><p>The 8-bytes are also sent via a bus <b>309</b> to an IMMediate Data SHIFTER (IMM SHIFTER <b>312</b>), which extracts immediate data from the current instruction, and to a DISPlacement SHIFTER (DISP SHIFTER <b>314</b>), which extracts displacement data from the current instruction. Data to these two shifters is delayed by a \u00bd cycle delay element <b>316</b> to keep it synchronized with the aligned instruction.</p><p>The ALIGN SHIFTER <b>310</b> outputs the next aligned instruction on a bus <b>311</b> to two ALIGN_IR latches <b>318</b> or <b>320</b>. These latches operate on opposite phases of the system clock, allowing two instructions to be latched per cycle. The ALIGN_IR latches <b>318</b> and <b>320</b> output-aligned instruction bytes on two output buses <b>321</b>. During the phase in which one of the latches is receiving a new value, the output of the other latch (which is the current aligned instruction) is selected by a multiplexer (MUX <b>322</b>). The MUX <b>322</b> outputs the current aligned instruction on an aligned instruction bus <b>323</b>. The output <b>323</b> is the primary output of the IAU. This output is used by the PREDECODER <b>304</b> to determine the length of the current instruction, and it is fed back into the ALIGN SHIFTER <b>310</b> as data from which the next instruction is extracted. The current aligned instruction is fed back to the ALIGN SHIFTER <b>310</b> via bus <b>325</b>, a stack <b>334</b> and a further bus <b>336</b>. The bus <b>336</b> also sends the current aligned instruction information to the \u00bd cycle data delay <b>316</b>.</p><p>The IMM and DISP SHIFTERS <b>312</b> and <b>314</b>, respectively, can therefore shift the immediate and displacement data, because they also require 16 total bytes to shift. The \u00bd cycle data delay <b>316</b> outputs instruction bytes to the shifters on a bus. The IMM SHIFTER <b>312</b> outputs immediate data corresponding to the current instruction on an IMMEDIATE DATA bus <b>340</b>. The DISP SHIFTER <b>314</b> outputs displacement data corresponding to the current instruction on a DISPLACEMENT DATA bus <b>342</b>.</p><p>The PREDECODER <b>304</b> comprises three decoder blocks: a Next Instruction Detector (NID) <b>324</b>, an Immediate Data and Displacement Detector (IDDD) <b>326</b>, and a Prefix Detector (PD) <b>328</b>. The NID and PD control the ALIGN SHIFTER and the EXTRACT SHIFTER, while the IDDD controls the IMM SHIFTER <b>312</b> and the DISP SHIFTER <b>314</b>.</p><p>The PD <b>328</b> is designed to detect the presence of prefix bytes in an instruction. It determines the number of prefixes present, and provides shift control signals to the ALIGN SHIFTER <b>310</b> and the COUNTER SHIFTER <b>332</b> via a line <b>331</b>, a MUX <b>330</b> and a line <b>333</b>, for extraction of the prefixes from the instruction stream in the next half cycle. In addition, the PD <b>328</b> decodes the prefixes themselves and provides this prefix information on an output line <b>329</b> to the IDU.</p><p>The basic architecture of the PD <b>328</b> consists of four identical prefix detection units (to detect up to four prefixes), and a second block of logic to decode the prefixes themselves. The CISC format defines the order in which prefixes can occur, but the present invention checks for the presence of all prefixes in each of the first four byte positions. Furthermore, the functions of detecting the presence of prefixes and decoding the prefixes are separated to take advantage of the reduced speed requirements for the decoder. A more detailed description of the architecture of the PD <b>328</b> will be addressed below.</p><p>The IDDD <b>326</b> is designed to extract immediate data and displacement data from each instruction. The IDDD always attempts to extract both fields, whether they are present or not. The IDDD <b>326</b> controls the IMM SHIFTER <b>312</b> and the DISP SHIFTER <b>314</b> on a pair of lines <b>344</b> and <b>346</b>, respectively. The IDU requires a half cycle to process the aligned instruction, but has no use for the immediate and displacement data. The immediate and displacement data is therefore delayed by the \u00bd cycle data delay <b>316</b> to allow more time for the IDDD <b>326</b> to compute shift amounts, because the shift occurs during the following phase, unlike the NID <b>324</b> which decodes and shifts in the same phase.</p><p>The NID <b>324</b> is the heart of the PREDECODER. The NID <b>324</b> determines the length of each instruction once the prefixes have been removed. The NID <b>324</b> controls the ALIGN SHIFTER <b>310</b> and a COUNTER SHIFTER <b>308</b> via a control line <b>325</b>, MUX <b>330</b> and line <b>333</b>. The NID comprises two sub-blocks, a Subset Next Instruction Detector (SNID <b>702</b>) and a Remaining Next Instruction Detector (RNID <b>704</b>), which will be discussed in conjunction with FIGS. 7A and 7B.</p><p>The SNID <b>702</b>, as its name implies, determines the lengths of a subset of the CISC instruction set. Instructions in the subset can be aligned at a rate of two per cycle by the SNID.</p><p>The RNID <b>704</b> determines the lengths of all remaining instructions, and requires an additional half cycle, which brings its total decode time to a full cycle. The determination of whether or not an instruction is in the subset is made by the SNID, and this signal is used within the NID to select the outputs of either the SNID or the RNID.</p><p>When a new instruction is being aligned, it is initially assumed to be in the subset, and thus the output of the SNID is selected. If the SNID determines (during this same half-cycle) that the instruction must be handled by the RNID, a signal is asserted and the IAU loops the current instruction to hold it for another half-cycle. During this second half-cycle, the RNID output is selected, and the instruction is properly aligned.</p><p>This architecture of the NID has several benefits. One, which was mentioned earlier, is that the selection between the SNID and the RNID can be made during a single half cycle if the cycle time is sufficiently long, allowing all instructions to be aligned in a single phase (not including the time to extract prefixes and instructions longer than eight bytes). This provides a per-cycle performance increase at lower cycle rates, without additional hardware.</p><p>A second advantage is that the selection signal can be used as an alignment cancel signal, because it causes the IAU to ignore the SNID shift outputs and hold the current instruction for an additional half cycle. The SNID could be designed to predict certain instruction combinations or lengths, and then generate the cancel signal if these predictions were incorrect. This could be used to align multiple instructions in a single half cycle, for example, which would further boost performance.</p><p>The IAU also comprises a COUNTER SHIFTER <b>332</b>. The COUNTER SHIFTER <b>332</b> is used to determine the shift amount for the EXTRACT SHIFTER <b>306</b> via a line <b>335</b>, and request additional CISC instruction bytes from the IFU using the ADVBUFREQ line <b>308</b>. The functionality of the COUNTER SHIFTER <b>332</b> will best be understood by reviewing the following flow chart of the IAU operation and a timing diagram example.</p><p>FIG. 4 shows a general flow chart of instruction byte extraction and alignment performed by the IAU of the present invention. When new data enters the lowest line <b>205</b> of the IFU's MBUF <b>204</b> (called BUCKET_#<b>0</b>), the EXTRACT SHIFTER <b>306</b> extracts 8 bytes starting with the first instruction, as shown at a step <b>402</b>. The 8 instruction bytes are passed along to the ALIGN_IR latches <b>318</b> and <b>320</b>, while bypassing the ALIGN SHIFTER <b>310</b>, as shown at a step <b>404</b>. The IAU then waits for the next clock phase while it holds the aligned instruction in the ALIGN_IR latch, as shown at a step <b>406</b>.</p><p>During the next clock phase, the IAU outputs the aligned instruction to the IDU, the STACK <b>334</b>, the IDDD <b>326</b>, the NID <b>324</b>, the PD <b>328</b> and the \u00bd cycle data delay <b>316</b>. The immediate data and displacement information is then output to the IDU on buses <b>340</b> and <b>342</b>, respectively. This data corresponds to the instruction aligned during the previous phase, if there was one. These operations are shown generally at a step <b>408</b> of FIG. <b>4</b>.</p><p>A conditional statement <b>409</b> is then entered by the IAU to determine if a prefix or prefixes are present. This determination is made by the PD (prefix decoder) <b>328</b>. If one or more prefixes are detected by the PD, as indicated by a \u201cYES\u201d arrow exiting the conditional statement <b>409</b>, the process proceeds to a step <b>410</b> in which the IAU selects the output of the PD with the MUX <b>330</b>. The decoded prefix information is then latched to be sent to the IDU during the next phase with the corresponding aligned instruction, as shown at a step <b>412</b>. If no prefix instruction bytes were detected, as indicated by a \u201cNO\u201d arrow exiting the conditional statement <b>409</b>, the output of the NID <b>324</b> is selected with the MUX <b>330</b>, as shown at a step <b>414</b>.</p><p>Once the steps <b>412</b> or <b>414</b> are completed, the current output of the COUNTER SHIFTER <b>332</b> is used to control the EXTRACT SHIFTER <b>306</b> to provide the next 8 bytes of instruction data to the ALIGN SHIFTER <b>310</b> and the \u00bd cycle delay <b>316</b>, as shown at a block <b>416</b>. Next, the IAU uses the output of the MUX <b>330</b> as a variable called SHIFT_A, which is used to control the ALIGN SHIFTER <b>310</b> to align the next instruction. The SHIFT_A is also added to the current EXTRACT SHIFTER shift amount (called BUF_COUNT) to compute the shift amount for use during the next phase. This addition is performed in the COUNTER SHIFTER <b>308</b>, as shown at a step <b>418</b>.</p><p>The next operational step performed by the IAU is to latch the output of the ALIGN SHIFTER in the ALIGN_IR latch, as shown at a step <b>420</b>. The position of the immediate data and displacement data in the IDDD <b>326</b> is then computed, and this shift amount is delayed by a \u00bd cycle, as shown at a step <b>422</b>. Next, the IAU uses the shift amount computed during the previous half cycle to shift the data currently entering the IMM SHIFTER <b>312</b> and DISP SHIFTER <b>314</b>, as shown at a step <b>424</b>. Finally, the process repeats beginning at step <b>406</b> to wait for the next clock phase. The steps <b>408</b> through <b>424</b> are repeated for the remaining instruction bytes in the instruction stream.</p><p>FIG. 5 shows a timing diagram associated with the IAU of FIG. <b>3</b>. Two instruction buckets are shown at the top of FIG. <b>5</b>. These instruction buckets, labeled BUCKET_#<b>0</b> and BUCKET_#<b>1</b>, each comprise 16 instruction bytes which are provided by the IFU (from an instruction memory not shown) to the IAU in FIG. <b>3</b>. Instruction alignment is always done from the right out of BUCKET_#<b>0</b>, (i.e., the bottom bucket). In this example, BUCKET_#<b>0</b> and BUCKET_#<b>1</b> are the bottom two buckets of the IFU's MBUF <b>204</b>. Other arrangements are also possible.</p><p>In this example, the first three instructions sent to the IAU are OP<b>0</b>, OP<b>1</b>, and OP<b>2</b>, which have lengths of 5 bytes, 3 bytes and 11 bytes, respectively. Note that only the first 8 bytes of instruction OP<b>2</b> fit in BUCKET_#<b>0</b>. The remaining 3 bytes wrap to the beginning of BUCKET_#<b>1</b>. To simplify this example, it is assumed that these three instructions have no prefix bytes. An additional phase would be required for the alignment of an instruction if prefixes are detected.</p><p>Instructions can start at any position of a bucket. Instructions are extracted up to 8 bytes at a time from the bottom bucket beginning with any instruction in that bucket. The IAU looks at two buckets to accommodate instructions which extend into the second bucket, such as OP<b>2</b> in the present example.</p><p>Trace \u201c1\u201d in the timing diagram is one of two system clocks CLK<b>0</b>. In this example, the system clock has a 6 nano second (ns) half cycle. CLK<b>0</b>, which has opposite phase compared to the other system clock CLK<b>1</b>, rises at T<b>6</b> and falls at T<b>0</b>, where T<b>0</b> is the rising edge of CLK<b>1</b> and T<b>6</b> is the rising edge of CLK<b>0</b>. The three main clock phases of FIG. 5 have been labeled \u03c6<b>1</b>, \u03c6<b>2</b> and \u03c6<b>3</b> to aid this discussion.</p><p>Traces \u201c2\u201d and \u201c3\u201d in the timing diagram represent instruction data on the input buses IFI<b>1</b>B and IFI<b>0</b>B. A new BUCKET_#<b>0</b> becomes available on bus IFI<b>0</b>B at the beginning of \u03c6<b>1</b>, as shown at <b>502</b>. A short time later, the first 8 bytes starting with OP<b>0</b> (B#<b>0</b>; <b>7</b>-<b>0</b>) are extracted by the EXTRACT SHIFTER <b>306</b> at <b>504</b>. BUCKET_#<b>0</b> bytes <b>7</b>-<b>0</b> are shown valid. The EXTRACT SHIFTER timing is shown at a trace \u201c4\u201d.</p><p>When CISC to RISC decoding of an instruction stream begins, the COUNTER SHIFTER <b>332</b> controls the EXTRACT SHIFTER <b>306</b> to extract the first 8 bytes from Bucket_#<b>0</b>. The COUNTER SHIFTER signals the EXTRACT SHIFTER to shift and extract further bytes of the buckets as the alignment of instructions progresses. When Bucket_#<b>0</b> is depleted of instruction bytes, the contents of Bucket_#<b>1</b> are shifted into Bucket_#<b>0</b>, and Bucket_#<b>1</b> is refilled from the instruction stream. After the initial extraction of 8 bytes, the EXTRACT SHIFTER extracts and shifts bytes under control of the COUNTER SHIFTER on line <b>335</b>, based on instruction length, prefix length and previous shift information.</p><p>For this example, however, the COUNTER SHIFTER signals the EXTRACT SHIFTER to shift zero to align the first instruction. Thus, the EXTRACT SHIFTER shifts-out the first 8 bytes of the first instruction to the ALIGN SHIFTER <b>310</b>. The timing of signals at the ALIGN SHIFTER are shown at trace \u201c5\u201d of the timing diagram. These 8 bytes become valid at the ALIGN SHIFTER during \u03c6<b>1</b> at the time period shown by a reference numeral <b>506</b>.</p><p>The first 8 bytes of Bucket_#<b>0</b> bypass the ALIGN SHIFTER and are stored in the two ALIGN_IR latches <b>318</b> or <b>320</b> (as shown at traces \u201c6\u201d and \u201c7\u201d in FIG. <b>3</b>). The ALIGN_IR latches receive the instruction bytes in an alternating fashion, based on the timing of clock signals CLK<b>0</b> and CLK<b>1</b>. ALIGN_IR<b>0</b><b>318</b> is a clock signal CLK<b>0</b> latch, meaning that it is latched while clock signal CLK<b>0</b> is high. ALIGN_IR<b>1</b><b>320</b> is a clock signal CLK<b>1</b> latch, which latches when clock signal CLK<b>0</b> is high. The first 8 bytes become valid at the ALIGN_IR<b>0</b> prior to the end of the first clock signal CLK<b>0</b> phase, as shown by a reference numeral <b>508</b> toward the end of \u03c6<b>1</b>.</p><p>The MUX <b>322</b> selects the latch that was latching during the previous phase. Thus, in this example, MUX <b>322</b> outputs the first eight bytes of OP<b>0</b> during the second full phase, \u03c6<b>2</b>.</p><p>The first 8 bytes of OP<b>0</b> then flow to the NID <b>324</b> and the STACK <b>334</b>. The NID <b>324</b> detects that the first instruction is 5 bytes long and sends this information back to the ALIGN SHIFTER and to the COUNTER SHIFTER via line <b>325</b>, MUX <b>330</b> and line <b>333</b>. At the same time the first 8 bytes flow through the stack and are fed back to the ALIGN SHIFTER, as discussed above. Thus, the ALIGN SHIFTER receives instruction bytes from the EXTRACT SHIFTER, and itself, indirectly. This is because the ALIGN SHIFTER needs 16 bytes of input in order to shift a maximum of 8 bytes per cycle. When the ALIGN SHIFTER shifts right X number of bytes, it discards the least significant X number of bytes, and passes the next 8 bytes of data to the latches <b>318</b> and <b>320</b>. In this case, the STACK <b>334</b> provides bytes <b>0</b>-<b>7</b> to the ALIGN SHIFTER <b>310</b>.</p><p>A bypass <b>336</b> around the ALIGN SHIFTER is used in the initial case when the EXTRACT SHIFTER extracts the first instruction from the instruction stream. It is not necessary for the ALIGN SHIFTER to shift in the initial case, because, excluding prefix bytes, the first instruction is aligned.</p><p>During \u03c6<b>2</b> of the timing diagram, the EXTRACT SHIFTER shifts out 8 bytes, bytes <b>15</b>-<b>8</b> of BUCKET_#<b>0</b>. See <b>510</b> at FIG. <b>5</b>. These bytes are sent to the ALIGN SHIFTER, which now has a total of 16 consecutive bytes to work with. The ALIGN SHIFTER looks at the output of the EXTRACT SHIFTER and the valid output of the latches <b>318</b> and <b>320</b> during \u03c6<b>2</b>.</p><p>Toward the end of \u03c6<b>2</b>, the ALIGN SHIFTER shifts bytes <b>12</b>-<b>5</b> of BUCKET_#<b>0</b> to its outputs, based on the signal from the NID, which indicated to the ALIGN SHIFTER to shift 5 bytes to the right, thereby discarding the 5 least significant bytes corresponding to instruction OP<b>0</b>. See the Shift_<b>5</b>_byte signal <b>512</b> at trace \u201c8\u201d in the timing diagram. The 8 bytes of remaining instruction data, bytes <b>12</b>-<b>5</b>, then flow through the ALIGN SHIFTER. Note that byte <b>5</b> is the first byte of the next instruction, OP<b>1</b>.</p><p>The COUNTER SHIFTER <b>332</b> then shifts the EXTRACT SHIFTER <b>306</b> 8 bytes, because the first 8 bytes are now available from the ALIGN_IR latches, thus the next bytes are needed. Beginning at phase <b>3</b>, the COUNTER SHIFTER will signal the EXTRACT SHIFTER to increase its shift amount by the number of bytes shifted out by the ALIGN SHIFTER <b>310</b> during the previous phase. The COUNTER SHIFTER must therefore comprise logic to store the previous EXTRACT SHIFTER shift amount, and add the ALIGN SHIFTER shift amount to this value.</p><p>Each time there is a new value for the ALIGN SHIFTER, the COUNTER SHIFTER adds that amount to its old shift amount. In this example, it shifted 8 bytes during \u03c6<b>2</b>. Therefore, in \u03c6<b>3</b>, it must tell the EXTRACT SHIFTER to shift 8+5, or 13 bytes. The bytes output by the EXTRACT SHIFTER are bytes <b>20</b>-<b>13</b>. Note that the ALIGN_IR latches will output bytes <b>12</b>-<b>5</b> during \u03c6<b>3</b>; and therefore, bytes <b>20</b>-<b>5</b> will be available at the ALIGN SHIFTER.</p><p>During \u03c6<b>3</b>, the EXTRACT SHIFTER will output bytes <b>20</b>-<b>13</b>. However, BUCKET_#<b>0</b> only contains bytes <b>15</b>-<b>0</b>, therefore, bytes <b>20</b>-<b>16</b> must be taken from BUCKET_#<b>1</b>. As shown at <b>514</b> in the timing diagram, BUCKET_#<b>1</b> becomes valid at the beginning of \u03c6<b>3</b>. The EXTRACT SHIFTER then shifts bytes <b>4</b>-<b>0</b> of BUCKET_#<b>1</b> and bytes <b>15</b>-<b>13</b> of BUCKET_#<b>0</b>, as shown at <b>516</b>. If BUCKET_#<b>1</b> was not valid at this time, the IAU would have to wait until it becomes valid.</p><p>As noted above, the Shift_<b>5</b>_byte signal was generated by the NID during \u03c6<b>2</b>. Based on this signal, bytes <b>12</b>-<b>5</b> of BUCKET_#<b>0</b> are shifted out by the ALIGN SHIFTER, as shown at <b>518</b>, and shortly thereafter are latched into ALIGN_IR<b>1</b>, as shown at <b>520</b>.</p><p>Bytes <b>12</b>-<b>5</b> are sent to the STACK <b>334</b> and the NID <b>324</b> by the MUX <b>322</b> at the beginning of \u03c6<b>3</b>. The STACK feeds bytes <b>12</b>-<b>5</b> back to the ALIGN SHIFTER as shown at <b>336</b>, and the NID determines the length of OP<b>1</b> to be 3 bytes and outputs the Shift_<b>3</b>_bytes signal during the latter half of \u03c6<b>3</b>, as shown in trace \u201c9\u201d at <b>522</b>. The ALIGN SHIFTER shifts 3 bytes (<b>15</b>-<b>8</b>), and this amount is added to the COUNTER SHIFTER.</p><p>The above process then repeats. Once an instruction advances beyond BUCKET_#<b>0</b> (i.e., BUCKET_#<b>0</b> is completely used), BUCKET_#<b>1</b> will become BUCKET_#<b>0</b> and a new BUCKET_#<b>1</b> will later become valid.</p><p>Trace \u201c10\u201d in the timing diagram shows the timing for extraction of bytes from the instruction stream. The Buf_Count#<b>0</b> blocks represent the stored extract shift amount. During each phase the aligned shift amount is added to Buf_Count#<b>0</b>, and the result becomes the extract shift amount during the next phase (see the blocks labeled COUNTER_SHIFT).</p><p>Trace \u201c11\u201d in the timing diagram shows instruction alignment timing. The blocks labeled IR_Latch_#<b>0</b> and IR_Latch_#<b>1</b> represent the time during which the instructions in the corresponding ALIGN_IR latch become valid. The small blocks labeled MUX<b>1</b> represent the time when the MUX <b>322</b> begins to select the valid align latch. The small blocks labeled MUX<b>2</b> represent the time when the MUX <b>330</b> begins to select the shift amount determined by the NID <b>324</b>. Finally, the blocks labeled ALIGN_SHIFT represent the time when the ALIGN SHIFTER begins to output the instruction.</p><p>Prefixes are extracted using the same technique by which instructions are aligned, but the output of PD <b>328</b> is selected by MUX <b>330</b> rather than the output of NID <b>324</b>.</p><p>A block diagram of a section of the STACK <b>334</b> is shown in FIG. <b>6</b>. The STACK comprises 64 1-bit stacks that are arranged in parallel. Each 1 bit stack <b>600</b> comprises two latches <b>602</b> and <b>604</b>, and a three input MUX <b>606</b>. The aligned instructions are input to the latches and the MUX on a bus <b>607</b> labeled IN. The loading of the two latches may be done independently on either clock phase. In addition, the MUX <b>606</b> has three MUX control lines <b>608</b> to select the output of either latch, or bypass the IN data directly to an output <b>610</b> labeled OUT.</p><p>The IAU may periodically transfer to a different instruction stream. The STACK allows the IAU to store two sets of 8 bytes of instruction data from the MUX <b>322</b>. This feature is generally used during CISC instruction emulation. When the IAU must branch to process a microcode routine for emulation of a complex CISC instruction, the state of the IAU can be stored and re-initiated once the emulation of the CISC instruction is completed.</p><p>The \u00bd cycle data delay <b>316</b> is used to delay the immediate data and displacement information. Placing the delay in the IAU before the shifters pipelines the immediate data and displacement logic in order to do the shift during the following phase, rather than determining the instruction length and the shift in the same half cycle. The operations can be spread across the cycle, thus making the timing requirement easier to meet for that logic. The IDDD block <b>326</b> controls the IMM Shifter <b>312</b> and the DISP Shifter <b>314</b> to extract the immediate data and displacement data from the instructions. For example, if the first 3 bytes of the instruction are opcode, followed by 4 bytes of displacement and 4 bytes of immediate data, the shifters would be enabled to shift out the appropriate bytes.</p><p>The shifters <b>312</b> and <b>314</b> always output 32 bits whether the actual data size is 8, 16 or 32 bits, with the immediate and displacement data appropriately aligned to the low order bits of the 32 bit output. The IDU determines whether the immediate and displacement data is valid, and if so, how much of the data is valid.</p><p>The determination of the length of any prefixes, immediate data, displacement data, and the actual length of the instructions is a function of the actual CISC instruction set being aligned and decoded. This information may be obtained by one skilled in the art by studying the CISC instruction set itself, the manufacture's user manuals, or other common reference material. Those skilled in the art will readily recognize how to accomplish this, as well as how to convert the information into random logic to implement the above described IAU subsystem, the IDU subsystem described below, and how to generate the control logic and signals used to control data flow.</p><p>Furthermore, once such random logic is generated, commercially available engineering software applications (e.g., Verilog manufactured by Cadence Design Systems, Inc., San Jose, Calif.), may be used to verify the logic, and can aid in defining the timing and generation of the control signals and associated random logic. Other commercially available engineering software applications are available to generate gate and cell layouts to optimize the implementation of the functional blocks and control logic.</p><p>The i486\u2122 instruction set supports 11 prefixes that have a defined order when used together in an instruction. The format defines that up to four prefixes can be included in a single instruction. Thus, the PREFIX DETECTOR <b>328</b> of the present invention comprises four identical prefix detect circuits. Each circuit looks for any of the 11 prefix codes. The first four bytes passed to the prefix detector are evaluated, and the outputs of the four prefix detect circuits are combined to determine the total number of prefixes present. The result is used as the shift amount that is passed through the MUX <b>330</b>.</p><p>A block diagram of the NID is shown in FIG. <b>7</b>A. The following discussion of the NID is specific to alignment of i486\u2122 instructions. Alignment of other CISC instructions would likely employ a different NID architecture. The techniques discussed below should therefore serve as a guide to those skilled in the art, but should not be considered to limit the scope of the present invention.</p><p>Only 4 bytes are required to determine the length of an instruction. (As noted above, the 4 bytes comprise two Opcode bytes, an optional ModR/M byte and a SIB byte.)</p><p>FIG. 7A shows a 4 byte (32 bit) bus <b>701</b> representing the first 4 bytes of an instruction received from the MUX <b>322</b>. The first 2 bytes are sent to the SNID <b>702</b> on a bus <b>703</b>. The SNID determines the length of a first subset of instructions that are, by definition, identifiable based on the first 2 bytes. The SNID can determine the length of this subset of instructions in a half cycle. The length of the subset instructions is output by the SNID on a bus <b>705</b>. The width of the bus may correspond to the maximum number of instruction bytes detected by the SNID. The SNID also has a 1 bit MOD DETect (MOD_DET) output line <b>707</b> to indicate whether a ModR/M byte is present in the instruction. In addition, the SNID has a 1 bit NID_WAIT line <b>709</b> to signal the control logic that the instruction is not in the subset (i.e., use the RNID's output instead). The IAU must therefore wait a half cycle for the RNID to decode the instruction if NID_WAIT is true.</p><p>The subset of instructions decoded by the SNID are those CISC instructions that can be decoded in a half cycle using a minimum of 1, 2 and 3 input gates (NANDS, NORs and inventors), with a maximum of 5 gate delays based on an 16\u00d716 Karnaugh map of the 256 instructions. Blocks of the map including most 1 byte opcode instructions can be implemented in this fashion. The remainder of the instructions are decoded by the RNID using a logic array with a longer gate delay.</p><p>The RNID <b>704</b> receives the first 4 bytes on the bus <b>701</b>. The RNID performs length determination decoding for the remaining instructions that requires more that one phase to decode. The RNID has outputs that are similar to the outputs of the SNID.</p><p>The RNID detects instruction lengths and outputs the result on a bus <b>711</b>. A 1 bit OVER<b>8</b> output <b>712</b> indicates that the instruction is over 8 bytes in length. The RNID also has a 1 bit MOD_DET output <b>714</b> that indicates whether the instruction includes a ModR/M byte.</p><p>The length decoded by either the SNID or the RNID is selected by a MUX <b>706</b>. A control line <b>708</b> for the MUX <b>706</b>, called SELect_DECoder for current InstRuction (SELDECIR), switches the MUX <b>706</b> between the two decoders to get the actual length which is 1 to 11 bytes. An 11 byte-long instruction, for example, would cause the RNID to output the OVER<b>8</b> signal and a 3 on bus <b>711</b>. The instruction length (In) is sent to the MUX <b>330</b> on a bus <b>716</b>, and is used by the ALIGN SHIFTER <b>310</b> and the COUNTER SHIFTER <b>332</b>. The 8 bits output by the top MUX <b>706</b> are used as shift controls (enables) for the ALIGN and COUNTER SHIFTERs.</p><p>The ModR/M bytes are also selected in a similar fashion. The SELDECIR signal <b>708</b> controls a second MUX <b>710</b> to choose the appropriate MOD line to indicate whether a ModR/M byte is present The MOD line output <b>718</b> is used by the IDDD.</p><p>The SELDECIR signal <b>708</b> is generated based on the NID_WAIT signal <b>709</b>. The output of the SNID is selected during the first clock phase because those results will be complete. If the NID_WAIT signal <b>709</b> indicates that the instruction was not decoded, the MUXs <b>706</b> and <b>710</b> are switched to select the output <b>711</b> of the RNID, which will become available at the beginning of the next clock phase.</p><p>The RNID <b>704</b> essentially comprises two parallel decoders, one decodes the instructions as if there is a 1 byte opcode and the other decodes as if there is a 2 byte opcode. An ESCape DETect (ESC_DET) input signal indicates whether the opcode is 1 byte or 2 bytes in length. For example, in the i486\u2122 instruction set, the first byte in all 2 byte opcodes (called the ESCAPE byte) has the value 0F hex that indicates the instruction has a 2 byte opcode. The RNID outputs a valid instruction length based on an ESC_DET signal. This signal indicates that the first opcode byte is an ESCAPE (0F hex), which indicates a 2 byte opcode, thereby enabling the second byte decoder. Decoding logic for generating the ESC-DET signal should be evident to those skilled in the art.</p><p>A block diagram of the RNID is shown in FIG. <b>7</b>B. The RNID comprises an RNID_<b>1</b>OP decoder <b>752</b>, which decodes the first opcode byte, an RNID_<b>2</b>OP decoder <b>754</b>, which decodes the second opcode byte, two identical RNID_MOD decoders <b>756</b> and <b>758</b>, which decode the ModR/M bytes in either of the two positions determined by the number of opcode bytes present, and an RNID_SUM summer <b>760</b>. Based on the outputs of the four RNID decoders <b>752</b>-<b>758</b>, the RNID_SUM summer <b>760</b> outputs the total length of the instruction on a bus <b>762</b>. The RNID_SUM summer <b>760</b> has an additional output line <b>764</b> labeled OVER<b>8</b>, to indicate whether the instruction is over 8 bytes in length.</p><p>The first opcode byte of the instruction and 3 bits (bits [<b>5</b>:<b>3</b>] called extension bits) of the ModR/M byte are input to the RNID_<b>1</b>OP <b>752</b> on a bus <b>766</b>. A further input line <b>768</b> called DATA_SZ to the RNID_<b>1</b>OP indicates whether the operand size of the instruction is 16 or 32 bits. The data size is determined based on the memory protection scheme used, and whether prefixes are present to override the default data size. RNID_<b>1</b>OP assumes that the instruction has a 1 byte opcode, and based on that information and the 3 extension bits, RNID_<b>1</b>OP attempts to determine the length of the instruction.</p><p>The RNID_MOD decoder <b>754</b> decodes the ModR/M byte of the instruction input on a bus <b>770</b>. The RNID_MOD decoder has an additional input bus <b>772</b> labeled ADD_SZ, which indicates whether the address size is 16 or 32 bits. The address size is independent of the data size.</p><p>The ESC_DET signal <b>774</b> is also input to block <b>760</b>. When the ESC_DET signal is logic HIGH, for example, the RNID_SUM block knows that the opcode is actually in the second byte.</p><p>The RNID_<b>2</b>OP decoder <b>754</b> assumes that the opcode is 2 bytes, and therefore decodes the second byte (see bus <b>776</b>) of the opcode. RNID_<b>2</b>OP decoder also has the input <b>768</b> identifying the data size.</p><p>Since the decoders themselves do not know the length of the opcode, i.e., 1 or 2 bytes, and since the ModR/M byte always follows the opcode, the second RNID_MOD decoder <b>758</b> is used to decode the byte (see bus <b>778</b>) following the 2 byte opcode, again assuming that it is there. The two RNID_MOD decoders are identical, but decode different bytes in the instruction stream.</p><p>Again, based on the ESC_DET signal <b>774</b>, the RNID_SUM <b>760</b> selects the outputs of the appropriate opcode and ModR/M byte decoders, and outputs the length of the instruction on bus <b>762</b>. The output <b>764</b> labeled OVER<b>8</b> indicates whether the instruction is over 8 bytes. If the instruction is over 8-bytes in length, the IR_NO[<b>7</b>:<b>0</b>] bus <b>762</b> indicates the number of instruction bytes over 8.</p><p>The RNID_<b>1</b>OP decoder <b>752</b> has an output bus <b>780</b> that is 9 bits wide. One line indicates whether the instruction is 1 byte long. The second line indicates that the instruction is 1 byte long and that a ModR/M byte is present, and thus, information from the ModR/M decoder should be included in the determination of the length of the instruction. Similarly, the remaining output lines of bus <b>780</b> indicate the following number of bytes: 2, 2/MOD, 3, 3/MOD, 4, 5, and 5/MOD. If the instruction is 4-bytes long there cannot be a ModR/M byte; this is inherent in the i486\u2122 instruction set. However, the present invention is in no way limited to any specific CISC instruction set. Those skilled in the art will be able to apply the features of the present invention to align and decode any CISC instruction set.</p><p>The RNID_<b>2</b>OP decoder <b>754</b> has an output bus <b>782</b> that is 6 bits wide. One line indicates whether the instruction is 1 byte long. The second line indicates that the instruction is 1 byte long and includes a ModR/M byte, which should be included in the determination of the length of the instruction. Similarly, the remaining output lines of bus <b>782</b> indicate that there are 2, 2/MOD, 3, and 5/MOD. There are no other possible instruction lengths supported by the i486\u2122 instruction set if the opcode is 2 bytes long.</p><p>Outputs <b>784</b> and <b>786</b> of the two RNID_MOD decoders <b>756</b> and <b>758</b> indicate to the RNID_SUM <b>760</b> the five possible additional lengths that can be specified by the ModR/M byte. Each RNID_MOD decoder has a 5 bit wide output bus. The five possible additional lengths are: 1, 2, 3, 5 and 6-bytes. The ModR/M byte itself is included in the total length determination. Any remaining bytes comprise immediate or displacement data.</p><p>FIG. 8 shows a block diagram of the IDDD <b>326</b>. The IDDD determines the shift amounts for the IMM SHIFTER <b>312</b> and the DISP SHIFTER <b>314</b>. The shift amount is determined by the ModR/M byte of the instruction.</p><p>The i486\u2122 instruction set includes two special instructions, the enter_detect and jump_call_detect instructions. The IDDD therefore has a block called the Immediate Special Detector (ISD) <b>802</b> to handle decoding of these instructions. An input <b>803</b> to the ISD is the first byte of the instruction. Two output lines EN_DET and JMP_CL_DET (<b>820</b> and <b>822</b>, respectively) indicate whether one of the corresponding instructions is detected.</p><p>MOD_DEC decoders <b>804</b> and <b>806</b> are identical and decode the immediate and displacement data. Based on ADD_SZ <b>772</b>, decoder <b>804</b> looks at the ModR/M byte assuming a 1 byte opcode and decoder <b>806</b> looks at the ModR/M byte assuming a 2 byte. The instruction byte inputs to MOD_DEC <b>804</b> and <b>806</b> are <b>805</b> and <b>807</b>, respectively. These decoders determine the displacement position and the immediate data position in the instruction stream. Two seven line outputs <b>824</b> and <b>826</b> indicate at what position the displacement and immediate data starts: the displacement can start at position two or position three; and immediate data can start at position two, three, four, six or seven.</p><p>The MOD_DET lines <b>707</b> and <b>714</b> are also input to the SELECT block <b>812</b>.</p><p>The SELECT block <b>812</b> combines the EN_DET and JMP_CL_DET signals, the MOD_DET and MOD_DEC results, and the ADD_SZ and outputs its results on four buses <b>832</b>-<b>838</b>. A DISPlacement <b>1</b> (DISP_<b>1</b>) bus <b>832</b> outputs the displacement shift results assuming a 1 byte opcode. A DISPlacement <b>2</b> (DISP_<b>2</b>) bus <b>834</b> outputs the displacement shift results assuming a 2 byte opcode. IMMediate <b>1</b> and <b>2</b> (IMM_<b>1</b> and IMM_<b>2</b>) buses <b>836</b> and <b>838</b> output the immediate data shift information assuming a 1 byte and a 2 byte opcode, respectively.</p><p>A last block <b>814</b> labeled MOD_SEL/DLY actually selects the appropriate shift amounts and delays these results a half cycle. The half cycle delay performed by MOD_SEL/DLY <b>816</b> represents the delay <b>316</b> shown in FIG. <b>3</b>. The ESC_DET signal <b>774</b> described above is used by the MOD_SEL/DLY block to perform the shift selection. The results are clocked out of the MOD_SEL/DLY <b>814</b> by the clock signals CLK<b>0</b> and CLK<b>1</b> after a half cycle delay. The immediate data shift control signal and the displacement shift control signal are sent to the DISP SHIFTER and the IMM SHIFTER via a SHIFT_D[<b>3</b>:<b>0</b>] bus <b>840</b> and a SHIFT_I[<b>7</b>:<b>0</b>] bus <b>842</b>, respectively. The number of possible positions within the CISC instruction of the immediate and displacement data define the number of bits required to specify the amount of shift.</p><p>A block diagram of the PREFIX DETECTOR <b>328</b> is shown in FIG. <b>9</b>. The PREFIX DETECTOR <b>328</b> comprises a Prefix_Number decoder (PRFX_NO) <b>902</b>, four Prefix_Detector decoders (PRFX_DECs <b>904</b>-<b>910</b>), and a Prefix_Decoder (PRFX_SEL) <b>912</b>.</p><p>The i486\u2122 instruction set, for example, includes 11 possible prefixes. Four total prefixes can be included per instruction, because there are several invalid prefix combinations. The ordering of the four prefixes is also defined by the instruction set. However, rather than detect only the legitimate prefix permutations, the PREFIX DETECTOR uses the four prefix detectors <b>904</b>-<b>910</b> to decode each of the first 4 bytes of the instruction. The first 4 bytes of the instruction are input to the PREFIX DETECTOR on a bus <b>901</b>. Each detector <b>904</b>-<b>910</b> has an output bus (<b>905</b>, <b>907</b>, <b>909</b> and <b>911</b>, respectively) that is 12 bits wide. The 12 outputs indicate which prefix(es) are present, if any are actually decoded at all. The twelfth prefix is called UNLOCK, which is the functional complement of the i486\u2122 LOCK prefix, and is only available to microcode routines during emulation mode.</p><p>An ALIGN_RUN control signal <b>920</b> may be included to enable/disable the prefix decoder, and can be used to mask-out all of the prefixes. A HOLD_PRFX control signal <b>922</b> is used to latch and hold the prefix information. Generally, for alignment of an instruction if the PREFIX DETECTOR <b>328</b> indicates that there are prefixes present, the control logic must latch the prefix information. The prefix information is then used by the ALIGN SHIFTER <b>310</b> to shift-out the prefixes. In the following cycle, the IAU determines the length of the instruction, aligns it, and passes it to the IDU.</p><p>The PRFX_NO decoder <b>902</b> indicates where and how many prefixes are present by decoding the first 4 bytes of the opcode. A logic diagram of the PRFX_NO decoder <b>902</b> is shown in FIG. <b>10</b>. The PRFX_NO decoder comprises four identical decoders <b>1002</b>-<b>1008</b> and a set of logic gates <b>1010</b>. The four decoders <b>1002</b>-<b>1008</b> each look at one of the first four bytes (<b>1010</b>-<b>1013</b>) and determine if a prefix is present. Since it is possible for a prefix byte to follow an opcode byte, the logic gates <b>1010</b> are used to output a result representing the total number of prefixes before the first opcode byte, because prefixes following an opcode apply only to the next instruction's opcode.</p><p>The total number of prefixes is one if the first byte (position) is a prefix and there is no prefix in the second position. As a further example, a prefix in the fourth position does not matter, unless there are prefixes in the first three positions. A logic HIGH (1) output from the bottom NAND <b>1014</b> gate indicates that there are four prefixes; a HIGH output from the second last NAND gate <b>1015</b> indicates that there are three prefixes, and so on. The four NAND gate outputs are combined to form a PREFIX_NO bus <b>1018</b> to indicate the total number of valid prefixes that precede the first opcode byte, i.e, the shift amount output of the PREFIX DETECTOR <b>328</b>.</p><p>The PRFX_NO decoder <b>902</b> also includes a Prefix_Present (PRFX_P) output bus <b>1020</b> (which is also 4 bits wide). Four PRFX_P output lines <b>1020</b>-<b>1023</b> indicate whether or not there is a prefix in the given position, regardless of what the other positions output. The PRFX_P outputs are tapped directly off the four decoder (<b>1002</b>-<b>1008</b>) outputs.</p><p>The PRFX_NO decoder results (to be discussed in connection with FIG. 10) and the information from the PRFX_DEC detectors <b>904</b>-<b>910</b> are combined by the PRFX_SEL decoder <b>912</b>. The prefix information is combined to form one 13 bit output bus <b>924</b> that indicates whether or not there are prefix signals and which prefixes are present.</p><p>3.0 Instruction Decode Unit Overview</p><p>All instructions are passed from the IAU to an Instruction Decode Unit (IDU), and are directly translated into RISC instructions. All instructions to be executed by the IEU are first processed by the IDU. The IDU determines whether each instruction is an emulated or a basic instruction. If it is emulated, the microcode emulation routine consisting entirely of basic instructions is processed. If the instruction is basic, it is directly translated by hardware into one to four nano-instructions and sent to the IEU. It is these nano-instructions, rather than the original CISC or microcode instructions, that the IEU actually executes.</p><p>The partitioning of instructions has two key benefits: the hardware is kept small because it only needs to support simple operations, and bugs are less troublesome because they are more likely to occur in the complex microcode routines, which can easily be changed.</p><p>The IDU's microcode routine support hardware in conjunction with the present invention has several features which make it unique. Typically, microcode instructions consist of control bits for the various datapaths present in a processor, with little or no encoding. The microcode of the present invention, in contrast, is a comparatively high-level machine language designed to emulate a specific complex instruction set. Whereas typical microcode is routed directly to a processor's function units, the microcode of the present invention is processed by the same decoder logic that is used for the target CISC (e.g., 80\u00d786) instructions. This gives the microcode of the present invention much better code-density than is achieved by typical microcode, and makes the microcode easier to develop due to its similarity with the target CISC instruction set. Furthermore, the present invention provides hardware support for microcode revisions: part or all of the on-chip ROM-based microcode can be replaced with external RAM-based microcode under software control. (See commonly owned, co-pending application titled, \u201cA ROM With RAM Cell and Cyclic Redundancy Check Circuit\u201d, Ser. No. 07/802,816, filed Dec. 6, 1991, Attorney Docket No. SP024; the disclosure of which is incorporated herein by reference.)</p><p>The microcode routine language is designed to be a set of instructions that can be executed by the RISC core to perform the functions required by all of the complex emulated instructions, plus the various control and maintenance functions associated with exception handling. Although emulated instructions are typically less performance sensitive than non-emulated (basic) instructions, and exceptions, (which are handled by microcode routines) occur infrequently, it is still critical to the overall system throughput that both be handled efficiently. This goal is achieved through the use of various forms of hardware support for the microcode routines. The present invention comprises four areas of hardware support for microcode: dispatch logic, mailboxes, a nano-instruction format, and special instructions.</p><p>The microcode dispatch logic controls the efficient transfer of program control from the target CISC instruction stream to a microcode routine and back to the target instruction stream. It is handled with a small amount of hardware, and in a manner that is transparent to the RISC core's Instruction Execution Unit (IEU). (The IEU executes the RISC instructions. The \u201cRISC core\u201d mentioned above is synonymous with the IEU. The details of the IEU are not necessary for one skilled in the art to practice the present invention. The features of the present invention are applicable to RISC processors in general.)</p><p>The mailboxes comprise a system of registers used to transfer information from the instruction decode hardware to microcode routines in a systematic way. This allows the hardware to pass instruction operands and similar data to the microcode routines, saving them the task of extracting this data from the instruction.</p><p>The nano-instruction format describes the information that passes from the IDU to the IEU. This format was chosen to allow it to be efficiently extracted from the source CISC instructions, but still provide adequate information to the IEU for dependency checking and function unit control.</p><p>Finally, the special instructions are a set of additional instructions provided to allow complete control of the RISC hardware and support certain unique emulation tasks in hardware, and are CISC instruction set specific.</p><p>3.1 Microcode Dispatch Logic</p><p>The fist step in dispatching to microcode is to determine the address of the microcode routine. This step has two important requirements: each microcode routine must have a unique starting address, and these addresses must be generated quickly. This is fairly easy to achieve for exception handling routines, since the small number of cases that must be handled allows the hardware to store the addresses as constants and merely select between them. Determining the addresses for emulated instructions is more difficult, however, because there are too many to make storing all the addresses feasible.</p><p>The microcode dispatch logic meets the requirements by basing each instruction's dispatch address directly on its opcode. For example, one-byte opcodes are mapped into the address space from 0H to 1FFFH, requiring that the upper three bits of the 16 bit dispatch address be zeroes. These microcode entry points are spaced 64 bytes apart, which requires the six least-significant bits of each entry point address to be zero. This leaves 7 bits undetermined, and they can be taken directly from seven of the opcode bits. Generating the address in this way requires very little logic, as will become evident to those skilled in the art. For example, a multiplexer alone can be used to select the proper bits from the opcode.</p><p>Once the dispatch address for a microcode routine has been determined, the microcode must be fetched from memory. Typically, microcode resides in on-chip ROM, but this is not necessarily the case. As detailed in the above referenced application Ser. No. 07/802,816, each entry point is associated with a ROM-invalid bit which indicates whether or not the ROM routine is correct. This bit is fetched in parallel with the ROM access, and functions similarly to a conventional cache-hit indicator. If this bit indicates that the ROM entry is valid, the microcode routine will continue to be fetched from ROM and executed normally. If the bit indicates that the ROM is invalid, however, the microcode is fetched from external memory, such as RAM or the like.</p><p>On chip microcode routine addressing is handled by the IDU itself. The IDU generates 16 bit addresses for accesses to the microcode ROM. If the ROM-invalid bit corresponding to the ROM entry being addressed indicates that the microcode is invalid, the address of external microcode residing off-chip in main memory is calculated. A U_Base register holds the upper 16 address bits (called the starting address) of the external microcode residing in main memory. The 16 bit address decoded by the IDU is concatenated with the upper 16 bits in the U_Base register to access the external microcode residing in main memory. If the location of the external microcode residing in main memory is changed, the contents of the U_Base register can be modified to reflect the new main memory location.</p><p>This feature allows microcode updates to be performed by replacing certain routines with alternates in external memory, without forcing all microcode to suffer the reduced performance of external memory accesses. It also makes it possible to remove all ROM from the RISC chip and place the entire microcode in external RAM, to reduce the RISC chip's area requirements or to aid in microcode development.</p><p>The dispatch logic is also responsible for providing a means for the microcode routine to return to the main instruction stream when its task is finished. To handle this, separate Program Counters (PC's) and instruction buffers are maintained. During normal operation, the main PC determines the address of each CISC instruction in external memory. A section of memory containing these instructions is fetched by the IFU and stored in the MBUF.</p><p>When an emulated instruction or exception is detected, the PC value and length of the current instruction are stored in temporary buffers, while the microcode dispatch address is calculated as described above and instructions are fetched from this address into the EBUF. Microcode is executed from the EBUF until a microcode \u201creturn\u201d instruction is detected, at which time the preserved PC value is reloaded, and execution continues from the MBUF. Since the MBUF and all other related registers are preserved during the transfer of control to the microcode routine, the transfer back to the CISC program happens very quickly.</p><p>There are two return instructions used by microcode routines to support the differences between instruction emulation routines and exception handling routines. When the microcode routine is entered for the purpose of handling an exception, it is important that after the routine is finished, the processor should return to the exact state in which it was interrupted. When the microcode routine is entered for the purpose of emulating an instruction, however, the routine wants to return to the instruction following the emulated instruction. Otherwise, the emulation routine will be executed a second time. These two functions are handled by the use of two return instructions: aret and eret. The aret instruction returns the processor to its state when microcode was entered, while the eret instruction causes the main PC to be updated and control to return to the next instruction in the target stream.</p><p>3.2 Mailboxes</p><p>For emulation routines to successfully perform the functions of a complex CISC instruction, it is necessary that the microcode have convenient access to the operands referenced by the emulated instruction. In the present invention, this is performed through the use of four mailbox registers. These registers are unique in their use only, they are defined to be the first four of a set of sixteen temporary registers in the integer register file that are available to microcode. Each emulation routine that requires operands or other information from the original instruction can expect to find these values stored in one or more of the mailbox registers upon entry into the routine. When the IDU detects an emulated instruction, it generates instructions which are used by the IEU to load the registers with the values that microcode expects, before execution of the microcode routine itself begins.</p><p>For example, consider the emulation of the Load Machine Status Word instruction (lmsw), which specifies any one of the general registers as an operand. Assume the specific instruction to be emulated is lmsw ax, which loads a 16 bit status word from the \u201cax\u201d register. The same microcode routine is used regardless of the register actually specified in the instruction, so for this instruction mailbox#<b>0</b> is loaded with the status word before microcode entry. When the IDU detects this instruction, it will generate a mov u0,ax instruction for the IEU to move the status word from the \u201cax\u201d register to the \u201cu0\u201d register, which is defined to be mailbox #<b>0</b>. After this mov instruction is sent to the IEU, the microcode routine will be fetched and sent. Thus, the microcode can be written as if the emulated instruction were lmsw u0, and it will correctly handle all of the possible operands that may be specified in the original CISC instruction.</p><p>3.3 Nano-Instruction Format</p><p>As mentioned above, CISC instructions are decoded by the IDU into nano-instructions, which are processed by the RISC processor core, referred to as the IEU. Nano-instructions are passed from the IDU to the IEU in groups of four, called \u201cbuckets\u201d. A single bucket is shown FIG. <b>11</b>. Each bucket consists of two packets, plus general information pertaining to the entire bucket. Packet #<b>0</b> always contains three nano-instructions which are executed in-order: a LOAD instruction <b>1102</b>, an ALU-type instruction <b>1104</b>, and a STORE instruction <b>1106</b>. Packet #<b>1</b> consists of a single ALU-type instruction <b>1108</b>.</p><p>The IEU can accept buckets from the IDU at a peak rate of one per cycle. The IDU processes basic instructions at a peak rate of two per cycle. Since most basic instructions are translated into a single packet, two basic instructions can usually be placed in one bucket and passed to the IEU together. The primary restriction on this rate is that the basic instructions must match the requirements of a bucket:</p><p>only one of the two basic instructions can reference a memory operand (there is only one load/store operation per bucket), and</p><p>both instructions must consist of a single ALU-type operation (as opposed to one instruction requiring two ALU-type operations).</p><p>If one or both of these restrictions is violated, the bucket is sent to the IEU with nano-instructions corresponding to only one of the basic instructions, and the remaining instruction is sent in a later bucket. These requirements closely mirror the capabilities of the IEU, i.e., an IEU having two ALUs and one Load/Store unit, so in reality they do not present a limitation on performance. An example of this type of IEU is disclosed in commonly owned, co-pending applications titled, \u201cHigh-Performance, Superscalar-Based Computer System with Out-of-Order Instruction Execution\u201d, application Ser. No. 07/817,810, filed Jan. 8, 1992 now U.S. Pat. No. 5,539,911, and \u201cHigh-Performance, Superscalar-Based Computer System with Out-of-Order Instruction Execution and Concurrent Results Distribution\u201d, application Ser. No. 08/397,016 filed Mar. 1, 1995, now U.S. Pat. No. 5,560,032, which is a file wrapper continuation of application Ser. No. 07/817,809, filed Jan. 8, 1992, the disclosures of which are incorporated herein by reference.</p><p>3.4 Special Instructions</p><p>There are many functions that must be performed by microcode routines which are difficult or inefficient to perform using general-purpose instructions. Furthermore, due to the expanded architecture of the present RISC processor compared to conventional CISC processors, certain functions are useful, whereas such functions would be meaningless for an CISC processor, and thus cannot be performed using any combination of CISC instructions. Together, these situations led to the creation of \u201cspecial instructions\u201d.</p><p>An example of the first category of special instructions is the extract_desc_base instruction. This instruction extracts various bit-fields from two of the microcode general-purpose registers, concatenates them together and places the result in a third general register for use by microcode. To perform the same operation without the benefit of this instruction, microcode would have to perform several masking and shift operations, plus require the use of additional registers to hold temporary values. The special instruction allows the same functionality to be performed by one instruction during a single cycle, and without the use of any scratch registers.</p><p>Two examples of the second category of special instructions were already presented: the two return instructions, aret and eret, used to end microcode routines. These instructions are only meaningful in the microcode environment, and thus have no equivalent instructions or instruction sequences in the CISC architecture. In this case, special instructions were required for correct functionality, not just for performance reasons.</p><p>Since the special instructions are only available to microcode routines, and emulated instructions can only be encountered in the target CISC instruction stream, the opcodes of emulated instructions are re-used in microcode mode for the special instructions. Thus, when one of these opcodes is encountered in the target CISC instruction stream, it merely indicates that the microcode emulation routine for that instruction should be executed. When the same opcode is encountered in the microcode instruction stream, however, it has a completely different function as one of the special instructions. To support this opcode re-use, the IDU keeps track of the current processor state and decodes the instructions appropriately. This re-use of the opcodes is transparent to the IEU.</p><p>The IDU decodes each CISC instruction (of the i486\u2122 instruction set, for example) and translates each instruction into several RISC processor nano-instructions. As described above, each CISC instruction is translated into 0 to 4 nano-instruction(s), depending on its complexity and functionality. The IDU decodes and translates two CISC instructions per cycle at best case. The basic functions of the IDU can be summarized as follows, it functions to:</p><p>Decode one CISC instruction per half cycle;</p><p>Decode the 1st CISC instruction in a first phase;</p><p>Hold as valid the decoded results of the 1st CISC instruction through the second phase;</p><p>Decode the 2nd CISC instruction in the second phase;</p><p>Combine the outputs of two instructions, if possible in the third phase; and</p><p>Output one bucket comprising four nano-instructions per cycle.</p><p>3.5 Instruction Decode Unit Block Diagrams</p><p>A block diagram of the IDU is shown in FIG. <b>12</b>. Aligned instructions from the IAU arrive at the IDU on a bus <b>1201</b> which is 32 bits wide ([<b>31</b>:<b>0</b>] or 4 bytes). The aligned instructions are received by an Instruction Decoder <b>1202</b>. The IDU <b>1202</b> only looks at the first four bytes of an aligned instruction in order to perform the CISC to RISC transformation.</p><p>The Instruction Decoder <b>1202</b> operates in one clock phase (a half cycle). The aligned instruction goes through the decoder and the decoded information that exits is MUXed and fed into a half cycle delay latch <b>1204</b> via a bus <b>1203</b>. The decoded information therefore experiences the equivalent to a one phase pipeline delay.</p><p>After the half cycle delay, the decoded information is sent via a bus <b>1205</b> to a MUX <b>1206</b> to determine the actual register codes used. At this stage of decoding, the decoded information is arranged in the nano-instruction format. The nano-instruction is then latched. Two complete nano-instruction buckets are latched per cycle. The latching of two nano-instruction buckets is shown diagrammatically by 1st IR and 2nd IR buckets <b>1208</b> and <b>1210</b>, respectively.</p><p>The IDU attempts to assemble buckets <b>1208</b> and <b>1210</b> into a single bucket <b>1212</b>. This assembly is performed by a set of control gates <b>1214</b>. The IDU first looks at the TYPE of each nano-instruction, and determines if the TYPEs are such that they can be combined. Note that either LoaD (LD) operation of the two latched instructions can be placed in a LD location <b>1216</b> of the single bucket <b>1212</b>; either STore (ST) operation of the latched instructions can be placed in a ST location <b>1218</b> of the single bucket; either A<b>0</b> operation can be placed in an A<b>0</b> location <b>1220</b>; and any A<b>0</b> or A<b>1</b> operation can be placed in an A<b>1</b> location <b>1222</b>.</p><p>The IDU treats the instructions as a whole. If the IDU cannot pack the two instructions into one bucket, it will leave one complete instruction behind. For example, if the 1st IR latch has only an A<b>0</b> operation, and the 2nd IR latch includes all four operations, the IFU will not take the A<b>1</b> from the 2nd IR latch and merge it with the A<b>0</b> operation. The A<b>0</b> operation will be sent by itself and the 2nd IR latch's set of operations will be transferred to the 1st IR latch and sent on the next phase, during which time the 2nd IR latch is reloaded. In other words, the operations stored in the 1st IR latch will always be sent, and the operations stored in the 2nd IR latch will be combined with the 1st IR latch operations if possible. The previous pipeline stages of the IDU and IAU must wait in the event that the 1st and 2nd IRs cannot be combined. The following situations permit the IDU to combine the 1st and 2nd IR latch operations:</p><p>both only use A<b>0</b>, or</p><p>one only uses A<b>0</b> and the other uses only A<b>0</b>, LD and ST.</p><p>Combination logic can readily be designed by those skilled in the art to generate the necessary control signals for the control gates to merge the content of the 1st and 2nd IR latches, based on the functionality discussed above and basic logic design practice.</p><p>Emulation mode is entered when the IDU identifies an instruction belonging to the subset of instructions requiring emulation. An EMULation MODE control signal (EMUL_MODE) is sent to the decoders of the IDU once emulation mode is entered. Direct decoding of the CISC instruction stops, and the microcode routine corresponding to the identified instruction is sent to the IDU for decoding. The IDU decoders return to basic mode for decoding further CISC instructions when the microcode routine is finished emulation of the subset instruction. Fundamentally, basic CISC instructions and microcode instructions are handled in the same way by the IDU. Only the interpretation of the opcode changes.</p><p>Karnaugh maps of the default (basic) mode for both 1 and 2 byte opcode instructions are shown at FIGS. 13A-13E. The numbers along the left hand side and the top of the Karnaugh maps represent the opcode bits. For example, a one-byte opcode coded as hex 0F corresponds to the first row and 11th column, which is the \u201c2 byte escape\u201d instruction.</p><p>The instruction boxes that are shaded gray in the Karnaugh map of FIGS. 13A-13E represent basic instructions and the white boxes are those instructions which must be emulated.</p><p>A block diagram of the IDU's Instruction Decoder <b>1202</b> is shown in FIG. <b>14</b>. The Instruction Decoder <b>1202</b> includes a plurality of decoders that are used to decode the CISC instructions and microcode routines.</p><p>A TYPE GENerator (TYPE_GEN) decoder <b>1402</b> receives the first full aligned instructions on the ALIGN_IR bus, and decodes instructions one at a time to identify the TYPE field of the instruction.</p><p>The identified TYPE field corresponds to the nano-instruction operations discussed above in connection with the IDU. The TYPE is signified by a 4 bit field representing each operation in a bucket (Load, ALU<b>0</b>, Store and ALU<b>1</b>). The TYPE_GEN decoder <b>1402</b> specifies which of those four operations are needed to execute the instruction. Depending on the instruction received, any number from 1-4 of the operations may be required to satisfy the CISC instruction.</p><p>For example, an add operation, which sums the contents in one register with the contents in another register, requires only one ALU nano-instruction operation. Alternatively, an instruction which requires the addition of the contents of a register with a memory location would require a Load, an ALU operation and then a Store operation, thus totalling three nano-instruction operations. (The data must be read from memory, added to the register, and then stored back in memory). More complicated CISC instructions may require all four nano-instructions.</p><p>The TYPE_GEN decoder <b>1402</b> comprises three TYPE decoders. A first decoder TYPE<b>1</b> assumes that the instruction has a one-byte opcode followed by the ModR/M byte, and computes the TYPE based on that assumption. A second decoder TYPE<b>2</b> assumes that the instruction has a two-byte opcode. The first byte being the ESCAPE byte, followed by the second byte which is the opcode and the third byte which is the ModR/M byte. A third decoder TYPEF assumes that the instruction is a floating point instruction, and decodes the instruction based on that assumption.</p><p>The TYPE_GEN decoder has three 4 bit wide TYPE instruction output buses (TYPE<b>1</b>, TYPE<b>2</b>, and TYPEF). Each bit corresponds to one of the 4 nano-instruction operations in a bucket. The specific TYPE field specifies which nano-instruction operations are necessary to carry out the CISC instruction. For example, if all 4 bits are logic HIGH, the CISC instruction requires a Load, a Store and two ALU operations.</p><p>The remaining decoders in FIG. 14 that include sections labeled <b>1</b>, <b>2</b> and F decode assuming a 1 byte opcode, a 2 byte opcode and a floating point instruction, respectively. The invalid results are merely not selected. A multiplexer selects the output of the correct decoder.</p><p>The two ALU operations (ALU<b>0</b> and ALU<b>1</b>) each have an opcode field which is 11 bits long. The 11 bits comprise the 8 bits of the opcode and three opcode extension bits from the adjacent ModR/M byte. For most CISC instructions processed by the IDU, the opcode bits are directly copied to the nano-instruction operations. Some CISC instructions, however, may require opcode substitution; here the IDU unit does not merely filter the CISC opcode to the instruction execution unit (IEU). This will become evident to those skilled in the art, because the type and number of functional units in the IEU will dictate whether or not opcode replacement is required within the IDU for specific CISC instructions.</p><p>In order for the IEU to process ALU operations, it must receive information concerning which functional unit is needed to process the specified ALU operation. The IDU therefore includes a Functional zero UNIT (F_<b>0</b>UNIT) decoder <b>1410</b>, which comprises decoders F_<b>0</b>UNIT<b>1</b>, F_<b>0</b>UNIT<b>2</b> and F_<b>0</b>UNITF. The outputs of the decoders are multi-byte fields that indicate which functional unit is necessary for processing the A<b>0</b> ALU operation. The functional unit decoding for the A<b>1</b> ALU operation is identical, but is handled by a separate decoder F_<b>1</b>UNIT <b>1412</b>.</p><p>Many CISC instructions carry out operations using registers that are implied by the opcode. For example, many instructions imply that the AX register is to be used as an accumulator. A ConSTant GENerator (CST_GEN) decoder <b>1414</b> is therefore included to generate register indices based on the opcode of the CISC instruction. The CST_GEN decoder specifies which register(s) are implied based on the specific opcode. Multiplexing for generating the correct source and destination register indices for the nano-instructions will be discussed below in conjunction with FIG. <b>15</b>.</p><p>An additional two bit control signal, TempCount (TC), is input to the CST_GEN decoder. The TC control signal is a two bit counter representing 4 temporary registers which may be cycled through for use as dummy registers by the IEU. The temporary (or dummy) registers represent another value of register that can be passed on by the CST_GEN decoder, in addition to the implied registers. The constant generator decoder passes on 4 constant fields because there are 2 ALU operations having 2 registers per operation. Each constant register bus is 20 bits wide, with each constant being a total of 5 bits, thereby permitting selection of one of the 32 registers in the IEU.</p><p>A SELect GENerator (SEL_GEN) decoder, shown generally at block <b>1416</b>, will now be discussed. The SEL_GEN decoder includes a FlaG Need Modify (FG_NM) decoder <b>1418</b>. The FG_NM decoder decodes for a one-byte opcode, a 2 byte opcode and a floating point instruction. In the i486\u2122 instruction set, for example, there are a total of 6 flags. These flags have to be valid before execution of some instructions begin, while the flags may be modified by some instructions. The FG_NM decoder outputs two signals per flag, one bit indicates whether the flag is needed for execution of this instruction and the other indicates whether or not this instruction actually modifies the flag.</p><p>Register INValiDation information concerning the ALU<b>0</b> and ALU<b>1</b> operations are decoded by an INVD<b>1</b> and an INVD<b>2</b> decoder, shown at <b>1420</b> and <b>1422</b> respectively. The INVD<b>1</b> and INVD<b>2</b> decoders are also part of the SEL_GEN decoder <b>1416</b>. INVD<b>1</b> and INVD<b>2</b> generate control signals for the IEU. These signals indicate whether the ALU registers should be used or not. Three possible register indices can be specified by each ALU operation. One can be used as a source and/or destination register, and the remaining two are limited to specifying source registers. A 4 bit field is uses to specify which register(s) are required by the operation.</p><p>The SEL_GEN decoder <b>1416</b> further includes a FLD_CNT decoder <b>1424</b> that indicates which of the register fields is required for the CISC instruction. The FLD_CNT decoder specifies which of the 2 fields is the source register and which is the destination register.</p><p>A Nano-InstRuction GENerator (NIR_GEN) decoder is shown generally as block <b>1426</b>. The data size (DATA_SZ) and address size (ADDR_SZ) input controls signals correspond to the default that the system is operating in. In order to decode the final address and operand size, the default mode must be known and the presence of any prefixes (discussed above in conjunction with the IAU) must be known. The EMUL_MODE control signal is also input to the NIR_GEN decoder, but it is also used by the other decoders.</p><p>The ESCape DETect (ESC_DET) input control signal is fed to the NIR_GEN decoder to indicate whether the instruction has a 2 byte opcode. In addition, a SELect OPcode EXTension (SEL_OP_EXT) input control signal is used to generate loading of the mailbox registers when an emulation instruction is detected.</p><p>A Floating Point REGister (FP_REG) input control signal passes the translated floating point register index to the IDU. The floating point format of the i486\u2122, for example, has eight registers for floating point numbers, but the registers are accessed like a stack. Accessing these registers is accomplished by using a stack accessing scheme: register<b>0</b> being the top of the stack, register<b>1</b> being the next top register, etc. This register stack is emulated by using eight linear registers with fixed indices. When the input instruction specifies register<b>0</b>, a translation block (not shown), translates the stack relative register index into the register index for the linear registers in a known manner. This permits the IDU to keep track of which register is on the top of the stack.</p><p>When the system branches to emulation mode, the IDU saves information about the instruction being emulated. The IDU saves the Data SIZE (EM<sub>13 </sub>DSIZE) and Address SIZE (EM_ASIZE) of the instruction, as well as the Register index of the DESTination (EM_RDEST), the source (EM_RDEST<b>2</b>) and the Base InDeX information (EM_BSIDX). This saved information is used by the microcode routine to properly emulate the instruction. Take for example the emulation of an add instruction. The microcode routine may check EM_ASIZE to determine the address size of the add instruction so that it knows what address size to emulate.</p><p>The NIR_GEN decoder <b>1426</b> includes a SIZE decoder <b>1428</b>. The fields generated by the SIZE decoder (i.e., SIZE<b>1</b>, SIZE<b>2</b> and SIZEF) indicate the address size, operand size and immediate data size of the instruction. An address size of 16 or 32 bits, an operand size of 8, 16 or 32 bits and an immediate data field size of 8, 16 or 32 bits are extracted for each instruction.</p><p>Another NIR_GEN decoder is called a LoaD INFormation (LD_INF) decoder <b>1430</b>. The LD_INF decoder decodes information corresponding to the Load and Store operations. The Load information is used for effective address calculations. The Load information fields (LD_INF<b>1</b>, LD_INF<b>2</b> and LD_INFF) can be used to specify which addressing mode is being used by the CISC instruction, since CISC instruction sets usually support many different addressing modes.</p><p>The i486\u2122 basic addressing mode includes a segment field and an offset which are added together to determine the address. An index register can be specified, as well as a scale for the index register (e.g., if the index registers are elements in an array), the elements can be specified as 1, 2, 4 or 8-bytes in length, thus the index register can be scaled by 1, 2, 4 or 8 before it is added to determine the address. The base and index are also specified by the LD_INF fields.</p><p>A Nano-InstRuction OPCode (NIR_OPC) decoder <b>1432</b> transfers opcode for the A<b>1</b> operation (packet<b>1</b>). The decoded fields (NIR_OPC<b>1</b>, NIR_OPC<b>2</b> and NIR_OPCF) comprise the first instruction byte (8 bits), plus three extension bits from the second byte.</p><p>A MIScellaneous OPCode (MISC_OPC) decoder <b>1434</b> indicates whether the instruction is a floating point instruction and whether a load instruction is actually present. The field generated by the MISC_OPC decoder will indicate whether conversion of the floating data is necessary. Multiplexing is not necessary for this decoder, because this information is easily extracted, regardless of the format of the instruction.</p><p>The opcode for the A<b>0</b> operation of packet<b>0</b> is specified by an OP_CODE decoder <b>1436</b>. The A<b>0</b> opcode is usually copied directly from the i486\u2122 input opcode, but for some instructions the opcode is replaced by an alternate opcode. (As noted above, the functionality of the signals generated by the NIR_GEN decoder are specific to the CISC instruction set being decoded, and thus should become evident to those skilled in the art upon review of the CISC instruction set and the nano-instruction format of the present invention.)</p><p>An EXT_CODE decoder <b>1440</b> extracts the 3 bit opcode extension from the ModR/M byte.</p><p>A IN_ORDER decoder <b>1442</b> decodes the instruction to determine whether the instruction must be executed \u201cin order\u201d. This instructs the IEU not to do anything with this instruction until all the previous instructions have been executed. Once the execution of the instruction is completed, execution of subsequent instructions is started.</p><p>A Control Flow Jump Size decoder <b>1444</b> indicates the displacement size for jumps that specify an address. This field, labeled CF_JV_SIZE, specifies the size of the address for the jump. This is specific to the type of addressing scheme employed by the CISC instruction set.</p><p>A 1 bit decoder labeled DEC_MDEST <b>1446</b> indicates whether or not the destination of the instruction is a memory address.</p><p>Finally, the Instruction Decoder includes three Register Code decoders <b>1438</b> to select the register codes (indices). The i486\u2122 instruction format encodes the index of the register fields in various places within the instruction. The indices of these fields are extracted by the RC decoder. The ModR/M byte also has two register indices, which are used as the destination/source as specified by the opcode itself. The Register Code decoder <b>1438</b> generates three RC fields RC<b>1</b>, RC<b>2</b> and RC<b>3</b>. RC<b>1</b> and RC<b>2</b> are extracted from the ModR/M byte as follows, if the processor is not in emulation mode, and that instruction is not a floating point instruction: RC<b>1</b>=bits [<b>2</b>:<b>0</b>] of the ModR/M byte; RC<b>2</b>=bits [<b>5</b>:<b>3</b>] of the ModR/M byte; and RC<b>3</b>=bits [<b>2</b>:<b>0</b>] of the opcode. For floating point instructions in basic (not emulation) mode, RC<b>1</b>, RC<b>2</b> and RC<b>3</b> are assigned as follows:</p><p>RC<b>1</b>: ST(<b>0</b>)=Top of stack;</p><p>RC<b>2</b>: ST(<b>1</b>)=Second item on stack=next to the top of the stack; and</p><p>RC<b>3</b>: ST(i)=The i<sup>th </sup>item from the stack, where i is specified in the opcode.</p><p>In emulation mode, RC<b>1</b>, RC<b>2</b> and RC<b>3</b> are assigned as follows:</p><p>RC<b>1</b>: bits [<b>4</b>:<b>0</b>] of byte <b>3</b>;</p><p>RC<b>2</b>: bits [<b>1</b>:<b>0</b>] of byte <b>2</b> and bits [<b>7</b>:<b>5</b>] of byte <b>3</b>; and</p><p>RC<b>3</b>: bits [<b>6</b>:<b>1</b>] of byte <b>2</b>.</p><p>FIG. 15 shows a representative block and logic gate diagram for the CST_GEN, NIR_GEN and SEL_GEN decoders (<b>1414</b>, <b>1438</b> and <b>1424</b> respectively). It should be understood that this FIG. 15 is an example of how the 1 byte opcode, 2 byte opcode and floating point decoded results are selected, delayed, and combined to generate source and destination register indices for nano-instruction operations A<b>0</b> and A<b>1</b>, and the destination register index for the Load instruction. The methodology of the selection, delay and multiplexing applies to all of the signals generated by the INSTRUCTION DECODER <b>1202</b>, with the exception of those signals which do not generate separate 1 byte opcode, 2 byte opcode and floating point results. Furthermore, the results generated by this example are application specific, in other words, they apply to decoding of i486\u2122 instructions into the nano-instruction format of the present invention. The principles discussed throughout these examples, however, are generally applicable to any CISC to RISC instruction alignment and decoding.</p><p>As discussed above, the CST_GEN decoder <b>1414</b> generates three outputs, CST<b>1</b>, CST<b>2</b> and CSTF, each of which comprise four constant 5 bit register fields (20 bits total). The SEL_GEN generates register field control signals (FLD<b>1</b>, FLD<b>2</b>, and FLD<b>3</b> for the selection of the multiplexers in a further section MUX <b>1512</b>. The selection of the CST<b>1</b>, CST<b>2</b> or CSTF results and the FLD<b>1</b>, FLD<b>2</b>, and FLDF results is shown generally at the multiplexer block <b>1502</b>. A 3 bit MUX select line <b>1504</b> is used to select the results depending on whether the instruction has a 1 byte opcode, 2 byte opcode, or is a floating point instruction.</p><p>A \u00bd cycle pipeline delay latch <b>1504</b> is used to delay the results selected by the multiplexer <b>1502</b>, and the three register control fields RC<b>1</b>, RC<b>2</b>, and RC<b>3</b>. Each input to the \u00bd pipeline delay <b>1504</b> is sent to a pair of oppositely clocked latches <b>1508</b>. The contents of the latches are selected by a multiplexers <b>1510</b>. This arrangement is similar to the \u00bd cycle delay <b>316</b> discussed above in connection to the IAU.</p><p>A further multiplexing stage is shown in block <b>1512</b>. The constant register fields selected by the multiplexer <b>1502</b> are input to the multiplexer <b>1512</b> as four separate fields labeled regc<b>1</b> through regc<b>4</b>, respectively, as shown generally at <b>1514</b>. Also shown as inputs to the block <b>1512</b> are the EXTRACT REGISTER fields RC<b>1</b>, RC<b>2</b>, and RC<b>3</b> from the opcode and ModR/M bytes. The regc fields and RC fields are combined by logic in the block <b>1512</b> under control of an FLD control signal <b>1520</b> to generate the source and destination register indexes a<b>0</b>_rd and a<b>0</b>_rs for operation A<b>0</b>, which are shown generally at <b>1516</b>, as well as the source and destination register indexes a<b>1</b>_rd and a<b>1</b><sub>13 </sub>rs for operation A<b>1</b>, which are shown generally at <b>1518</b>. An index ld_rd, which is the destination register index for the Load instruction, is also selected in the block <b>1512</b>.</p><p>4.0 Decoded Instruction FIFO</p><p>A block diagram of a Decode FIFO (DFIFO) in conjunction with the present invention is shown in FIG. <b>16</b>A. The DFIFO holds four complete buckets, each of which contains four nano-instructions, two immediate data fields, and one displacement field. Each bucket corresponds to one level of pipeline register in the DFIFO. These buckets are generated in the IDU and pushed to the DFIFO during each cycle that the IEU requests a new bucket. The nano-instructions in a bucket are divided into two groups, called packet<b>0</b> and packet<b>1</b>. Packet<b>0</b> can consist of a Load, ALU, and/or Store operation, which corresponds to one, two, or three nano-instruction. Packet<b>1</b> can only be an ALU operation, corresponding to one nano-instruction. As a result of this division, a bucket can only contain two ALU operations, and only one of them can reference memory. If subsequent instructions both require memory operands, they must be placed in separate buckets.</p><p>As can be seen from FIG. 16B, there is only a fair amount of general information associated with each packet and with the bucket as a whole. This information is stored in a general information FIFO. By default, the four nano-instructions in a bucket are executed in order, from NIR<b>0</b> to NIR<b>3</b>. One of the bucket general information bits can be set to indicate that NIR<b>3</b> should be executed before NIR<b>0</b>-NIR<b>2</b>. This feature makes it much easier to combine subsequent instructions into a single bucket, because their order no longer affects their ability to fit the bucket requirements.</p><p>FIG. 16C shows an immediate data and displacement FIFO for buckets<b>0</b>-<b>4</b>. IMM<b>0</b> represents the immediate data corresponding to packet<b>0</b>, and IMM<b>1</b> represents the immediate data corresponding to packet<b>1</b>. DISP represents the displacement corresponding to packet<b>0</b>. Packet<b>1</b> does not use DISP information because the DISP fields are only used as a part of address calculation.</p><p>A specific example of the three types of nano-instruction described above is shown in FIG. <b>17</b>. The field descriptions and definitions are also described in Appendix A, pages 1-10. These tables provide detailed information about the contents of each bucket.</p><p>While various embodiments of the present invention have been described above, it should be understood that they have been presented by way of example, and not limitation. Thus the breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Brett", "last_name": "Coon", "name": ""}, {"first_name": "Yoshiyuki", "last_name": "Miyayama", "name": ""}, {"first_name": "Le Trong", "last_name": "Nguyen", "name": ""}, {"first_name": "Johannes", "last_name": "Wang", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "SEIKO EPSON CORPORATION"}, {"first_name": "", "last_name": "TRANSMETA LLC", "name": ""}, {"first_name": "", "last_name": "INTELLECTUAL VENTURE FUNDING LLC", "name": ""}, {"first_name": "", "last_name": "S-MOS SYSTEMS, INC.", "name": ""}, {"first_name": "", "last_name": "TRANSMETA CORPORATION", "name": ""}, {"first_name": "", "last_name": "SEIKO EPSON CORPORATION", "name": ""}, {"first_name": "", "last_name": "TRANSMETA CORPORATION", "name": ""}, {"first_name": "", "last_name": "S-MOS SYSTEMS, INC.", "name": ""}, {"first_name": "", "last_name": "SEIKO EPSON CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/30"}], "locarno_classes": [], "ipcr_classes": [{"label": "C10G   1/00        20060101A I20051008RMEP"}, {"label": "C10G  17/02        20060101A I20051008RMEP"}, {"label": "G06F  15/76        20060101A I20060506RMEP"}, {"label": "G06F   9/22        20060101ALI20051220RMJP"}, {"label": "G06F   9/318       20060101A I20051008RMEP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}, {"label": "G06F   9/30        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712209"}, {"primary": false, "label": "712E09037"}, {"primary": false, "label": "712E09055"}, {"primary": false, "label": "712E09049"}, {"primary": false, "label": "712E09031"}, {"primary": false, "label": "712E09029"}, {"primary": false, "label": "712204"}, {"primary": false, "label": "712E09054"}], "ecla_classes": [{"label": "G06F   9/38C2"}, {"label": "G06F   9/30U"}, {"label": "G06F   9/30T4T"}, {"label": "G06F   9/38B9"}, {"label": "G06F   9/30U2"}, {"label": "C10G   1/00"}, {"label": "G06F   9/30R2"}, {"label": "C10G  17/02"}, {"label": "G06F   9/30X2"}, {"label": "G06F   9/30T2A"}, {"label": "G06F   9/38E"}, {"label": "G06F   9/30T2"}, {"label": "G06F   9/38E6"}, {"label": "G06F   9/30T4S"}], "cpc_classes": [{"label": "G06F   9/3853"}, {"label": "G06F   9/30149"}, {"label": "G06F   9/30101"}, {"label": "G06F   9/3017"}, {"label": "G06F   9/30174"}, {"label": "G06F   9/30167"}, {"label": "G06F   9/30185"}, {"label": "G06F   9/3816"}, {"label": "G06F   9/30145"}, {"label": "G06F   9/382"}, {"label": "G06F   9/30152"}, {"label": "G06F   9/30163"}, {"label": "G06F   9/38"}, {"label": "B82Y  10/00"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1992-03-31", "application_date": "1999-09-22", "family_members": [{"ucid": "US-5546552-A", "titles": [{"lang": "EN", "text": "Method for translating non-native instructions to native instructions and combining them into a final bucket for processing on a host processor"}]}, {"ucid": "US-6954847-B2", "titles": [{"lang": "EN", "text": "System and method for translating non-native instructions to native instructions for processing on a host processor"}]}, {"ucid": "US-7664935-B2", "titles": [{"lang": "EN", "text": "System and method for translating non-native instructions to native instructions for processing on a host processor"}]}, {"ucid": "US-20030084270-A1", "titles": [{"lang": "EN", "text": "System and method for translating non-native instructions to native instructions for processing on a host processor"}]}, {"ucid": "KR-950701100-A", "titles": [{"lang": "EN", "text": "CISC-RISC Instruction translation sorting and decoding"}, {"lang": "KO", "text": "\uc528\uc544\uc774\uc5d0\uc2a4\uc528-\uc54c\uc544\uc774\uc5d0\uc2a4\uc528(CISC-RISC) \uba85\ub839\uc5b4 \ubc88\uc5ed \uc815\ub82c \ubc0f \ub514\ucf54\ub529"}]}, {"ucid": "EP-1028370-A2", "titles": [{"lang": "DE", "text": "System und Verfahren zur \u00dcbersetzung eines fremden Befehlsstroms zur Ausf\u00fchrung in einem Gastgeberprozessor"}, {"lang": "EN", "text": "System and method for translating a stream of non-native instructions for processing on a host processor"}, {"lang": "FR", "text": "Syst\u00e8me et proc\u00e9d\u00e9 de traduction d'un flot d'instructions non natives pour son ex\u00e9cution dans un processeur h\u00f4te"}]}, {"ucid": "WO-1993020507-A3", "titles": [{"lang": "EN", "text": "CISC TO RISC INSTRUCTION TRANSLATION ALIGNMENT AND DECODING"}, {"lang": "FR", "text": "ALIGNEMENT ET DECODAGE DANS LA TRADUCTION D'INSTRUCTIONS CISC EN INSTRUCTIONS RISC"}]}, {"ucid": "US-5438668-A", "titles": [{"lang": "EN", "text": "System and method for extraction, alignment and decoding of CISC instructions into a nano-instruction bucket for execution by a RISC computer"}]}, {"ucid": "KR-100343530-B1", "titles": [{"lang": "KO", "text": "\uc528\uc544\uc774\uc5d0\uc2a4\uc528-\uc54c\uc544\uc774\uc5d0\uc2a4\uc528\uba85\ub839\uc5b4\ubc88\uc5ed\uc815\ub82c\ubc0f\ub514\ucf54\ub529"}, {"lang": "EN", "text": "CISC-RISC INSTRUCTION TRANSLATION ALIGNMENT AND DECODING"}]}, {"ucid": "WO-1993020507-A2", "titles": [{"lang": "FR", "text": "ALIGNEMENT ET DECODAGE DANS LA TRADUCTION D'INSTRUCTIONS CISC EN INSTRUCTIONS RISC"}, {"lang": "EN", "text": "CISC TO RISC INSTRUCTION TRANSLATION ALIGNMENT AND DECODING"}]}, {"ucid": "US-5619666-A", "titles": [{"lang": "EN", "text": "System for translating non-native instructions to native instructions and combining them into a final bucket for processing on a host processor"}, {"lang": "EN", "text": "COMPUTER SYSTEM"}]}, {"ucid": "US-5983334-A", "titles": [{"lang": "EN", "text": "Superscalar microprocessor for out-of-order and concurrently executing at least two RISC instructions translating from in-order CISC instructions"}]}, {"ucid": "EP-1028370-A3", "titles": [{"lang": "DE", "text": "System und Verfahren zur \u00dcbersetzung eines fremden Befehlsstroms zur Ausf\u00fchrung in einem Gastgeberprozessor"}, {"lang": "EN", "text": "System and method for translating a stream of non-native instructions for processing on a host processor"}, {"lang": "FR", "text": "Syst\u00e8me et proc\u00e9d\u00e9 de traduction d'un flot d'instructions non natives pour son ex\u00e9cution dans un processeur h\u00f4te"}]}, {"ucid": "DE-69333630-D1", "titles": [{"lang": "EN", "text": "System and method for translating a foreign instruction stream for execution in a host processor"}, {"lang": "DE", "text": "System und Verfahren zur \u00dcbersetzung eines fremden Befehlsstroms zur Ausf\u00fchrung in einem Gastgeberprozessor"}]}, {"ucid": "EP-0636257-A1", "titles": [{"lang": "DE", "text": "\u00dcBERSETZUNGSAUSRICHTUNG UND DECODIERUNG VON BEFEHLEN VON CISC ZU RISC."}, {"lang": "EN", "text": "CISC TO RISC INSTRUCTION TRANSLATION ALIGNMENT AND DECODING"}, {"lang": "FR", "text": "ALIGNEMENT ET DECODAGE DANS LA TRADUCTION D'INSTRUCTIONS CISC EN INSTRUCTIONS RISC"}]}, {"ucid": "US-7343473-B2", "titles": [{"lang": "EN", "text": "System and method for translating non-native instructions to native instructions for processing on a host processor"}]}, {"ucid": "US-20080162880-A1", "titles": [{"lang": "EN", "text": "System and Method for Translating Non-Native Instructions to Native Instructions for Processing on a Host Processor"}]}, {"ucid": "US-20050251653-A1", "titles": [{"lang": "EN", "text": "System and method for translating non-native instructions to native instructions for processing on a host processor"}]}, {"ucid": "DE-69333630-T2", "titles": [{"lang": "EN", "text": "A system and method for translating a foreign instruction stream for execution in a host processor"}, {"lang": "DE", "text": "System und Verfahren zur \u00dcbersetzung eines fremden Befehlsstroms zur Ausf\u00fchrung in einem Gastgeberprozessor"}]}, {"ucid": "DE-69329644-D1", "titles": [{"lang": "EN", "text": "TRANSLATION ORIENTATION AND DECODING OF COMMANDS FROM CISC TO RISC."}, {"lang": "DE", "text": "\u00dcBERSETZUNGSAUSRICHTUNG UND DECODIERUNG VON BEFEHLEN VON CISC ZU RISC."}]}, {"ucid": "DE-69329644-T2", "titles": [{"lang": "EN", "text": "TRANSLATION ORIENTATION AND DECODING OF COMMANDS FROM CISC TO RISC."}, {"lang": "DE", "text": "\u00dcBERSETZUNGSAUSRICHTUNG UND DECODIERUNG VON BEFEHLEN VON CISC ZU RISC."}]}, {"ucid": "KR-957001100-A", "titles": []}, {"ucid": "EP-1028370-B1", "titles": [{"lang": "DE", "text": "System und Verfahren zur \u00dcbersetzung eines fremden Befehlsstroms zur Ausf\u00fchrung in einem Gastgeberprozessor"}, {"lang": "EN", "text": "System and method for translating a stream of non-native instructions for processing on a host processor"}, {"lang": "FR", "text": "Syst\u00e8me et proc\u00e9d\u00e9 de traduction d'un flot d'instructions non natives pour son ex\u00e9cution dans un processeur h\u00f4te"}]}, {"ucid": "EP-0636257-B1", "titles": [{"lang": "DE", "text": "\u00dcBERSETZUNGSAUSRICHTUNG UND DECODIERUNG VON BEFEHLEN VON CISC ZU RISC."}, {"lang": "EN", "text": "CISC TO RISC INSTRUCTION TRANSLATION ALIGNMENT AND DECODING"}, {"lang": "FR", "text": "ALIGNEMENT ET DECODAGE DANS LA TRADUCTION D'INSTRUCTIONS CISC EN INSTRUCTIONS RISC"}]}, {"ucid": "KR-100371929-B1", "titles": [{"lang": "EN", "text": "CISC TO RISC INSTRUCTION TRANSLATION ALIGNMENT AND DECODING"}, {"lang": "KO", "text": "\uc528\uc544\uc774\uc5d0\uc2a4\uc528-\uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \uba85\ub839\uc5b4 \ubc88\uc5ed \uc815\ub82c \ubc0f \ub514\ucf54\ub529"}]}, {"ucid": "JP-2000215051-A", "titles": [{"lang": "JA", "text": "\u547d\u4ee4\u30b9\u30c8\u30ea\u2015\u30e0\u306e\u5909\u63db\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "CONVERSION SYSTEM FOR INSTRUCTION STREAM"}]}, {"ucid": "JP-3547052-B2", "titles": [{"lang": "JA", "text": "\uff23\uff29\uff33\uff23\u578b\u304b\u3089\uff32\uff29\uff33\uff23\u578b\u547d\u4ee4\u3078\u306e\u5909\u63db\u306e\u305f\u3081\u306e\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u4e26\u3073\u306b\u30c7\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0"}, {"lang": "EN", "text": "Alignment and decoding for conversion from CISC type to RISC type instructions"}]}, {"ucid": "JP-2000215050-A", "titles": [{"lang": "JA", "text": "\u30d7\u30ed\u30bb\u30c3\u30b5"}, {"lang": "EN", "text": "PROCESSOR"}]}, {"ucid": "US-6263423-B1", "titles": [{"lang": "EN", "text": "System and method for translating non-native instructions to native instructions for processing on a host processor"}]}, {"ucid": "JP-H07505968-A", "titles": []}]}