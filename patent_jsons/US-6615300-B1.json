{"patent_number": "US-6615300-B1", "publication_id": 73526744, "family_id": 27766418, "publication_date": "2003-09-02", "titles": [{"lang": "EN", "text": "Fast look-up of indirect branch destination in a dynamic translation system"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50542469\"><p>Dynamic translation of indirect branch instructions of a target application by a host processor is enhanced by including a cache to provide access to the addresses of the most frequently used translations of a host computer, minimizing the need to access the translation buffer. Each entry in the cache includes a host instruction address, a logical address of the instruction of the target application, the physical address of that instruction, the code segment limit to the instruction, and the context value of the host processor associated with that instruction, the last four named components constituting tags to the host instruction address, and a valid-invalid bit. In a basic embodiment, the cache is a software cache apportioned by software from the main processor memory chips.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00001\" num=\"1\"><claim-text>1. The computer implemented method of retrieving a pre-existing translation of an instruction of a target application program in a host computer that dynamically translates and processes instructions of a target application program designed for processing by a target computer having an instruction set different from the instruction set of said host computer, comprising the steps of:</claim-text><claim-text>(a) creating a plurality of tags for each translation made of a target application instruction, a tag including multiple elements of data, including an extended instruction pointer (\u201ceip\u201d) supplied by the target application; a physical instruction pointer (\u201cpeip\u201d) derived by calculation from said extended instruction pointer; the context of a target processor existing at the time the translation was produced by a host processor and the code segment limit (\u201cCS-limit\u201d) of the target processor; </claim-text><claim-text>(b)(1) storing each said translation together with said associated tags as an entry within a memory, and </claim-text><claim-text>(b)(2) storing a fraction of said translations and said tags associated therewith stored in said memory as entries in a cache; </claim-text><claim-text>(c) indexing said entries within said cache by hashing the information of the extended information pointers (\u201cEIP\u201d) associated with said translations stored in said cache to form a hash table for said cache; </claim-text><claim-text>(d) hashing an eip of a target application instruction asserted for execution by the host computer and applying the hashed eip to a index to determine if said eip of said target application instruction matches an eip tag; of a translated target application instruction in said cache, wherein an individual translation in said cache may be selected through said hash table by matching the value of the EIP of a translation being sought with an EIP of said index; and </claim-text><claim-text>(e) when said determination is positive, comparing the CS-limit of said asserted target application instruction with the CS-limit tag of the eip matched translated target application instruction, and comparing the context of the target processor existing in said host processor at the time of assertion of said target application instruction with and the context tag of said eip matched translated target application instruction; </claim-text><claim-text>(f) retrieving said translated target application instruction for execution when each of the foregoing comparisons produce a match; </claim-text><claim-text>(g) calculating the \u201cpeip\u201d of said asserted target application instruction and comparing the calculated \u201cpeip\u201d with the \u201cpeip\u201d tag of said retrieved translated target application instruction, and if such comparison produces a match, then asserting said retrieved translated target application instruction as a correct translation; </claim-text><claim-text>(h) when said determination is negative or if any of the other of said tag comparisons results in a mismatch, generating a cache MISS exception; and </claim-text><claim-text>(i) if a cache MISS exception is generated, conducting a search of said memory for the translated target application instruction of said asserted target application instruction. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00002\" num=\"2\"><claim-text>2. The computer implemented method defined in <claim-ref idref=\"US-6615300-B1-CLM-00001\">claim 1</claim-ref> wherein said step of</claim-text><claim-text>g) calculating the \u201cpeip\u201d of said asserted target application instruction and comparing the calculated \u201cpeip\u201d with the \u201cpei p\u201d tag of said retrieved translated target application instruction, and if such comparison produces a match, then asserting said retrieved translated target application instruction as a correct translation, further includes the step of: </claim-text><claim-text>jumping to the address of the correct translation and executing said correct translation. </claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00003\" num=\"3\"><claim-text>3. The computer implemented method defined in <claim-ref idref=\"US-6615300-B1-CLM-00001\">claim 1</claim-ref> wherein said step of conducting a search of said memory for the translated target application instruction of said asserted target application instruction following the generation of a cache MISS exception, further comprises the steps of:</claim-text><claim-text>retrieving a correct translation of said target application instruction and accompanying tags from said memory; and </claim-text><claim-text>writing said translated target application instruction and accompanying tags into said cache. </claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00004\" num=\"4\"><claim-text>4. The computer implemented method of <claim-ref idref=\"US-6615300-B1-CLM-00001\">claim 1</claim-ref>, wherein said step of (f) retrieving said translated target application instruction for execution when each of the foregoing comparisons produce a match, includes the step of:</claim-text><claim-text>copying the \u201cpeip\u201d tag of said translated target instruction into a register; and wherein the step of (g) calculating the \u201cpeip\u201d of said asserted target application instruction and comparing the calculated \u201cpeip\u201d with the \u201cpeip\u201d tag of said retrieved translated target application instruction, includes the step of: </claim-text><claim-text>comparing said calculated \u201cpeip\u201d with the \u201cpeip\u201d value registered in said register. </claim-text></claim>"}, {"num": 5, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00005\" num=\"5\"><claim-text>5. The method of storing and retrieving a selected stored translation of dynamically recompiled instructions of a target application program within a host processor of the type that dynamically recompiles instructions of said target application program and performs the function of said target application program by executing said translations, each target application program instruction including an instruction code and being associated with a plurality of tags, said tags comprising a logical address (eip), a code-segment limit value, and wherein a physical address (phys-ip) of said instruction code is derived by a calculation that incorporates said logical address, ffi(eip); wherein each translation of a target application instruction made by said host processor includes a context value produced by the host processor, said context value describing the state of the registers of a target processor existing at the time of the respective translation; and wherein each stored translation of said target application instructions includes a respective plurality of host tags, said host tags including said logical address (eip) of the respective target application program instruction; said physical address (phys-ip) of the respective target application program instruction; said code-segment limit value of the respective target application program instruction, and said respective context value of the target processor; comprising the steps of:</claim-text><claim-text>storing a plurality of translations including associated tags for said translations in a hardware cache, whereby each respective translation and tags associated therewith defines an entry of said hardware cache; </claim-text><claim-text>producing an index of the logical address tag of said target application program instructions in said cache, whereby an individual translation of a target application program instruction may be located within said cache through said index by applying a logical address of said individual translation to said index; </claim-text><claim-text>and wherein retrieval of an individual translation for a target application program instruction from amongst said stored translations in said cache, comprises the steps of: </claim-text><claim-text>applying the logical address of said target application program instruction to said index of said cache to determine if an entry in said cache contains an identical logical address; and </claim-text><claim-text>if an entry in said cache contains the identical logical address that defines a prospective matched entry, </claim-text><claim-text>comparing a code-segment limit tag of said target application program instruction with the code-segment limit tag of said prospective matched entry; </claim-text><claim-text>comparing a context tag of said target application program instruction with the context tag of said prospective matched entry; and, then calculating the physical address of said target application program instruction, and comparing said physical address of said target application program instruction with the physical address tag of said prospective matched entry; and if said code-segment limit tag, said context tag and said physical address tag of each of said target application program instruction and said prospective matched entry each match to define a matched entry , then accepting said entry as the translation of the individual target application program instruction; and upon failure to produce a match of said logical address of said target instruction and a logical address of said index or upon failure to produce a match for each of said context tag, said CS-limit tag, and said physical address tag, then producing an exception. </claim-text></claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00006\" num=\"6\"><claim-text>6. The method of locating a translation of an instruction of a target application, comprising the steps of:</claim-text><claim-text>establishing a memory containing a listing of all translations of instructions of said target application; </claim-text><claim-text>establishing a software cache containing a partial listing of translations of instructions of said target application; </claim-text><claim-text>maintaining a hardware cache containing a partial listing of translations of instructions of said target application; </claim-text><claim-text>searching said hardware cache for the translation of said instruction; and, if said translation is not located in said hardware cache, then </claim-text><claim-text>searching said software cache for said translation of said instruction; and, if said translation is not located in said software cache, then </claim-text><claim-text>searching said memory for said translation. </claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00007\" num=\"7\"><claim-text>7. The method as defined in <claim-ref idref=\"US-6615300-B1-CLM-00006\">claim 6</claim-ref>, wherein said step of searching said hardware cache comprises the steps of:</claim-text><claim-text>comparing the logical address of said instruction with a logical address; associated with each translation in said hardware cache, and, if a match is not made, proceeding to the next search, and, if a match is made with a logical address of a translation in said cache, accepting the translation associated therewith as a prospective translation of said instruction, and </claim-text><claim-text>calculating the physical address of said instruction from said logical address, and </claim-text><claim-text>comparing said calculated physical address of said instruction to a physical address tag associated with said prospective translation; </claim-text><claim-text>comparing said CS-limit of said instruction with the CS-limit tag of said prospective translation; and </claim-text><claim-text>comparing the context associated with said instruction with the context tag associated with said prospective translation; and, if any of said comparisons fail to produce a match, then proceeding to the next search, and, if all of said comparisons result in a match, accepting said prospective translation as the translation of said instruction. </claim-text></claim>"}, {"num": 8, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00008\" num=\"8\"><claim-text>8. In a host digital processor that dynamically translates and executes instructions of a target application designed for processing by a target digital computer having a different instruction set from that of said host digital processor, the computer implemented method of processing target application call and return instructions, comprising the steps of:</claim-text><claim-text>determining if a target application instruction being translated constitutes a translation of a target application call instruction, and, if so, retrieving the next host instruction address in a target application program; and </claim-text><claim-text>pushing said retrieved translated next instruction address together with a plurality of tags associated with said next translated target instruction address as an entry onto a stack, said plurality of tags comprising a logical address of a target instruction, a code-segment limit for said target instruction and a context value of a target processor associated with said target instruction; </claim-text><claim-text>determining if a target application instruction being translated constitutes a translation of a target application return instruction, and, if so, </claim-text><claim-text>popping said translated next instruction address from said stack; </claim-text><claim-text>checking said tags associated with said translated next instruction address against the corresponding tags of the target application instruction address, and if the tags match; and </claim-text><claim-text>jumping to said translated next instruction address and executing said next instruction. </claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00009\" num=\"9\"><claim-text>9. The computer implemented method defined in <claim-ref idref=\"US-6615300-B1-CLM-00008\">claim 8</claim-ref>, wherein said step of popping said translated next instruction address from said stack, further comprises the steps of:</claim-text><claim-text>jumping to the top of the stack pointed to by a pointer; </claim-text><claim-text>comparing a \u201ceip\u201d tag, a CS-limit tag and a context tag associated with the entry located at said top of the stack against the corresponding tags of the target application instruction, and if such comparison shows a match, </claim-text><claim-text>retrieving said entry as the translated next instruction address; but if said comparison proves a mismatch; </claim-text><claim-text>decrementing the pointer to reposition the top of the stack comparing the \u201ceip\u201d tag, the CS-limit tag and the context tag associated with the repositioned entry located at said repositioned top of the stack against the corresponding tags of the target application instruction, and if such comparison shows a match, retrieving said first repositioned entry as the translated next instruction address; but if said second comparison proves a mismatch; </claim-text><claim-text>again decrementing the pointer to reposition the top of the stack a second time; and </claim-text><claim-text>comparing the \u201ceip\u201d tag, the CS-limit tag and the context tag associated with the second repositioned entry located at said further repositioned top of the stack against the corresponding tags of the target application instruction, and if such comparison shows a match, retrieving said second repositioned entry as the translated next instruction address; but if said second third proves a mismatch, then generating an exception. </claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00010\" num=\"10\"><claim-text>10. In a processor for dynamically translating and executing instructions of a target application designed for a different processor to accomplish the purpose of said target application, said processor including at least a processing unit and a memory for storing translations of target application instructions made for potential re-use during continued processing of said target application, the improvement comprising in combination therewith:</claim-text><claim-text>a cache for storing a fraction of the translations stored in said memory, said processing unit being programmed to check said cache for a desired translation when a target application instruction is asserted for execution before any check of said memory is necessitated, whereby a subsequent translation of an target application instruction during processing of said target application may be procured from said cache. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00011\" num=\"11\"><claim-text>11. The processor as defined in <claim-ref idref=\"US-6615300-B1-CLM-00010\">claim 10</claim-ref>, further comprising a plurality of tags for each said instruction, said tags comprising the eip of the target application instruction, the peip of the target application instruction, the CS-limit of the target application instruction, and the context of the target processor being emulated by a VLIW processor, and wherein each of said tags associated with a translation is stored in said memory accompanying said translation of said target application instruction.</claim-text></claim>"}, {"num": 12, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00012\" num=\"12\"><claim-text>12. The processor defined in <claim-ref idref=\"US-6615300-B1-CLM-00010\">claim 10</claim-ref>, wherein said cache comprises a hardware cache, said hardware cache being separate from said memory.</claim-text></claim>"}, {"num": 13, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00013\" num=\"13\"><claim-text>13. The processor defined in <claim-ref idref=\"US-6615300-B1-CLM-00010\">claim 10</claim-ref>, wherein said cache comprises a software cache, said software cache further comprising a reserved portion of said memory.</claim-text></claim>"}, {"num": 14, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00014\" num=\"14\"><claim-text>14. The processor defined in <claim-ref idref=\"US-6615300-B1-CLM-00012\">claim 12</claim-ref>, wherein said improvement further comprises a hardware stack.</claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6615300-B1-CLM-00015\" num=\"15\"><claim-text>15. The processor as defined in <claim-ref idref=\"US-6615300-B1-CLM-00014\">claim 14</claim-ref>, wherein said processor comprises a VLIW processor.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53978407\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>FIELD OF THE INVENTION</h4><p>This invention relates to an improvement in digital processors (the \u201chost processors\u201d) that dynamically translate instructions of a computer application program (the \u201ctarget application\u201d) designed for processing by a digital processor (the \u201ctarget processor\u201d) that functions with a different instruction set than the instruction set of the host processor, executing the translated instructions in real time to carry out the purpose of the target application, and, more particularly, relates to a new method and apparatus for processing of indirect branch instructions of the target application to reduce latency in processing by the host processor.</p><h4>BACKGROUND</h4><p>A unique digital processing system is described in U.S. Pat. No. 6,031,992, granted Feb. 29, 2000, entitled Combining Hardware and Software to provide an Improved Microprocessor, assigned to Transmeta Corporation, (referred to as the '992 Transmeta patent), the content of which is incorporated by reference herein in its entirety. The Transmeta processor serves as the host processor capable of executing software programs, the target application, designed with an instruction set intended to run on a processor of different design, the \u201ctarget\u201d processor, that contains an instruction set unique to the target processor, but different from that of the host processor. The present invention improves upon the host processor and, hence, the host processing system.</p><p>The microprocessor of the '992 Transmeta patent is formed by a combination of a hardware processing portion (sometimes called a \u201cmorph host\u201d), and a software portion, referred to as \u201ccode morphing software.\u201d Among other things, the code morphing software carries out a significant portion of the functions of digital processors in software, reducing the hardware required for processing, and, hence, reducing power consumption. The morph host processor executes the code morphing software which translates the target application programs dynamically into host processor instructions that are able to accomplish the purpose of the original software. As the instructions are translated, they are stored in a translation buffer where they may be subsequently accessed and executed, as needed, during continued program execution without further translation.</p><p>A set of host registers (in addition to normal working registers) is included in the Transmeta processor. The host registers store \u201cstate\u201d (also referred to as \u201ccontext\u201d) of the target processor which exists at the beginning of any sequence of target instructions being translated. In one embodiment, the results of translations are held in a gated store buffer until the translations execute. If the sequence of translated instructions execute without raising an exception the results are stored in memory by a commit instruction. Further, the registers holding the target state are updated to the target state at the point at which the results from the sequence of translated instructions was committed. The information contained in those registers are used to advantage in the present invention as a \u201ctag\u201d for a translation.</p><p>The '992 Transmeta processor is capable of processing target applications programs designed for other processors. Application programs contain indirect branch instructions, in which the instruction execution requires the processor to \u201cbranch\u201d to a specified address (in memory) and execute the instruction found at that address before returning to process the next instruction of the application program. When that branch address is not known, that is, is not included in the branch instruction, the branch instruction is referred to as \u201cindirect\u201d. The latter is the type of instruction with which the present invention is principally concerned. Thus, any reference herein to a branch instruction should be understood to refer to an indirect branch instruction, unless the text expressly states to the contrary.</p><p>Given that the branch address is not initially known, to complete execution of the branch instruction, the processor must first calculate or otherwise determine the unknown branch target address. The processor makes the calculation, determines the branch address, jumps to that address and executes the instruction found at that address.</p><p>In processors that include a memory \u201cstack\u201d and \u201ccall\u201d and \u201creturn\u201d instructions, the return instruction constitutes one important class of indirect branch instruction. The call instruction constitutes a kind of branch. To transfer the flow of the application program to the procedure, such as a subroutine, to which a jump is made, the target processor employs the CALL instruction. Then to return to the program following the execution of a branch instruction (and any other intervening instruction executions, as may include additional call and return instructions (called a nested branch), as example, that target processor employs the RETURN instruction.</p><p>When a CALL is made, the return address of the next instruction of the application program is saved in a memory stack (e.g. is \u201cpushed\u201d onto the stack) so that the flow of the program may continue later, when a RETURN instruction is executed. The RETURN instruction in turn \u201cpops\u201d the next instruction address of the target application off of the stack, and that succeeding instruction is then executed by the target processor (e.g. the processor jumps to that address and executes the instruction). That combination of software and hardware of the target processor reduces the latency in obtaining the next instruction of the program for execution.</p><p>When an indirect branch instruction of an application program intended for operation in a target type system is to be executed by the host Transmeta processor, in order to correctly translate that branch instruction into instructions of the host processor, the host must not only generate code to perform the effect of the branch instruction, but must also generate code to determine the address of the translation of the target of the branch. Thus in order for the host processor to execute the target branch instruction, the target program address and other target processor state information that was earlier saved by the host processor must be converted into the address of a corresponding translation followed by a transfer of control of the host processor to that translation.</p><p>A translation corresponds to a target address if the execution of the (machine language) code in the translation has the same effect on the state of the target processor stored in the context registers of the host processor as would be caused by a target processor executing that same target processor code. The host processor also associates additional information with each translation, called \u201ctags\u201d. One tag may contain information of the state of the target processor at the time the translation was made, as example, and other tags will contain other information, as later herein described. Those tags may be used to enable the processor to later identify (and, as appropriate, retrieve) the particular translation when again needed.</p><p>To find a pre-existing translation (e.g. host instruction) of an instruction address of the target processor, the host processor first searches (e.g. \u201clooks\u201d) through the translation memory, the library of translations stored in a memory earlier referred to, to find a translation whose tags match the current target state. As example, that memory may contain tens of thousands of translations. A conventional approach to efficient searching of the translation buffer is to establish an index of the stored information, known as a hash table, to make the search easier to accomplish. A hash table or \u201chashing\u201d is the creation of an index to the table content that is derived from a transformation of the information stored. As example, see Schildt, \u201cC: The Complete Reference\u201d, third edition, Osborne-McGraw-Hill Ch 21 p 587 (1995). In practice one finds that searching a physical memory of the processing system in that way or any other way that requires searching through all translations is slower than desired because of the great number of system clock cycles required to accomplish the search and the volume of translations that is stored. Those familiar with the Transmeta processor refer to such a search as a slow look-up.</p><p>In other processing systems of the prior art a cache is used to hold data and/or instructions that are used frequently during the processing of an application program. By first looking for required data or instructions being sought in the cache, processing of the program being run proceeds more quickly should that information be found in the cache than when access must be made to the main memory for that information. Those prior caches may be software caches, hardware caches or combinations of the two types of caches. The present invention also takes advantage of a cache for translations of target application instructions, or more precisely, the address of such translations. The adaptation of a cache to the translation process of the host computer involves the application and caching of the translation \u201ctags\u201d required by the host processor, as becomes apparent from the detailed description of the invention which follows.</p><p>On inspection of the operation of the Transmeta processor, the skilled person finds that each translation of a target instruction is accompanied by four different pieces of information, referred to as tags. One tag is the extended instruction pointer (the \u201ceip\u201d) of the target application, which is the logical address of the target instruction contained in the target application. Another tag is the physical instruction pointer of the target application instruction (the \u201cPhys-ip\u201d), which is the physical address of such instruction (in a memory of a target processor). The Phys-ip value is derived from the logical address by a simple calculation made by the target processor and is the means of equating an address used by the software programmer with an actual physical location in memory of the target system.</p><p>A third tag is the \u201cstate\u201d or \u201ccontext\u201d of the target processor being emulated by the host processor. As earlier noted, a number of working registers of the Transmeta (e.g., host) processor contain data indicative of the condition of the target processor, called state or context. That data provides a snapshot of the condition of the target processor. A more detailed description of context may be found in the co-pending application of D. Keppel, Ser. No. 09/417,981, filed Oct. 13, 1999, entitled Method and Apparatus for Maintaining Context While Executing Translated Instructions.</p><p>Prior to translation of a target instruction, the data in the foregoing working registers reflects the context of the target processor, as maintained by the host processor. When a target instruction is successfully translated and executed by the host processor, the data in those registers is updated as a side effect to the successful instruction execution. The data stored in the registers hence depicts the new context of the X86 processor. Among other things, that context information may be used by the host processor as a verification of the correctness of a translation during subsequent processing.</p><p>When a target instruction is successfully translated by the host processor during the processing of a target application, the translation is saved (stored) in a translation memory for re-use later during further processing of that application program. At the time the translation is made, the working registers of the host processor stores the assumed \u201cstate\u201d or \u201ccontext\u201d of the target processor that is being dynamically translated by the host processor. That context information is saved along with the translation to ensure that the circumstances in the host processor are the same as before to ensure that the translation, if later accessed for use in processing, will correctly execute.</p><p>A fourth tag is the code segment limit of the target instruction (the \u201cCS-limit\u201d). The CS limit is an appendage to instructions found in the target application. The value specifies a maximum size of memory that the target instruction should not exceed and serves as a check on the integrity of the target instruction. Should an instruction exceed that size, an error condition results.</p><p>Accordingly, an object of the invention is to reduce latency in the dynamic translation by the host system of indirect branch instructions of a target application.</p><p>A further object of the invention is to permit existing translations of the instructions of a target application to be located as needed for the execution of a branch instruction more rapidly than before.</p><h4>SUMMARY</h4><p>In accordance with the foregoing objects and advantages, a digital processor (the \u201chost processor\u201d) of the kind that dynamically translates instructions of a computer application program (the \u201ctarget application\u201d) designed for processing by a \u201ctarget processor\u201d, a digital processor with a different instruction set than the instruction set of the host processor, and executes the translated instructions in real time to carry out the purpose of the target application and stores such translations that are made within a searchable translation buffer along with the accompanying tags to the translation for later re-use in processing of the target application, is modified to include a cache for translations (and the accompanying tags) more limited in size than the translation buffer. The cache is indexed using a selected one of the tags, specifically the logical address (\u201cEIP\u201d) of the target application instruction.</p><p>In one embodiment, the cache is a software cache, one defined by the operation of the software in a portion of the main memory of the host processor. The process is such that should a search of the cache fail to find the translation sought, then the search is repeated in the translation buffer. A second embodiment of the invention includes both a hardware cache formed of memory dedicated to look-ups of translations and, as a back-up, a software cache. The processor control is such that should a search of the hardware cache fail to find the translation sought, the search is continued in the software cache. Should the search of the software cache also fail, searching is continued, as in the first embodiment, in the translation buffer which stores all the translations, a \u201cslow look-up\u201d procedure.</p><p>One embodiment of the invention also includes a memory stack. Upon the occurrence of the translation of a target call instruction, the host address of the translation of the next instruction of the target application and the associated tags are \u201cpushed\u201d onto the stack. Thereafter, some future execution of a host processor return instruction may be executed which will compare in current target state with those of the stack, and, if there is a match, will then pop the top of the stack and jump to the host system address so popped from the stack. If the translation address at the top of the stack is not a correct translation, the processor checks a number of additional stack entries as a further attempt to find the correct translation.</p><p>Preferably the host processor employs very long instruction words (\u201cVLIW\u201d), that pack together a number of different instructions that are executed in parallel, permitting an application to be processed more quickly. As a benefit of such VLIW instructions, look-up of the next host instruction address may be accomplished simultaneously with the execution of the target branch instruction and other target instructions.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><p>The foregoing and additional objects and advantages of the invention together with the structure characteristic thereof, which was only briefly summarized in the foregoing passages, will become more apparent to those skilled in the art upon reading the detailed description of a preferred embodiment of the invention, which follows in this specification, taken together with the illustrations thereof presented in the accompanying drawings.</p><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>In the drawings:</p><p>FIG. 1 is a block diagram of a host computer system that implements the invention;</p><p>FIGS. 2A and 2B are flow charts illustrating the method implemented by the embodiment of FIG. 1; and</p><p>FIG. 3 is a block diagram of a host computer system that implements the second more improved embodiment of the invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</h4><p>FIG. 1, to which reference is made, generally illustrates in simplified block form the principal elements of the host processing system that implements the method of the invention. Those elements include host processor <b>1</b>, its code morphing software <b>2</b> and the memory <b>3</b>. Memory <b>3</b> is partitioned into multiple sections, including a cache memory (\u201ccache\u201d) <b>5</b> and translation memory <b>7</b>. A portion of memory <b>3</b> also stores the target application <b>8</b>. Other regions of the memory and the processor that are not essential to the understanding of the invention are not specifically identified. The method makes use of a cache <b>5</b> that is reserved (defined) in the memory of the host processor by the code morphing software for storage of a fraction of the translations of target addresses and the respective accompanying tags for each respective translation. Translation memory <b>7</b>, sometimes referred to as the translation buffer, holds all of the translations produced during the run of the target application program.</p><p>In a practical embodiment, cache <b>5</b> is organized as a two-way set associative cache with 2,048 sets, a recognized structure in the computer art; See Computer Systems Design and Architecture, Heuring &amp; Jordan, published by Addision-Wesley 1997, subchapter 7.5\u201cCache\u201d. Because cache <b>5</b> is defined by software, the cache is referred to herein as the software cache. In a specific embodiment software cache <b>5</b> contains space for four thousand entries, substantially less than the tens of thousands of translations that accumulate and are stored during the operation of the '992 Transmeta processing system in processing a target application. Typically the cache is formed in the processor memory and is directly accessible to processor <b>1</b>.</p><p>The translation memory <b>7</b> contains an entry for each translation compiled by processor <b>1</b> during the run of the target program. Translation memory or buffer <b>7</b>, recognized as an element of the '992 Transmeta processor serves as a back-up to software cache <b>5</b>, as later herein described.</p><p>A cache, as is known, offers the processor a faster means to access frequently used information in fewer clock cycles as compared to accessing conventional memory, such as the larger translation memory <b>7</b>, for that information. In target processors cache is used for storing blocks of instructions or data from the more difficult to access main memory. By incorporating a cache in the '992 Transmeta processing system for the store of frequently used translation information, the dynamic translation process is accomplished in fewer system clock cycles than previously.</p><p></p><p>FIG. 2<i>a </i>and FIG. 2<i>b </i>define the new method for the dynamic translation process. Considering FIG. 2<i>a</i>, when the Transmeta processor is executing the instructions of a target application, one of the instructions of that program that will be executed is an indirect branch instruction. As represented in operation block <b>10</b>, for this description of operation, the method begins with a translated branch instruction of the target application that was previously translated by the host processor. As a first step to execution of the branch, represented by block <b>14</b>, the host processor calculates the target address for the branch instruction in the target processor environment, and the target address is stored <b>15</b>. Then the calculated target address is translated by the processor into a host address as represented in block <b>16</b>. The branch is then taken. Following the branch, processing continues with the next instruction of the target application, represented at block <b>20</b>. The translation process is illustrated in greater detail in the flow-chart of FIG. 2<i>b</i>, later herein described.</p><p>During the execution of the target application, the host processor dynamically translated and stored various translations of TARGET instructions in the translation memory <b>7</b> (FIG. <b>1</b>). The target address of a target application instruction thus has a counterpart host address in the translation and in the host instruction (e.g. the instruction translation). Ideally then, the translation of the target address of the target processor is accomplished by performing a look up of the previously stored information.</p><p>The look up or identification method may involve two subroutines. The first is called a fast look-up. If the first subroutine is unsuccessful, resort is made to the second sub-routine, the slow look-up of the prior art noted in the background to this specification. It is appreciated that the foregoing references to speed are relative to one another, the one being faster to completion than the slower one, and requires fewer system clock cycles to complete. Reference is made to FIG. 2B, which illustrates the steps involved in accomplishing the function of translation of block <b>16</b> through use of software cache <b>5</b>.</p><p>Each translation of target application instructions stored in the translation memory <b>7</b> and in cache <b>5</b> includes or is accompanied by four different pieces of information of target processor \u201cstate\u201d, which are the tags earlier referred to. Those pieces include the extended instruction pointer (\u201ceip\u201d) of the target application, which is the logical address of a target instruction, the physical instruction pointer (\u201cpeip\u201d), which is the physical address of such instruction, the \u201ccontext\u201d of the TARGET processor being emulated as determined by the host processor, and the code segment limit (\u201cCS-limit\u201d) of the TARGET processor.</p><p>When a target application instruction is successfully translated by the host processor during the processing of a target application, the translation is saved (stored) in translation memory <b>7</b> for re-use later during further processing of that application program. At the time such translation was made, certain working registers of the host processor applied to maintaining the indicia of target processor state held the assumed \u201cstate\u201d or \u201ccontext\u201d of the target processor that is being dynamically emulated by the host processor just prior to dynamically compiling the instruction of the target application. That context information was saved along with the translation to ensure that the circumstances in the host processor are the same as before to help ascertain that the translation, if later accessed for use in processing, is one appropriate to the circumstances. Thus if the same target application instruction is again asserted for execution, the theory is that the context of the target processor would be the same as that which existed when that same target application instruction was originally translated and executed.</p><p>In a practical embodiment, cache <b>5</b> is sufficient in size to store four thousand entries. Each entry that is made into cache <b>5</b> by the processor contains the values of the four tags associated with a particular translation and the address of the code of the host processor that comprises the translation of the instruction of the target application. Initially, cache <b>5</b> is empty. During operation, cache <b>5</b> is the first location at which the processor \u201clooks\u201d for an address of a translation of a target application instruction being \u201clooked-up\u201d during a \u201cfast look-up\u201d. If the translation is not found in the cache, the processor then looks for that information in translation memory <b>7</b>. The latter process is the \u201cslow look-up\u201d procedure, earlier mentioned; a process that serves as a back-up, later herein described, to the fast look-up procedure of the invention. When the translation address is located in the translation memory <b>7</b>, the processor, among other functions, copies the translation address, which was located, and the tags associated with that translation address into cache <b>5</b>, providing an entry in the cache. Accordingly, during the initial processing operation, the processor of necessity makes a number of slow look-ups and writes translation addresses as entries in cache <b>5</b>.</p><p>For the method of the present invention, the index to cache <b>5</b> is formed by hashing the lower order bits of the current \u201ceip\u201d tag to the translation. As example, the \u201ceip\u201d in a practical embodiment is thirty-two bits in length, whereas an index is typically only twelve bits in length. The low order bits are chosen for the indexing, since those bits are most likely to be more random in value that the higher order bits.</p><p>The fast look-up sub-routine computes the \u201chash\u201d of the current \u201ceip\u201d (block <b>16</b>A) of the target application instruction being executed. Using that hashed \u201ceip\u201d, the sub-routine indexes the cache to locate an entry with the same hashed \u201ceip\u201d (as represented by operational block <b>16</b>B) and checks for a match (decisional block <b>16</b>C). If a match is found, evidencing a prospective translation, the subroutine then checks the CS-limit and context values associated with the target application instruction being asserted against the corresponding tags for the prospective entry selected (block <b>16</b>D). If matches are found (decisional block <b>16</b>E), the sub-routine computes the \u201cpeip\u201d value of the target application instruction (<b>16</b>F) and compares the computed value with the \u201cpeip\u201d tag of the prospective translation (<b>16</b>G). If the \u201cpeip\u201d values match (<b>16</b>H), the sub-routine \u201cjumps\u201d to the host code (translation) address in the cache entry, block <b>16</b>J.</p><p>If an \u201ceip\u201d match cannot be found (block <b>16</b>C) or if the either of the other three tags associated with the asserted instruction fail to match the prospective translation (block <b>16</b>C), the processor determines if the look-up was a first attempt, as represented at decisional blocks <b>16</b>K, <b>16</b>L and <b>16</b>M, respectively. In each case, the Fast look-up subroutine inverts a \u201cbit\u201d in the hash value used to make the initial selection of a potential translation, and repeats the look-up as represented at block <b>16</b>Q.</p><p>Inversion of a bit, e.g. changing a \u201c1\u201d to a \u201c0\u201d changes to the \u201cpaired\u201d address. The approximately 4,000 addresses in the cache may be grouped into two 2,000 address sets. Each address of one group contains is an even number ending; the other an odd number, and the address of the even numbered set is regarded as paired with an address in the odd numbered set whose address differs by one unit. By changing the last bit of the address from the \u201c1\u201d to the \u201c0\u201d, a switch is made to location of the paired address.</p><p>If the tags of the second entry matches the computed tag, the fast look-up software jumps to the address of the host code translation (block <b>16</b>J) and executes the translation (FIG. <b>2</b>A\u2014operational block <b>18</b>). If neither entry matches, the process automatically switches to a second sub-routine, earlier referred to as the slow look-up routine, and a slow lookup is made by that routine of the existing translations (block <b>16</b>P), the translation is located (block <b>16</b>Q), since the translation memory <b>7</b> contains all of the translations. The Slow look-up routine, as is recalled, is the basic memory search technique of the prior art earlier referenced.</p><p>When a translation is found using the Slow look-up sub-routine, the host instruction (translation) address and the associated tags are written into one of the two cache entries previously checked with unsuccessful result during the fast look-up routine (<b>16</b>R). Effectively that write-back ensures that the address of the translation will be located by the fast look-up routine should the same target application instruction address reoccur during continued execution of the target application.</p><p>It is also recognized that translation memory <b>7</b> may not contain the translation being sought. If the slow look-up procedure does not locate the desired translation of a target application instruction, execution continues by other means, including dynamic translation of the target instruction and the execution of that target application instruction, such as described in the cited Transmeta patent.</p><p>It should be appreciated that the foregoing hashed tag indexed cache (of the fast look-up) provides a faster means to obtain translations during processing that the slower search of the slow look-up routine. The foregoing method allows the processor to locate the correct translation of the target processor address that is the object of the branch instruction, and, hence, improves processing efficiency of the host processor in processing indirect branch instructions of the target application.</p><p>It is appreciated that a translation may, during the course of processing, prove invalid for a number of reasons. Should that be recognized by the processor it is necessary to mark that translation invalid, so the translation cannot be used thereafter (and necessitating re-translation of the instruction of the target application). When a translation that has a corresponding entry in cache <b>5</b> is invalid, the cache entry must be emptied. That is accomplished by writing \u201c0\u201d to the context tag in the entry, which cannot match any context tag. With a \u201c0\u201d as the context value, any look-up of a translation will result in a cache MISS, since the context of the target application instruction and that of the translation, by definition, cannot match.</p><p>The foregoing method is further improved, leading to even faster processing of branch instructions by including a hardware stack and a hardware cache. Reference is next made to the embodiment of FIG. <b>3</b>. For convenience those elements of this embodiment which have equivalent elements in the embodiment of FIG. 1 are identified by the same numeral as in the prior embodiment, and are primed. Thus this embodiment includes the host processor <b>1</b>\u2032 and its code morphing software <b>2</b>\u2032, memory <b>3</b>\u2032 which subsumes therewith the reserved sections for translation memory <b>7</b>\u2032 and software cache <b>5</b>\u2032; and contains the target application <b>8</b>\u2032.</p><p>In this embodiment the procedure of looking-up host instructions that follow execution of a branch instruction (or of nested branch instructions) of the target program is also greatly enhanced over the foregoing software hash table approach by accomplishing a call and return procedure. As noted in the background to this specification, processors of the prior art contain a similar call and return procedure.</p><p>In this, additional hardware is incorporated within the processing system, including a RAM array <b>30</b>, a data path formed of registers <b>35</b>, <b>38</b> and <b>40</b> and comparators <b>37</b>, and additional control logic <b>34</b>. RAM array <b>30</b> is separate from memory <b>3</b>\u2032.</p><p>RAM array <b>30</b> is logically divided into two sections: The first portion serves as a memory stack <b>31</b>, sometimes referred to as the return stack, which contains a group (or stack) of storage cells. The term cell, as used herein, is a unit of memory that holds a predefined number of digital bits, the data, defining at least an address and additional tag information, as later herein more fully described. The stack is organized as a circular buffer, as represented in the diagram by the return arrow line extending between the top and the bottom. Hence, if the number of entries written into the stack during operation exceeds the number of stack positions or cells, instead of an overflow, the additional entry is written into the first stack cell, overwriting any entry then present in the first cell, a procedure referred to as \u201cwrapping\u201d the stack. Still additional entries, if any, are written into the next succeeding cells of the stack, overwriting the respective earlier written entries found in those respective stack cells. In a specific embodiment of the present invention, the stack contains space for sixteen entries.</p><p>During processing of a indirect branch instruction of the target application, stack <b>31</b> holds the addresses of the \u201chost\u201d instructions of the host processor that the host processor is to return to and execute following execution of and return from a branch instruction.</p><p>The stack array <b>31</b> is organized like a stack using a pointer containing an index into the array. A stack (or \u201ctop\u201d) pointer <b>33</b> points to the \u201ctop\u201d of the stack. By definition the cell location to which pointer <b>33</b> is pointing constitutes the \u201ctop\u201d of the stack. The cell position within the stack for the WRITE by the processor or, alternately, as the case may be, from which an entry is to be READ by the processor during operation is the cell located at the top of the stack. Pointer <b>33</b> is a part of the control logic <b>34</b> That control logic includes a recirculating bi-directional counter. Data is \u201cpushed\u201d onto the stack by incrementing the pointer and writing into the cell in the array that is being pointed to by the pointer at that time. And data is \u201cpopped\u201d off the stack by reading the cell pointed to by the pointer and then decrementing the pointer in preparation for any succeeding read operation.</p><p>The second portion of the RAM array is configured as a cache <b>36</b>. The particular type of cache selected for this embodiment is direct mapped (see Heuring, Computer Design). A set associative cache (or any other kind of cache) may be substituted in the combination, if desired, without departing from the invention. In the specific embodiment here described the cache is sufficient in size to hold one-hundred and twenty eight entries; and is indexed using the lower seven bits of the \u201ceip\u201d, the target application extended instruction pointer (e.g. logical address) of an target application instruction, earlier herein described. Cache <b>36</b> is considerably smaller in size than cache <b>5</b>\u2032.</p><p>Datapath unit <b>32</b> contains a number of registers <b>35</b> for holding tag values for \u201ceip\u201d, context and CS-limit values that correspond to current target system state, a number of comparators <b>37</b> for comparing data, and a register <b>38</b> (herein called the Tag Holding Register) to serve as a temporary repository of data, while comparisons are made. Each are logic devices of known structure. Control logic <b>34</b> of the fast look-up hardware contains the logic circuits, not illustrated, to define and practice the invention. The structure of the logic circuits becomes evident to those skilled in the art from the description of operation which follows and need not be illustrated as those details of conventional logic circuits do not aid one to understand of the invention.</p><p>Stack <b>31</b> implements a relatively fast look-up for return instructions of the host processor. Cache <b>36</b> implements a fast look-up for other kinds of indirect branch instructions. The cache is also used in circumstances in which the current context of the target processor has changed in an unpredictable way and a translation needs to be found that matches that current context.</p><p>Registers <b>35</b> of datapath unit <b>32</b> hold the current value of the target system context, the \u201ceip\u201d of the target processor and a representation of the CS limit of the target processor. Those values are written into the respective registers by the host processor <b>1</b>\u2032 when a target application instruction is asserted for translation. The value of the context and the CS-limit changes during continued translation by the processor and the foregoing registers are updated routinely by the processor with the new values. The \u201ceip\u201d value is set by the processor in a register <b>35</b> of data path unit <b>32</b> when either cache <b>36</b> or stack <b>31</b> are to be used.</p><p>Each entry (or cell) in the stack <b>31</b> holds three of the four tag values, an address of the host processor to which a \u201cjump\u201d will be made if the entry is selected during the operation, and a valid bit. The \u201cphysical ip\u201d (physical address) of the target processor is excluded from the entry for reasons hereafter described. The valid bit is included as a check on the validity of the host address. Typically that bit is \u201cset\u201d (e.g. \u201c1\u201d) indicating that the translation is valid. For purposes of the following description it is presumed that the valid bit is set, but discussion in greater detail is deferred to a later point in this specification. Each entry in the cache <b>36</b>, however, holds the four tag values and the address of the host processor to which a \u201cjump\u201d will be made if the entry is selected during the operation, and also holds the valid bit.</p><p>The \u201ceip\u201d, context and CS-limit values of the target application instruction are held in register <b>35</b>. When an entry in stack <b>31</b> or in cache <b>36</b> is to be examined, the corresponding tags of the entry are read into Tag Holding register <b>38</b>. The processor then initiates the comparators <b>37</b> to compare the values in the Tag Holding register with the corresponding values in the tags of the prospective translation identified in register <b>35</b>. For the check of the \u201cpeip\u201d value, the processor transfers the tag into general purpose registers <b>39</b> and compares that in software to the computed \u201cpeip\u201d value, computed from the eip value of the target application instruction.</p><p>The hardware cache of this embodiment has a like function and purpose to the cache previously described in the prior embodiment. Because it is separate hardware, look-ups may be accomplished more quickly than with the preceding embodiment. Cache <b>36</b> implements target processor transfers of control (jumps) in which one or more of the four tags are not known at the time the target processor code is translated, and which probably vary in value from one execution of the code to the next. Usually this includes the \u201ceip\u201d tag, but sometimes the context or CS-limit is not known (as example, after loading an X86 segment register).</p><p>The code of the host processor is contained in the translation of an instruction of the target application that causes such an indirect branch contains a number of elements or functions:</p><p>(1) Loading the target application instruction eip into the Fast look-up cache eip register <b>35</b> in data path <b>32</b>;</p><p>(2). Issuing a instruction of the host processor to read the entry in cache <b>36</b> whose index is the low order seven bits of the \u201ceip\u201d value stored in register <b>35</b> (which implements the direct mapped cache look-up), setting the Tag Holding Register <b>38</b> to the \u201ceip\u201d, context and \u201ccs-limit\u201d values read from the entry in cache <b>36</b> and reading the \u201cphys-ip\u201d from the entry in cache <b>36</b> into a register in general purpose registers <b>39</b>.</p><p>(3) compares the tag in the Tag Holding Register with register <b>35</b> for a match;</p><p>(4) loads link register <b>40</b> with one of two alternative values, namely, either (<b>4</b>A) if the tags are found to match, loads the host address from the hardware cache; or, (<b>4</b>B) if the tags do not match, then loads the address of a recovery routine into the link register.</p><p>(5). Translating the eip value into the phys-ip value;</p><p>(7). Compare the peip calculated from the eip with the peip read from cache <b>36</b>, and, if the two values do not match, jumping to the recovery routine; and</p><p>(8). Jump to the link register address either (a) to execute the matching translation or (b) to execute the fixed host processor routines.</p><p>The foregoing elements are wholly or partially included within the translated code (host instruction) of the target processor instruction or are wholly or partially included within fixed host processor routines that are \u201cjumped to\u201d by the translated code (translation). In the preferred embodiment of the invention, the first two elements are included within the translated code and the second two elements are included in the recovery code.</p><p>The recovery code implements the software fast look-up cache, which functions in the same manner as described in connection with the embodiment of FIG. 1, not here repeated. If the desired translation is found in the software fast look-up cache (by matching the tags associated with the address of a translation), then the hardware cache <b>36</b> is also loaded with the translation and associated tags of the translation and processing will jump to the address in the hardware Fast look-up cache entry and execute the translation (instruction) at that address.</p><p>If, however, the desired translation is located in the slow look-up routine hash table, then the translation that was identified is loaded from the translation buffer into both the hardware fast look-up cache <b>36</b> and software fast look-up cache <b>5</b>\u2032.</p><p>As earlier briefly noted, each entry in the cache includes a valid bit. If that bit is set to a digital \u201c1\u201d, the entry is valid; if unset, a digital \u201c0\u201d, then the bit is interpreted by the processor as invalid. On initialization of the host processor all of the valid bits associated with entries in the cache are marked invalid. Each entry written into the cache thereafter changes the associated bit to valid. Only entries having a valid bit of \u201c1\u201d can be successfully matched. When a translation is invalid, the valid bit for a cache entry of that translation, if any, should be set to \u201c0\u201d.</p><p>The Fast look-up stack <b>31</b> operation is next considered. In operation stack <b>31</b> implements call and return instructions of the target processor. The translation of a target processor CALL instruction contains instructions of the host processor to create the effect of the call on the target processor state. That effect is to \u201cpush\u201d the target processor return address onto the memory stack of the target processor. The translation also contains a \u201ccall\u201d atom of the host processor. Execution of the call atom of the host processor is preceded by a WRITE of the target application instruction \u201ceip\u201d, corresponding to the return address of the target processor, into the \u201ceip\u201d register <b>35</b>.</p><p>Execution of the call atom of the host processor then \u201cpushes\u201d the foregoing \u201ceip\u201d, the current target processor context and the CS-limit of the target processor(three of the four values constituting the \u201ctag\u201d to the translation) together with the address of the next instruction of the host processor (e.g. translation) onto stack <b>31</b> at the cell therein to which pointer <b>33</b> is pointing. The foregoing accumulation of data constitutes a single entry in the stack. Ideally the translation of the next target application instruction is accomplished by locating a pre-existing translation in the cache in the manner earlier described.</p><p>The code of the host processor that constitutes the translation of a call instruction of the target application (e.g. target application call instruction) accomplishes a number of functions: First the code execution (1) loads the \u201ceip\u201d of the target application instruction that follows the target call instruction into register <b>35</b>; then (2) performs a \u201cpush\u201d of the \u201ceip\u201d of the next target application instruction onto the target system stack, and perform any other side effects of the target system call instruction; (3) executes a host call instruction which pushes the \u201ceip\u201d, context and CS-limit values stored in register <b>35</b> and the host address of the translation of the next target application instruction onto stack <b>31</b> (ie. increments TOP of stack <b>31</b> and writes the cited values into the stack entry which is being pointed to by TOP); and either (<b>4</b>A) continues processing of target system instructions at the destination of the target call instruction (ie. at the address included in the call instruction); or (<b>4</b>B), in the case of a target system call instruction that constitutes an indirect branch, follows the foregoing procedures earlier described for an indirect branch.</p><p>The code of the host processor that constitutes the translation of a return instruction of the target application (e.g. target application return instruction) accomplishes a number of functions: (1) First, \u201cpop\u201d the return \u201ceip\u201d off of host system stack <b>31</b> and load that \u201ceip\u201d into the \u201ceip\u201d storage in register <b>35</b>; (2) perform any other side effects of the target system return instruction; (3) perform a host system return instruction that loads the tags from the top entry of stack <b>31</b> into Tag Holding Register <b>38</b>; (4) compare (using comparator <b>37</b>) the tags in Tag Holding Register <b>38</b> with the corresponding tags in register <b>35</b>; either (5A), when the tags are found to match, load the host system address for the TOP of stack <b>31</b> into the \u201cnext instruction address\u201d <b>41</b> storage located within host processor <b>1</b>\u2032 and then \u201cpop\u201d the top of the stack; or (5B), when it is found that the tags do not match, raise a return mismatch exception; and (6) continue processing either at the next instruction address or at the return mismatch exception handler, as appropriate.</p><p>When (in the preceding step <b>5</b>A) a match is found, the code (instruction) of the host processor found at that address is a translation of the target processor code found at the return address of the target processor. That code also checks the \u201cphys-ip\u201d of the target code that it translates is the same as the \u201cphys-ip\u201d that was computed from the current \u201ceip\u201d, which is the fourth and last tag, not earlier checked by the return instruction of the host processor.</p><p>To ensure correct translation, each of the four elements of the translation tag must be checked for a match, and that check may be accomplished in either software or in hardware. Only three of the four elements were, as above described, \u201cpushed\u201d at the call site and checked at the return site. Computing the phys-ip of the target application instruction at the call site and at the return site is thought to require too many additional host instructions and to incur too great a latency before the call instruction could be issued and, hence, is not preferred and is not used. Hence, the check of the phys-ip is preferably made at this later stage.</p><p>If, however, the contents of the top of stack <b>31</b> do not match the loaded eip value, current context and cs-limit, the return atom takes a return mismatch exception. Control is then transferred to an exception handler, a software routine designed to deal with and resolve the problem. The exception handler for this exception examines (\u201clooks at\u201d) the next two entries in the stack. If one of the entries matches the loaded \u201ceip\u201d value, current context value, and cs-limit value, the exception handler \u201cpops\u201d the stack a number of times until that matched entry is advanced to the top of the stack (e.g. the stack pointer is decremented to the matched entry); and initiates re-execution of the RET (return) instruction of the host processor. On re-execution the foregoing procedure repeats. This time, however, a match is made, whereupon the process completes as earlier described in the preceding paragraphs, and the next translated target application instruction is executed.</p><p>If the exception handler does not find an entry in the stack to match the value looked-up, the exception handler restores the top of stack <b>31</b> to its previous state and \u201cpushes\u201d a new entry onto the stack that does match. The foregoing push is accomplished by the exception handler by causing the processor to execute a host call atom. The instruction address contained in that entry is the address of the fast look-up cache code, earlier herein described. The return instruction is then re-executed (along with any other interrupted atoms as may be contained in the VLIW instruction) and control is transferred to the Fast look-up routine.</p><p>The operation of the foregoing look-up hardware (in the VLIW processor of the Transmeta processor system) can be accomplished in parallel with other operations associated with the indirect branch and with the target system instructions that preceded the indirect branch. The foregoing parallelism of execution contributes to the greater speed with which the hardware look-up system is able to accomplish a look-up more quickly than that of the software look-up system of the first embodiment.</p><p>As earlier described, stack <b>31</b> is finite in size. Should the number of entries \u201cpushed\u201d onto the stack exceed that size the stack will \u201cwrap\u201d around to the front or top of the stack and over-write prior entries. The effect of such wrapping is to later cause a failure to match an entry in the stack on a later RETurn instruction. Such a failure cannot cause an unrecoverable fault in processing, but merely causes an exception; and that exception is handled in the same manner earlier described on other failures to match an entry, allowing processing to continue.</p><p>It is seen that when popping the stack, it is not necessary to invalidate the entry that was popped from the stack, since the entry cannot be used if there is no match or is ultimately overwritten by a succeeding entry.</p><p>Entries in the stack that point to a translation that is no longer valid, that is invalid host processor code (instruction), must be invalidated so that code cannot be accessed from the stack. As example, the proper translation (host processor code) may have been overwritten. When a translation is invalid, it is necessary to invalidate any entries in the stack that refer to that translation.</p><p>As earlier briefly noted, each entry in the stack includes a valid bit. If that bit is set to a digital \u201c1\u201d, the entry is valid; if unset, a digital \u201c0\u201d, then the bit is interpreted by the processor as invalid. On initialization of the host processor all of the valid bits associated with positions in the stack are marked invalid. Each entry pushed onto the stack thereafter changes the associated bit to valid. Only entries having a valid bit of \u201c1\u201d can be successfully matched. When a translation is invalid, the valid bit for a stack entry for that translation, if any, should be set to \u201c0\u201d.</p><p>When a valid bit of a translation is invalidated, one can mark only the valid bit in the stack entry associated with that translation, if any, as invalid. In the preferred embodiment, when an invalid translation is encountered, the valid bits associated with all the entries in the stack are marked invalid. The latter approach is preferred because the situation rarely occurs and the approach requires less circuitry than the former approach. In those rare occurrences, the invalidation of all the entries in the stack results in a marginal increase in processing latency for a very short time, since new entries will be subsequently entered into the stack during continued execution of the target application.</p><p>Some CALL instructions of the target processor may never be matched with an return instruction of the target processor that \u201cpops\u201d and uses the \u201ceip;\u201d that is \u201cpushed\u201d by the call. If the code morphing software of the host processor recognizes the foregoing circumstance, the code morphing software implements the target processor call without using a call of the host processor. An example of the foregoing is a call that simply jumps to the next target application instruction, usually provided in the program as a way of accessing the target application instruction eip.</p><p>It is believed that the foregoing description of the preferred embodiments of the invention is sufficient in detail to enable one skilled in the art to make and use the invention. However, it is expressly understood that the detail of the elements presented for the foregoing purpose is not intended to limit the scope of the invention, in as much as equivalents to those elements and other modifications thereof, all of which come within the scope of the invention, will become apparent to those skilled in the art upon reading this specification. Thus, the invention is to be broadly construed within the full scope of the appended claims.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "John", "last_name": "Banning", "name": ""}, {"first_name": "Brett", "last_name": "Coon", "name": ""}, {"first_name": "Linus", "last_name": "Torvalds", "name": ""}, {"first_name": "Brian", "last_name": "Choy", "name": ""}, {"first_name": "Malcolm", "last_name": "Wing", "name": ""}, {"first_name": "Patrick", "last_name": "Gainer", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "TRANSMETA CORPORATION"}, {"first_name": "", "last_name": "INTELLECTUAL VENTURES HOLDING 81 LLC", "name": ""}, {"first_name": "", "last_name": "INTELLECTUAL VENTURES HOLDING 81 LLC", "name": ""}, {"first_name": "", "last_name": "INTELLECTUAL VENTURE FUNDING LLC", "name": ""}, {"first_name": "", "last_name": "TRANSMETA LLC", "name": ""}, {"first_name": "", "last_name": "TRANSMETA CORPORATION", "name": ""}, {"first_name": "", "last_name": "TRANSMETA CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/06"}, {"primary": false, "label": "G06F  15/00"}, {"primary": false, "label": "G06F   9/45"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/45        20060101A I20051110RMUS"}, {"label": "G06F   9/455       20060101A I20070721RMEP"}, {"label": "G06F   9/06        20060101A I20051110RMEP"}, {"label": "G06F  15/00        20060101A I20051110RMEP"}], "national_classes": [{"primary": true, "label": "710100"}, {"primary": false, "label": "712205"}, {"primary": false, "label": "711118"}, {"primary": false, "label": "711202"}], "ecla_classes": [{"label": "G06F   9/455B"}], "cpc_classes": [{"label": "G06F   9/30061"}, {"label": "G06F   9/45504"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "2000-06-19", "application_date": "2000-06-19", "family_members": [{"ucid": "US-6615300-B1", "titles": [{"lang": "EN", "text": "Fast look-up of indirect branch destination in a dynamic translation system"}]}, {"ucid": "US-7111096-B1", "titles": [{"lang": "EN", "text": "Fast look-up of indirect branch destination in a dynamic translation system"}]}, {"ucid": "US-7644210-B1", "titles": [{"lang": "EN", "text": "Method and system for storing and retrieving a translation of target program instruction from a host processor using fast look-up of indirect branch destination in a dynamic translation system"}]}]}