{"patent_number": "US-5584002-A", "publication_id": 71366015, "family_id": 21801830, "publication_date": "1996-12-10", "titles": [{"lang": "EN", "text": "Cache remapping using synonym classes"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA37592781\"><p>A method for addressing data in a cache unit which has a plurality of congruence classes, following a failure which disables one or more of the congruence classes in the cache unit. A plurality of synonym classes are established. A subset of the congruence classes is assigned to each of the synonym classes. Any disabled congruence classes are identified. The synonym class to which the disabled congruence class belongs is identified. An alternate congruence class is selected which belongs to the same synonym class as the disabled congruence class. When a request is received by the cache to store a line of data into the disabled congruence class, the line is stored into the alternate congruence class in response to the request.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. In a cache unit adapted for use with a memory used for storing a plurality of data values in a digital processor system, a method for storing said plurality or data values in said memory using said cache trait, said cache trait including:<claim-text>a plurality of congruence classes each for storing a different one of said plurality of data values in said cache unit, and</claim-text><claim-text>a synonym class including ones of said plurality of congruence classes, each of said ones of said congruence classes addressed by a first address field which is identical in each of said ones of said congruence classes and a second address field which differs in each of said ones of said congruence classes,</claim-text><claim-text>wherein at least one of said plurality of congruence classes included in said synonym class is an inoperative congruence class, the method comprising the steps of:<claim-text>(a) determining that one of said plurality of congruence classes is said inoperative congruence class;</claim-text><claim-text>(b) selecting a further one of said plurality of congruence classes included in said synonym class as an alternate congruence class to substitute for said inoperative congruence class;</claim-text><claim-text>(c) storing a synonym class data value in a location associated with said inoperative congruence class to identify said inoperative congruence class as being inoperative;</claim-text><claim-text>(d) storing a further data value in a further location associated with said inoperative congruence class to identify said alternate congruence class as a substitute for said inoperative congruence class;</claim-text><claim-text>(e) storing a congruence class data value in a location associated with said alternate congruence class to identify said alternate congruence class as said alternate congruence class;</claim-text><claim-text>(f) initiating storage of one of said plurality of data values to a memory location in said memory;</claim-text><claim-text>(g) determining that said one of said plurality of data values is intended to be stored in a cache location in said cache unit corresponding to said memory location if, in step (f) a cache hit results, wherein said cache location is said inoperative congruence class;</claim-text><claim-text>(h) storing said one of said plurality of data values into said alternate congruence class by accessing said further data value in said further location associated with said inoperative congruence class;</claim-text><claim-text>(i) transferring said one of said plurality of data values from said alternate congruence class to said memory location which corresponds to said inoperative congruence class;</claim-text></claim-text><claim-text>(j) determining that said one of said plurality of data values is not intended to be stored in said cache unit if in step (f) a cache miss occurs and then performing one of 1) storing said one of said plurality of data values in said memory without storing said one of said plurality of data values in said cache unit and 2) allocating said cache location in said cache unit to receive said one of said plurality of data values.</claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. A method in accordance with claim 1, in which the cache unit has a cache directory with a plurality of entries, further comprising the step of setting an indicator within said cache directory in one of said entries which is associated with said alternate congruence class when said data are stored in said alternate congruence class.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. A method in accordance with claim 1, further comprising the steps of:<claim-text>(g) identifying a further request to retrieve said data from said inoperative congruence class; and</claim-text><claim-text>(h) retrieving said data from said alternate congruence class in response to said further request.</claim-text></claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. A method in accordance with claim 3 in which the system has a cache directory with a plurality of entries, each entry associated with a respective one of said plurality of congruence classes, in which step (h) comprises the steps of:<claim-text>selecting one of said entries which is associated with said disabled congruence class;</claim-text><claim-text>retrieving from said selected entry a value which identifies a further entry that is associated with said alternate congruence class;</claim-text><claim-text>determining whether said further entry contains a value associated with said inoperative congruence class; and</claim-text><claim-text>fetching said data from said alternate congruence class only if said field contains said value associated with said disabled congruence class.</claim-text></claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. A method in accordance with claim 1 which includes the further steps of:<claim-text>using a real address to determine, for which congruence class, storage is requested when transferring said data to said cache unit; and</claim-text><claim-text>using said real address to determine from which congruence class said data is subsequently retrieved.</claim-text></claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. A method in accordance with claim 1 which includes the further steps of:<claim-text>using a virtual address to determine, for which congruence class, storage is requested when transferring said data to said cache unit; and</claim-text><claim-text>using said virtual address to determine from which congruence class said data are subsequently retrieved.</claim-text></claim-text></claim>"}, {"num": 7, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. A cache unit for providing rapid access to a memory used for storing a plurality of data values, said cache unit comprising:<claim-text>(a) congruence class means including a plurality of congruence classes,</claim-text><claim-text>(b) synonym class means including a synonym class, said synonym class including ones of said plurality of congruence classes, each of said ones of said congruence classes addressed by a first address field which is identical in each of said ones of said congruence classes and a second address field which differs in each of said ones of said congruence classes;</claim-text><claim-text>(c) identifying means for determining that one of said plurality of congruence classes is an inoperative congruence class;</claim-text><claim-text>(d) means for selecting a further one of said congruence classes included in said synonym class as an alternate congruence class to substitute for said inoperative congruence class;</claim-text><claim-text>(e) storage means including a location associated with said inoperative congruence class for receiving a synonym class data value which identifies said inoperative congruence class as being inoperative;</claim-text><claim-text>(f) further storage means, including a further location associated with said inoperative congruence class, for receiving a further data value which identifies said alternative congruence class as a substitute for said inoperative congruence class;</claim-text><claim-text>(g) means for storing a congruence class data value in a location associated with said alternate congruence class to identify said alternate congruence class as said alternate congruence class;</claim-text><claim-text>(h) means for initiating storage of one of said plurality of data values to a memory location in said memory;</claim-text><claim-text>(i) means for determining that said one of said plurality of data values is intended to be stored in a cache location in said cache unit corresponding to said memory location if a cache hit results, wherein said cache location is said inoperative congruence class;</claim-text><claim-text>(j) means, responsive to said cache hit, for storing one of said plurality of said data values into said alternate congruence class;</claim-text><claim-text>(k) means for transferring said one of said plurality of data values from said alternate congruence class to said memory location which corresponds to said inoperative congruence class; and</claim-text><claim-text>(l) means for determining that said one of said plurality of data values is not intended to be stored in said cache unit and for then performing one of 1) storing said one of said plurality of data values in said memory without storing said one of said plurality of data values in said cache unit if a cache miss occurs and 2) allocating said cache location in said cache unit to receive said one of said plurality of data values.</claim-text></claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. A system in accordance with claim 7, wherein said cache unit is a direct mapped cache.</claim-text></claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. A system in accordance with claim 7, wherein said cache unit is a set-associative cache.</claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. A system for addressing data in a cache memory which has a plurality of synonym classes, each of said synonym classes having a plurality of congruence classes, following a failure which disables at least one of said congruence classes wherein said cache memory is used with a memory used for storing a plurality of data values, comprising:<claim-text>identifying means for identifying said disabled congruence class;</claim-text><claim-text>means responsive to said identifying means for selecting an alternate congruence class from a subset of said plurality of congruence classes which are in the same synonym class as said disabled congruence class;</claim-text><claim-text>a cache directory which includes a plurality of entries, each respective entry associated with a respective congruence class which is used for storing a different one of said plurality of data values in said cache memory, each entry comprising:<claim-text>(a) a first indicator which indicates whether said associated congruence class is disabled;</claim-text><claim-text>(b) a second indicator which indicates whether said associated congruence class contains data remapped from a further congruence class which is disabled;</claim-text><claim-text>(c) an address tag field which identifies a respective datum which is stored in said associated congruence class; and</claim-text><claim-text>(d) a further field which identifies an alternate congruence class in which said datum is stored as said alternate congruence class if said associated congruence class is disabled; and</claim-text></claim-text><claim-text>means for setting said first and second indicator, said address tag field and said further field associated with said disabled congruence class so as to remap access to said respective datum into said alternate congruence class;</claim-text><claim-text>means for initiating storage of one of said plurality of data values to a memory location in said memory and for determining that said one of said plurality of data values is intended to be stored in a cache location in said cache unit corresponding to said memory location if a cache hit results, wherein said cache location is said disabled congruence class;</claim-text><claim-text>means for transferring said one of said plurality of data values from said alternate congruence class to said memory location which corresponds to said inoperative congruence class; and</claim-text><claim-text>means for determining that said one of said plurality of data values is not intended to be stored in said cache unit and for then performing one of 1) storing said one of said plurality of data values in said memory without storing said one of said plurality of data values in said cache unit if a cache miss occurs and 2) allocating said cache location in said cache unit to receive said one of said plurality of data values.</claim-text></claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. A system in accordance with claim 10, further comprising means for storing a line of data in said alternate congruence class in response to a request to store said line of data in said disabled congruence class if said first indicator is set in one of said entries which is associated with said disabled congruence class.</claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim num=\"12\"><claim-text>12. A system in accordance with claim 11, further comprising means for retrieving said line of data from said alternate congruence class if said first indicator is set in one of said entries which is associated with said disabled congruence class, and said second indicator is set in a further one of said entries which is associated with said alternate congruence class.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES66856708\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates generally to cache memory systems, and in particular, to mechanisms for accommodating hardware failures which disable a subset of the cache storage elements.</p><p>2. Description of the Related Art</p><p>High performance processors have used cache memory systems as an integral component of overall system design for many years. A cache memory typically has a much faster access time than main storage. For example, cache may make use of a relatively small number (N) of high-speed data storage elements, located in close proximity to an associated processor, while main storage typically uses larger numbers of storage elements and is located at some distance from the processor. Cache memory systems have been designed to overcome the access speed limitation of main storage by providing rapid access to a relatively small set of data which is likely to be used during a relatively short time interval.</p><p>If a datum with a given address can be stored in any location within the cache (a fully associative cache) access time is relatively slow, because of the large number of address comparisons required to find the datum. To provide rapid access to data in the cache, most caches limit the number of locations within the cache into which a datum with a given virtual address may be stored. The set-associativity of the cache determines the number of locations in the cache into which a datum with a given address (in main memory) can be placed. The set-associativity of the cache is an important design parameter, influencing the access speed and the cache hit ratio.</p><p>Set associative caches are commonly used. In a set associative cache, a datum with a given address may be stored in one of a limited group of locations in the cache, known as a congruence class. The directory for such a cache will include a row of addresses for each congruence class. To access data in the cache, the addresses in the row are compared to the desired address in parallel, to determine whether the desired datum is stored in the cache in any of the locations within the congruence class. Logic is required to determine which, if any, of the addresses match the desired address. Because a given datum can be stored in more than one location, a replacement strategy may be implemented to retain data in the cache which is likely to be accessed, improving the cache hit ratio.</p><p>When the set associativity is 1, the cache is said to be direct mapped. FIG. 1 shows a conventional direct mapped cache. That is, the congruence class only includes one location for a datum with a given address. FIG. 1 also shows a conventional apparatus for addressing data in a direct mapped cache unit 100. Cache unit 100 includes a cache directory 110 and a cache memory 112. The cache memory includes a plurality of rows, 108a-n, each row including a line of data. Each row 108a-n forms a congruence class with a single set or location within the row into which a given datum may be stored. The cache directory includes entries 180a-n which are associated with respective rows 108a-n. Entries 180a-n include address tags 105a-n which store the high order bits of the respective addresses (in main memory) of the requested data stored in respective rows 108a-n. Valid bits 103a-n indicate whether the data in the associated cache memory storage elements 108a-n are valid. There is also a one-for-one correspondence between the low order bits 116 of the requested address and the entries 180a-n in directory 110, so that it is unnecessary to store the low order bits of the address in entries 180a-n.</p><p>Because cache 100 is direct mapped, identification of a row in cache memory 108a-n is sufficient to determine where a given datum is stored. Because cache 100 uses real placement, the translated ADHIGH bits 114 of the translatable portion of the address are stored in the address tag 105a-n.</p><p>When a datum 120 is requested by the processor 140, the low order bits of the address in ADLOW 116 are used to select a row in directory 110 to check. The directory entry 180a-n contains an address tag which comprises the high order bits of the address in main memory in which the data in the associated cache memory line 105a-n are stored. The address tag 180a-n is compared to ADHIGH 114 at the same time that valid bit 103a-n is checked. If the addresses match and the data is valid, then there is a cache hit and the associated cache memory entry 108a-n is provided to the processor 140.</p><p>The direct mapped structure has a very fast access latency, because for any desired datum, only one address in the cache directory must be compared to the desired address to determine whether the datum is in the cache. The direct mapped cache may also be less expensive, because the logic used in a set-associative cache to perform multiple compares within each congruence class is not needed. For some applications, the faster cache access speed of a direct mapped cache outweighs the slightly higher (relative to set-associative mapping) cache miss rate.</p><p>Nonetheless, direct mapped caches have not been used as widely as set-associative caches. One reason is the inability of a direct mapped cache to accommodate hardware failures. If a location in the cache is subject to a hard failure (a failure of a storage element, the electrical path connecting the element, or the logic that is used to access the element), then data which map to the failed location in the cache cannot be stored in the cache at all. Any reference to data which map to the failed location results in a cache miss; the data must be fetched from main memory, which has a much longer access time than cache.</p><p>While set-associative caches are more reliable, they are not immune to failure. The loss of a single storage element in a set associative cache only disables one set of the congruence class. But a failure in one of the lines used to access the congruence class may result in the loss of an entire congruence class, even in a set associative cache.</p><p>Another aspect of cache memory design is the determination of the number of congruence classes. The simplest method to increase the size of a cache memory is to increase the number of congruence classes without changing set associativity. So long as the number of bits required to uniquely identify the congruence class does not exceed the number of non-translatable bits in the virtual address, the non-translated (virtual) address may be used to request data from the cache. This is faster than using the real (translated) address to access the cache, because there is a delay associated with address translation.</p><p>When the number of congruence classes grows so large that the number of bits in the non-translated portions of the address is insufficient to uniquely identify the congruence class, then the requesting address expands into the translated field. This results in formation of cache synonym classes. A synonym class includes a plurality of congruence classes whose addresses have the same non-translatable address field but different low order bits within the translatable address field. If the virtual address is used to search for a datum in the cache, it is possible that the wrong congruence class within the synonym class is checked. The system responds as if there is a cache miss, even though the desired datum is actually present in the cache in another congruence class different from the class addressed by the request.</p><p>The existence of cache synonym classes has generally been regarded as a problem in cache design, and a number of systems have been disclosed to detect the existence of synonym classes, so that virtual addresses may be used for retrieving data from the cache. Such systems are discussed in U.S. Pat. Nos. 4,332,010 to Messina and 4,400,770 to Chan et al.</p><h4>SUMMARY OF THE INVENTION</h4><p>The present invention is embodied in a method for addressing data in a cache memory unit following a failure which disables one of the congruence classes in the cache. The cache memory unit is adapted for use in a digital processor system. The cache memory unit has a plurality of congruence classes.</p><p>A plurality of synonym classes are established. A respective subset of the congruence classes is assigned to each of the synonym classes. The congruence class which has been disabled by the failure is identified. The synonym classs to which this congruence class is assigned is identified. A further congruence class assigned to the identified synonym class is selected as an alternate congruence class.</p><p>A request to store a line of data into the disabled congruence class is identified. The line of data is stored into the alternate congruence class in response to the request.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 show a prior art cache unit.</p><p>FIG. 2 shows an exemplary embodiment of the invention.</p><p>FIG. 3 is a flow diagram of a process for storing data in accordance with the invention.</p><p>FIG. 4 is a flow diagram of a process for retrieving data in accordance with the invention.</p><p>FIG. 5 shows a further exemplary embodiment of the invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DESCRIPTION OF THE EXEMPLARY EMBODIMENTS</h4><h4>OVERVIEW</h4><p>The present invention is embodied in a cache system in which a hardware failure that disables a congruence class is accommodated by remapping data to an alternate congruence class within the group of congruence classes assigned to the same synonym class as the affected congruence class.</p><p>FIG. 2 shows a cache unit 200 suitable for use in an exemplary cache memory in accordance with the present invention. The cache unit 200 includes a cache directory 210 with addressing information 204a-n and 206a-n and a cache memory 212, in which lines of data are retained. The embodiment of the invention shown in FIG. 2 is adapted for use in a system with a direct mapped cache memory. In a direct mapped cache, a word (datum or instruction, referred to as a datum) with a given virtual address in main memory has a single congruence class in the cache memory into which the datum is stored.</p><p>The cache directory includes, for each congruence class, an entry 280a-n with an AHIGH field 204a-n for the high order bits 222 of the address 220. Cache memory 212 includes respective lines 208a-n for storing data from the locations in main memory (not shown) associated with the respective congruence classes. The low order bits 226 of the address 220 of the datum are implicit in the location of the congruence class in directory 210 and cache memory 212. Valid bits 203a-n identify whether the data in the associated lines 208a-n of cache memory 212 is valid. AHIGH fields 204a-n, data lines 208a-n and valid bits 203a-n are similar to respective fields 180a-n, lines 108a-n and valid bits 103a-n in the conventional cache shown in FIG. 1. Mapping into this single congruence class, defined solely by the address used to store the data in main memory, is referred to as \"canonical mapping.\"</p><p>Cache directory 210 includes three additional fields in the respective entries 280a-n for each congruence class, which are not present in the cache unit shown in FIG. 1. The first added field is the synonym class (SC) field 202a-n. The SC field 202a-n indicates whether there is a hardware failure which has disabled the congruence class associated with each entry 280a-n. The second added field is the Remapped Data (RM) field 201a-n. The RM field 201a-n stores an indicator which indicates whether the congruence class is an \"alternate congruence class\" which contains data that have been remapped from a disabled congruence class. The third added field is the AMID field 206a-n. AMID 206a-n includes additional bits from the address 220 which are used to locate data in the cache. If references to a given disabled congruence class are remapped to an alternate congruence class within the same synonym class, the AMID field 206a-n identifies that alternate congruence class. Replacing a portion 224 of the address 220 of the datum requested by the processor with the value stored in AMID 206a-n for the associated cache entry 280a-n causes the directory to point to the alternate congruence class.</p><p>FIG. 3 is a flow diagram showing an exemplary method in accordance with the present invention. In the exemplary embodiment of FIG. 2, each synonym class includes four congruence classes. That is, there may be four locations in the cache memory for any given ALOW field 226 value. Consequently, the AMID field 206a-n includes two of the higher order bits from the address.</p><p>At step 500, during the power-on sequenced the cache memory 212 is checked for hardware failures. The processor determines whether there is a hardware failure in the storage element 208a-n associated with any congruence class. If there is a failure, at step 502, recovery software in the processor selects an alternate congruence class within the same synonym class as the congruence class disabled by the hardware failure. At step 504, the SC field 202a-n for the disabled congruence class is set to a value to indicate that a failure has been detected. The AMID field 206a-n for the disabled congruence class is set to a value associated with the alternate congruence class. Data from the address in main memory that normally would be mapped to the disabled congruence class (by canonical mapping) may now be stored in cache memory 212 in the alternate congruence class.</p><p>At step 506, the processor issues a request for a datum. At step 508, the datum is fetched from the main memory (not shown) in response to a processor request. The datum is a candidate for storage in the cache 200. At step 510, the low order bits 226 of address 220 are examined. The low order bits 226 identify the congruence class in which the datum may be stored. At step 512, if there is no hardware failure in that congruence class, than at step 514, the datum is stored in the congruence class defined by canonical mapping.</p><p>If, however, at step 512, a hardware failure has disabled the storage element 208a-n associated with this congruence class, then at step 516, the AMID field 206a-n identifies the alternate congruence class to which this congruence class is remapped. At step 518, the value in AMID 206a-n is substituted for the middle bits 224 of the address 220. At step 520, the datum is stored in cache memory 212 in the alternate congruence class defined by the low order bits 226 and the substituted middle bits 224. The RM field 201a-n is set in the alternate congruence class to indicate that the data stored in this line of the cache was stored by remapping, and not by canonical mapping.</p><p>FIG. 4 is a flow chart of a method for retrieving data from cache memory 212 following remapping. At step 400, the cache 200 receives a processor request for data from address 220 (as shown in FIG. 2. At step 402, the congruence class is determined from the low order bits 226 of the address 220. At step 404, the SC field is checked to determine whether this congruence class has a hardware failure. At step 406, if no failure is indicated (no remapping has occurred), then the requested data may be in the cache in the canonical congruence class; at step 408, an address compare for the high order address bits 222 is performed similar to the method used for a conventional cache. At step 409, the RM field 201a-n is checked. At step 409, if RM 201a-n is not set, an address tag comparison is performed at step 411. If the addresses match at step 411, there is a cache hit. If the RM field 201a-n is set at step 409, then the data in the line of the cache is not from the desired line, but has been remapped from another congruence class, so a miss is detected. In other words, this congruence class is the alternate congruence class for a disabled congruence class within the same synonym class.</p><p>If a hardware failure is detected at step 406 (remapping has occurred), then at step 410, the AMID field 206a-n is read from the directory 210 and substituted for the middle bits 224 of the requested virtual address. At step 412, the value of AMID 206a-n is used to identify the alternate congruence class in which the requested data may be stored. The processor will wait for another cache cycle, while the directory 210 entry 280a-n associated with the alternate congruence class is checked. At step 416, the RM field 201a-n of the alternate congruence class is checked. If the address tag (which includes the AHIGH field 204a-n) of the entry 280a-n matches desired value 222 and RM 201a-n is set then there is a cache hit in the alternate congruence class. If RM 201a-n is not set, then the data stored in the alternate congruence class are not remapped from the disabled congruence class and there is a miss. At step 418, if the RM field is set but the address is not the desired address tag, there is a miss.</p><h4>DETAILED DESCRIPTION</h4><p>The first exemplary embodiment of the invention is adapted for use in a synonym free direct mapped cache with real placement.</p><p>FIG. 2 shows an exemplary embodiment of the present invention. In this embodiment, the cache memory 212 is direct mapped with real placement, as is cache memory 112 shown in FIG. 1. Cache memory 212 has N congruence classes which are assigned to S synonym classes, with S being less than N. A real placed cache is inherently synonym free, so a plurality of synonym classes are created and a respective subset of the congruence classes are assigned to each synonym class. Since the purpose of implementing the synonym classes is only to accommodate hardware failures, it is typically sufficient for S to be equal to two or four. In order to implement the invention, synonym classes are established, as would be accomplished by one of ordinary skill in the art, even if the cache has few enough congruence classes to be synonym free (i.e., even if the total number of bits used to reference the congruence class contained in the AMID 224 and ALOW 226 fields is greater than or equal to log<sub>2</sub> N). Directory 210 has a plurality of entries 280a-n, each respective entry 280a-n associated with a respective congruence class.</p><p>Each time the cache unit 200 is powered on, a memory check is performed, as is commonly known in the art. During this memory check, if a cache memory 212 hardware failure is detected (e.g., failure of a conductive path which disables a congruence class) in the i<sup>th</sup> congruence class, then the SC bit 202i of the directory entry associated with the failed line is set to one. The processor 240 selects an alternate congruence class within the same synonym class as the affected congruence class, and stores the identification (AMID) bits which identify the alternate congruence class in the AMID field 206i of the entry for the congruence class disabled by the failure. The SC field 202i and the AMID field 206i retain the values set during the power on sequence until the cache unit 200 is powered off to identify the alternate congruence class.</p><p>When a datum is to be stored in the cache (e.g., following a cache miss) from a particular address in main memory, log<sub>2</sub> N bits of the address are used to identify the location in the cache in which the datum may be stored. Of the log<sub>2</sub> N bits, log<sub>2</sub> S bits are used to identify the congruence class within the synonym class, and log<sub>2</sub> N-log<sub>2</sub> S bits identify the synonym class.</p><p>For example, if there are 128 lines in the cache memory 212 (N=128) then 7 bits are sufficient (log<sub>2</sub> [128]=7) to uniquely identify the 128 congruence classes. The least significant 5 bits of the address form the ALOW part of the address 226 and the next 2 bits (log<sub>2</sub> 4=2) of the addresss form the AMID field 224.</p><p>The cache directory 210 entry 280i (designated by the index \"i\") associated with the values in AMID 224 and ALOW 226 is checked to determine the value of the SC bit. If the SC bit 202i is reset to zero, then there is no hardware failure in this congruence class. The desired datum may be stored in the associated cache memory storage element 208i and the associated valid bit 203i in the directory entry 280i is set to one.</p><p>If the SC bit 202i is set to one, then the request is for storage in a disabled congruence class and the datum to be stored in the cache memory 212 must be stored in the alternate congruence class (designated by subscript \"j\"). The AMID 206i field of the directory 210 entry for the alternate congruence class is substituted for the AMID portion 224 of the address requested. The datum is then stored in the storage element 208j associated with the alternate congruence class, and the address tag (AHIGH 222 and the substituted AMID value 224) is stored in respective fields 204j and 206j of the directory entry 280j for the alternate congruence class. The values in the RM bit 201j and valid bit 203j of the alternate congruence class entry are each set to one. The datum is successfully stored in the cache.</p><p>When the processor subsequently requests retrieval of a datum stored in the cache, the cache directory 210 entry associated with,the requested values in AMID 224 and ALOW 226 is checked to determine the values of the SC 202i and RM 201i indicator bits. The RM field 201i stores an indicator which identifies whether there are data stored in this congruence class which were remapped from a failed congruence class.</p><p>The value of the SC field 202i is stored in a flip-flop 230 for one cycle and the value SC<sub>t-1</sub> from the previous cycle is input to an EXCLUSIVE-NOR gate 236, along with the RM value from 201a-n. If SC<sub>t-1</sub> and RM are different, the output value 236a from gate 236 is 0, and there is a cache miss. If SC<sub>t-1</sub> and RM have the same value, the output value 236a from gate 236 is 1, and there may be a cache hit. Address tag fields 204a-n in the directory 210 entry 280i are compared with respective request fields AHIGH 222 and AMID 226 in respective comparators 232 and 234. If the EXCLUSIVE-NOR output value 236a and the valid bit Vi 203i are both set to one and address tags match (AHIGH 222 matches AHIGH 204i and AMID 224 matches AMID 206i) then there is a cache hit. If any of these conditions is not met, AND gate 238 will provide a zero output signal 238a.</p><p>In the case where SC<sub>t-1</sub> and RM are each reset to zero, then the desired congruence class is functioning properly and any data stored in the i<sup>th</sup> congruence class were placed in the cache by canonical mapping (i.e., the i<sup>th</sup> class is the primary congruence class). The address tag comparison for this case is similar to that in the cache shown in FIG. 1.</p><p>In the second case, SC<sub>t-1</sub> is set to one and RM is reset to zero. This can occur when the primary congruence class is disabled by a hardware failure. When a request is received for data from a disabled congruence class in which the SC field 202i is set to one, A RECYCLE signal 230a is sent to the processor, along with the AMID value 206i in the directory entry 280i. In response to the recycle signal, the processor again requests the datum, except that the AMID value stored in 206i is substituted for the AMID field 224 in the request. When this request is received by the cache unit 200, SC<sub>t-1</sub> is set to one and RMj 201j may be either zero or one. If RMj is reset to zero, then the data contained in the alternate congruence class storage element 208j are not the desired data and were not placed in element 208j by remapping. The j<sup>th</sup> congruence class is the primary class for the data currently stored in element 208j.</p><p>In the third case, SC<sub>t-1</sub> and RM are each set to one. This can also occur when a hardware failure is involved. As in the second case, when a request is received for data from a congruence class in which the SC field 202i is set to one, A RECYCLE signal 230a is sent to the processor, along with the AMID value 206i in the directory entry 280i. In response to the recycle signal, the processor again requests the datum, except that the AMID value stored in 206i is substituted for the AMID field 224 in the request. When this request is received by the cache unit 200, SC<sub>t-1</sub> is set to one. If RMj 201j is set to one, then whatever data are stored in element 208j were stored there as a result of remapping from a congruence class other than the j<sup>th</sup> class. This may result in a cache hit, if other conditions are met. The data in the element 208j may or may not be from the desired i<sup>th</sup> congruence class. If there are more than two congruence classes in a synonym class, then the data stored in element 208j may also have been remapped from one of the remaining two congruence classes within the same synonym class (e.g. the k<sup>th</sup> congruence class). Such a condition is detected by comparator 234, which determines whether the data in element 208j was remapped from the i<sup>th</sup> congruence class. If there are valid data from the i<sup>th</sup> congruence class, then there is a cache hit.</p><p>The fourth possible condition is the one in which SC<sub>t-1</sub> is reset to zero but RM is set to one. This can occur if the primary (i<sup>th</sup>) congruence class is functioning properly, but is serving as the alternate congruence class for a disabled class. For example, assume a condition in which the i<sup>th</sup> congruence class is functioning properly, and the processor issues a request for a datum which maps to the i<sup>th</sup> class. The j<sup>th</sup> congruence class has failed and is remapped to the i<sup>th</sup> class; a line of data which would be canonically mapped to element 208j is remapped to element 208i. Upon receiving the request for a datum that canonically maps to element 208i, the condition will result that SC<sub>t-1</sub> is reset to zero but RM is set to one. The output signal 236a of EXCLUSIVE-NOR gate 236 is reset to zero, and a cache miss is determined from the output signal 238a of AND gate 238 (even though the data in element 208j are valid).</p><p>Further exemplary embodiments of the invention include cache memory systems which are set associative and cache memory systems which use virtual placement. FIG. 5 shows a system which is associative and which uses real placement.</p><p>FIG. 5 shows a system which has a processor 340, a conventional dynamic lookaside address translator (DLAT) 360, and an associative cache unit 300 which includes a cache directory 310 and a cache memory 312. In the exemplary embodiment, each congruence class includes two sets. That is, there are address tags 307a-n and 311a-n and two valid bits 305a-n and 309a-n in the directory 310. Each congruence class also contains two associated data lines 314a-n and 316a-n. It is understood by those skilled in the art that the cache may be dimensioned with a larger number of sets in each congruence class, and the discussion for two sets can be generalized for K sets.</p><p>In this embodiment, the page size in memory is assumed to be 4096 bytes, so that 12 bits are required to identify a byte within the page (i.e., the portion of the address which does not require translation). The cache memory 312 has 128 byte lines, so that 7 bits are required to identify a byte within a line. Finally, the cache has 128 congruence classes, so that 7 bits are required to determine into which congruence class a line of data is stored. Since 7 plus 7 or 14 bits are required to identify the location of a datum in the cache, the cache would not be inherently synonym free if cache placement were based only on the virtual address. Therefore, the congruence class into which data are stored is selected after address translation. The DLAT 360 has storage elements in which recently used address translations are stored. Given a request from the processor for data from a desired virtual address, the DLAT 360 can rapidly provide the real address if the data have been referenced recently. The above mentioned 14 bits are assigned to the AMID 324 and ALOW 326 fields, so that the 12 least significant bits are in ALOW 326 and the 2 most significant bits are in AMID 324. The 17 most significant bits of the address (the remaining bits which must be translated) are in AHIGH 322.</p><p>As in the embodiment of FIG. 2, the address tags in the cache are expanded to include both AHIGH 307a-n and 311a-n and AMID 313a-n fields. ALOW is implicit in the congruence class selection. The 2 bits assigned to AMID 313a-n define four synonym classes in a manner similar to the embodiment of FIG. 2. For a given entry 380i in the directory associated with a single congruence class, only one value of AMID 313i is needed, since AMID is the same for both sets within the congruence class. Because the set associativity of cache 300 is two, the Remapped data (RM), Valid (V) and Address tag (AHIGH) fields are duplicated for each set in the cache. Increasing the set associativity beyond two would require a commensurate increase in the number of each of these fields.</p><p>The labelling of a failed congruence class during the power-on sequence is similar to the labelling for the embodiment shown in FIG. 2 and discussed above. Each time the cache unit 300 is powered on, a memory check is performed. If a cache memory 312 hardware failure is detected in the i<sup>th</sup> congruence class, then the SC bit 301i of the directory entry associated with the failed congruence class is set to one. The processor 340 selects an alternate congruence class within the same synonym class as the affected congruence class, and stores the identification (AMID) bits associated with the alternate congruence class in the AMID field 313i of the entry 380i for the disabled congruence class. The SC field 301i and the AMID field 313i retain the values set during the power on sequence until the cache unit 300 is powered off. The processor selects an alternate congruence class within the same synonym class as the failed congruence class. The value of AMID associated.</p><p>When a datum is to be stored in cache 312, the 14 low order bits of the address, including AMID 324 and ALOW 326 are used to select the congruence class.</p><p>The cache directory 310 entry (designated by the index \"i\") associated with the values in AMID 324 and ALOW 326 is checked to determine the value of the SC bit. If the SC bit 301i is reset to zero, then there is no hardware failure in this congruence class. The desired datum may be stored in one of the associated cache memory storage elements 314i or 316i and the respective valid bit 305i or 309i in the directory entry is set to one. If either element 314i or 316i already is holding data, then a conventional replacement scheme (e.g., least recently used) is used to select the data to replace.</p><p>If the SC bit is set to one, then the datum to be stored in the cache memory 312 must be stored in the alternate congruence class (designated by subscript \"j\"). The alternate congruence class is determined by substituting the AMID 313j field of the directory 310 entry for the alternate congruence class for the original AMID portion 324 of the address requested. The datum is then stored in the storage element 314j (or 316j) associated with the alternate congruence class, and the address tag (AHIGH 322 and the originally requested AMID value 313i of the affected congruence class) is stored in respective fields 307j (or 311j) and 313j of the directory entry for the alternate congruence class. The values in the RM bit 303j (or 308j) and valid bit 305j (or 309j) of the alternate congruence class entry are each set to one. If both of the sets 314j or 316j of the alternate congruence class contain valid data, a known replacement strategy (e.g. least recently used) is used to determine which set of data in the alternate congruence class are replaced by the data remapped from the disabled congruence class. The datum is successfully stored in the cache.</p><p>The four different states discussed above with respect to the embodiment of FIG. 2 (for the different values of SC<sub>t-1</sub> and RM also applicable to the associative cache shown in FIG. 5. In cache 300 however, the RM bits 303a-n and 308a-n may be set independently of one another. When data are remapped into the alternate congruence class J, the RM bits are only set to 1 for the set(s) within the alternate congruence class J which actually store remapped data. It is thus possible for congruence class J to contain only canonically mapped data (Both RM bits 303j and 308j are reset). Class J may contain only remapped data (Both RM bits 303j and 308j are set to 1). Or class J may contain a combination of remapped and canonically mapped data (Bit 303j is set and bit 308j reset, or bit 303j is reset and bit 308j set). For example, if RMja 303j is set to 1 and RMjb 308j is reset to zero, then cache storage element 314j has remapped data (remapped from the failed congruence class identified by the value stored in AMID 313j). Cache storage element 316j has canonically mapped data.</p><p>When the processor subsequently requests a datum stored in the cache, the cache directory 310 entry for the congruence class associated with the requested values in AMID 324 and ALOW 326 is checked to determine the values of the SC 301i and RM 303i and 308i bits. The SC field 301i identifies whether the i<sup>th</sup> congruence class is functioning normally (SC=0) or has failed (SC=1). The RM fields 303i and 308i identify whether there are data stored in this congruence class which were remapped from a failed congruence class. When an SC value of 1 is detected, then a recycle signal 329 is sent to the processor. On the next cache cycle, a request for data from the alternate congruence class is made by requesting data from the congruence class identified by the AMID 313i field in the failed congruence class.</p><p>The value of the SC field 301i is stored in a flip-flop 330 for one cycle and the value SC<sub>t-1</sub> from the previous cycle is input to an EXCLUSIVE-NOR gates 336a and 336b, along with the respective RM values from 303i and 308i. If SC<sub>t-1</sub> and RMi 303a (or 308i) are different, the output value 337a (or 337b) from gate 336a (or 336b) is 0, and the desired data are not in storage element 314i (or 316i). If SC<sub>t-1</sub> and RMi 303i (or 308i) have the same value, the output value 337a (or 337b) from gate 336a (or 336b) is 1, and there may be a cache hit in storage element 314i (or 316i). Address tag fields 307i, 311i and AMID 313i in the directory 310 entry are compared with respective request fields AHIGH 322 and AMID 326 in comparators 332a, 332b, 334a and 334b. If the EXCLUSIVE-NOR output value 336a (or 336b) and one of the valid bits 305i (or 309i) are both set to ones and the address tags match (AHIGH 322 matches AHIGH 307i or 311i; and AMID 224 matches AMID 313i) then there is a cache hit. One of the AND gates 338a and 338b will be set to one if there is a hit in respective cache element 314i or 316i. When either of these AND gates is set to one, OR gate 342a is sets indicating a cache hit, and the respective data line stored in 314i or 316i is output from D parallel OR gates 342b, where D is the number of bits in the data field.</p><p>It is understood by those skilled in the art that the embodiment of FIG. 5 may be employed in virtually placed caches. In a virtually placed cache, the cache request comes directly from processor 340 via lines 320a and 320b, not from the DLAT 360. The processor 360 provides the virtual address high order bits to comparators 332a-b and the middle bits to comparators 334a-b. The address translation is done in parallel with the cache directory lookup. The real address produced by the DLAT is compared with the address tag output by the directory 310 and if they match, there is a hit.</p><p>The embodiment of FIG. 5 with virtual placement may also be varied, so that some of the translatable bits of the virtual address are used to identify the congruence class. For example, if the same cache 300 described above (with 128 congruence classes and 128 bytes per line) is used in a system in which the virtual page size is 4096 bytes, 2 untranslated bits are used to identify the congruence class. The virtual address only includes 12 bits which do not require translation. But as described above, 14 bytes are required to uniquely identify a congruence class in cache 300. In other words, there are synonym classes inherent in the system.</p><p>When untranslated bits are used to address the cache, several methods may be used to correctly store and fetch data. Both the hit ratio and coherence are considerations in choosing a method. One method is to increase the size of the cache directory 310, so that each row 380a-n of the directory includes all of the congruence classes within the same synonym class as the desired congruence class. Each time a congruence class is interrogated to look for an address tag AHIGH, the other congruence classes in the same synonym class would also be checked. For the case where there are four congruence classes in each synonym class, this would mean quadrupling the size (i.e. the number of columns in each entry 380a-n) of the directory. Although this method has a high hit ratio and ensures coherence, it increases hardware costs.</p><p>A second method would include address tag compares for all of the congruence classes in the synonym class, for every request. This method also ensures coherence, but it slows down response time since additional accesses to the directory are made. The impact on response time can be reduced by only checking all of the congruence classes within the synonym class during store operations. On fetch operations, if the first address tag compare shows a hit, then the remaining congruence classes within the synonym class are not checked for the presence of the data. In most cases, the desired data are found on the first cache access. If the data are not found on the first access, then the remaining congruence classes in the synonym class are checked sequentially until either a hit is detected or all of the congruence classes within the synonym class have been checked without an address tag match, in which case there is genuinely a cache miss. This method requires more complex hardware to implement.</p><p>A third method is to just treat the virtual address like a real address. If there is no address tag match in the congruence class selected by the low order (not requiring translation) and middle order (requiring translation, but not translated) bits, then the reference is treated as a cache miss; other congruence classes in the same synonym class are not checked. This is simple to implement, but has a higher miss ratio.</p><p>Those skilled in the art will recognize that other known synonym detection techniques used during fetch operations in conventional synonym detection systems for virtual-placed caches may be modified and adapted for use, in conjunction with congruence class remappping as discussed with reference to the embodiments of FIGS. 2 and 5.</p><p>Another variation of the embodiment of FIG. 5 includes within each directory 310 entry 380a-n a separate AMID field (not shown) for each set within the associated congruence class. If each synonym class includes more than two congruence classes (i.e., AMID includes at least two bits), then a single congruence class could store remapped data from more than one failed congruence class. The individual AMID fields in the entry would identify the failed class from which the data in each set are remapped.</p><p>It is understood by one skilled in the art that many variations of the embodiments described herein are contemplated. While the invention has been described in terms of exemplary embodiments, it is contemplated that it may be practiced as outlined above with modifications within the spirit and scope of the appended claims.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Philip G.", "last_name": "Emma", "name": ""}, {"first_name": "Joshua W.", "last_name": "Knight", "name": ""}, {"first_name": "Keith N.", "last_name": "Langston", "name": ""}, {"first_name": "James H.", "last_name": "Pomerene", "name": ""}, {"first_name": "Thomas R.", "last_name": "Puzak", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTERNATIONAL BUSINESS MACHINES CORPORATION"}, {"first_name": "", "last_name": "INTERNATIONAL BUSINESS MACHINES CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  11/20"}], "locarno_classes": [], "ipcr_classes": [{"label": "G11C  29/00        20060101A I20051008RMEP"}, {"label": "G06F  12/08        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711003"}, {"primary": false, "label": "711E12018"}, {"primary": false, "label": "711165"}, {"primary": false, "label": "711202"}, {"primary": false, "label": "711118"}], "ecla_classes": [{"label": "G11C  29/88"}, {"label": "T05K999:99"}, {"label": "G06F  12/08B10"}], "cpc_classes": [{"label": "G06F  12/0864"}, {"label": "G06F  12/0864"}, {"label": "G11C  29/88"}, {"label": "G11C  29/88"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1993-02-22", "application_date": "1993-02-22", "family_members": [{"ucid": "US-5584002-A", "titles": [{"lang": "EN", "text": "Cache remapping using synonym classes"}]}]}