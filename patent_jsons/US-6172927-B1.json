{"patent_number": "US-6172927-B1", "publication_id": 72538234, "family_id": 46257007, "publication_date": "2001-01-09", "titles": [{"lang": "EN", "text": "First-in, first-out integrated circuit memory device incorporating a retransmit function"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11123659\" source=\"national office\"><p>An integrated circuit first-in, first-out (\"FIFO\") memory device comprises an input bus for receiving data, an input buffer coupled to the input bus for storing the data and at least one dynamic random access memory (\"DRAM\") array coupled to the input buffer. A write pointer is operative for storing the data in the input buffer to a location within the memory array indicated and an output bus is coupled to the memory array and a read pointer for providing previously written data from the memory array at a location indicated by the read pointer. In a preferred embodiment, the FIFO further comprises at least one static random access memory (\"SRAM\") row, or register, interposed between the input and output buses and the memory array having a width corresponding to each row of the memory array. In an alternative embodiment, the FIFO memory device includes a \"Retransmit\" feature which allows data to be read from the device multiple times as well as the Read Pointer to be selectively placed under user control. In a specific embodiment, the Read or Output bus may also be used as an address bus.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72495578\"><p>An integrated circuit first-in, first-out (\u201cFIFO\u201d) memory device comprises an input bus for receiving data, an input buffer coupled to the input bus for storing the data and at least one dynamic random access memory (\u201cDRAM\u201d) array coupled to the input buffer. A write pointer is operative for storing the data in the input buffer to a location within the memory array indicated and an output bus is coupled to the memory array and a read pointer for providing previously written data from the memory array at a location indicated by the read pointer. In a preferred embodiment, the FIFO further comprises at least one static random access memory (\u201cSRAM\u201d) row, or register, interposed between the input and output buses and the memory array having a width corresponding to each row of the memory array. In an alternative embodiment, the FIFO memory device includes a \u201cRetransmit\u201d feature which allows data to be read from the device multiple times as well as the Read Pointer to be selectively placed under user control. In a specific embodiment, the Read or Output bus may also be used as an address bus.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00001\" num=\"1\"><claim-text>1. A memory device comprising:</claim-text><claim-text>an input data bus for receiving input data to be written to said memory device; </claim-text><claim-text>a dynamic random access memory array coupled to receive said input data and to store said input data therein at a location within said memory array determined by a write pointer; </claim-text><claim-text>at least one static memory row coupled to said memory array for holding at least a portion of said input data stored in said memory array as determined by a read pointer; and </claim-text><claim-text>an output bus coupled to said at least one static memory row for supplying said at least a portion of said input data as output data thereon, said memory device operative such that writes to said memory device are made at least to said memory array and reads from said memory device are from at least said at least one static memory row. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00002\" num=\"2\"><claim-text>2. The memory device of claim <b>1</b> wherein said output bus further comprises an address bus for selectively placing said read pointer at a selected location in said memory array.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00003\" num=\"3\"><claim-text>3. The memory device of claim <b>1</b> further comprising a retransmit input for causing said memory device to reposition said read pointer to a previous location in said memory array to again supply at least a portion of said output data on said output bus.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00004\" num=\"4\"><claim-text>4. The memory device of claim <b>1</b> further comprising:</claim-text><claim-text>an address offset register for allowing said read and write pointers to be repositioned within said memory device in accordance with an offset value stored therein. </claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00005\" num=\"5\"><claim-text>5. The memory device of claim <b>4</b> further comprising:</claim-text><claim-text>a polarity indication input in conjunction with said address offset register for allowing said read and write pointers to be selectively incremented or decremented by said offset value. </claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00006\" num=\"6\"><claim-text>6. The memory device of claim <b>1</b> further comprising:</claim-text><claim-text>a return input for causing said memory device to return said read pointer to a predetermined location in said memory array. </claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00007\" num=\"7\"><claim-text>7. The memory device of claim <b>6</b> wherein said predetermined location is a previous location of said read pointer in said memory array.</claim-text></claim>"}, {"num": 8, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00008\" num=\"8\"><claim-text>8. The memory device of claim <b>6</b> wherein said predetermined location is a previous location plus an additional increment of said read pointer in said memory array.</claim-text></claim>"}, {"num": 9, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00009\" num=\"9\"><claim-text>9. The memory device of claim <b>6</b> wherein said predetermined location is determined in accordance with a value stored in a mode register.</claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00010\" num=\"10\"><claim-text>10. The memory device of claim <b>9</b> further comprising:</claim-text><claim-text>at least one input for programming said value stored in said mode register. </claim-text></claim>"}, {"num": 11, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00011\" num=\"11\"><claim-text>11. The memory device of claim <b>1</b> wherein said dynamic random access memory array comprises a plurality of dynamic random access memory banks.</claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00012\" num=\"12\"><claim-text>12. The memory device of claim <b>11</b> wherein said at least one static memory row comprises a plurality of static random access memory banks.</claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00013\" num=\"13\"><claim-text>13. The memory device of claim <b>12</b> wherein each of said plurality of dynamic random access memory banks is associated with a corresponding one of said plurality of static random access memory banks.</claim-text></claim>"}, {"num": 14, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00014\" num=\"14\"><claim-text>14. The memory device of claim <b>12</b> wherein said plurality of dynamic random access memory banks are freely associated with said plurality of static random access memory banks.</claim-text></claim>"}, {"num": 15, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00015\" num=\"15\"><claim-text>15. The memory device of claim <b>1</b> further comprising:</claim-text><claim-text>a memory device \u201cReady\u201d output. </claim-text></claim>"}, {"num": 16, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00016\" num=\"16\"><claim-text>16. the memory device of claim <b>1</b> further comprising:</claim-text><claim-text>a memory device \u201cWait\u201d output. </claim-text></claim>"}, {"num": 17, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00017\" num=\"17\"><claim-text>17. An integrated circuit first-in, first-out memory device comprising:</claim-text><claim-text>an input bus for receiving data to be written to said memory device; </claim-text><claim-text>an input buffer coupled to said input bus for storing said data; </claim-text><claim-text>at least one dynamic random access memory array coupled to said input buffer and a write pointer for storing said data in said input buffer to a location within said memory array indicated by said write pointer; </claim-text><claim-text>an output bus coupled to said memory array and a read pointer for providing previously written data from said memory array at a location indicated by said read pointer, said read pointer being selectively placeable at any location in said memory array under user control; and </claim-text><claim-text>at least one static random access memory row interposed between said input and output buses and said memory array. </claim-text></claim>"}, {"num": 18, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00018\" num=\"18\"><claim-text>18. The memory device of claim <b>17</b> wherein said at least one static random access memory row has a width corresponding to that of said memory array.</claim-text></claim>"}, {"num": 19, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00019\" num=\"19\"><claim-text>19. The memory device of claim <b>17</b> wherein said at least one static random access memory row has a width corresponding to a portion of that of said memory array.</claim-text></claim>"}, {"num": 20, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00020\" num=\"20\"><claim-text>20. The memory device of claim <b>17</b> wherein said at least one dynamic random access memory array comprises first and second memory array banks.</claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00021\" num=\"21\"><claim-text>21. The memory device of claim <b>20</b> wherein said at least one static random access memory row comprises at least first and second static random access memory rows interposed between said input and output buses and said first and second memory array banks.</claim-text></claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00022\" num=\"22\"><claim-text>22. The memory device of claim <b>21</b> wherein each of said first and second static random access memory rows have a width corresponding to that of each of said first and second memory array banks.</claim-text></claim>"}, {"num": 23, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00023\" num=\"23\"><claim-text>23. The memory device of claim <b>21</b> wherein each of said first and second static random access memory rows have a width corresponding to a portion of that of each of said first and second memory array banks.</claim-text></claim>"}, {"num": 24, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00024\" num=\"24\"><claim-text>24. The memory device of claim <b>20</b> wherein said first and second memory array banks are alternatively mapped with rows of said data.</claim-text></claim>"}, {"num": 25, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00025\" num=\"25\"><claim-text>25. The memory device of claim <b>17</b> further comprising a retransmit input for causing said memory device to reposition said read pointer to a previous location in said memory array to again supply at least a portion of said previously written data on said output bus.</claim-text></claim>"}, {"num": 26, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00026\" num=\"26\"><claim-text>26. The memory device of claim <b>17</b> further comprising:</claim-text><claim-text>an address offset register for allowing said read and write pointers to be repositioned within said memory device in accordance with an offset value stored therein. </claim-text></claim>"}, {"num": 27, "parent": 26, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00027\" num=\"27\"><claim-text>27. The memory device of claim <b>26</b> further comprising:</claim-text><claim-text>a polarity indication input in conjunction with said address offset register for allowing said read and write pointers to be selectively incremented or decremented by said offset value. </claim-text></claim>"}, {"num": 28, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00028\" num=\"28\"><claim-text>28. The memory device of claim <b>17</b> further comprising:</claim-text><claim-text>a return input for causing said memory device to return said read pointer to a predetermined location in said memory array. </claim-text></claim>"}, {"num": 29, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00029\" num=\"29\"><claim-text>29. The memory device of claim <b>28</b> wherein said predetermined location is a previous location of said read pointer in said memory array.</claim-text></claim>"}, {"num": 30, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00030\" num=\"30\"><claim-text>30. The memory device of claim <b>28</b> wherein said predetermined location is a previous location plus an additional increment of said read pointer in said memory array.</claim-text></claim>"}, {"num": 31, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00031\" num=\"31\"><claim-text>31. The memory device of claim <b>28</b> wherein said predetermined location is determined in accordance with a value stored in a mode register.</claim-text></claim>"}, {"num": 32, "parent": 31, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00032\" num=\"32\"><claim-text>32. The memory device of claim <b>31</b> further comprising:</claim-text><claim-text>at least one input for programming said value stored in said mode register. </claim-text></claim>"}, {"num": 33, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00033\" num=\"33\"><claim-text>33. The memory device of claim <b>17</b> wherein said dynamic random access memory array comprises a plurality of dynamic random access memory banks.</claim-text></claim>"}, {"num": 34, "parent": 33, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00034\" num=\"34\"><claim-text>34. The memory device of claim <b>33</b> wherein said static random access memory row comprises a plurality of static random access memory banks.</claim-text></claim>"}, {"num": 35, "parent": 34, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00035\" num=\"35\"><claim-text>35. The memory device of claim <b>34</b> wherein each of said plurality of dynamic random access memory banks is associated with a corresponding one of said plurality of static random access memory banks.</claim-text></claim>"}, {"num": 36, "parent": 34, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00036\" num=\"36\"><claim-text>36. The memory device of claim <b>34</b> wherein said plurality of dynamic random access memory banks are freely associated with said plurality of static random access memory banks.</claim-text></claim>"}, {"num": 37, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00037\" num=\"37\"><claim-text>37. The memory device of claim <b>17</b> further comprising: memory device \u201cReady\u201d output.</claim-text></claim>"}, {"num": 38, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6172927-B1-CLM-00038\" num=\"38\"><claim-text>38. The memory device of claim <b>17</b> further comprising: memory device \u201cWait\u201d output.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54478127\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><h4>CROSS REFERENCE TO RELATED PATENT APPLICATIONS</h4><p>The present application is a continuation-in-part of U.S. patent application Ser. No. 09/266,472 filed Mar. 11, 1999 now U.S. Pat. No. 6,072,741for \u201cFirst-in, First-Out Integrated Circuit Memory Device Incorporating a Retransmit Function\u201d, which patent application is a continuation-in-part of U.S. patent application Ser. No. 08/840,118 filed Apr. 1, 1997 now U.S. Pat. No. 5,901,100 issued May 4, 1999 for \u201cFirst-In, First-Out Integrated Circuit Memory Device Utilizing a Dynamic Random Access Memory Array for Data Storage Implemented in Conjunction with an Associated Static Random Access Memory Cache\u201d, both assigned to Enhanced Memory Systems, Inc., Colorado Springs, Colo., assignee of the present invention, the disclosures of which are herein specifically incorporated by this reference.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>The present invention relates, in general, to a first-in, first-out (\u201cFIFO\u201d) integrated circuit (\u201cIC\u201d) memory device. More particularly, the present invention relates to a FIFO memory device utilizing a dynamic random access memory (\u201cDRAM\u201d) memory array implemented in conjunction with enhanced dynamic random access memory technology (\u201cEDRAM\u00ae\u201d is a trademark of Enhanced Memory Systems, Inc.) in lieu of a conventional static random access memory (\u201cSRAM\u201d) based memory array.</p><p>FIFOs are integrated circuit (\u201cIC\u201d) devices which integrate a memory array, such as dual-ported SRAM memory array, with associated on-chip logic which may be utilized in a wide variety of data buffering applications such as graphics, disk controllers and communication networks. Despite requiring up to six transistors per memory cell as opposed to a single transistor and capacitor, SRAM memory has nevertheless been used in these applications due to its significant speed advantage over conventional dynamic random access memory (\u201cDRAM\u201d) due to the latter's inherent delays in bit line precharge, memory cell refresh, row access times and the like.</p><p>A FIFO memory's function allows quick write and read bursts to minimize the time spent by a central processing unit (\u201cCPU\u201d) when communicating with slower circuit elements thereby allowing the highest performance on the computer bus. FIFOs may also be used to enhance the throughput of time-critical systems developed for digital signal processing (\u201cDSP\u201d). Typical applications may involve allowing high speed throughput between DSPs in pipelined and parallel applications, supporting communications between a DSP and a host processor and buffering data between mismatched processor speeds and the buses. Typically, FIFO buffer memories allow the matching of multiple asynchronous systems whereby one system is operating at a significantly different clock frequency than another in order that data from one system may be temporarily stored before being read out for processing. Characteristically, the length of the FIFO is determined by the difference in clock rates and the amount of data to be buffered. When utilizing dual-ported SRAM, conventional FIFOs allow simultaneous access to the memory through two independent \u201cwrite\u201d and \u201cread\u201d ports. Since the data is always contiguous, an address bus is not needed and data is read out in the same order in which it was received.</p><p>In a synchronous FIFO, data may be clocked into and out of registers which buffer the actual memory array, so that shorter data setup and hold times are possible than with asynchronous FIFOs. Synchronous FIFOs also provide easier integration into synchronous systems. Writing and reading operations are controlled by \u201cwrite\u201d and \u201cread\u201d enables, while the \u201cwrite\u201d and \u201cread\u201d clocks may have either the same or different frequencies or have differing phase relationships.</p><p>In conventional FIFO design, four \u201cflags\u201d are provided to give the user information on the status of the memory array. In dual-ported RAM arrays, dedicated write and read address pointers are utilized, and the flag logic prevents illogical writes and reads from occurring. The \u201cempty\u201d flag indicates that the read and write cycle counts are equal, and will be automatically asserted after a reset, which functions to reset the cycle counters and returns both read and write pointers to memory address zero. The empty flag, therefore, prevents reading while empty, a data underflow condition. As a result, if the memory array is empty, a read cycle is inhibited until at least one data entry has been written.</p><p>On the other hand, a \u201cfull\u201d flag indicates that the write and read counts are at a maximum distance apart, which implies that a full load of data has been written to the FIFO and has not yet been read out. The full flag, therefore, prevents writing while full, a data overflow condition. If the memory array is full, a write cycle is inhibited until at least one data entry has been read out. Once data that has been stored at a given address is read, it can then be overwritten. In such conventional FIFO operation, as long as the read pointer is advancing due to read cycles, the write pointer will \u201cwrap around,\u201d continuing past the last memory address and beginning again at the first memory address until the difference between the write and read counters indicate that the FIFO is full. Therefore, the flag status of the FIFO is a function of the difference between the pointers and not their absolute value. Resetting the FIFO simply initializes the address pointers to address zero.</p><p>The other pair of \u201cflags\u201d are conventionally known as programmable \u201calmost empty\u201d and programmable \u201calmost full\u201d flags which are user programmable to provide a preset offset before the empty and full conditions are reached to provide early warning to the user of approaching states of fullness or emptiness. In conventional FIFOs, multiple write enables and read enables are provided to be utilized at reset times to configure the FIFO for programmable flags.</p><p>To enable high speed device operation, conventional FIFOs have utilized SRAM memory arrays which are capable of reading and writing data more quickly than DRAM memory due, in part, to the fact that DRAM memory must be periodically refreshed, the bit lines precharged and the like. However, SRAM memory cells generally comprise four or even six transistors per memory cell as opposed to the single transistor and capacitor of the typical DRAM memory cell. As a consequence, SRAM memory cannot be as densely integrated as DRAM memory and is, therefore, more space consuming in terms of on-chip die area required to fabricate a comparable size memory array and consequently more costly to produce.</p><h4>SUMMARY OF THE INVENTION</h4><p>The EDRAM integrated circuit memory device architecture disclosed in the aforementioned United States Patent Applications is designed to minimize delays associated with row access, precharge and refresh operations of a conventional DRAM memory array. Essentially, this is accomplished through the integration of one or more relatively small SRAM row(s), or register(s), associated with the DRAM memory which allows reads to the device to be made only from the SRAM row(s) and, therefore, to be allowed to occur during refresh and precharge cycles of the DRAM array. Moreover, the SRAM row(s) and DRAM array are sufficiently decoupled so that writes to the device can occur to the DRAM (with a write-through to the SRAM if a row \u201chit\u201d occurs) and reads and writes to the device can occur simultaneously. Alternatively, a common read/write path can be utilized to achieve a simplified architecture which provides the capability to hide DRAM precharge and refresh activities. The benefits of simultaneous read/writes versus a simplified common read/write path must be evaluated based on desired product price/performance positioning. As a consequence, utilizing EDRAM memory device technology, significantly smaller chip sizes can be achieved while maintaining the same number of array bits or much higher array density can be achieved while maintaining the same chip size. Both approaches yield an improved cost performance point.</p><p>Particularly disclosed herein is an integrated circuit FIFO memory device which comprises an input bus for receiving data, an input buffer coupled to the input bus for storing the data and at least one DRAM array coupled to the input buffer. A write pointer is operative for storing the data in the input buffer to a location within the memory array indicated and an output bus is coupled to the memory array and a read pointer for providing previously written data from the memory array at a location indicated by the read pointer. In a preferred embodiment, the FIFO further comprises at least one or more SRAM row(s) interposed between the input and output buses and the memory array having a width corresponding to each row of the memory array. Other embodiments where the SRAM rows have a width equal to a fraction and multiples of a row width are possible. The SRAM row(s) can be directly mapped to a memory array block or can be freely associative.</p><p>Disclosed herein is a DRAM-based FIFO memory device which incorporates a Retransmit feature. Further disclosed herein is a DRAM-based FIFO memory device which incorporates a Retransmit feature as well as one or more SRAM row(s) associated with the memory array. Also disclosed herein is a FIFO memory device which includes a Retransmit function as well as using the output data bus as an address bus for selectively repositioning the Read pointer in accordance with an address placed on the address bus. Still further disclosed herein is a FIFO memory device that incorporates an offset register to facilitate the movement of either or both of the Read and Write pointers under user control. Also further disclosed herein is a FIFO memory device incorporating a Return function which allows the read pointer to return to a previous location or a selected offset to a previous location in the memory array. Additionally disclosed herein is a FIFO memory device that allows for the placement of the Read pointer anywhere in the memory array under user selectable control.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>The aforementioned and other features and objects of the present invention and the manner of attaining them will become more apparent and the invention itself will be best understood by reference to the following description of a preferred embodiment taken in conjunction with the accompanying drawings, wherein:</p><p>FIG. 1 is a representative functional block diagram of a FIFO memory device in accordance with the present invention utilizing, for example, multiple DRAM banks as a primary memory array in lieu of conventional SRAM based architectures and wherein this particular exemplary embodiment shows a direct map between each bank and the SRAM row(s) although fully associative mapping is also possible, wherein any of the SRAM row(s) can be associated with either bank;</p><p>FIG. 2 is a logic flowchart beginning with the initialization of the representative device of FIG. 1 useful in understanding the control procedure for a FIFO memory device in accordance with the present invention;</p><p>FIGS. 3A and 3B are a further, more detailed, logic flowchart illustrating the main control loop depicted in the flowchart of FIG. 2;</p><p>FIG. 4 is a further, more detailed, logic flowchart illustrating the \u201cmemory not ready\u201d (\u201cMNRF\u201d) flow illustrated in the flowchart of FIGS. 3A and 3B;</p><p>FIG. 5 is a further, more detailed, logic flowchart illustrating the MNRF write multiplexer (\u201cmux\u201d) counter flag (\u201cWMCF\u201d) flow referenced in the preceding FIG. 4;</p><p>FIG. 6 is a further, more detailed, logic flowchart illustrating the MNRF read mux counter flag (\u201cRMCF\u201d) flow referenced in the preceding FIG. 4;</p><p>FIGS. 7A and 7B are a further, more detailed, logic flowchart illustrating the MNRF refresh flag (\u201cRFF\u201d) flow referenced in the preceding FIG. 4;</p><p>FIG. 8 is a further, more detailed, logic flowchart illustrating the SRAM only flow;</p><p>FIGS. 9A and 9B are a further, more detailed, logic flowchart illustrating the MNRF maximum (\u201cmax\u201d) access time flag (\u201cMATF\u201d) flow referenced in the preceding FIG. 4;</p><p>FIG. 10 illustrates a functional block diagram of an alternative embodiment of a FIFO memory device in accordance with the present invention incorporating a \u201cRetransmit\u201d function which allows for data to be read from the device more than once; and</p><p>FIG. 11 is a representative logic flow diagram illustrative of the functional operation of the FIFO memory device of FIG. <b>10</b>.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DESCRIPTION OF A PREFERRED EMBODIMENT</h4><p>With reference now to FIG. 1, a first-in, first-out (\u201cFIFO\u201d) memory device <b>10</b> is shown. The memory device <b>10</b> comprises, in pertinent part, a primary DRAM memory array comprising DRAM bank <b>0</b> (<b>12</b>A) and DRAM bank <b>1</b> (<b>12</b>B). An SRAM row comprising SRAM bank <b>0</b> (<b>14</b>A) and SRAM bank <b>1</b> (<b>14</b>B) is associated with each of the DRAM banks <b>12</b>A and <b>12</b>B respectively.</p><p>Data input to the memory device <b>10</b> is supplied on a data input bus <b>16</b> through an optional pre-input buffer <b>18</b> to an input multiplexer (\u201cmux\u201d) <b>20</b>, as shown. Data input on the data input bus <b>16</b> is ultimately maintained within an input buffer <b>22</b> at a location determined by the input multiplexer <b>20</b>. The input buffer <b>22</b> is nominally an input buffer (\u201cIB\u201d) number of words deep.</p><p>Data maintained within the input buffer <b>22</b> is alternately supplied to the SRAM rows <b>14</b>A and <b>14</b>B in accordance with a write pointer <b>24</b> and write multiplexer <b>26</b>. The write pointer <b>24</b> and write multiplexer <b>26</b> are controlled by an input/output (\u201cI/O\u201d) and control block <b>28</b>. The I/O and control block <b>28</b> is bidirectionally coupled to a number of external inputs/outputs for the memory device <b>10</b> including, inter alia, a \u201cfull\u201d output <b>30</b>, an \u201cempty\u201d output <b>32</b>, a master reset input <b>34</b>, a write clock input <b>36</b> and a read clock input <b>38</b>.</p><p>Data maintained within the SRAM rows <b>14</b>A and <b>14</b>B is supplied, respectively, to corresponding rows within the DRAM banks <b>12</b>A and <b>12</b>B in accordance with instructions from a refresh and maximum access time control block <b>40</b> as will be more fully described hereinafter. Data ultimately read from the DRAM banks <b>12</b>A and <b>12</b>B is supplied on a data output bus <b>50</b> through an optional pre-output buffer <b>48</b> in accordance with an I/O and control block <b>42</b>, a read pointer <b>44</b> and read multiplexer <b>46</b>. The I/O and control blocks <b>28</b> and <b>42</b> are bidirectionally coupled to the refresh and maximum access time control block <b>40</b>, as well as to the input/output pins of the memory device <b>10</b>.</p><p>As noted previously, FIFOs have typically been designed using only SRAM technology memory arrays because DRAM technology has been too slow and the delays (i.e. row access, precharge, refresh, maximum access time, etc.) have made any other implementation other than SRAM inadequate.</p><p>The EDRAM technology developed by Enhanced Memory Systems, Inc. serves to minimize delays associated with row access, precharge, and therefore refresh in DRAM arrays. The EDRAM architecture employs one or more small SRAM row(s) which allow reads to occur during refresh and precharge cycles of the DRAM array. Functionally, the SRAM row(s) and DRAM array are sufficiently decoupled so that writes can occur to the SRAM or DRAM or both and reads from the SRAM and writes to the DRAM can occur simultaneously.</p><p>These features provide the efficiency necessary to enable the design of a FIFO utilizing a DRAM primary memory in conjunction with one or more associated SRAM row(s) equal to the performance of those designed with solely SRAM technology. EDRAM technology allows for the manufacture of large FIFOs at a much lower cost than alternative technologies.</p><p>As shown in the preceding figure, the FIFO memory device <b>10</b> incorporates an input buffer <b>22</b> to allow writes to occur during refresh cycles, precharge cycles, row access cycles, and delays caused by the implementation of special features. A refresh counter, internal refresh timer or an external refresh pin may also be incorporated. In alternative embodiments, the FIFO memory device <b>10</b> may also incorporate: an internal clock that is some multiple of the system clock or other high frequency clock; a sleep mode (in order to ensure refreshes occur during quiescent state automatically); pre-input and pre-output buffers <b>18</b>, <b>48</b> to relieve constraints imposed by simultaneous activity in the memory array <b>12</b> and the input buffer <b>22</b> and/or the output; an output or multiple output buffers to enhance FIFO memory device <b>10</b> performance or to allow for the implementation of special features; and maximum access time row registers and timers (one set for each DRAM bank <b>12</b>A and <b>12</b>B).</p><p>In the preferred embodiment illustrated, the FIFO memory device <b>10</b> has as a minimum an input bus <b>16</b>, an output bus <b>50</b>, a read clock <b>38</b>, a write clock <b>36</b>, and power (V<sub>DD </sub>or V<sub>CC</sub>) and ground pins (V<sub>SS</sub>, not shown). It is also desirable to have empty <b>32</b> and/or full <b>30</b> flags. Other flags and features could include programmable almost full (\u201cPAF\u201d), programmable almost empty (\u201cPAE\u201d), \u201cRetransmit\u201d, and the like. In alternative embodiments, the EDRAM based FIFO memory device <b>10</b> might advantageously consist of a single bank of DRAM memory but the multiple bank (two or more DRAM banks <b>12</b>A and <b>12</b>B) architecture is desirable inasmuch as write row preparation in one bank can take place in parallel with writes to the other bank of the DRAM array <b>12</b>.</p><p>With respect to the FIFO memory device <b>10</b>, the SRAM banks <b>14</b>A and <b>14</b>B and DRAM banks <b>12</b>A and <b>12</b>B may be implemented as they are in the EDRAM disclosed in the aforementioned patent applications except that is advantageous to turn off the write-through mechanism at certain times. The inputs and outputs <b>16</b>, <b>50</b> may be word-wide. In the preferred embodiment illustrated, the FIFO memory device <b>10</b> memory is organized as Y rows by X columns and the columns are word-wide as well. For example, a 2 Megabit FIFO memory device <b>10</b> with 2 Kbits per row and 16 bits I/O would comprise a memory array <b>12</b> with 1024 rows (512 in each bank <b>12</b>A and <b>12</b>B). Each row of the DRAM banks <b>12</b>A and <b>12</b>B would have 128 columns and, therefore, each SRAM bank <b>14</b>A and <b>14</b>B would be 2048 bits and 128 columns. Alternatively smaller SRAM row(s) could be utilized wherein a portion of each DRAM row is loaded into the SRAM row(s).</p><p>The organization in this exemplary embodiment of the FIFO memory device <b>10</b> memory has been chosen to minimize control complexity and minimize overall die size. The memory may be mapped such that the even rows are in Bank <b>0</b> and the odd rows are in Bank <b>1</b>. This may not be absolutely necessary but it serves to simplify the ensuing FIFO memory device <b>10</b> control description and may help ultimately minimize the control logic.</p><p>The input buffer <b>22</b> is preferably sized so that writes do not stall if the DRAM array banks <b>12</b>A and <b>12</b>B are blocked when a refresh, precharge, row access cycle, etc. is in progress. The input buffer <b>22</b> may be implemented in several ways (i.e. as a shift register, a latch with a multiplexer to reorder the data, etc.) but it is desirable that the data written from the latch to the memory is in the order the data is received. The input buffer <b>22</b> could also be effectively transparent as it is only required when writes are blocked by a DRAM bank <b>12</b>A and <b>12</b>B related activity (i.e. a refresh cycle, row access cycle, precharge cycle, etc.). Writes to the FIFO memory device <b>10</b> may occur directly to the memory (write-through) much the same way that the standard EDRAM functions. The latch need only be written when writes to the DRAM banks <b>12</b>A and <b>12</b>B are blocked.</p><p>The optional buffers on the input (<b>18</b>) and output (<b>48</b>) may be desirable in order to compensate for internal FIFO memory device <b>10</b> delays. This can occur if a write to the FIFO memory device <b>10</b> (Data In <b>16</b>) and a write from the latch to the memory occur simultaneously. An output buffer can also be required when the read multiplexer <b>46</b> is being reset (see, for example the SRAM only logic flowchart of FIG. 8, more fully described hereinafter). In any case, these are single cycle delays and the internal bandwidth of the FIFO memory device <b>10</b> may ultimately be sufficient to make the pre-input and pre-output buffers <b>18</b>, <b>48</b> unnecessary.</p><p>In order to effectively control the FIFO memory device <b>10</b> the following information is needed: the size and state of the input buffer <b>22</b>; the state of all timers (i.e. has the refresh timer expired); the location of the read pointer <b>44</b> in the memory and relative to the write pointer <b>24</b>; the location of the write pointer <b>24</b> in the memory and relative to the read pointer <b>44</b>; the location of the next row in the DRAM banks <b>12</b>A and <b>12</b>B to be refreshed; the location of open rows that are reaching the maximum access time limit; the size of the memory (maximum address); the number of rows in the DRAM memory array; and the depth of the rows (the number of columns in each Bank).</p><p>With reference to the following figures and the description of a preferred embodiment, the following timers, counters, registers, and flags are defined to describe the operational flow control for the FIFO memory device <b>10</b>, although other equivalent control mechanisms may be acceptable:</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"119PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Description and Purpose</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"119PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">Counters</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">WP</entry><entry morerows=\"0\" valign=\"top\">Write Pointer</entry><entry morerows=\"0\" valign=\"top\">Indicates the number of words</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">24</entry><entry morerows=\"0\" valign=\"top\">written to the FIFO memory device</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">10. It also indicates the address of</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">the next word to be written. The</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">length is determined by the</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">maximum address (i.e. if the FIFO is</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1024 words deep WP is 10 bits).</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">When the maximum value is reached</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">it is reset to 0.</entry></row><row><entry morerows=\"0\" valign=\"top\">RP</entry><entry morerows=\"0\" valign=\"top\">Read Pointer</entry><entry morerows=\"0\" valign=\"top\">This counter is analogous to WP</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">44</entry><entry morerows=\"0\" valign=\"top\">except it indicates the number of</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">words read and the address of the</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">next word to be read. It is equal in</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">length to WP and is also reset to 0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">after it reaches the maximum value.</entry></row><row><entry morerows=\"0\" valign=\"top\">WRDC</entry><entry morerows=\"0\" valign=\"top\">WP RP</entry><entry morerows=\"0\" valign=\"top\">Indicates the distance between the</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Distance Cntr</entry><entry morerows=\"0\" valign=\"top\">Read Pointer and the Write Pointer.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">When WRDC is 0 the FIFO memory</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">device 10 is empty and when WRDC</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">is equal to the maximum address the</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">FIFO is full. WRDC can also be</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">used for an almost full or almost</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">empty output if desired.</entry></row><row><entry morerows=\"0\" valign=\"top\">IBC</entry><entry morerows=\"0\" valign=\"top\">Input Buffer</entry><entry morerows=\"0\" valign=\"top\">Indicates the number of valid words</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Counter</entry><entry morerows=\"0\" valign=\"top\">in the input buffer</entry></row><row><entry morerows=\"0\" valign=\"top\">WRC</entry><entry morerows=\"0\" valign=\"top\">Write Row</entry><entry morerows=\"0\" valign=\"top\">Indicates the row to which data is</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Counter</entry><entry morerows=\"0\" valign=\"top\">being written. It also indicates the</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">bank that the write multiplexer 26 is</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">in (i.e. when WRC is even the write</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">mux is in Bank 0 and WRC is odd</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">write mux is in Bank 1. Each time</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WMC is reset WRC is incremented.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">When WRC reaches the maximum</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">number of rows it is reset to 0.</entry></row><row><entry morerows=\"0\" valign=\"top\">RRC</entry><entry morerows=\"0\" valign=\"top\">Read Row</entry><entry morerows=\"0\" valign=\"top\">Analogous to WRC except that it</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Counter</entry><entry morerows=\"0\" valign=\"top\">indicates row from which data is</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">being read and the bank the read</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">multiplexer 26 is in.</entry></row><row><entry morerows=\"0\" valign=\"top\">WMC</entry><entry morerows=\"0\" valign=\"top\">Write Mux</entry><entry morerows=\"0\" valign=\"top\">Points to the next column where data</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Counter</entry><entry morerows=\"0\" valign=\"top\">is to be written to the memory. When</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">the value of WMC equals the number</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">of columns in a row WMCF is set and</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WMC is reset to 0.</entry></row><row><entry morerows=\"0\" valign=\"top\">RMC</entry><entry morerows=\"0\" valign=\"top\">Read Mux</entry><entry morerows=\"0\" valign=\"top\">Analogous to WMC except it</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Counter</entry><entry morerows=\"0\" valign=\"top\">indicates the position of the read</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">multiplexer 26. When RMC equals</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">the number of columns in a row</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RMCF is set and RMC is reset to 0.</entry></row><row><entry morerows=\"0\" valign=\"top\">RFC</entry><entry morerows=\"0\" valign=\"top\">Refresh</entry><entry morerows=\"0\" valign=\"top\">Indicates the next row to be</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Counter</entry><entry morerows=\"0\" valign=\"top\">refreshed. It ticks every refresh</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">cycle. The counter is equal in length</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WRC or RRC. When RFC reaches</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">its maximum value it is reset to 0.</entry></row><row><entry morerows=\"0\" valign=\"top\">Timers</entry></row><row><entry morerows=\"0\" valign=\"top\">MATT(0)</entry><entry morerows=\"0\" valign=\"top\">Max Access</entry><entry morerows=\"0\" valign=\"top\">Timer (Bank 0) of sufficient</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Time Tmr</entry><entry morerows=\"0\" valign=\"top\">granularity to signal the control logic</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">that a precharge needs to be</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">performed. When MATT reaches its</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">preprogrammed value of MATF is</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">set.</entry></row><row><entry morerows=\"0\" valign=\"top\">MATT(1)</entry><entry morerows=\"0\" valign=\"top\">Max Access</entry><entry morerows=\"0\" valign=\"top\">Timer (Bank 1) of sufficient</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Time Tmr</entry><entry morerows=\"0\" valign=\"top\">granularity to signal the control logic</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">that a precharge needs to be</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">performed. When MATT reaches its</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">preprogrammed value of MATF is</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">set.</entry></row><row><entry morerows=\"0\" valign=\"top\">RFT</entry><entry morerows=\"0\" valign=\"top\">Refresh Timer</entry><entry morerows=\"0\" valign=\"top\">Timer of sufficient granularity to</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">signal the control logic that a refresh</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">needs to be performed. When RFT</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">reaches its preprogrammed value</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RFF is set.</entry></row><row><entry morerows=\"0\" valign=\"top\">Flags</entry></row><row><entry morerows=\"0\" valign=\"top\">MATF(O)</entry><entry morerows=\"0\" valign=\"top\">Max Access</entry><entry morerows=\"0\" valign=\"top\">Signals the control logic that a</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Time Flag</entry><entry morerows=\"0\" valign=\"top\">precharge must be performed in</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DRAM Bank 0 12A.</entry></row><row><entry morerows=\"0\" valign=\"top\">MATF(1)</entry><entry morerows=\"0\" valign=\"top\">Max Access</entry><entry morerows=\"0\" valign=\"top\">Signals the control logic that a</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Time Flag</entry><entry morerows=\"0\" valign=\"top\">precharge must be performed in</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DRAM Bank 1 12B.</entry></row><row><entry morerows=\"0\" valign=\"top\">RFF</entry><entry morerows=\"0\" valign=\"top\">Refresh Flag</entry><entry morerows=\"0\" valign=\"top\">Signals the control logic that a</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">refresh cycle needs to be performed.</entry></row><row><entry morerows=\"0\" valign=\"top\">MNRF(O)</entry><entry morerows=\"0\" valign=\"top\">Memory Not</entry><entry morerows=\"0\" valign=\"top\">Signals the control logic that the</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Ready</entry><entry morerows=\"0\" valign=\"top\">DRAM array is not accessible in</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Bank 0 12A (i.e. a refresh, a bank</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">access, or a precharge cycle is in</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">progress)</entry></row><row><entry morerows=\"0\" valign=\"top\">MNRF(1)</entry><entry morerows=\"0\" valign=\"top\">Memory Not</entry><entry morerows=\"0\" valign=\"top\">Signals the control logic that the</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Ready</entry><entry morerows=\"0\" valign=\"top\">DRAM array is not accessible in</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Bank 1 12B (i.e. a refresh, a bank</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">access, or a precharge cycle is in</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">progress).</entry></row><row><entry morerows=\"0\" valign=\"top\">WMCF</entry><entry morerows=\"0\" valign=\"top\">Write Mux</entry><entry morerows=\"0\" valign=\"top\">Indicates a page boundary for writes</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Counter Flag</entry><entry morerows=\"0\" valign=\"top\">to the memory.</entry></row><row><entry morerows=\"0\" valign=\"top\">RMCF</entry><entry morerows=\"0\" valign=\"top\">Read Mux</entry><entry morerows=\"0\" valign=\"top\">Indicates a page boundary for reads</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Counter Flag</entry><entry morerows=\"0\" valign=\"top\">from the memory.</entry></row><row><entry morerows=\"0\" valign=\"top\">Registers</entry></row><row><entry morerows=\"0\" valign=\"top\">WMCS</entry><entry morerows=\"0\" valign=\"top\">Write Mux Cntr</entry><entry morerows=\"0\" valign=\"top\">Temporary variable used to mark the</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SRAM</entry><entry morerows=\"0\" valign=\"top\">location of the write multiplexer 26.</entry></row><row><entry morerows=\"0\" valign=\"top\">IB</entry><entry morerows=\"0\" valign=\"top\">Input Buffer</entry><entry morerows=\"0\" valign=\"top\">Size of the input buffer 22 in words</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">(fixed value).</entry></row><row><entry morerows=\"0\" valign=\"top\">CN</entry><entry morerows=\"0\" valign=\"top\">Column</entry><entry morerows=\"0\" valign=\"top\">Number of columns in a row (fixed</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Number</entry><entry morerows=\"0\" valign=\"top\">value).</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>In order to more fully understand the operation of the FIFO memory device <b>10</b> it may be useful to generally describe the operation of an EDRAM device as disclosed in the aforementioned patent applications. The EDRAM integrated circuit memory device incorporates one or more SRAM row(s) embedded near the sense amplifiers of a DRAM array and there is one SRAM cell per sense amplifier. The result is one or more SRAM row(s) which may, in a particular embodiment, be equal to the length of a row for each bank of DRAM while in other implementations, only a portion of a row may be maintained in the SRAM row(s) at one time wherein there are less SRAM cells per DRAM cells in each row. The typical operation of an EDRAM device is to load the SRAM row(s) on a read (i.e. all reads from the device are from the SRAM row(s)) and to write to the DRAM on a write (i.e. all writes to the device are to the DRAM array). If the read and write are to the same row (i.e. a row \u201chit\u201d to the last row read) both the SRAM row(s) and DRAM array are written (i.e., a write-through). Precharge and refresh cycles may be done in parallel with reads from the SRAM.</p><p>With reference additionally now to FIG. 2, a logic flow chart for an exemplary control procedure for the functional operation of the memory device <b>10</b> of FIG. 1 is shown. The process <b>100</b> begins with a master reset step <b>102</b> which serves to initialize the memory device <b>10</b> by application of an appropriate signal to the master reset input <b>34</b> (FIG. <b>1</b>). At step <b>104</b>, the empty flag is set and the full flag is cleared. In addition, all other internal flags are cleared and all counters of the memory device <b>10</b> are reset. Still further, all memory device <b>10</b> timers are reset and DRAM bank <b>0</b> (<b>12</b>A) and DRAM bank <b>1</b> (<b>12</b>B) are opened (rows <b>0</b> and <b>1</b> respectively). At this point, the write multiplexer <b>26</b> is set to column <b>0</b> and the read multiplexer <b>46</b> is also set to column <b>0</b>. Thereafter, at step <b>106</b>, the maximum access time timer (\u201cMATT(<b>1</b>)\u201d) is set to a value of 1 and the process <b>100</b> proceeds to step <b>108</b> to enter the logic flow main loop as will be discussed more fully hereinafter with respect to FIGS. 3A and 3B.</p><p>As previously described, following a master reset, or upon power up, all memory device <b>10</b> counters and timers are set to their proper state. The device empty pin <b>32</b> (output) is set to indicate there is no valid data in the FIFO memory device <b>10</b>. The full pin <b>30</b> (output) is cleared to indicate there is room in the FIFO memory device <b>10</b> for more data. Thereupon, rows <b>0</b> and <b>1</b> (banks <b>0</b> and <b>1</b> of the DRAM array) are opened and prepared to read or write; the internal data path is set to write both the SRAM banks <b>14</b>A and <b>14</b>B and DRAM banks <b>12</b>A and <b>12</b>B and all timers are enabled and incrementing.</p><p>With reference additionally now to FIGS. 3A and 3B, the main loop process <b>110</b> is shown. The main loop process <b>110</b> begins with decision step <b>112</b> (wherein it is determined if the refresh flag (\u201cRFF\u201d), the maximum access time flags (\u201cMATF\u201d), the write multiplexer counter flag (\u201cWMCF\u201d) and read multiplexer counter flags (\u201cRMCF\u201d) are set.) If all of these flags are set, then the main loop process <b>110</b> proceeds to the various memory not ready (\u201cMNRF\u201d) process flows <b>114</b> shown in various of the succeeding figures. On the other hand, if all of the aforementioned flags tested in the decision step <b>112</b> are not set, then, at decision step <b>116</b>, it is determined if the write clock <b>36</b> is active. If the write clock <b>36</b> is active, then the process <b>110</b> proceeds to step <b>118</b> where a word is loaded to the input buffer <b>22</b>, the write pointer (\u201cWP\u201d) <b>24</b> is incremented, and the input buffer counter (\u201cIBC\u201d) is also incremented. In addition, the write pointer distance counter (\u201cWPDC\u201d) is incremented. Alternatively, if at decision step <b>116</b>, the write clock <b>36</b> is not active, then the process <b>110</b> proceeds to step <b>128</b>, as will be more fully described hereinafter.</p><p>Following step <b>118</b> at decision step <b>120</b>, the write pointer distance counter is tested to see if it is at the maximum capacity of the memory. If it is, then the full flag is set at step <b>122</b> and the process <b>110</b> proceeds to decision step <b>124</b>. Alternatively, if the write pointer distance counter is not at the maximum amount of memory, then the process <b>110</b> proceeds directly to decision step <b>124</b>.</p><p>At decision step <b>124</b>, the memory not ready flag is tested to see if it is set in the bank of the write row counter (\u201cWRC\u201d). If the MNRF is set, then the process proceeds to step <b>126</b>, which will be more fully described hereinafter, followed by a return to initial decision step <b>112</b>. Concurrently, the process flow proceeds to decision step <b>128</b> to determine if the read clock is active. If at decision step <b>124</b>, the MNRF is not set in the bank of the write row counter, then at step <b>130</b>, the contents of the input buffer <b>22</b> are written to the memory device <b>10</b> memory. At this point, it should be noted that this write operation will occur to either the DRAM banks <b>0</b> or <b>1</b> (<b>12</b>A or <b>12</b>B), the SRAM rows <b>14</b>A or <b>14</b>B only or to both depending on the relative position of the write pointer <b>24</b> and the read pointer <b>44</b>, as will be more fully described hereinafter with respect to the MNRF process flows.</p><p>Following step <b>130</b>, the process <b>110</b> returns to the initial decision step <b>112</b> and the read clock <b>38</b> is tested at decision step <b>128</b>. The step <b>130</b> also includes returns from the MNRF flows at step <b>132</b>, as will be more fully described hereinafter. At decision step <b>128</b>, if the read clock <b>38</b> is active, then the write and read pointer distance counters are decremented at step <b>134</b> and, at step <b>136</b>, the data word is output, the read pointer <b>44</b> is incremented and the read multiplex counter (\u201cRMC\u201d) is incremented. However, if at decision step <b>128</b> the read clock <b>38</b> is not active, then the process <b>110</b> enters a loop to test the state of the read clock and the process <b>110</b> returns to initial decision step <b>112</b>. Following step <b>136</b>, the WRPDC is tested to see if it is equal to 0 at decision step <b>138</b> and if it is, the empty flag is set at step <b>140</b>. Alternatively, if at decision step <b>138</b> the WRPDC is not equal to 0, then the process <b>110</b> returns to initial step <b>112</b> and to test the state of the read clock <b>38</b> at decision step <b>128</b>.</p><p>In operation, the process <b>110</b> begins with the memory device <b>10</b> control logic verifying that some action dealing with the DRAM array is not required (see MNRF Flow) and waits for a read or write clock active indication. If the write clock <b>36</b> becomes active, a word is written to the input buffer <b>22</b> and the write pointer (WP), the write read distance counter (WRPDC) and the input buffer counter (IBC) are incremented. If WRPDC is equal to the size of the memory in words the full pin <b>30</b> is set. If the memory is not ready (i.e., the memory not ready flag is set) the memory device <b>10</b> returns to the top of the process <b>110</b> loop and continues to write data to the input buffer <b>22</b> until MNRF is cleared. If MNRF is clear (i.e., NMRF cycles return) in the bank of the write mux <b>46</b>, then the contents the input buffer <b>22</b> (the number of valid words in the input buffer is equal to IBC) is written to the memory (if IBC is 0, nothing is written to the memory). The input buffer <b>22</b> is now empty and IBC is cleared. The write mux <b>46</b> (or write column decoder) moves to the location where the next word will be written (from the input buffer <b>22</b> to the memory). The memory device <b>10</b> then returns to wait for an active read clock <b>38</b>, an active write clock <b>36</b> or a flag indicating that some action dealing with the DRAM array banks <b>12</b>A and <b>12</b>B is required.</p><p>Read operations occur on active read clocks <b>38</b>. On a read clock active cycle, a word is output (from the SRAM banks <b>14</b>A and <b>14</b>B to the Data Out bus <b>50</b>), WRDC is decremented, and if WRDC is 0, the empty pin <b>32</b> is set and the memory device <b>10</b> again waits for an active read or write clock (<b>38</b>, <b>36</b>) or flag.</p><p>With reference additionally now to FIG. 4, the initial process <b>150</b> for the various MNRF flow sequences is shown. The process <b>150</b> begins at decision step <b>152</b> where the state of the flags RFF/MTF/WMCF/RMCF are tested to see if they are set. Thereafter, at decision step <b>154</b>, if more than one of the aforementioned flags is set, then the process <b>150</b> proceeds to step <b>156</b> to accord priority to the various flags as indicated. However, if at decision step <b>154</b>, only one of the aforementioned flags in decision step <b>152</b> is set, then the process proceeds to the appropriate one of steps <b>158</b> (\u201cMATF\u201d), <b>160</b> (\u201cRFF\u201d), <b>162</b> (\u201cWMCF\u201d) or <b>164</b> (\u201cRMCF\u201d).</p><p>Functionally, the flow <b>150</b> is initiated when any of the flags signaling an event associated with the memory array is set. If one or more flags are set, a priority is established for the purpose of deciding the order in which the requests are serviced. The priority may vary from that described and shown as necessary if there is some benefit to the particular implementation.</p><p>With reference additionally now to FIG. 5, the MNRF process flow <b>170</b> corresponding to step <b>162</b> of FIG. 4 is shown. The process flow <b>170</b> begins at decision step <b>172</b> to determine if MNRF is set in the bank of the write row counter plus 1. If the MNRF is set, then at step <b>174</b>, a wait is entered for the MNRF to clear. Alternatively, if the MNRF is not set, then at step <b>176</b>, MNRF is set in the bank of the write row counter plus 1. Thereafter, at step <b>178</b>, the write row counter minus 1 is closed to allow for a precharge operation to occur. At step <b>180</b>, the write row counter plus 1 is opened to allow for a write through operation. At step <b>182</b>, the maximum access time timer in the bank of the write row counter minus 1 is reset at step <b>182</b>. Thereafter at step <b>184</b>, the WMCF and MNRF are cleared. At step <b>186</b>, the process flow <b>170</b> returns to the main loop.</p><p>In operation, the process <b>170</b> cycle prepares the memory for writes in the bank ahead of the write multiplexer <b>26</b>. The write mux counter (WMC) tracks the position of the write multiplexer <b>26</b>. The write mux counter is reset (set to 0) after it reaches the number equal to the number of columns in a row. Each time WMC is set to 0, the write row counter (WRC) is incremented and the write mux counter flag (WMCF) is set indicating the write multiplexer <b>26</b> has crossed a bank boundary. When WMCF is set, the memory device <b>10</b> checks for other memory related activity (MNRF is set in the bank ahead of WRC). If MNRF is set in that bank (i.e. if WRC is odd the status of MNRF(<b>0</b>) is needed), the memory device <b>10</b> waits for MNRF to clear. When the memory is ready, MNRF is set to prevent other memory activities from interfering and a precharge is performed on the row in the previous bank. The next row is then opened and set to write to the DRAM array only. The maximum access time timer is then reset in the bank ahead of WRC and MNRF and WMCF are cleared and control returns to the Main Loop shown in FIGS. 3A and 3B.</p><p>With reference additionally now to FIG. 6, a process flow <b>190</b> corresponding to the step <b>164</b> of FIG. 4 is shown. The process flow <b>190</b> begins at decision step <b>192</b> to determine if the MNRF is set in the bank of the read row counter plus 1. If MNRF is set, then at step <b>194</b>, a wait is entered for that to clear. Alternatively, if MNRF is not set, then it is set at step <b>196</b> in the bank of the read row counter plus 1. Thereafter, at decision step <b>198</b>, a determination is made as to whether the read row counter is equal to the write row counter. If it is, then at step <b>200</b>, writes to the write row counter plus 1 are made to both the appropriate one of the SRAM <b>14</b>A or <b>14</b>B and the DRAM <b>12</b>A or <b>12</b>B. At step <b>202</b>, the RMCF and MNRF are cleared and the process <b>190</b> returns to the main loop at step <b>204</b>.</p><p>Alternatively, if RRC is not equal to WRC, then at decision step <b>206</b>, a determination is made as to whether the write row counter is in the bank of the read row counter plus 1. Thereafter, if the write row counter is in the bank of the read row counter plus 1, then at step <b>208</b>, that row is closed to allow for a precharge operation and, at step <b>210</b>, the row RRC plus 1 is read and loaded into the SRAM. At step <b>212</b>, the WRC row is restored to allow for a write through and the maximum access time timer in the bank of the read row counter plus 1 is reset at step <b>214</b> prior to entry of step <b>202</b> as previously described. Alternatively, if at decision step <b>206</b> the read row counter is not in the bank of the write row counter plus 1, then at step <b>216</b> row RRC plus 1 is read to load the SRAM and the process <b>190</b> proceeds to step <b>202</b>.</p><p>Functionally the process <b>190</b> cycle prepares the memory for a read operation in the bank ahead of the read multiplexer <b>46</b>. The read mux counter (RMC) tracks the position of the read multiplexer <b>46</b> and is reset after it reaches the number equal to the number of columns in a row. Each time RMC is set, the read row counter flag (RMCF) is set indicating the read multiplexer <b>46</b> has crossed a page boundary and RRC is incremented indicating the read multiplexer <b>26</b> is in the next row. When RMCF is set, the memory device <b>10</b> checks for other memory related activity (MNRF is set in the bank ahead of RRC). If MNRF is set in that bank (i.e. if RRC is odd the status of MNRF(<b>0</b>) is needed) the memory device <b>10</b> waits for MNRF to clear. When the memory is ready, MNRF is set to prevent other memory activities from interfering. If WMC and RMC (RMD=WMC) are the same row, the row ahead (WRC+1) is set to write both the appropriate ones of the SRAM banks <b>14</b>A and <b>14</b>B and DRAM banks <b>12</b>A and <b>12</b>B. MNRF and RMCF are then cleared and control returns to the main loop of FIGS. 3A and 3B. If the read and write multiplexers <b>46</b>, <b>26</b> are not in the same row and the write multiplexer <b>26</b> is in the bank of RRC+1, the row (WRC) is precharged, RRC+1 is loaded into the SRAM, the row equal to WRC is restored, MATT for that bank is reset and control returns to the main loop.</p><p>With reference additionally now to FIGS. 7A and 7B, a process flow <b>220</b> corresponding to step <b>160</b> of FIG. 4 is shown. The process flow <b>220</b> begins at step <b>222</b> to set the refresh flag. At decision step <b>224</b>, a determination is made as to whether MNRF is set in that particular bank. If it is, then a wait is entered at step <b>226</b> which returns to step <b>224</b> until it is not set. If at decision step <b>224</b> MNRF is not set, then the process flow <b>220</b> proceeds to step <b>228</b> to set MNRF and then proceeds to decision step <b>230</b> to determine whether the write row counter is equal to the read row counter. If the write row counter is equal to the read row counter, then the process proceeds to decision step <b>232</b> to determine if the write multiplexer counter minus the read multiplexer counter is less than the size of the buffers. Alternatively, if at decision step <b>230</b> the write read counter is not equal to the row read counter, then at decision step <b>234</b> a determination is made as to whether the write row counter is set equal to the read row counter plus 1. Thereafter at step <b>236</b>, if the write multiplexer counter plus CN minus the read multiplexer counter is less than the size of the buffers, then the process <b>220</b> proceeds to step <b>238</b> to turn off write-through operations and write only to either the SRAM banks <b>14</b>A or <b>14</b>B as described in the SRAM only flow of FIG. 8, to be more fully described hereinafter.</p><p>On the other hand, if at decision step <b>236</b>, WMC plus CN minus RMC is not less than the size of the buffers, then at step <b>240</b>, a wait is entered for either a read or write operation and the main loop flow <b>110</b> of FIGS. 3A and 3B is followed. At step <b>242</b>, the refresh row is set equal to the refresh counter and at step <b>244</b> the MNRF and RFF flags are cleared. Thereafter at step <b>246</b>, the refresh counter is incremented and the refresh timer is reset. A return to the main loop flow <b>110</b> is executed at step <b>248</b>. With reference to step <b>238</b>, at step <b>250</b>, WMCS is set to WMC and at step <b>252</b> a read and write on active is implemented as described in the SRAM only flow of FIG. 8 as will be more fully described hereinafter. At step <b>254</b>, the refresh row is set equal to the refresh counter and at step <b>256</b>, the SRAM only loop is exited at step <b>256</b>. Thereafter, at step <b>258</b>, the write multiplexer <b>26</b> is returned to its starting position (WMCS) and at step <b>260</b> the memory is set to write to the appropriate ones of both the SRAM banks <b>14</b>A or <b>14</b>B, as well as the DRAM banks <b>12</b>A or <b>12</b>B. The process flow <b>220</b> concludes with step <b>262</b> where the contents of the input buffer <b>22</b> are written to the memory and the write multiplexer input buffer counter columns are moved and the input buffer counter columns are cleared. Thereafter, the process flow <b>220</b> returns to step <b>244</b> as previously described.</p><p>In operation, the refresh flag is set when the refresh timer signals that a refresh is required. The refresh timer has sufficient granularity to allow a refresh cycle to be delayed if some other activity associated with the memory is in progress or a higher priority activity is pending. For example, if the refresh interval is <b>64</b> S, the refresh flag is set some number of ticks before <b>64</b> S has elapsed sufficient to complete all activities in progress or pending. When RFF is set, the memory device <b>10</b> waits for MNRF to clear (if set), determines that no other memory related activities are pending and sets MNRF in the bank of the refresh counter (RFC). A test is then done to determine if there is ample space in the input buffer <b>22</b> to allow reads and writes to occur without stalling at the maximum read clock <b>38</b> and write clock <b>36</b> frequency. If there is ample space, the appropriate MNRF is set, writes are to the input buffer <b>22</b> and reads are from the SRAM banks <b>14</b>A and <b>14</b>B as per the Main Loop. A refresh cycle is then completed, the refresh counter is incremented (next row to be refreshed), the refresh timer is reset and MNRF and RFF are cleared. At this point, control returns to the main loop flow <b>110</b> of FIGS. 3A and 3B.</p><p>If there is not a sufficient distance between the read and write multiplexers <b>46</b>, <b>26</b> the write path to the DRAM banks <b>12</b>A and <b>12</b>B is disabled but the write path to the SRAM banks <b>14</b>A and <b>14</b>B remains enabled. The position of the write multiplexer <b>26</b> is then saved (WMCS) and control is now as described in the SRAM Only Flow of FIG. <b>8</b>. The writes to the memory device <b>10</b> are now to the input buffer <b>22</b> and the SRAM banks <b>14</b>A and <b>14</b>B and the flow is similar to that in the main loop except that the input buffer counter (IBC) is not cleared. When the refresh cycle completes, the write multiplexer <b>26</b> is reset to the starting position (WMCS), the write path for the SRAM banks <b>14</b>A and <b>14</b>B and DRAM banks <b>12</b>A and <b>12</b>B is restored and the contents of the input buffer <b>22</b> are written to memory, the refresh timer is reset and the refresh counter is incremented and control returns to the main loop. It should be noted that a refresh cycle is the longest delay for which the memory device <b>10</b> cannot be written. Therefore the size chosen for the input buffer <b>22</b> may be predicated on the refresh delay at the maximum read or write clock <b>38</b>, <b>36</b>. When a refresh cycle is activated, writes to the DRAM banks <b>12</b>A and <b>12</b>B must be disabled.</p><p>Refresh operations also place constraints on the minimum number of columns in a row. WMCF and RMCF cycles must complete before the read or write multiplexers <b>46</b>, <b>26</b> reach the end of a row. If, for example, a refresh cycle started an instant before RMCF and WMCF were set there could conceivably be a delay of up to 200 nS-300 nS. Since the read and write clocks <b>38</b>, <b>36</b> can continue at the maximum specified clock frequency, the minimum number of columns is set equal to the maximum delay divided by the clock period.</p><p>With reference additionally now to FIG. 8, the SRAM only process flow <b>270</b> previously alluded to is shown. The process flow <b>270</b> begins at decision step <b>272</b> to determine if the write clock is active. If it is, then the process flow <b>270</b> proceeds to step <b>274</b> to load the word to the input buffer <b>22</b>, increment the write pointer <b>26</b>, increment the input buffer counter, and increment WRPDC. Thereafter, at decision step <b>276</b>, a determination is made as to whether the WRPDC is equal to the maximum memory. If it is, then the full flag is set at step <b>278</b> and the process <b>270</b> proceeds to decision step <b>280</b> to determine if MNRF is set in the bank of the write row counter. Alternatively, if at decision step <b>276</b> WRPDC is not equal to the maximum memory, then the process also proceeds to decision step <b>280</b>.</p><p>If MNRF is set in the bank of the write row counter, then at decision step <b>282</b>, a determination is made as to whether the read clock <b>38</b> is active. Alternatively, if MNRF is not set in the bank of the write row counter, then the contents of the input buffer <b>22</b> are written to memory (SRAM banks <b>0</b> and <b>1</b> (<b>14</b>A or <b>14</b>B)) only, the write multiplexer <b>26</b> is moved an input buffer count number of columns and the input buffer counter is added to the write multiplexer counter. The process flow <b>270</b> then returns to decision step <b>272</b>.</p><p>If at decision step <b>282</b>, the read clock <b>38</b> is active, then the process flow <b>270</b> proceeds to step <b>286</b> to decrement WRPDC. At step <b>288</b>, the word is output, the read pointer <b>44</b> is incremented, and the read multiplexer counter is incremented. At decision step <b>290</b>, WRPDC is tested to see if it is equal to 0. If it is, then at step <b>292</b>, the empty flag is set and the process returns to decision step <b>290</b>. If at decision step <b>290</b> WRPDC is not equal to 0, then the process flow returns to step <b>272</b> to determine if the write clock <b>36</b> is active. As shown, if at decision step <b>272</b>, the write clock <b>36</b> is not active, then the process flow <b>270</b> proceeds to decision step <b>282</b> to determine if the read clock <b>38</b> is active. If the read clock <b>38</b> is not active, then a loop is entered at decision step <b>282</b> until a positive result is obtained. At decision step <b>292</b>, if WRPDC is not equal to 0, then the read clock <b>38</b> is again tested to see if it is active at step <b>282</b>.</p><p>With reference additionally now to FIGS. 9A and 9B, a MNRF process flow <b>300</b> corresponding to step <b>158</b> of FIG. 4 is shown. At step <b>302</b>, the maximum access time timer flag is tested and as decision step <b>304</b>, a determination is made as to whether the MNRF is set in that particular bank of the memory. If MNRF is set, then at step <b>306</b>, a wait is entered for MNRF to clear. If at decision step <b>304</b> MNRF is not set, then it is set at step <b>308</b> and the process flow <b>300</b> proceeds to step <b>310</b> to test whether the write row counter is set equal to the read row counter. If WRC equals RRC then the process flow <b>300</b> proceeds to decision step <b>312</b> where it is determined whether WMC minus RMC is less than the size of the buffers. Altematively, if WRC is not equal to RRC at decision step <b>310</b>, then the process flow <b>300</b> proceeds to decision step <b>314</b> where a determination is made as to whether WRC is equal to RRC plus 1. If at decision step <b>316</b> WMC plus NC minus RMC is less than the size of the buffers, then the process flow <b>300</b> proceeds to step <b>318</b> to turn off write-through operations and write to the SRAM banks <b>14</b>A and <b>14</b>B only, as described in the preceding FIG. <b>8</b>. Alternatively, the process flow proceeds from either decision step <b>312</b> or decision step <b>316</b> to step <b>320</b> to execute a wait for a read or write operation and the main loop process flow <b>110</b> of FIGS. 3A and 3B is followed. Following step <b>320</b>, at step <b>322</b>, the refresh row is set equal to RFC and at step <b>324</b> MNRF is cleared and MATF is also cleared. At this point, at step <b>326</b>, the max access time timer is reset and a return to the main loop of FIGS. 3A and 3B is executed at step <b>328</b>.</p><p>From step <b>318</b>, the process flow <b>300</b> proceeds to step <b>330</b> to set WMCS to WMC. Thereafter at step <b>332</b>, the read and write operations on active takes place in accordance with the SRAM only flow of FIG. 8 previously described. At step <b>334</b>, the appropriate row is precharged and the SRAM only flow <b>270</b> loop is exited at step <b>336</b>. At this point, the write multiplexer <b>26</b> is returned to the starting position (WMCS) at step <b>338</b> and the memory is set to write to the SRAM banks <b>14</b>A or <b>14</b>B and the DRAM banks <b>12</b>A or <b>12</b>B. At step <b>342</b>, the contents of the input buffer <b>22</b> are written to memory and the write multiplexer input buffer counter columns are moved and the input buffer <b>22</b> is cleared, whereupon the process <b>300</b> returns to step <b>324</b>.</p><p>In operation, the maximum access time limits are caused by sense amplifier decay. If a row in the DRAM array banks <b>12</b>A and <b>12</b>B is not precharged within the appropriate time limit, data will be lost. In some applications the process flow <b>300</b> may not be absolutely necessary but is described and shown for sake of completeness. The two bank FIFO memory device <b>10</b> shown here is designed to eliminate the need for maximum access time detection and control by making the refresh interval less than of the maximum access time interval. This serves to ensure that every open row is precharged within the prescribed limit. If maximum access time detection and control is necessary, the flow may be designed similarly to the flow for refresh operations except that the row reaching the time limit only requires a precharge cycle.</p><p>What has been provided, therefore, is an integrated circuit FIFO memory device comprises an input bus for receiving data, an input buffer coupled to the input bus for storing the data and at least one DRAM array coupled to the input buffer. A write pointer is operative for storing the data in the input buffer to a location within the memory array indicated and an output bus is coupled to the memory array and a read pointer for providing previously written data from the memory array at a location indicated by the read pointer. In a preferred embodiment, the FIFO further comprises at least one SRAM row(s) interposed between the input and output buses and the memory array having a width corresponding to each row of the memory array.</p><p>With reference additionally now to FIG. 10, a functional block diagram of an alternative embodiment of a FIFO memory device <b>500</b> in accordance with the present invention is shown. The memory device <b>500</b> advantageously incorporates a \u201cRetransmit\u201d function which allows for data to be read from the device more than once and, in the exemplary embodiment illustrated, comprises a number of DRAM banks <b>512</b>A through <b>512</b>D inclusive (Banks <b>0</b>-<b>3</b>) each having an associated SRAM bank <b>514</b>A through <b>514</b>D inclusive (Banks <b>0</b>-<b>3</b>). As can be seen DRAM bank <b>512</b>A may store data for Row <b>0</b> and Row <b>4</b>, DRAM bank <b>512</b>B may store data for Row <b>1</b> and Row <b>5</b>, DRAM bank <b>512</b>C may store data for Row <b>2</b> and Row <b>6</b> and DRAM bank <b>512</b>D may store data for Row <b>3</b> and Row <b>7</b>.</p><p>The address bus (A<b>0</b>-An) is coupled through a mode register <b>516</b> and address offset register <b>518</b> to the address decoders and control logic block <b>522</b>. The address decoders and control logic block <b>522</b> is bi-directionally coupled to the internal data bus coupling the input buffer <b>520</b> to the various DRAM banks <b>512</b>A-<b>512</b>D inclusive as well as to a number of I/O terminals as indicated and as will be more fully described hereinafter. The input buffer <b>520</b> is coupled to receive data input to the memory device <b>500</b> on the data bus (D<b>0</b>-Dn) as shown for subsequent writing to selected locations in the DRAM banks <b>512</b>A-<b>512</b>D. Data read out of the various SRAM banks <b>514</b>A-<b>514</b>D as previously written to them from the associated DRAM banks <b>512</b>A-<b>512</b>D is supplied on the multiplexed address and data output pins as signals Q<b>0</b>-Qn as shown.</p><p>The memory device <b>500</b> as shown incorporates a unique \u201cRetransmit\u201d capability unlike that of a typical FIFO device operation which only allows for data to be read from it once. This functionality is provided in that it may be desirable to retransmit data in an application if the original data was not valid for some reason (i.e. system fault, transmission error, etc.). In other applications it may also be desirable to move the read pointer forward if the data forward of the read pointer becomes critical for a particular application. Still further, it may also be beneficial to move the read pointer, output a predetermined amount of data and return the read pointer to the location when the \u201cRetransmit\u201d was requested and resume operation.</p><p>It is noted that while some SRAM-based FIFOs provide a \u201cRetransmit\u201d feature, they require the location of the start of the retransmission to be marked at the time of input and do not have the ability to move the read pointer forward. As to such SRAM-based FIFOs, this feature is useful only if the prospect of a retransmission requirement is known when the data is written. Further while it might be seen that the term \u201cRetransmit\u201d implies only a decrementing of the read pointer in a backwards direction, as the term is used herein, it is utilized in conjunction with a request to move the read pointer in any direction, forwards or backwards.</p><p>A more flexible scheme as contemplated herein is one which allows the user to reset the read pointer to any location in the array. This requires an address bus of sufficient granularity to access every word in the memory device <b>500</b> such that, <b>2</b><sup>n</sup>\u2267Maximum Number of Words Deep, where n=the number of address pins. It is generally not considered desirable to add an address bus as it would significantly increase the number of pins required for any reasonably large FIFO. If, as illustrated the read or output bus (A<sub>n</sub>/Q<sub>n</sub>) were made as bi-directional it could be used to provide the address granularity needed without requiring additional device pins.</p><p>Since FIFOs are often applied as packet memories, the address offset register <b>518</b> is operational to allow the user to move the read pointer in increments or relative to some data packet size. In this case the user would apply the multiple for the number of packets he wishes to move forward or back to the A<sub>n</sub>/Q<sub>n </sub>bus and the read pointer would move in packet increments. If this feature is desirable some additional functionality may be added to reduce the burden of tracking the read pointer addresses. The mode register <b>516</b> may be used to allow the user to program the device to operate upon a \u201cRetransmit\u201d request. Example modes of operation are as follows:</p><p>Mode <b>0</b>: Continue to output data until the end of the packet and save the location of the read pointer (end of packet). Move the read pointer to the beginning of the packet requested for retransmission and output data as required. If a \u201cReturn\u201d is requested, complete any initiated packet transmissions and return to the saved location plus 1. This allows the user to finish outputting a packet, move to another packet location, transmit that packet and return.</p><p>Mode <b>1</b>: Stop transmission, save the location of the read pointer. Move to the beginning of the packet requested for retransmission and output data as required. If a \u201cReturn\u201d is requested, complete any initiated packet transmissions and return to the beginning of the packet of the location of the read pointer. This allows the user to immediately interrupt the output, move to a new packet location, transmit one or more packets and move back to the location he started from and re-send the entire packet.</p><p>Other combinations of modes may be desirable and can easily be added. It should be noted here that it is incumbent upon the user to not drive the A<sub>n</sub>/Q<sub>n </sub>until the last valid word is output and it may be desirable to have an output pin that informs the user that packet transmissions have completed rather then require a bus sensing scheme. In this regard, a \u201cPacket\u201d pin could be added that toggles each time a packet boundary has been reached.</p><p>The functionality of the memory device <b>500</b> advantageously provides a FIFO device with maximum flexibility and with operation similar to that described with respect to the preceding figures with the addition of a bi-directional Address/Read (A<sub>n</sub>/Q<sub>n</sub>) bus and a number of additional I/O control pins. The device <b>500</b> includes a multi-bank enhanced DRAM (\u201cEDRAM\u2122\u201d) or enhanced synchronous DRAM (\u201cESDRAM\u2122\u201d, both trademarks of Enhanced Memory Systems, Inc., Colorado Springs, Colo.) architecture with consecutive rows mapped across bank boundaries. Although the operation of the memory device <b>500</b> is described herein as synchronous with SRAM row(s) directly mapped to DRAM banks, it should be noted asynchronous operation and/or freely associative SRAM row(s) integration is likewise possible.</p><p>The memory device <b>500</b> incorporates a \u201cRetransmit\u201d pin (\u201cRT\u201d), a pin that is programmable as a \u201cReady\u201d or \u201cWait\u201d pin and a \u201cReturn\u201d pin. If an offset register <b>518</b> is implemented as shown, it may be programmed at initialization as could be the mode register <b>516</b>. It should be noted that it may not be necessary to add a pin to put the memory device <b>500</b> into a \u201cprogramming\u201d mode as a combination of the existing control pins may be utilized in a specified sequence otherwise unused in normal operation. A programming pin is, however, illustrated for sake of clarity. Additionally, a polarity pin (i.e. move the read pointer forward or back) may be necessary if the Address/Read (A<sub>n</sub>/Q<sub>n</sub>) bus is not of sufficient width to provide the address granularity required. If the bus is of sufficient width, the least significant bit not in the address field could be used as the polarity bit. A packet pin is shown should it prove useful and all other I/O pins are as previously described with respect to the preceding figures.</p><p>With reference additionally now to FIG. 11, a representative logic flow process <b>600</b> illustrative of the functional operation of the FIFO memory device <b>500</b> of FIG. 10 is shown. In operation the device would function as previously described with respect to FIG. 10 until a \u201cRetransmit\u201d (\u201cRT\u201d) request is received.</p><p>The memory device <b>500</b> is initialized as described with respect to the preceding figures. After normal initialization, the Program pin is asserted and the device is in programming mode. Bit patterns on the address bus will be defined to set the value of the address offset register (\u201cAOR\u201d) <b>518</b>, the mode register <b>516</b> and set the Ready/pin to be either a \u201cReady\u201d or \u201cWait\u201d. A predetermined value in the address offset register <b>518</b> (e.g. \u201c0\u201d) may be utilized to cause the memory device <b>500</b> to expect the entire address upon a \u201cRetransmit\u201d request. Utilizing this scheme, any whole number other then zero will then cause the read pointer to be moved in packet increments of that amount. After the program pin is de-asserted the memory device <b>500</b> is ready to receive and transmit data as previously described.</p><p>In a representative process flow <b>600</b>, when the memory device <b>500</b> receives a \u201cRetransmit\u201d request at decision step <b>602</b> (pin RT is set), the current address of the read pointer is saved and the \u201cReady\u201d pin is then de-asserted or the \u201cWait\u201d is asserted at step <b>604</b>. Functionally, the operation of \u201cReady\u201d and \u201cWait\u201d is similar except that \u201cWait\u201d indicates a normal access (minimum cycle time) is not possible, while \u201cReady\u201d indicates valid data is on the bus.</p><p>The memory device <b>500</b> must also determine if the DRAM bank <b>512</b>A-<b>512</b>D being accessed is currently in an uninterruptible DRAM process at decision step <b>606</b> (i.e. refresh cycle, an SRAM bank <b>514</b> load, DRAM bank <b>512</b> write, etc.). If the memory device <b>500</b> cannot be interrupted, the process is completed at step <b>608</b> before proceeding. On the other hand, if the memory device <b>500</b> is interruptible, or the DRAM process is completed, the value of the address offset register <b>518</b> is read at decision step <b>610</b>.</p><p>If the value in the address offset register <b>518</b> is zero, the memory device <b>500</b> is expecting and will load the full address for the new value of the Read Pointer from the A/Q bus at step <b>612</b>. Alternatively, if the value of the address offset register <b>518</b> is something other then zero, the memory device <b>500</b> will load the value from the A/Q bus and multiply it times the value of the address offset register <b>518</b> and move the read pointer that many locations forward or backward depending on the state of the polarity pin as shown in step <b>614</b> in accordance with the technique previously described in the preceding Mode definitions.</p><p>With the new address for the Read Pointer determined, the memory device <b>500</b> will load the proper row in the appropriate SRAM bank <b>514</b> and set the column address appropriately as shown in step <b>616</b>. At this point, the \u201cReady\u201d pin will be asserted or \u201cWait\u201d will be de-asserted at step <b>618</b> and the memory device <b>500</b> will return to normal operation at step <b>632</b> unless a \u201cReturn\u201d is requested. If a \u201cReturn\u201d is requested at decision step <b>620</b>, the operation follows as previously described except that the Read Pointer is restored to the location previously saved in step <b>604</b> (or as described in the Mode definitions) and the memory device <b>500</b> returns to normal operation at step <b>632</b>.</p><p>Particularly, at decision step <b>620</b>, if a \u201cReturn\u201d is not asserted, the process <b>600</b> returns to step <b>632</b> and normal operation begins. On the other hand, if a \u201cReturn\u201d is asserted, at step <b>622</b>, \u201cWait\u201d is asserted or \u201cReady\u201d is de-asserted. If a DRAM cycle is active at decision step <b>624</b>, that operation is allowed to complete at step <b>626</b>. Otherwise, the appropriate SRAM bank <b>514</b> is loaded and the column set as described with respect to step <b>616</b>. At step <b>630</b>, the \u201cWait\u201d is de-asserted or the \u201cReady\u201d is asserted and the process <b>600</b> returns to normal operation until a \u201cReturn\u201d is asserted at decision step <b>620</b>. If a \u201cRetransmit\u201d is asserted before a \u201cReturn\u201d is requested, the return address is replaced so that the return address marks the location of the read pointer when the last \u201cRetransmit\u201d was requested in accordance with the mode definitions.</p><p>It should be noted that while the various operations described and illustrated with respect to FIG. 11 have been shown as substantially sequential for purposes of clarity, many of the operations may and would desirably be effectuated in parallel for sake of overall speed of operation.</p><p>An exemplary utilization of the \u201cRetransmit\u201d feature of the memory device <b>500</b> might be one in which a network bridge receives data in one protocol and packet changes the protocol, re-packetizes the data and transmits. Many times protocols include cyclical redundancy checks (\u201cCRCs\u201d) and if there is a transmission error, a request is sent back to the controller to re-send the packet. If a FIFO memory device <b>500</b> having the architecture previously disclosed were employed, and the packet was still in the FIFO memory device <b>500</b>, a re-send request could be handled without going through the bridge back to the other network, changing the protocol, re-packetizing the data and stacking it back in the FIFO memory device <b>500</b>. The controller could then simply finish sending the current packet (e.g. Mode <b>0</b>) back up the required number of packets, begin to resend the packet that was in error and assert \u201cReturn\u201d. The FIFO memory device <b>500</b> will complete the transmission of the packet that was received in error and return to the packet that was next in line when the \u201cRetransmit\u201d request was received and is then ready to transmit where it left off.</p><p>While there have been described above the principles of the present invention in conjunction with specific device architecture, it is to be clearly understood that the foregoing description is made only by way of example and not as a limitation to the scope of the invention. While the exemplary memory device disclosed represents an asynchronous device, in a synchronous implementation the read and write clocks may be replaced with read and write enables instead. Particularly, it is recognized that the teachings of the foregoing disclosure will suggest other modifications to those persons skilled in the relevant art. Such modifications may involve other features which are already known per se and which may be used instead of or in addition to features already described herein. Although claims have been formulated in this application to particular combinations of features, it should be understood that the scope of the disclosure herein also includes any novel feature or any novel combination of features disclosed either explicitly or implicitly or any generalization or modification thereof which would be apparent to persons skilled in the relevant art, whether or not such relates to the same invention as presently claimed in any claim and whether or not it mitigates any or all of the same technical problems as confronted by the present invention. The applicants hereby reserve the right to formulate new claims to such features and/or combinations of such features during the prosecution of the present application or of any further application derived therefrom.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Craig", "last_name": "Taylor", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "RAMTRON INTERNATIONAL CORPORATION"}, {"first_name": "", "last_name": "FOOTHILLS IP LLC", "name": ""}, {"first_name": "", "last_name": "INTELLECTUAL VENTURES ASSETS 161 LLC", "name": ""}, {"first_name": "", "last_name": "HANGER SOLUTIONS, LLC", "name": ""}, {"first_name": "", "last_name": "INTELLECTUAL VENTURES I LLC", "name": ""}, {"first_name": "", "last_name": "PURPLE MOUNTAIN SERVER LLC", "name": ""}, {"first_name": "", "last_name": "RAMTRON INTERNATIONAL CORPORATION", "name": ""}, {"first_name": "", "last_name": "INFINEON TECHNOLOGIES AG", "name": ""}, {"first_name": "", "last_name": "RAMTRON INTERNATIONAL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G11C   7/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   5/10        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "365219"}, {"primary": false, "label": "36523005"}, {"primary": false, "label": "345537"}, {"primary": false, "label": "365221"}, {"primary": false, "label": "36518904"}, {"primary": false, "label": "365220"}], "ecla_classes": [{"label": "G06F   5/12"}, {"label": "S06F205:126"}, {"label": "S06F205:062"}, {"label": "G06F   5/10"}, {"label": "S06F5:14"}], "cpc_classes": [{"label": "G06F   5/14"}, {"label": "G06F2205/062"}, {"label": "G06F   5/12"}, {"label": "G06F2205/062"}, {"label": "G06F   5/14"}, {"label": "G06F   5/10"}, {"label": "G06F2205/126"}, {"label": "G06F2205/126"}, {"label": "G06F   5/10"}, {"label": "G06F   5/12"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1997-04-01", "application_date": "2000-03-24", "family_members": [{"ucid": "US-6172927-B1", "titles": [{"lang": "EN", "text": "First-in, first-out integrated circuit memory device incorporating a retransmit function"}]}]}