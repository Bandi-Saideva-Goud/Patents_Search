{"patent_number": "US-6505295-B1", "publication_id": 73283786, "family_id": 14180065, "publication_date": "2003-01-07", "titles": [{"lang": "EN", "text": "Data processor"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50434963\"><p>To provide a data processing apparatus equipped with a control means to reduce the power required for memory accessing, in spite of the unavailability of a repeat instruction, by reading instructions reiteratively from a small scale buffer in loop processing. Also to provide a data processing apparatus equipped with a means to opt to apply, or not to apply, control to read instructions, that have to be executed reiteratively in loop processing, out of a small scale buffer reiteratively.</p><p>If, as a result of execution of an instruction to alter the content of a certain register prior to a series of instructions to be executed reiteratively, the register satisfies a specific condition, the series of instructions to be executed repeatedly are read out of a small scale buffer reiteratively.</p><p>A data processing apparatus equipped with a control means to reduce the power required for memory accessing, in spite of the unavailability of a repeat instruction, by reading instructions reiteratively from a small scale buffer in loop processing can be provided. Also a data processing apparatus equipped with a means to opt to apply, or not to apply, control to read instructions, that have to be executed reiteratively in loop processing, out of a small scale buffer reiteratively can be provided.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00001\" num=\"1\"><claim-text>1. A data processing apparatus, comprising:</claim-text><claim-text>a first instruction storing means, </claim-text><claim-text>a second instruction storing means for temporary holding a series of instructions to be executed reiteratively, and </claim-text><claim-text>a register means, </claim-text><claim-text>wherein when the content of said register means satisfies a specific condition after execution of a first instruction to alter the content of said register means prior to a series of instructions to be executed reiteratively, said second instruction storing means holds the series of instructions and causes the series of instructions to be outputted reiteratively from the second instruction storing means, and </claim-text><claim-text>wherein when the content of said register means does not satisfy the specific condition after the execution of the first instruction, the series of instructions are reiteratively read from the first instruction storing means. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00002\" num=\"2\"><claim-text>2. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00001\">claim 1</claim-ref>, wherein the final one of said series of instructions to be executed reiteratively is an instruction to cause branching to the first one of the series of instructions to be effected when the specific condition has come to be satisfied.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00003\" num=\"3\"><claim-text>3. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00002\">claim 2</claim-ref>, wherein the first instruction to alter the content of said register means is an instruction to designate the logical value of a bit contained in said register means.</claim-text></claim>"}, {"num": 4, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00004\" num=\"4\"><claim-text>4. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00002\">claim 2</claim-ref>, wherein the first instruction to alter the content of said register means is an instruction to load the number of times the execution of the series of instructions is to be repeated into said register means.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00005\" num=\"5\"><claim-text>5. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00001\">claim 1</claim-ref>, wherein said second instruction storing means is an instruction buffer provided independently from instruction queues to store a plurality of instructions to be read out of said first instruction storing means prior to execution.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00006\" num=\"6\"><claim-text>6. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00001\">claim 1</claim-ref>, wherein the first instruction to alter the content of said register means is an instruction to load information to specify the position of the leading one and information to specify the position of the trailing one of said series of instructions to be repeated into said register means.</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00007\" num=\"7\"><claim-text>7. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00006\">claim 6</claim-ref>, wherein that the number of the instructions to be executed reiteratively, obtained from said information to specify the position of the leading instruction and said information to specify the position of the trailing information, is not greater than a specific value, corresponds to said specific condition.</claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00008\" num=\"8\"><claim-text>8. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00007\">claim 7</claim-ref>, wherein said second instruction storing means is instruction queues to store a plurality of instructions to be read out of said first instruction storing means prior to execution.</claim-text></claim>"}, {"num": 9, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00009\" num=\"9\"><claim-text>9. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00001\">claim 1</claim-ref>, wherein said second instruction storing means has:</claim-text><claim-text>a memory holding circuit whose constituent elements include: </claim-text><claim-text>a first N channel type MOSFET of which the gate terminal is connected to a first node, either one of the source and drain terminals is connected to a second node and the other to a third node; </claim-text><claim-text>a second N channel type MOSFET of which the gate terminal is connected to said first node, either one of the source and drain terminals is connected to a fourth node and the other to a fifth node; </claim-text><claim-text>a third N channel type MOSFET of which the gate terminal is connected to said fifth node, the drain terminal is connected to said third node and the source terminal is connected to a first operating potential point; and </claim-text><claim-text>a fourth N channel type MOSFET of which the gate terminal is connected to said third node, the drain terminal is connected to said fifth node and the source terminal is connected to said first operating potential point. </claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00010\" num=\"10\"><claim-text>10. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00009\">claim 9</claim-ref>, wherein said second instruction storing means further has an amplifying circuit responsive to input signals pairing said second node and said fourth node.</claim-text></claim>"}, {"num": 11, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00011\" num=\"11\"><claim-text>11. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00001\">claim 1</claim-ref>, wherein the specific condition is satisfied when the number of instructions included in the series of instructions is smaller than the capacity of said second instruction storing means.</claim-text></claim>"}, {"num": 12, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00012\" num=\"12\"><claim-text>12. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00001\">claim 1</claim-ref>, wherein said first instruction storing means is a cache memory for storing some of the instructions to be stored in a main memory unit.</claim-text></claim>"}, {"num": 13, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00013\" num=\"13\"><claim-text>13. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00001\">claim 1</claim-ref>, formed over a single semiconductor substrate.</claim-text></claim>"}, {"num": 14, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00014\" num=\"14\"><claim-text>14. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00001\">claim 1</claim-ref>, wherein said instructions are nonexistent at the time of source program formulation, but are generated upon conversion into object codes by a compiler.</claim-text></claim>"}, {"num": 15, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00015\" num=\"15\"><claim-text>15. A data processing apparatus on a single semiconductor substrate, comprising;</claim-text><claim-text>a program memory; </claim-text><claim-text>instruction queues arranged to hold instructions stored in said program memory; </claim-text><claim-text>a register; and </claim-text><claim-text>an instruction executing section for executing instructions provided from said instruction queues, </claim-text><claim-text>wherein when a first instruction to alter the content of said register sets the content of said register to a first condition, a series of instructions for repeating execution are read out from said program memory and stored in said instruction queues at a first routine, and then the series of instructions are repeatedly provided from said instruction queues at the following routines, and </claim-text><claim-text>wherein when the first instruction to alter the content of said register sets the content of said register to a second condition, instructions are provided from said program memory via said instruction queues as an instruction pre-fetch buffer. </claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00016\" num=\"16\"><claim-text>16. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00015\">claim 15</claim-ref>, wherein said series of instructions are a plurality of instructions, and the final one of said series of instructions is an instruction to cause branching to the first one of said series of instructions when a prescribed condition is satisfied.</claim-text></claim>"}, {"num": 17, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00017\" num=\"17\"><claim-text>17. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00015\">claim 15</claim-ref>, wherein the first condition is satisfied when the number of instructions included in the series of instructions is smaller than the number of instruction queues.</claim-text></claim>"}, {"num": 18, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00018\" num=\"18\"><claim-text>18. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00017\">claim 17</claim-ref>, wherein said program memory is a cache memory for storing some of the instructions to be stored in a main memory unit outside the data processing system.</claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00019\" num=\"19\"><claim-text>19. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00018\">claim 18</claim-ref>, wherein the first instruction to alter the content of said register is an instruction to designate the logical value of a bit contained in said register.</claim-text></claim>"}, {"num": 20, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00020\" num=\"20\"><claim-text>20. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00018\">claim 18</claim-ref>, wherein the first instruction to alter the content of said register is an instruction to load information corresponding to the number of repeats of said instructions to be executed reiteratively into said register.</claim-text></claim>"}, {"num": 21, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00021\" num=\"21\"><claim-text>21. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00018\">claim 18</claim-ref>, wherein the first instruction to alter the content of said register is an instruction to load information to specify the position of the leading one and information to specify the position of the trailing one of said series of instructions to be repeated into said register.</claim-text></claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"US-6505295-B1-CLM-00022\" num=\"22\"><claim-text>22. A data processing apparatus, as stated in <claim-ref idref=\"US-6505295-B1-CLM-00021\">claim 21</claim-ref>, wherein that the difference between said information to specify the position of the leading instruction and said information to specify the position of the trailing information is not greater than a specific value, corresponds to said specific condition.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53860009\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><p>This is a national stage application filed under 35 U.S.C. 371 of PCT/JP97/00411 filed Feb. 17, 1997.</p><h4>TECHNICAL FIELD</h4><p>The present invention relates to a data processing apparatus such as a microprocessor or a digital signal process (DSP), and more particularly to a technique effectively applicable to instruction buffers.</p><h4>BACKGROUND ART</h4><p>Along with the development of sophisticated information apparatuses including personal computers (PCs), personal digital assistants (PDAs), digital cellular units and car navigation aids in recent years, the need to reduce power consumption of large scale integrated circuits (LSIs) mounted on these apparatuses has tremendously increased. This is due to the requirements to make the batteries of portable information devices to keep their charged state longer and to suppress the costs of chip packages and cooling systems for desktop information devices. On the other hand, there are now increasingly active trends to incorporate high performance multimedia functions for processing video and audio signals and communication into information apparatuses. Thus the calculation capacity required of LSIs to execute such multimedia processing is ever increasing, and this constitutes one of the main causes of increased power consumption by LSIs.</p><p>Data processing apparatuses including microprocessors and digital signal processors (DSPs) are extensively used as LSIs for executing multimedia processing such as mentioned above. Incidentally, when these data processing apparatuses are to execute multimedia processing, generally the processing is very often to execute a loop consisting of a relatively small number of instructions, because most instances of multimedia processing are ones of digital signal processing mainly consisting of product sum calculations, which are accomplished by repeating many times (1) multiplication and (2) the addition of the result of multiplication to the cumulative sum.</p><p>In a digital signal processor, in many cases, an instruction to generate an internal state for repeated execution of a series of instructions (repeat instruction) is supported. A repeat instruction the number of the serial instructions to be executed reiteratively immediately after that and the number of times they are to be executed reiteratively. As a result, instructions to be executed many times reiteratively are executed without having to read them out of a memory (ROM, RAM or cache memory) many times. Therefore, high speed and reduced power consumption can be achieved. Examples are described in \u201cTMS320C30 Third Generation Digital Signal Processor Users Manual\u201d published by Texas Instruments Japan Ltd. in 1990 (hereinafter referred to as Prior Art 1) and the Gazette of the Japanese Patent Laid-open No. 293124/1992 (hereinafter referred to as Prior Art 2).</p><h4>DISCLOSURE OF THE INVENTION</h4><p>Digital signal processors such as those described in Prior Art 1 and Prior Art 2 presuppose, in order to save the power required for memory accessing by reiteratively reading instructions from an instruction buffer in loop processing, the availability of a repeat instruction. Accordingly there is a problem that the control method uses by digital signal processors such as those of Prior Art 1 and Prior Art 2 cannot be applied to a data processing apparatus provided with no repeat instruction.</p><p>In microprocessors of the like for general use instead of specializing in digital signal processing, a repeat instruction is not necessarily supported. In order to be provided with a repeat instruction, an instruction buffer or a repeat control circuit has to be introduced into them. Since, moreover, a repeat control circuit needs many items of hardware such as a repeat start address register, a repeat end address register, a repeat count register, a comparator and a down counter, this is based on a way of thinking that increasing the circuitry scale by introducing such a repeat control circuit is not necessarily advantageous to a microprocessor.</p><p>Further, in loop processing emerging in an actual processing, not only simple repetitions but also loops of diverse structures emerge. They include loops to which the control method of reading instructions reiteratively out of the aforementioned instruction buffer cannot be applied as a matter of principle. For instance, where a loop has a plurality of routes of which a different one is followed according to the number of repetitions of the loop, the aforementioned instruction buffer, in which only the instruction executed over the first route is stored, is incompatible with the second and subsequent loops. Therefore the microprocessor should be provided with a means to prohibit the application of control to read instructions reiteratively out of the instruction buffer depending on the structure of the loop. However, as the digital signal processors of Prior Art 1 and Prior Art 2 are provided with no such means and, on every occasion of loop processing, control to reiteratively read out instructions out of the instruction buffer is effected, they involve the problem that correct program processing cannot be accomplished when they come across a loop of a structure to which control to reiteratively read out instructions from the instruction buffer cannot be applied.</p><p>On the other hand, a technique to increase the speed or program processing by having, during the execution of loop processing, every instruction in the loop stay in a cache memory without fail is described in the Japanese Patent Laid-open No. 333929/1992 (hereinafter referred to as Prior Art 3). According to Prior Art 3, irrespective of whether or not loop processing is being executed, the cache memory operates whenever an instruction is read (unless miscaching is committed). In order to reduce the power spent in loop processing, the capacity of the cache memory itself should be reduced. However, there is the problem that, as the same small capacity memory is accessed even during non-loop processing, the hit ratio drops, making it impossible to increase the speed of program processing.</p><p>An object of the present invention is to provide a data processing apparatus provided with a control means which, in spite of the unavailability of a repeat instruction, reduces the power needed for memory accessing by reading instructions from a small scale buffer reiteratively during loop processing.</p><p>Another object of the invention is to provide a data processing apparatus provided with a means to opt to apply, or not to apply, control to read reiteratively, from a small scale buffer, instructions to be reiteratively executed during loop processing.</p><p>The aforementioned and other objects and novel features of the invention will become apparent from the description in this specification and accompanying drawings.</p><p>The following is a brief description of the typical aspects of the invention disclosed in this application.</p><p>Thus, a data processing apparatus (<b>100</b>, <b>700</b>, <b>900</b>, <b>1400</b> or <b>1600</b>) for executing instructions stored in a first instruction storing means (<b>102</b>, <b>702</b>, <b>902</b>, <b>1402</b> or <b>1602</b>) causes, if, as a result of the execution of an instruction to alter the content of a register (<b>125</b>, <b>742</b>, <b>931</b>, <b>932</b>, <b>1429</b> or <b>1629</b>) prior to a series of instructions to be executed reiteratively, the content of the register (<b>125</b>, <b>742</b>, <b>931</b>, <b>932</b>, <b>1429</b> or <b>1629</b>) satisfies a specific condition, a second instruction storing means (<b>104</b>, <b>704</b>, <b>904</b>, <b>1421</b> or <b>1621</b>) to hold the series of instructions to be executed reiteratively and causes them to be outputted reiteratively from the second instruction storing means (<b>104</b>, <b>704</b>, <b>904</b>, <b>1421</b> or <b>1621</b>) (see FIGS. 1, <b>5</b>, <b>7</b>, <b>11</b> and <b>13</b>).</p><p>Further, the final one of the series of instructions to be executed reiteratively in the data processing apparatus (<b>100</b>, <b>700</b>, <b>1400</b>, <b>1600</b>) is an instruction to cause branching to the first one of the series of instructions to be effected when a prescribed condition has come to be satisfied.</p><p>Further, the instruction to alter the content of the register (<b>125</b>, <b>1429</b> or <b>1629</b>) in the data processing apparatus (<b>100</b>, <b>700</b>, <b>1400</b> or <b>1600</b>) is an instruction to designate the logical value of a specific bit (<b>124</b>, <b>1428</b> or <b>1628</b>) contained in the register (<b>125</b>, <b>1429</b> or <b>1629</b>) (see FIGS. 1, <b>11</b> and <b>13</b>).</p><p>Further, in the data processing apparatus (<b>700</b>), the instruction to alter the content of the register (<b>125</b>, <b>1429</b> or <b>1629</b>) is an instruction to load the number of times the execution of the series of instructions is to be repeated into the register (<b>742</b>) (see FIG. <b>5</b>).</p><p>Further, in the data processing apparatus (<b>100</b>, <b>700</b> or <b>900</b>), the second instruction storing means is a different instruction buffer (<b>104</b>, <b>704</b> or <b>904</b>) from instruction queues to store a plurality of instructions to be read out of the first instruction storing means prior to execution.</p><p>Further, in the data processing apparatus (<b>900</b>), the instruction to alter the content of the register (<b>931</b> or <b>932</b>) is an instruction to load information to specify the position of the leading one and information to specify the position of the trailing one of the series of instructions to be repeated into the register (<b>931</b> or <b>932</b>) (see FIG. 7)</p><p>Further, in the data processing apparatus (<b>900</b>), that the number of the instructions to be executed reiteratively, obtained from the information to specify the position of the leading instruction and the information to specify the position of the trailing information, is not greater than a specific value corresponds to the aforementioned specific condition (see FIG. <b>7</b>).</p><p>Further, in the data processing apparatus (<b>1400</b> or <b>1600</b>), the second instruction storing means is instruction queues (<b>1421</b> or <b>1621</b>) to store a plurality of instructions to be read out of the first instruction storing means prior to execution.</p><p>Further, in the data processing apparatus (<b>100</b>, <b>700</b>, <b>900</b>), the second instruction storing means (<b>104</b>, <b>704</b> or <b>904</b>) has a memory holding circuit (<b>1030</b>_k_l) whose constituent elements include a first N channel type MOSFET (<b>1103</b>) of which the gate terminal is connected to a first node (WL-k), either one of the source and drain terminals is connected to a second node (BL-l) and the other to a third node (N<b>1101</b>); a second N channel type MOSFET (<b>1104</b>) of which the gate terminal is connected to the first node (WL-k), either one of the source and drain terminals is connected to a fourth node (BLB-l) and the other to a fifth node (N<b>1102</b>); a third N channel type MOSFET (<b>1101</b>) of which the gate terminal is connected to a fifth node (N<b>1102</b>), the drain terminal is connected to the third node (N<b>1101</b>) and the source terminal is connected to a first operating potential point (GND); and a fourth N channel type MOSFET (<b>1102</b>) of which the gate terminal is connected to the third node (N<b>1101</b>), the drain terminal is connected to the fifth node (N<b>1102</b>) and the source terminal is connected to the first operating potential point (GND) (see FIGS. 1, <b>5</b>, <b>7</b>, <b>8</b> and <b>9</b>).</p><p>Further, in the data processing apparatus (<b>100</b>, <b>700</b> or <b>900</b>), the second instruction storing means (<b>104</b>, <b>704</b> or <b>904</b>) has an amplifying circuit (<b>1040</b>_l) responsive to input signals pairing the second node (BL_l) and the fourth node (BLB_l) (see FIGS. 1, <b>5</b>, <b>7</b> and <b>8</b>).</p><p>Further in a state in which the content of the register (<b>1429</b> or <b>1629</b>) does not satisfy the specific condition in the data processing apparatus (<b>1400</b> or <b>1600</b>), any instruction read out of the first instruction storing means (<b>1402</b> or <b>1602</b>) is temporarily held by the second instruction storing means (<b>1421</b> or <b>1621</b>) at most until it is executed once (see FIGS. <b>11</b> and <b>13</b>).</p><p>For instance, the data processing apparatus (<b>100</b>), in order to read out an instruction reiteratively from a buffer (<b>104</b>) in executing a loop, has only to insert an instruction to set a specific bit (<b>124</b>, a buffer control flag) immediately before the execution of the bit. Therefore, it can reduce the power consumed for memory accessing by reiteratively reading the instruction out of the small scale buffer (<b>104</b>) when processing the loop without using a repeat instruction.</p><p>Further, unless the specific bit (<b>124</b>, the buffer control flag) is set, the buffer (<b>104</b>) is not accessed in the processing of any loop. Therefore, in order to forbid the application of the control to read an instruction out of the buffer (<b>104</b>) reiteratively in executing a loop, it is sufficient merely to refrain from inserting an instruction to set the specific bit (<b>124</b>, the buffer control flag) immediately before the execution of the loop.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF DRAWINGS</h4><p>FIG. 1 illustrates the configuration of a data processing apparatus representing a first embodiment of the present invention (Embodiment 1).</p><p>FIG. <b>2</b>(<i>a</i>) and FIG. <b>2</b>(<i>b</i>) illustrate the instruction reading operation of the data processing apparatus of Embodiment 1.</p><p>FIG. 3 illustrates an algorithm for inserting a buffer control flag setting instruction into a program description in the data processing apparatus of Embodiment 1.</p><p>FIG. 4 illustrates a loop size distribution in the execution of a voice encoding/decoding program in a certain data processing apparatus.</p><p>FIG. 5 illustrates the configuration of a data processing apparatus representing a second embodiment of the invention (Embodiment 2).</p><p>FIG. 6 illustrates an algorithm for substituting an instruction in a program distribution in the data processing apparatus of Embodiment 2.</p><p>FIG. 7 illustrates the configuration of a data processing apparatus representing a third embodiment of the invention.</p><p>FIG. 8 illustrates the configuration of a buffer included in the data processing apparatus of Embodiment 1.</p><p>FIG. 9 illustrates the configuration of a memory cell included in the buffer.</p><p>FIG. 10 compares areas occupied by a buffer.</p><p>FIG. 11 illustrates the configuration of a data processing apparatus representing a fourth embodiment of the invention (Embodiment 4).</p><p>FIG. 12 illustrates control by the data processing apparatus of Embodiment 4.</p><p>FIG. 13 illustrates the configuration of a data processing apparatus representing a fifth embodiment of the invention (Embodiment 5).</p><p>FIG. 14 illustrates control by the data processing apparatus of Embodiment 5.</p><p>FIG. 15 illustrates a classification of the modes of carrying out the invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>BEST MODES FOR CARRYING OUT THE INVENTION</h4><p>Embodiments of the present invention will be described in detail below with reference to drawings.</p><h4>Embodiment 1</h4><p>FIG. 1 illustrates the configuration of a data processing apparatus representing a first embodiment of the invention. A data processing apparatus <b>100</b> consists of a data processing section comprising a control section <b>120</b>, an instruction executing section <b>140</b>, a program counter <b>160</b>, a buffer <b>104</b>, a selector <b>106</b> and the like, and of a memory <b>102</b>. The data processing apparatus <b>100</b> may either be formed over a single semiconductor substrate or only the aforementioned data processing section may be formed over a single semiconductor substrate. The control section <b>120</b> consists of an instruction decoder <b>122</b>, a control register <b>125</b>, a buffer control circuit <b>126</b> and the like. To add, instruction fetch queues(instruction pre-reading buffers) may as well be provided either within the instruction decoder <b>122</b> or between the selector <b>106</b> and the instruction decoder <b>122</b>.</p><p>The memory <b>102</b> is, for example, either a read only memory (ROM) or random access memory (RAM) as a main storage or a cache memory for holding some of the instructions to be stored into the main storage. The ROM may consist of, for instance, either a mask ROM programmed in a semiconductor manufacturing process or an electrically rewritable non-volatile memory such as a flash memory. The RAM may consist of, for instance, a static random access memory (SRAM), a dynamic random access memory (DRAM), or a ferroelectric memory (an electrically rewritable nonvolatile whose write cycle and read cycle are substantially equal). The cache memory may be composed in a full associative or a set associative system.</p><p>Incidentally, the output S<b>162</b> of the program counter <b>160</b> may be supplied to the memory <b>102</b> via an address bus.</p><p>In this embodiment, control to read instructions reiteratively out of the buffer <b>104</b> when a loop, wherein the trailing one of a group of instructions to be executed reiteratively constitutes a conditional branching instruction to the leading instruction. Therefore it utilizes no repeat instruction. An outline of the operation of the data processing apparatus <b>100</b> to execute a group of instructions reiteratively will be presented below.</p><p>(1) Immediately before the execution of a loop to which control to read instructions reiteratively out of the buffer <b>104</b>, an instruction to set a specific bit <b>124</b> (buffer control flag) is executed. From immediately after the setting of the specific bit <b>124</b> (buffer control flag) onward, the instructions read out of the memory <b>102</b> are successively written into the buffer <b>104</b> while being put to execution. The process goes on to (2).</p><p>(2) After the bit <b>124</b> (buffer control flag) is set, the conditional branching instruction (trailing instruction) is first read, and the process goes on to (3) if that condition is satisfied, or to (5) if it is not satisfied.</p><p>(3) Accessing to the memory <b>102</b> is stopped, and the instructions stored in the buffer <b>104</b> are read successively, beginning with the leading one. The process goes on to (4).</p><p>(4) The conditional branching instruction (trailing instruction) is read, and the process goes on to (3) if that condition is satisfied, or to (5) if it is not satisfied.</p><p>(5) Accessing to the memory <b>102</b> is stopped, and usual reading of instructions out of the memory <b>102</b> is started. The bit <b>124</b> (buffer control flag) is cleared.</p><p>By the process described above, no repeat instruction is used, but instructions are read reiteratively out of the small buffer <b>104</b> and the memory <b>102</b> is prevented from being accessed during loop processing. Further, unless the bit <b>124</b> (buffer control flag) is set, no accessing to the buffer <b>104</b> takes place during the processing of any loop. Therefore, in order to forbid the application of control to read instructions reiteratively out of the buffer <b>104</b> when a given loop is to be executed, it is sufficient merely to refrain from inserting an instruction to set the bit <b>124</b> (buffer control flag) immediately before the execution of the loop.</p><p>Next will be presented an example of loop in which the trailing one of a group of instructions to be executed reiteratively constitutes a conditional branching instruction to the leading instruction.</p><p>In order, for example, to execute n (n is a positive integer) instructions (inst(<b>1</b>), inst(<b>2</b>), . . . , inst(n)) m times (m is a positive integer), the program is encoded as follows.</p><p>gr<b>0</b>\u2190km;</p><p>LOOP: inst(<b>1</b>);</p><p>inst(<b>2</b>);</p><p>.</p><p>.</p><p>.</p><p>inst(n);</p><p>gr<b>0</b>\u2190gr<b>0</b>\u22121;</p><p>if NZ goto LOOP;</p><p>Here \u201cgr<b>0</b>\u2190m\u201d denotes the setting of the number of loop repeats into a register (gr<b>0</b>, provided in the instruction executing section for example). \u201cgr<b>0</b>\u2190gr<b>0</b>\u22121\u201d denotes a decrement of the number of loop repeats. \u201cif NZ goto LOOP\u201d is a conditional branching instruction to cause branching to the leading instruction (inst(<b>1</b>)) of the loop if the result of calculating the decrement of the number of loop repeats, performed immediately before, is not 0 (NZ: Not Zero), i.e. the loop has not yet been completed.</p><p>When this loop is executed, the buffer <b>104</b> is caused to hold the instructions, and to have the instructions reiteratively read out of this buffer <b>104</b>, an instruction (set BCF) to set the buffer control flag <b>124</b> (BCF) in the control register <b>125</b> is inserted before the leading instruction (inst(<b>1</b>)) of the loop as follows.</p><p>gr<b>0</b>\u2190m;</p><p>set BCF;</p><p>LOOP: inst(<b>1</b>);</p><p>inst(<b>2</b>);</p><p>.</p><p>.</p><p>.</p><p>inst(n);</p><p>gr<b>0</b>\u2190gr<b>0</b>\u22121;</p><p>if NZ goto LOOP;</p><p>FIG. 2 illustrates the operation to read instructions which takes place when the data processing apparatus <b>100</b> processes the above-described loop. The operation of the data processing apparatus <b>100</b> will be described below with reference to FIG. <b>2</b>.</p><p>The instruction reading operation of the data processing apparatus <b>100</b> has the following three states of operation (see FIG. <b>2</b>(<i>b</i>)).</p><p>(1) \u201cUsual\u201d State</p><p>An instruction read out of the memory <b>102</b> in accordance with the count of the program counter <b>160</b> is delivered as it is to the control section <b>120</b> via the output S<b>101</b> of the memory and a bus S<b>102</b>. The buffer <b>104</b> is at halt. The selector <b>106</b> is caused by a selection signal SEL to select a signal of an output S<b>103</b> from the bus S<b>102</b>.</p><p>(2) State of \u201cWriting Into Buffer\u201d</p><p>The instruction read out of the memory <b>102</b> is successively written into the buffer <b>104</b> at the same time as being delivered to the control section <b>120</b>. The selector <b>106</b> is caused by the selection signal SEL to select the signal of the output S<b>103</b> from the bus S<b>102</b>.</p><p>(3) State of \u201cReading Out of Buffer\u201d</p><p>The instruction read out of the memory <b>102</b> is delivered to the control section <b>120</b>. The buffer <b>104</b> is at halt. The selector <b>106</b> is caused by the selection signal SEL to select a signal of an output S<b>104</b> from the buffer <b>104</b>.</p><p>As illustrated in FIG. <b>2</b>(<i>a</i>), when the buffer control flag <b>124</b> (BCF) is not set, the data processing apparatus <b>100</b> reads instruction in the \u201cusual\u201d state. Once an instruction (set BCF) to set the buffer control flag <b>124</b> (BCF) is executed, instructions are read in accordance with the following rules.</p><p>(i) Immediately after the buffer control flag <b>124</b> (BCF) is set, a shift to the state of \u201cwriting into buffer\u201d takes place.</p><p>(ii) When the conditional branching instruction (if NZ goto LOOP) is read in the state of \u201cwriting into buffer,\u201d (iii) will be followed if the condition is satisfied, or (v) will be followed if it is not satisfied.</p><p>(iii) A shift to the state of \u201creading out of buffer\u201d takes place. Instructions stored in the buffer <b>104</b> are sequentially read beginning with the leading one. If the conditional branching instruction (if NZ goto LOOP) is read, (iv) will be followed.</p><p>(iv) If the condition is satisfied, (iii) will be followed, or if not, (v) will be followed.</p><p>(v) A shift to the \u201cusual\u201d state takes place. The buffer control flag <b>124</b> (BCF) is cleared by a buffer control clear signal CLR.</p><p>In order to perform the actions of (i) through (v), the buffer control circuit <b>126</b> issues the following control signals to the memory <b>102</b>, buffer <b>104</b>, selector <b>106</b> and buffer control flag <b>124</b> (BCF) on the basis of an output S<b>126</b> from the buffer control flag <b>124</b> (BCF) and branching information S<b>123</b> (information concerning the detection of a conditional branching instruction and on the satisfaction or non-satisfaction of the condition) from the instruction decoder <b>122</b>.</p><p>(a) Memory Enable Signal MEN:</p><p>This signal causes the memory <b>102</b> to be instructed to operate or stop. When at a \u201cLOW\u201d level, the signal causes the memory <b>102</b> to stop in the state of \u201creading out of buffer.\u201d When at a \u201cHIGH\u201d level, it causes the memory <b>102</b> to operate. This signal may as well be used as a memory access request signal.</p><p>(b) Selector Control Signal SEL:</p><p>This signal causes the selector <b>106</b> to be controlled. When at a \u201cHIGH\u201d level, it causes the output S<b>104</b> from the buffer to be selected in the state of \u201creading out of buffer.\u201d When at a \u201cLOW\u201d level, it causes the output S<b>103</b> from the bus <b>102</b> to be selected.</p><p>(c) Pointer Reset Signal RST:</p><p>This signal causes the pointer of the buffer <b>104</b> to be returned to the start position. It is caused to be activated (\u201cHIGH\u201d level) when the conditional branching instruction is read in either the state of \u201cwriting into buffer\u201d or the state of \u201creading out of buffer.\u201d</p><p>(d) Buffer Enable Signal BEN:</p><p>This signal causes the buffer <b>104</b> to be instructed to operate or stop. In either the state of \u201cwriting into buffer\u201d or the state of \u201creading out of buffer,\u201d it is turned \u201cHIGH\u201d and causes the buffer <b>104</b> to be operated.</p><p>(e) Write Enable Signal WEN:</p><p>This signal causes an instruction to be given to write into or read out of the buffer <b>104</b>. In the state of \u201cwriting into buffer,\u201d it is turned \u201cHIGH\u201d and caused to instruct writing.</p><p>(f) Buffer Control Flag Clear Signal CLR:</p><p>When the condition of the conditional branching instruction is not satisfied, this signal is caused to clear the buffer control flag <b>124</b> (BCF).</p><p>Thus, this embodiment can reduce the power consumed for memory accessing by reiteratively reading instructions out of the small scale buffer <b>104</b> when processing a loop without using a repeat instruction. To add, the buffer control circuit <b>126</b> can be realized with a very small scale sequential circuit.</p><p>In this embodiment, unless the buffer control flag <b>124</b> (BCF) is set, no accessing to the buffer <b>104</b> takes place during the processing of any loop. Therefore, in order to forbid the application of control to read instructions reiteratively out of the buffer <b>104</b> when a given loop is to be executed, it is sufficient merely to refrain from inserting an instruction to set (set BCF) the bit <b>124</b> (buffer control flag) immediately before the execution of the loop (immediately before inst(<b>1</b>) in the above-cited example).</p><p>Next, in order to apply control to read instructions reiteratively out of the buffer <b>104</b> to only small scale loops which involve no flow control instructions, such as a branching instruction, except the trailing instruction (hereinafter referred to as \u201csimple reiterative loops\u201d) and whose number of constituent instructions is not greater than the maximum number of instructions the buffer <b>104</b> can accommodate, a buffer control flag set instruction (set BCF) is inserted into the program description in accordance with an algorithm shown in FIG. <b>3</b>. The algorithm shown in FIG. 3 will be explained below.</p><p>(1) One instruction is referred to (S<b>1</b>).</p><p>(2) If the instruction satisfies all of the following conditions A through D, processing under (3) is performed. In any other case, (4) is followed (S<b>21</b>, S<b>22</b>, S<b>23</b>, S<b>24</b>).</p><p>Condition A: The instruction referred to is a conditional branching instruction (if NZ goto loop in the example cited above).</p><p>Condition B: (Address of branching destination)&lt;(Address of conditional branching instruction).</p><p>Condition C: (Number of instructions from instruction on branching destination to conditional branching instruction)\u2266(Maximum number of instructions buffer <b>104</b> can accommodate), n+2\u2266(Maximum number of instructions buffer <b>104</b> can accommodate) in the above-cited example.</p><p>Condition D: Between the instruction on the branching destination and the conditional branching instruction (from inst(<b>1</b>) to if NZ goto LOOP in the above-cited example), there is no other flow control instruction (branching instruction or the like) than the instruction referred to (if NZ goto LOOP in the above-cited example).</p><p>(3) The buffer control flag set instruction (set BCF) is inserted immediately before the instruction on the branching destination (inst(<b>1</b>) in the above-cited example) (S<b>3</b>).</p><p>(4) The object of reference is shifted to the next instruction (S<b>4</b>).</p><p>If the above-described algorithm is built into an object code generating tool, such as a compiler or an assembler, in advance, the programmer can encode the program (source code) as usual without being conscious of the presence of the buffer <b>104</b>. Further, if the objects of application control to read instructions reiteratively out of the buffer <b>104</b> to only small scale simple reiterative loops as stated above, a considerable effect to save power consumption can be expected.</p><p>FIG. 4 illustrates a simple reiterative loop size distribution in the execution of a voice encoding/decoding program. The horizontal axis represents the loop size (number of instructions), and the vertical axis, the cumulative number of cycles of loop execution (%). When the data processing apparatus <b>100</b> executes a voice encoding/decoding program, about 60% of the total execution cycles consists of simple reiterative loops each consisting of 20 or fewer steps. That is to say, if the buffer <b>104</b> has a capacity to accommodate up to 20 instructions, about 60% of the total execution cycles can be prevented from accessing the memory <b>102</b>. Further, if the capacity of the buffer <b>104</b> is expanded to 32 instructions, about 80% of the cycles can be covered.</p><h4>Embodiment 2</h4><p>FIG. 5 illustrates the configuration of a data processing apparatus representing a second embodiment of the present invention. A data processing apparatus <b>700</b> consists of a data processing section comprising a control section <b>720</b>, an instruction executing section <b>740</b>, a program counter <b>760</b>, a buffer <b>704</b>, a selector <b>706</b> and the like, and of a memory <b>702</b>. The data processing apparatus <b>700</b> may either be formed over a single semiconductor substrate or only the aforementioned data processing section may be formed over a single semiconductor substrate. The control section <b>720</b> consists of an instruction decoder <b>722</b>, a buffer control circuit <b>724</b> and the like. To add, instruction fetch queues (instruction pre-reading buffers) may as well be provided either within the instruction decoder <b>722</b> or between the selector <b>706</b> and the instruction decoder <b>722</b>.</p><p>The memory <b>702</b> is, for example, either a read only memory (ROM) or random access memory (RAM) as a main storage or a cache memory for holding some of the instructions to be stored into the main storage. The ROM may consist of, for instance, either a mask ROM programmed in a semiconductor manufacturing process or an electrically rewritable non-volatile memory such as a flash memory. The RAM may consist of, for instance, a static random access memory (SRAM), a dynamic random access memory (DRAM), or a ferroelectric memory (an electrically rewritable non-volatile whose write cycle and read cycle are substantially equal).</p><p>Incidentally, the output S<b>762</b> of the program counter <b>760</b> may be supplied to the memory <b>702</b> via an address bus.</p><p>The data processing apparatus <b>700</b> is provided with a loop count register <b>742</b> (LC) in place of the buffer control flag <b>124</b> (BCF) which the data processing apparatus <b>100</b> was provided with.</p><p>The data processing apparatus <b>700</b> is provided with no repeat instruction either. Accordingly, in order, for example, to execute n (n is a positive integer) instructions (inst(<b>1</b>), inst(<b>2</b>), . . . , inst(n)) m times (m is a positive integer), the program is encoded as follows.</p><p>gr<b>0</b>\u2190m;</p><p>LOOP: inst(<b>1</b>);</p><p>inst(<b>2</b>);</p><p>.</p><p>.</p><p>.</p><p>inst(n);</p><p>gr<b>0</b>\u2190gr<b>0</b>\u22121;</p><p>if NZ goto LOOP;</p><p>Here \u201cgr<b>0</b>\u2190m\u201d denotes the setting of the number of loop repeats into a general purpose register (gr<b>0</b>, provided in the instruction executing section for example). \u201cgr<b>0</b>\u2190gr<b>0</b>\u22121\u201d denotes a decrement of the number of loop repeats. \u201cif NZ goto LOOP\u201d is a conditional branching instruction to cause branching to the leading instruction (inst(<b>1</b>)) of the loop if the result of calculating the decrement of the number of loop repeats, performed immediately before, is not 0 (NZ: Not Zero), i.e. the loop has not yet been completed.</p><p>When this loop is executed, the buffer <b>704</b> is caused to hold the instructions, and to have the instructions reiteratively read out of this buffer, the number of loop repeats is counted using the loop count register <b>742</b> (LC) instead of the register (gr<b>0</b>) as follows.</p><p>LC\u2190m;</p><p>LOOP: inst(<b>1</b>);</p><p>inst(<b>2</b>);</p><p>.</p><p>.</p><p>.</p><p>inst(n);</p><p>LC\u2190LC\u22121;</p><p>if NZ goto LOOP;</p><p>The instruction reading operation accomplished when the data processing apparatus <b>700</b> processes the above-described loop will be explained below. The data processing <b>700</b>, like the data processing apparatus <b>100</b>, three states of operation including \u201cusual,\u201d \u201cwriting into buffer\u201d and \u201creading out of buffer\u201d states (see FIG. <b>2</b>(<i>b</i>)). The initial count of the loop count register <b>742</b> (LC) is 0. When the count of the loop count register <b>724</b> (LC) is 0, the data processing apparatus <b>700</b> reads instructions in the \u201cusual\u201d state. When the number of times the loop is to be repeated (any other value than 0) is loaded into the loop count register <b>742</b> (LC) (LC\u2190m), instructions are read in accordance with the following rules.</p><p>(i) Immediately after the non-0 value is loaded into the loop count register <b>742</b> (LC), a shift to the state of \u201cwriting into buffer\u201d takes place.</p><p>(ii) When the conditional branching instruction (if NZ goto LOOP) is read in the state of \u201cwriting into buffer,\u201d (iii) will be followed if the condition is satisfied, or (v) will be followed if it is not satisfied.</p><p>(iii) A shift to the state of \u201creading out of buffer\u201d takes place. Instructions stored in the buffer <b>704</b> are sequentially read beginning with the leading one. If the conditional branching instruction (if NZ goto LOOP) is read, (iv) will be followed.</p><p>(iv) If the condition is satisfied, (iii) will be followed, or if not, (v) will be followed.</p><p>(v) A shift to the \u201cusual\u201d state takes place.</p><p>In order to perform the actions of (i) through (v), the buffer control circuit <b>724</b> issues the following control signals to the memory <b>702</b>, buffer <b>704</b>, and selector <b>706</b> on the basis of an output S<b>742</b> from the loop count register <b>742</b> (LC) and branching information S<b>722</b> (information concerning the detection of a conditional branching instruction and on the satisfaction or non-satisfaction of the condition) from the instruction decoder <b>722</b>.</p><p>(a) Memory Enable Signal MEN:</p><p>This signal causes the memory <b>702</b> to be instructed to operate or stop. When at a \u201cLOW\u201d level, the signal causes the memory <b>702</b> to stop in the state of \u201creading out of buffer.\u201d When at a \u201cHIGH\u201d level, it causes the memory <b>702</b> to operate. This signal may as well be used as a memory access request signal.</p><p>(b) Selector Control Signal SEL:</p><p>This signal causes the selector <b>706</b> to be controlled. When at a \u201cHIGH\u201d level, it causes the output S<b>704</b> from the buffer to be selected in the state of \u201creading out of buffer.\u201d When at a \u201cLOW\u201d level, it causes the output S<b>703</b> from the bus <b>702</b> to be selected.</p><p>(c) Pointer Reset Signal RST:</p><p>This signal causes the pointer of the buffer <b>704</b> to be returned to the start position. It is caused to be activated (\u201cHIGH\u201d level) when the conditional branching instruction is read in either the state of \u201cwriting into buffer\u201d or the state of \u201creading out of buffer.\u201d</p><p>(d) Buffer Enable Signal BEN:</p><p>This signal causes the buffer <b>704</b> to be instructed to operate or stop. In either the state of \u201cwriting into buffer\u201d or the state of \u201creading out of buffer,\u201d it is turned \u201cHIGH\u201d and causes the buffer <b>704</b> to be operated.</p><p>(e) Write Enable Signal WEN:</p><p>This signal causes an instruction to be given to write into or read out of the buffer <b>704</b>. In the state of \u201cwriting into buffer,\u201d it is turned \u201cHIGH\u201d and caused to instruct writing.</p><p>Thus, this embodiment can reduce the power consumed for memory accessing by reiteratively reading instructions out of the small scale buffer <b>704</b> when processing a loop without using a repeat instruction. To add, the buffer control circuit <b>724</b> can be realized with a very small scale sequential circuit.</p><p>In this embodiment, unless a non-0 value is loaded (if 0 is loaded) into the loop counter register <b>742</b> (LC) is set, no accessing to the buffer <b>704</b> takes place during the processing of any loop. Therefore, in order to forbid the application of control to read instructions reiteratively out of the buffer <b>704</b> when a given loop is to be executed, it is sufficient merely to refrain from using the loop count register <b>742</b> (LC) for counting the number of loop repetitions (the register gr<b>0</b> or the like may be used).</p><p>Next, in order to apply control to read instructions reiteratively out of the buffer <b>704</b> to only small scale loops whose number of constituent instructions is not greater than the maximum number of instructions the buffer <b>704</b> can accommodate, the register to be used for counting the number of loop repetitions is altered to the loop count register <b>742</b> (LC) in accordance with an algorithm shown in FIG. <b>6</b>.</p><p>(1) One instruction is referred to (S<b>10</b>).</p><p>(2) If the instruction satisfies all of the following conditions A through F, processing under (3) is performed. In any other case, (4) is followed (S<b>201</b>, S<b>202</b>, S<b>203</b>, S<b>204</b>, S<b>205</b>, S<b>206</b>).</p><p>Condition A: The instruction referred to is a conditional branching instruction (if NZ goto loop in the example cited above).</p><p>Condition B: (Address of branching destination)&lt;(Address of conditional branching instruction).</p><p>Condition C: (Number of instructions from instruction on branching destination to conditional branching instruction)\u2266(Maximum number of instructions buffer <b>704</b> can accommodate), n+2\u2266(Maximum number of instructions buffer <b>704</b> can accommodate) in the above-cited example.</p><p>Condition D: Between the instruction on the branching destination and the conditional branching instruction (from inst(<b>1</b>) to if NZ goto LOOP in the above-cited example), there is no other flow control instruction (branching instruction or the like) than the instruction referred to (if NZ goto LOOP in the above-cited example).</p><p>Condition E: The instruction immediately before the branching destination is an instruction into a certain register (gr<b>0</b>\u2190m in the above-cited example.</p><p>Condition F: The instruction immediately before the conditional branching destination is an instruction to decrement the count of the register (gr<b>0</b>\u2190gr<b>0</b>\u22121).</p><p>(3) The operands of the above-mentioned load instruction and decrement instruction are substituted into the loop count register <b>742</b> (LC) (S<b>30</b>).</p><p>(4) The object of reference is shifted to the next instruction (S<b>40</b>).</p><p>If the above-described algorithm is built into an object code generating tool, such as a compiler or an assembler, in advance, the programmer can encode the program (source code) as usual without being conscious of the presence of the buffer <b>704</b>.</p><h4>Embodiment 3</h4><p>FIG. 7 illustrates the configuration of a data processing apparatus representing a third embodiment of the invention. A data processing apparatus <b>900</b> consists of a data processing section comprising a control section <b>940</b>, an instruction executing section <b>950</b>, a program counter <b>960</b>, a buffer <b>904</b>, a selector <b>906</b> and the like, and of a memory <b>902</b>. The data processing apparatus <b>900</b> may either be formed over a single semiconductor substrate or only the aforementioned data processing section may be formed over a single semiconductor substrate. The control section <b>940</b> consists of an instruction decoder <b>920</b>, a repeat control section <b>930</b> and the like. To add, instruction fetch queues (instruction pre-reading buffers) may as well be provided either within the instruction decoder <b>920</b> or between the selector <b>906</b> and the instruction decoder <b>920</b>.</p><p>The memory <b>902</b> is, for example, either a read only memory (ROM) or random access memory (RAM) as a main storage or a cache memory for holding some of the instructions to be stored into the main storage. The ROM may consist of, for instance, either a mask ROM programmed in a semiconductor manufacturing process or an electrically rewritable non-volatile memory such as a flash memory. The RAM may consist of, for instance, a static random access memory (SRAM), a dynamic random access memory (DRAM), or a ferroelectric memory (an electrically rewritable non-volatile whose write cycle and read cycle are substantially equal).</p><p>Incidentally, the output S<b>962</b> of the program counter <b>960</b> may be supplied to the memory <b>902</b> via an address bus.</p><p>In this embodiment, the data processing apparatus <b>900</b> is provided with a repeat instruction. The repeat control section <b>930</b> is provided with a repeat start address register <b>931</b> (RS), repeat end address register <b>932</b> (RE), repeat count register <b>933</b> (RC), comparator circuit <b>935</b>, down counter <b>936</b>, difference detecting circuit <b>937</b> and buffer control circuit <b>938</b>.</p><p>In order, for example, to execute n (n is a positive integer) instructions (inst(<b>1</b>), inst(<b>2</b>), . . . , inst(n)) m times (m is a positive integer), the program is encoded as follows.</p><p>RS\u2190START;</p><p>RE\u2190END;</p><p>RC\u2190m;</p><p>RPT;</p><p>START: inst(<b>1</b>);</p><p>inst(<b>2</b>);</p><p>.</p><p>.</p><p>.</p><p>END: inst(n);</p><p>Here \u201cRS\u2190START\u201d denotes an instruction to load the address (START) of the leading one (inst(<b>1</b>)) of a series of instructions to be executed reiteratively into the repeat start address register <b>931</b> (RS). \u201cRS\u2190END\u201d denotes an instruction to load the address (END) of the trailing one (inst(n)) of a series of instructions to be executed reiteratively into the repeat end address register <b>932</b> (RE). \u201cRC\u2190m\u201d denotes an instruction to load the required number (m) of repeats of execution into the repeat count register <b>933</b> (RC). \u201cRPT\u201d is an instruction to generate an internal state for reiterative execution of instructions (repeat instruction).</p><p>When the repeat instruction (RPT) is executed, the content of the repeat end address register <b>932</b> (RE) and the program counter (PC) are compared by the comparator circuit <b>935</b>. If they are found identical and the content of the repeat count register <b>933</b> (RC) is not 1, the repeat count register <b>933</b> (RC) is counted down by 1 by the down counter <b>936</b>, and the count of the program counter <b>960</b> is replaced by the count of the repeat start address register <b>931</b> (RS) to continue processing. If the content of the repeat end address register <b>932</b> (RE) and the program counter (PC) are found identical and the content of the repeat count register <b>933</b> (RC) not 1, the repeat state is discontinued. If it is desired to keep the count of the repeat count register <b>933</b> (RC) in the non-repeat state at 0 all the time, control to clear the count of the repeat count register <b>933</b> (RC) can be effect at this point of time. To add, RS\u2190START, RS\u2190END, RC\u2190m and RPT need not be four separate instruction codes. It is also possible to describe the aforementioned four instruction codes collectively in a single instruction code. It is also possible to integrate RC\u2190m and RPT into a repeat instruction RC\u2190m.</p><p>The data processing apparatus <b>900</b> performs control to read instructions reiteratively from the small scale buffer <b>904</b> during reiterative execution of instructions by a repeat instruction. However, if it is attempted to store such a large loop that the number of instructions constituting the loop exceeds the maximum number of instructions that can be accommodated by the buffer <b>904</b> into the buffer <b>904</b> as it is, proper loop processing is made impossible because instructions in the final part of the loop will be overwritten into a place where instructions are already stored.</p><p>The simplest way to avert this problem is to forbid the application of control to read instructions reiteratively from the buffer <b>904</b> to loops larger than the size of the buffer <b>904</b>. In the data processing apparatus <b>900</b>, this is realized in the following manner. The difference detecting circuit <b>937</b> calculates the number of instructions constituting a loop (n in the above-cited example) from the difference between the counts of the repeat start address register <b>931</b> (RS) and of the repeat end address register <b>932</b> ($#). If the number of instructions constituting the loop (n in the above-cited example) surpasses the maximum number of instructions that can be accommodated by the buffer <b>904</b>, the difference detecting circuit <b>937</b> instructs the buffer control circuit <b>938</b> to forbid access to the buffer <b>904</b>, and causes instructions to be read out of the memory <b>902</b> as usual.</p><p>Thus, this embodiment can forbid the application of control to read instructions reiteratively from the buffer <b>904</b> if the number of instructions constituting the loop surpasses the maximum number of instructions that can be accommodated by the buffer <b>904</b>.</p><p>To add, although the positional information on the leading and trailing ones of the series of instructions to be executed reiteratively in this embodiment is supposed to be the physical addresses in which they are stored, it may be expressed in some other form, such as relative addresses. Or it may be the aforementioned number of instructions (number of steps) to be executed reiteratively, which can be figured out from the positional information on the leading and trailing ones of the series of instructions to be executed reiteratively.</p><p>(Configuration of the Buffer)</p><p>FIG. 8 illustrates one example of configuration of the buffer <b>104</b> the data processing apparatus <b>100</b> is provided with. In this embodiment, the buffer <b>104</b> is composed of a memory circuit. An instruction code S<b>103</b> is supposed to be M bits wide, and the maximum number of instructions the buffer <b>104</b> can accommodate is supposed to be N. Thus instructions are stored in a memory array of N words\u00d7M bits. Each bit in the instruction code is stored into a memory cell <b>1030</b>_k_l (where k=1, 2, . . . ,N, l=1, 2, . . . , M).</p><p>A counter <b>1060</b> counts up by 1 at a time an address S<b>1062</b> given to an address decoder <b>1070</b>. When the pointer reset signal RST from the buffer control circuit<b>126</b> is activated, the counter <b>1060</b> returns the address S<b>1062</b> to the start position.</p><p>The address decoder <b>107</b> decodes the address S<b>1062</b> given by the counter <b>1060</b>, and selects a matching one of word lines WL_k (k=1, 2, . . . , N).</p><p>During a writing action, instruction codes S<b>103</b>_l (l=1, 2, . . . , M) are written into memory cells selected by the word lines via drain-source routes of transistors <b>1020</b>_l (l=1, 2, . . . , M).</p><p>During a reading action, small amplitude complementary signals emerging on bit line pairs (BL_<b>1</b>, BLB_<b>1</b>, . . . , BL_M, BLB_M) from memory cells selected by word lines are taken out as output signals S<b>104</b>_l (l=1, 2, . . . , M) by amplifying circuits <b>1040</b>_<b>1</b> (l=1, 2, . . . , M).</p><p>One example of configuration of the memory cell <b>1030</b>_k_l (where k=1, 2, . . . , N, l=1, 2, . . . , M) is illustrated in FIG. <b>9</b>. The memory cell <b>1030</b>_k_l (where k=1, 2, . . .,N, l=1, 2, . . . , M) is composed of a so-called 6 MOS transistor SRAM. Transistors <b>1105</b> and <b>1106</b> are P channel type MOS transistors (P channel type MOSFETs). Transistors <b>1101</b>, <b>1102</b>, <b>1103</b> and <b>1104</b> are N channel MOS transistors (N channel type MOSFETs). \u201cVVD\u201d denotes the source voltage, and \u201cGND\u201d the grounding voltage.</p><p>The buffer configuration of this embodiment is applicable not only to the data processing apparatus <b>100</b> but also to the data processing apparatuses <b>700</b> and <b>900</b>.</p><p>The composition of the buffer <b>104</b> of a memory circuit has the advantage over the composition using a register that, especially where the number of instructions to be stored in the buffer is relatively large, that the area occupied by the buffer can be reduced, because, where the buffer is composed of a memory circuit, minute signals would suffice as the signals to be read out of the memory cells <b>1030</b>_k_l (where k=1, 2, . . . ,N, l=1, 2, . . . , M) to the bit line pairs (BL_<b>1</b>, BLB_<b>1</b>, . . . , BL_M, BLB_M), so that the memory cells' own current drive power need not be large and accordingly the dimensions of elements to constitute the memory cells can be reduced.</p><h4>Embodiment 4</h4><p>In a high speed microprocessor, instruction queues (instruction pre-reading buffers) for temporarily holding a plurality of instructions until the instructions taken out of a memory (e.g. a cache memory) are delivered to an instruction decoder is provided in the control section. As instructions are delivered from the instruction queues to the instruction decoder, further instructions are taken into the instruction queues from the memory to minimize vacancy if any. It was studied if these instruction queues could be let function a s the buffer <b>104</b> of the data processing apparatus <b>100</b>. An embodiment of the result will be described below.</p><p>FIG. 11 illustrates the configuration of a data processing apparatus representing a fourth embodiment of the present invention. A data processing apparatus <b>1400</b> consists of a data processing section comprising a control section <b>1420</b>, a program counter <b>1460</b> and the like, and of a memory <b>1402</b>. The data processing apparatus <b>1400</b> may either be formed over a single semiconductor substrate or only the aforementioned data processing section may be formed over a single semiconductor substrate. The control section <b>1420</b> consists of an instruction decoder <b>1422</b>, instruction queues <b>1421</b> (TQ<b>0</b>\u02dc<b>7</b>), a pointer <b>1424</b>, an instruction queue control circuit <b>1426</b>, a control register <b>1429</b> and the like.</p><p>The memory <b>1402</b> is, for example, either a read only memory (ROM) or random access memory (RAM) as a main storage or a cache memory for holding some of the instructions to be stored into the main storage. The ROM may consist of, for instance, either a mask ROM programmed in a semiconductor manufacturing process or an electrically rewritable non-volatile memory such as a flash memory. The RAM may consist of, for instance, a static random access memory (SRAM), a dynamic random access memory (DRAM), or a ferroelectric memory (an electrically rewritable nonvolatile whose write cycle and read cycle are substantially equal).</p><p>Incidentally, the output S<b>1462</b> of the program counter <b>1460</b> may be supplied to the memory <b>1402</b> via an address bus.</p><p>The instruction queues (IQ<b>0</b>\u02dc<b>7</b>) function as conventional queues when reiterative instruction reading is not performed.</p><p>To describe the operation of the data processing apparatus <b>1400</b>, the program description used for describing the operation of the data processing apparatus <b>100</b> is presented here again.</p><p>gr<b>0</b>\u2190m;</p><p>set BCF;</p><p>LOOP: inst(<b>1</b>);</p><p>inst(<b>2</b>);</p><p>.</p><p>.</p><p>.</p><p>inst(n);</p><p>gr<b>0</b>\u2190gr<b>0</b>\u22121;</p><p>if NZ goto LOOP;</p><p>The data processing apparatus <b>1400</b> is caused to effect control in accordance with the following rules.</p><p>(i) The buffer control flag <b>1428</b> (BCF) is referred to, and (ii) will be followed if it is set, or (viii) will be followed if it is not set (S<b>151</b>).</p><p>(ii) The instruction the pointer <b>1424</b> points to is decoded. (iii) will be followed (S<b>152</b>).</p><p>(iii) If the decoded instruction is not a conditional branching instruction (if NZ goto LOOP in the above-cited example), (iv) will be followed, or if it is a conditional branching instruction, (v) will be followed (S<b>153</b>).</p><p>(iv) An instruction is issued, and the pointer <b>1424</b> is incremented (S<b>154</b>). (ix) will be followed.</p><p>(v) If the branching condition is satisfied, (vi) will be followed, or if not, (vii) will be followed (S<b>155</b>).</p><p>(vi) A branching instruction is issued, and the pointer <b>1424</b> is initialized to IQ<b>0</b> (S<b>156</b>). (ix) will be followed.</p><p>(vii) All the instructions from IQ<b>0</b> to that the pointer <b>1424</b> pointed to are shifted out of the instruction queues <b>1421</b>, the pointer <b>1424</b> is initialized, and the buffer control flag <b>1428</b> (BCF) is cleared (S<b>157</b>). (ix) will be followed.</p><p>(viii) The instruction the pointer <b>1424</b> points to is decoded and issued. The issued instruction is shifted out of the instruction queues <b>1421</b> (S<b>158</b>). (ix) will be followed.</p><p>(ix) A shift to the next decode cycle takes place (S<b>159</b>)</p><p>Thus, by this embodiment, without using a repeat instruction, instructions are read out of the instruction queues (IQ<b>0</b>\u02dc<b>7</b>) reiteratively when processing a loop. In that while, since the instruction queues (IQ<b>0</b>\u02dc<b>7</b>) are filled with instructions, no instruction is read out of the memory <b>1402</b>, making it possible to save the power consumed in memory accessing.</p><p>Further, in this embodiment, unless the buffer control flag <b>1428</b> (BCF) is set, the instruction queues (IQ<b>0</b>\u02dc<b>7</b>) are used in the conventional way in the processing of any loop. Therefore, in order to forbid the application of the control to read an instruction out of the instruction queues (IQ<b>0</b>\u02dc<b>7</b>) reiteratively in executing a certain loop, it is sufficient merely to refrain from inserting an instruction (set BCF) to set the buffer control flag <b>1428</b> (BCF) immediately before the execution of the loop (immediately before inst(<b>1</b>)) in the above-cited example).</p><p>If the mode of this embodiment is applied to a microprocessor already equipped with instruction queues, there will be no need to add a buffer <b>105</b> as in Embodiment 1, resulting in the benefit of enabling the occupied area to be saved.</p><h4>Embodiment 5</h4><p>FIG. 13 illustrates the configuration of a data processing apparatus representing a fifth embodiment of the present invention. A data processing apparatus <b>1600</b> consists of a data processing section comprising a control section <b>1620</b>, an instruction executing section <b>1640</b>, a program counter <b>1660</b> and the like, and of a memory <b>1602</b>. The data processing apparatus <b>1600</b> may either be formed over a single semiconductor substrate or only the aforementioned data processing section may be formed over a single semiconductor substrate. The control section <b>1620</b> consists of an instruction decoder <b>1622</b>, instruction queues <b>1621</b> (IQ<b>0</b>\u02dc<b>7</b>), an instruction queue control circuit <b>1626</b>, a control register <b>1629</b> and the like.</p><p>The memory <b>1602</b> is, for example, either a read only memory (ROM) or random access memory (RAM) as a main storage or a cache memory for holding some of the instructions to be stored into the main storage. The ROM may consist of, for instance, either a mask ROM programmed in a semiconductor manufacturing process or an electrically rewritable non-volatile memory such as a flash memory. The RAM may consist of, for instance, a static random access memory (SRAM), a dynamic random access memory (DRAM), or a ferroelectric memory (an electrically rewritable non-volatile whose write cycle and read cycle are substantially equal).</p><p>Incidentally, the output S<b>1662</b> of the program counter <b>1660</b> may be supplied to the memory <b>1602</b> via an address bus.</p><p>The data processing apparatus <b>1600</b>, like the data processing apparatus <b>1400</b>, utilizes instruction queues (IQ<b>0</b>\u02dc<b>7</b>). However, it uses execution flags (E<b>0</b>\u02dc<b>7</b>) accompanying the instruction queues (IQ<b>0</b>\u02dc<b>7</b>) in place of the pointer <b>1424</b> in the data processing apparatus <b>1400</b>.</p><p>The data processing apparatus <b>1600</b> is caused to effect control in accordance with the following rules.</p><p>(i) The buffer control flag <b>1628</b> (BCF) is referred to, and (ii) will be followed if it is set, or (viii) will be followed if it is not set (S<b>171</b>).</p><p>(ii) An instruction whose execution flag (E flag: E<b>0</b>\u02dc<b>7</b>) is cleared is decoded (S<b>172</b>). (iii) will be followed.</p><p>(iii) If the decoded instruction is not a conditional branching instruction (if NZ goto LOOP in the above-cited example), (iv) will be followed, or if it is a conditional branching instruction, (v) will be followed (S<b>173</b>).</p><p>(iv) An instruction is issued, and the matching execution flag (E<b>0</b>\u02dc<b>7</b>) is set (S<b>174</b>). (ix) will be followed.</p><p>(v) If the branching condition is satisfied, (vi) will be followed, or if not, (vii) will be followed (S<b>175</b>).</p><p>(vi) A branching instruction is issued, and all the execution flags (E<b>0</b>\u02dc<b>7</b>) are cleared (S<b>176</b>). (ix) will be followed.</p><p>(vii) All the instructions for which execution flags (E<b>0</b>\u02dc<b>7</b>) are set are shifted out of the instruction queues (IQ<b>0</b>\u02dc<b>7</b>), and the buffer control flag <b>1628</b> (BCF) is cleared (S<b>177</b>). (ix) will be followed.</p><p>(viii) An instruction is decoded and issued. The issued instruction is shifted out of the instruction queues (IQ<b>0</b>\u02dc<b>7</b>) (S<b>178</b>). (ix) will be followed.</p><p>(ix) A shift to the next decode cycle takes place (S<b>179</b>).</p><p>Thus, by this embodiment, without using a repeat instruction, instructions are read out of the instruction queues (IQ<b>0</b>\u02dc<b>7</b>) reiteratively when processing a loop. In that while, since the instruction queues (IQ<b>0</b>\u02dc<b>7</b>) are filled with instructions, no instruction is read out of the memory <b>1602</b>, making it possible to save the power consumed in memory accessing.</p><p>Further, in this embodiment, unless the buffer control flag <b>1628</b> (BCF) is set, the instruction queues (IQ<b>0</b>\u02dc<b>7</b>) are used in the conventional way in the processing of any loop. Therefore, in order to forbid the application of the control to read an instruction out of the instruction queues (IQ<b>0</b>\u02dc<b>7</b>) reiteratively in executing a certain loop, it is sufficient merely to refrain from inserting an instruction (set BCF) to set the buffer control flag <b>1628</b> (BCF) immediately before the execution of the loop (immediately before inst(<b>1</b>)) in the above-cited example).</p><p>If the mode of this embodiment is applied to a microprocessor already equipped with instruction queues, there will be no need to add a buffer <b>105</b> as in Embodiment 1, resulting in the benefit of enabling the occupied area to be saved. Moreover, as it is possible with this embodiment, when executing instructions reiteratively using the instruction queues (IQ<b>0</b>\u02dc<b>7</b>), it is possible to alter the sequence of instructions in the loop and issue executable instructions before others, there is another benefit that loop processing can be made faster than with Embodiment 4.</p><p>The modes of carrying out the present invention can be classified as shown in FIG. <b>15</b>. The following three alternatives can be cited as means to determine whether or not to use a buffer for reading instructions reiteratively in processing a certain loop.</p><p>(1) Introduction of a control flag. For instance, the buffer control flag <b>124</b> (BCF) of Embodiment 1.</p><p>(2) Loading of the number of loop repetitions into a loop count register. For instance, the loop count register <b>742</b> (LC) of Embodiment 2.</p><p>(3) Checking the difference between the leading and trailing address register counts in repetition. For instance, the repeat start address register <b>931</b> (RS), repeat end address register <b>932</b> (RE) and their difference detecting circuit <b>937</b> of Embodiment 3.</p><p>On the other hand, means to realize a buffer can be broadly classified into the following two.</p><p>(i) A buffer is provided separately from instruction queues. For instance, the buffer <b>104</b> of Embodiment 1 is an entirely functional block from instruction queues.</p><p>(ii) A buffer is realized by diverting instruction queues. For instance, the buffer (IQ<b>0</b>\u02dc<b>7</b>) of Embodiment 4 or 5 are also used as instruction queues.</p><p>Modes of carrying out the present invention can be realized by combining as desired (1) through (3) and (i) through (ii) (in 3\u00d72=6 sets). Therefore, besides the combinations presented as Embodiments 1, 2, 3, 4 and 5, embodiments combining (2) and (i) or (3) and (ii) above can also be realized.</p><p>The invention accomplished by the present inventor has so far been described specifically with reference to embodiments thereof, the invention is not limited to them, but it goes without saying that various modifications are possible without deviating the spirit thereof.</p><p>To describe briefly the effects that can be attained by the typical of the aspects of the invention disclosed in this application, the following can be said.</p><p>Thus, there can be provided a data processing apparatus provided with a control means to reduce the power required for memory accessing, in spite of the unavailability of a repeat instruction, by reading instructions reiteratively from a small scale buffer in loop processing. Furthermore, there can be provided a data processing apparatus provided with a means to opt to apply, or not to apply, control to read instructions, that have to be executed reiteratively in loop processing, out of a small scale buffer reiteratively.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Mitsuru", "last_name": "Hiraki", "name": ""}, {"first_name": "Atsushi", "last_name": "Kiuchi", "name": ""}, {"first_name": "Kesami", "last_name": "Hagiwara", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "HITACHI, LTD."}, {"first_name": "", "last_name": "HITACHI, LTD.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/40"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/38        20060101A I20051008RMEP"}, {"label": "G06F   9/32        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712241"}, {"primary": false, "label": "712E09078"}, {"primary": false, "label": "712207"}, {"primary": false, "label": "712205"}, {"primary": false, "label": "712E09058"}], "ecla_classes": [{"label": "G06F   9/38B4L"}, {"label": "G06F   9/32B6"}], "cpc_classes": [{"label": "G06F   9/381"}, {"label": "G06F   9/325"}, {"label": "G06F   9/325"}, {"label": "G06F   9/381"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1997-02-17", "application_date": "1999-08-16", "family_members": [{"ucid": "WO-1998036351-A1", "titles": [{"lang": "EN", "text": "DATA PROCESSOR"}, {"lang": "FR", "text": "PROCESSEUR DE DONNEES"}]}, {"ucid": "US-7080240-B2", "titles": [{"lang": "EN", "text": "Data processing apparatus"}]}, {"ucid": "US-6505295-B1", "titles": [{"lang": "EN", "text": "Data processor"}]}, {"ucid": "US-20030074546-A1", "titles": [{"lang": "EN", "text": "Data processing apparatus"}]}]}