{"patent_number": "US-6076141-A", "publication_id": 72329117, "family_id": 26681278, "publication_date": "2000-06-13", "titles": [{"lang": "EN", "text": "Look-up switch accelerator and method of operating same"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11018816\" source=\"national office\"><p>A look-up switch accelerator which includes an associative memory for storing information associated with one or more look-up switch statements. For each look-up switch statement, this information includes a look-up switch identifier value, a plurality of match values and a corresponding plurality of jump offset values. The look-up switch accelerator also includes circuitry for determining whether a current instruction corresponds to a look-up switch statement stored in the memory, circuitry for determining whether a current match value associated with the current instruction corresponds with one of the match values stored in the memory, and circuitry for accessing a jump offset value from the memory when the current instruction corresponds to a look-up switch statement stored in the memory and the current match value corresponds with one of the match values stored in the memory (wherein the accessed jump offset value corresponds with the current match value). Also included is circuitry for retrieving match and jump offset values associated with a current look-up switch statement when the associative memory does not already contain the match and jump offset values associated with the current look-up switch statement.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA38081307\"><p>A look-up switch accelerator which includes an associative memory for storing information associated with one or more look-up switch statements. For each look-up switch statement, this information includes a look-up switch identifier value, a plurality of match values and a corresponding plurality of jump offset values. The look-up switch accelerator also includes circuitry for determining whether a current instruction corresponds to a look-up switch statement stored in the memory, circuitry for determining whether a current match value associated with the current instruction corresponds with one of the match values stored in the memory, and circuitry for accessing a jump offset value from the memory when the current instruction corresponds to a look-up switch statement stored in the memory and the current match value corresponds with one of the match values stored in the memory (wherein the accessed jump offset value corresponds with the current match value). Also included is circuitry for retrieving match and jump offset values associated with a current look-up switch statement when the associative memory does not already contain the match and jump offset values associated with the current look-up switch statement.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. A lookup switch accelerator comprising:<claim-text>an instruction bus;</claim-text><claim-text>an execution unit coupled to said instruction bus wherein said execution unit receives a stream of instructions comprising one or more lookup switch statements, each of said one or more lookup switch statements having a lookup switch identifier value and a current match value;</claim-text><claim-text>another bus wherein said another bus carries a lookup switch identifier value for a lookup switch statement on said instruction bus;</claim-text><claim-text>a jump offset value output bus coupled to said execution unit;</claim-text><claim-text>a memory circuit comprising:<claim-text>a first memory panel wherein said first memory panel is for storing information corresponding to a first lookup switch statement, including a first lookup switch identifier value, a plurality of first match values, and a plurality of corresponding first jump offset values;</claim-text><claim-text>a first input circuit coupled to an operand bus carrying a current match value for said lookup switch statement on said instruction bus, and coupled to said first memory panel to access said plurality of first match values<claim-text>wherein the first input circuit detects whether a match exists between the current match value on said operand bus and any one of the plurality of first match values; and</claim-text></claim-text><claim-text>a first output circuit coupled to said first memory panel to have access to the first plurality of corresponding jump offset values stored in the first memory panel, and selectively coupled to said jump offset value output bus;</claim-text></claim-text><claim-text>a comparator coupled to said another bus to receive said lookup switch identifier value and coupled to said first memory panel to receive the stored first lookup switch identifier value, wherein the comparator detects whether a match exists between the lookup switch identifier value on said another bus and the stored first lookup switch identifier value;</claim-text><claim-text>wherein the first output circuit is coupled to said jump offset value output bus to supply a first jump offset value from the first memory panel when the comparator detects a match and the first input circuit detects a match, wherein the first jump offset value corresponds to the current match value.</claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. The look-up switch accelerator of claim 1, wherein the first memory panel is a content addressable memory.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. The look-up switch accelerator of claim 1, wherein the first output circuit is coupled to access a first default jump offset value when the comparator detects a match and the first input circuit does not detect a match.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. The lookup switch accelerator of claim 1 wherein said memory circuit further comprises:<claim-text>a second memory panel wherein said second memory panel is for storing information corresponding to a second lookup switch statement, including a second lookup switch identifier value, a plurality of second match values and a plurality of corresponding second jump offset values, wherein the comparator is further coupled to receive the second lookup switch identifier value, the comparator detecting whether a match exists between the lookup switch identifier value and the second lookup switch identifier value;</claim-text><claim-text>a second input circuit coupled to said operant bus to receive the current match value, and to said second memory panel to access the plurality of second match values, wherein the second input circuit detects whether a match exists between the current match value and any one of the plurality of second match values; and</claim-text><claim-text>a second output circuit coupled to said second memory panel to have access to the second plurality of second jump offset values, and selectively coupled to said jump offset value output bus, wherein the second output circuit is coupled to said jump offset value output bus to supply a second jump offset value from the second memory panel when the comparator detects a match between the lookup switch identifier value and the second lookup switch identifier value, and the second input circuit detects a match, wherein the second jump offset value corresponds to the current match value.</claim-text></claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. The look-up switch accelerator of claim 4, wherein the first and second memory panels are content addressable memories.</claim-text></claim>"}, {"num": 6, "parent": 4, "type": "dependent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. The lookup switch accelerator of claim 4, wherein the first output circuit is coupled to access a first default jump offset value when the comparator detects a match between the lookup switch identifier value and the first lookup switch identifier value, and the first input circuit does not detect a match, and wherein the second output circuit is coupled to access a second default jump offset value when the comparator detects a match between the lookup switch identifier value and the second lookup switch identifier value, and the second input circuit does not detect a match.</claim-text></claim>"}, {"num": 7, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. A lookup switch accelerator comprising:<claim-text>a memory for storing information associated with a lookup switch statement, the information comprising a lookup switch identifier value, a plurality of match values and a corresponding plurality of jump offset values;</claim-text><claim-text>hardware means for determining whether a current instruction corresponds to the lookup switch statement stored in the memory;</claim-text><claim-text>hardware means for determining whether a current match value corresponds with any one of the match values stored in the memory; and</claim-text><claim-text>hardware means for accessing a jump offset value from the memory when the current instruction corresponds to the lookup switch statement stored in the memory and the current match value corresponds with any one of the match values stored in the memory, wherein the accessed jump offset value corresponds with the current match value.</claim-text></claim-text></claim>"}, {"num": 8, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. A method of implementing a lookup switch statement, the method comprising:<claim-text>storing information associated with a lookup switch statement in a memory, the information comprising a lookup switch identifier value, a plurality of match values and a corresponding plurality of jump offset values;</claim-text><claim-text>comparing a lookup switch identifier value of a current instruction, which is on an instruction bus, with said stored lookup switch identifier value to determine whether said current instruction corresponds to the lookup switch statement stored in the memory;</claim-text><claim-text>comparing a current match value on an operand bus to determine whether said current match value corresponds with any one of the match values stored in the memory; and</claim-text><claim-text>accessing a jump offset value from the memory when the current instruction corresponds to the lookup switch statement stored in the memory and the current match value corresponds with any one of the match values stored in the memory, wherein the accessed jump offset value corresponds with the current match value.</claim-text></claim-text></claim>"}, {"num": 9, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. A system of accelerating a lookup switch statement, the system comprising:<claim-text>a processor coupled to an instruction bus to receive a stream of instructions, the instructions comprising one or more lookup switch statements, each lookup switch statement having a corresponding lookup switch identifier value;</claim-text><claim-text>a plurality of memory panels, wherein each memory panel is configured to store information associated with a corresponding lookup switch statement, the information comprising a lookup switch identifier value, a plurality of match values, and a plurality of corresponding jump offset values;</claim-text><claim-text>a comparator coupled to another bus to receive a current lookup switch identifier for a current lookup switch statement on said instruction bus and coupled to said plurality of memory panels to receive the lookup switch identifier value stored in said each memory panel, wherein said comparator detects whether a match exists between said current lookup switch identifier value and any one of said lookup switch identifier values stored in the plurality of memory panels; and</claim-text><claim-text>means for accessing information associated with the current lookup switch statement when the comparator detects that no match exists, wherein the means for accessing provides the information associated with the current lookup switch statement and instructs the processor to load the information into a selected one of the memory panels.</claim-text></claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. The system of claim 9, wherein the means for accessing is implemented in software code or microcode.</claim-text></claim>"}, {"num": 11, "parent": 9, "type": "dependent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. The system of claim 9, wherein the processor loads the information into the selected one of the memory panels in accordance with a least recently used algorithm.</claim-text></claim>"}, {"num": 12, "parent": 9, "type": "dependent", "paragraph_markup": "<claim num=\"12\"><claim-text>12. The system of claim 9, wherein the processor loads the information into the selected one of the memory panels in accordance with a first in, first out algorithm.</claim-text></claim>"}, {"num": 13, "parent": 9, "type": "dependent", "paragraph_markup": "<claim num=\"13\"><claim-text>13. The system of claim 9, wherein the processor loads the information into the selected one of the memory panels in a random manner.</claim-text></claim>"}, {"num": 14, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"14\"><claim-text>14. A method of executing a plurality of lookup switch statements, the method comprising:<claim-text>storing a plurality of lookup switch statements in an associative memory;</claim-text><claim-text>determining whether a current instruction corresponds with one of the lookup switch statements stored in the associative memory; and</claim-text><claim-text>retrieving information stored in the associative memory to execute the current lookup switch statement if the current lookup switch statement corresponds with one of the lookup switch statements stored in the associative memory.</claim-text></claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim num=\"15\"><claim-text>15. The method of claim 14, further comprising: if the current lookup switch statement does not correspond with one of the lookup switch statements stored in the associative memory, retrieving information associated with the current lookup switch statement, storing the information associated with the current lookup switch statement in the associative memory, and then retrieving the information associated with the current lookup switch statement from the associative memory to execute the current lookup switch statement.</claim-text></claim>"}, {"num": 16, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"16\"><claim-text>16. A system for executing a plurality of look-up switch statements, the system comprising:<claim-text>an associative memory for storing a plurality of look-up switch statements;</claim-text><claim-text>means for determining whether a current instruction corresponds with one of the look-up switch statements stored in the associative memory; and</claim-text><claim-text>means for retrieving information stored in the associative memory to execute the current look-up switch statement if the current look-up switch statement corresponds with one of the look-up switch statements stored in the associative memory.</claim-text></claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim num=\"17\"><claim-text>17. The system of claim 16, further comprising:<claim-text>means for retrieving information associated with the current look-up switch statement if the current look-up switch statement does not correspond with one of the look-up switch statements stored in the associative memory;</claim-text><claim-text>means for storing the retrieved information associated with the current look-up switch statement in the associative memory; and</claim-text><claim-text>means for retrieving the information retrieved associated with the current look-up switch statement from the associative memory to execute the current look-up switch statement.</claim-text></claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES318027519\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><h4>RELATED APPLICATIONS</h4><p>This application claims the benefit of U.S. Provisional Application No. 60/010,527, filed Jan. 24, 1996, entitled \"Methods and Apparatuses for Implementing the JAVA Virtual Machine\" (JAVA is a trademark of Sun Microsystems, Inc.) and naming Marc Tremblay, James Michael O'Connor, Robert Garner, and William N. Joy as inventors, and is a continuation-in-part application of U.S. application Ser. No. 08/641,760, filed May 2, 1996, now abandoned, entitled \"Methods and Apparatuses for Implementing a Look-up Switch Function\" and naming Marc Tremblay and James Michael O'Connor as inventors that also claimed the benefit of U.S. Provisional Application No. 60/010,527, filed Jan. 24, 1996, entitled \"Methods and Apparatuses for Implementing the JAVA Virtual Machine\" and naming Marc Tremblay, James Michael O'Connor, Robert Garner, and William N. Joy as inventors.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>REFERENCE TO APPENDIX I</h4><p>A portion of the disclosure of this patent document including Appendix I, The JAVA Virtual Machine Specification and Appendix A thereto, contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the U.S. Patent and Trademark Office patent files or records, but otherwise reserves all copyright rights whatsoever.</p><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates generally to computer systems and, in particular, to physical implementations of look-up switch statements in a computer system.</p><p>2. Discussion of Related Art</p><p>Many individuals and organizations in the computer and communications industries tout the Internet as the fastest growing market on the planet. In the 1990s, the number of users of the Internet appears to be growing exponentially with no end in sight. In June of 1995, an estimated 6,642,000 hosts were connected to the Internet; this represented an increase from an estimated 4,852,000 hosts in January, 1995. The number of hosts appears to be growing at around 75% per year. Among the hosts, there were approximately 120,000 networks and over 27,000 web servers. The number of web servers appears to be approximately doubling every 53 days.</p><p>In July 1995, with over 1,000,000 active Internet users, over 12,505 usenet news groups, and over 10,000,000 usenet readers, the Internet appears to be destined to explode into a very large market for a wide variety of information and multimedia services.</p><p>In addition, to the public carrier network or Internet, many corporations and other businesses are shifting their internal information systems onto an intranet as a way of more effectively sharing information within a corporate or private network. The basic infrastructure for an intranet is an internal network connecting servers and desktops, which may or may not be connected to the Internet through a firewall. These intranets provide services to desktops via standard open network protocols which are well established in the industry. Intranets provide many benefits to the enterprises which employ them, such as simplified internal information management and improved internal communication using the browser paradigm. Integrating Internet technologies with a company's enterprise infrastructure and legacy systems also leverages existing technology investment for the party employing an intranet. As discussed above, intranets and the Internet are closely related, with intranets being used for internal and secure communications within the business and the Internet being used for external transactions between the business and the outside world. For the purposes of this document, the term \"networks\" includes both the Internet and intranets. However, the distinction between the Internet and an intranet should be born in mind where applicable.</p><p>In 1990, programmers at Sun Microsystems wrote a universal programming language. This language was eventually named the JAVA programming language. (JAVA is a trademark of Sun Microsystems of Mountain View, Calif.) The JAVA programming language resulted from programming efforts which initially were intended to be coded in the C++ programming language; therefore, the JAVA programming language has many commonalties with the C++ programming language. However, the JAVA programming language is a simple, object-oriented, distributed, interpreted yet high performance, robust yet safe, secure, dynamic, architecture neutral, portable, and multi-threaded language.</p><p>The JAVA programming language has emerged as the programming language of choice for the Internet as many large hardware and software companies have licensed it from Sun Microsystems. The JAVA programming language and environment is designed to solve a number of problems in modern programming practice. The JAVA programming language omits many rarely used, poorly understood, and confusing features of the C++ programming language. These omitted features primarily consist of operator overloading, multiple inheritance, and extensive automatic coercions. The JAVA programming language includes automatic garbage collection that simplifies the task of programming because it is no longer necessary to allocate and free memory as in the C programming language. The JAVA programming language restricts the use of pointers as defined in the C programming language, and instead has true arrays in which array bounds are explicitly checked, thereby eliminating vulnerability to many viruses and nasty bugs. The JAVA programming language includes objective-C interfaces and specific exception handlers.</p><p>The JAVA programming language has an extensive library of routines for coping easily with TCP/IP protocol (Transmission Control Protocol based on Internet protocol), HTTP (Hypertext Transfer Protocol) and FTP (File Transfer Protocol). The JAVA programming language is intended to be used in networked/distributed environments. The JAVA programming language enabled the construction of virus-free, tamper-free systems. The authentication techniques are based on public-key encryption.</p><p>Many computer systems, including those implementing the JAVA programming language, include look-up switch statements (which are used for jump tables) within their instruction sets. Table 1 provides a high level outline of a look-up switch statement, SWITCH (SHAPE).</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->              TABLE 1                                                     \n______________________________________                                    \nSWITCH (SHAPE)                                                            \n RECTANGLE:            BEGIN                                              \n                       .                                                  \n                       .                                                  \n                       END                                                \n CIRCLE:               BEGIN                                              \n                       .                                                  \n                       .                                                  \n                       END                                                \n TRIANGLE:             BEGIN                                              \n                       .                                                  \n                       .                                                  \n                       END                                                \n DEFAULT:              BEGIN                                              \n                       .                                                  \n                       .                                                  \n                       END                                                \n______________________________________                                    \n</pre><p>In the look-up switch statement of Table 1, the variable SHAPE is iteratively compared with the match values RECTANGLE, CIRCLE and TRIANGLE. If a match exists between the variable SHAPE and one of the match values, then code associated with the match value causing the match is accessed. If a match does not exist between the variable SHAPE and any of the match values, the code associated with a default value, DEFAULT is accessed. The code associated with the match values is represented by the BEGIN . . . END statements in Table 1. When analyzed at a lower level, a look-up switch statement has a corresponding program counter value which uniquely identifies the look-up switch statement. A look-up switch statement also has an associated variable, MATCH (e.g., SHAPE in Table 1). As described in more detail below, the value of the variable MATCH is used to determine the next instruction to be implemented.</p><p>Also associated with the look-up switch statement are one or more constant values, MATCH<sub>--</sub> 1, MATCH<sub>--</sub> 2 . . . MATCH<sub>--</sub> N (e.g., RECTANGLE, CIRCLE, TRIANGLE in Table 1). Each of these constant values has a corresponding jump offset value, JUMP<sub>--</sub> OFFSET<sub>--</sub> 1, JUMP<sub>--</sub> OFFSET<sub>--</sub> 2 . . . JUMP<sub>--</sub> OFFSET<sub>--</sub> N. The variable MATCH is iteratively compared with each of the constant values MATCH<sub>--</sub> 1, MATCH<sub>--</sub> 2 . . . MATCH<sub>--</sub> N. If an equality is detected between the variable MATCH and one of the constant values (e.g., MATCH<sub>--</sub> 2), the corresponding jump offset value (e.g., JUMP<sub>--</sub> OFFSET<sub>--</sub> 2) is added to the program counter value, thereby causing processing to continue with the instruction identified by the new program counter value. If an equality is not detected, then a default jump offset value is added to the program counter value.</p><p>The step-by-step comparisons required by conventional look-up switch statements can require hundreds of cycles, and therefore consume valuable time until the appropriate jump offset value is retrieved and instruction execution resumes. It would therefore be desirable to have a method and apparatus for accelerating the execution of a look-up switch statement.</p><h4>SUMMARY</h4><p>Accordingly, the present invention provides a look-up switch accelerator which executes one or more look-up switch statements using an associative memory. In one embodiment, the look-up switch accelerator includes a processor, an associative memory panel, a comparator, an input circuit and an output circuit. The processor is coupled to receive a stream of instructions which includes one or more look-up switch statements. Each of the look-up switch statements has a corresponding look-up switch identifier value (e.g., a program counter value) and an associated current match value.</p><p>The associative memory panel stores information corresponding to a first look-up switch statement, including a first look-up switch identifier value, a plurality of first match values and a plurality of corresponding first jump offset values. In one embodiment, the associative memory panel is a content addressable memory.</p><p>The comparator is coupled to receive the look-up switch identifier value received by the processor and the first look-up switch identifier value. The comparator determines whether there is a match between these values. Such a match indicates that the first match values and the first jump offset values stored in the associative memory panel correspond to the current look-up switch statement. In one embodiment, the comparator is implemented within the processor.</p><p>The input circuit is coupled to have access to the current match value and the plurality of first match values stored in the associative memory panel. The input circuit detects whether a match exists between the current match value and one of the first match values.</p><p>The output circuit is coupled to have access to the first jump offset values stored in the associative memory panel. The output circuit accesses a first jump offset value from the first memory panel when both the comparator and the input circuit detect matches. The accessed first jump offset value corresponds to the current match value. The output circuit can further be coupled to access a default jump offset value when the comparator detects a match and the input circuit does not detect a match. A plurality of associative memory panels can be provided to implement a corresponding plurality of look-up switch statements.</p><p>The associative memory panels advantageously enable the jump offset values to be accessed without the iterative comparisons required by conventional structures for implementing look-up switch statements.</p><p>In another embodiment, the look-up switch accelerator includes an associative memory for storing information associated with a look-up switch statement, including a look-up switch identifier value, a plurality of match values and a corresponding plurality of jump offset values. The look-up switch accelerator also includes circuitry for determining whether the current instruction corresponds to the look-up switch statement stored in the memory, circuitry for determining whether the current match value corresponds with any one of the match values stored in the memory, and circuitry for accessing a jump offset value from the memory when the current instruction corresponds to the look-up switch statement stored in the memory and the current match value corresponds with any one of the match values stored in the memory (wherein the accessed jump offset value corresponds with the current match value).</p><p>The present invention also includes a method for implementing a look-up switch statement which includes the steps of: (1) storing information associated with the look-up switch statement in a memory, wherein the information includes a look-up switch identifier value, a plurality of match values and a corresponding plurality of jump offset values, (2) determining whether a current instruction corresponds to the look-up switch statement stored in the memory, (3) determining whether a current match value associated with the current instruction corresponds with any one of the match values stored in the memory, and (4) accessing a jump offset value from the memory when the current instruction corresponds to the look-up switch statement stored in the memory and the current match value corresponds with one of the match values stored in the memory, wherein the accessed jump offset value corresponds with the current match value.</p><p>Yet another embodiment includes a system for accelerating a look-up switch statement which includes a processor, a plurality of memory panels and a comparator. The processor is coupled to receive a stream of instructions which include one or more look-up switch statements, each having a corresponding look-up switch identifier value. Each memory panel is configured to store information associated with a corresponding look-up switch statement, including a look-up switch identifier value, a plurality of match values and a plurality of corresponding jump offset values. The comparator detects whether a match exists between the current look-up switch identifier value received by the processor and the look-up switch identifier values stored in the memory panels. Software is provided for accessing information associated with the current look-up switch statement when the comparator detects that no match exists. This software retrieves the information associated with the current look-up switch statement and instructs the processor to load this information into a selected one of the memory panels.</p><p>The present invention also includes a method of accelerating the execution of a plurality of look-up switch statements which are encountered at various locations in an instruction stream. The look-up switch statements to be accelerated can be determined by a compiler or by hardware. This method includes the steps of (1) storing a plurality of look-up switch statements in an associative memory, (2) determining whether a current instruction corresponds with one of the look-up switch statements stored in the associative memory, and (3) retrieving information stored in the associative memory to execute the current look-up switch statement if the current look-up switch statement corresponds with one of the look-up switch statements stored in the associative memory. If the current look-up switch statement does not correspond with one of the look-up switch statements stored in the associative memory, then the following steps can be performed: retrieving information associated with the current look-up switch statement, storing the information associated with the current look-up switch statement in the associative memory, and then retrieving the information associated with the current look-up switch statement from the associative memory to execute the current look-up switch statement.</p><p>In machines which execute multiple instructions per cycle, such as machines of the superscaler or VLIW type, two or more look-up switch statements can be accelerated in parallel.</p><p>The present invention further includes a system for executing a plurality of look-up switch statements which includes an associative memory for storing a plurality of look-up switch statements, circuitry for determining whether a current instruction corresponds with one of the look-up switch statements stored in the associative memory, and circuitry for retrieving information stored in the associative memory to execute the current look-up switch statement if the current look-up switch statement corresponds with one of the look-up switch statements stored in the associative memory.</p><p>The present invention will be more fully understood in light of the following detailed description taken together with the drawings.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 is a block diagram of one embodiment of virtual machine hardware processor that utilizes the look-up switch accelerator of this invention.</p><p>FIG. 2 is an process flow diagram for generation of virtual machine instructions that are used in one embodiment of this invention.</p><p>FIG. 3 illustrates an instruction pipeline implemented in the hardware processor of FIG. 1.</p><p>FIG. 4A is an illustration of the one embodiment of the logical organization of a stack structure where each method frame includes a local variable storage area, an environment storage area, and an operand stack utilized by the hardware processor of FIG. 1.</p><p>FIG. 4B is an illustration of an alternative embodiment the logical organization of a stack structure where each method frame includes a local variable storage area and an operand stack on the stack, and an environment storage area for the method frame is included on a separate execution environment stack.</p><p>FIG. 4C is an illustration of an alternative embodiment of the stack management unit for the stack and execution environment stack of FIG. 4B.</p><p>FIG. 4D is an illustration of one embodiment of the local variables look-aside cache in the stack management unit of FIG. 1.</p><p>FIG. 5 illustrates several possible add-ons to the hardware processor of FIG. 1.</p><p>FIG. 6 is a block diagram of a look-up switch instruction accelerator which is implemented in the hardware processor of FIG. 1 in accordance with one embodiment of the present invention.</p><p>FIG. 7 is a schematic diagram of exemplary program counter values, instructions, and top stack entries which are provided to the look-up switch accelerator of FIG. 6 in accordance with one embodiment of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>These and other features and advantages of the present invention will be apparent from the Figures as explained in the Detailed Description of the Invention. Like or similar features are designated by the same reference numeral(s) throughout the drawings and the Detailed Description of the Invention.</p><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>In accordance with one embodiment of the present invention, a look-up switch instruction accelerator is implemented within a hardware processor which is configured to execute virtual computing machine instructions (e.g., JAVA Virtual Machine computing instructions). Such a hardware processor is described below. The description of this hardware processor is followed by a description of a look-up switch instruction accelerator which is implemented within the hardware processor. Although the look-up switch instruction accelerator is described as being implemented within a particular processor, it is understood that in other embodiments of the invention, the look-up switch instruction accelerator can be implemented within any processor which executes a look-up switch instruction.</p><p>FIG. 1 illustrates one embodiment of a virtual machine instruction hardware processor 100, hereinafter hardware processor 100, that includes look-up switch accelerator 145 in accordance with the present invention, and that directly executes virtual machine instructions that are processor architecture independent. The performance of hardware processor 100 in executing JAVA virtual machine instructions is much better than high-end CPUs, such as the Intel PENTIUM microprocessor or the Sun Microsystems ULTRASPARC processor, (ULTRASPARC is a trademark of Sun Microsystems of Mountain View, Calif., and PENTIUM is a trademark of Intel Corp. of Sunnyvale, Calif.) interpreting the same virtual machine instructions with a software JAVA interpreter. or with a JAVA just-in-time compiler; is low cost; and exhibits low power consumption. As a result, hardware processor 100 is well suited for portable applications. Hardware processor 100 provides similar advantages for other virtual machine stack-based architectures as well as for virtual machines utilizing features such as garbage collection, thread synchronization, etc.</p><p>In view of these characteristics, a system based on hardware processor 100 presents attractive price for performance characteristics, if not the best overall performance, as compared with alternative virtual machine execution environments including software interpreters and just-in-time compilers. Nonetheless, the present invention is not limited to virtual machine hardware processor embodiments, and encompasses any suitable stack-based, or non-stack-based machine implementations, including implementations emulating the JAVA virtual machine as a software interpreter, compiling JAVA virtual machine instructions (either in batch or just-in-time) to machine instruction native to a particular hardware processor, or providing hardware implementing the JAVA virtual machine in microcode, directly in silicon, or in some combination thereof.</p><p>Regarding price for performance characteristics, hardware processor 100 has the advantage that the 250 Kilobytes to 500 Kilobytes (Kbytes) of memory storage, e.g., read-only memory or random access memory, typically required by a software interpreter, is eliminated.</p><p>A simulation of hardware processor 100 showed that hardware processor 100 executes virtual machine instructions twenty times faster than a software interpreter running on a variety of applications on a PENTIUM processor clocked at the same clock rate as hardware processor 100, and executing the same virtual machine instructions. Another simulation of hardware processor 100 showed that hardware processor 100 executes virtual machine instructions five times faster than a just-in-time compiler running on a PENTIUM processor running at the same clock rate as hardware processor 100, and executing the same virtual machine instructions.</p><p>In environments in which the expense of the memory required for a software virtual machine instruction interpreter is prohibitive, hardware processor 100 is advantageous. These applications include, for example, an Internet chip for network appliances, a cellular telephone processor, other telecommunications integrated circuits, or other low-power, low-cost applications such as embedded processors, and portable devices.</p><p>As used herein, a virtual machine is an abstract computing machine that, like a real computing machine, has an instruction set and uses various memory areas. A virtual machine specification defines a set of processor architecture independent virtual machine instructions that are executed by a virtual machine implementation, e.g., hardware processor 100. Each virtual machine instruction defines a specific operation that is to be performed. The virtual computing machine need not understand the computer language that is used to generate virtual machine instructions or the underlying implementation of the virtual machine. Only a particular file format for virtual machine instructions needs to be understood.</p><p>In an exemplary embodiment, the virtual machine instructions are JAVA virtual machine instructions. Each JAVA virtual machine instruction includes one or more bytes that encode instruction identifying information, operands, and any other required information. Appendix I, which is incorporated herein by reference in its entirety, includes an illustrative set of the JAVA virtual machine instructions. The particular set of virtual machine instructions utilized is not an essential aspect of this invention. In view of the virtual machine instructions in Appendix I and this disclosure, those of skill in the art can modify the invention for a particular set of virtual machine instructions, or for changes to the JAVA virtual machine specification.</p><p>A JAVA compiler JAVAC, (FIG. 2) that is executing on a computer platform, converts an application 201 written in the JAVA computer language to an architecture neutral object file format encoding a compiled instruction sequence 203, according to the JAVA Virtual Machine Specification, that includes a compiled instruction set. However, for this invention, only a source of virtual machine instructions and related information is needed. The method or technique used to generate the source of virtual machine instructions and related information is not essential to this invention.</p><p>Compiled instruction sequence 203 is executable on hardware processor 100 as well as on any computer platform that implements the JAVA virtual machine using, for example, a software interpreter or just-in-time compiler. However, as described above, hardware processor 100 provides significant performance advantages over the software implementations.</p><p>In this embodiment, hardware processor 100 (FIG. 1) processes the JAVA virtual machine instructions, which include bytecodes. Hardware processor 100, as explained more completely below, executes directly most of the bytecodes. However, execution of some of the bytecodes is implemented via microcode.</p><p>One strategy for selecting virtual machine instructions that are executed directly by hardware processor 100 is described herein by way of an example. Thirty percent of the JAVA virtual machine instructions are pure hardware translations; instructions implemented in this manner include constant loading and simple stack operations. The next 50% of the virtual machine instructions are implemented mostly, but not entirely, in hardware and require some firmware assistance; these include stack based operations and array instructions. The next 10% of the JAVA virtual machine instructions are implemented in hardware, but require significant firmware support as well; these include function invocation and function return. The remaining 10% of the JAVA virtual machine instructions are not supported in hardware, but rather are supported by a firmware trap and/or microcode; these include functions such as exception handlers. Herein, firmware means microcode stored in ROM that when executed controls the operations of hardware processor 100.</p><p>In one embodiment, hardware processor 100 includes an I/O bus and memory interface unit 110, an instruction cache unit 120 including instruction cache 125, an instruction decode unit 130, a unified execution unit 140, a stack management unit 150 including stack cache 155, a data cache unit 160 including a data cache 165, and program counter and trap control logic 170. Each of these units is described more completely below.</p><p>Also, as illustrated in FIG. 1, each unit includes several elements. For clarity and to avoid distracting from the invention, the interconnections between elements within a unit are not shown in FIG. 1. However, in view of the following description, those of skill in the art will understand the interconnections and cooperation between the elements in a unit and between the various units.</p><p>The pipeline stages implemented using the units illustrated in FIG. 1 include fetch, decode, execute, and write-back stages. If desired, extra stages for memory access or exception resolution are provided in hardware processor 100.</p><p>FIG. 3 is an illustration of a four stage pipeline for execution of instructions in the exemplary embodiment of processor 100. In fetch stage 301, a virtual machine instruction is fetched and placed in instruction buffer 124 (FIG. 1). The virtual machine instruction is fetched from one of (i) a fixed size cache line from instruction cache 125 or (ii) external memory.</p><p>With regard to fetching, aside from instructions tableswitch and lookupswitch, (See Appendix I.) each virtual machine instruction is between one and five bytes long. Thus, to keep things simple, at least forty bits are required to guarantee that all of a given instruction is contained in the fetch.</p><p>Another alternative is to always fetch a predetermined number of bytes, for example, four bytes, starting with the opcode. This is sufficient for 95% of JAVA virtual machine instructions (See Appendix I). For an instruction requiring more than three bytes of operands, another cycle in the front end must be tolerated if four bytes are fetched. In this case, the instruction execution can be started with the first operands fetched even if the full set of operands is not yet available.</p><p>In decode stage 302 (FIG. 3), the virtual machine instruction at the front of instruction buffer 124 (FIG. 1) is decoded and instruction folding is performed if possible. Stack cache 155 is accessed only if needed by the virtual machine instruction. Register OPTOP, that contains a pointer OPTOP to a top of a stack 400 (FIGS. 4A and 4B), is also updated in decode stage 302 (FIG. 3).</p><p>Herein, for convenience, the value in a register and the register are assigned the same reference numeral. Further, in the following discussion, use of a register to store a pointer is illustrative only of one embodiment. Depending on the specific implementation of the invention, the pointer may be implemented using a hardware register, a hardware counter, a software counter, a software pointer, or other equivalent embodiments known to those of skill in the art. The particular implementation selected is not essential to the invention, and typically is made based on a price to performance trade-off.</p><p>In execute stage 303, the virtual machine instruction is executed for one or more cycles. Typically, in execute stage 303, an ALU in integer unit 142 (FIG. 1) is used either to do an arithmetic computation or to calculate the address of a load or a store from data cache unit (DCU) 160. If necessary, traps are prioritized and taken at the end of execute stage 303 (FIG. 3). For control flow instructions, the branch address is calculated in execute stage 303, as well as the condition upon which the branch is dependent.</p><p>Cache stage 304 is a non-pipelined stage. Data cache 165 (FIG. 1) is accessed if needed during execution stage 303 (FIG. 3). The reason that stage 304 is non-pipelined is because hardware processor 100 is a stack-based machine. Thus, the instruction following a load is almost always dependent on the value returned by the load. Consequently, in this embodiment, the pipeline is held for one cycle for a data cache access. This reduces the pipeline stages, and the die area taken by the pipeline for the extra registers and bypasses.</p><p>Write-back stage 305 is the last stage in the pipeline. In stage 305, the calculated data is written back to stack cache 155.</p><p>Hardware processor 100, in this embodiment, directly implements a stack 400 (FIG. 4A) that supports the JAVA virtual machine stack-based architecture (See Appendix I). Sixty-four entries on stack 400 are contained on stack cache 155 in stack management unit 150. Some entries in stack 400 may be duplicated on stack cache 155. Operations on data are performed through stack cache 155.</p><p>Stack 400 of hardware processor 100 is primarily used as a repository of information for methods. At any point in time, hardware processor 100 is executing a single method. Each method has memory space, i.e., a method frame on stack 400, allocated for a set of local variables, an operand stack, and an execution environment structure.</p><p>A new method frame, e.g., method frame two 410, is allocated by hardware processor 100 upon a method invocation in execution stage 303 (FIG. 3) and becomes the current frame, i.e., the frame of the current method. Current frame 410 (FIG. 4A), as well as the other method frames, may contain a part of or all of the following six entities, depending on various method invoking situations:</p><p>Object reference;</p><p>Incoming arguments;</p><p>Local variables;</p><p>Invoker's method context;</p><p>Operand stack; and</p><p>Return value from method.</p><p>In FIG. 4A, object reference, incoming arguments, and local variables are included in arguments and local variables area 421. The invoker's method context is included in execution environment 422, sometimes called frame state, that in turn includes: a return program counter value 431 that is the address of the virtual machine instruction, e.g., JAVA opcode, next to the method invoke instruction; a return frame 432 that is the location of the calling method's frame; a return constant pool pointer 433 that is a pointer to the calling method's constant pool table; a current method vector 434 that is the base address of the current method's vector table; and a current monitor address 435 that is the address of the current method's monitor.</p><p>The object reference is an indirect pointer to an object-storage representing the object being targeted for the method invocation. JAVA compiler JAVAC (See FIG. 2.) generates an instruction to push this pointer onto operand stack 423 prior to generating an invoke instruction. This object reference is accessible as local variable zero during the execution of the method. This indirect pointer is not available for a static method invocation as there is no target-object defined for a static method invocation.</p><p>The list of incoming arguments transfers information from the calling method to the invoked method. Like the object reference, the incoming arguments are pushed onto stack 400 by JAVA compiler generated instructions and may be accessed as local variables. JAVA compiler JAVAC (See FIG. 2.) statically generates a list of arguments for current method 410 (FIG. 4A), and hardware processor 100 determines the number of arguments from the list. When the object reference is present in the frame for a non-static method invocation, the first argument is accessible as local variable one. For a static method invocation, the first argument becomes local variable zero.</p><p>For 64-bit arguments, as well as 64-bit entities in general,, the upper 32-bits, i.e., the 32 most significant bits, of a 64-bit entity are placed on the upper location of stack 400, i.e., pushed on the stack last. For example, when a 64-bit entity is on the top of stack 400, the upper 32-bit portion of the 64-bit entity is on the top of the stack, and the lower 32-bit portion of the 64-bit entity is in the storage location immediately adjacent to the top of stack 400.</p><p>The local variable area on stack 400 (FIG. 4A) for current method 410 represents temporary variable storage space which is allocated and remains effective during invocation of method 410. JAVA compiler JAVAC (FIG. 2) statically determines the required number of local variables and hardware processor 100 allocates temporary variable storage space accordingly.</p><p>When a method is executing on hardware processor 100, the local variables typically reside in stack cache 155 and are addressed as offsets from pointer VARS (FIGS. 1 and 4A), which points to the position of the local variable zero. Instructions are provided to load the values of local variables onto operand stack 423 and store values from operand stack into local variables area 421.</p><p>The information in execution environment 422 includes the invoker's method context. When a new frame is built for the current method, hardware processor 100 pushes the invoker's method context onto newly allocated frame 410, and later utilizes the information to restore the invoker's method context before returning. Pointer FRAME (FIGS. 1 and 4A) is a pointer to the execution environment of the current method. In the exemplary embodiment, each register in register set 144 (FIG. 1) is 32-bits wide.</p><p>Operand stack 423 is allocated to support the execution of the virtual machine instructions within the current method. Program counter register PC (FIG. 1) contains the address of the next instruction, e.g., opcode, to be executed. Locations on operand stack 423 (FIG. 4A) are used to store the operands of virtual machine instructions, providing both source and target storage locations for instruction execution. The size of operand stack 423 is statically determined by JAVA compiler JAVAC (FIG. 2) and hardware processor 100 allocates space for operand stack 423 accordingly. Register OPTOP (FIGS. 1 and 4A) holds a pointer to a top of operand stack 423.</p><p>The invoked method may return its execution result onto the invoker's top of stack, so that the invoker can access the return value with operand stack references. The return value is placed on the area where an object reference or an argument is pushed before a method invocation.</p><p>Simulation results on the JAVA virtual machine indicate that method invocation consumes a significant portion of the execution time (20-40%). Given this attractive target for accelerating execution of virtual machine instructions, hardware support for method invocation is included in hardware processor 100, as described more completely below.</p><p>The beginning of the stack frame of a newly invoked method, i.e., the object reference and the arguments passed by the caller, are already stored on stack 400 since the object reference and the incoming arguments come from the top of the stack of the caller. As explained above, following these items on stack 400, the local variables are loaded and then the execution environment is loaded.</p><p>One way to speed up this process is for hardware processor 100 to load the execution environment in the background and indicate what has been loaded so far, e.g., simple one bit scoreboarding. Hardware processor 100 tries to execute the bytecodes of the called method as soon as possible, even though stack 400 is not completely loaded. If accesses are made to variables already loaded, overlapping of execution with loading of stack 400 is achieved, otherwise a hardware interlock occurs and hardware processor 100 just waits for the variable or variables in the execution environment to be loaded.</p><p>FIG. 4B illustrates another way to accelerate method invocation. Instead of storing the entire method frame in stack 400, the execution environment of each method frame is stored separately from the local variable area and the operand stack of the method frame. Thus, in this embodiment, stack 400B contains modified method frames, e.g. modified method frame 410B having only local variable area 421 and operand stack 423. Execution environment 422 of the method frame is stored in an execution environment memory 440. Storing the execution environment in execution environment memory 440 reduces the amount of data in stack cache 155. Therefore, the size of stack cache 155 can be reduced. Furthermore, execution environment memory 440 and stack cache 155 can be accessed simultaneously. Thus, method invocation can be accelerated by loading or storing the execution environment in parallel with loading or storing data onto stack 400B.</p><p>In one embodiment of stack management unit 150, the memory architecture of execution environment memory 440 is also a stack. As modified method frames are pushed onto stack 400B through stack cache 155, corresponding execution environments are pushed onto execution environment memory 440. For example, since modified method frames 0 to 2, as shown in FIG. 4B, are in stack 400B, execution environments (EE) 0 to 2, respectively, are stored in execution environment memory circuit 440.</p><p>To further enhance method invocation, an execution environment cache can be added to improve the speed of saving and retrieving the execution environment during method invocation. The architecture described more completely below for stack cache 155, dribbler manager unit 151, and stack control unit 152 for caching stack 400, can also be applied to caching execution environment memory 440.</p><p>FIG. 4C illustrates an embodiment of stack management unit 150 modified to support both stack 400B and execution environment memory 440. Specifically, the embodiment of stack management unit 150 in FIG. 4C adds an execution environment stack cache 450, an execution environment dribble manager unit 460, and an execution environment stack control unit 470. Typically, execution dribble manager unit 460 transfers an entire execution environment between execution environment cache 450 and execution environment memory 440 during a spill operation or a fill operation.</p><h4>I/O Bus and Memory Interface Unit</h4><p>I/O bus and memory interface unit 110 (FIG. 1), sometimes called interface unit 110, implements an interface between hardware processor 100 and a memory hierarchy which in an exemplary embodiment includes external memory and may optionally include memory storage and/or interfaces on the same die as hardware processor 100. In this embodiment, I/O controller 111 interfaces with external I/O devices and memory controller 112 interfaces with external memory. Herein, external memory means memory external to hardware processor 100. However, external memory either may be included on the same die as hardware processor 100, may be external to the die containing hardware processor 100, or may include both on- and off-die portions.</p><p>In another embodiment, requests to I/O devices go through memory controller 112 which maintains an address map of the entire system including hardware processor 100. On the memory bus of this embodiment, hardware processor 100 is the only master and does not have to arbitrate to use the memory bus.</p><p>Hence, alternatives for the input/output bus that interfaces with I/O bus and memory interface unit 110 include supporting memory-mapped schemes, providing direct support for PCI, PCMCIA, or other standard busses. Fast graphics (w/VIS or other technology) may optionally be included on the die with hardware processor 100.</p><p>I/O bus and memory interface unit 110 generates read and write requests to external memory. Specifically, interface unit 110 provides an interface for instruction cache and data cache controllers 121 and 161 to the external memory. Interface unit 110 includes arbitration logic for internal requests from instruction cache controller 121 and data cache controller 161 to access external memory and in response to a request initiates either a read or a write request on the memory bus to the external memory. A request from data cache controller 161 is always treated as higher priority relative to a request from instruction cache controller 121.</p><p>Interface unit 110 provides an acknowledgment signal to the requesting instruction cache controller 121, or data cache controller 161 on read cycles so that the requesting controller can latch the data. On write cycles, the acknowledgment signal from interface unit 110 is used for flow control so that the requesting instruction cache controller 121 or data cache controller 161 does not generate a new request when there is one pending. Interface unit 110 also handles errors generated on the memory bus to the external memory.</p><h4>Instruction Cache Unit</h4><p>Instruction cache unit (ICU) 120 (FIG. 1) fetches virtual machine instructions from instruction cache 125 and provides the instructions to instruction decode unit 130. In this embodiment, upon a instruction cache hit, instruction cache controller 121, in one cycle, transfers an instruction from instruction cache 125 to instruction buffer 124 where the instruction is held until integer execution unit IEU, that is described more completely below, is ready to process the instruction. This separates the rest of pipeline 300 (FIG. 3) in hardware processor 100 from fetch stage 301. If it is undesirable to incur the complexity of supporting an instruction-buffer type of arrangement, a temporary one instruction register is sufficient for most purposes. However, instruction fetching, caching, and buffering should provide sufficient instruction bandwidth to support instruction folding as described below.</p><p>The front end of hardware processor 100 is largely separate from the rest of hardware processor 100. Ideally, one instruction per cycle is delivered to the execution pipeline.</p><p>The instructions are aligned on an arbitrary eight-bit boundary by byte aligner circuit 122 in response to a signal from instruction decode unit 130. Thus, the front end of hardware processor 100 efficiently deals with fetching from any byte position. Also, hardware processor 100 deals with the problems of instructions that span multiple cache lines of cache 125. In this case, since the opcode is the first byte, the design is able to tolerate an extra cycle of fetch latency for the operands. Thus, a very simple de-coupling between the fetching and execution of the bytecodes is possible.</p><p>In case of an instruction cache miss, instruction cache controller 121 generates an external memory request for the missed instruction to I/O bus and memory interface unit 110. If instruction buffer 124 is empty, or nearly empty, when there is an instruction cache miss, instruction decode unit 130 is stalled, i.e., pipeline 300 is stalled. Specifically, instruction cache controller 121 generates a stall signal upon a cache miss which is used along with an instruction buffer empty signal to determine whether to stall pipeline 300. Instruction cache 125 can be invalidated to accommodate self-modifying code, e.g., instruction cache controller 121 can invalidate a particular line in instruction cache 125.</p><p>Thus, instruction cache controller 121 determines the next instruction to be fetched, i.e., which instruction in instruction cache 125 needs to accessed, and generates address, data and control signals for data and tag RAMs in instruction cache 125. On a cache hit, four bytes of data are fetched from instruction cache 125 in a single cycle, and a maximum of four bytes can be written into instruction buffer 124.</p><p>Byte aligner circuit 122 aligns the data out of the instruction cache RAM and feeds the aligned data to instruction buffer 124. As explained more completely below, the first two bytes in instruction buffer 124 are decoded to determine the length of the virtual machine instruction. Instruction buffer 124 tracks the valid instructions in the queue and updates the entries, as explained more completely below.</p><p>Instruction cache controller 121 also provides the data path and control for handling instruction cache misses. On an instruction cache miss, instruction cache controller 121 generates a cache fill request to I/O bus and memory interface unit 110.</p><p>On receiving data from external memory, instruction cache controller 121 writes the data into instruction cache 125 and the data are also bypassed into instruction buffer 124. Data are bypassed to instruction buffer 124 as soon as the data are available from external memory, and before the completion of the cache fill.</p><p>Instruction cache controller 121 continues fetching sequential data until instruction buffer 124 is full or a branch or trap has taken place. In one embodiment, instruction buffer 124 is considered full if there are more than eight bytes of valid entries in buffer 124. Thus, typically, eight bytes of data are written into instruction cache 125 from external memory in response to the cache fill request sent to interface unit 110 by instruction cache unit 120. If there is a branch or trap taken while processing an instruction cache miss, only after the completion of the miss processing is the trap or branch executed.</p><p>When an error is generated during an instruction cache fill transaction, a fault indication is generated and stored into instruction buffer 124 along with the virtual machine instruction, i.e., a fault bit is set. The line is not written into instruction cache 125. Thus, the erroneous cache fill transaction acts like a non-cacheable transaction except that a fault bit is set. When the instruction is decoded, a trap is taken.</p><p>Instruction cache controller 121 also services non-cacheable instruction reads. An instruction cache enable (ICE) bit, in a processor status register in register set 144, is used to define whether a load can be cached. If the instruction cache enable bit is cleared, instruction cache unit 120 treats all loads as non-cacheable loads. Instruction cache controller 121 issues a non-cacheable request to interface unit 110 for non-cacheable instructions. When the data are available on a cache fill bus for the non-cacheable instruction, the data are bypassed into instruction buffer 124 and are not written into instruction cache 125.</p><p>In this embodiment, instruction cache 125 is a direct-mapped, eight-byte line size cache. Instruction cache 125 has a single cycle latency. The cache size is configurable to 0K, 1K, 2K, 4K, 8K and 16K byte sizes where K means kilo. The default size is 4K bytes. Each line has a cache tag entry associated with the line. Each cache tag contains a twenty bit address tag field and one valid bit for the default 4K byte size.</p><p>Instruction buffer 124, which, in an exemplary embodiment, is a twelve-byte deep first-in, first-out (FIFO) buffer, de-links fetch stage 301 (FIG. 3) from the rest of pipeline 300 for performance reasons. Each instruction in buffer 124 (FIG. 1) has an associated valid bit and an error bit. When the valid bit is set, the instruction associated with that valid bit is a valid instruction. When the error bit is set, the fetch of the instruction associated with that error bit was an erroneous transaction. Instruction buffer 124 includes an instruction buffer control circuit (not shown) that generates signals to pass data to and from instruction buffer 124 and that keeps track of the valid entries in instruction buffer 124, i.e., those with valid bits set.</p><p>In an exemplary embodiment, four bytes can be received into instruction buffer 124 in a given cycle. Up to five bytes, representing up to two virtual machine instructions, can be read out of instruction buffer 124 in a given cycle. Alternative embodiments, particularly those providing folding of multi-byte virtual machine instructions and/or those providing folding of more than two virtual machine instructions, provide higher input and output bandwidth. Persons of ordinary skill in the art will recognize a variety of suitable instruction buffer designs including, for example, alignment logic, circular buffer design, etc. When a branch or trap is taken, all the entries in instruction buffer 124 are nullified and the branch/trap data moves to the top of instruction buffer 124.</p><p>In the embodiment of FIG. 1, a unified execution unit 140 is shown. However, in another embodiment, instruction decode unit 130, integer unit 142, and stack management unit 150 are considered a single integer execution unit, and floating point execution unit 143 is a separate optional unit. In still other embodiments, the various elements in the execution unit may be implemented using the execution unit of another processor. In general the various elements included in the various units of FIG. 1 are exemplary only of one embodiment. Each unit could be implemented with all or some of the elements shown. Again, the decision is largely dependent upon a price vs. performance trade-off.</p><h4>Instruction Decode Unit</h4><p>As explained above, virtual machine instructions are decoded in decode stage 302 (FIG. 3) of pipeline 300. In an exemplary embodiment, two bytes, that can correspond to two virtual machine instructions, are fetched from instruction buffer 124 (FIG. 1). The two bytes are decoded in parallel to determine if the two bytes correspond to two virtual machine instructions, e.g., a first load top of stack instruction and a second add top two stack entries instruction, that can be folded into a single equivalent operation. Folding refers to supplying a single equivalent operation corresponding to two or more virtual machine instructions.</p><p>In an exemplary hardware processor 100 embodiment, a single-byte first instruction can be folded with a second instruction. However, alternative embodiments provide folding of more than two virtual machine instructions, e.g., two to four virtual machine instructions, and of multi-byte virtual machine instructions, though at the cost of instruction decoder complexity and increased instruction bandwidth. See U.S. patent application Ser. No. 08/786,351, entitled \"INSTRUCTION FOLDING FOR A STACK-BASED MACHINE\" naming Marc Tremblay and James Michael O'Connor as inventors, assigned to the assignee of this application, and filed on even date herewith, which is incorporated herein by reference in its entirety. In the exemplary processor 100 embodiment, if the first byte, which corresponds to the first virtual machine instruction, is a multi-byte instruction, the first and second instructions are not folded.</p><p>An optional current object loader folder 132 exploits instruction folding, such as that described above, and in greater detail in U.S. patent application Ser. No. 08/786,351, entitled \"INSTRUCTION FOLDING FOR A STACK-BASED MACHINE\" naming Marc Tremblay and James Michael O'Connor as inventors, assigned to the assignee of this application, and filed on even date herewith, which is incorporated herein by reference in its entirety, in virtual machine instruction sequences which simulation results have shown to be particularly frequent and therefore a desirable target for optimization. In particular, a method invocation typically loads an object reference for the corresponding object onto the operand stack and fetches a field from the object. Instruction folding allow this extremely common virtual machine instruction sequence to be executed using an equivalent folded operation.</p><p>Quick variants are not part of the virtual machine instruction set (See Chapter 3 of Appendix I), and are invisible outside of a JAVA virtual machine implementation. However, inside a virtual machine implementation, quick variants have proven to be an effective optimization. (See Appendix A in Appendix I; which is an integral part of this specification.) Supporting writes for updates of various instructions to quick variants in a non-quick to quick translator cache 131 changes the normal virtual machine instruction to a quick virtual machine instruction to take advantage of the large benefits bought from the quick variants. In particular, as described in more detail in U.S. patent application Ser. No. 08/788,805, entitled \"NON-QUICK INSTRUCTION ACCELERATOR AND METHOD OF IMPLEMENTING SAME\" naming Marc Tremblay and James Michael O'Connor as inventors, assigned to the assignee of this application, and filed on even date herewith, which is incorporated herein by reference in its entirety, when the information required to initiate execution of an instruction has been assembled for the first time, the information is stored in a cache along with the value of program counter PC as tag in non-quick to quick translator cache 131 and the instruction is identified as a quick-variant. In one embodiment, this is done with self-modifying code.</p><p>Upon a subsequent call of that instruction, instruction decode unit 130 detects that the instruction is identified as a quick-variant and simply retrieves the information needed to initiate execution of the instruction from non-quick to quick translator cache 131. Non-quick to quick translator cache is an optional feature of hardware processor 100.</p><p>With regard to branching, a very short pipe with quick branch resolution is sufficient for most implementations. However, an appropriate simple branch prediction mechanism can alternatively be introduced, e.g., branch predictor circuit 133. Implementations for branch predictor circuit 133 include branching based on opcode, branching based on offset, or branching based on a two-bit counter mechanism.</p><p>The JAVA virtual machine specification defines an instruction invokenonvirtual, opcode 183, which, upon execution, invokes methods. The opcode is followed by an index byte one and an index byte two. (See Appendix I.) Operand stack 423 contains a reference to an object and some number of arguments when this instruction is executed.</p><p>Index bytes one and two are used to generate an index into the constant pool of the current class. The item in the constant pool at that index points to a complete method signature and class. Signatures are defined in Appendix I and that description is incorporated herein by reference.</p><p>The method signature, a short, unique identifier for each method, is looked up in a method table of the class indicated. The result of the look-up is a method block that indicates the type of method and the number of arguments for the method. The object reference and arguments are popped off this method's stack and become initial values of the local variables of the new method. The execution then resumes with the first instruction of the new method. Upon execution, instructions invokevirtual, opcode 182, and invokestatic, opcode 184, invoke processes similar to that just described. In each case, a pointer is used to look up a method block.</p><p>A method argument cache 134, that also is an optional feature of hardware processor 100, is used, in a first embodiment, to store the method block of a method for use after the first call to the method, along with the pointer to the method block as a tag. Instruction decode unit 130 uses index bytes one and two to generate the pointer and then uses the pointer to retrieve the method block for that pointer in cache 134. This permits building the stack frame for the newly invoked method more rapidly in the background in subsequent invocations of the method. Alternative embodiments may use a program counter or method identifier as a reference into cache 134. If there is a cache miss, the instruction is executed in the normal fashion and cache 134 is updated accordingly. The particular process used to determine which cache entry is overwritten is not an essential aspect of this invention. A least-recently used criterion could be implemented, for example.</p><p>In an alternative embodiment, method argument cache 134 is used to store the pointer to the method block, for use after the first call to the method, along with the value of program counter PC of the method as a tag. Instruction decode unit 130 uses the value of program counter PC to access cache 134. If the value of program counter PC is equal to one of the tags in cache 134, cache 134 supplies the pointer stored with that tag to instruction decode unit 130. Instruction decode unit 130 uses the supplied pointer to retrieve the method block for the method. In view of these two embodiments, other alternative embodiments will be apparent to those of skill in the art.</p><p>Wide index forwarder 136, which is an optional element of hardware processor 100, is a specific embodiment of instruction folding for instruction wide. Wide index forwarder 136 handles an opcode encoding an extension of an index operand for an immediately subsequent virtual machine instruction. In this way, wide index forwarder 136 allows instruction decode unit 130 to provide indices into local variable storage 421 when the number of local variables exceeds that addressable with a single byte index without incurring a separate execution cycle for instruction wide.</p><p>Aspects of instruction decoder 135, particularly instruction folding, non-quick to quick translator cache 131, current object loader folder 132, branch predictor 133, method argument cache 134, and wide index forwarder 136 are also useful in implementations that utilize a software interpreter or just-in-time compiler, since these elements can be used to accelerate the operation of the software interpreter or just-in-time compiler. In such an implementation, typically, the virtual machine instructions are translated to an instruction for the processor executing the interpreter or compiler, e.g., any one of a Sun processor, a DEC processor, an Intel processor, or a Motorola processor, for example, and the operation of the elements is modified to support execution on that processor. The translation from the virtual machine instruction to the other processor instruction can be done either with a translator in a ROM or a simple software translator. For additional examples of dual instruction set processors, see U.S. patent application Ser. No. 08/787,618, now U.S. Pat. No. 5,925,123, entitled \"A PROCESSOR FOR EXECUTING INSTRUCTION SETS RECEIVED FROM A NETWORK OR FROM A LOCAL MEMORY\" naming Marc Tremblay and James Michael O'Connor as inventors, assigned to the assignee of this application, and filed on even date herewith, which is incorporated herein by reference in its entirety</p><h4>Integer Execution Unit</h4><p>Integer execution unit IEU, that includes instruction decode unit 130, integer unit 142, and stack management unit 150, is responsible for the execution of all the virtual machine instructions except the floating point related instructions. The floating point related instructions are executed in floating point unit 143.</p><p>Integer execution unit IEU interacts at the front end with instructions cache unit 120 to fetch instructions, with floating point unit (FPU) 143 to execute floating point instructions, and finally with data cache unit (DCU) 160 to execute load and store related instructions. Integer execution unit IEU also contains microcode ROM 141 which contains instructions to execute certain virtual machine instructions associated with integer operations.</p><p>Integer execution unit IEU includes a cached portion of stack 400, i.e., stack cache 155. Stack cache 155 provides fast storage for operand stack and local variable entries associated with a current method, e.g., operand stack 423 and local variable storage 421 entries. Although, stack cache 155 may provide sufficient storage for all operand stack and local variable entries associated with a current method, depending on the number of operand stack and local variable entries, less than all of local variable entries or less than all of both local variable entries and operand stack entries may be represented in stack cache 155. Similarly, additional entries, e.g., operand stack and or local variable entries for a calling method, may be represented in stack cache 155 if space allows.</p><p>Stack cache 155 is a sixty-four entry thirty-two-bit wide array of registers that is physically implemented as a register file in one embodiment. Stack cache 155 has three read ports, two of which are dedicated to integer execution unit IEU and one to dribble manager unit 151. Stack cache 155 also has two write ports, one dedicated to integer execution unit IEU and one to dribble manager unit 151.</p><p>Integer unit 142 maintains the various pointers which are used to access variables, such as local variables, and operand stack values, in stack cache 155. Integer unit 142 also maintains pointers to detect whether a stack cache hit has taken place. Runtime exceptions are caught and dealt with by exception handlers that are implemented using information in microcode ROM 141 and circuit 170.</p><p>Integer unit 142 contains a 32-bit ALU to support arithmetic operations. The operations supported by the ALU include: add, subtract, shift, and, or, exclusive or, compare, greater than, less than, and bypass. The ALU is also used to determine the address of conditional branches while a separate comparator determines the outcome of the branch instruction.</p><p>The most common set of instructions which executes cleanly through the pipeline is the group of ALU instructions. The ALU instructions read the operands from the top of stack 400 in decode stage 302 and use the ALU in execution stage 303 to compute the result. The result is written back to stack 400 in write-back stage 305. There are two levels of bypass which may be needed if consecutive ALU operations are accessing stack cache 155.</p><p>Since the stack cache ports are 32-bits wide in this embodiment, double precision and long data operations take two cycles. A shifter is also present as part of the ALU. If the operands are not available for the instruction in decode stage 302, or at a maximum at the beginning of execution stage 303, an interlock holds the pipeline stages before execution stage 303.</p><p>The instruction cache unit interface of integer execution unit IEU is a valid/accept interface, where instruction cache unit 120 delivers instructions to instruction decode unit 130 in fixed fields along with valid bits. Instruction decoder 135 responds by signaling how much byte aligner circuit 122 needs to shift, or how many bytes instruction decode unit 130 could consume in decode stage 302. The instruction cache unit interface also signals to instruction cache unit 120 the branch mis-predict condition, and the branch address in execution stage 303. Traps, when taken, are also similarly indicated to instruction cache unit 120. Instruction cache unit 120 can hold integer unit 142 by not asserting any of the valid bits to instruction decode unit 130. Instruction decode unit 130 can hold instruction cache unit 120 by not asserting the shift signal to byte aligner circuit 122.</p><p>The data cache interface of integer execution unit IEU also is a valid-accept interface, where integer unit 142 signals, in execution stage 303, a load or store operation along with its attributes, e.g., non-cached, special stores etc., to data cache controller 161 in data cache unit 160. Data cache unit 160 can return the data on a load, and control integer unit 142 using a data control unit hold signal. On a data cache hit, data cache unit 160 returns the requested data, and then releases the pipeline.</p><p>On store operations, integer unit 142 also supplies the data along with the address in execution stage 303. Data cache unit 160 can hold the pipeline in cache stage 304 if data cache unit 160 is busy, e.g., doing a line fill etc.</p><p>Floating point operations are dealt with specially by integer execution unit IEU. Instruction decoder 135 fetches and decodes floating point unit 143 related instructions. Instruction decoder 135 sends the floating point operation operands for execution to floating point unit 142 in decode state 302. While floating point unit 143 is busy executing the floating point operation, integer unit 142 halts the pipeline and waits until floating point unit 143 signals to integer unit 142 that the result is available.</p><p>A floating point ready signal from floating point unit 143 indicates that execution stage 303 of the floating point operation has concluded. In response to the floating point ready signal, the result is written back into stack cache 155 by integer unit 142. Floating point load and stores are entirely handled by integer execution unit IEU, since the operands for both floating point unit 143 and integer unit 142 are found in stack cache 155.</p><h4>Stack Management Unit</h4><p>A stack management unit 150 stores information, and provides operands to execution unit 140. Stack management unit 150 also takes care of overflow and underflow conditions of stack cache 155.</p><p>In one embodiment, stack management unit 150 includes stack cache 155 that, as described above, is a three read port, two write port register file in one embodiment; a stack control unit 152 which provides the necessary control signals for two read ports and one write port that are used to retrieve operands for execution unit 140 and for storing data back from a write-back register or data cache 165 into stack cache 155; and a dribble manager 151 which speculatively dribbles data in and out of stack cache 155 into memory whenever there is an overflow or underflow in stack cache 155. In the exemplary embodiment of FIG. 1, memory includes data cache 165 and any memory storage interfaced by memory interface unit 110. In general, memory includes any suitable memory hierarchy including caches, addressable read/write memory storage, secondary storage, etc. Dribble manager 151 also provides the necessary control signals for a single read port and a single write port of stack cache 155 which are used exclusively for background dribbling purposes.</p><p>In one embodiment, stack cache 155 is managed as a circular buffer which ensures that the stack grows and shrinks in a predictable manner to avoid overflows or overwrites. The saving and restoring of values to and from data cache 165 is controlled by dribbler manager 151 using high- and low-water marks, in one embodiment.</p><p>Stack management unit 150 provides execution unit 140 with two 32-bit operands in a given cycle. Stack management unit 150 can store a single 32-bit result in a given cycle.</p><p>Dribble manager 151 handles spills and fills of stack cache 155 by speculatively dribbling the data in and out of stack cache 155 from and to data cache 165. Dribble manager 151 generates a pipeline stall signal to stall the pipeline when a stack overflow or underflow condition is detected. Dribble manager 151 also keeps track of requests sent to data cache unit 160. A single request to data cache unit 160 is a 32-bit consecutive load or store request.</p><p>The hardware organization of stack cache 155 is such that, except for long operands (long integers and double precision floating-point numbers), implicit operand fetches for opcodes do not add latency to the execution of the opcodes. The number of entries in operand stack 423 (FIG. 4A) and local variable storage 421 that are maintained in stack cache 155 represents a hardware/performance tradeoff. At least a few operand stack 423 and local variable storage 422 entries are required to get good performance. In the exemplary embodiment of FIG. 1, at least the top three entries of operand stack 423 and the first four local variable storage 421 entries are preferably represented in stack cache 155.</p><p>One key function provided by stack cache 155 (FIG. 1) is to emulate a register file where access to the top two registers is always possible without extra cycles. A small hardware stack is sufficient if the proper intelligence is provided to load/store values from/to memory in the background, therefore preparing stack cache 155 for incoming virtual machine instructions.</p><p>As indicated above, all items on stack 400 (regardless of size) are placed into a 32-bit word. This tends to waste space if many small data items are used, but it also keeps things relatively simple and free of lots of tagging or muxing. An entry in stack 400 thus represents a value and not a number of bytes. Long integer and double precision floating-point numbers require two entries. To keep the number of read and write ports low, two cycles to read two long integers or two double precision floating point numbers are required.</p><p>The mechanism for filling and spilling the operand stack from stack cache 155 out to memory by dribble manager 151 can assume one of several alternative forms. One register at a time can be filled or spilled, or a block of several registers filled or spilled at once. A simple scoreboarded method is appropriate for stack management. In its simplest form, a single bit indicates if the register in stack cache 155 is currently valid. In addition, some embodiments of stack cache 155 use a single bit to indicate whether the data content of the register is saved to stack 400, i.e., whether the register is dirty. In one embodiment, a high-water mark/low-water mark heuristic determines when entries are saved to and restored from stack 400, respectively (FIG. 4A). Alternatively, when the top-of-the-stack becomes close to bottom 401 of stack cache 155 by a fixed, or alternatively, a programmable number of entries, the hardware starts loading registers from stack 400 into stack cache 155. For other embodiments of stack management unit 150 and dribble manager unit 151 see U.S. patent application Ser. No. 08/787,736, entitled \"METHODS AND APPARATI FOR STACK CACHING\" naming Marc Tremblay and James Michael O'Connor as inventors, assigned to the assignee of this application, and filed on even date herewith, which is incorporated herein by reference in its entirety, and see also U.S. patent application Ser. No. 08/787,617, entitled \"METHOD FRAME STORAGE USING MULTIPLE MEMORY CIRCUITS\" naming Marc Tremblay and James Michael O'Connor as inventors, assigned to the assignee of this application, and filed on even date herewith, which also is incorporated herein by reference in its entirety.</p><p>In one embodiment, stack management unit 150 also includes an optional local variable look-aside cache 153. Cache 153 is most important in applications where both the local variables and operand stack 423 (FIG. 4A) for a method are not located on stack cache 155. In such instances when cache 153 is not included in hardware processor 100, there is a miss on stack cache 155 when a local variable is accessed, and execution unit 140 accesses data cache unit 160, which in turn slows down execution. In contrast, with cache 153, the local variable is retrieved from cache 153 and there is no delay in execution.</p><p>One embodiment of local variable look-aside cache 153 is illustrated in FIG. 4D for method 0 to 2 on stack 400. Local variables zero to M, where M is an integer, for method 0 are stored in plane 421A<sub>--</sub> 0 of cache 153 and plane 421A<sub>--</sub> 0 is accessed when method number 402 is zero. Local variables zero to N, where N is an integer, for method 1 are stored in plane 421A<sub>--</sub> 1 of cache 153 and plane 421A<sub>--</sub> 1 is accessed when method number 402 is one. Local variables zero to P, where P is an integer, for method 1 are stored in plane 421A<sub>--</sub> 2 of cache 153 and plane 421A<sub>--</sub> 2 is accessed when method number 402 is two. Notice that the various planes of cache 153 may be different sizes, but typically each plane of the cache has a fixed size that is empirically determined.</p><p>When a new method is invoked, e.g., method 2, a new plane 421A<sub>--</sub> 2 in cache 153 is loaded with the local variables for that method, and method number register 402, which in one embodiment is a counter, is changed, e.g., incremented, to point to the plane of cache 153 containing the local variables for the new method. Notice that the local variables are ordered within a plane of cache 153 so that cache 153 is effectively a direct-mapped cache. Thus, when a local variable is needed for the current method, the variable is accessed directly from the most recent plane in cache 153, i.e., the plane identified by method number 402. When the current method returns, e.g., method 2, method number register 402 is changed, e.g., decremented, to point at previous plane 421A-1 of cache 153. Cache 153 can be made as wide and as deep as necessary.</p><h4>Data Cache Unit</h4><p>Data cache unit 160 (DCU) manages all requests for data in data cache 165. Data cache requests can come from dribbling manager 151 or execution unit 140. Data cache controller 161 arbitrates between these requests giving priority to the execution unit requests. In response to a request, data cache controller 161 generates address, data and control signals for the data and tags RAMs in data cache 165. For a data cache hit, data cache controller 161 reorders the data RAM output to provide the right data.</p><p>Data cache controller 161 also generates requests to I/O bus and memory interface unit 110 in case of data cache misses, and in case of non-cacheable loads and stores. Data cache controller 161 provides the data path and control logic for processing non-cacheable requests, and the data path and data path control functions for handling cache misses.</p><p>For data cache hits, data cache unit 160 returns data to execution unit 140 in one cycle for loads. Data cache unit 160 also takes one cycle for write hits. In case of a cache miss, data cache unit 160 stalls the pipeline until the requested data is available from the external memory. For both non-cacheable loads and stores, data cache 165 is bypassed and requests are sent to I/O bus and memory interface unit 110. Non-aligned loads and stores to data cache 165 trap in software.</p><p>Data cache 165 is a two-way set associative, write back, write allocate, 16-byte line cache. The cache size is configurable to 0, 1, 2, 4, 8, 16 Kbyte sizes.</p><p>The default size is 8 Kbytes. Each line has a cache tag store entry associated with the line. On a cache miss, 16 bytes of data are written into cache 165 from external memory.</p><p>Each data cache tag contains a 20-bit address tag field, one valid bit, and one dirty bit. Each cache tag is also associated with a least recently used bit that is used for replacement policy. To support multiple cache sizes, the width of the tag fields also can be varied. If a cache enable bit in processor service register is not set, loads and stores are treated like non-cacheable instructions by data cache controller 161.</p><p>A single sixteen-byte write back buffer is provided for writing back dirty cache lines which need to be replaced. Data cache unit 160 can provide a maximum of four bytes on a read and a maximum of four bytes of data can be written into cache 165 in a single cycle. Diagnostic reads and writes can be done on the caches.</p><h4>Memory Allocation Accelerator</h4><p>In one embodiment, data cache unit 160 includes a memory allocation accelerator 166. Typically, when a new object is created, fields for the object are fetched from external memory, stored in data cache 165 and then the field is cleared to zero. This is a time consuming process that is eliminated by memory allocation accelerator 166. When a new object is created, no fields are retrieved from external memory. Rather, memory allocation accelerator 166 simply stores a line of zeros in data cache 165 and marks that line of data cache 165 as dirty. Memory allocation accelerator 166 is particularly advantageous with a write-back cache. Since memory allocation accelerator 166 eliminates the external memory access each time a new object is created, the performance of hardware processor 100 is enhanced.</p><h4>Floating Point Unit</h4><p>Floating point unit (FPU) 143 includes a microcode sequencer, input/output section with input/output registers, a floating point adder, i.e., an ALU, and a floating point multiply/divide unit. The microcode sequencer controls the microcode flow and microcode branches. The input/output section provides the control for input/output data transactions, and provides the input data loading and output data unloading registers. These registers also provide intermediate result storage.</p><p>The floating point adder-ALU includes the combinatorial logic used to perform the floating point adds, floating point subtracts, and conversion operations. The floating point multiply/divide unit contains the hardware for performing multiply/divide and remainder.</p><p>Floating point unit 143 is organized as a microcoded engine with a 32-bit data path. This data path is often reused many times during the computation of the result. Double precision operations require approximately two to four times the number of cycles as single precision operations. The floating point ready signal is asserted one-cycle prior to the completion of a given floating point operation. This allows integer unit 142 to read the floating point unit output registers without any wasted interface cycles. Thus, output data is available for reading one cycle after the floating point ready signal is asserted.</p><h4>Execution Unit Accelerators</h4><p>Since the JAVA Virtual Machine Specification of Appendix I is hardware independent, the virtual machine instructions are not optimized for a particular general type of processor, e.g., a complex instruction set computer (CISC) processor, or a reduced instruction set computer (RISC) processor. In fact, some virtual machine instructions have a CISC nature and others a RISC nature. This dual nature complicates the operation and optimization of hardware processor 100.</p><p>For example, the JAVA virtual machine specification defines opcode 171 for an instruction lookupswitch, which is a traditional switch statement. The datastream to instruction cache unit 120 includes an opcode 171, identifying the N-way switch statement, that is followed zero to three bytes of padding. The number of bytes of padding is selected so that first operand byte begins at an address that is a multiple of four. Herein, datastream is used generically to indicate information that is provided to a particular element, block, component, or unit.</p><p>Following the padding bytes in the datastream are a series of pairs of signed four-byte quantities. The first pair is special. A first operand in the first pair is the default offset for the switch statement that is used when the argument, referred to as an integer key, or alternatively, a current match value, of the switch statement is not equal to any of the values of the matches in the switch statement. The second operand in the first pair defines the number of pairs that follow in the datastream.</p><p>Each subsequent operand pair in the datastream has a first operand that is a match value, and a second operand that is an offset. If the integer key is equal to one of the match values, the offset in the pair is added to the address of the switch statement to define the address to which execution branches. Conversely, if the integer key is unequal to any of the match values, the default offset in the first pair is added to the address of the switch statement to define the address to which execution branches. Direct execution of this virtual machine instruction requires many cycles.</p><p>To enhance the performance of hardware processor 100, a look-up switch accelerator 145 is included in hardware processor 100. Look-up switch accelerator 145 includes an associative memory which stores information associated with one or more look-up switch statements. For each look-up switch statement, i.e., each instruction lookupswitch, this information includes a look-up switch identifier value, i.e., the program counter value associated with the look-up switch statement, a plurality of match values and a corresponding plurality of jump offset values.</p><p>Look-up switch accelerator 145 determines whether a current instruction received by hardware processor 100 corresponds to a look-up switch statement stored in the associative memory. Look-up switch accelerator 145 further determines whether a current match value associated with the current instruction corresponds with one of the match values stored in the associative memory. Look-up switch accelerator 145 accesses a jump offset value from the associative memory when the current instruction corresponds to a look-up switch statement stored in the memory and the current match value corresponds with one of the match values stored in the memory wherein the accessed jump offset value corresponds with the current match value.</p><p>Look-up switch accelerator 145 further includes circuitry for retrieving match and jump offset values associated with a current look-up switch statement when the associative memory does not already contain the match and jump offset values associated with the current look-up switch statement. Look-up switch accelerator 145 is described in more detail below.</p><p>In the process of initiating execution of a method of an object, execution unit 140 accesses a method vector to retrieve one of the method pointers in the method vector, i.e., one level of indirection. Execution unit 140 then uses the accessed method pointer to access a corresponding method, i.e., a second level of indirection.</p><p>To reduce the levels of indirection within execution unit 140, each object is provided with a dedicated copy of each of the methods to be accessed by the object. Execution unit 140 then accesses the methods using a single level of indirection. That is, each method is directly accessed by a pointer which is derived from the object. This eliminates a level of indirection which was previously introduced by the method pointers. By reducing the levels of indirection, the operation of execution unit 140 can be accelerated. The acceleration of execution unit 140 by reducing the levels of indirection experienced by execution unit 140 is described in more detail in U.S. patent application Ser. No. 08/787,846, now U.S. Pat. No. 5,970,242, entitled \"REPLICATING CODE TO ELIMINATE A LEVEL OF INDIRECTION DURING EXECUTION OF AN OBJECT ORIENTED COMPUTER PROGRAM\" naming Marc Tremblay and James Michael O'Connor as inventors, assigned to the assignee of this application, and filed on even date herewith, which is incorporated herein by reference in its entirety.</p><h4>Getfield-putfield Accelerator</h4><p>Other specific functional units and various translation lookaside buffer (TLB) types of structures may optionally be included in hardware processor 100 to accelerate accesses to the constant pool. For example, the JAVA virtual machine specification defines an instruction putfield, opcode 181, that upon execution sets a field in an object and an instruction getfield, opcode 180, that upon execution fetches a field from an object. In both of these instructions, the opcode is followed by an index byte one and an index byte two. Operand stack 423 contains a reference to an object followed by a value for instruction putfield, but only a reference to an object for instruction getfield.</p><p>Index bytes one and two are used to generate an index into the constant pool of the current class. The item in the constant pool at that index is a field reference to a class name and a field name. The item is resolved to a field block pointer which has both the field width, in bytes, and the field offset, in bytes.</p><p>An optional getfield-putfield accelerator 146 in execution unit 140 stores the field block pointer for instruction getfield or instruction putfield in a cache, for use after the first invocation of the instruction, along with the index used to identify the item in the constant pool that was resolved into the field block pointer as a tag. Subsequently, execution unit 140 uses index bytes one and two to generate the index and supplies the index to getfield-putfield accelerator 146. If the index matches one of the indexes stored as a tag, i.e., there is a hit, the field block pointer associated with that tag is retrieved and used by execution unit 140. Conversely, if a match is not found, execution unit 140 performs the operations described above. Getfield-putfield accelerator 146 is implemented without using self-modifying code that was used in one embodiment of the quick instruction translation described above.</p><p>In one embodiment, getfield-putfield accelerator 146 includes an associative memory that has a first section that holds the indices that function as tags, and a second section that holds the field block pointers. When an index is applied through an input section to the first section of the associative memory, and there is a match with one of the stored indices, the field block pointer associated with the stored index that matched in input index is output from the second section of the associative memory.</p><h4>Bounds Check Unit</h4><p>Bounds check unit 147 (FIG. 1) in execution unit 140 is an optional hardware circuit that checks each access to an element of an array to determine whether the access is to a location within the array. When the access is to a location outside the array, bounds check unit 147 issues an active array bound exception signal to execution unit 140. In response to the active array bound exception signal, execution unit 140 initiates execution of an exception handler stored in microcode ROM 141 that in handles the out of bounds array access.</p><p>In one embodiment, bounds check unit 147 includes an associative memory element in which is stored a array identifier for an array, e.g., a program counter value, and a maximum value and a minimum value for the array. When an array is accessed, i.e., the array identifier for that array is applied to the associative memory element, and assuming the array is represented in the associative memory element, the stored minimum value is a first input signal to a first comparator element, sometimes called a comparison element, and the stored maximum value is a first input signal to a second comparator element, sometimes also called a comparison element. A second input signal to the first and second comparator elements is the value associated with the access of the array's element.</p><p>If the value associated with the access of the array's element is less than or equal to the stored maximum value and greater than or equal to the stored minimum value, neither comparator element generates an output signal. However, if either of these conditions is false, the appropriate comparator element generates the active array bound exception signal. A more detailed description of one embodiment of bounds check unit 147 is provided in U.S. patent application Ser. No. 08/786,352, now U.S. Pat. No. 6,014,723, entitled \"PROCESSOR WITH ACCELERATED ARRAY ACCESS BOUNDS CHECKING\" naming Marc Tremblay, James Michael O'Connor, and William N. Joy as inventors, assigned to the assignee of this application, and filed on even date herewith which is incorporated herein by reference in its entirety.</p><p>The JAVA Virtual Machine Specification defines that certain instructions can cause certain exceptions. The checks for these exception conditions are implemented, and a hardware/software mechanism for dealing with them is provided in hardware processor 100 by information in microcode ROM 141 and program counter and trap control logic 170. The alternatives include having a trap vector style or a single trap target and pushing the trap type on the stack so that the dedicated trap handler routine determines the appropriate action.</p><p>No external cache is required for the architecture of hardware processor 100. No translation lookaside buffers need be supported.</p><p>FIG. 5 illustrates several possible add-ons to hardware processor 100 to create a unique system. Circuits supporting any of the eight functions shown, i.e., NTSC encoder 501, MPEG 502, Ethernet controller 503, VIS 504, ISDN 505, I/O controller 506, ATM assembly/reassembly 507, and radio link 508 can be integrated into the same chip as hardware processor 100 of this invention.</p><h4>Look-up Switch Statement Accelerator</h4><p>FIG. 6 is a block diagram of operand stack 423, instruction decode unit 130, look-up switch accelerator 145, trap logic circuit 170, software code 19 and execution unit 140 in accordance with one embodiment of the present invention. Software code 19 is typically found in a local memory (not shown), which is coupled to I/O bus and memory interface unit 110. Look-up switch accelerator 145 includes look-up switch statement processor 15, associative memory circuit 14, comparator circuit 16 and output multiplexer 26. Although comparator circuit 16 and look-up switch statement processor 15 are illustrated as separate elements, it is understood that in other embodiments, comparator circuit 16 can be implemented within look-up switch statement processor 15. The associative memory circuit 14, in turn, includes a plurality of memory panels 30A-30C. Although three memory panels are shown, other numbers of memory panels can be used in other embodiments. As described in more detail below, each of the memory panels 30A-30C accelerates a corresponding look-up switch statement. Thus, the number of memory panels is selected to correspond with the number of look-up switch statements which are to be accelerated. Memory panel 30A includes match memory section 18A, jump offset memory section 20A, look-up switch identifier memory section 21A, input circuit 22A, output circuit 24A, and multiplexer 25A. Similarly, memory panel 30B includes match memory section 18B, jump offset memory section 20B, look-up switch identifier memory section 21B, input circuit 22B, output circuit 24B, and multiplexer 25B. Memory panel 30C includes match memory section 18C, jump offset memory section 20C, look-up switch identifier memory section 21C, input circuit 22C, output circuit 24C and multiplexer 25C.</p><p>Instruction decode unit 130 is coupled to receive a stream of instructions, such as JAVA byte codes, from instruction cache unit 120. Although the present invention is described in connection with JAVA instructions, the present invention is also applicable to other types of instructions.</p><p>In response to the received instructions, instruction decoder unit 130 provides decoded instructions on bus 12 and program counter values (PC) corresponding to the decoded instructions on bus 13. These instructions and PC values are provided to execution unit 140 and to look-up switch statement processor 15. In general, each of the PC values uniquely identifies a corresponding instruction. The top entry of operand stack 423 is provided to look-up switch statement processor 15 and to input circuits 22A, 22B and 22C of memory panels 30A, 30B and 30C.</p><p>FIG. 7 is a schematic diagram of exemplary PC values, instructions and top entries of operand stack 423 which are provided to look-up switch accelerator 145 in accordance with one embodiment of the present invention. Look-up switch accelerator 145 operates as follows in response to these PC values, instructions and operand stack entries.</p><p>PC value 98 corresponds with a PUSH instruction. Decode unit 130 provides the PC value and the decoded PUSH instruction to execution unit 140 and look-up switch statement processor 15. As described in more detail below, look-up switch statement processor 15 is only activated when the decoded instruction is a look-up switch statement or a look-up switch load instruction. Thus, look-up switch statement processor 15 is not activated in response to the PUSH instruction. In response to the PUSH instruction, execution unit 140 pushes a 1 value onto the top of operand stack 423. This operation is indicated in the far right column of FIG. 7.</p><p>Execution unit 140 then increments the PC value by one to 99. PC value 99 corresponds to a PUSH 6 instruction. Again, look-up switch statement processor 15 is not activated by this PUSH instruction. However, execution unit 140 pushes a 6 value onto the top of operand stack 423. The previously pushed 1 value is relocated one position down from the top of operand stack 423.</p><p>Execution unit 140 then increments the PC value by one to 100. PC value 100 corresponds to an ADD instruction. Again, look-up switch statement processor 15 is not activated by the ADD instruction (since the ADD instruction is not a look-up switch statement or a look-up switch load instruction). In response to the ADD instruction, execution unit 140 adds the top two values of operand stack 423 (i.e., 6 and 1) and writes the result (i.e., 7) to the top of operand stack 423.</p><p>Execution unit 140 then increments the PC value by one to 101. PC value 101 corresponds to a look-up switch statement (which is hereinafter referred to as the current look-up switch statement). In general, a look-up switch statement instructs execution unit 140 to access instructions residing at one of several PC values, depending upon the value of a predefined variable. Stated another way, a look-up switch statement causes the processing performed by execution unit 140 to branch off onto one of several paths in response to the value of the predefined variable.</p><p>In the present example, the current look-up switch statement enables processing to branch off onto one of four paths, depending upon the value of the top entry of operand stack 423. Thus, a top stack entry of 0 causes the current PC value (i.e., 101) to be incremented by 19, such that the instruction having a PC value of 120 will be the next instruction executed by execution unit 140. Similarly, a top stack entry of 1 will cause the current PC value (i.e., 101) to be incremented by 29, such that the instruction having a PC value of 130 will be the next instruction executed by execution unit 140. A top stack entry of 7 will cause the current PC value (i.e., 101) to be incremented by 39, such that the instruction having a PC value of 140 will be the next instruction executed by execution unit 140. Finally, a top stack entry having a value which is not 0, 1 or 7 will cause the current PC value (i.e., 101) to be incremented by the specified default value of 50, such that the instruction having a PC value of 102 will be the next instruction executed by the execution unit 140. The values which are compared with the top stack entry (i.e., 0, 1 and 7) are generally referred to as match values (since the top stack entry must match these values for a particular processing path to be implemented). The values which are added to the current PC value (i.e., 19, 29, 39 and 1) are generally referred to as jump offset values (since these values indicate the number by which the current PC value is offset). Although this look-up switch statement is described as providing jump offset values which are added to the current PC value, it is understood that these jump offset values can be replaced with absolute program counter values in an alternate embodiment of the invention.</p><p>Thus, in the described embodiment, for execution unit 140 to implement the instructions specified by a look-up switch statement, the execution unit 140 must receive the look-up switch statement, the current PC value, and a corresponding jump offset value. This information is provided to execution unit 140 as follows.</p><p>Initially, look-up switch statement processor 15 determines whether the instruction provided on bus 12 is a look-up switch statement. This determination can be made by decoding an identifying portion (or portions) of the instruction. Thus, look-up switch statement processor 15 determines that the current look-up switch statement (which has a PC value of 101) is a look-up switch statement. Upon identifying the current look-up switch statement as a look-up switch statement, look-up switch statement processor 15 provides the corresponding current PC value (i.e., 101) to comparator circuit 16. Comparator circuit 16 is also coupled to receive PC values which have been previously stored in look-up switch identifier memory sections 21A, 21B and 21C as look-up switch identifier values PC<sub>--</sub> 1, PC<sub>--</sub> 2 and PC<sub>--</sub> 3, respectively. Each of the look-up switch identifier values PC<sub>--</sub> 1, PC<sub>--</sub> 2 and PC<sub>--</sub> 3 provides a PC value for a corresponding Look-up SWITCH statement. Initially, the look-up switch identifier values PC<sub>--</sub> 1, PC<sub>--</sub> 2 and PC<sub>--</sub> 3 are set to invalid values. Alternatively, `valid` bits associated with the look-up switch identifier values PC<sub>--</sub> 1, PC<sub>--</sub> 2 and PC<sub>--</sub> 3 can be cleared.</p><p>Comparator circuit 16 compares the look-up switch identifier values PC<sub>--</sub> 1, PC<sub>--</sub> 2 and PC<sub>--</sub> 3 with the current PC value (i.e., 101). Comparator circuit 16 asserts a PC<sub>--</sub> HIT<sub>--</sub> 1 signal if the look-up switch identifier value PC<sub>--</sub> 1 matches the current PC value. Similarly, comparator circuit 16 asserts a PC<sub>--</sub> HIT<sub>--</sub> 2 signal if the look-up switch identifier value PC<sub>--</sub> 2 matches the current PC value. Comparator circuit 16 asserts a PC<sub>--</sub> HIT<sub>--</sub> 3 signal if the look-up switch identifier value PC<sub>--</sub> 3 matches the current PC value. The PC<sub>--</sub> HIT<sub>--</sub> 1, PC<sub>--</sub> HIT<sub>--</sub> 2 and PC<sub>--</sub> HIT<sub>--</sub> 3 signals are provided back to look-up switch statement processor 15. Because the look-up switch identifier values PC<sub>--</sub> 1, PC<sub>--</sub> 2 and PC<sub>--</sub> 3 are initially invalid (or have cleared `valid` bits), these values do not match the current PC value, and none of the PC<sub>--</sub> HIT<sub>--</sub> 1, PC<sub>--</sub> HIT<sub>--</sub> 2 or PC<sub>--</sub> HIT<sub>--</sub> 3 signals is asserted.</p><p>The absence of a match between the current PC value and the look-up switch identifier values PC<sub>--</sub> 1, PC<sub>--</sub> 2 and PC<sub>--</sub> 3 indicates that the match and jump offset values associated with the current look-up switch statement are not currently stored in associative memory 14. As a result, look-up switch statement processor 15 must initially retrieve these match and jump offset values before the current look-up switch statement can be accelerated.</p><p>To accomplish this, look-up switch statement processor 15 asserts a NO<sub>--</sub> PC<sub>--</sub> HIT signal, which is provided to trap logic 170. In response, trap logic 170 temporarily suspends the operation of execution unit 140, and causes software code 19 to be accessed. Software code 19 accesses the incoming instruction stream to retrieve the match and jump offset values of the current look-up switch statement having the current PC value (i.e., 101). Software code 19 further causes these match and jump offset values to be loaded into operand stack 423. Software code 19 also provides one or more look-up switch load instructions to instruction decode unit 130. Decode unit 130, in turn, decodes these look-up switch load instructions. The decoded look-up switch load instructions are provided to look-up switch statement processor 15 on bus 12. Look-up switch statement processor 15 identifies the look-up switch load instructions which are present on bus 12, and in response, retrieves the match and jump offset values from operand stack 423.</p><p>Look-up switch statement processor 15 then performs a series of write operations to load the current PC value and the retrieved match and jump offset values to one of the memory panels 30A-30C. The number of write operations is proportional to the number of match values in the look-up switch statement. The method used to select the particular memory panel to be accessed can be, for example, random, a least recently used (LRU) algorithm or a first in, first out (FIFO) algorithm. In the described example, memory panel 30A is initially selected. Thus, the current PC value (i.e., 101) is written to look-up switch identifier memory section 21A as look-up switch identifier value PC<sub>--</sub> 1. The current PC value is routed from look-up switch statement processor 15 to memory section 21A on bus 31. Bus 31 also extends to memory sections 21B and 21C. Look-up switch statement processor 15 controls a multiplexer circuit (not shown) which controls the routing of the current PC value to a selected one of look-up switch identifier memory sections 21A-21C.</p><p>The match values associated with the current look-up switch statement are written to match memory section 18A of the selected memory panel 30A on bus 32. Bus 32 also extends to match memory sections 18B and 18C. Look-up switch statement processor 15 controls a multiplexer circuit (not shown) which controls the routing of the MATCH values to a selected one of match memory sections 18A-18C. Each of the match values is written to a corresponding entry of match memory section 18A. Thus, a match value of \"0\" is written to the first entry of match memory section 18A (as MATCH<sub>--</sub> 1); a match value of \"1\" is written to the second entry of match memory section 18A (as MATCH<sub>--</sub> 2); and a match value of \"7\" is written to the third entry of match memory section 18A (as MATCH<sub>--</sub> 3). Invalid PC values are stored in the remaining entries of match memory section 18A. Alternatively, `valid` bits associated with these remaining entries can be cleared.</p><p>The jump offset values associated with the current look-up switch statement are written to jump offset memory section 20A of the selected memory panel 30A on bus 33. Bus 33 also extends to jump offset memory sections 20B and 20C. Look-up switch statement processor 15 controls a multiplexer circuit (not shown) which in turn controls the routing of the jump offset values to a selected one of jump offset memory sections 20A-20C. Each of the jump offset values is written to a corresponding entry of jump offset memory section 20A. Thus, a jump offset value of \"19\" is written to the first entry of memory section 20A (as JUMP<sub>--</sub> OFFSET<sub>--</sub> 1); a jump offset value of \"29\" is written to the second entry of memory section 20A (as JUMP<sub>--</sub> OFFSET<sub>--</sub> 2); and a jump offset value of \"39\" is written to the third entry of memory section 20A (as JUMP<sub>--</sub> OFFSET<sub>--</sub> 3). The default jump offset value of \"50\" is stored in a memory (not shown) which applies the default jump offset value to an input terminal of multiplexer 25A as default jump offset value DF1.</p><p>After the current PC value and the corresponding match and jump offset values have been written to memory panel 30A, the software code 19 resubmits the current look-up switch statement (along with the current PC value 101) to instruction decode unit 130. At this time, the top entry of operand stack 423 is equal to the value which was previously stored as the top entry of operand stack 423 before look-up switch statement processor 15 retrieved the match and jump offset values. Consequently, in the described example, the top entry of operand stack 423 is equal to 7 at this time.</p><p>Instruction decode unit 130 provides the decoded look-up switch statement and current PC value to look-up switch statement processor 15. Look-up switch statement processor 15 again compares the current PC value (i.e., 101) with the contents of look-up switch identifier memory sections 21A-21C. At this time, the current PC value matches the look-up switch identifier value PC<sub>--</sub> 1 stored in memory section 21A. In response to this match, comparator circuit 16 asserts the PC<sub>--</sub> HIT<sub>--</sub> 1 signal, thereby informing look-up switch statement processor 15 that the match and jump offset values associated with the current look-up switch statement have been previously loaded into memory panel 30A. Consequently, look-up switch statement processor 15 does not attempt to retrieve these values via trap logic 170 and software code 19.</p><p>In addition, the top entry of operand stack 423 is provided to each of input circuits 22A, 22B and 22C of memory panels 30A, 30B and 30C, respectively. Each of memory panels 30A, 30B and 30C is a content addressable memory (CAM). When the top entry of operand stack 423 is identical to a match value stored in one of memory panels 30A-30C, the jump offset value corresponding to the match value is provided to the output circuit of the memory panel. In the present example, input circuit 22A detects a match between the current top entry of operand stack 423 (which has a value of 7), and the third entry (MATCH <sub>--</sub> 3) of match memory section 18A (which also has a value of 7). In response, the third entry (JUMP<sub>--</sub> OFFSET<sub>--</sub> 3) of jump offset memory section 20A (which has a value of 39), is routed through output circuit 24A to multiplexer 25A.</p><p>Upon detecting a match, input circuit 22A asserts a HIT<sub>--</sub> 1 signal, which is provided to the control terminal of multiplexer 25A. In response to the asserted HIT<sub>--</sub> 1 signal, multiplexer 25A routes the jump offset value provided by output circuit 24A (i.e., JUMP<sub>--</sub> OFFSET<sub>--</sub> 3) to output multiplexer 26. If input circuit 22A does not detect a match, then input circuit 22A does not assert the HIT<sub>--</sub> 1 signal. In response to the non-asserted HIT<sub>--</sub> 1 signal, the default jump offset value DF1 is routed through multiplexer 25A to output multiplexer 26.</p><p>Output multiplexer 26 is controlled by the PC<sub>--</sub> HIT<sub>--</sub> 1, PC<sub>--</sub> HIT<sub>--</sub> 2 and PC<sub>--</sub> HIT<sub>--</sub> 3 signals provided by comparator circuit 16. The PC<sub>--</sub> HIT<sub>--</sub> 1, PC<sub>--</sub> HIT<sub>--</sub> 2 and PC<sub>--</sub> HIT<sub>--</sub> 3 signals, when asserted, cause the output signals from multiplexers 25A, 25B and 25C, respectively, to be routed through output multiplexer 26. If none of the PC<sub>--</sub> HIT<sub>--</sub> 1, PC<sub>--</sub> HIT<sub>--</sub> 2 or PC<sub>--</sub> HIT<sub>--</sub> 3 signals is asserted, then output multiplexer 26 does not pass any of the signals provided by multiplexers 25A-25C. In the present example, the PC<sub>--</sub> HIT<sub>--</sub> 1 signal is asserted because the current PC value matches the look-up switch identifier value PC<sub>--</sub> 1 stored in look-up switch identifier memory section 21A. In response to the asserted PC<sub>--</sub> HIT<sub>--</sub> 1 signal, the output signal provided by multiplexer 25A (i.e., the JUMP<sub>--</sub> OFFSET<sub>--</sub> 3 value) is routed through output multiplexer 26 and provided to execution unit 140.</p><p>To summarize, execution unit 140 receives the current PC value and the current look-up switch statement from instruction decode unit 11, and the appropriate jump offset value from look-up switch accelerator 145. In response, execution unit 140 executes the current look-up switch statement.</p><p>Once the PC value, the match values and the jump offset values corresponding to a look-up switch statement have been loaded into one of the memory panels 30A-30C, the look-up switch statement can be subsequently executed without having to access the software code. As a result, the look-up switch statement can be executed much faster than in the prior art. More specifically, a look-up switch statement which previously required hundreds of cycles to execute in the prior art, can be executed in a single cycle in accordance with the present invention, without requiring register access or an ALU operation.</p><p>As previously described, each of memory panels 30A-30C can store values corresponding to a different look-up switch statement. For example, the look-up switch statement corresponding to PC value 200 (See, FIG. 7) can be implemented in memory panel 30B. To accomplish this, the PC value 200 is stored in look-up switch identifier memory section 21B as look-up switch identifier value PC<sub>--</sub> 2, the MATCH values of 1, 6 and 23 are stored as the MATCH<sub>--</sub> 1, MATCH<sub>--</sub> 2 and MATCH<sub>--</sub> 3 entries, respectively, in match memory section 18B, and the JUMP OFFSET values of 299, 300 and -30 are stored as the JUMP<sub>--</sub> OFFSET<sub>--</sub> 1, JUMP<sub>--</sub> OFFSET<sub>--</sub> 2 and JUMP<sub>--</sub> OFFSET<sub>--</sub> 3 values, respectively, in jump offset memory section 20B. The default jump offset value of 199 is stored in a memory (not shown) which provides the default jump offset value DF2 to multiplexer 25B. Memory panel 30B (as well as memory panel 30C) is programmed and accessed in the same manner previously described in connection with memory panel 30A.</p><p>A look-up switch statement having a number of MATCH values greater than N can be handled in several different manners. For example, such a look-up switch statement can be executed in software, external to look-up switch accelerator 145. Alternatively, this look-up switch statement can be divided into a smaller number of look-up switch statements by a compiler. For example, if each of memory panels 30A-30C has 10 entries (i.e., N=10), then a look-up switch statement having 30 MATCH values can be divided into three look-up switch statements, each having 10 MATCH values. The compiler would assign each of these three look-up switch statements a separate PC value to enable these three look-up switch statements to be accessed properly.</p><p>Although the invention has been described in connection with several embodiments, it is understood that this invention is not limited to the embodiments disclosed, but is capable of various modifications which would be apparent to a person skilled in the art. For example, in machines which execute multiple instructions per cycle, such as machines of the superscaler or VLIW type, two or more look-up switch statements can be accelerated in parallel. Moreover, although the look-up switch statements have been described as providing jump offset values which are added to a program counter value, look-up switch statements which provide an absolute program counter value in place of a jump offset value can also be accelerated in accordance with the teachings of the present invention. Thus, the invention is limited only by the following claims.</p><h4>APPENDIX I</h4><h4>The JAVA Virtual Machine Specification</h4><p>\u00a91993, 1994, 1995 Sun Microsystems, Inc. 2550 Garcia Avenue, Mountain View, Calif. 94043-1100 U.S.A.</p><p>All rights reserved. This BETA quality release and related documentation are protected by copyright and distributed under licenses restricting its use, copying, distribution, and decompilation. No part of this release or related documentation may be reproduced in any form by any means without prior written authorization of Sun and its licensors, if any.</p><p>Portions of this product may be derived from the UNIX\u00ae and Berkeley 4.3 BSD systems, licensed from UNIX System Laboratories, Inc. and the University of California, respectively. Third-party font software in this release is protected by copyright and licensed from Sun's Font Suppliers.</p><p>RESTRICTED RIGHTS LEGEND: Use, duplication, or disclosure by the United States Government is subject to the restrictions set forth in DFARS 252.227-7013 (c)(1)(ii) and FAR 52.227-19.</p><p>The release described in this manual may be protected by one or more U.S. patents, foreign patents, or pending applications.</p><h4>TRADEMARKS</h4><p>Sun, Sun Microsystems, Sun Microsystems Computer Corporation, the Sun logo, the Sun Microsystems Computer Corporation logo, WebRunner, JAVA, FirstPerson and the FirstPerson logo and agent are trademarks or registered trademarks of Sun Microsystems, Inc. The \"Duke\" character is a trademark of Sun Microsystems, Inc. and Copyright (c) 1992-1995 Sun Microsystems, Inc. All Rights Reserved. UNIX\u00ae is a registered trademark in the United States and other countries, exclusively licensed through X/Open Company, Ltd. OPEN LOOK is a registered trademark of Novell, Inc. All other product names mentioned herein are the trademarks of their respective owners.</p><p>All SPARC trademarks, including the SCD Compliant Logo, are trademarks or registered trademarks of SPARC International, Inc. SPARCstation, SPARCserver, SPARCengine, SPARCworks, and SPARCompiler are licensed exclusively to Sun Microsystems, Inc. Products bearing SPARC trademarks are based upon an architecture developed by Sun Microsystems, Inc.</p><p>The OPEN LOOK\u00ae and Sun\u2122 Graphical User Interfaces were developed by Sun Microsystems, Inc. for its users and licensees. Sun acknowledges the pioneering efforts of Xerox in researching and developing the concept of visual or graphical user interfaces for the computer industry. Sun holds a non-exclusive license from Xerox to the Xerox Graphical User Interface, which license also covers Sun's licensees who implement OPEN LOOK GUIs and otherwise comply with Sun's written license agreements.</p><p>X Window System is a trademark and product of the Massachusetts Institute of Technology.</p><p>THIS PUBLICATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.</p><p>THIS PUBLICATION COULD INCLUDE TECHNICAL INACCURACIES OR TYPOGRAPHICAL ERRORS. CHANGES ARE PERIODICALLY ADDED TO THE INFORMATION HEREIN; THESE CHANGES WILL BE INCORPORATED IN NEW EDITIONS OF THE PUBLICATION. SUN MICROSYSTEMS, INC. MAY MAKE IMPROVEMENTS AND/OR CHANGES IN THE PRODUCT(S) AND/OR THE PROGRAM(S) DESCRIBED IN THIS PUBLICATION AT ANY TIME.</p><h4>Preface</h4><p>This document describes version 1.0 of the JAVA Virtual Machine and its instruction set. We have written this document to act as a specification for both compiler writers, who wish to target the machine, and as a specification for others who may wish to implement a compliant JAVA Virtual Machine.</p><p>The JAVA Virtual Machine is an imaginary machine that is implemented by emulating it in software on a real machine. Code for the JAVA Virtual Machine is stored in .class files, each of which contains the code for at most one public class.</p><p>Simple and efficient emulations of the JAVA Virtual Machine are possible because the machine's format is compact and efficient bytecodes. Implementations whose native code speed approximates that of compiled C are also possible, by translating the bytecodes to machine code, although Sun has not released such implementations at this time.</p><p>The rest of this document is structured as follows:</p><p>Chapter 1 describes the architecture of the JAVA Virtual Machine;</p><p>Chapter 2 describes the class file format;</p><p>Chapter 3 describes the bytecodes; and</p><p>Appendix A contains some instructions generatedinternally by Sun's implementation of the JAVA Virtual Machine. While not strictly part of the specification we describe these here so that this specification can serve as a reference for our implementation. As more implementations of the JAVA Virtual Machine become available, we may remove Appendix A from future releases.</p><p>Sun will license the JAVA Virtual Machine trademark and logo for use with compliant implementations of this specification. If you are considering constructing your own implementation of the JAVA Virtual Machine please contact us, at the email address below, so that we can work together to insure 100% compatibility of your implementation.</p><p>Send comments on this specification or questions about implementing the JAVA Virtual Machine to our electronic mail address:JAVA@JAVA.sun.com.</p><p>1. JAVA Virtual Machine Architecture</p><p>1.1 Supported Data Types</p><p>The virtual machine data types include the basic data types of the JAVA language:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nbyte        // 1-byte signed 2's complement integer                       \nshort       // 2-byte signed 2's complement integer                       \nint         // 4-byte signed 2's complement integer                       \nlong        // 8-byte signed 2's complement integer                       \nfloat       // 4-byte IEEE 754 single-precision float                     \ndouble      // 8-byte IEEE 754 double-precision float                     \nchar        // 2-byte unsigned Unicode character                          \n______________________________________                                    \n</pre><p>Nearly all JAVA type checking is done at compile time. Data of the primitive types shown above need not be tagged by the hardware to allow execution of JAVA. Instead, the bytecodes that operate on primitive values indicate the types of the operands so that, for example, the iadd, ladd, fadd, and dadd instructions each add two numbers, whose types are int, long, float, and double, respectively</p><p>The virtual machine doesn't have separate instructions for boolean types. Instead, integer instructions, including integer returns, are used to operate on boolean values; byte arrays are used for arrays of boolean.</p><p>The virtual machine specifies that floating point be done in IEEE 754 format, with support for gradual underflow. Older computer architectures that do not have support for IEEE format may run JAVA numeric programs very slowly.</p><p>Other virtual machine data types include:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nobject          // 4-byte reference to a JAVA                             \n                object                                                    \nreturnAddress   // 4 bytes, used with                                     \n                jsr/ret/jsr.sub.-- w/ret.sub.-- w instructions            \n______________________________________                                    \n</pre><p>Note: JAVA arrays are treated as objects.</p><p>This specification does not require any particular internal structure for objects. In our implementation an object reference is to a handle, which is a pair of pointers: one to a method table for the object, and the other to the data allocated for the object. Other implementations may use inline caching, rather than method table dispatch; such methods are likely to be faster on hardware that is emerging between now and the year 2000.</p><p>Programs represented by JAVA Virtual Machine bytecodes are expected to maintain proper type discipline and an implementation may refuse to execute a bytecode program that appears to violate such type discipline.</p><p>While the JAVA Virtual Machines would appear to be limited by the bytecode deonition to running on a 32-bit address space machine, it is possible to build a version of the JAVA Virtual Machine that automatically translates the bytecodes into a 64-bit form. A description of this transformation is beyond the scope of the JAVA Virtual Machine Specification.</p><p>1.2 Registers</p><p>At any point the virtual machine is executing the code of a single method, and the pc register contains the address of the next bytecode to be executed.</p><p>Each method has memory space allocated for it to hold:</p><p>a set of local variables, referenced by a vars register;</p><p>an operand stack, referenced by an optop register; and</p><p>a execution environment structure, referenced by a frame register.</p><p>All of this space can be allocated at once, since the size of the local variables and operand stack are known at compile time, and the size of the execution environment structure is well-known to the interpreter.</p><p>All of these registers are 32 bits wide.</p><p>1.3 Local Variables</p><p>Each JAVA method uses a fixed-sized set of local variables. They are addressed as word offsets from the vars register. Local variables are all 32 bits wide.</p><p>Long integers and double precision floats are considered to take up two local variables but are addressed by the index of the first local variable. (For example, a local variable with index containing a double precision float actually occupies storage at indices n and n+1.) The virtual machine specification does not require 64-bit values in local variables to be 64-bit aligned. Implementors are free to decide the appropriate way to divide long integers and double precision floats into two words.</p><p>Instructions are provided to load the values of local variables onto the operand stack and store values from the operand stack into local variables.</p><p>1.4 The Operand Stack</p><p>The machine instructions all take operands from an operand stack, operate on them, and return results to the stack. We chose a stack organization so that it would be easy to emulate the machine efficiently on machines with few or irregular registers such as the Intel 486 microprocessor.</p><p>The operand stack is 32 bits wide. It is used to pass parameters to methods and receive method results, as well as to supply parameters for operations and save operation results.</p><p>For example, execution of instruction iadd adds two integers together. It expects that the two integers are the top two words on the operand stack, and were pushed there by previous instructions. Both integers are popped from the stack, added, and their sum pushed back onto the operand stack. Subcomputations may be nested on the operand stack, and result in a single operand that can be used by the nesting computation.</p><p>Each primitive data type has specialized instructions that know how to operate on operands of that type. Each operand requires a single location on the stack, except for long and double operands, which require two locations.</p><p>Operands must be operated on by operators appropriate to their type. It is illegal, for example, to push two integers and then treat them as a long. This restriction is enforced, in the Sun implementation, by the bytecode verifier. However, a small number of operations (the dup opcodes and swap) operate on runtime data areas as raw values of a given width without regard to type.</p><p>In our description of the virtual machine instructions below, the effect of an instruction's execution on the operand stack is represented textually, with the stack growing from left to right, and each 32-bit word separately represented. Thus:</p><p>Stack: . . . , value1, value2 \u2192. . . , value3</p><p>shows an operation that begins by having value2 on top of the stack with value1 just beneath it. As a result of the execution of the instruction, value1 and value2 are popped from the stack and replaced by value3, which has been calculated by the instruction. The remainder of the stack, represented by an ellipsis, is unaffected by the instruction's execution.</p><p>The types long and double take two 32-bit words on the operand stack:</p><p>Stack: . . . \u2192. . . , value-word1,value-word2</p><p>This specification does not say how the two words are selected from the 64-bit long or double value; it is only necessary that a particular implementation be internally consistent.</p><p>1.5 Execution Environment</p><p>The information contained in the execution environment is used to do dynamic linking, normal method returns, and exception propagation.</p><p>1.5.1 Dynamic Linking</p><p>The execution environment contains references to the interpreter symbol table for the current method and current class, in support of dynamic linking of the method code. The class file code for a method refers to methods to be called and variables to be accessed symbolically. Dynamic linking translates these symbolic method calls into actual method calls, loading classes as necessary to resolve as-yet-undefined symbols, and translates variable accesses into appropriate offsets in storage structures associated with the runtime location of these variables.</p><p>This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.</p><p>1.5.2 Normal Method Returns</p><p>If execution of the current method completes normally, then a value is returned to the calling method. This occurs when the calling method executes a return instruction appropriate to the return type.</p><p>The execution environment is used in this case to restore the registers of the caller, with the program counter of the caller appropriately incremented to skip the method call instruction. Execution then continues in the calling method's execution environment.</p><p>1.5.3 Exception and Error Propagation</p><p>An exceptional condition, known in JAVA as an Error or Exception, which are subclasses of Throwable, may arise in a program because of:</p><p>a dynamic linkage failure, such as a failure to find a needed class file;</p><p>a run-time error, such as a reference through a null pointer;</p><p>an asynchronous event, such as is thrown by Thread.stop, from another thread; and</p><p>the program using a throw statement.</p><p>When an exception occurs:</p><p>A list of catch clauses associated with the current method is examined. Each catch clause describes the instruction range for which it is active, describes the type of exception that it is to handle, and has the address of the code to handle it.</p><p>An exception matches a catch clause if the instruction that caused the exception is in the appropriate instruction range, and the exception type is a subtype of the type of exception that the catch clause handles. If a matching catch clause is found, the system branches to the specified handler. If no handler is found, the process is repeated until all the nested catch clauses of the current method have been exhausted.</p><p>The order of the catch clauses in the list is important. The virtual machine execution continues at the first matching catch clause. Because JAVA code is structured, it is always possible to sort all the exception handlers for one method into a single list that, for any possible program counter value, can be searched in linear order to find the proper (innermost containing applicable) exception handler for an exception occurring at that program counter value.</p><p>If there is no matching catch clause then the current method is said to have as its outcome the uncaught exception. The execution state of the method that called this method is restored from the execution environment, and the propagation of the exception continues, as though the exception had just occurred in this caller.</p><p>1.5.4 Additional Information</p><p>The execution environment may be extended with additional implementation-specified information, such as debugging information.</p><p>1.6 Garbage Collected Heap</p><p>The JAVA heap is the runtime data area from which class instances (objects) are allocated. The JAVA language is designed to be garbage collected--it does not give the programmer the ability to deallocate objects explicitly. The JAVA language does not presuppose any particular kind of garbage collection; various algorithms may be used depending on system requirements.</p><p>1.7 Method Area</p><p>The method area is analogous to the store for compiled code in conventional languages or the text segment in a UNIX process. It stores method code (compiled JAVA code) and symbol tables. In the current JAVA implementation, method code is not part of the garbage-collected heap, although this is planned for a future release.</p><p>1.8 The JAVA Instruction Set</p><p>An instruction in the JAVA instruction set consists of a one-byte opcode specifying the operation to be performed, and zero or more operands supplying parameters or data that will be used by the operation. Many instructions have no operands and consist only of an opcode.</p><p>The inner loop of the virtual machine execution is effectively:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndo {                                                                      \n fetch an opcode byte                                                     \n execute an action depending on the value of                              \n the opcode                                                               \n} while (there is more to do);                                            \n______________________________________                                    \n</pre><p>The number and size of the additional operands is determined by the opcode. If an additional operand is more than one byte in size, then it is stored in big-endian order--high order byte first. For example, a 16-bit parameter is stored as two bytes whose value is:</p><p>first<sub>--</sub> byte*256+second<sub>--</sub> byte</p><p>The bytecode instruction stream is only byte-aligned, with the exception being the tableswitch and lookupswitch instructions, which force alignment to a 4-byte boundary within their instructions.</p><p>These decisions keep the virtual machine code for a compiled JAVA program compact and reflect a conscious bias in favor of compactness at some possible cost in performance.</p><p>1.9 Limitations</p><p>The per-class constant pool has a maximum of 65535 entries. This acts as an internal limit on the total complexity of a single class.</p><p>The amount of code per method is limited to 65535 bytes by the sizes of the indices in the code in the exception table, the line number table, and the local variable table.</p><p>Besides this limit, the only other limitation of note is that the number of words of arguments in a method call is limited to 255.</p><p>2. Class File Format</p><p>This chapter documents the JAVA class (.class) file format.</p><p>Each class file contains the compiled version of either a JAVA class or a JAVA interface. Compliant JAVA interpreters must be capable of dealing with all class files that conform to the following specification.</p><p>A JAVA class file consists of a stream of 8-bit bytes. All 16-bit and 32-bit quantities are constructed by reading in two or four 8-bit bytes, respectively. The bytes are joined together in network (big-endian) order, where the high bytes come first. This format is supported by the JAVA JAVA.io.DataInput and JAVA.io.DataOutput interfaces, and classes such as JAVA.io.DataInputStream and JAVA.io.DataOutputStream.</p><p>The class file format is described here using a structure notation. Successive fields in the structure appear in the external representation without padding or alignment. Variable size arrays, often of variable sized elements, are called tables and are commonplace in these structures.</p><p>The types u1, u2, and u4 mean an unsigned one-, two-, or four-byte quantity, respectively, which are read by method such as readUnsignedByte, readUnsignedShort and readint of the JAVA.io.DataInput interface.</p><p>2.1 Format</p><p>The following pseudo-structure gives a top-level description of the format of a class file:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nClassFile {                                                               \n u4 magic;                                                                \n u2 minor.sub.-- version;                                                 \n u2 major.sub.-- version;                                                 \n u2 constant.sub.-- pool.sub.-- count;                                    \n cp.sub.-- info constant.sub.-- pool [constant.sub.-- pool.sub.-- count - \n1];                                                                       \n u2 access.sub.-- flags;                                                  \n u2 this.sub.-- class;                                                    \n u2 super.sub.-- class;                                                   \n u2 interfaces.sub.-- count;                                              \n u2 interfaces [interfaces.sub.-- count];                                 \n u2 fields.sub.-- count;                                                  \n field.sub.-- info fields [fields.sub.-- count]                           \n u2 methods.sub.-- count;                                                 \n method.sub.-- info methods [methods.sub.-- count];                       \n u2 attributes.sub.-- count;                                              \n attribute.sub.-- info attributes [attribute.sub.-- count];               \n______________________________________                                    \n</pre><p>magic</p><p>This field must have the value OxCAFEBABE.</p><p>minor<sub>--</sub> version, major<sub>--</sub> version</p><p>These fields contain the version number of the JAVA compiler that produced this class file. An implementation of the virtual machine will normally support some range of minor version numbers 0-n of a particular major version number. If the minor version number is incremented the new code won't run on the old virtual machines, but it is possible to make a new virtual machine which can run versions up to n+1.</p><p>A change of the major version number indicates a major incompatible change, one that requires a different virtual machine that may not support the old major version in any way.</p><p>The current major version number is 45; the current minor version number is 3.</p><p>constant<sub>--</sub> pool<sub>--</sub> count</p><p>This field indicates the number of entries in the constant pool in the class file.</p><p>constant<sub>--</sub> pool</p><p>The constant pool is a table of values. These values are the various string constants, class names, field names, and others that are referred to by the class structure or by the code.</p><p>constant<sub>--</sub> pool[0] is always unused by the compiler, and may be used by an implementation for any purpose.</p><p>Each of the constant<sub>--</sub> pool entries 1 through constant<sub>--</sub> pool<sub>--</sub> count-1 is a variable-length entry, whose format is given by the first \"tag\" byte, as described in section 2.3.</p><p>access<sub>--</sub> flags</p><p>This field contains a mask of up to sixteen modifiers used with class, method, and field declarations. The same encoding is used on similar fields in field<sub>--</sub> info and method<sub>--</sub> info as described below. Here is the encoding:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->__________________________________________________________________________\nFlag Name    Value Meaning      Used By                                   \n__________________________________________________________________________\nACC.sub.-- PUBLIC                                                         \n             0 \u00d7 0001                                               \n                   Visible to everyone                                    \n                                Class,                                    \n                                Method,                                   \n                                Variable                                  \nACC.sub.-- PRIVATE                                                        \n             0 \u00d7 0002                                               \n                   Visible only to the                                    \n                                Method,                                   \n                   defining class                                         \n                                Variable                                  \nACC.sub.-- PROTECTED                                                      \n             0 \u00d7 0004                                               \n                   Visible to subclasses                                  \n                                Method,                                   \n                                Variable                                  \nACC.sub.-- STATIC                                                         \n             0 \u00d7 0008                                               \n                   Variable or method is                                  \n                                Method,                                   \n                   static       Variable                                  \nACC.sub.-- FINAL                                                          \n             0 \u00d7 0010                                               \n                   No further subclassing,                                \n                                Class,                                    \n                   overriding, or assignment                              \n                                Method,                                   \n                   after initialization                                   \n                                Variable                                  \nACC.sub.-- SYNCHRONIZED                                                   \n             0 \u00d7 0020                                               \n                   Wrap use in monitor lock                               \n                                Method                                    \nACC.sub.-- VOLATILE                                                       \n             0 \u00d7 0040                                               \n                   Can't cache  Variable                                  \nACC.sub.-- TRANSIENT                                                      \n             0 \u00d7 0080                                               \n                   Not to be written or read                              \n                                Variable                                  \n                   by a persistent object                                 \n                   manager                                                \nACC.sub.-- NATIVE                                                         \n             0 \u00d7 0100                                               \n                   Implemented in a language                              \n                                Method                                    \n                   other than JAVA                                        \nACC.sub.-- INTERFACE                                                      \n             0 \u00d7 0200                                               \n                   Is an interface                                        \n                                Class                                     \nACC.sub.-- ABSTRACT                                                       \n             0 \u00d7 0400                                               \n                   No body provided                                       \n                                Class,                                    \n                                Method                                    \n__________________________________________________________________________\n</pre><p>this<sub>--</sub> class</p><p>This field is an index into the constant pool; constant<sub>--</sub> pool [this<sub>--</sub> class] must be a CONSTANT<sub>--</sub> class.</p><p>super<sub>--</sub> class</p><p>This field is an index into the constant pool. If the value of super<sub>--</sub> class is nonzero, then constant<sub>--</sub> pool [super<sub>--</sub> class] must be a class, and gives the index of this class's superclass in the constant pool.</p><p>If the value of super<sub>--</sub> class is zero, then the class being defined must be JAVA.lang.Object, and it has no superclass.</p><p>interfaces<sub>--</sub> count</p><p>This field gives the number of interfaces that this class implements.</p><p>interfaces</p><p>Each value in this table is an index into the constant pool. If a table value is nonzero (interfaces[i] !=0, where 0\u2266=i &lt;interfaces<sub>--</sub> count), then constant<sub>--</sub> pool [interfaces[i]] must be an interface that this class implements.</p><p>fields<sub>--</sub> count</p><p>This field gives the number of instance variables, both static and dynamic, defined by this class. The fields table includes only those variables that are defined explicitly by this class. It does not include those instance variables that are accessible from this class but are inherited from superclasses.</p><p>fields</p><p>Each value in this table is a more complete description of a field in the class. See section 2.4 for more information on the field<sub>--</sub> info structure.</p><p>methods<sub>--</sub> count</p><p>This field indicates the number of methods, both static and dynamic, defined by this class. This table only includes those methods that are explicitly defined by this class. It does not include inherited methods.</p><p>methods</p><p>Each value in this table is a more complete description of a method in the class. See section 2.5 for more information on the method<sub>--</sub> info structure.</p><p>attributes<sub>--</sub> count</p><p>This field indicates the number of additional attributes about this class.</p><p>attributes</p><p>A class can have any number of optional attributes associated with it. Currently, the only class attribute recognized is the \"SourceFile\" attribute, which indicates the name of the source file from which this class file was compiled. See section 2.6 for more information on the attribute<sub>--</sub> info structure.</p><p>2.2 Signatures</p><p>A signature is a string representing a type of a method, field or array.</p><p>The field signature represents the value of an argument to a function or the value of a variable. It is a series of bytes generated by the following grammar:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n&lt;field.sub.-- signature&gt; ::= &lt;field.sub.-- type&gt;                          \n&lt;field.sub.-- type&gt; ::= &lt;base.sub.-- type&gt;|&lt;object.sub.--        \ntype&gt;|                                                           \n        &lt;array.sub.-- type&gt;                                               \n&lt;base.sub.-- type&gt; :: = B|C|D|F|I.vert\nline.J|S|Z                                              \n&lt;object.sub.-- type&gt; ::= L&lt;fullclassname&gt;;                                \n&lt;array.sub.-- type&gt; ::= &lt;optional.sub.-- size&gt;&lt;field.sub.-- type&gt;         \n&lt;optional.sub.-- size&gt; ::= [0-9]                                          \nThe meaning of the base types is as follows:                              \nB               byte       signed byte                                    \nC               char       character                                      \nD               double     double                                         \n                           precision IEEE                                 \n                           float                                          \nF               float      single                                         \n                           precision IEEE                                 \n                           float                                          \nI               int        integer                                        \nJ               long       long integer                                   \nL&lt;fullclassname&gt;;                                                         \n                . . .      an object of                                   \n                           the given                                      \n                           class                                          \nS               short      signed short                                   \nZ               boolean    true or false                                  \n[&lt;field sig&gt;    . . .      array                                          \n______________________________________                                    \n</pre><p>A return-type signature represents the return value from a method. It is a series of bytes in the following grammar:</p><p>&lt;return<sub>--</sub> signature&gt;::=&lt;field<sub>--</sub> type&gt;|V</p><p>The character V indicates that the method returns no value. Otherwise, the signature indicates the type of the return value.</p><p>An argument signature represents an argument passed to a method:</p><p>&lt;argument<sub>--</sub> signature&gt;::=&lt;field<sub>--</sub> type&gt;</p><p>A method signature represents the arguments that the method expects, and the value that it returns.</p><p>&lt;method<sub>--</sub> signature&gt;::=(&lt;arguments<sub>--</sub> signature&gt;) &lt;return<sub>--</sub> signature&gt;</p><p>&lt;arguments<sub>--</sub> signature&gt;::=&lt;argument<sub>--</sub> signature&gt;*</p><p>2.3 Constant Pool</p><p>Each item in the constant pool begins with a 1-byte tag:. The table below lists the valid tags and their values.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nConstant Type        Value                                                \n______________________________________                                    \nCONSTANT.sub.-- Class                                                     \n                     7                                                    \nCONSTANT.sub.-- Fieldref                                                  \n                     9                                                    \nCONSTANT.sub.-- Methodref                                                 \n                     10                                                   \nCONSTANT.sub.-- InterfaceMethodref                                        \n                     11                                                   \nCONSTANT.sub.-- String                                                    \n                     8                                                    \nCONSTANT.sub.-- Integer                                                   \n                     3                                                    \nCONSTANT.sub.-- Float                                                     \n                     4                                                    \nCONSTANT.sub.-- Long 5                                                    \nCONSTANT.sub.-- Double                                                    \n                     6                                                    \nCONSTANT.sub.-- NameAndType                                               \n                     12                                                   \nCONSTANT.sub.-- Utf8 1                                                    \nCONSTANT.sub.-- Unicode                                                   \n                     2                                                    \n______________________________________                                    \n</pre><p>Each tag byte is then followed by one or more bytes giving more information about the specific constant.</p><p>2.3.1 CONSTANT<sub>--</sub> Class</p><p>CONSTANT<sub>--</sub> Class is used to represent a class or an interface.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n         CONSTANT.sub.-- Class.sub.-- info {                              \n          u1 tag;                                                         \n          u2 name.sub.-- index;                                           \n         }                                                                \n______________________________________                                    \n</pre><p>tag</p><p>The tag will have the value CONSTANT<sub>--</sub> Class</p><p>name<sub>--</sub> index</p><p>constant pool[name<sub>--</sub> index] is a CONSTANT<sub>--</sub> Utf8 giving the string name of the class.</p><p>Because arrays are objects, the opcodes anewarray and multianewarray can reference array \"classes\" via CONSTANT<sub>--</sub> Class items in the constant pool. In this case, the name of the class is its signature. For example, the class name for</p><p>int[][]</p><p>is</p><p>[[I</p><p>The class name for</p><p>Thread[]</p><p>is</p><p>\"[LJAVA.lang.Thread;\"</p><p>2.3.2 CONSTANT<sub>--</sub> {Fieldref,Methodref, InterfaceMethodref}</p><p>Fields, methods, and interface methods are represented by similar structures.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nCONSTANT.sub.-- Fieldref.sub.-- info {                                    \n u1 tag;                                                                  \n u2 class.sub.-- index;                                                   \n u2 name.sub.-- and.sub.-- type.sub.-- index;                             \nCONSTANT.sub.-- Methodref.sub.-- info {                                   \n u1 tag;                                                                  \n u2 class.sub.-- index;                                                   \n u2 name.sub.-- and.sub.-- type.sub.-- index;                             \n}                                                                         \nCONSTANT.sub.-- InterfaceMethodref.sub.-- info {                          \n u1 tag;                                                                  \n u2 class.sub.-- index;                                                   \n u2 name.sub.-- and.sub.-- type.sub.-- index;                             \n}                                                                         \n______________________________________                                    \n</pre><p>tag</p><p>The tag will have the value CONSTANT<sub>--</sub> Fieldref, CONSTANT<sub>--</sub> Methodref, or CONSTANT<sub>--</sub> InterfaceMethodref.</p><p>class<sub>--</sub> index</p><p>constant<sub>--</sub> pool[class<sub>--</sub> index] will be an entry of type CONSTANT<sub>--</sub> Class giving the name of the class or interface containing the field or method.</p><p>For CONSTANT<sub>--</sub> Fieldref and CONSTANT<sub>--</sub> Methodref, the CONSTANT<sub>--</sub> Class item must be an actual class. For CONSTANT<sub>--</sub> InterfaceMethodref, the item must be an interface which purports to implement the given method.</p><p>name<sub>--</sub> and<sub>--</sub> type<sub>--</sub> index</p><p>constant<sub>--</sub> pool [name<sub>--</sub> and<sub>--</sub> type<sub>--</sub> index] will be an entry of type CONSTANT<sub>--</sub> NameAndType. This constant pool entry indicates the name and signature of the field or method.</p><p>2.3.3 CONSTANT<sub>--</sub> String</p><p>CONSTANT<sub>--</sub> String is used to represent constant objects of the built-in type String.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n         CONSTANT.sub.-- String.sub.-- info {                             \n          u1 tag;                                                         \n          u2 string.sub.-- index;                                         \n         }                                                                \n______________________________________                                    \n</pre><p>tag</p><p>The tag will have the value CONSTANT<sub>--</sub> String</p><p>string<sub>--</sub> index</p><p>constant<sub>--</sub> pool [string<sub>--</sub> index] is a CONSTANT<sub>--</sub> Utf8 string giving the value to which the String object is initialized.</p><p>2.3.4 CONSTANT<sub>--</sub> Integer and CONSTANT<sub>--</sub> Float</p><p>CONSTANT<sub>--</sub> Integer andCONSTANT<sub>--</sub> Float represent four-byte constants.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n         CONSTANT.sub.-- Integer.sub.-- info {                            \n          u1 tag;                                                         \n          u4 bytes;                                                       \n         }                                                                \n         CONSTANT.sub.-- Float.sub.-- info {                              \n          u1 tag;                                                         \n          u4 bytes;                                                       \n         }                                                                \n______________________________________                                    \n</pre><p>tag</p><p>The tag will have the value CONSTANT<sub>--</sub> Integer or CONSTANT<sub>--</sub> Float</p><p>bytes</p><p>For integers, the four bytes are the integer value. For floats, they are the IEEE 754 standard representation of the floating point value. These bytes are in network (high byte first) order.</p><p>2.3.5 CONSTANT<sub>--</sub> Long and CONSTANT<sub>--</sub> Double</p><p>CONSTANT<sub>--</sub> Long andCONSTANT<sub>--</sub> Double represent eight-byte constants.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n         CONSTANT.sub.-- Long.sub.-- info {                               \n          u1 tag;                                                         \n          u4 high.sub.-- bytes;                                           \n          u4 low.sub.-- bytes;                                            \n         }                                                                \n         CONSTANT.sub.-- Double.sub.-- info {                             \n          u1 tag;                                                         \n          u4 high.sub.-- bytes;                                           \n          u4 low.sub.-- bytes;                                            \n         }                                                                \n______________________________________                                    \n</pre><p>All eight-byte constants take up two spots in the constant pool. If this is the n<sup>th</sup> item in the constant pool, then the next item will be numbered n+2.</p><p>tag</p><p>The tag will have the value CONSTANT<sub>--</sub> Long or CONSTANT<sub>--</sub> Double.</p><p>high<sub>--</sub> bytes, low<sub>--</sub> bytes</p><p>For CONSTANT<sub>--</sub> Long, the 64-bit value is (high<sub>--</sub> bytes&lt;&lt;32)+low<sub>--</sub> bytes.</p><p>For CONSTANT<sub>--</sub> Double, the 64-bit value, high<sub>--</sub> bytes and low<sub>--</sub> bytes together represent the standard IEEE 754 representation of the double-precision floating point number.</p><p>2.3.6 CONSTANT<sub>--</sub> NameAndType</p><p>CONSTANT<sub>--</sub> NameAndType is used to represent a field or method, without indicating which class it belongs to.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n       CONSTANT.sub.-- NameAndType.sub.-- info {                          \n        u1 tag;                                                           \n        u2 name.sub.-- index;                                             \n        u2 signature.sub.-- index;                                        \n       }                                                                  \n______________________________________                                    \n</pre><p>tag</p><p>The tag will have the valueCONSTANT<sub>--</sub> NameAndType.</p><p>name<sub>--</sub> index</p><p>constant<sub>--</sub> pool [name<sub>--</sub> index] is a CONSTANT<sub>--</sub> Utf8 string giving the name of the field or method.</p><p>signature<sub>--</sub> index</p><p>constant<sub>--</sub> pool [signature<sub>--</sub> index] is a CONSTANT<sub>--</sub> Utf8 string giving the signature of the field or method.</p><p>2.3.7 CONSTANT<sub>--</sub> Utf8 and CONSTANT<sub>--</sub> Unicode</p><p>CONSTANT<sub>--</sub> Utf8 andCONSTANT<sub>--</sub> Unicode are used to represent constant string values.</p><p>CONSTANT<sub>--</sub> Utf8 strings are \"encoded\" so that strings containing only non-null ASCII characters, can be represented using only one byte per character, but characters of up to 16 bits can be represented:</p><p>All characters in the range 0x0001 to 0x007F are represented by a single byte: ##STR1##</p><p>The null character (0x0000) and characters in the range 0x0080 to 0x07FF are represented by a pair of two bytes: ##STR2##</p><p>Characters in the range 0x0800 to 0xFFFF are represented by three bytes: ##STR3##</p><p>There are two differences between this format and the \"standard\" UTF-8 format. First, the null byte (0x00) is encoded in two-byte format rather than one-byte, so that our strings never have embedded nulls. Second, only the one-byte, two-byte, and three-byte formats are used. We do not recognize the longer formats.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n        CONSTANT.sub.-- Utf8.sub.-- info {                                \n         u1 tag;                                                          \n         u2 length;                                                       \n         u1 bytes [length];                                               \n        }                                                                 \n        CONSTANT.sub.-- Unicode.sub.-- info {                             \n         u1 tag;                                                          \n         u2 length;                                                       \n         u2 bytes [length];                                               \n        }                                                                 \n______________________________________                                    \n</pre><p>tag</p><p>The tag will have the value CONSTANT<sub>--</sub> Utf8 or CONSTANT<sub>--</sub> Unicode.</p><p>length</p><p>The number of bytes in the string. These strings are not null terminated.</p><p>bytes</p><p>The actual bytes of the string.</p><p>2.4 Fields</p><p>The information for each field immediately follows the field<sub>--</sub> count field in the class file. Each field is described by a variable length field<sub>--</sub> info structure. The format of this structure is as follows:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfield.sub.-- info {                                                       \n u2 access.sub.-- flags;                                                  \n u2 name.sub.-- index;                                                    \n u2 signature.sub.-- index;                                               \n u2 attributes.sub.-- count;                                              \n attribute.sub.-- info attributes [attribute.sub.-- count];               \n______________________________________                                    \n</pre><p>access<sub>--</sub> flags</p><p>This is a set of sixteen flags used by classes, methods, and fields to describe various properties and how they many be accessed by methods in other classes. See the table \"Access Flags\" which indicates the meaning of the bits in this field.</p><p>The possible fields that can be set for a field are ACC<sub>--</sub> PUBLIC, ACC<sub>--</sub> PRIVATE, ACC<sub>--</sub> PROTECTED, ACC<sub>--</sub> STATIC, ACC<sub>--</sub> FINAL, ACC<sub>--</sub> VOLATILE, and ACC<sub>--</sub> TRANSIENT.</p><p>At most one of ACC<sub>--</sub> PUBLIC, ACC<sub>--</sub> PROTECTED, and ACC<sub>--</sub> PRIVATE can be set for any method.</p><p>name<sub>--</sub> index</p><p>constant<sub>--</sub> pool [name<sub>--</sub> index] is a CONSTANT<sub>--</sub> Utf8 string which is the name of the field.</p><p>signature<sub>--</sub> index</p><p>constant<sub>--</sub> pool [signature<sub>--</sub> index] is a CONSTANT<sub>--</sub> Utf8 string which is the signature of the field. See the section \"Signatures\" for more information on signatures.</p><p>attributes<sub>--</sub> count</p><p>This value indicates the number of additional attributes about this field.</p><p>attributes</p><p>A field can have any number of optional attributes associated with it. Currently, the only field attribute recognized is the \"ConstantValue\" attribute, which indicates that this field is a static numeric constant, and indicates the constant value of that field.</p><p>Any other attributes are skipped.</p><p>2.5 Methods</p><p>The information for each method immediately follows the method<sub>--</sub> count field in the class file. Each method is described by a variable length method<sub>--</sub> info structure. The structure has the following format:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nmethod.sub.-- info {                                                      \n u2 access.sub.-- flags;                                                  \n u2 name.sub.-- index;                                                    \n u2 signature.sub.-- index;                                               \n u2 attributes.sub.-- count;                                              \n attribute.sub.-- info attributes [attribute.sub.-- count];               \n______________________________________                                    \n</pre><p>access<sub>--</sub> flags</p><p>This is a set of sixteen flags used by classes, methods, and fields to describe various properties and how they many be accessed by methods in other classes. See the table \"Access Flags\" which gives the various bits in this field.</p><p>The possible fields that can be set for a method are ACC<sub>--</sub> PUBLIC, ACC<sub>--</sub> PRIVATE, ACC<sub>--</sub> PROTECTED, ACC<sub>--</sub> STATIC, ACC<sub>--</sub> FINAL, ACC<sub>--</sub> SYNCHRONIZED, ACC<sub>--</sub> NATIVE, and ACC<sub>--</sub> ABSTRACT.</p><p>At most one of ACC<sub>--</sub> PUBLIC, ACC<sub>--</sub> PROTECTED, and ACC<sub>--</sub> PRIVATE can be set for any method.</p><p>name<sub>--</sub> index</p><p>constant<sub>--</sub> pool[name<sub>--</sub> index] is a CONSTANT<sub>--</sub> Utf8 string giving the name of the method.</p><p>signature<sub>--</sub> index</p><p>constant<sub>--</sub> pool [signature<sub>--</sub> index] is a CONSTANT<sub>--</sub> Utf8 string giving the signature of the field. See the section \"Signatures\" for more information on signatures.</p><p>attributes<sub>--</sub> count</p><p>This value indicates the number of additional attributes about this field.</p><p>attributes</p><p>A field can have any number of optional attributes associated with it. Each attribute has a name, and other additional information. Currently, the only field attributes recognized are the \"Code\" and \"Exceptions\" attributes, which describe the bytecodes that are executed to perform this method, and the JAVA Exceptions which are declared to result from the execution of the method, respectively.</p><p>Any other attributes are skipped.</p><p>2.6 Attributes</p><p>Attributes are used at several different places in the class format. All attributes have the following format:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n         GenericAttribute.sub.-- info {                                   \n          u2 attribute.sub.-- name;                                       \n          u4 attribute.sub.-- length;                                     \n          u1 info [attribute.sub.-- length];                              \n         }                                                                \n______________________________________                                    \n</pre><p>The attribute<sub>--</sub> name is a 16-bit index into the class's constant pool; the value of constant<sub>--</sub> pool [attribute<sub>--</sub> name] is a CONSTANT<sub>--</sub> Utf8 string giving the name of the attribute. The field attribute<sub>--</sub> length indicates the length of the subsequent information in bytes. This length does not include the six bytes of the attribute<sub>--</sub> name and attribute<sub>--</sub> length.</p><p>In the following text, whenever we allow attributes, we give the name of the attributes that are currently understood. In the future, more attributes will be added. Class file readers are expected to skip over and ignore the information in any attribute they do not understand.</p><p>2.6.1 SourceFile</p><p>The \"SourceFile\" attribute has the following format:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n         SourceFile.sub.-- attribute {                                    \n          u2 attribute.sub.-- name.sub.-- index;                          \n          u4 attribute.sub.-- length;                                     \n          u2 sourcefile.sub.-- index;                                     \n         }                                                                \n______________________________________                                    \n</pre><p>attribute<sub>--</sub> name<sub>--</sub> index</p><p>constant<sub>--</sub> pool [attribute<sub>--</sub> name<sub>--</sub> index] is the CONSTANT<sub>--</sub> Utf8 string \"SourceFile\".</p><p>attribute<sub>--</sub> length</p><p>The length of a SourceFile<sub>--</sub> attribute must be 2.</p><p>sourcefile<sub>--</sub> index</p><p>constant<sub>--</sub> pool [sourcefile<sub>--</sub> index] is a CONSTANT<sub>--</sub> Utf8 string giving the source file from which this class file was compiled.</p><p>2.6.2 ConstantValue</p><p>The \"ConstantValue\" attribute has the following format:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n         ConstantValue.sub.-- attribute {                                 \n          u2 attribute.sub.-- name.sub.-- index;                          \n          u4 attribute.sub.-- length;                                     \n          u2 constantvalue.sub.-- index;                                  \n         }                                                                \n______________________________________                                    \n</pre><p>attribute<sub>--</sub> name<sub>--</sub> index</p><p>constant<sub>--</sub> pool [attribute<sub>--</sub> name<sub>--</sub> index] is the CONSTANT<sub>--</sub> Utf8 string \"ConstantValue\".</p><p>attribute<sub>--</sub> length</p><p>The length of a ConstantValue<sub>--</sub> attribute must be 2.</p><p>constantvalue<sub>--</sub> index</p><p>constant pool [constantvalue<sub>--</sub> index] gives the constant value for this field.</p><p>The constant pool entry must be of a type appropriate to the field, as shown by the following table:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlong                CONSTANT.sub.-- Long                                  \nfloat               CONSTANT.sub.-- Float                                 \ndouble              CONSTANT.sub.-- Double                                \nint, short, char, byte, boolean                                           \n                    CONSTANT.sub.-- Integer                               \n______________________________________                                    \n</pre><p>2.6.3 Code</p><p>The \"Code\" attribute has the following format:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nCode.sub.-- attribute {                                                   \n u2 attribute.sub.-- name.sub.-- index;                                   \n u4 attribute.sub.-- length;                                              \n u2 max.sub.-- stack;                                                     \n u2 max.sub.-- locals;                                                    \n u4 code.sub.-- length;                                                   \n u1 code [code.sub.-- length];                                            \n u2 exception.sub.-- table.sub.-- length;                                 \n {  u2  start.sub.-- pc;                                                  \n    u2  end.sub.-- pc;                                                    \n    u2  handler.sub.-- pc;                                                \n    u2  catch.sub.-- type;                                                \n } exception.sub.-- table [exception.sub.-- table.sub.-- length];         \n u2 attributes.sub.-- count;                                              \n attribute.sub.-- info.sub.-- attributes [attribute.sub.-- count];        \n______________________________________                                    \n</pre><p>attribute<sub>--</sub> name<sub>--</sub> index</p><p>constant<sub>--</sub> pool [attribute<sub>--</sub> name<sub>--</sub> index] is the CONSTANT<sub>--</sub> Utf8 string \"Code\".</p><p>attribute<sub>--</sub> length</p><p>This field indicates the total length of the \"Code\" attribute, excluding the initial six bytes.</p><p>max<sub>--</sub> stack</p><p>Maximum number of entries on the operand stack that will be used during execution of this method. See the other chapters in this spec for more information on the operand stack.</p><p>max<sub>--</sub> locals</p><p>Number of local variable slots used by this method. See the other chapters in this spec for more information on the local variables.</p><p>code<sub>--</sub> length</p><p>The number of bytes in the virtual machine code for this method.</p><p>code</p><p>These are the actual bytes of the virtual machine code that implement the method. When read into memory, if the first byte of code is aligned onto a multiple-of-four boundary the tableswitch and tablelookup opcode entries will be aligned; see their description for more information on alignment requirements.</p><p>exception<sub>--</sub> table<sub>--</sub> length</p><p>The number of entries in the following exception table.</p><p>exception<sub>--</sub> table</p><p>Each entry in the exception table describes one exception handler in the code.</p><p>start<sub>--</sub> pc, end<sub>--</sub> pc</p><p>The two fieldsstart<sub>--</sub> pc and end<sub>--</sub> pc indicate the ranges in the code at which the exception handler is active. The values of both fields are offsets from the start of the code.start<sub>--</sub> pc is inclusive.end<sub>--</sub> pc is exclusive.</p><p>handler<sub>--</sub> pc</p><p>This field indicates the starting address of the exception handler. The value of the field is an offset from the start of the code.</p><p>catch<sub>--</sub> type</p><p>If catch<sub>--</sub> type is nonzero, then constant<sub>--</sub> pool [catch<sub>--</sub> type] will be the class of exceptions that this exception handler is designated to catch. This exception handler should only be called if the thrown exception is an instance of the given class.</p><p>If catch<sub>--</sub> type is zero, this exception handler should be called for all exceptions.</p><p>attributes<sub>--</sub> count</p><p>This field indicates the number of additional attributes about code. The \"Code\" attribute can itself have attributes.</p><p>attributes</p><p>A \"Code\" attribute can have any number of optional attributes associated with it. Each attribute has a name, and other additional information. Currently, the only code attributes defined are the \"LineNumberTable\" and \"LocalVariableTable,\" both of which contain debugging information.</p><p>2.6.4 Exceptions Table</p><p>This table is used by compilers which indicate which Exceptions a method is declared to throw:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nExceptions.sub.-- attribute {                                             \n u2 attribute.sub.-- name.sub.-- index;                                   \n u4 attribute.sub.-- length;                                              \n u2 number.sub.-- of.sub.-- exceptions;                                   \n u2 exception.sub.-- index.sub.-- table [number.sub.-- of.sub.-- exception\ns]                                                                        \n______________________________________                                    \n</pre><p>attribute<sub>--</sub> name<sub>--</sub> index</p><p>constant<sub>--</sub> pool [attribute<sub>--</sub> name<sub>--</sub> index] will be the CONSTANT<sub>--</sub> Utf8 string \"Exceptions\".</p><p>attribute<sub>--</sub> length</p><p>This field indicates the total length of the Exceptions<sub>--</sub> attribute, excluding the initial six bytes.</p><p>number<sub>--</sub> of<sub>--</sub> exceptions</p><p>This field indicates the number of entries in the following exception index table.</p><p>exception<sub>--</sub> index<sub>--</sub> table</p><p>Each value in this table is an index into the constant pool. For each table element (exception<sub>--</sub> index<sub>--</sub> table [i] !=0, where 0\u2266i &lt;number<sub>--</sub> of<sub>--</sub> exceptions), then constant<sub>--</sub> pool [exception<sub>--</sub> index+table [i]] is a Exception that this class is declared to throw.</p><p>2.6.5 LineNumberTable</p><p>This attribute is used by debuggers and the exception handler to determine which part of the virtual machine code corresponds to a given location in the source. The LineNumberTable<sub>--</sub> attribute has the following format:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nLineNumberTable.sub.-- attribute {                                        \n u2            attribute.sub.-- name.sub.-- index;                        \n u4            attribute.sub.-- length;                                   \n u2            line.sub.-- number.sub.-- table.sub.-- length;             \n { u2          start.sub.-- pc;                                           \n u2             line.sub.-- number;                                       \n }             line.sub.-- number.sub.-- table[line.sub.--                \n               number.sub.-- table.sub.-- length];                        \n______________________________________                                    \n</pre><p>attribute<sub>--</sub> name<sub>--</sub> index</p><p>constant<sub>--</sub> pool [attribute<sub>--</sub> name<sub>--</sub> index] will be the CONSTANT<sub>--</sub> Utf8 string \"LineNumberTable\".</p><p>attribute<sub>--</sub> length</p><p>This field indicates the total length of the LineNumberTable<sub>--</sub> attribute, excluding the initial six bytes.</p><p>line<sub>--</sub> number<sub>--</sub> table<sub>--</sub> length</p><p>This field indicates the number of entries in the following line number table.</p><p>line<sub>--</sub> number<sub>--</sub> table</p><p>Each entry in the line number table indicates that the line number in the source file changes at a given point in the code.</p><p>start<sub>--</sub> Pc</p><p>This field indicates the place in the code at which the code for a new line in the source begins. source<sub>--</sub> pc &lt;&lt;SHOULD THAT BEstart<sub>--</sub> pc?&gt;&gt; is an offset from the beginning of the code.</p><p>line<sub>--</sub> number</p><p>The line number that begins at the given location in the file.</p><p>2.6.6 LocalVariableTable</p><p>This attribute is used by debuggers to determine the value of a given local variable during the dynamic execution of a method. The format of the LocalVariableTable<sub>--</sub> attribute is as follows:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n       LocalVariableTable.sub.-- attribute {                              \n        u2 attribute.sub.-- name.sub.-- index;                            \n        u4 attribute.sub.-- length;                                       \n        u2 local.sub.-- variable.sub.-- table.sub.-- length;              \n        { u2 start.sub.-- pc;                                             \n         u2 length;                                                       \n         u2 name.sub.-- index;                                            \n         u2 signature.sub.-- index;                                       \n         u2 slot;                                                         \n        } local.sub.-- variable.sub.-- table[local.sub.--                 \n          variable.sub.-- table.sub.-- length];                           \n       }                                                                  \n______________________________________                                    \n</pre><p>attribute<sub>--</sub> name<sub>--</sub> index</p><p>constant<sub>--</sub> pool [attribute<sub>--</sub> name<sub>--</sub> index] will be the CONSTANT<sub>--</sub> Utf8 string \"LocalVariableTable\".</p><p>attribute<sub>--</sub> length</p><p>This field indicates the total length of the LineNumberTable<sub>--</sub> attribute, excluding the initial six bytes.</p><p>local<sub>--</sub> variable<sub>--</sub> table<sub>--</sub> length</p><p>This field indicates the number of entries in the following local variable table.</p><p>local<sub>--</sub> variable<sub>--</sub> table</p><p>Each entry in the local variable table indicates a code range during which a local variable has a value. It also indicates where on the stack the value of that variable can be found.</p><p>start<sub>--</sub> pc, length</p><p>The given local variable will have a value at the code between start<sub>--</sub> pc andstart<sub>--</sub> pc+length. The two values are both offsets from the beginning of the code.</p><p>name<sub>--</sub> index, signature<sub>--</sub> index</p><p>constant<sub>--</sub> pool[name<sub>--</sub> index] and constant<sub>--</sub> pool [signature<sub>--</sub> index] are CONSTANT<sub>--</sub> Utf8 strings giving the name and signature of the local variable.</p><p>slot</p><p>The given variable will be the slot<sup>th</sup> local variable in the method's frame.</p><p>3. The Virtual Machine Instruction Set</p><p>3.1 Format for the Instructions</p><p>JAVA Virtual Machine instructions are represented in this document by an entry of the following form.</p><p>instruction name</p><p>Short description of the instruction</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nopcode = number                                                           \noperand1                                                                  \noperand2                                                                  \n. . .                                                                     \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2\u2192. . . , value3</p><p>A longer description that explains the functions of the instruction and indicates any exceptions that might be thrown during execution.</p><p>Each line in the syntax table represents a single 8-bit byte.</p><p>Operations of the JAVA Virtual Machine most often take their operands from the stack and put their results back on the stack. As a convention, the descriptions do not usually mention when the stack is the source or destination of an operation, but will always mention when it is not. For instance, instruction iload has the short description \"Load integer from local variable.\" Implicitly, the integer is loaded onto the stack. Instruction iadd is described as \"Integer add\"; both its source and destination are the stack.</p><p>Instructions that do not affect the control flow of a computation may be assumed to always advance the virtual machine program counter to the opcode of the following instruction. Only instructions that do affect control flow will explicitly mention the effect they have on the program counter.</p><p>3.2 Pushing Constants onto the Stack</p><p>bipush</p><p>Push one-byte signed integer</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nbipush = 16                                                               \nbyte1                                                                     \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , value</p><p>byte1 is interpreted as a signed 8-bitvalue. This value is expanded to an integer and pushed onto the operand stack.</p><p>sipush</p><p>Push two-byte signed integer</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nsipush = 17                                                               \nbyte1                                                                     \nbyte2                                                                     \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , item</p><p>byte1 and byte2 are assembled into a signed 16-bit value. This value is expanded to an integer and pushed onto the operand stack.</p><p>ldc1</p><p>Push item from constant pool</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nldc1 = 18                                                                 \nindexbyte1                                                                \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , item</p><p>indexbyte1 is used as an unsigned 8-bit index into the constant pool of the current class. The item at that index is resolved and pushed onto the stack. If a String is being pushed and there isn't enough memory to allocate space for it then an OutOfMemoryError is thrown.</p><p>Note: A String push results in a reference to an object.</p><p>ldc2</p><p>Push item from constant pool</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nldc2 = 19                                                                 \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , item</p><p>indexbyte1 and indexbyte2 are used to construct an unsigned 16-bit index into the constant pool of the current class. The item at that index is resolved and pushed onto the stack. If a String is being pushed and there isn't enough memory to allocate space for it then an OutOfMemoryError is thrown.</p><p>Note: A String push results in a reference to an object.</p><p>ldc2w</p><p>Push long or double from constant pool</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nldc2w=20                                                                  \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , constant-word1, constant-word2</p><p>indexbyte1 and indexbyte2 are used to construct an unsigned 16-bit index into the constant pool of the current class. The two-word constant that index is resolved and pushed onto the stack.</p><p>aconst<sub>--</sub> null</p><p>Push null object reference</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \naconst.sub.-- null=1                                                      \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . .,null</p><p>Push the null object reference onto the stack.</p><p>iconst<sub>--</sub> m1</p><p>Push integer constant -1</p><p>SyntaX:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \niconst.sub.-- ml=2                                                        \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , 1</p><p>Push the integer -1 onto the stack.</p><p>iconst<sub>--</sub> &lt;n&gt;</p><p>Push integer constant</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \niconst.sub.--,&lt;n&gt;                                                         \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , &lt;n&gt;</p><p>Forms: iconst<sub>--</sub> 0=3, iconst<sub>--</sub> 1=4, iconst<sub>--</sub> 2=5, iconst<sub>--</sub> 3=6, iconst<sub>--</sub> 4=7, iconst<sub>--</sub> 5=8</p><p>Push the integer &lt;n&gt; onto the stack.</p><p>lconst<sub>--</sub> &lt;l&gt;</p><p>Push long integer constant</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlconst.sub.-- &lt;1&gt;                                                         \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , &lt;l&gt;-word1, &lt;l&gt;-word2</p><p>Forms: lconst<sub>--</sub> 0=9, lconst<sub>--</sub> 1=10</p><p>Push the long integer &lt;l&gt; onto the stack.</p><p>fconst<sub>--</sub> &lt;f&gt;</p><p>Push single float</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfconst.sub.-- &lt;f&gt;                                                         \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , &lt;f&gt;</p><p>Forms: fconst<sub>--</sub> 0=11, fconst<sub>--</sub> 1=12, fconst<sub>--</sub> 2=13</p><p>Push the single-precision floating point number &lt;f&gt; onto the stack.</p><p>dconst<sub>--</sub> &lt;d&gt;</p><p>Push double float</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndconst.sub.-- &lt;d&gt;                                                         \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , &lt;d&gt;-word1, &lt;d&gt;-word2</p><p>Forms: dconst<sub>--</sub> 0=14, dconst-1=15</p><p>Push the double-precision floating point number &lt;d&gt; onto the stack.</p><p>3.3 Loading Local Variables Onto the Stack</p><p>lload</p><p>Load integer from local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \niload=21                                                                  \nvindex                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , value</p><p>The value of the local variable at vindex in the current JAVA frame is pushed onto the operand stack.</p><p>iload<sub>--</sub> &lt;n&gt;</p><p>Load integer from local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \niload.sub.-- &lt;n&gt;                                                          \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , value</p><p>Forms: iload<sub>--</sub> 0=26, iload<sub>--</sub> 1=27,iload<sub>--</sub> 2=28, iload<sub>--</sub> 3=29</p><p>The value of the local variable at &lt;n&gt; in the current JAVA frame is pushed onto the operand stack.</p><p>This instruction is the same as iload with a vindex of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.</p><p>iload</p><p>Load long integer from local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \niload = 22                                                                \nvindex                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , value-word1, value-work2</p><p>The value of the local variables at vindex and vindex+1 in the current JAVA frame is pushed onto the operand stack.</p><p>lload<sub>--</sub> &lt;n&gt;</p><p>Load long integer from local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \niload.sub.-- &lt;n&gt;                                                          \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , value-word1, value-word2</p><p>Forms: lload<sub>--</sub> 0=30, lload<sub>--</sub> 1=31, lload<sub>--</sub> 2=32, lload<sub>--</sub> 3=33</p><p>The value of the local variables at &lt;n&gt; and &lt;n&gt;+1 in the current JAVA frame is pushed onto the operand stack.</p><p>This instruction is the same as lload with a vindex of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.</p><p>fload</p><p>Load single float from local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfload = 23                                                                \nvindex                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , value</p><p>The value of the local variable at vindex in the current JAVA frame is pushed onto the opera and stack.</p><p>fload<sub>--</sub> &lt;n&gt;</p><p>Load single float from local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfload.sub.-- &lt;n&gt;                                                          \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . ,value</p><p>Forms: fload<sub>--</sub> 0=34, fload<sub>--</sub> 1=35, fload<sub>--</sub> 2=36, fload<sub>--</sub> 3=37</p><p>The value of the local variable at &lt;n&gt; in the current JAVA frame is pushed onto the operand stack.</p><p>This instruction is the same as fload with a vindex of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.</p><p>dload</p><p>Load double float from local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndload = 24                                                                \nvindex                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , value-word1, value-word2</p><p>The value of the local variables at vindex and vindex+1 in the current JAVA frame is pushed onto the operand stack.</p><p>dload<sub>--</sub> &lt;n&gt;</p><p>Load double float from local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndload.sub.-- &lt;n&gt;                                                          \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , value-word1, value-word2</p><p>Forms: dload<sub>--</sub> 0=38, dload<sub>--</sub> 1=39, dload<sub>--</sub> 2=40, dload<sub>--</sub> 3=41</p><p>The value of the local variables at &lt;n&gt; and &lt;n&gt;+1 in the current JAVA frame is pushed onto the operand stack.</p><p>This instruction is the same as dload with a vindex of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.</p><p>aload</p><p>Load object reference from local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \naload = 25                                                                \nvindex                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , value</p><p>The value of the local variable at vindex in the current JAVA frame is pushed onto the operand stack.</p><p>aload<sub>--</sub> &lt;n&gt;</p><p>Load object reference from local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \naload.sub.-- &lt;n&gt;                                                          \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , value</p><p>Forms: aload<sub>--</sub> 0=42,aload<sub>--</sub> 1=43, aload<sub>--</sub> 2=44, aload<sub>--</sub> 3=45</p><p>The value of the local variable at &lt;n&gt; in the current JAVA frame is pushed onto the operand stack.</p><p>This instruction is the same as aload with a vindex of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.</p><p>3.4 Storing Stack Values into Local Variables</p><p>istore</p><p>Store integer into local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nistore = 54                                                               \nvindex                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>value must be an integer. Local variable vindex in the current JAVA frame is set to value.</p><p>istore<sub>--</sub> &lt;n&gt;</p><p>Store integer into local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nistore.sub.-- &lt;n&gt;                                                         \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>Forms: istore<sub>--</sub> 0=59, istore<sub>--</sub> 1=60, istore<sub>--</sub> 2=61, istore<sub>--</sub> 3=62</p><p>value must be an integer. Local variable &lt;n&gt; in the current JAVA frame is set to value.</p><p>This instruction is the same as istore with a vindex of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.</p><p>lstore</p><p>Store long integer into local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlstore = 55                                                               \nvindex                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;. . .</p><p>value must be a long integer. Local variables vindex+1 in the current JAVA frame are set to value.</p><p>lstore<sub>--</sub> &lt;n&gt;</p><p>Store long integer into local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlstore.sub.-- &lt;n&gt;                                                         \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;</p><p>Forms: lstore<sub>--</sub> 0=63, lstore<sub>--</sub> 1=64, lstore<sub>--</sub> 2=65, lstore<sub>--</sub> 3=66</p><p>value must be a long integer. Local variables &lt;n&gt; and &lt;n&gt;+1 in the current JAVA frame are set to value.</p><p>This instruction is the same as lstore with a vindex of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.</p><p>fstore</p><p>Store single float into local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfstore =56                                                                \nvindex                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>value must be a single-precision floating point number. Local variable vindex in the current JAVA frame is set to value.</p><p>fstore<sub>--</sub> &lt;n&gt;</p><p>Store single float into local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfstore.sub.-- &lt;n&gt;                                                         \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>Forms: fstore<sub>--</sub> 0=67, fstore<sub>--</sub> 1=68, fstore<sub>--</sub> 2=69, fstore<sub>--</sub> 3=70</p><p>value must be a single-precision floating point number. Local variable &lt;n&gt; in the current JAVA frame is set to value.</p><p>This instruction is the same as fstore with a vindex of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.</p><p>dstore</p><p>Store double float into local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndstore = 57                                                               \nvindex                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;. . .</p><p>value must be a double-precision floating point number. Local variables vindex and vindex+1 in the current JAVA frame are set to value.</p><p>dstore<sub>--</sub> &lt;n&gt;</p><p>Store double float into local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndstore.sub.-- &lt;n&gt;                                                         \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;. . .</p><p>Forms: dstore<sub>--</sub> 0=71, dstore<sub>--</sub> 1=72, dstore<sub>--</sub> 2=73, dstore<sub>--</sub> 3=74</p><p>value must be a double-precision floating point number. Local variables &lt;n&gt; and &lt;n&gt;+1 in the current JAVA frame are set to value.</p><p>This instruction is the same as dstore with a vindex of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.</p><p>astore</p><p>Store object reference into local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nastore = 58                                                               \nvindex                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>value must be a return address or a reference to an object. Local variable vindex in the current JAVA frame is set to value.</p><p>astore<sub>--</sub> &lt;n&gt;</p><p>Store object reference into local variable</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nastore.sub.-- &lt;n&gt;                                                         \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>Forms: astore<sub>--</sub> 0=75, astore<sub>--</sub> 1=76, astore<sub>--</sub> 2=77, astore<sub>--</sub> 3=78</p><p>value must be a return address or a reference to an object. Local variable &lt;n&gt; in the current JAVA frame is set to value.</p><p>This instruction is the same as astore with a vindex of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.</p><p>iinc</p><p>Increment local variable by constant</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \niinc = 132                                                                \nvindex                                                                    \nconst                                                                     \n______________________________________                                    \n</pre><p>Stack: no change</p><p>Local variable vindex in the current JAVA frame must contain an integer. Its value is incremented by the value const, where const is treated as a signed 8-bit quantity.</p><p>3.5 Wider index for Loading, Storing and Incrementing</p><p>wide</p><p>Wider index for accessing local variables in load, store and increment.</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nwide = 196                                                                \nvindex2                                                                   \n______________________________________                                    \n</pre><p>Stack: no change</p><p>This bytecode must precede one of the following bytecodes: iload, lload, fload, dload, aload, istore, lstore, fstore, dstore, astore, iinc. The vindex of the following bytecode and vindex2 from this bytecode are assembled into an unsigned 16-bit index to a local variable in the current JAVA frame. The following bytecode operates as normal except for the use of this wider index.</p><p>3.6 Managing Arrays</p><p>newarray</p><p>Allocate new array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nnewarray = 188                                                            \natype                                                                     \n______________________________________                                    \n</pre><p>Stack: . . . , size=&gt;result</p><p>size must be an integer. It represents the number of elements in the new array.</p><p>atype is an internal code that indicates the type of array to allocate. Possible values for atype are as follows:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n       T.sub.-- BOOLEAN                                                   \n                4                                                         \n       T.sub.-- CHAR                                                      \n                5                                                         \n       T.sub.-- FLOAT                                                     \n                6                                                         \n       T.sub.-- DOUBLE                                                    \n                7                                                         \n       T.sub.-- BYTE                                                      \n                8                                                         \n       T.sub.-- SHORT                                                     \n                9                                                         \n       T.sub.-- INT                                                       \n                10                                                        \n       T.sub.-- LONG                                                      \n                11                                                        \n______________________________________                                    \n</pre><p>A new array of atype, capable of holding size elements, is allocated, and result is a reference to this new object. Allocation of an array large enough to contain size items of atype is attempted. All elements of the array are initialized to zero.</p><p>If size is less than zero, a NegativeArraySizeException is thrown. If there is not enough memory to allocate the array, anOutOfMemoryError is thrown.</p><p>anewarray</p><p>Allocate new array of references to objects</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nanewarray = 189                                                           \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , size=&gt;result</p><p>size must be an integer. It represents the number of elements in the new array.</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item at that index is resolved. The resulting entry must be a class.</p><p>A new array of the indicated class type and capable of holding size elements is allocated, and result is a reference to this new object. Allocation of an array large enough to contain size items of the given class type is attempted. All elements of the array are initialized to null.</p><p>If size is less than zero, a NegativeArraySizeException is thrown. If there is not enough memory to allocate the array, an OutOfMemoryError is thrown.</p><p>anewarray is used to create a single dimension of an array of object references. For example, to create</p><p>new Thread[7]</p><p>the following code is used:</p><p>bipush 7</p><p>anewarray &lt;Class \"JAVA.lang.Thread\"&gt;</p><p>anewarray can also be used to create the first dimension of a multi-dimensional array. For example, the following array declaration:</p><p>new int[6][]</p><p>is created with the following code:</p><p>bipush 6</p><p>anewarray &lt;Class \"[I\"&gt;</p><p>See CONSTANT<sub>--</sub> Class in the \"Class File Format\" chapter for information on array class names.</p><p>multianewarray</p><p>Allocate new multi-dimensional array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nmultianewarray = 197                                                      \nindexbyte1                                                                \nindexbyte2                                                                \ndimensions                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , size1 size2 . . . sizen=&gt;result</p><p>Each size must be an integer. Each represents the number of elements in a dimension of the array.</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item at that index is resolved. The resulting entry must be an array class of one or more dimensions.</p><p>dimensions has the following aspects:</p><p>It must be an integer \u22671.</p><p>It represents the number of dimensions being created. It must be \u2267 the number of dimensions of the array class.</p><p>It represents the number of elements that are popped off the stack. All must be integers greater than or equal to zero. These are used as the sizes of the dimension.</p><p>For example, to create</p><p>new int[6][3][]</p><p>the following code is used:</p><p>bipush 6</p><p>bipush 3</p><p>multianewarray &lt;Class \"[[[I\"&gt;2</p><p>If any of the size arguments on the stack is less than zero, a NegativeArraySizeException is thrown. If there is not enough memory to allocate the array, an OutOfMemoryError is thrown.</p><p>The result is a reference to the new array object.</p><p>Note: It is more efficient to use newarray or anewarray when creating a single dimension.</p><p>See CONSTANT<sub>--</sub> Class in the \"Class File Format\" chapter for information on array class names.</p><p>arraylength</p><p>Get length of array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \narraylength = 190                                                         \n______________________________________                                    \n</pre><p>Stack: . . . , objectref=&gt;. . . , length</p><p>objectref must be a reference to an array object. The length of the array is determined and replaces objectref on the top of the stack.</p><p>If the objectref is null, a NullPointerException is thrown.</p><p>iaload</p><p>Load integer from array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \niaload = 46                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index=&gt;. . . , value</p><p>arrayref must be a reference to an array of integers.index must be an integer. The integer value at position number index in the array is retrieved and pushed onto the top of the stack.</p><p>If arrayref is null a NullPointerException is thrown. If index is not within the bounds of the array an ArrayIndexOutOfBoundsException is thrown.</p><p>laload</p><p>Load long integer from array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlaoad = 47                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index=&gt;. . . , value-word1, value-word2</p><p>arrayref must be a reference to an array of long integers. index must be an integer. The long integer value at position number index in the array is retrieved and pushed onto the top of the stack.</p><p>If arrayref is null a NullPointerException is thrown. If index is not within the bounds of the array an ArrayIndexOutOfBoundsException is thrown.</p><p>faload</p><p>Load single float from array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfaload = 48                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index=&gt;. . . , value</p><p>arrayref must be a reference to an array of single-precision floating point numbers. index must be an integer. The single-precision floating point number value at position number index in the array is retrieved and pushed onto the top of the stack.</p><p>If arrayref is null a NullPointerException is thrown. If index is not within the bounds of the array an ArrayIndexOutOfBoundsException is thrown.</p><p>daload</p><p>Load double float from array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndaload = 49                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index=&gt;. . . , value-word1, value-word2</p><p>arrayref must be a reference to an array of double-precision floating point numbers. index must be an integer. The double-precision floating point number value at position number index in the array is retrieved and pushed onto the top of the stack.</p><p>If arrayref is null a NullPointerException is thrown. If index is not within the bounds of the array an ArrayIndexOutOfBoundsException is thrown.</p><p>aaload</p><p>Load object reference from array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \naaload = 50                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index=&gt;. . . , value</p><p>arrayref must be a reference to an array of references to objects. index must be an integer. The object reference at position number index in the array is retrieved and pushed onto the top of the stack.</p><p>If arrayref is null a NullPointerException is thrown. If index is not within the bounds of the array an ArrayIndexOutOfBoundsException is thrown.</p><p>baload</p><p>Load signed byte from array.</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nbaload = 51                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index=&gt;. . . , value</p><p>arrayref must be a reference to an array of signed bytes. index must be an integer. The signed byte value at position number index in the array is retrieved, expanded to an integer, and pushed onto the top of the stack.</p><p>If arrayref is null a NullPointerException is thrown. If index is not within the bounds of the array an ArrayIndexOutOfBoundsException is thrown.</p><p>caload</p><p>Load character from array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ncaload = 52                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index=&gt;. . . ,value</p><p>arrayref must be a reference to an array of characters. index must be an integer. The character value at position number index in the array is retrieved, zero-extended to an integer, and pushed onto the top of the stack.</p><p>If arrayref is null a NullPointerException is thrown. If index is not within the bounds of the array an ArrayIndexOutOfBoundsException is thrown.</p><p>saload</p><p>Load short from array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nsaload = 53                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index=&gt;. . . , value</p><p>arrayref must be a reference to an array of short integers. index must be an integer. The ;signed short integer value at position number index in the array is retrieved, expanded to an integer, and pushed onto the top of the stack.</p><p>If arrayref is null, a NullPointerException is thrown. If index is not within the bounds of the array an ArrayIndexOutOfBoundsException is thrown.</p><p>iastore</p><p>Store into integer array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \niastore = 79                                                              \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index, value=&gt;. . .</p><p>arrayref must be a reference to an array of integers, index must be an integer, and value an integer. The integer value is stored at position index in the array.</p><p>If arrayref is null, a NullPointerException is thrown. If index is not within the bounds of the array an ArrayIndexOutOfBoundsException is thrown.</p><p>lastore</p><p>Store into long integer array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlastore = 80                                                              \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index, value-word1, value-word2=&gt;. . .</p><p>arrayref must be a reference to an array of long integers, index must be an integer, and value a long integer. The long integer value is stored at position index in the array.</p><p>If arrayref is null, a NullPointerException is thrown. If index is not within the bounds of the array, an ArrayIndexOutOfBoundsException is thrown.</p><p>fastore</p><p>Store into single float array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfastore = 81                                                              \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index, value=&gt;. . .</p><p>arrayref must be an array of single-precision floating point numbers, index must be an integer, and value a single-precision floating point number. The single float value is stored at position index in the array.</p><p>If arrayref is null, a NullPointerException is thrown. If index is not within the bounds of the array an ArrayIndexOutOfBoundsException is thrown.</p><p>dastore</p><p>Store into double float array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndastore = 82                                                              \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index, value-word1, value-word2=&gt;. . .</p><p>arrayref must be a reference to an array of double-precision floating point numbers, index must be an integer, and value a double-precision floating point number. The double float value is stored at position index in the array.</p><p>If arrayref is null, a NullPointerException is thrown. If index is not within the bounds of the array an ArrayIndexOutOfBoundsException is thrown.</p><p>aastore</p><p>Store into object reference array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \naastore = 83                                                              \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index, value=&gt;. . .</p><p>arrayref must be a reference to an array of references to objects, index must be an integer, and value a reference to an object. The object reference value is stored at position index in the array.</p><p>If arrayref is null, a NullPointerException is thrown. If index is not within the bounds of the array, an ArrayIndexOutOfBoundsException is thrown.</p><p>The actual type of value must be conformable with the actual type of the elements of the array. For example, it is legal to store an instance of class Thread in an array of class Object, but not vice versa. An ArrayStoreException is thrown if an attempt is made to store an incompatible object reference.</p><p>bastore</p><p>Store into signed byte array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nbastore = 84                                                              \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index, value=&gt;. . .</p><p>arrayref must be a reference to an array of signed bytes, index must be an integer, and value an integer. The integer value is stored at position index in the array. If value is too large to be a signed byte, it is truncated.</p><p>If arrayref is null, a NullPointerException is thrown. If index is not within the bounds of the array an ArrayIndexOutOfBoundsException is thrown.</p><p>castore</p><p>Store into character array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ncastore = 85                                                              \n______________________________________                                    \n</pre><p>Stack: . . . , arrayref, index, value=&gt;. . .</p><p>arrayref must be an array of characters, index must be an integer, and value an integer. The integer value is stored at position index in the array. If value is too large to be a character, it is truncated.</p><p>If arrayref is null, a NullPointerException is thrown. If index is not within the bounds of [the array an ArrayIndexOutOfBoundsException is thrown.</p><p>sastore</p><p>Store into short array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nsastore = 86                                                              \n______________________________________                                    \n</pre><p>Stack: . . . , array, index, value=&gt;. . .</p><p>arrayref must be an array of shorts, index must be an integer, and value an integer. The integer value is stored at position index in the array. If value is too large to be an short, it is truncated.</p><p>If arrayref is null, a NullPointerException is thrown. If index is not within the bounds of the array an ArrayIndexOutOfBoundsException is thrown.</p><p>3.7 Stack Instructions</p><p>nop</p><p>Do nothing</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nnop = 0                                                                   \n______________________________________                                    \n</pre><p>Stack: no change</p><p>Do nothing.</p><p>pop</p><p>Pop top stack word</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \npop = 87                                                                  \n______________________________________                                    \n</pre><p>Stack: . . . , any=&gt;. . .</p><p>Pop the top word from the stack.</p><p>pop2</p><p>Pop top two stack words</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \npop2 = 89                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , any2, any1=&gt;. . .</p><p>Pop the top two words from the stack.</p><p>dup</p><p>Duplicate top stack word</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndup = 89                                                                  \n______________________________________                                    \n</pre><p>Stack: . . . , any=&gt;. . . , any,any</p><p>Duplicate the top word on the stack.</p><p>dup2</p><p>Duplicate top two stack words</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndup2 = 92                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , any2,any1=&gt;. . . , any2, any1,any2, any1</p><p>Duplicate the top two words on the stack.</p><p>dup<sub>--</sub> x1</p><p>Duplicate top stack word and put two down</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndup.sub.-- xl = 90                                                        \n______________________________________                                    \n</pre><p>Stack: . . . , any2, any1=&gt;. . . , any1, any2, any1</p><p>Duplicate the top word on the stack and insert the copy two words down in the stack.</p><p>dup2<sub>--</sub> x1</p><p>Duplicate top two stack words and put two down</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndup.sub.-- xl = 93                                                        \n______________________________________                                    \n</pre><p>Stack: . . . , any3, any2, any1=&gt;. . . , any2, any1, any3, any2, any1</p><p>Duplicate the top two words on the stack and insert the copies two words down in the stack.</p><p>dup<sub>--</sub> x2</p><p>Duplicate top stack word and put three down</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndup.sub.-- x2 = 91                                                        \n______________________________________                                    \n</pre><p>Stack: . . . , any3, any2, any1=&gt;. . . , any1, any3, any2, any1</p><p>Duplicate the top word on the stack and insert the copy three words down in the stack.</p><p>dup2<sub>--</sub> x2</p><p>Duplicate top two stack words and put three down</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndup2.sub.-- x2 = 94                                                       \n______________________________________                                    \n</pre><p>Stack: . . . , any4, any3, any2, any1=&gt;. . . , any2, any1, any4, any3, any2, any1</p><p>Duplicate the top two words on the stack and insert the copies three words down in the stack.</p><p>swap</p><p>Swap top two stack words</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nswap = 95                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , any2, any1=&gt;. . . , any2, any1</p><p>Swap the top two elements on the stack.</p><p>3.8 Arithmetic Instructions</p><p>iadd</p><p>Integer add</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \niadd = 96                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must be integers. The values are added and are replaced on the stack by their integer sum.</p><p>ladd</p><p>Long integer add</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nladd = 97                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result-word2</p><p>value1 and value 2 must be long integers. The values are added and are replaced on the stack by their long integer sum.</p><p>fadd</p><p>Single floats add</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfadd = 98                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must be single-precision floating point numbers. The values are added and are replaced on the stack by their single-precision floating point sum.</p><p>dadd</p><p>Double floats add</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndadd = 99                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result -word2</p><p>value1 and value 2 must be double-precision floating point numbers. The values are added and are replaced on the stack by their double-precision floating point sum.</p><p>isub</p><p>Integer subtract</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nisub = 100                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must be integers. value2 is subtracted from value1, and both values are replaced on the stack by their integer difference.</p><p>lsub</p><p>Long integer subtract</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlsub = 101                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result-word2</p><p>value1 and value 2 must be long integers. value2 is subtracted from value1, and both values are replaced on the stack by their long integer difference.</p><p>fsub</p><p>Single float subtract</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfsub = 102                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must be single-precision floating point numbers. value2 is subtracted from value1, and both values are replaced on the stack by their single-precision floating point difference.</p><p>dsub</p><p>Double float subtract</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndsub = 103                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result-word2</p><p>value1 and value 2 must be double-precision floating point numbers. value2 is subtracted from value1, and both values are replaced on the stack by their double-precision floating point difference.</p><p>imul</p><p>Integer multiply</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nimul = 104                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must be integers. Both values are replaced on the stack by their integer product.</p><p>lmul</p><p>Long integer multiply</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nimul = 105                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result-word2</p><p>value1 and value 2 must be long integers. Both values are replaced on the stack by their long integer product.</p><p>fmul</p><p>Single float multiply</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfmul = 106                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must be single-precision floating point numbers. Both values are replaced on the stack by their single-precision floating point product.</p><p>dmul</p><p>Double float multiply</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndmul = 107                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result-word2</p><p>value1 and value 2 must be double-precision floating point numbers. Both values are replaced on the stack by their double-precision floating point product.</p><p>idiv</p><p>Integer divide</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nidiv = 108                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must be integers. value1 is divided by value2, and both values are replaced on the stack by their integer quotient.</p><p>The result is truncated to the nearest integer that is between it and 0. An attempt to divide by zero results in a \"/ by zero\" ArithmeticException being thrown.</p><p>ldiv</p><p>Long integer divide</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nldiv = 109                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result-word2</p><p>value1 and value 2 must be long integers. value1 is divided by value2, and both values are replaced on the stack by their long integer quotient.</p><p>The result is truncated to the nearest integer that is between it and 0. An attempt to divide by zero results in a \"/ by zero\" ArithmeticException being thrown.</p><p>fdiv</p><p>Single float divide</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfdiv = 110                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must be single-precision floating point numbers. value1 is divided by value2, and both values are replaced on the stack by their single-precision floating point quotient.</p><p>Divide by zero results in the quotient being NaN.</p><p>ddiv</p><p>Double float divide</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nddiv = 111                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result-word2</p><p>value1 and value 2 must be double-precision floating point numbers. value1 is divided by value2, and both values are replaced on the stack by their double-precision floating point quotient.</p><p>Divide by zero results in the quotient being NaN.</p><p>irem</p><p>Integer remainder</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nirem = 112                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must both be integers. value1 is divided by value2, and both values are replaced on the stack by their integer remainder.</p><p>An attempt to divide by zero results in a \"/ by zero\" ArithmeticException being thrown.</p><p>lrem</p><p>Long integer remainder</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlrem = 113                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result-word2</p><p>value1 and value 2 must both be long integers. value1 is divided by value2, and both values are replaced on the stack by their long integer remainder.</p><p>An attempt to divide by zero results in a \"/ by zero\" ArithmeticException being thrown.</p><p>frem</p><p>Single float remainder</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfrem = 114                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must both be single-precision floating point numbers. value1 is divided by value2, and the quotient is truncated to an integer, and then multiplied by value2. The product is subtracted from value1. The result, as a single-precision floating point number, replaces both values on the stack. result=value1-(integral<sub>--</sub> part(value1/value2) *value2), where integral<sub>--</sub> part() rounds to the nearest integer, with a tie going to the even number.</p><p>An attempt to divide by zero results in NaN.</p><p>drem</p><p>Double float remainder</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndrem = 115                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result-word2</p><p>value1 and value 2 must both be double-precision floating point numbers. value1 is divided by value2, and the quotient is truncated to an integer, and then multiplied by value2. The product is subtracted from value1. The result, as a double-precision floating point number, replaces both values on the stack. result=value1-(integral<sub>--</sub> part(value1/value2) * value2), where integral<sub>--</sub> part() rounds to the nearest integer, with a tie going to the even number.</p><p>An attempt to divide by zero results in NaN.</p><p>ineg</p><p>Integer negate</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nineg = 116                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . . , result</p><p>value must be an integer. It is replaced on the stack by its arithmetic negation.</p><p>lneg</p><p>Long integer negate</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlneg = 117                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;. . . , result-word1, result-word2</p><p>value must be a long integer. It is replaced on the stack by its arithmetic negation.</p><p>fneg</p><p>Single float negate</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfneg = 118                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . . , result</p><p>value must be a single-precision floating point number. It is replaced on the stack by its arithmetic negation.</p><p>dneg</p><p>Double float negate</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndneg = 119                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;. . . , result-word1, result-word2</p><p>value must be a double-precision floating point number. It is replaced on the stack by its arithmetic negation.</p><p>3.9 Logical Instructions</p><p>ishl</p><p>Integer shift left</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nishl = 120                                                                \n______________________________________                                    \n</pre><p>Stack: . . . ,value1, value2=&gt;. . . , result</p><p>value1 and value 2 must be integers. value1 is shifted left by the amount indicated by the low five bits of value2. The integer result replaces both values on the stack.</p><p>ishr</p><p>Integer arithmetic shift right</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nishr = 122                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must be integers. value1 is shifted right arithmetically (with sign extension) by the amount indicated by the low five bits of value2. The integer result replaces both values on the stack.</p><p>iushr</p><p>Integer logical shift right</p><p>Syntax</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \niushr = 124                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must be integers. value1 is shifted right logically (with no sign extension) by the amount indicated by the low five bits of value2. The integer result replaces both values on the stack.</p><p>lshl</p><p>Long integer shift left</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlshl = 121                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2=&gt;. . . , result-word1, result-word2</p><p>value1 must be a long integer and value 2 must be an integer. value1 is shifted left by the amount indicated by the low six bits of value2. The long integer result replaces both values on the stack.</p><p>lshr</p><p>Long integer arithmetic shift right</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlshr = 123                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2=&gt;. . . , result-word1, result-word2</p><p>value1 must be a long integer and value 2 must be an integer. value1 is shifted right arithmetically (with sign extension) by the amount indicated by the low six bits of value2. The long integer result replaces both values on the stack.</p><p>lushr</p><p>Long integer logical shift right</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlushr = 125                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result-word2</p><p>value1 must be a long integer and value 2 must be an integer. value1 is shifted right logically (with no sign extension) by the amount indicated by the low six bits of value2. The long integer result replaces both values on the stack.</p><p>iand</p><p>Integer boolean AND</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \niand = 126                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result value1 and value 2 must both be integers. They are replaced on the stack by their bitwise logical and (conjunction).</p><p>land</p><p>Long integer boolean AND</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nland = 127                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result-word2</p><p>value1 and value 2 must both be long integers. They are replaced on the stack by their bitwise logical and (conjunction).</p><p>ior</p><p>Integer boolean OR</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nior = 128                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must both be integers. They are replaced on the stack by their bitwise logical or (disjunction)</p><p>lor</p><p>Long integer boolean OR</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlor = 129                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result-word2</p><p>value1 and value 2 must both be long integers. They are replaced on the stack by their bitwise logical or (disjunction).</p><p>ixor</p><p>Integer boolean XOR</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nixor = 130                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . , result</p><p>value1 and value 2 must both be integers. They are replaced on the stack by their bitwise exclusive or (exclusive disjunction).</p><p>lxor</p><p>Long integer boolean XOR</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlxor = 131                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word2=&gt;. . . , result-word1, result-word2</p><p>value1 and value 2 must both be long integers. They are replaced on the stack by their bitwise exclusive or (exclusive disjunction).</p><p>3.10 Conversion Operations</p><p>i21</p><p>Integer to long integer conversion</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ni2l = 133                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . . , result-word1, result-word2</p><p>value must be an integer. It is converted to a long integer. The result replaces value on the stack.</p><p>i2f</p><p>Integer to single float</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ni2f = 134                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . . , result</p><p>value must be an integer. It is converted to a single-precision floating point number. The result replaces value on the stack.</p><p>i2d</p><p>Integer to double float</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ni2d = 135                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . . , result-word1, result-word2</p><p>value must be an integer. It is converted to a double-precision floating point number. The result replaces value on the stack.</p><p>l2i</p><p>Long integer to integer</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nl2i = 136                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;. . . , result</p><p>value must be a long integer. It is converted to an integer by taking the low-order 32 bits. The result replaces value on the stack.</p><p>l2f</p><p>Long integer to single float</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nl2f = 137                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;. . . , result</p><p>value must be a long integer. It is converted to a single-precision floating point number. The result replaces value on the stack.</p><p>l2d</p><p>Long integer to double float</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nl2d = 138                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;. . . , result-word1, result-word2</p><p>value must be a long integer. It is converted to a double-precision floating point number. The result replaces value on the stack.</p><p>f2i</p><p>Single float to integer</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nf2i = 139                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . . , result</p><p>value must be a single-precision floating point number. It is converted to an integer. The result replaces value on the stack.</p><p>f2l</p><p>Single float to long integer</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nf21 = 140                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . . , result-word1, result-word2</p><p>value must be a single-precision floating point number. It is converted to a long integer. The result replaces value on the stack.</p><p>f2d</p><p>Single float to double float</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nf2d = 141                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . . , result-word1, result-word2</p><p>value must be a single-precision floating point number. It is converted to a double-precision floating point number. The result replaces value on the stack.</p><p>d2i</p><p>Double float to integer</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n2di = 142                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;. . . , result</p><p>value must be a double-precision floating point number. It is converted to an integer. The result replaces value on the stack.</p><p>d2l</p><p>Double float to long integer</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nd2l = 143                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;. . . , result-word1, result-word2</p><p>value must be a double-precision floating point number. It is converted to a long integer. The result replaces value on the stack.</p><p>d2f</p><p>Double float to single float</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n2df = 144                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;. . . , result</p><p>value must be a double-precision floating point number. It is converted to a single-precision floating point number. If overflow occurs, the result must be infinity with the same sign as value. The result replaces value on the stack.</p><p>int2byte</p><p>Integer to signed byte</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nint2byte = 157                                                            \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . . , result</p><p>value must be an integer. It is truncated to a signed 8-bit result, then sign extended to an integer. The result replaces value on the stack.</p><p>int2char</p><p>Integer to char</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nint2char = 146                                                            \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . . , result</p><p>value must be an integer. It is truncated to an unsigned 16-bit result, then zero extended to an integer. The result replaces value on the stack.</p><p>int2short</p><p>Integer to short</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nint2short =                                                               \n147                                                                       \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . . , result</p><p>value must be an integer. It is truncated to a signed 16-bit result, then sign extended to an integer. The result replaces value on the stack.</p><p>3.11 Control Transfer Instructions</p><p>ifeq</p><p>Branch if equal to 0</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nifeq = 153                                                                \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>value must be an integer. It is popped from the stack. If value is zero, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the ifeq.</p><p>ifnull</p><p>Branch if null</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nifnull = 198                                                              \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>value must be a reference to an object. It is popped from the stack. If value is null, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the ifnull.</p><p>iflt</p><p>Branch if less than 0</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \niflt = 155                                                                \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>value must be an integer. It is popped from the stack. If value is less than zero, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the iflt.</p><p>ifle</p><p>Branch if less than or equal to 0</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nifle=158                                                                  \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>value must be an integer. It is popped from the stack. If value is less than or equal to zero, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the ifle.</p><p>ifne</p><p>Branch if not equal to 0</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nifne=154                                                                  \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>value must be an integer. It is popped from the stack. If value is not equal to zero, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the ifne.</p><p>ifnonnull</p><p>Branch if not null</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nifnonnull=199                                                             \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>value must be a reference to an object. It is popped from the stack. If value is notnull, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the ifnonnull.</p><p>ifgt</p><p>Branch if greater than 0</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nifft=157                                                                  \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>value must be an integer. It is popped from the stack. If value is greater than zero, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the ifgt.</p><p>ifge</p><p>Branch if greater than or equal to 0</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nifge=156                                                                  \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . .</p><p>value must be an integer. It is popped from the stack. If value is greater than or equal to zero, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following instruction ifge.</p><p>if<sub>--</sub> icmpeq</p><p>Branch if integers equal</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nif.sub.-- icmpeq=159                                                      \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . .</p><p>value1 and value2 must be integers. They are both popped from the stack. If value1 is equal to value2, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following instruction if<sub>--</sub> icmpeq.</p><p>if<sub>--</sub> icmpne</p><p>Branch if integers not equal</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nif.sub.-- icmpne=160                                                      \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . .</p><p>value1 and value2 must be integers. They are both popped from the stack. If value1 is not equal to value2, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following instruction if<sub>--</sub> icmpne.</p><p>if<sub>--</sub> icmplt</p><p>Branch if integer less than</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nif.sub.-- icmplt=161                                                      \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . .</p><p>value1 and value2 must be integers. They are both popped from the stack. If value1 is less than value2, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following instruction if<sub>--</sub> icmplt.</p><p>if<sub>--</sub> icmpgt</p><p>Branch if integer greater than</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nif.sub.-- icmpgt=163                                                      \nbranchbyte 1                                                              \nbranchbyte 2                                                              \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . .</p><p>value1 and value2 must be integers. They are both popped from the stack. If value1 is greater than value2, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following instruction if<sub>--</sub> icmpgt.</p><p>if<sub>--</sub> icmple</p><p>Branch if integer less than or equal to</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nif.sub.-- icmple=164                                                      \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . .</p><p>value1 and value2 must be integers. They are both popped from the stack. If value1 is less than or equal to value2, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following instruction if<sub>--</sub> icmple.</p><p>if<sub>--</sub> icmpge</p><p>Branch if integer greater than or equal to</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nif.sub.-- icmpge=162                                                      \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . .</p><p>value1 and value2 must be integers. They are both popped from the stack. If value1 is greater than or equal to value2, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following instruction if<sub>--</sub> icmpge.</p><p>lcmp</p><p>Long integer compare</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlcmp=148                                                                  \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2,value2-word1, value2-word1=&gt;. . . , result</p><p>value1 and value2 must be long integers. They are both popped from the stack and compared. If value1 is greater than value2, the integer value1 is pushed onto the stack. If value1 is equal to value2, the value 0 is pushed onto the stack. If value1 is less than value2, the value -1 is pushed onto the stack.</p><p>fcmpl</p><p>Single float compare (1 on NaN)</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfcmpl=149                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . . ,result</p><p>value1 and value2 must be single-precision floating point numbers. They are both popped from the stack and compared. If value1 is greater than value2, the integer value 1 is pushed onto the stack. If value1 is equal to value2, the value 0 is pushed onto the stack. If value1 is less than value2, the value -1 is pushed onto the stack.</p><p>If either value1 or value2 is NaN, the value -1 is pushed onto the stack.</p><p>fcmpg</p><p>Single float compare (1 on NaN)</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfcmpg=150                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . ,value1, value2=&gt;. . . , result</p><p>value1 and value2 must be single-precision floating point numbers. They are both popped from the stack and compared. If value1 is greater than value2, the integer value 1 is pushed onto the stack. If value1 is equal to value2, the value 0 is pushed onto the stack. If value1 is less than value2, the value -1 is pushed onto the stack.</p><p>If either value1 or value2 is NaN, the value 1 is pushed onto the stack.</p><p>dcmpl</p><p>Double float compare (-1 on NaN)</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndcmpl-151                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word1=&gt;. . . , result</p><p>value1 and value2 must be double-precision floating point numbers. They are both popped from the stack and compared. If value1 is greater than value2, the integer value 1 is pushed onto the stack. If value1 is equal to value2, the value 0 is pushed onto the stack. If value1 is less than value2, the value 1 is pushed onto the stack.</p><p>If either value1 or value2 is NaN, the value 1 is pushed onto the stack.</p><p>dcmpg</p><p>Double float compare (1 on NaN)</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndcmpg=152                                                                 \n______________________________________                                    \n</pre><p>Stack: . . . , value1-word1, value1-word2, value2-word1, value2-word1=&gt;. . . , result</p><p>value1 and value2 must be double-precision floating point numbers. They are both popped from the stack and compared. If value1 is greater than value2, the integer value 1 is pushed onto the stack. If value1 is equal to value2, the value 0 is pushed onto the stack. If value1 is less than value2, the value -1 is pushed onto the stack.</p><p>If either value1 or value2 is NaN, the value 1 is pushed onto the stack.</p><p>if<sub>--</sub> acmpeq</p><p>Branch if object references are equal</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nif.sub.-- acmpeq=165                                                      \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . ,value1,value2=&gt;. . .</p><p>value1 and value2 must be references to objects. They are both popped from the stack. If the objects referenced are not the same, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset.</p><p>Execution proceeds at that offset from the Address of this instruction. Otherwise execution proceeds at the instruction following the if<sub>--</sub> acmpeq.</p><p>if<sub>--</sub> acmpne</p><p>Branch if object references not equal</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nif.sub.-- acmpne=166                                                      \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value1, value2=&gt;. . .</p><p>value1 and value2 must be references to objects. They are both popped from the stack. If the objects referenced are not the same, branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset.</p><p>Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following instruction if<sub>--</sub> acmpne.</p><p>goto</p><p>Branch always</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ngoto=167                                                                  \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: no change</p><p>branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction.</p><p>goto<sub>--</sub> w</p><p>Branch always (wide index)</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ngoto.sub.-- w=200                                                         \nbranchbyte1                                                               \nbranchbyte2                                                               \nbranchbyte3                                                               \nbranchbyte4                                                               \n______________________________________                                    \n</pre><p>Stack: no change</p><p>branchbyte1, branchbyte2, branchbyte3, and branchbyte4 are used to construct a signed 32-bit offset.</p><p>Execution proceeds at that offset from the address of this instruction.</p><p>jsr</p><p>Jump subroutine</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \njsr=168                                                                   \nbranchbyte1                                                               \nbranchbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;, return-address</p><p>branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset. The address of the instruction immediately following the jsr is pushed onto the stack. Execution proceeds at the offset from the address of this instruction.</p><p>jsr<sub>--</sub> w</p><p>Jump subroutine (wide index)</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \njsr.sub.-- w=201                                                          \nbranchbyte1                                                               \nbranchbyte2                                                               \nbranchbyte3                                                               \nbranchbyte4                                                               \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , return-address</p><p>branchbyte1, branchbyte2, branchbyte3, and branchbyte4 are used to construct a signed 32-bit offset. The address of the instruction immediately following the jsr<sub>--</sub> w is pushed onto the stack. Execution proceeds at the offset from the address of this instruction.</p><p>ret</p><p>Return from subroutine</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nret=169                                                                   \nvindex                                                                    \n______________________________________                                    \n</pre><p>Stack: no change</p><p>Local variable vindex in the current JAVA frame must contain a return address. The contents of the local variable are written into the pc.</p><p>Note that jsr pushes the address onto the stack, and ret gets it out of a local variable. This asymmetry is intentional.</p><p>ret<sub>--</sub> w</p><p>Return from subroutine (wide index)</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nret.sub.-- w=209                                                          \nvindexhbyte1                                                              \nvindexbyte2                                                               \n______________________________________                                    \n</pre><p>Stack: no change</p><p>vindexbyte1 and vindexbyte2 are assembled into an unsigned 16-bit index to a local variable in the current JAVA frame. That local variable must contain a return address. The contents of the local variable are written into the pc. See the ret instruction for more information.</p><p>3.12 Function Return</p><p>ireturn</p><p>Return integer from function</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nireturn=172                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;[empty]</p><p>value must be an integer. The value value is pushed onto the stack of the previous execution environment. Any other values on the operand stack are discarded. The interpreter then returns control to its caller.</p><p>lreturn</p><p>Return long integer from function</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlreturn=173                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;[empty]</p><p>value must be a long integer. The value value is pushed onto the stack of the previous execution environment. Any other values on the operand stack are discarded. The interpreter then returns control to its caller.</p><p>freturn</p><p>Return single float from function</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nfreturn=174                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;[empty]</p><p>value must be a single-precision floating point number. The value value is pushed onto the stack of the previous execution environment. Any other values on the operand stack are discarded. The interpreter then returns control to its caller.</p><p>dreturn</p><p>Return double float from function</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ndreturn=175                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value-word1, value-word2=&gt;[empty]</p><p>value must be a double-precision floating point number. The value value is pushed onto the stack of the previous execution environment. Any other values on the operand stack are discarded. The interpreter then returns control to its caller.</p><p>areturn</p><p>Return object reference from function</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nareturn=176                                                               \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;[empty]</p><p>value must be a reference to an object. The value value is pushed onto the stack of the previous execution environment. Any other values on the operand stack are discarded. The interpreter then returns control to its caller.</p><p>return</p><p>Return (void) from procedure</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nreturn=177                                                                \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;[empty]</p><p>All values on the operand stack are discarded. The interpreter then returns control to its caller.</p><p>breakpoint</p><p>Stop and pass control to breakpoint handler</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nbreakpoint=202                                                            \n______________________________________                                    \n</pre><p>Stack: no change</p><p>3.13 Table Jumping</p><p>tableswitch</p><p>Access jump table by index and jump</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ntableswitch = 170                                                         \n. . . 0-3 byte pad . . .                                                  \ndefault-offset1                                                           \ndefault-offset2                                                           \ndefault-offset3                                                           \ndefault-offset4                                                           \nlow1                                                                      \nlow2                                                                      \nlow3                                                                      \n1ow4                                                                      \nhigh1                                                                     \nhigh2                                                                     \nhigh3                                                                     \nhigh4                                                                     \n. . . jump offsets . . .                                                  \n______________________________________                                    \n</pre><p>Stack: . . . , index=&gt;. . .</p><p>tableswitch is a variable length instruction. Immediately after the tableswitch opcode, between zero and three 0's are inserted as padding so that the next byte begins at an address that is a multiple of four. After the padding follow a series of signed 4-byte quantities: default-offset, low, high, and then high-low+1 further signed 4-byte offsets. The high-low+1 signed 4-byte offsets are treated as a 0-based jump table.</p><p>The index must be an integer. If index is less than low or index is greater than high, then default-offset is added to the address of this instruction. Otherwise, low is subtracted from index, and the index-low'th element of the jump table is extracted, and added to the address of this instruction.</p><p>lookupswitch</p><p>Access jump table by key match and jump</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nlookupswitch=171                                                          \n. . . 0-3 byte pad . . .                                                  \ndefault-offset1                                                           \ndefault-offset2                                                           \ndefault-offset3                                                           \ndefault-offset4                                                           \nnpairs1                                                                   \nnpairs2                                                                   \nnpairs3                                                                   \nnpairs4                                                                   \n. . . match-offset pairs . . .                                            \n______________________________________                                    \n</pre><p>Stack: . . . , key=&gt;. . .</p><p>lookupswitch is a variable length instruction. Immediately after the lookupswitch opcode, between zero and three 0's are inserted as padding so that the next byte begins at an address that is a multiple of four.</p><p>Immediately after the padding are a series of pairs of signed 4-byte quantities. The first pair is special. The first item of that pair is the default offset, and the second item of that pair gives the number of pairs that follow. Each subsequent pair consists of a match and an offset.</p><p>The key must be an integer. The integer key on the stack is compared against each of the matches. If it is equal to one of them, the offset is added to the address of this instruction. If the key does not match any of the matches, the default offset is added to the address of this instruction.</p><p>3.14 Manipulating Object Fields</p><p>putfield</p><p>Set field in object</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nputfield=181                                                              \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , objectref, value=&gt;. . . OR</p><p>Stack: . . . , objectref, value-word1, value-word2=&gt;. . .</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The constant pool item will be a field reference to a class name and a field name. The item is resolved to a field block pointer which has both the field width (in bytes) and the field offset (in bytes).</p><p>The field at that offset from the start of the object referenced by object refwill be set to the value on the top of the stack.</p><p>This instruction deals with both 32-bit and 64-bit wide fields.</p><p>If object ref is null, aNullPointerException is generated.</p><p>If the specified field is a static field, anIncompatibleClassChangeError is thrown.</p><p>getfield</p><p>Fetch field from object</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ngetfield=180                                                              \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , objectref=&gt;. . . ,value OR</p><p>Stack: . . . , objectref=&gt;. . . , value-word1, value-word2</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The constant pool item will be a field reference to a class name and a field name. The item is resolved to a field block pointer which has both the field width (in bytes) and the field offset (in bytes).</p><p>objectref must be a reference to an object. The value at offset into the object referenced by objectref replaces objectref on the top of the stack.</p><p>This instruction deals with both 32-bit and 64-bit wide fields.</p><p>If objectref is null, a NullPointerException is generated.</p><p>If the specified field is a static field, an IncompatibleClassChangeError is thrown.</p><p>putstatic</p><p>Set static field in class</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nputstatic-179                                                             \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , value=&gt;. . . OR</p><p>Stack: . . . , value-word1, value-word2=&gt;. . .</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The constant pool item will be a field reference to a static field of a class. That field will be set to have the value on the top of the stack.</p><p>This instruction works for both 32-bit and 64-bit wide fields.</p><p>If the specified field is a dynamic field, an IncompatibleClassChangeError is thrown.</p><p>getstatic</p><p>Get static field from class</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ngetstatic=178                                                             \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , =&gt;. . . , value OR</p><p>Stack: . . . , =&gt;. . . , value-word1, value-word2</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The constant pool item will be a field reference to a static field of a class.</p><p>This instruction deals with both 32-bit and 64-bit wide fields.</p><p>If the specified field is a dynamic field, an IncompatibleClassChangeError is generated.</p><p>3.15 Method Invocation</p><p>There are four instructions that implement method invocation.</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ninvokevirtual  Invoke an instance method of an                            \n               object, dispatching based on the                           \n               runtime (virtual) type of the                              \n               object. This is the normal method                          \n               dispatch in JAVA.                                          \ninvokenonvirtual                                                          \n               Invoke an instance method of an                            \n               object, dispatching based on the                           \n               compile-time (non-virtual) type of                         \n               the object. This is used, for                              \n               example, when the keywordsuper or                          \n               the name of a superclass is used as                        \n               a method qualifier.                                        \ninvokestatic   Invoke a class (static) method in a                        \n               named class.                                               \ninvokeinterface                                                           \n               Invoke a method which is                                   \n               implemented by an interface,                               \n               searching the methods implemented                          \n               by the particular run-time object                          \n               to find the appropriate method.                            \n______________________________________                                    \n</pre><p>invokevirtual</p><p>Invoke instance method, dispatch based on run-time type</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ninvokevirtual=182                                                         \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , objectref, [arg1, [arg2 . . . ]], . . . =&gt;. . .</p><p>The operand stack must contain a reference to an object and some number of arguments.indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item at that index in the constant pool contains the complete method signature. A pointer to the object's method table is retrieved from the object reference. The method signature is looked up in the method table. The method signature is guaranteed to exactly match one of the method signatures in the table.</p><p>The result of the lookup is an index into the method table of the named class, which is used with the object's dynamic type to look in the method table of that type, where a pointer to the method block for the matched method is found. The method block indicates the type of method (native, synchronized, and so on) and the number of arguments expected on the operand stack.</p><p>If the method is marked synchronized the monitor associated with objectref is entered.</p><p>The objectref and arguments are popped off this method's stack and become the initial values of the local variables of the new method. Execution continues with the first instruction of the new method.</p><p>If the object reference on the operand stack is null, a NullPointerException is thrown. If during the method invocation a stack overflow is detected, a StackOverflowError is thrown.</p><p>invokenonvirtual</p><p>Invoke instance method, dispatching based on compile-time type</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ninvokenonvirtual=183                                                      \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , objectref, [arg1, [arg2 . . . ]], . . . =&gt;. . .</p><p>The operand stack must contain a reference to an object and some number of arguments.indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item at that index in the constant pool contains a complete method signature and class. The method signature is looked up in the method table of the class indicated. The method signature is guaranteed to exactly match one of the method signatures in the table.</p><p>The result of the lookup is a method block. The method block indicates the type of method (native, synchronized, and so on) and the number of arguments (nargs) expected on the operand stack.</p><p>If the method is marked synchronized the monitor associated with objectref is entered.</p><p>The objectref and arguments are popped off this method's stack and become the initial values of the local variables of the new method. Execution continues with the first instruction of the new method.</p><p>If the object reference on the operand stack is null, a NullPointerException is thrown. If during the method invocation a stack overflow is detected, a StackOverflowError is thrown.</p><p>invokestatic</p><p>Invoke a class (static) method</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ninvokestatis=                                                             \n184                                                                       \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , [arg1, [arg2 . . . ]], . . . =&gt;. . .</p><p>The operand stack must contain some number of arguments.indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item at that index in the constant pool contains the complete method signature and class. The method signature is looked up in the method table of the class indicated. The method signature is guaranteed to exactly match one of the method signatures in the class's method table.</p><p>The result of the lookup is a method block. The method block indicates the type of method (native, synchronized, and so on) and the number of arguments (nargs) expected on the operand stack.</p><p>If the method is marked synchronized the monitor associated with the class is entered.</p><p>The arguments are popped off this method's stack and become the initial values of the local variables of the new method. Execution continues with the first instruction of the new method.</p><p>If during the method invocation a stack overflow is detected, a StackoverflowError is thrown.</p><p>invokeinterface</p><p>Invoke interface method</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ninvokeinterface = 185                                                     \nindexbyte1                                                                \nindexbyte2                                                                \nnargs                                                                     \nreserved                                                                  \n______________________________________                                    \n</pre><p>Stack: . . . , objectref, [arg1, [arg2 . . . ]], . . . =&gt;. . .</p><p>The operand stack must contain a reference to an object and nargs-1 arguments. indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item at that index in the constant pool contains the complete method signature. A pointer to the object's method table is retrieved from the object reference. The method signature is looked up in the method table. The method signature is guaranteed to exactly match one of the method signatures in the table.</p><p>The result of the lookup is a method block. The method block indicates the type of method (native, synchronized, and so on) but unlike invokevirtual and invokenonvirtual, the number of available arguments (nargs) is taken from the bytecode.</p><p>If the method is markedsynchronized the monitor associated with objectref is entered.</p><p>The objectref and arguments are popped off this method's stack and become the initial values of the local variables of the new method. Execution continues with the first instruction of the new method.</p><p>If the objectref on the operand stack is null, a NullPointerException is thrown. If during the method invocation a stack overflow is detected, a StackOverflowError is thrown.</p><p>3.16 Exception Handling</p><p>athrow</p><p>Throw exception or error</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nathrow = 191                                                              \n______________________________________                                    \n</pre><p>Stack: . . . , objectref=&gt;[undefined]</p><p>objectref must be a reference to an object which is a subclass of Throwable, which is thrown. The current JAVA stack frame is searched for the most recent catch clause that catches this class or a superclass of this class. If a matching catch list entry is found, the pc is reset to the address indicated by the catch-list entry, and execution continues there.</p><p>If no appropriate catch clause is found in the current stack frame, that frame is popped and the object is rethrown. If one is found, it contains the location of the code for this exception. The pc is reset to that location and execution continues. If no appropriate catch is found in the current stack frame, that frame is popped and the objectref is rethrown.</p><p>If objectref is null, then a NullPointerException is thrown instead.</p><p>3.17 Miscellaneous Object Operations</p><p>new</p><p>Create new object</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nnew = 187                                                                 \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . , objectref</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item at that index must be a class name that can be resolved to a class pointer, class. A new instance of that class is then created and a reference to the object is pushed on the stack.</p><p>checkcast</p><p>Make sure object is of given type</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ncheckcast =                                                               \n192                                                                       \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , objectref=&gt;. . . , objectref</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The string at that index of the constant pool is presumed to be a class name which can be resolved to a class pointer, class. objectref must be a reference to an object.</p><p>checkcast determines whether objectref can be cast to be a reference to an object of class class. A null objectref can be cast to any class. Otherwise the referenced object must be an instance of class or one of its superclasses. If objectref can be cast to class execution proceeds at the next instruction, and the objectref remains on the stack.</p><p>If objectref cannot be cast to class, a ClassCastException is thrown.</p><p>instanceof</p><p>Determine if an object is of given type</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ninstanceof = 193                                                          \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . , objectref=&gt;. . . , result</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The string at that index of the constant pool is presumed to be a class name which can be resolved to a class pointer, class. objectref must be a reference to an object.</p><p>instanceof determines whether objectref can be cast to be a reference to an object of the class class. This instruction will overwrite objectref with 1 if objectref is an instance of class or one of its superclasses. Otherwise, objectref is overwritten by 0. If objectref is null, it's overwritten by 0.</p><p>3.18 Monitors</p><p>monitorenter</p><p>Enter monitored region of code</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nmonitorenter = 194                                                        \n______________________________________                                    \n</pre><p>Stack: . . . , objectref=&gt;. . .</p><p>objectref must be a reference to an object.</p><p>The interpreter attempts to obtain exclusive access via a lock mechanism to objectref. If another thread already has objectref locked, than the current thread waits until the object is unlocked. If the current thread already has the object locked, then continue execution. If the object is not locked, then obtain an exclusive lock.</p><p>If objectref is null, then a NullPointerException is thrown instead.</p><p>monitorexit</p><p>Exit monitored region of code</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nmonitorexit = 195                                                         \n______________________________________                                    \n</pre><p>Stack: . . . , objectref=&gt;. . .</p><p>objectref must be a reference to an object. The lock on the object released. If this is the last lock that this thread has on that object (one thread is allowed to have multiple locks on a single object), then other threads that are waiting for the object to be available are allowed to proceed.</p><p>If objectref is null, then a NullPointerException is thrown instead.</p><p>Appendix A: An Optimization</p><p>The following set of pseudo-instructions suffixed by <sub>--</sub> quick are variants of JAVA virtual machine instructions. They are used to improve the speed of interpreting bytecodes. They are not part of the virtual machine specification or instruction set, and are invisible outside of an JAVA virtual machine implementation. However, inside a virtual machine implementation they have proven to be an effective optimization.</p><p>A compiler from JAVA source code to the JAVA virtual machine instruction set emits only non-<sub>--</sub> quick instructions. If the <sub>--</sub> quick pseudo-instructions are used, each instance of a non-<sub>--</sub> quick instruction with a <sub>--</sub> quick variant is overwritten on execution by its <sub>--</sub> quick variant. Subsequent execution of that instruction instance will be of the<sub>--</sub> quick variant.</p><p>In all cases, if an instruction has an alternative version with the suffix<sub>--</sub> quick, the instruction references the constant pool. If the<sub>--</sub> quick optimization is used, each non-<sub>--</sub> quick instruction with a<sub>--</sub> quick variant performs the following:</p><p>Resolves the specified item in the constant pool;</p><p>Signals an error if the item in the constant pool could not be resolved for some reason;</p><p>Turns itself into the <sub>--</sub> quick version of the instruction. The instructions putstatic, getstatic, putfield, and getfield each have two <sub>--</sub> quick versions; and</p><p>Performs its intended operation.</p><p>This is identical to the action of the instruction without the <sub>--</sub> quick optimization, except for the additional step in which the instruction overwrites itself with its <sub>--</sub> quick variant.</p><p>The <sub>--</sub> quick variant of an instruction assumes that the item in the constant pool has already been resolved, and that this resolution did not generate any errors. It simply performs the intended operation on the resolved item.</p><p>Note: some of the invoke methods only support a single-byte offset into the method table of the object; for objects with 256 or more methods some invocations cannot be \"quicked\" with only these bytecodes.</p><p>This Appendix doesn't give the opcode values of the pseudo-instructions, since they are invisible and subject to change.</p><p>A.1 Constant Pool Resolution</p><p>When the class is read in, an array constant<sub>--</sub> pool [] of size n constants is created and assigned to a field in the class.constant<sub>--</sub> pool [0] is set to point to a dynamically allocated array which indicates which fields in the constant<sub>--</sub> pool have already been resolved.constant<sub>--</sub> pool [1] through constant<sub>--</sub> pool [nconstants-1] are set to point at the \"type\" field that corresponds to this constant item.</p><p>When an instruction is executed that references the constant pool, an index is generated, and constant<sub>--</sub> pool[0] is checked to see if the index has already been resolved. If so, the value of constant<sub>--</sub> pool [index] is returned. If not, the value of constant<sub>--</sub> pool [index] is resolved to be the actual pointer or data, and overwrites whatever value was already in constant<sub>--</sub> pool [index].</p><p>A.2 Pushing Constants onto the Stack (<sub>--</sub> quick variants)</p><p>ldc1<sub>--</sub> quick</p><p>Push item from constant pool onto stack</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n1dc1.sub.-- quick                                                         \nindexbyte1                                                                \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . ,item</p><p>indexbyte1 is used as an unsigned 8-bit index into the constant pool of the current class. The item at that index is pushed onto the stack.</p><p>ldc2<sub>--</sub> quick</p><p>Push item from constant pool onto stack</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n1dc2.sub.-- quick                                                         \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . ,item</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The constant at that index is resolved and the item at that index is pushed onto the stack.</p><p>ldc2w<sub>--</sub> quick</p><p>Push long integer or double float from constant pool onto stack</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n1dc2w.sub.-- quick                                                        \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . ,constant-word1,constant-word2</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The constant at that index is pushed onto the stack.</p><p>A.3 Managing Arrays (<sub>--</sub> quick variants)</p><p>anewarray<sub>--</sub> quick</p><p>Allocate new array of references to objects</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nanewarray.sub.-- quick                                                    \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . ,size=&gt;result</p><p>size must be an integer. It represents the number of elements in the new array.</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The entry must be a class.</p><p>A new array of the indicated class type and capable of holding size elements is allocated, and result is a reference to this new array. Allocation of an array large enough to contain size items of the given class type is attempted. All elements of the array are initialized to zero.</p><p>If size is less than zero, a NegativeArraySizeException is thrown. If there is not enough memory to allocate the array, an OutOfMemoryError is thrown.</p><p>multianewarray<sub>--</sub> quick</p><p>Allocate new multi-dimensional array</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nmultianewarray.sub.-- quick                                               \nindexbyte1                                                                \nindexbyte2                                                                \ndimensions                                                                \n______________________________________                                    \n</pre><p>Stack: . . . ,size1,size2, . . .sizen=&gt;result</p><p>Each size must be an integer. Each represents the number of elements in a dimension of the array.</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The resulting entry must be a class.</p><p>dimensions has the following aspects:</p><p>It must be an integer \u22671.</p><p>It represents the number of dimensions being created. It must be 5 the number of dimensions of the array class.</p><p>It represents the number of elements that are popped off the stack. All must be integers greater than or equal to zero. These are used as the sizes of the dimension.</p><p>If any of the size arguments on the stack is less than zero, a NegativeArraySizeException is thrown. If there is not enough memory to allocate the array, an OutOfMemoryError is thrown.</p><p>The result is a reference to the new array object.</p><p>A.4 Manipulating Object Fields (<sub>--</sub> quick variants)</p><p>putfield<sub>--</sub> quick</p><p>Set field in object</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nputfield2.sub.-- quick                                                    \noffset                                                                    \nunused                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . ,objectref,value=&gt;. . .</p><p>objectref must be a reference to an object. value must be a value of a type appropriate for the specified field. offset is the offset for the field in that object. value is written at offset into the object. Both objectref and value are popped from the stack.</p><p>If objectref is null, a NullPointerException is generated.</p><p>putfield2<sub>--</sub> quick</p><p>Set long integer or double float field in object</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nputfield2.sub.-- quick                                                    \noffset                                                                    \nunused                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . ,objectref,value-word1,value-word2=&gt;. . .</p><p>objectref must be a reference to an object. value must be a value of a type appropriate for the specified field. offset is the offset for the field in that object. value is written at offset into the object. Both objectref and value are popped from the stack.</p><p>If objectref is null, a NullPointerException is generated.</p><p>getfield<sub>--</sub> quick</p><p>Fetch field from object</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ngetfield2.sub.-- quick                                                    \noffset                                                                    \nunused                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . ,objectref=&gt;. . . ,value</p><p>objectref must be a handle to an object. The value at offset into the object referenced by objectref replaces objectref on the top of the stack.</p><p>If objectref is null, a NullPointerException is generated.</p><p>getfield2<sub>--</sub> quick</p><p>Fetch field from object</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ngetfield2.sub.-- quick                                                    \noffset                                                                    \nunused                                                                    \n______________________________________                                    \n</pre><p>Stack: . . . ,objectref=&gt;. . . ,value-word1,value-word2</p><p>objectref must be a handle to an object. The value at offset into the object referenced by objectref replaces objectref on the top of the stack.</p><p>If objectref is null, a NullPointerException is generated.</p><p>putstatic<sub>--</sub> quick</p><p>Set static field in class</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nputstatic.sub.-- quick                                                    \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . ,value=&gt;. . .</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The constant pool item will be a field reference to a static field of a class.value must be the type appropriate to that field. That field will be set to have the value value.</p><p>putstatic2<sub>--</sub> quick</p><p>Set static field in class</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nputstatic2.sub.-- quick                                                   \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . ,value-word1,value-word2=&gt;. . .</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The constant pool item will be a field reference to a static field of a class. That field must either be a long integer or a double precision floating point number. value must be the type appropriate to that field. That field will be set to have the value value.</p><p>getstatic<sub>--</sub> quick</p><p>Get static field from class</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ngetstatic.sub.-- quick                                                    \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . ,=&gt;. . . ,value</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The constant pool item will be a field reference to a static field of a class. The value of that field will replace handle on the stack.</p><p>getstatic2<sub>--</sub> quick</p><p>Get static field from class</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ngetstatic2.sub.-- quick                                                   \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . ,=&gt;. . . ,value-word1,value-word2</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The constant pool item will be a field reference to a static field of a class. The field must be a long integer or a double precision floating point number. The value of that field will replace handle on the stack</p><p>A.5 Method Invocation (<sub>--</sub> quick variants)</p><p>invokevirtual<sub>--</sub> quick</p><p>Invoke instance method, dispatching based on run-time type</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ninvokevirtual.sub.-- quick                                                \noffset                                                                    \nnargs                                                                     \n______________________________________                                    \n</pre><p>Stack: . . . ,objectref,[arg1,[arg2 . . . ]]=&gt;. . .</p><p>The operand stack must contain objectref, a reference to an object and nargs-1 arguments. The method block at offset in the object's method table, as determined by the object's dynamic type, is retrieved. The method block indicates the type of method (native, synchronized, etc.).</p><p>If the method is marked synchronized the monitor associated with the object is entered.</p><p>The base of the local variables array for the new JAVA stack frame is set to point to objectref on the stack, making objectref and the supplied arguments (arg1,arg2, . . . ) the first nargs local variables of the new frame. The total number of local variables used by the method is determined, and the execution environment of the new frame is pushed after leaving sufficient room for the locals. The base of the operand stack for this method invocation is set to the first word after the execution environment. Finally, execution continues with the first instruction of the matched method.</p><p>If objectref is null, a NullPointerException is thrown. If during the method invocation a stack overflow is detected, a StackOverflowError is thrown.</p><p>invokevirtualobject<sub>--</sub> quick</p><p>Invoke instance method of class JAVA.lang.object, specifically for benefit of arrays</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ninvokevirtualobject.sub.-- quick                                          \noffset                                                                    \nnargs                                                                     \n______________________________________                                    \n</pre><p>Stack: . . . ,objectref,[arg1,[arg2 . . . ]]=&gt;. . .</p><p>The operand stack must contain objectref, a reference to an object or to an array and nargs-1 arguments. The method block at offset in JAVA.lang.Object's method table is retrieved. The method block indicates the type of method (native, synchronized, etc.).</p><p>If the method is marked synchronized the monitor associated with handle is entered.</p><p>The base of the local variables array for the new JAVA stack frame is set to point to objectref on the stack, making objectref and the supplied arguments (arg1,arg2, . . . ) the first nargs local variables of the new frame. The total number of local variables used by the method is determined, and the execution environment of the new frame is pushed after leaving sufficient room for the locals. The base of the operand stack for this method invocation is set to the first word after the execution environment. Finally, execution continues with the first instruction of the matched method.</p><p>If objectref is null, a NullPointerException is thrown. If during the method invocation a stack overflow is detected, a StackoverflowError is thrown.</p><p>invokenonvirtual<sub>--</sub> quick</p><p>Invoke instance method, dispatching based on compile-time type</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ninvokenonvirtual.sub.-- quick                                             \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . ,objectref,[arg1,[arg2 . . .]]=&gt;. . .</p><p>The operand stack must contain objectref, a reference to an object and some number of arguments. indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item at that index in the constant pool contains a method slot index and a pointer to a class. The method block at the method slot index in the indicated class is retrieved. The method block indicates the type of method (native, synchronized, etc.) and the number of arguments (nargs) expected on the operand stack.</p><p>If the method is marked synchronized the monitor associated with the object is entered.</p><p>The base of the local variables array for the new JAVA stack frame is set to point to objectref on the stack, making objectref and the supplied arguments (arg1, arg2, . . . ) the first nargs local variables of the new frame. The total number of local variables used by the method is determined, and the execution environment of the new frame is pushed after leaving sufficient room for the locals. The base of the operand stack for this method invocation is set to the first word after the execution environment. Finally, execution continues with the first instruction of the matched method.</p><p>If objectref is null, a NullPointerException is thrown. If during the method invocation a stack overflow is detected, a StackOverflowError is thrown.</p><p>invokestatic<sub>--</sub> quick</p><p>Invoke a class (static) method</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ninvokestatic.sub.-- quick                                                 \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . ,[arg1,[arg2 . . . ]]=&gt;. . .</p><p>The operand stack must contain some number of arguments. indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item at that index in the constant pool contains a method slot index and a pointer to a class. The method block at the method slot index in the indicated class is retrieved. The method block indicates the type of method (native, synchronized, etc.) and the number of arguments (nargs) expected on the operand stack.</p><p>If the method is marked synchronized the monitor associated with the method's class is entered.</p><p>The base of the local variables array for the new JAVA stack frame is set to point to the first argument on the stack, making the supplied arguments (arg1,arg2, . . . ) the first nargs local variables of the new frame. The total number of local variables used by the method is determined, and the execution environment of the new frame is pushed after leaving sufficient room for the locals. The base of the operand stack for this method invocation is set to the first word after the execution environment. Finally, execution continues with the first instruction of the matched method.</p><p>If the object handle on the operand stack is null, a NullPointerException is thrown. If during the method invocation a stack overflow is detected, a StackOverflowError is thrown.</p><p>invokeinterface<sub>--</sub> quick</p><p>Invoke interface method</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ninvokeinterface.sub.-- quick                                              \nidbyte1                                                                   \nidbyte2                                                                   \nnargs                                                                     \nguess                                                                     \n______________________________________                                    \n</pre><p>Stack: . . . ,objectref,[arg1,[arg2 . . . ]]=&gt;. . .</p><p>The operand stack must contain objectref, a reference to an object, and nargs-1 arguments. idbyte1 and idbyte2 are used to construct an index into the constant pool of the current class. The item at that index in the constant pool contains the complete method signature. A pointer to the object's method table is retrieved from the object handle.</p><p>The method signature is searched for in the object's method table. As a short-cut, the method signature at slot guess is searched first. If that fails, a complete search of the method table is performed. The method signature is guaranteed to exactly match one of the method signatures in the table.</p><p>The result of the lookup is a method block. The method block indicates the type of method (native, synchronized, etc.) but the number of available arguments (nargs) is taken from the bytecode.</p><p>If the method is marked synchronized the monitor associated with handle is entered.</p><p>The base of the local variables array for the new JAVA stack frame is set to point to handle on the stack, making handle and the supplied arguments (arg1,arg2, . . . ) the first nargs local variables of the new frame. The total number of local variables used by the method is determined, and the execution environment of the new frame is pushed after leaving sufficient room for the locals. The base of the operand stack for this method invocation is set to the first word after the execution environment. Finally, execution continues with the first instruction of the matched method.</p><p>If objectref is null, a NullPointerException is thrown. If during the method invocation a stack overflow is detected, a StackOverflowError is thrown.</p><p>guess is the last guess. Each time through, guess is set to the method offset that was used.</p><p>A.6 Miscellaneous Object Operations (<sub>--</sub> quick variants)</p><p>new<sub>--</sub> quick</p><p>Create new object</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \nnew.sub.-- quick                                                          \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . =&gt;. . . ,objectref</p><p>indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item at that index must be a class. A new instance of that class is then created and objectref, a reference to that object is pushed on the stack.</p><p>checkcast<sub>--</sub> quick</p><p>Make sure object is of given type</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ncheckcast.sub.-- quick                                                    \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . ,objectref=&gt;. . . ,objectref</p><p>objectref must be a reference to an object. indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The object at that index of the constant pool must have already been resolved.</p><p>checkcast then determines whether objectref can be cast to a reference to an object of class class. A null reference can be cast to any class, and otherwise the superclasses of objectref's type are searched for class. If class is determined to be a superclass of objectref's type, or if objectref is null, it can be cast to objectref cannot be cast to class, a ClassCastException is thrown.</p><p>instanceof<sub>--</sub> quick</p><p>Determine if object is of given type</p><p>Syntax:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \ninstanceof.sub.-- quick                                                   \nindexbyte1                                                                \nindexbyte2                                                                \n______________________________________                                    \n</pre><p>Stack: . . . ,objectref=&gt;. . . ,result</p><p>objectref must be a reference to an object. indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item of class class at that index of the constant pool must have already been resolved.</p><p>Instance of determines whether objectref can be cast to an object of the class class. A null objectref can be cast to any class, and otherwise the superclasses of objectref's type are searched for class. If class is determined to be a superclass of objectref's type, result is 1 (true). Otherwise, result is 0 (false). If handle is null, result is 0 (false).</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Marc", "last_name": "Tremblay", "name": ""}, {"first_name": "James Michael", "last_name": "O'Connor", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "SUN MICROSYTEMS, INC."}, {"first_name": "", "last_name": "Oracle America, Inc.", "name": ""}, {"first_name": "", "last_name": "SUN MICROSYSTEMS, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/02"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/445       20060101A I20051008RMEP"}, {"label": "G06F   9/345       20060101A I20051008RMEP"}, {"label": "G06F   9/318       20060101A I20051008RMEP"}, {"label": "G06F   9/32        20060101A I20051008RMEP"}, {"label": "G06F   9/40        20060101A I20051008RMEP"}, {"label": "G06F   9/42        20060101A I20051008RMEP"}, {"label": "G06F   9/455       20060101A I20051008RMEP"}, {"label": "G06F   9/30        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711108"}, {"primary": false, "label": "712E09082"}, {"primary": false, "label": "712E09039"}, {"primary": false, "label": "711128"}, {"primary": false, "label": "712E0902"}, {"primary": false, "label": "711221"}, {"primary": false, "label": "712E09084"}, {"primary": false, "label": "712E09077"}, {"primary": false, "label": "712E09035"}, {"primary": false, "label": "712E09075"}, {"primary": false, "label": "36504917"}, {"primary": false, "label": "712E09037"}, {"primary": false, "label": "712E09027"}, {"primary": false, "label": "707999006"}], "ecla_classes": [{"label": "G06F   9/30X"}, {"label": "G06F   9/30A1C"}, {"label": "S06F212:451"}, {"label": "G06F   9/30A3C"}, {"label": "G06F   9/30U2"}, {"label": "G06F   9/30R5S"}, {"label": "G06F   9/44F2A"}, {"label": "G06F   9/44F1A"}, {"label": "G06F   9/32B"}, {"label": "G06F   9/345"}, {"label": "G06F   9/445V"}, {"label": "G06F   9/455H"}], "cpc_classes": [{"label": "G06F   9/30058"}, {"label": "G06F   9/4484"}, {"label": "G06F   9/30058"}, {"label": "G06F   9/30174"}, {"label": "G06F   9/449"}, {"label": "G06F   9/30145"}, {"label": "G06F   9/322"}, {"label": "G06F   9/30174"}, {"label": "G06F2212/451"}, {"label": "G06F   9/449"}, {"label": "G06F   9/345"}, {"label": "G06F   9/30021"}, {"label": "G06F   9/30134"}, {"label": "G06F   9/44589"}, {"label": "G06F   9/4484"}, {"label": "G06F   9/30134"}, {"label": "G06F   9/30196"}, {"label": "Y10S 707/99936"}, {"label": "G06F2212/451"}, {"label": "G06F   9/30145"}, {"label": "G06F   9/44589"}, {"label": "G06F   9/30021"}, {"label": "G06F   9/322"}, {"label": "G06F   9/30196"}, {"label": "G06F   9/345"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1996-01-24", "application_date": "1997-01-23", "family_members": [{"ucid": "US-6076141-A", "titles": [{"lang": "EN", "text": "Look-up switch accelerator and method of operating same"}]}]}