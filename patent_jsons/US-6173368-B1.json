{"patent_number": "US-6173368-B1", "publication_id": 72538030, "family_id": 27485813, "publication_date": "2001-01-09", "titles": [{"lang": "EN", "text": "Class categorized storage circuit for storing non-cacheable data until receipt of a corresponding terminate signal"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11123455\" source=\"national office\"><p>A microprocessor (62) for coupling to an external read/write memory (70) having an addressable storage space for storing data. The microprocessor includes a data storage circuit (76) for storing a portion of the data, where that portion of data comprises non-cacheable data. The microprocessor further includes a class storage circuit (80) for storing a class identifier corresponding to the portion of the non-cacheable data, as well as an input (TERMINATE) for receiving a terminate signal and an input (CLASS) for receiving a class signal. Lastly, the microprocessor includes an indicator (82) for indicating that the portion of the non-cacheable data in the data storage circuit is expired in response to assertions of the terminate signal and the class signal matching the class identifier.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72495400\"><p>A microprocessor (<b>62</b>) for coupling to an external read/write memory (<b>70</b>) having an addressable storage space for storing data. The microprocessor includes a data storage circuit (<b>76</b>) for storing a portion of the data, where that portion of data comprises non-cacheable data. The microprocessor further includes a class storage circuit (<b>80</b>) for storing a class identifier corresponding to the portion of the non-cacheable data, as well as an input (TERMINATE) for receiving a terminate signal and an input (CLASS) for receiving a class signal. Lastly, the microprocessor includes an indicator (<b>82</b>) for indicating that the portion of the non-cacheable data in the data storage circuit is expired in response to assertions of the terminate signal and the class signal matching the class identifier.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00001\" num=\"1\"><claim-text>1. A microprocessor for coupling to an external read/write memory having an addressable storage space for storing data including non-cacheable data, said microprocessor comprising:</claim-text><claim-text>a non-cacheable data storage circuit for storing a portion of said data which comprises non-cacheable data recalled from the external read/write memory; </claim-text><claim-text>a non-cacheable address storage circuit for storing an address corresponding to said non-cacheable data stored in said non-cacheable data storage circuit; </claim-text><claim-text>a class storage circuit for storing a class identifier corresponding to said non-cacheable data stored in said non-cacheable data storage circuit; </claim-text><claim-text>an input for receiving a class signal indicating a class for a corresponding subset of non-cacheable data; </claim-text><claim-text>an input for receiving a terminate signal indicating expiration of a lifespan of non-cacheable data corresponding to said class signal; </claim-text><claim-text>an indicator for indicating a lifespan of said non-cacheable data in said non-cacheable data storage circuit is expired in response to assertions of said terminate signal and said class signal matching said class identifier; and </claim-text><claim-text>a control circuit connected to said non-cacheable address storage circuit, said non-cacheable address storage circuit, said indicator and a read address of a central processing unit for comparing said read address to said non-cacheable address and generating a hit signal permitting said central processing unit to read from said non-cacheable data storage circuit upon an address match if said indicator indicates said non-cacheable data in said non-cacheable data storage circuit is not expired. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00002\" num=\"2\"><claim-text>2. The microprocessor of claim <b>1</b> wherein:</claim-text><claim-text>said control circuit is further connected to a write address of said central processing unit for comparing said write address to said non-cacheable address and generating said hit signal permitting said central processing unit to write to said non-cacheable data storage circuit upon an address match if said indicator indicates said non-cacheable data in said non-cacheable data storage circuit is not expired; </claim-text><claim-text>and further comprising a clean/dirty indicator for indicating said non-cacheable data in said non-cacheable data storage circuit has been modified after being stored in said non-cacheable data storage circuit. </claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00003\" num=\"3\"><claim-text>3. The microprocessor of claim <b>2</b> and further comprising:</claim-text><claim-text>circuitry for evaluating said clean/dirty indicator; and </claim-text><claim-text>circuitry for writing said non-cacheable data to said addressable storage space of said external read/write memory in response to said circuitry for evaluating detecting that said clean/dirty indicator has changed from a clean state to a dirty state. </claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00004\" num=\"4\"><claim-text>4. The microprocessor of claim <b>3</b> wherein said circuitry for evaluating said clean/dirty indicator evaluates said clean/dirty indicator in response to assertions of said terminate signal and said class signal matching said class identifier.</claim-text></claim>"}, {"num": 5, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00005\" num=\"5\"><claim-text>5. The microprocessor of claim <b>3</b> wherein said circuitry for evaluating said clean/dirty indicator evaluates said clean/dirty indicator before response to assertions of said terminate signal and said class signal matching said class identifier.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00006\" num=\"6\"><claim-text>6. The microprocessor of claim <b>1</b> wherein said addressable storage space of said external read/write memory includes a video display buffer storing non-cacheable display data for a screen display in a plurality of scan lines and wherein:</claim-text><claim-text>said terminate signal is asserted in response to a horizontal synchronization signal. </claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00007\" num=\"7\"><claim-text>7. The microprocessor of claim <b>1</b> wherein said addressable storage space of said external read/write memory includes a video display buffer storing non-cacheable display data for a screen display in a plurality of scan lines and wherein:</claim-text><claim-text>said terminate signal is asserted in response to a vertical synchronization signal. </claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00008\" num=\"8\"><claim-text>8. The microprocessor of claim <b>1</b> and further comprising:</claim-text><claim-text>a prefetch buffer, wherein said non-cacheable data storage circuit is a storage circuit in said prefetch buffer and wherein said prefetch buffer is operable to perform a prefetch function; </claim-text><claim-text>an enable signal associated with said non-cacheable data storage circuit; </claim-text><claim-text>wherein, whe said enable signal is asserted in a first state: </claim-text><claim-text>said non-cacheable data storage circuit operates according to stor said non-cacheable data; and </claim-text><claim-text>said indicator for indicating said non-cacheable data in said non-cacheable data storage circuit is expired is established in response to assertions of said terminate signal and said class signal matching said class identifier; and </claim-text><claim-text>wherein, when said enable signal is asserted in a second state said non-cacheable data storage circuit operates to perform said prefetch function. </claim-text></claim>"}, {"num": 9, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00009\" num=\"9\"><claim-text>9. A microprocessor for coupling to an externalread/write memory having an addressable storage space for storing dat including non-cacheable data, said microprocessor comprising:</claim-text><claim-text>a non-cacheable data storage circuit for storing a portion of said data which comprises non-cacheable data; </claim-text><claim-text>a non-cacheable address storage circuit for storing an address corresponding to said non-cacheable data stored in said non-cacheable data storage circuit; </claim-text><claim-text>a class storage circuit for storing a class identifier corresponding to said non-cacheable data stored in said non-cacheable data storage circuit; </claim-text><claim-text>an input for receiving a class signal indicating a class for a corresponding subset of non-cacheable data; </claim-text><claim-text>an input for receiving a terminate signal indicating an end of a lifespan of non-cacheable data corresponding to said class signal; </claim-text><claim-text>an indicator for indicating said non-cacheable data in said non-cacheable data storage circuit is expired in response to assertions of said terminate signal and said class signal matching said class identifier; </claim-text><claim-text>a control circuit connected to said non-cacheable address storage circuit, said non-cacheable address storage circuit, said indicator and a read address of a central processing unit for comparing said read address to said non-cacheable address and generating a hit signal permitting said central processing unit to read from said non-cacheable data storage circuit upon a match; </claim-text><claim-text>a prefetch buffer, wherein said non-cacheable data storage circuit is a storage circuit in said prefetch buffer and wherein said prefetch buffer is operable to perform a prefetch function; </claim-text><claim-text>an enable signal associated with said non-cacheable data storage circuit; </claim-text><claim-text>wherein, when said enable signal is asserted in a first state: </claim-text><claim-text>said non-cacheable data storage circuit operates according to store said non-cacheable data; and </claim-text><claim-text>said indicator for indicating said non-cacheable data in said non-cacheable data storage circuit is expired is established in response to assertions of said terminate signal and said class signal matching said class identifier; and </claim-text><claim-text>wherein, when said enable signal is asserted in a second state said non-cacheable data storage circuit operates to perform said prefetch function; </claim-text><claim-text>wherein said prefetch buffer further comprises an additional plurality of non-cacheable data storage circuits, each for storing a portion of said data which comprises non-cacheable data; </claim-text><claim-text>and further comprising an additional plurality of class storage circuits, wherein each of said additional plurality of class storage circuits is associated with a corresponding one of said additional plurality of non-cacheable data storage circuits and is operable to store a corresponding class identifier; </claim-text><claim-text>and further comprising an additional plurality of indicators corresponding to each of said additional plurality of non-cacheable data storage circuits, and for indicating said non-cacheable data in said corresponding storage circuit is expired in response to assertions of said terminate signal and said class signal matching said corresponding class identifier. </claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00010\" num=\"10\"><claim-text>10. The microprocessor of claim <b>9</b> and further comprising:</claim-text><claim-text>an non-cacheable address storage circuit for storing an address corresponding to said portion of said data which comprises said non-cacheable data; </claim-text><claim-text>an additional plurality of non-cacheable address storage circuits, each for storing an address corresponding to said portion of said data which comprises non-cacheable data stored in a corresponding one of said additional plurality of non-cacheable data storage circuits; </claim-text><claim-text>circuitry for comparing a snoop address to said address stored in each of said non-cacheable address storage circuits; and </claim-text><claim-text>circuitry for outputting a hit in response to said circuitry for comparing finding a match of said snoop address to said address in one of said non-cacheable address storage circuits and said indicators corresponding to said non-cacheable data storage circuit corresponding to said one of said non-cacheable address storage circuits indicating said data in said corresponding non-cacheable data storage circuit is not expired. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00011\" num=\"11\"><claim-text>11. The microprocessor of claim <b>10</b>:</claim-text><claim-text>and further comprising a plurality of clean/dirty indicators, wherein each of said plurality of clean/dirty indicators corresponds to one of said non-cacheable data storage circuits; </claim-text><claim-text>wherein each of said plurality of clean/dirty indicators is for indicating said non-cacheable data in said corresponding one of said non-cacheable data storage circuits has been modified after being stored in said non-cacheable data storage circuit; </claim-text><claim-text>and further comprising: </claim-text><claim-text>circuitry, in response to said hit, for outputting said non-cacheable data from said non-cacheable data storage circuit corresponding to said one of said non-cacheable address storage circuits; and </claim-text><claim-text>circuitry, responsive to said circuitry for outputting said portion of said non-cacheable data in response to said hit, for setting to clean said clean/dirty indicator corresponding to said non-cacheable data storage circuit corresponding to said one of said non-cacheable address storage circuits. </claim-text></claim>"}, {"num": 12, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00012\" num=\"12\"><claim-text>12. The microprocessor of claim <b>10</b>:</claim-text><claim-text>and further comprising a plurality of valid/invalid indicators, wherein each of said plurality of valid/invalid indicators corresponds to one of said non-cacheable data storage circuits; </claim-text><claim-text>wherein each of said plurality of valid/invalid indicators is for indicating said non-cacheable data in said corresponding one of said non-cacheable data storage circuits is valid or invalid; </claim-text><claim-text>and further comprising: </claim-text><claim-text>circuitry, in response to said hit, for outputting said non-cacheable data from said non-cacheable data storage circuit corresponding to said one of said non-cacheable address storage circuits; and </claim-text><claim-text>circuitry, responsive to said circuitry for outputting said non-cacheable data in response to said hit, for setting to invalid from valid said valid/invalid indicator corresponding to said non-cacheable data storage circuit corresponding to said one of said non-cacheable address storage circuits. </claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00013\" num=\"13\"><claim-text>13. A microprocessor for coupling to an external read/write memory having an addressable storage space for storing data including non-cacheable data, said microprocessor comprising:</claim-text><claim-text>a non-cacheable data storage circuit for storing a portion of said data which comprises non-cacheable data; </claim-text><claim-text>a non-cacheable address storage circuit for storing an address corresponding to said non-cacheable data stored in said non-cacheable data storage circuit; </claim-text><claim-text>a class storage circuit for storing a class identifier corresponding to said non-cacheable data stored in said non-cacheable data storage circuit; </claim-text><claim-text>an input for receiving a class signal indicating a class for a corresponding subset of non-cacheable data; </claim-text><claim-text>an input for receiving a terminate signal indicating an end of a lifespan of non-cacheable data corresponding to said class signal; </claim-text><claim-text>an indicator for indicating said non-cacheable data in said non-cacheable data storage circuit is expired in response to assertions of said terminate signal and said class signal matching said class identifier; and </claim-text><claim-text>a control circuit connected to said non-cacheable address storage circuit, said non-cacheable address storage circuit, said indicator and a read address of a central processing unit for comparing said read address to said non-cacheable address and generating a hit signal permitting said central processing unit to read from said non-cacheable data storage circuit upon an address match if said indicator indicates said non-cacheable data in said non-cacheable data storage circuit is not expired; </claim-text><claim-text>wherein said portion of said data which comprises non-cacheable data comprises a first portion of said non-cacheable data; </claim-text><claim-text>wherein said class storage circuit for storing a class identifier corresponding to said portion of said non-cacheable data comprises a first class storage circuit for storing a class identifier corresponding to said first portion of said non-cacheable data; </claim-text><claim-text>wherein said indicator for indicating said portion of said non-cacheable data in said non-cacheable data storage circuit is expired comprises a first indicator; </claim-text><claim-text>and further comprising: </claim-text><claim-text>a second non-cacheable data storage circuit for storing a second portion of said non-cacheable data; </claim-text><claim-text>a second class storage circuit for storing a class identifier corresponding to said second portion of said non-cacheable data; and </claim-text><claim-text>a second indicator for indicating said second portion of said non-cacheable data in said second non-cacheable data storage circuit is expired in response to assertions of said terminate signal and said class signal matching said class identifier in said second class storage circuit. </claim-text></claim>"}, {"num": 14, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00014\" num=\"14\"><claim-text>14. The microprocessor of claim <b>1</b> wherein said addressable storage space of said external read/write memory includes a disk data buffer for storing non-cacheable data and wherein:</claim-text><claim-text>said portion of said data stored in said non-cacheable data storage circuit comprises data for storing in said disk data buffer in said external read/write memory. </claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00015\" num=\"15\"><claim-text>15. The microprocessor of claim <b>14</b> wherein said terminate signal is asserted in response to an amount of data stored in said disk data buffer falling below a predetermined amount of data.</claim-text></claim>"}, {"num": 16, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00016\" num=\"16\"><claim-text>16. The microprocessor of claim <b>1</b> further comprising:</claim-text><claim-text>a timer having a predetermined time interval, wherein said timer is started upon initial storage of data into said non-cacheable data storage circuit and said terminate signal is asserted in response to said timer reaching said predetermined time interval. </claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00017\" num=\"17\"><claim-text>17. The microprocessor of claim <b>16</b> wherein said timer is located on the microprocessor.</claim-text></claim>"}, {"num": 18, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00018\" num=\"18\"><claim-text>18. The microprocessor of claim <b>1</b> wherein said addressable storage space of said external read/write memory includes a video display buffer storing non-cacheable display data for a screen display in a plurality of scan lines, further comprising:</claim-text><claim-text>a graphics adaptor connected to said external read/write memory for generating a raster scan video signal having interleaved horizontal synchronization signals for display from said plurality of scan lines of said video display buffer; </claim-text><claim-text>wherein data addresses within said external read/write memory corresponding to each of said plurality of scan lines have assigned a unique class code; and </claim-text><claim-text>wherein said graphics adaptor generates said terminate signal and a class signal for a corresponding one of said plurality of scan lines upon each horizontal synchronization signal. </claim-text></claim>"}, {"num": 19, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00019\" num=\"19\"><claim-text>19. A microprocessor for coupling to an external read/write memory having an addressable storage space for storing data including cacheable data and non-cacheable data, said microprocessor comprising:</claim-text><claim-text>a plurality of data cache memories, </claim-text><claim-text>a plurality of tag memories, one tag memory corresponding to each data cache memory, each tag memory including </claim-text><claim-text>an address field for storing an address within the addressable storage space corresponding to data stored in the corresponding data cache memory, </claim-text><claim-text>a valid/invalid indicator indicating whether data stored in the corresponding data cache memory is valid or invalid, </claim-text><claim-text>a class register storing a class indicator corresponding to data stored in said corresponding data cache memory; </claim-text><claim-text>a cache control circuit connected to the external read/write memory, said plurality of data cache memories, said plurality of tag memories and receiving a read address of a central processing unit and a terminate signal indicating expiration of a lifespan of non-cacheable data of a corresponding class, said cache control circuit operable to </claim-text><claim-text>compare said read address to said address field of each of said tag memories, </claim-text><claim-text>if said read address fails to match said address field of any of said plurality of tag memories or if said read address matches said address field of any one of said plurality of tag memories and said valid/invalid indicator of said matching tag memory indicates invalid (1) recall data from said read address within said external read/write memory, (2) store said recalled data in a data cache memory, (3) store said address in said address field of said corresponding tag memory, (4) set said valid/invalid indicator of said corresponding tag memory indicating valid and (5) store a class indicator of said corresponding tag memory indicating a class corresponding to said address if said external read/write memory stores non-cacheable data at said read address and (6) store a predetermined class indicator of said corresponding tag memory indicating cacheable data if said external read/write memory stores cacheable data at said read address, </claim-text><claim-text>if said read address matches said address field of any one of said plurality of tag memories and said valid/invalid indicator of said matching tag memory indicates valid (1) recall data from said data cache memory corresponding to said matching tag memory, </claim-text><claim-text>compare the class of a terminate signal to said class register of all tag memories, and </claim-text><claim-text>set said valid/invalid indicator to invalid for any tag memory in which said class of a terminate signal matches said class register, wherein no terminate signal has a class matching said predetermined class indicating cacheable data. </claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00020\" num=\"20\"><claim-text>20. The microprocessor of claim <b>19</b>, wherein:</claim-text><claim-text>each of said tag memories further includes a clean/dirty indicator indicating whether data stored in said corresponding data cache memory has been written to after initial storage; and </claim-text><claim-text>said control circuit further receives a write address and write data from said central processing unit, said cache control circuit further operable to </claim-text><claim-text>compare said write address to said address field of each of said tag memories, </claim-text><claim-text>if said write address matches said address field of any one of said plurality of tag memories (1) store said write data into said data cache memory corresponding to said matching tag memory and (2) set said clean/dirty indicator of said matching tag memory to dirty. </claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00021\" num=\"21\"><claim-text>21. The microprocessor of claim <b>20</b> wherein:</claim-text><claim-text>said cache control circuit is further operable upon receipt of a terminate signal indicating expiration of the lifespan of a class corresponding to said class indicator of any tag memory to store non-cacheable data stored in a data cache memory in said external memory at an address corresponding to said address field of any matching tag memory. </claim-text></claim>"}, {"num": 22, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00022\" num=\"22\"><claim-text>22. The microprocessor of claim <b>19</b> wherein:</claim-text><claim-text>said cache control circuit is further operable to store said write data in said external memory at an address corresponding to said write address. </claim-text></claim>"}, {"num": 23, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00023\" num=\"23\"><claim-text>23. A method of data processing comprising the steps of:</claim-text><claim-text>storing cacheable data and non-cacheable data in a unified address space in an external memory; </claim-text><claim-text>upon initial reading of non-cacheable data from the external memory storing the non-cacheable data, a corresponding address and a corresponding class identifier in a non-cacheable data memory; </claim-text><claim-text>generating a terminate signal for a corresponding class identifier upon expiration of a lifespan of non-cacheable data of the corresponding class; </claim-text><claim-text>indicating stored non-cacheable data is expired upon receipt of the terminate signal for the corresponding class identifier; </claim-text><claim-text>comparing a read address to the address corresponding to the stored non-cacheable data; </claim-text><claim-text>reading data from the non-cacheable data memory upon an address match between the read address and the address corresponding to the stored non-cacheable data if the non-cacheable data has not expired. </claim-text></claim>"}, {"num": 24, "parent": 23, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00024\" num=\"24\"><claim-text>24. The method of data processing of claim <b>23</b>, wherein:</claim-text><claim-text>said step of generating a terminate signal for a corresponding class identifier generates the terminate signal upon occurrence of a corresponding event associated with the external memory. </claim-text></claim>"}, {"num": 25, "parent": 23, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00025\" num=\"25\"><claim-text>25. The method of data processing of claim <b>23</b>, wherein:</claim-text><claim-text>said step of generating a terminate signal for a corresponding class identifier generates the terminate signal upon occurrence of the first of a corresponding event associated with the external memory or expiration of a predetermined interval of time following storing the non-cacheable data in the non-cacheable data memory. </claim-text></claim>"}, {"num": 26, "parent": 23, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00026\" num=\"26\"><claim-text>26. The method of data processing of claim <b>23</b>, further comprising the steps of:</claim-text><claim-text>comparing a write address to the address corresponding to the stored non-cacheable data; </claim-text><claim-text>writing data to the non-cacheable data memory upon an address match between the write address and the address corresponding to the stored non-cacheable data if the non-cacheable data has not expired. </claim-text></claim>"}, {"num": 27, "parent": 26, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00027\" num=\"27\"><claim-text>27. The method of data processing of claim <b>26</b>, further comprising:</claim-text><claim-text>writing data from the non-cacheable data memory to the external memory upon writing data to the non-cacheable data memory. </claim-text></claim>"}, {"num": 28, "parent": 26, "type": "dependent", "paragraph_markup": "<claim id=\"US-6173368-B1-CLM-00028\" num=\"28\"><claim-text>28. The method of data processing of claim <b>26</b>, further comprising:</claim-text><claim-text>indicating the data stored in the non-cacheable data memory is dirty upon writing data to the non-cacheable data memory; and </claim-text><claim-text>writing data from the non-cacheable data memory to the external memory upon the terminate signal if the data stored in the non-cacheable data memory is dirty. </claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54477949\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This application claims priority under 35 U.S.C. 119(e) (1) from U.S. Provisional Patent Application No. 60/048,772 filed Jun. 6, 1997.</p><h4>CROSS-REFERENCES TO RELATED APPLICATIONS</h4><p>The present application is related to co-pending United States Provisional Patent Application Number 60/008,799, filed Dec. 18, 1995, upon which U.S. patent application Ser. No. 08/769,195 filed Dec. 18, 1995 claims priority, now U.S. Pat. No. 6,032,225 issued Feb. 20, 2000, entitled \u201cMicroprocessor System With Burstable, Non-cacheable Memory Access Support\u201d, which is hereby incorporated herein by reference.</p><p>The present application is related to co-pending United States Provisional Patent Application Number 60/029,232, filed Oct. 31, 1996, upon which U.S. patent application Ser. No. 08/962,987 filed Oct. 31, 1997 claims priority, entitled \u201cMicroprocessor Circuits And Systems With Life Spanned Storage Circuit For Storing Non-cacheable Data\u201d, which is hereby incorporated herein by reference.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT</h4><p>Not Applicable.</p><h4>BACKGROUND OF THE INVENTION</h4><p>The present embodiments relate to microprocessors, and are more particularly directed to microprocessor circuits, systems, and methods with a class categorized storage circuit for storing non-cacheable data.</p><p>As is evident in the field, modem high performance data processing systems are conventionally implemented using single-chip microprocessors as the central processing units (CPU), and using semiconductor random-access memory (RAM) as main system memory. The main memory is generally implemented in the form of random access memory (RAM) devices such as dynamic RAM (DRAM), which are of high density and low cost-per-bit; however, the access and cycle times of conventional DRAM memory are relatively slow, and are not able to keep up with the clock rates of modem microprocessors.</p><p>Conventional microprocessor-based data processing systems have addressed the performance limitations of main memory access, while still obtaining the low-cost benefit of high-density DRAM, through the use of cache memories. Cache memories are typically small blocks of high speed static RAM (SRAM), either on-chip with the microprocessor or off-chip (or both), for storing the contents of memory locations that are likely to be accessed in the near future. Typically, cache memory stores the contents of memory locations that are near neighbors to a memory location that was recently accessed; because microprocessors often access memory in a sequential fashion, it is likely that successive memory accesses in successive cycles will access memory addresses that are very close to one another in the memory space. Accordingly, by storing the neighboring memory location contents in a cache, a good portion of the memory accesses may be made by the microprocessor to cache, rather than to main memory. The overall performance of the system is thus improved through the implementation of cache memory. Some modem microprocessors include multiple levels of cache memory, with the capacity of the cache increasing (and its speed decreasing) with each successive level, to optimize performance. Intelligent cache design and implementation can greatly improve system performance by minimizing accesses to main memory.</p><p>Another approach toward improving memory access performance in microprocessor-based systems is the use of special memory access cycles, commonly referred to as \u201cburst\u201d access cycles. Burst memory access cycles are used, in the operation of the memory devices, to provide access to a series of memory locations. Typically, the burst access is performed by way of a memory controller chip placed between the microprocessor and main memory, and which operates in response to the address information and control signals presented by the microprocessor. Burst cycles are highly effective in improving the performance of memory accesses. For example, in a modern system having an eight-byte bus, a burst cycle can access thirty-two bytes of memory with the presentation of a single memory address in as few as five bus cycles (2-1-1-1), when using a best case cache. Burst access is also highly efficient using page mode DRAM, in which a thirty-two byte access may be performed in a bus cycle sequence of 8-3-3-3 (totaling seventeen bus cycles), and using special DRAM functions such as Early Data Out (EDO) and synchronous DRAM, in which thirty-two byte burst accesses may be accomplished, in the best case, with a bus cycle sequence of 6-1-1-1 (totaling nine bus cycles). This is a drastic improvement over the non-burst case in which access of a 32-byte line requires 64 cycles when accessed as a group of eight separate 4 byte reads (considering that non-burst accesses are generally not longer than 4 bytes). As such, burst mode memory access is typically twice to six times as fast as non-burst cycles.</p><p>In microprocessors utilizing the well-known \u201cx86\u201d architecture, including the so-called \u201cPentium-class\u201d microprocessors (referring to microprocessors having functionality and instruction set compatibility with PENTIUM microprocessors available from Intel Corporation), burst memory access are linked to cache operations. In other words, in these x86-architecture microprocessors, burst memory operations are performed only in connection with cache line fill operations (reads from memory) and cache write-back operations (writes to memory). Given the cache architecture of these microprocessors, where most data and instruction retrieval is accomplished by way of cache memory, the performance provided by performing burst memory accesses for cache operations is quite high.</p><p>Caching typically works quite well for \u201ctrue\u201d memory locations, to and from which only the microprocessor writes and reads data using conventional memory access operations, because the microprocessor can ensure that its cache copy of the memory location matches the copy in main memory. So long as the cache and main memory copies of the same memory locations are the same, reading of the cache copy instead of the main memory copy will have no side effects. However, certain memory locations, such as those containing the status of an I/O device or those portions of the screen buffer that may be changed by a graphics accelerator, are volatile to the extent that cache copies of these memory locations would be frequently out-of-date. The reading of a cache copy of these volatile memory locations, in lieu of the main memory locations, could have significant side effects in system operation. Accordingly, accesses by the microprocessor to these volatile locations are blocked from being \u201ccacheable\u201d (i.e., from being stored in cache memory) in conventional IBM PC architecture systems, typically by the operation of a memory controller.</p><p>For example, the memory mapped register is generally a blocked area in the cacheable access sense, despite being accessed via conventional memory access, because the memory mapped register is often polled to detect changes in device status, responsive to which certain control functions are effected. If the memory-mapped register were cached, changes in device status would be reflected in the main memory copy of the memory-mapped register but not in the cached copy; periodic polling of the memory-mapped register would read the cache copy only, and would therefore not detect the sought-for change in device status, effectively bringing control to a standstill. By way of another example, the caching of non-memory devices such as memory-mapped I/O functions may cause additional side effects for those types of I/O devices which change state in response to a read operation on the bus, since reads of on-chip cache memory do not appear as bus cycles. Write-back caching also presents side effects for these non-memory locations, as the cache could contain a more up-to-date copy than main memory; since writes to write-back cache do not appear on the bus, the caching of these locations would appear to reorder writes performed on the bus.</p><p>Another example of a memory area that is volatile and therefore typically blocked from cacheable access is video memory, which is logically within the memory map of the microprocessor and physically located either within or separate from main memory (such as in a graphics adapter). Video memory is often under the control of a device other than the microprocessor, such as a graphics processor or graphics adapter, and is therefore not suitable for cacheable access by the main microprocessor as its contents are frequently changed outside of the control of the microprocessor. If a portion of video memory were to be stored in the microprocessor cache, the cache contents would likely be invalid for subsequent accesses because of the changes made by the graphics processor.</p><p>According to conventional x86 architecture microprocessors, therefore, burstable memory accesses are linked to the cacheability of the memory location to be accessed. For example, the PENTIUM microprocessor requests a burstable memory access by asserting a control signal at terminal CACHE# (the # indicating that the signal is active at a low logic level) during an access to memory (indicated by the microprocessor presenting a high logic level at terminal M/IO#). Responsive to this request, the memory controller determines if the memory address presented by the microprocessor is in a cacheable area of the memory space and, if so, asserts the KEN# input to the microprocessor and effects the burst access. According to this conventional implementation, if the microprocessor requests a burstable access to an area of memory that is blocked from cacheable access, the memory controller will not effect a burstable access, and will indicate the same by deasserting KEN#. Single transfer access to the desired memory location will then proceed.</p><p>By way of further background, still another consideration in the complexity in cache architectures is the existence and sometimes requirement of snoop capability. Snooping is known in the art, and generally includes two different types of snoop requests, each of which is associated with one or more memory locations identified by an explicit address that accompanies or corresponds to the snoop request. For example, a snoop request may be issued including an address, where the entire cache line which includes the addressed information is to be operated upon in response to the snoop request. In any event, as to the two types of snoop requests, generally a first type of such a request indicates to a cache (or caches) that the requesting circuit seeks to share the addressed information. If a cache does not have a copy of the addressed information, then it simply takes no action with respect to the request. On the other hand, if the cache does have a copy of the addressed information and that information has been modified since the time it was stored in the cache, then the cache outputs the addressed information to main memory. Therefore, the requesting circuit may then read the addressed information from main memory (or \u201csnarf\u201d it from the bus as it is being written from the cache to the main memory). The second type of snoop request indicates to a cache (or caches) that the requesting circuit seeks the addressed information and will change that information. Once again, if a cache does not have a copy of the addressed information, then it simply takes no action with respect to the request. On the other hand, if the cache does have a copy of the addressed information and that information has been modified since the time it was stored in the cache, then the cache also outputs the addressed information to main memory. However, note that because the requesting circuit will change the information, the outputting cache also must invalidate its own copy of the information to prevent subsequent use of information that has been changed.</p><p>Given the existence of snooping as introduced above, note also that it may further limit the types of information that are considered cacheable under current architectures. For example, assume there is a device which is external from a microprocessor and operates to alter data of the main memory used by the microprocessor. Assume further that this external device does not provide snooping capability. Therefore, the types of data associated with this external device are typically deemed non-cacheable because to allow otherwise would provide the danger that the type of data altered by this external device would exist in a cache on the microprocessor and would not be properly output by the cache to the main memory because of the lack of snooping capability of the device. Thus, snooping provides yet another complexity in the consideration of cache techniques and limitations.</p><p>In view of the above, the present inventors have recognized various limitations of the above factors regarding cacheability. Thus, below are presented various inventive embodiments which improve performance as measured against these prior art drawbacks.</p><h4>BRIEF SUMMARY OF THE INVENTION</h4><p>In the preferred embodiment, there is a microprocessor for coupling to an external read/write memory having an addressable storage space for storing data. The microprocessor includes a data storage circuit for storing a portion of the data, where that portion of data comprises non-cacheable data. The microprocessor further includes a class storage circuit for storing a class identifier corresponding to the portion of the non-cacheable data, as well as an input for receiving a terminate signal and an input for receiving a class signal. Lastly, the microprocessor includes an indicator for indicating that the portion of the non-cacheable data in the data storage circuit is expired in response to assertions of the terminate signal and the class signal matching the class identifier. Other circuits, systems, and methods are also disclosed and claimed.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWING</h4><p>FIG. 1 is an electrical diagram, in block form, of a data processing system according to one inventive embodiment;</p><p>FIG. 2 is an electrical diagram of a first embodiment, in block form, of the memory and input/output controller of the system of FIG. 1;</p><p>FIG. 3 is a schematic diagram of the memory address space and input/output address space of the data processing system of FIG. 1, schematically illustrating the conditions under which each address space is accessed;</p><p>FIG. <b>4</b><i>a </i>is a timing diagram illustrating the request and performance of a burst read from non-cacheable memory according to the first embodiment;</p><p>FIG. <b>4</b><i>b </i>is a tiding diagram illustrating the request and performance of a burst write from non-cacheable memory according to the first embodiment;</p><p>FIG. 5 is an electrical diagram of a second embodiment, in block form, of the memory and input/output controller of the system of FIG. 1;</p><p>FIG. 6 is an electrical diagram of a third embodiment, in block form, of a microprocessor coupled to a screen display via a graphics adapter;</p><p>FIG. 7 is a schematic of a microprocessor embodiment for storing non-cacheable data and a class identifier corresponding to that data, where the non-cacheable data may be read and written by the microprocessor and modified during a life span as determined by assertion of a terminate signal and a corresponding class signal;</p><p>FIG. 8 is a flow chart of a method embodiment of operation of the schematic of FIG. 7;</p><p>FIG. 9 is a schematic of a microprocessor embodiment for storing a plurality of lines of non-cacheable data where each line has a class identifier corresponding to the data of that line, and where each line may be read and written by the microprocessor and modified during a life span as determined by assertion of a terminate signal and a corresponding class signal; and</p><p>FIG. 10 is a schematic of a microprocessor embodiment for storing a plurality of lines of data and corresponding class identifiers, where some of the lines are governed by known cache policies while others may be read and written by the microprocessor and modified during a life span as determined by assertion of a terminate signal.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>Referring first to FIG. 1, an exemplary microprocessor-based system <b>2</b> into which a first preferred embodiment is implemented is now described in detail. As shown in FIG. 1, system <b>2</b> includes central processing unit (CPU) <b>5</b> which, in this embodiment of the invention, is a microprocessor of the well-known \u201cx86-architecture\u201d, and is preferably a Pentium-class microprocessor. CPU <b>5</b> includes a bus interface unit (BIU) <b>8</b>. BIU <b>8</b> is circuitry within CPU <b>5</b> which serves to control and accomplish communication between CPU <b>5</b> and the remainder of system <b>2</b>. In his embodiment, BIU <b>8</b> of CPU <b>5</b> is connected to a bus consisting of address bus ABUS, data bus DBUS, and control bus CBUS. As is conventional in the art, address bus ABUS is a bus upon which CPU <b>5</b> presents a binary address to access other elements of system <b>2</b>, data bus DBUS is a bus for the communication of digital data between CPU <b>5</b> and the other system elements, and control bus CBUS is a bus by way of which control signals are communicated among the elements of system <b>2</b>.</p><p>In system <b>2</b> of FIG. 1, various peripheral elements are connected to buses ABUS, DBUS, CBUS, by way of associated controllers, to perform usual system functions. Main memory <b>20</b> of system <b>2</b> is coupled to buses ABUS, DBUS, CBUS by memory controller <b>10</b>; as such, memory controller <b>10</b> receives address values and control signals from CPU <b>5</b>, and presents corresponding control signals to main memory <b>20</b> to accomplish the desired operation, which generally involves the communication of data to or from CPU <b>5</b> on data bus DBUS. System <b>2</b> also includes level <b>3</b> cache memory <b>22</b>, which is connected to cache controller <b>12</b> in the conventional manner; cache controller <b>12</b> is connected to buses ABUS, DBUS, CBUS, to control the communication of data between CPU <b>5</b> and level <b>3</b> cache memory <b>22</b>. In this example, level <b>3</b> cache memory <b>22</b> is a third level cache memory for system <b>2</b>, with level <b>1</b> and level <b>2</b> cache memory present within CPU <b>5</b> (level <b>2</b> cache <b>6</b> being shown in FIG. <b>1</b>). System <b>2</b> also includes I/O controller <b>14</b> which is connected to CPU <b>5</b> via buses ABUS, DBUS, CBUS, and which is also connected to several input/output devices <b>24</b>. Input/output devices <b>24</b> may include typical input and output peripherals in system <b>2</b>, such as a video monitor, a keyboard, a pointing device, disk drive subsystems, and the like. Controllers <b>10</b>,<b>12</b>,<b>14</b> are typically implemented by way of a so-called \u201cchip set\u201d that is designed to operate in conjunction with CPU <b>5</b>. System <b>2</b> further includes clock generator circuit <b>16</b>, which generates a periodic clock signal on line CLK for presentation to each of the elements of system <b>2</b>, including CPU <b>5</b> via BIU <b>8</b>, and from which internal clock signals may be generated within each of the various system elements. Accordingly, it is contemplated that system <b>2</b> corresponds to a typical modem computer, such as of the desktop, workstation or portable type, in which computer programs are stored within disk storage (represented by one of input/output devices <b>24</b>) and downloaded to main memory <b>20</b> for operation.</p><p>Memory accesses are accomplished by the presentation of an address value on bus ABUS by CPU <b>5</b> in combination with the appropriate control signals on control bus CBUS (including a read/write selection signal); memory controller <b>10</b>, in turn, presents the appropriate control signals to main memory <b>20</b> to access the desired location. In this example, a portion <b>20</b><i>v </i>of main memory <b>20</b> is video memory, which may be independently accessed by the one of I/O functions <b>24</b> that is the graphics adapter (or controller), either by way of buses ABUS, DBUS, CBUS or by way of a second bus (not shown); alternatively, video memory <b>20</b><i>v </i>could be implemented as its own device on the bus, as in the case of a PCI video card. Under the control of memory controller <b>10</b>, which is generally accomplished by way of a handshaking protocol between it and CPU <b>5</b> via control bus CBUS, CPU <b>5</b> either presents data on data bus DBUS (in a memory write) or receives data from data bus DBUS (in a memory read).</p><p>As illustrated in FIG. 1, both memory and input/output traffic occurs by way of the same buses, namely address bus ABUS, data bus DBUS, and control bus CBUS. Accordingly, in this embodiment as is typical for x86-architecture microprocessor-based systems, input/output accesses are performed in a similar fashion as memory accesses described above, with CPU <b>5</b> presenting an address on address bus ABUS in combination with the appropriate control signals on line CBUS. For an I/O operation, the address on address bus ABUS corresponds to a particular one of input/output functions <b>24</b>. Under the control of I/O controller <b>14</b>, data is then communicated from CPU <b>5</b> to the selected I/O function <b>24</b> via data bus DBUS (for an output operation) or from the selected I/O function <b>24</b> to CPU <b>4</b> via data bus DBUS (for an input operation).</p><p>Referring now to FIG. 2, the construction and operation of memory controller <b>10</b> according to the first embodiment, and in conjunction with CPU <b>5</b> and main memory <b>20</b>, is now described in detail. As shown in FIG. 2, BIU <b>8</b> of CPU <b>5</b> communicates with memory controller <b>10</b> by way of address bus ABUS, data bus DBUS, and control bus CBUS, which are connected to specified terminals of CPU <b>5</b>. The terminals of CPU <b>5</b> are its external connectors, which may be in the form of pins (as in pin-grid-array packages), solder balls, package leads, bond pads (when in chip form), or any other conventional type of external connection for integrated circuit packages. As known in the art, the terminals of CPU <b>5</b> are conventionally referred to by pin or signal names; for purposes of this description, bus lines connected to terminals of CPU <b>5</b> have the same name as their corresponding terminal. As shown in FIG. 2, control bus CBUS includes lines corresponding to terminals of CPU <b>5</b> including, in this example conventional Pentium-class microprocessor terminals such as memory/IO select M/IO#, cache request CACHE#, burst ready BRDY# and cache enable KEN#. Other conventional Pentium-class terminals used in performing memory accesses (but not shown in FIG. <b>2</b>), include byte enable signals BE<b>7</b>#-BE<b>0</b>, address status signal ADS#, data/control select D/C#, write/read select W/R#, write-back/write-through signal WB/WT#, and the like. Clock generator <b>16</b> provides a clock signal on line CLK to CPU <b>5</b> (via BIU <b>8</b>) and to memory controller <b>10</b>.</p><p>Memory controller <b>10</b> includes several functional blocks for providing communication between CPU <b>5</b> and main memory <b>20</b>. These blocks are shown functionally in FIG. 2, as it is contemplated that one of ordinary skill in the art will fully understand the construction and operation of memory controller <b>10</b> from a functional description. As is conventional in the art, address buffer <b>21</b> receives the memory address from CPU <b>5</b> on address bus ABUS, and forwards that memory address to address multiplexer <b>26</b> for presentation to main memory <b>20</b> on address lines AN through A<b>0</b>. Data buffer <b>23</b> in memory controller <b>10</b> similarly receives data from CPU <b>5</b> on data bus DBUS, and forwards that data, in write operations, to write buffer <b>27</b> which is in communication with main memory <b>20</b> via data lines D<sub>in</sub>; this path is bidirectional, however, and as such write buffer <b>27</b> may receive data from main memory <b>20</b> on lines D<sub>out</sub>, and forward this data to data buffer <b>23</b> for presentation to CPU <b>5</b> in memory read operations.</p><p>Control of communication between CPU <b>5</b> and main memory <b>20</b> is accomplished by bus control circuit <b>25</b>, connected to control bus CBUS and memory control circuit <b>29</b>; in addition, memory controller <b>10</b> also includes control logic <b>28</b>, which controls the internal operation of memory controller <b>10</b>. In particular, bus control circuit <b>25</b> receives control signals from CPU <b>5</b> on control bus CBUS, including signals M/IO# and CACHE# and, in response to a request for memory access, instructs memory control circuit <b>29</b> to issue the appropriate conventional DRAM control and timing signals to main memory <b>20</b> to accomplish the memory access, such signals including row address strobe (RAS#), column address strobe (CAS#), write enable (WE#). In addition, bus control circuit <b>25</b> issues control signals to CPU <b>5</b> indicating the status of the memory access, such control signals include cache enable signal KEN#, as well as burst ready signal BRDY#, which is of particular importance for burst accesses as is described below.</p><p>Control logic <b>28</b> of memory controller <b>10</b> also preferably includes programmable registers for controlling the operation of memory controller <b>10</b>, including registers that define non-cacheable locations of main memory <b>20</b>. In response to each memory access requested by CPU <b>5</b>, control logic <b>28</b> examines these registers to determine whether the desired memory address, as presented on address bus ABUS, is in a non-cacheable area of the memory address space. As is known in the art, memory controller <b>10</b> asserts line KEN# to indicate to CPU <b>5</b> that the desired memory access is cacheable, and deasserts line KEN# if the desired memory address is in a non-cacheable area.</p><p>According to the prior art, as described above relative to the Background of the Invention, burstable memory accesses were available only for memory addresses that were not in a non-cacheable area. In prior art microprocessor implementations therefore, line KEN# would be deasserted responsive to a request for memory access made to a non-cacheable area; in addition, terminal BRDY# of the microprocessor would be asserted only for the duration of a single transfer operation (read or write) made to a non-cacheable area of memory, rather than for multiple bus cycles as would be the case for a burst access.</p><p>FIG. 3 schematically illustrates the respective address spaces in system <b>2</b> according to this embodiment In exemplary system <b>2</b>, as is conventional for Pentium-class microprocessors, a 4 Gbyte memory address space <b>30</b> (memory addresses from 0000 0000 h to FFFF FFFFh) and a 64 k byte I/O address space <b>40</b> (memory addresses from 0000 0000 h to 0000 FFFFh) are provided. Also as is typical for Pentium-class microprocessors, including CPU <b>5</b>, memory address space <b>30</b> and I/O address space <b>40</b> share some of the same address values (i.e., address values between 0000 0000 h and 0000 FFFFh correspond to locations both in memory address space <b>30</b> and in I/O address space <b>40</b>). As described above, conventional x86-architecture microprocessors present a control signal on a terminal referred to as M/IO#, which at a high logic level indicates that a memory access was to occur, and with a low logic level indicates that an I/O operation was to occur.</p><p>As shown in FIG. 3, memory address space <b>30</b> includes a non-cacheable area <b>32</b>. Non-cacheable area <b>32</b> corresponds to a region of memory address space <b>30</b> that is blocked from being accessed by way of a cache write or a cache read, as described hereinabove. Cacheable access to non-cacheable areas is prevented by memory controller <b>10</b>, particularly by its control logic <b>28</b>, according to the contents of certain registers containing the addresses for which cacheable access is to be prevented. Non-cacheable area <b>32</b> may include video memory <b>20</b><i>v </i>(see FIG. <b>1</b>), or memory-mapped control registers, neither of which are typically considered suitable for cache storage. As such, the contents of non-cacheable area <b>32</b> are prevented from being stored in internal caches within CPU <b>5</b>, such as level <b>2</b> cache <b>6</b> shown in FIG. 1, through the operation of memory controller <b>10</b> and its issuance of a deasserted state on line KEN#.</p><p>However, it has been discovered by the present inventors that it may be useful to provide burst access capability to non-cacheable areas of main memory <b>20</b> in x86-architecture microprocessors. For example, CPU <b>5</b> may wish to rapidly access (i.e., in a burst mode) the contents of a portion of video memory <b>20</b><i>v</i>, in non-cacheable area <b>32</b>. For example, CPU <b>5</b> may wish to copy the screen image into memory, or copy another portion of memory into video memory. Since video memory <b>20</b><i>v </i>is non-cacheable, prior art x86-architecture systems would prevent burstable access to non-cacheable area <b>32</b>.</p><p>According to a first preferred embodiment, however, CPU <b>5</b> is able to request burstable but non-cacheable access to main memory <b>20</b>, through the use of existing control signals in control bus CBUS. As indicated hereinabove, the control output signal M/IO# is used by conventional x86-architecture microprocessors to indicate whether a memory access (M/IO# high) or an I/O operation (M/IO# low) is to be performed. In contrast, according to this embodiment, the combination of a low logic level on line M/IO# in combination with assertion of the CACHE# signal (with a low logic level) is used by CPU <b>5</b> to request a burstable memory access to a non-cacheable area of memory address space <b>30</b>. Memory controller <b>10</b>, and specifically its bus control circuit <b>25</b>, interprets this combination of M/I<b>0</b># low and CACHE# low as a request for a burst memory access (rather than as an I/O request, as would be the interpretation according to the prior art), and performs a non-cacheable burst memory access to main memory <b>20</b> even if control logic <b>28</b> indicates that the memory address is within the non-cacheable area <b>32</b> of memory address space <b>30</b>. If CPU <b>5</b> presents an address, in combination with M/I<b>0</b># and CACHE# low, that is within the cacheable area of memory address space <b>30</b>, a burst access is requested and performed; however, CPU <b>5</b> does not attempt to cache the access, even though cache access is available for the addressed memory location in this case.</p><p>Memory and I/O operations according to this embodiment may thus be requested by CPU <b>5</b>, via control signals M/IO# and CACHE#, according to the following Table 1 and the corresponding logic in FIG. <b>3</b>:</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"98PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"70PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\">TABLE 1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Operation type</entry><entry morerows=\"0\" valign=\"top\">M/IO#</entry><entry morerows=\"0\" valign=\"top\">CACHE#</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Burstable, cacheable</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">memory access</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">I/O operation (IN or OUT)</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Nonburstable,</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">noncacheable memory</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">access</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Burstable, non-cacheable</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">memory access</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>This operation is schematically illustrated in FIG. 3 by the portion of bus control circuit <b>25</b> used to drive control signals MEN<b>1</b> for single memory transfer cycle (i.e., non-burstable, non-cacheable), MENBC for burstable, cacheable memory access, IOEN for I/O operation, and MENBNC for burstable, non-cacheable memory access. AND gate <b>31</b> drives line MEN<b>1</b> high only in response to both of lines M/IO# and CACHE# high, AND gate <b>33</b> drives line IOEN high only in response to line M/IO# low with line CACHE# high, AND gate <b>35</b> drives line MENBC high only in response to line M/IO# high and line CACHE# low, and AND gate <b>37</b> drives line MENBNC high only in response to both of lines M/IO# and CACHE# low.</p><p>Of course, according to this embodiment, I/O controller <b>14</b> is configured to not respond to a low logic level on line M/IO# in combination with line CACHE# low, so as to prevent bus conflict due to a burstable non-cacheable memory access occurring simultaneously with an unintended I/O operation.</p><p>Referring now to FIG. <b>4</b><i>a</i>, a timing diagram illustrating the operation of a burstable, non-cacheable memory read, as requested by CPU <b>5</b> and performed by main memory <b>20</b> and memory controller <b>10</b> according to this first preferred embodiment is now described, for purposes of further explanation. In this example, the read memory access is requested by CPU <b>5</b> issuing a memory address on address bus lines A<b>31</b>-A<b>3</b> in combination with a 0 value on byte enable lines BE<b>7</b>#-BE<b>0</b>#; this address is indicated by CPU <b>5</b> as valid upon its assertion of a low logic level on line ADS#. In this example of a burstable non-cacheable memory read, the address presented by CPU <b>5</b> is within a non-cacheable area <b>32</b> of memory address space <b>30</b>. In combination with the memory address, CPU <b>5</b> also issues a high logic level on line D/C# to indicate that this operation is a data operation, and asserts line W/R# low to request a memory read. These signals are conventional for x86-architecture microprocessor read operations. According to this first embodiment of the invention, CPU <b>5</b> also presents a low logic level on line M/IO# in combination with a low logic level on line CACHE#. These signals are all present in bus cycle B<b>0</b> of FIG. <b>4</b><i>a. </i></p><p>This combination of signals indicates to memory controller <b>10</b> that a burstable access to a non-cacheable area of main memory <b>20</b> is being requested. Memory controller <b>10</b> responds to this request by issuing the appropriate control signals and addresses to the addressed memory devices in main memory <b>20</b>. In bus cycle B<b>2</b> (bus cycle B<b>1</b> being a wait state), memory controller <b>10</b> indicates to CPU <b>5</b> that a burstable access to main memory <b>20</b> has been granted by asserting line KEN# low, and that data bus DBUS will have valid memory data placed upon it at the end of the current clock cycle by asserting line BRDY# low. Line WB/WT# is a don't care in this operation, since the memory read is non-cacheable. Valid data, in the form of quad words QW<b>0</b> through QW<b>3</b> (each being 64 bits, or eight bytes), then appear upon data bus DBUS at the end of the current bus cycle B<b>2</b> and the next three successive bus cycles B<b>3</b> through B<b>5</b> (assuming no wait states). The burst memory read according to this embodiment is then indicated as complete, by memory controller driving line BRDY# to a high state, in bus cycle B<b>6</b>. Subsequent memory accesses, of the burstable, non-cacheable type, or of another type, may then be performed in the conventional manner.</p><p>Referring now to FIG. <b>4</b><i>b</i>, the operation of a burstable, non-cacheable memory write operation is now described in detail. Similarly as in the case of the memory read of FIG. <b>4</b><i>a</i>, CPU <b>5</b> initiates the operation with the presentation of the desired address on address lines A<b>31</b> through A<b>3</b>, and the zero value for byte enable bits BE#, together with a high level on line D/C# at the time that CPU <b>5</b> asserts the ADS# signal low in bus cycle WB<b>0</b>. Also in this cycle WB<b>0</b>, CPU <b>5</b> indicates that it wishes to perform a memory write by asserting line W/R# high, and requests a burst write to a non-cacheable memory location by asserting line M/IO# low in combination with line CACHE# low. Again, as in the case of the read, if the address points to a cacheable area of memory address space <b>30</b>, a burst access is performed but the write is performed via cache. In response to this request by CPU <b>5</b>, memory controller <b>10</b> issues (in bus cycle WB<b>2</b>, after a single wait state) a low logic level on line KEN# to indicate that burst access to main memory <b>20</b> has been granted, in combination with a low logic level on line BRDY# indicating that valid data is expected at the end of the current bus cycle WB<b>2</b>. CPU <b>5</b> then performs the write by placing valid data onto data bus DBUS at the end of bus cycle WB<b>2</b> and the subsequent three bus cycles WB<b>3</b> through WB<b>5</b>. The burst write operation is then indicated as complete by memory controller <b>10</b> driving line BRDY# in the final bus cycle WB<b>6</b>.</p><p>According to this embodiment, therefore, burstable access is provided to non-cacheable areas of main memory in an x86-architecture microprocessor-based computer system. The benefits of accomplishing memory operations at burst rates are thus obtained for a wider range of memory operations, particularly in accessing memory locations that are not suitable for cacheability such as video RAM locations. In addition, such access is provided according to this embodiment without requiring an additional pin on the microprocessor.</p><p>If an additional microprocessor pin and corresponding mother board conductor are available, the various inventive aspects may be implemented according to a second embodiment, as is now described relative to FIG. <b>5</b>. In FIG. 5, like reference numerals are used to refer to like elements as shown in FIG. <b>2</b>.</p><p>FIG. 5 illustrates CPU <b>50</b>, which is also a Pentium-class microprocessor as described above relative to FIG. 2, but which in this case is configured so that certain types of memory accesses imply a request for burstable access. These requests are communicated (either expressly or implicitly) to bus control logic <b>55</b> in memory controller <b>60</b>, for interpretation as burst memory access requests.</p><p>For example, the execution of a block memory access operation by CPU <b>50</b>, such as a REP MOV instruction, may set a control flag in BIU <b>8</b> that is communicated to bus control logic <b>55</b>. In this event, once the control flag is set, bus control logic <b>55</b> may then interpret all subsequent memory access requests (line M/IO# high) as requests for burst access, for accesses both to cacheable and also non-cacheable areas of the memory address space. Alternatively, specific instructions may be executable by CPU <b>50</b> that explicitly refer to burst memory accesses both to cacheable and non-cacheable areas of memory; a flag or control signal would again be set by CPU <b>50</b> to indicate to memory controller <b>60</b> that a burst access is requested.</p><p>According to this second embodiment, because burst memory accesses may be requested by CPU <b>50</b> both to cacheable and non-cacheable areas of memory, separate indications of cacheability and burstability are preferably given by memory controller <b>60</b> to CPU <b>50</b>. This is because CPU <b>50</b> may issue a implied burst access request while not knowing whether the memory address is in a cacheable area of the memory address space; even if the memory access is non-cacheable, burstable access will still be desirable. According to this embodiment, therefore, burst enable signal BEN# is provided, which is a signal and corresponding CPU terminal provided in this embodiment, in addition to the conventional Pentium-class control signals and pins. As shown in FIG. 5, according to this embodiment of the invention, bus control logic <b>55</b> issues a signal on line KEN# to indicate cacheability of the memory access (similarly as described hereinabove relative to the first embodiment of the invention), and also issues a signal on line BEN# to indicate whether or not burst access was granted. In the event that CPU <b>50</b> requested burst access to a non-cacheable memory location, line KEN# is maintained high by bus control logic <b>55</b> (indicating non-cacheable access) and line BEN# is driven low by bus control logic <b>55</b>, indicating the grant of burstable access and thus instructing CPU <b>50</b> to either present or expect four quad-words of data on data bus DBUS.</p><p>Having described various aspects of the present embodiments directed to non-cacheable data, the present inventors below provide still additional aspects directed to handling data traditionally treated as non-acheable (i.e., not permitted to be duplicated in one or more secondary stores such as cache storage), where the additional embodiments treat such data according to a classification structure such that the data nevertheless may be temporarily copied in a memory or other storage device (i.e., in a cache-like manner) despite the otherwise traditional restrictions which cause the data to be considered non-cacheable. In other words, under the following embodiments, a multiple copy is permitted of certain types, or \u201cclasses\u201d, of non-cacheable data, yet proper techniques are implemented to ensure that the additional potential copy does not interfere with proper memory coherency. To provide an example of such treatment, FIG. 6 illustrates still another embodiment of an inventive CPU configuration, which is provided by way of example to also introduce classes of data as that term is used for the remainder of this document.</p><p>Turning then to FIG. 6, once again it illustrates a CPU, here designated at <b>62</b> and which also includes a BIU <b>8</b> as described in connection with either CPU <b>5</b> or CPU <b>50</b> above. Thus, BIU <b>8</b> generally includes there buses to communicate externally from CPU <b>62</b>, those being the ABUS, DBUS, and CBUS for addresses, data, and control, respectively. Note that each of these buses may operate in the manner described above, but for purposes of detailing the following embodiments only additional aspects of the CBUS need be discussed here. In this regard, note that CPU <b>62</b> includes two new signals as part of its CBUS signals where those signals relate to the treatment of non-cacheable data, and where those signals may be in addition to or in lieu of some of the CBUS signals discussed above. In any event, turning then to these signals they are designated as CLASS and TERMINATE. Each of these signals is discussed below.</p><p>The CLASS and TERMINATE signals are used in combination to permit what may otherwise may be considered non-cacheable data in the traditional sense to be stored in a cache-like manner for a limited period of time. More particularly, under the following embodiments, data of a desired type, as shown by way of examples below, may be assigned to a class, and this assignment is encoded in the CLASS signal on the CBUS. For example, the types of classes may pertain to video data, as may be appreciated by continuing with FIG. <b>6</b>. Thus, CPU <b>62</b> is connected to a graphics adapter <b>64</b>, and graphics adapter <b>64</b> is connected to output a drive signal to a screen display <b>66</b>. With the exception of the capabilities of the CLASS and TERMINATE signals as described below, graphics adapter <b>64</b> may be one of many various configurations known to. one skilled in the art. Similarly, screen display <b>66</b> by itself also may be of various types, such as those including CRT devices or flat screen (e.g., LCD) devices as well.</p><p>Turning to the known aspects of graphics adapter <b>64</b>, it includes a video controller <b>68</b> which may be various types of control or microprocessor devices used to implement video capability, and it further includes a memory <b>70</b> or some other type of data storage device which is mapped to the main memory space of CPU <b>62</b> for storing video data. Without the present embodiments, note that the data stored in MEMORY <b>70</b> is typically designated as non-cacheable because it may be subject to change independent of CPU <b>62</b>, that is, it may be changed by video controller <b>68</b>. As a secondary consideration, note also that video controller <b>68</b> does not support typical snooping as would be required if known caching techniques were permitted with respect to data stored in MEMORY <b>70</b>. Graphics adapter <b>64</b> is also shown to include two additional blocks, those including character and attribute circuitry <b>72</b> and a signal generator <b>74</b>. Note that these blocks may include additional distinct circuits so as to support the various functions typically implemented to accommodate either text and/or graphics data, and to sufficiently process data so that it may be serialized to signal generator <b>74</b> and presented as a meaningful drive signal such that the desired data is output by screen display <b>66</b>.</p><p>Looking now to the CLASS and TERMINATE signals, note that they distinguish graphics adapter <b>64</b> (and CPU <b>62</b>) from the known art and provide additional functionality which, in this or other contexts, permits otherwise non-cacheable data to be temporarily copied into a storage circuit other than MEMORY <b>70</b>. For the video data example of FIG. 6, assume for reasons more clear below that each group of data in MEMORY <b>70</b> corresponding to each different scanline is assigned to a different class. More specifically, scanlines are known in the art as corresponding to the number of horizontal traces across screen display <b>66</b>. Therefore, for each such scanline, there is a corresponding group of data required to provide that scanline (i.e, a single horizontal trace) across screen display <b>66</b>. For example, assume screen display <b>66</b> provides a total resolution of 1024 by 768 pixels, thereby indicating that a complete update of screen display <b>66</b> involves 768 horizontal traces. By definition, therefore, this indicates a total of 768 different scanlines of data in MEMORY <b>70</b>. Given this data, for the current example of the present embodiment assume that each of these scanlines is attributed a CLASS number from 1 to 768.</p><p>Given the classification system described immediately above, a single scanline of data in MEMORY <b>70</b> may be identified according to its CLASS for use in conjunction with the TERMINATE signal to permit temporary duplication of that scanline data in a cache or cache-like structure. This operation is detailed below. For introductory purposes, however, an example of this functionality is now instructive. As stated above, in the prior art, the data in MEMORY <b>70</b> is non-cacheable and, therefore, the only copy of that data is located in MEMORY <b>70</b>. However, the following embodiments define a \u201clifespan\u201d for each CLASS of data, and during the live period of that lifespan the data in a given CLASS may be copied in a cache-like manner into a storage device other than MEMORY <b>70</b>. The TERMINATE signal, when asserted, ends the lifespan for a stated data CLASS and therefore commands the additional storage device to respond in a manner detailed later. In other words, before the TERMINATE signal is asserted, the copy of this data may be used and/or changed by circuits having access to the other storage device. Therefore, in effect, the non-cacheable data is temporarily available to be used in a cache-like manner. These operations and benefits are better understood after the description of FIG. 7 following immediately below.</p><p>FIG. 7 illustrates a detailed schematic of CPU <b>62</b> of FIG. 6 and, therefore, is directed to a configuration where CPU <b>62</b> may temporarily store and modify non-cacheable data for a certain time period. Turning then to FIG. 7, it illustrates BIU <b>8</b> discussed above and, again, which is coupled to the three buses DBUS, ABUS, and CBUS, as well as receiving the CLK signal from clock generator circuit <b>16</b>. Moreover, note in FIG. 7 that the CBUS includes the CLASS and TERMINATE signals introduced in FIG. 6, above. Additionally, below BIU <b>8</b> are numerous additional circuits which have not yet been discussed (other than L<b>2</b> cache <b>6</b>). Regarding these additional circuits, note first for purposes of simplicity that each of the DBUS, ABUS, and CBUS is shown connected, through BIU <b>8</b>, to a common bus B. Thus, within microprocessor <b>5</b> it is intended that bus B may carry any of data, address, or control information. Bus B is connected to provide a DATA transaction unit to, or receive a DATA transaction unit from, a first register <b>76</b>. In the present embodiment, the bus B transaction width for DATA is 8 bytes . Further, for purposes discussed below, in the preferred embodiment register <b>76</b> is sized to store up to one burst line of data; therefore, if the bus burst size is 32 bytes, then register <b>76</b> may store up to 32 data bytes. Note further, however, that in alternative embodiments register <b>76</b> may be larger or smaller than a single burst size of data. Bus B is further connected to provide an ADDRESS to, or receive an ADDRESS from, a second register <b>78</b>, where that address corresponds to the DATA being read into, or written from, register <b>76</b>. Lastly, bus B is connected to provide a CLASS identifier, if applicable, from the CBUS to a third register <b>80</b> which also corresponds to the DATA being read into, or written from, register <b>76</b>.</p><p>Also associated with registers <b>76</b>, <b>78</b>, and <b>80</b> are preferably three indicators <b>82</b>, <b>84</b>, and <b>86</b>. Indicator <b>82</b> indicates whether the DATA in register <b>76</b> is live or expired as those terms are understood below; therefore, indicator <b>82</b> is hereafter referred to as L/E indicator <b>82</b>. Indicator <b>84</b> indicates whether the DATA in register <b>76</b> is clean or dirty and, therefore, hereafter is referred to as C/D indicator <b>84</b>. The terms clean and dirty are used here in the same manner as in the cache art, thereby indicating whether DATA has been modified after being received in register <b>76</b>. Moreover, recall from above that data register <b>76</b> is preferably sized to store 32 bytes of information. In alternative embodiments, therefore, C/D indictor <b>84</b> may be a single indicator for the entire set of DATA stored in register <b>76</b> or alternatively, may includes separate indications for each byte and, therefore, will include a total of 32 indicators, one for each of the 32 potential DATA bytes stored in register <b>76</b>. Still further, C/D indictor <b>84</b> may include separate indications for other byte groupings, such as the bus transaction unit size of 8 bytes, or groups of 4 bytes or other groups as well. Indicator <b>86</b> indicates whether portions of the DATA are valid or invalid and, therefore, is referred to hereafter as a V/I indicator <b>86</b>. Unless stated otherwise, the terms valid and invalid are also used in the manner of the cache art, that is, to indicate whether a given portion (e.g., a byte) of the DATA may be relied upon as valid information by a circuit reading that information. Again, recall from above that data register <b>76</b> is preferably sized to store 32 bytes of information. In this context, in the preferred embodiment, V/I indictor <b>86</b> preferably includes separate indications for each bus transaction size and, therefore, includes a total of four indicators, one for each of the 8 byte transaction units of DATA stored in register <b>76</b>. However, as was the case for C/D indicator <b>84</b>, in alternative embodiments indicator <b>86</b> may include separate indications for other byte groupings, such as groups of 4 by tes, individual bytes, or other groups as well. Each of indicators <b>82</b>, <b>84</b>, and <b>86</b> may be represented in various manners as known in the art, such as a bit in separate or common registers, a signal on a conductor, or a state in a state machine. The definition of the indications, that is live or expired, valid or invalid, and dirty or clean, is further demonstrated below with respect to the operation of the circuits of FIG. <b>7</b>.</p><p>L/E indicator <b>82</b> is connected to a L/E control and response circuit <b>88</b>. More particularly, in the preferred embodiment, L/E control and response circuit <b>88</b> may write the state to L/E indicator <b>82</b> and, thereafter, may read that same value for purposes explained below. In addition, L/E control and response circuit <b>88</b> is connected to receive the CLASS and TERMINATE signals from bus B. As detailed below, L/E control and response circuit <b>88</b> is operable to output a HIT/MISS signal which relates to the stored DATA, its CLASS, and its L/E indication. Lastly, note that L/E control and response circuit <b>88</b> may be constructed by a person skilled in the art using various known approaches given an understanding of its functionality and circuit relationships as discussed below.</p><p>The schematic of FIG. 7 further includes a C/D control and response circuit <b>90</b>. More particularly, in the preferred embodiment, C/D control and response circuit <b>90</b> may write the state to C/D indicator <b>84</b> and V/I indicator <b>86</b>, and thereafter it may read those same values for purposes explained below. In addition, C/D control and response circuit <b>90</b> may read the DATA in register <b>76</b>, and also provide control signals to both registers <b>76</b> and <b>78</b> to cause, under circumstances described below, the DATA and ADDRESS of those registers to be written to bus B. Still further, C/D control and response circuit <b>90</b> is connected to receive the above-discussed CLASS signal from bus B. Lastly, note that C/D control and response circuit <b>90</b> may be constructed by a person skilled in the art using various known approaches given an understanding of its functionality and circuit relationships as discussed below.</p><p>Lastly, FIG. 7 further illustrates level <b>2</b> cache circuit <b>6</b>. For reasons more clear below, level <b>2</b> cache circuit <b>6</b> is included to contrast the difference in storage techniques of the circuits of FIG. <b>7</b>. Briefly, recall from above that main memory (e.g., see FIG. 3) may have storage space which is separated into cacheable and non-cacheable data. With respect to FIG. 7, portions of the cacheable data may be stored in level <b>2</b> cache circuit <b>6</b> (or some other cache structure). In contrast, portions of the non-cacheable data may be stored in data register <b>76</b>. The techniques as well as the benefits from the latter storage are detailed below.</p><p>FIG. 8 illustrates a flowchart of a method <b>92</b> of various operational steps of the circuits of FIG. <b>7</b>. Before detailing those steps, note first that the order of various steps in method <b>92</b> is by way of example, and a person skilled in the art may readily alter such order while still taking advantage of various inventive aspects provided by the present circuitry. In addition, various of the steps in FIG. 8 also may be performed concurrently during a common clock cycle rather than sequentially, but a sequential flow is presented to simplify the present discussion.</p><p>Turning to FIG. 8, method <b>92</b> begins with step <b>94</b> where CPU <b>62</b> reads DATA into register <b>76</b>, its corresponding ADDRESS into register <b>78</b>, and its corresponding CLASS identifier into register <b>80</b>. In the preferred embodiment, the DATA which is read is non-cacheable data. Various types of non-cacheable data which may be used with the present embodiments will be ascertainable by one skilled in the art. Indeed, FIG. 6 above introduced one such example, that is, data from a video memory (i.e., MEMORY <b>70</b>). Still other examples are discussed later. In any event, as stated above, DATA register <b>76</b> is preferably sized to store up to a burst sequence of DATA. Thus, after step <b>94</b>, register <b>76</b> stores all 32 bytes of DATA. Recall also in connection with FIG. <b>4</b><i>a </i>that an address was issued on bus lines A<b>31</b>-A<b>3</b> to address the burst sequence of data. Because this address corresponds to the DATA, it is stored as the ADDRESS in register <b>78</b>. Lastly, in accordance with the present embodiments, data stored in data register <b>76</b> will have a CLASS identifier assigned to it. Therefore, step <b>94</b> also reads this CLASS from bus B into register <b>80</b>. Note also that although the above is described as preferable with a burst sequence of DATA, note further in an alternative operation that less than a burst of DATA may be stored in register <b>76</b> (or more than a burst if register <b>76</b> is larger than a single burst size). Thus, it is stated above that register <b>76</b> is operable to store up to one burst line of data, yet it clearly may store less than a burst such as a only a single unit of data (e.g., 8 bytes). Lastly, as further borne out below, note further that once the first DATA arrives in register <b>76</b>, its lifespan has essentially comnenced. Moreover, if this DATA arrives as a burst, the lifespan preferably begins upon receipt of the first part of the burst, such as the first eight bytes. The end of the lifespan is discussed later.</p><p>Step <b>96</b> initializes the values of indicators <b>82</b>, <b>84</b>, and <b>86</b>. Again, although this step is shown in FIG. 8 as following step <b>94</b>, this is done simply to separate the present discussion. Thus, the following actions may occur during the same clock cycle as step <b>94</b>, with the indicators set in response to new DATA being received by register <b>76</b>. Turning now to the indicators, L/E indicator <b>80</b> is initialized to indicate that the newly received DATA in register <b>76</b> is live, again as explained in greater detail below. Moreover, in a manner similar to the meanings in the cache art, C/D indicator <b>84</b> is initialized to indicate that the newly received DATA in register <b>76</b> is clean, and V/I indicator <b>86</b> is initialized to indicate that the newly received DATA in register <b>76</b> is valid. Note further that these settings may be accomplished by L/E control and response circuit <b>88</b> writing the new value to L/E indicator <b>82</b> and C/D control and response circuit <b>90</b> writing the new value to C/D indicator <b>84</b> and V/I indicator <b>86</b>. Again, these two latter indications have the meaning typically used in the cache art Therefore, with respect to C/D indicator <b>84</b>, a clean indication represents that DATA in register <b>76</b> has been unchanged since it was read into register <b>76</b>; conversely, an indication that the DATA is dirty represents that it has been changed since it was read into register <b>76</b> and, therefore, for coherency purposes, is the most current form of that DATA (i.e., the line of DATA acts in a \u201cwrite back\u201d manner as known in the art). With respect to V/I indicator <b>86</b>, a valid indication represents that the DATA in register <b>76</b> may be read by circuits having access to that DATA; conversely, the same DATA should not be read if marked invalid.</p><p>Step <b>98</b> demonstrates a waiting period during which the DATA in register <b>76</b> may be used in a cache-like manner, and again may occur in parallel operation to steps <b>94</b> and <b>96</b>, above. Specifically, step <b>98</b> determines whether the CLASS of DATA stored in register <b>76</b> has been terminated. More specifically, note now that upon assertion of the TERMINATE signal, L/E control and response circuit <b>88</b> compares the CLASS signal on bus B to the CLASS identifier stored in register <b>80</b>. If a match in the CLASS signals occurs, then according to the present embodiments the DATA in register should no longer be used by other circuits having access to that DATA and method <b>92</b> continues to step <b>100</b>. On the other hand, if either the TERMINATE signal has not yet been asserted, or it has been asserted but the CLASS signal on bus B does not match the CLASS identifier stored in CLASS register <b>80</b>, then step <b>98</b> continues to await satisfaction of these conditions before advancing method <b>92</b>. Therefore, note that during step <b>98</b>, the copy of the DATA in register <b>76</b> is live (as indicated by its L/E indicator). Consequently, until that indication changes, then any circuit having access to the DATA may read and/or write to it (of course, provided the DATA is also marked valid). Note, therefore, that during the pendency of step <b>98</b> the DATA which otherwise is usually considered non-cacheable may be used in a cache-like sense, that is, a copy of the DATA has been duplicated from the original version as it existed in a non-cache (e.g., MEMORY <b>70</b>), and that copy is readily accessible to circuitry within CPU <b>62</b> to either read or update that DATA without that same circuitry having to perform an off-chip access to the original copy of the DATA (e.g., to MEMORY <b>70</b>).</p><p>Step <b>100</b>, having been reached once the TERMINATE signal is asserted and detected, and the then-stated CLASS signal on bus B matches the CLASS identifier in register <b>80</b>, changes the state of L/E indicator <b>82</b> from live to expired. Again, this operation may be accomplished by L/E control and response circuit <b>88</b> writing the new value to L/E indicator <b>82</b>. Given the operation thus far, it is again clear that between steps <b>96</b> and <b>100</b> the storage of the DATA and ADDRESS provides a cache-like storage for what is otherwise non-cacheable data. Specifically, before the condition of step <b>98</b> is satisfied, indicator <b>82</b> indicates that the DATA is live. This indication indicates to any requesting circuit that it is permissible during the live status to either read or write the DATA in register <b>76</b>. Of course, this indication is also to be viewed in light of the two other indicators <b>84</b> and <b>86</b>. For example, assume that an entire burst of DATA is stored in register <b>76</b> (i.e., indicator <b>86</b> indicates valid), that the CLASS of the stored DATA has not been terminated, (i.e., indicator <b>82</b> indicates live), and the DATA has not been modified since it was received (i.e., indicator <b>84</b> indicates clean). Thus, like a cache configuration, an address placed on bus B and seeking to read corresponding data may address the DATA in register <b>76</b>. More specifically, such an address is received by L/E control and response circuit <b>88</b>. Circuit <b>88</b> then determines if the address on bus B matches the ADDRESS in register <b>76</b> and whether the DATA is live and valid; if these conditions are met then circuit <b>88</b> issues a HIT in the manner of a cache circuit. Thus, in response to the HIT signal, the circuit which issued the ADDRESS may then read the DATA from register <b>76</b>. Moreover, in a similar regard, note also that a snoop address also may be received by circuit <b>88</b> in a like manner. As known in the art, snooping permits cache structures to maintain proper memory coherency. In the present embodiment, however, recall it is generally non-cacheable data which is stored in register <b>76</b>. Nevertheless, as pointed out with respect to step <b>98</b>, above, the DATA in register <b>76</b> is actually comparable to cached data during the waiting period of step <b>98</b>; consequently, again to ensure proper memory coherency (i.e., to preserve data consistency among different copies of data attributed to a common address in main memory), this DATA also may be snooped, as is accomplished by having circuit <b>88</b> receive a snoop address as mentioned above. Again, therefore, circuit <b>88</b> may compare the snoop address to the ADDRESS in register <b>76</b>, and issue a HIT if the corresponding DATA is live and valid. Still further, if the snoop request further requests a cast out operation, the corresponding DATA may then be written to bus B as well and, therefore, be available in response to the snoop. In this event, C/D indicator <b>84</b> also would be set to clean since the copy of DATA in register <b>76</b> is therefore no longer the only copy of that information. As yet another example, the snoop request may, in addition to requesting a cast out of the DATA, also may request an invalidate. Thus, in addition to outputting the DATA, V/I indicator <b>86</b> would be set to invalid. Indeed, note further under the present embodiment that in response to a snoop which causes an invalidate then V/I indicator <b>86</b> also may be set to expired because otherwise the data would be live but invalid which may not provide a useful state. These as well as other snoop techniques may therefore be included, and such techniques are known in the art such as demonstrated by Section 8.3 of the text \u201cComputer Architecture A Quantitative Approach\u201d, second edition, by Hennessy and Patterson, 1996, publisher Morgan Kaufmann Publishers, Inc., where that section is entitled \u201cCentralized Shared-Memory Architectures,\u201d and which is hereby incorporated herein by reference.</p><p>In addition to the above, due to the described cache-like operation, note further that while the DATA in register <b>76</b> is live, it also may be modified again in a manner similar to the cache art. Thus, if an address seeking to write information is placed on bus B, circuit <b>88</b> again determines whether that address matches the ADDRESS in register <b>78</b> and, if so, further determines whether the DATA in register <b>76</b> is live. If so, the DATA in register <b>76</b> may be modified. Moreover, in such an event, circuit <b>90</b> detects the change to the DATA and changes the state of C/D indicator <b>84</b> from clean to dirty. These as well as other cache-like operations also may be included with the present embodiments, and again are ascertainable from various references, such as the above-cited and incorporated by reference text entitled \u201cComputer Architecture A Quantitative Approach\u201d.</p><p>While the immediately two preceding paragraphs described a cache-like operation for selected circuits of FIG. 7, it is now straightforward to appreciate the concept of the \u201clife span\u201d of the DATA in register <b>76</b> as ultimately defined by the assertion of the TERMINATE signal for the given CLASS of DATA. Specifically, during step <b>100</b>, the DATA is marked expired and, therefore, after that action circuit <b>88</b> will always indicate a miss for that DATA. In other words, even if an address (either a bus address for a read or write from bus B, or a snoop address) is issued to circuit <b>88</b> and matches the address in register <b>78</b>, circuit <b>88</b> will detect that the DATA is expired because the conditions of step <b>98</b> have previously been met (i.e., TERMINATE was asserted as to DATA of the CLASS set forth in register <b>80</b>). Thus, only during the \u201clife span\u201d between the initial loading of the DATA into register <b>76</b> up to its termination is the DATA available in a cache-like manner. Note further, however, that this operation is only stated to be cache-like due to those of its operations which are similar to those of typical cache structures. However, because the DATA is by definition non-cacheable (as indicated from the main memory or other memory which is mapped to main memory space), it is not presented to another non-class identifying cache structure such as level <b>2</b> cache <b>6</b> or other caches within or external from CPU <b>62</b>.</p><p>Turning next to step <b>102</b>, it determines whether C/D indicator <b>84</b> is clean or dirty as corresponding to valid DATA. If the indicator states the DATA in register <b>76</b> is clean (and which is also valid), method <b>92</b> continues to step <b>106</b>. On the other hand, if C/D indicator <b>84</b> indicates that the DATA in register <b>76</b> is dirty, then the method continues to step <b>104</b>.</p><p>During step <b>104</b> circuit <b>90</b> issues appropriate control signals so that the DATA in register <b>76</b> is written to main memory (or some other higher level storage structure such as the graphics adapter memory), according to the ADDRESS stored in register <b>78</b>, thereby ensuring proper memory coherency. Moreover, note further that the CPU <b>62</b> preferably further includes sufficient wait causing circuitry during the period from step <b>100</b> to step <b>104</b> when dirty DATA is not yet written back to main memory. hi other words, assume that step <b>102</b> identifies dirty data and step <b>104</b> therefore commences writing that data to main memory, but assume further that during the write operation(s) there is a request to read that same data. As one approach, the circuit performing the read may be made to wait until the DATA is written to the main memory, and then that circuit reads the DATA from the main memory. As another approach, the circuit performing the read may read the DATA from the bus as that DATA is being written to the main memory.</p><p>Returning briefly to step <b>102</b>, note further that it may be changed or eliminated in alternative embodiments. For example, while method <b>92</b> illustrates that dirty DATA is written to main memory only after the DATA is terminated in response to the assertion of the TERMINATE and appropriate CLASS signals, note further that C/D control and response circuit <b>90</b> also may periodically take this action even before termination occurs. In other words, circuit <b>90</b> may be configured to evaluate the C/D indicator <b>84</b> at some periodic interval regardless of whether TERMINATE has been asserted and, if the DATA is dirty, issue appropriate control signals to cause the DATA to be written to a main memory. Thus, periodic updates could be made to a main memory based on some consideration other than termination. As another example of a modification to the above, the notion of writing dirty information back to a higher storage arises in the context of what is referred to in the art as a writeback approach, that is, an approach where data is initially written to a cache (or cache-like) structure, and is later output to update a higher level memory structure. In an alternative embodiment, therefore, the known write through methodology may be used. In such an event, each time a modification is made to already-stored DATA in register <b>76</b>, it is also written to a main memory (e.g., MEMORY <b>70</b> in the example of FIG. <b>6</b>). In such an event, there is no need to have a dirty versus clean indicator because, by definition, the DATA is always clean (because it is always a copy of the same information available in a higher level memory). Indeed, given the alternative of writeback and write through, still another approach of the present embodiment is to make the choice dynamically alterable. For example, an enable signal could be used. In such an event, when the signal is in a first state, DATA is written in a writeback manner, thereby requiring maintenance of, and adherence to the representation of, C/D indicator <b>84</b> with respect to that DATA. Conversely, when the signal is in a second state, DATA is written in a write through manner, thereby eliminating the need to maintain or respond to the representation of C/D indicator <b>84</b> with respect to that DATA. Lastly, once a proper technique is used to ensure memory coherency due to a modification of the DATA in register <b>76</b>, method <b>92</b> continues to step <b>106</b>.</p><p>Step <b>106</b> merely indicates an end to the flow for the particular instance of DATA and its corresponding ADDRESS. Thus, the DATA is marked as invalid as it is now expired and, again, a valid and expired status may not be useful. Next, after step <b>106</b>, method <b>92</b> may repeat with respect to different non-cacheable DATA written to register <b>76</b>, and then repeat the steps of method <b>92</b> in the manner described above.</p><p>Having completed the discussion of FIG. 7, it is instructive to now return to FIG. 6 to demonstrate how the steps of FIG. 7 may be implemented in the example of video data stored in MEMORY <b>70</b> and, therefore, to demonstrate the operation of the CLASS and TERMINATE signals. Thus, suppose now that the scanlines for screen display <b>66</b> are classified as incrementing from top to bottom of the screen. In other words, suppose that the data in MEMORY <b>70</b> corresponding to the uppermost line on screen display <b>66</b> has a corresponding CLASS identifier of 1, while the data in MEMORY <b>70</b> corresponding to the lowermost line on screen display <b>66</b> has a corresponding CLASS identifier of <b>768</b>, with each CLASS identifier ascending down the screen between CLASS <b>1</b> and CLASS <b>768</b>. Next, assume that MEMORY <b>70</b> at a first instance stores all data corresponding to all <b>768</b> scanlines. Using the present embodiment, therefore, while the uppermost scanline is being traced across screen display <b>66</b>, the next successive scanline (i.e., CLASS <b>2</b>) may be stored as DATA in register <b>76</b> (i.e., as an example of step <b>94</b>), which also therefore stores the identifier value of 2 in CLASS register <b>80</b>, and initializes the indicators corresponding to the stored DATA. Thus, at this point, any circuit having access to register <b>76</b> may use or modify the stored data (i.e., the second scanline) because it is live, clean, and valid. Next, assume that the top scanline across screen display <b>66</b> is complete. At this time, and as is known in the art, video controller <b>68</b> asserts a horizontal synchronization signal. Thus, it is known that very soon in the near future the second scanline will be traced. Therefore, in accordance with the present embodiments, the TERMINATE signal may be the same as, or triggered by, the horizontal synchronization signal Given this signal, at the same time TERMINATE is asserted, video controller <b>68</b> asserts to CPU <b>62</b> the value of CLASS <b>2</b> as the value for the CLASS signal. In response, step <b>98</b> will detect the match of the CLASS signal to the CLASS identifier stored in register <b>80</b>, thereby changing L/E indicator <b>82</b> to expired and causing the stored data, if dirty, to be written out to MEMORY <b>70</b>. Therefore, when the next horizontal trace across screen display <b>66</b> occurs, it may occur using the data in MEMORY <b>70</b> which has now been output from DATA register <b>76</b>. Given this example, therefore, one skilled in the art will appreciate that the non-cacheable video data has, in essence, been available for cache-like use during a lifespan which ends in response to the horizontal synchronization signal. Indeed, this process may repeat for each scanline so that while a scanline is being traced across screen display <b>66</b>, the next successive line is stored in DATA register <b>76</b> and is live for cache-like availability. Note also that the above timing is only by way of example and other alternatives may be used as well. For example, when the first scanline is complete, the TERMINATE signal may be issued along with a CLASS signal corresponding to the third scanline as well. Thus, the DATA, if any, stored in DATA register <b>76</b> and corresponding to that third scanline also would be render expired and, thereafter unavailable for cache like use (as well as being output to memory <b>70</b> provided that DATA is dirty). Numerous other examples will be ascertainable by one skilled in the art.</p><p>Given the above, note further that DATA may be used with present embodiments and terminated in contexts other than the horizonal synchronization signal described above. For example, also in the area of video data, it is known that video controller <b>68</b> will also provide a vertical synchronization signal when the lowest horizontal scanline across screen display <b>66</b> is complete. Thus, the TERMINATE signal could be responsive to this vertical synchronization signal, that is, the TERMINATE signal may be the same as, or triggered by, the assertion of the vertical synchronization signal. Indeed, note further that the present embodiments may apply to data other than video data. For example, various other memory locations in a main memory location may include data pertaining to the status of an I/O device where that data is typically non-cacheable, yet that data may be temporarily stored in a manner consistent with the present embodiments. Given that situation, a copy of such data could be stored and assigned a CLASS identifier as corresponding to the particular I/O device. Therefore, when it is desired that the data be available to the I/O device from a main memory, a signal from the I/O device could be used to trigger the TERMINATE signal while also asserting the designated CLASS identifier, thereby causing the main memory to update and making the correct DATA then available to the I/O device. As an I/O example, a disk controller often includes a disk data buffer, where that buffer is filled with data which, either during the filling process or once the buffer is full, is written to the disk in the corresponding disk drive (the buffer also may receive data from the disk to be written out, such as to main memory). In this regard, a control signal may be output by the disk controller, whereby that control signal is asserted when the buffer reaches a certain empty status (i.e., when a certain portion of the buffer is empty and ready to be filled with more data). Given such a control signal, under the present embodiments it is then used to trigger the TERMINATE signal while a CLASS identifier is concurrently provided (such as by the disk controller). More specifically, when data is being written from the disk data buffer to the disk and the buffer reaches a certain status of less than full, the control signal would be asserted, thereby asserting TERMINATE. At the same time, the CLASS identifier would indicate a group of data to be written to the buffer. Consequently, in response, the data necessary to fill the buffer would be updated from register <b>76</b> to the main memory, and thus would also be available to the disk data buffer. Still other examples may be ascertained by one skilled in the art.</p><p>FIG. 9 illustrates an alternative embodiment to FIG. 7 where many of the same concepts are carried forward yet are duplicated to store numerous independent sets of DATA and ADDRESSES. Thus, to simplify the common aspects of FIGS. 7 and 9, like reference numerals are carried forward in most instances, but subscripts are added or reference numbers are changed to distinguish those changed features, each of which is discussed below.</p><p>The implementation of FIG. 9 allows storage of three different lines of DATA in corresponding registers <b>76</b><sub>1</sub>, <b>76</b><sub>2</sub>, and <b>76</b><sub>3</sub>. Each of these lines is again preferably operable to store up to one burst line of data (e.g., 32 bytes). Moreover, each line of DATA has a corresponding ADDRESS stored in a respective register <b>78</b><sub>1</sub>, <b>78</b><sub>2</sub>, and <b>78</b><sub>3</sub>. Still further, note that each of these lines also has a corresponding CLASS register <b>80</b><sub>1</sub>, <b>80</b><sub>2</sub>, and <b>80</b><sub>3</sub>. Indeed, note that where multiple storage units are used such as depicted in FIG. 9, one approach is to use existing microprocessor storage circuits. For example, often a microprocessor includes a prefetch buffer which includes the capability to store lines of data and corresponding addresses. Thus, one technique for implementing the multiple data and address registers of FIG. 9 is to share the prefetch buffer responsibility with the operation described in this document. In other words, an enable signal could be associated with each storage line. When the enable signal is in a first state, the line operates according to the predetermined prefetch function of the microprocessor. However, when the enable signal is in a second state, the line operates according to the present embodiments. For more information about an inventive prefetch buffer arrangement, the reader is invited to review U.S. Provisional Patent Application Number 60/024,860, entitled \u201cMicroprocessor Circuit, Systems, And Methods Using A Combined Writeback Queue And Victim Cache\u201d, filed Aug. 28,1996, upon which U.S. patent application Ser. No. 08/919,732 claims priority, now U.S. Pat. No. 6,035,654 issued Mar. 14, 2000, which is hereby incorporated herein by reference.</p><p>Returning to each line of information provided by FIG. 9 in the sense of the present embodiments, each such line further includes a corresponding L/E indicator <b>82</b><sub>1</sub>, <b>82</b><sub>2</sub>, and <b>82</b><sub>3</sub>, a corresponding C/D indicator <b>84</b><sub>1</sub>, <b>84</b><sub>2</sub>, and <b>84</b><sub>3</sub>, and a corresponding V/I indicator <b>861</b>, <b>862</b>, and <b>863</b>. Each of the above registers and indicators are again connected to control circuits, those including L/E control and response circuit <b>88</b> and C/D control and response circuit <b>90</b>. In this instance, however, circuits <b>88</b> and <b>90</b> include additional hardware to accommodate the plurality of independent data lines as well as their corresponding ADDRESS and CLASS registers. Lastly, note that the TERMINATE and CLASS signals are connected to both L/E control and response circuit <b>88</b> and C/D control and response circuit <b>90</b> and, therefore, each line corresponding to a terminated CLASS may be identified and output to main memory as better appreciated below.</p><p>The operation of the circuit of FIG. 9 is generally the same as method <b>92</b> of FIG. 8 discussed above. However, the same steps set forth above with respect to method <b>92</b> are preferably independently carried out with respect to each different line (i.e., DATA, as well as its corresponding ADDRESS, CLASS identifier, indicators, and the TERMINATE and CLASS signals). Thus, the reader is first referred to the above discussion of FIG. 8 for an extensive description. At this point, one skilled in the art will appreciate that, for each line of DATA and corresponding ADDRESS, a life span is associated with that line due to the corresponding CLASS, and during the life span the DATA may be read or written and memory coherency is ensured either during or at the end of that life span. However, note now the effect of multiple lines sharing the same CLASS. More specifically, the example of FIG. 9 includes three separate lines to store the above-discussed information (i.e., DATA, CLASS, ADDRESS, and indicators). Now, suppose by way of example that the top and bottom lines in FIG. 9 have an identifier value of 3 in their CLASS registers, while the middle line has an identifier value of 2 in its CLASS register. Next, note that when the TERMINATE signal is asserted, L/E control and response circuit <b>88</b> determines whether the contemporaneously asserted CLASS signal matches that in any one or more of the CLASS registers. For example, assume TERMINATE is asserted and the CLASS signal then on bus B indicates a value of 3. Therefore, L/E control and response circuit <b>88</b> finds a match in both the top and bottom lines of information in FIG. <b>9</b>. In response, L/E control and response circuit <b>88</b> will set L/E indicators <b>82</b><sub>1</sub>, and <b>82</b><sub>3 </sub>to expired, will indicator <b>82</b><sub>2 </sub>will remain set to live. Moreover, also in response, C/D control and response circuit <b>90</b> will then operate with respect to the top and bottom lines of DATA as discussed above. In other words, if that DATA is dirty, it is output to a higher memory to ensure proper coherency.</p><p>Given the example provided in the immediately preceding paragraph, one skilled in the art will appreciate that the present embodiments may be further modified to include any number of lines in the storage structure, where each of those lines is also capable of associating a CLASS to the DATA stored in a line. Given this capability, a single CLASS identifier, when evaluated in response to the assertion of the TERMINATE signal, may cause various different lines of DATA to be output by the storage structure to a higher memory. Note therefore that the present embodiments may be distinguished in various manners to the outputting of data from a typical cache. For example, in a typical cache, only one cache line is identified as requiring output to a higher memory. In contrast, in the present embodiments, if DATA in more than one line is associated with the same CLASS identifier, then each of those lines are identified as required for output (if the data is dirty) by the single assertion of the TERMINATE and CLASS signals. As another example, in a typical cache a request directed to the cache is made by presenting the cache with an address, and from that address it is known that the addressed data and perhaps some data contiguous to that data (i.e., commonly the surrounding data in the same cache line as the addressed data) is to be affected by the request. In contrast, in the present embodiments, an explicit address is not provided in the request to the storage structure to output dirty DATA. Still further, also in the present embodiments, a single CLASS identifier may affect DATA which is in various lines in the storage structure, and which therefore does not necessarily reflect data stored in contiguous memory locations. Still other differences and benefits will be appreciated by one skilled in the art</p><p>FIG. 10 illustrates an alternative embodiment to FIG. 9 where various of the above-discussed concepts are carried forward with additional modifications within the inventive scope. Thus, again there is designated generally a microprocessor <b>62</b> having a BIU <b>8</b> receiving three external bus signals (i.e., DBUS, ABUS, and CBUS) as well as a CLK signal. Again for simplicity each of the DBUS, ABUS, and CBUS is shown connected through BIU <b>8</b> to a common bus B. As an introductory matter, note that the embodiment of FIG. 10 demonstrates how various of the present inventive concepts may be further combined by modifying an existing cache structure. For example, the circuits shown below bus B in FIG. 10 may be included with, or associated with, a cache structure such as L<b>2</b> cache <b>6</b> shown in various of the above Figures. By associating the present embodiment with an existing cache, design complexity is minimized with such an approach, as may be the data path since a separate data path need not be constructed to a structure which is completely independent of an existing cache. Given this introduction, the discussion below describes the various circuits and well as their relationship to both the present embodiments as well as current cache structures.</p><p>The circuits of FIG. 10 include a tag memory <b>108</b> and as associated data memory <b>110</b>. In general, the association of a tag memory and data memory is known in the art, whereby the tag memory stores information regarding a corresponding entry in the data memory. Tag memory <b>108</b> and data memory <b>110</b> have a corresponding number of rows, illustrated as an integer N in FIG. <b>10</b>. With respect to tag memory <b>108</b>, each of its rows includes three portions as known in the art and may include other as well. With respect to the three known portions shown, tag memory <b>108</b> includes an ADDRESS of the corresponding data in data memory <b>110</b>, an indicator of whether the corresponding data is clean or dirty (i.e., shown as a C/D indicator), and an indicator of whether the corresponding data is valid or invalid (i.e., shown as a V/I indicator). As with the above embodiments, the indicators may be represented by a signal or bit, and may be for an entire width of a data entry or include multiple indicators for parts of the data entry (e.g., per byte, multiple bytes, burst size, and so forth). Lastly, in order to provide an appropriate HIT/MISS signal as demonstrated below, the ADDRESSEes from tag memory <b>108</b> may be read, and each of the C/D indicators and V/I indicators may be both read and written by a C/D and V/I control and response circuit <b>112</b>.</p><p>In addition to the known elements of tag memory <b>108</b>, it also includes at least two other aspects thereby creating a system within the present inventive embodiments. As a first aspect, in addition to indicating validity for purposes known in the art, each V/I indicator may be also be set to invalid in response to an L/E control and response circuit <b>114</b>. As better appreciated below, therefore, when the life span, if any, for the data corresponding to the tag memory entry reaches its threshold, the V/I indicator is set to invalid. As a second aspect, a number of rows in tag memory <b>108</b>, which in the preferred embodiment includes all N rows, includes a CLASS register in addition to the other three portions described above. The detailed functionality of the CLASS indicator in the CLASS register is described below.</p><p>Completing the remaining connections of FIG. 10, it again indicates that the CBUS may pass both a TERMINATE and CLASS signal to bus B. The CLASS signal is coupled so that it may be input to the CLASS register which corresponds to a given one of the lines when DATA is written to that line. Additionally, the CLASS signal, as well as the TERMINATE signal, are connected to both C/D and V/I control and response circuit <b>112</b> and L/E control and response circuit <b>114</b> for reasons more clear below.</p><p>The operation of the circuits of FIG. 10 share some commonality with various of the embodiments described in connection with earlier Figures and, therefore, the reader is assumed to have an understanding of the earlier-described embodiments such that some of the detail need not be re-stated below. In a first sense and as an additional aspect of the present embodiment, tag memory <b>108</b> and data memory <b>110</b> may be made to operate, based on the value of the CLASS identifier stored in a CLASS register, according to known technology. Particularly, if the value in a CLASS register is set to some predetermined value (e.g., CLASS=0), then standard cache operations may occur with respect to the DATA in the line corresponding to that CLASS register. Thus, if CLASS equals the predetermined value (e.g., 0), then an ADDRESS on bus B is connected to tag memory <b>108</b> and, provided that the ADDRESS matches an ADDRESS in tag memory <b>100</b> corresponding to valid DATA, C/D and V/I control and response circuit <b>112</b> outputs a HIT signal from which the appropriate action may be taken (i.e., depending on the request corresponding to the ADDRESS, such as reading the DATA, updating the DATA, or responding to some type of snoop). On the other hand, if the value in a CLASS register is not the predetermined value (e.g., non-zero), then the operation is more in the manner described above in connection with earlier embodiments, and as detailed below.</p><p>In addition to the known functionality of tag memory <b>108</b>, note that the embodiments of FIG. 10 further include inventive operation permitting a life span to be associated with DATA in data memory <b>110</b>. Specifically, recall that each row in tag memory <b>108</b> includes a CLASS register for storing a CLASS identifier. Note now that a CLASS identifier for a given row is operable to store an identification of any one of many different classes or, as described above, may be set to some predetermined value (e.g., zero) to indicate that the DATA of the row is not associated with any particular class. For example, assume that CLASS, which corresponds to DATA<sub>1</sub>, states a value of 1. Therefore, only once the TERMINATE signal is asserted along with a CLASS signal of 1 is DATA<sub>1 </sub>changed from live to expired. Thus, before that event, DATA<sub>1 </sub>is live and may be accessed and/or updated by a circuit having access to data memory <b>110</b>. Note also that the CLASS register embodiment of FIG. 10 also permits more than one row of DATA to be associated with the same CLASS identifier, or for each different row to be associated with a different CLASS identifier.</p><p>Note that the configuration of FIG. 10 as well as its operation gives rise to yet another alternative aspect, namely, in connection with the indication of whether data is live or expired. Recall that the embodiments of FIG. 7 and 9 include an L/E indicator which is separate and independent from a V/I indicator for each line. However, as an alternative, note in the embodiment of FIG. 10 that a separate and independent V/I indicator is not provided for each line. Instead, L/E control and response circuit <b>114</b> is connected so that it may modify the V/I indicator for each line of tag memory <b>108</b>. As a result, once a CLASS of DATA is terminated by the TERMINATE signal, rather than setting a separate L/E indicator to expired, L/E control and response circuit <b>114</b> sets the V/I indicator for that line to invalid. Like the above embodiments, upon this event it is also determined whether the corresponding data is dirty (i.e., by its corresponding C/D indicator) and, if so, the dirty data is written to some higher level of storage so as to ensure proper memory coherency. In any event, because there is not a separate L/E indicator, the V/I indicator not only indicates whether the corresponding data is valid according to known cache policy, but may further designate the data as invalid due to an event which caused assertion of the TERMINATE signal. Consequently, because an invalid state of a V/I indicator in known cache technology indicates that data is no longer valid, note therefore that expired DATA is thereafter treated as invalid and, hence, the expired data will not be relied upon by a circuit seeking that information from data memory <b>110</b>. Given this functionality, one skilled in the art will further appreciate that L/E control and response circuit <b>114</b> includes sufficient circuitry to monitor the incoming TERMINATE signal as well as the values of each CLASS register storing a non-zero CLASS identifier. Thus, when the TERMINATE signal is asserted along with the CLASS of data to be terminated, then the DATA for each line having the matching CLASS identifier will be invalidated, that is, the V/I indicator corresponding to each such line will be set by circuit <b>114</b> to invalid. As an example, assume that both CLASS<sub>1 </sub>and CLASS<sub>2 </sub>both identify a value of 3, and that the TERMINATE signal is asserted with a CLASS value of 3 then on bus B. Given that example, L/E control and response circuit <b>114</b> will detect the match of the CLASS signal with the values in both the CLASS<sub>1 </sub>and CLASS<sub>2 </sub>registers. In response, L/E control and response circuit <b>114</b> will set both V/I<sub>1 </sub>and V/I<sub>2 </sub>to invalid. Lastly, note that this alternative of eliminating a separate and independent L/E indicator permits data which still is live based on a lack of an applicable TERMINATE signal to otherwise be marked as invalid. For example, if a given line of DATA corresponds to a CLASS which has not been asserted along with a TERMINATE signal, and a snoop and invalidate request is received by tag memory <b>108</b> for that line, then the line will be set to invalid by C/D and V/I control and response circuit <b>112</b> even though a TERMINATE signal has not been received which corresponds to that line. In contrast, a separate L/E indication such as in FIGS. 7 and 9 will not permit such an event and therefore provides a separate indication of a line which has not been terminated in response to the TERMINATE signal. Thus, any of the embodiments herein may use either alternative, that is, either an L/E indicator separate and independent from the V/I indicator, or a single V/I indicator which operates according to known cache policies, but which additionally identifies data as invalid if the life span of that data has reached its threshold.</p><p>From the above, it may be appreciated that the above embodiments permit storage of non-cacheable data into a cache-like structure for a certain life span of that data, and this structure may be independent of, or merged with, an existing cache structure. In either event, the life spanned data may be read and modified during this time without having to seek it from main memory. Moreover, the duration of the life span may be tied to various different events and circumstances to minimize or eliminate the possibility of active operations on two different versions of data corresponding to the same address. In addition, while the present embodiments have been described in detail, various substitutions, modifications or alterations could be made to the descriptions set forth above without departing from the inventive scope. Numerous such examples are presented above. As still another example, note that various principles in this document may be practiced independent of others. For example, the life span concept of FIGS. 6 through <b>10</b> may apply to processors using techniques differing from those in FIGS. 1 through 5. As another example, note that the present embodiments may be combined with those in the earlier incorporated by reference application Ser. No. 60/029,232, filed Oct. 31, 1996, upon which U.S. patent application Ser. No. 08/962,987 filed Oct. 31, 1997 claims priority, entitled \u201cMicroprocessor Circuits And Systems With Life Spanned Storage Circuit For Storing Non-cacheable Data\u201d (attorney docket number TI-23331P). Briefly, U.S patent application Ser. No. 08/962,987 which has the same inventors as the current patent application, also discloses a structure permitting storage of non-cacheable data into a cache-like structure for a certain life span of that data. In the incorporated patent application, however, the life span is defined by the expiration of a timer, that is, when the count in the timer times out by reaching some predetermined threshold. Thus, in the incorporated patent application, this time out causes the data to be marked as expired rather than a non-timer event as in the present patent application. However, note now that the two technologies may be combined, whereby the L/E indicator would indicate an expired status in response to the occurrence of either: (1) an event as in the present patent; or (2) the time out of a timer as in the referenced patent application. Thus, the TERMINATE signal could be asserted in response to either of these two occurrences. Still other examples are ascertainable by a person skilled in the art. Thus, the above benefits as well as the flexibility of the various examples set forth above demonstrate the many aspects of the present embodiments, which are defined by the following claims.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Steven D.", "last_name": "Krueger", "name": ""}, {"first_name": "Jonathan H.", "last_name": "Shiell", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "TEXAS INSTRUMENTS INCORPORATED"}, {"first_name": "", "last_name": "TEXAS INSTRUMENTS INCORPRATED", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  13/28"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711135"}, {"primary": false, "label": "711E12021"}, {"primary": false, "label": "711133"}, {"primary": false, "label": "712205"}], "ecla_classes": [{"label": "G06F  12/08B18"}], "cpc_classes": [{"label": "G06F  12/0888"}, {"label": "G06F2212/6022"}, {"label": "G06F  12/0888"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1995-12-18", "application_date": "1998-06-05", "family_members": [{"ucid": "US-6173368-B1", "titles": [{"lang": "EN", "text": "Class categorized storage circuit for storing non-cacheable data until receipt of a corresponding terminate signal"}]}]}