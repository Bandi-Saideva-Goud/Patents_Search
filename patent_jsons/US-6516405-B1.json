{"patent_number": "US-6516405-B1", "publication_id": 73307779, "family_id": 23888499, "publication_date": "2003-02-04", "titles": [{"lang": "EN", "text": "Method and system for safe data dependency collapsing based on control-flow speculation"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50445700\"><p>The present invention is directed to an apparatus and method for data collapsing based on control-flow speculation (conditional branch predictions). Because conditional branch outcomes are resolved based on actual data values, the conditional branch prediction provides potentially valuable insight into data values. Upon encountering a branch if equal instruction and this instruction is predicted as taken or a branch if not equal instruction and this instruction is predicted as not taken, this invention assumes that the two operands used to determine the conditional branch are equal. The data predictions are safe because a data misprediction means a conditional branch misprediction which results in a pipeline flush of the instructions following the conditional branch instruction including the data mispredictions.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11472983\" source=\"national office\"><p>The present invention is directed to an apparatus and method for data collapsing based on control-flow speculation (conditional branch predictions). Because conditional branch outcomes are resolved based on actual data values, the conditional branch prediction provides potentially valuable insight into data values. Upon encountering a branch if equal instruction and this instruction is predicted as taken or a branch if not equal instruction and this instruction is predicted as not taken, this invention assumes that the two operands used to determine the conditional branch are equal. The data predictions are safe because a data misprediction means a conditional branch misprediction which results in a pipeline flush of the instructions following the conditional branch instruction including the data mispredictions.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00001\" num=\"1\"><claim-text>1. An apparatus for collapsing a set of operands, comprising:</claim-text><claim-text>a post-decode unit which: </claim-text><claim-text>upon decoding one of a set of instructions that modifies its zero flag when executed, records information in a first entry about a set of operands for that particular one of the set of instructions; </claim-text><claim-text>upon decoding one of a set of instructions that is at least one of a branch if equal and predicted as taken and a branch if not equal and predicted as not taken, copies the recorded information in the first entry to one of a set of second entries; and </claim-text><claim-text>translates the set of operands for each one of a set of instructions if information is recorded about the set of operands in one of the set of second entries and that recorded information is valid. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00002\" num=\"2\"><claim-text>2. The apparatus of <claim-ref idref=\"US-6516405-B1-CLM-00001\">claim 1</claim-ref> wherein the post-decode unit upon decoding one of the set of instructions that writes to one of the set of operands whose information was recorded in at least one of the first entry and one of the set of second entries, disables the collapsing of the set of operands for that particular one of the set of operands.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00003\" num=\"3\"><claim-text>3. The apparatus of <claim-ref idref=\"US-6516405-B1-CLM-00002\">claim 2</claim-ref> wherein the recorded information in the first entry is stored in a compare operand buffer, the compare operand buffer includes a first entry, the first entry corresponding to one of the set of instructions that modifies its zero flag, the first entry has:</claim-text><claim-text>a set of operands; and </claim-text><claim-text>a valid field indicating whether the set of operands is valid. </claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00004\" num=\"4\"><claim-text>4. The apparatus of <claim-ref idref=\"US-6516405-B1-CLM-00003\">claim 3</claim-ref> wherein the set of operands for the first entry has:</claim-text><claim-text>a register number field including an architectural register for one of the set of operands; and </claim-text><claim-text>an immediate value/register number field including at least one of the architectural register of another of the set of operands and an immediate value. </claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00005\" num=\"5\"><claim-text>5. The apparatus of <claim-ref idref=\"US-6516405-B1-CLM-00004\">claim 4</claim-ref> wherein the first entry includes a register/immediate field indicating whether the immediate value/register number field includes the archtitectural register identifier for the other of the set of operands or the immediate value.</claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00006\" num=\"6\"><claim-text>6. The apparatus of <claim-ref idref=\"US-6516405-B1-CLM-00005\">claim 5</claim-ref> wherein upon decoding at least one of the branch if equal and predicted as taken, and the branch if not equal and predicted as not taken, the recorded information in the first entry is copied to a register translation table, the register translation table includes the set of second entries, one second entry for each of a set of architectural registers, each one of the set of second entries has:</claim-text><claim-text>one of the set of operands for one of the set of instructions whose zero flag is modified, that particular one of the set of operands indexed using the other of the set of operands; </claim-text><claim-text>a valid field indicating whether the particular one of the set of second entries is valid; and </claim-text><claim-text>a register/immediate field indicating whether the particular one of the set of operands is an immediate value or an architectural register for the particular one of the set of operands. </claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00007\" num=\"7\"><claim-text>7. The apparatus of <claim-ref idref=\"US-6516405-B1-CLM-00006\">claim 6</claim-ref> wherein the one of the set of operands used for indexing is a predicted latest defined operand.</claim-text></claim>"}, {"num": 8, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00008\" num=\"8\"><claim-text>8. An apparatus for collapsing a set of operands, comprising:</claim-text><claim-text>a modified register renamer which: </claim-text><claim-text>upon decoding one of a set of instructions that modifies its zero flag when executed, records information in an entry about a set of operands for that particular one of the set of instructions that modifies its zero flag; and </claim-text><claim-text>remaps an architectural register for one of the set of operands to a physical register for another of the set of operands when at least one of a branch if equal and predicted as taken and a branch if not equal and predicted as not taken and the recorded information in the entry is valid. </claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00009\" num=\"9\"><claim-text>9. The apparatus of <claim-ref idref=\"US-6516405-B1-CLM-00008\">claim 8</claim-ref> wherein the modified register renamer, upon decoding one of the set of instructions that writes to one of the set of operands whose information is recorded in the entry, invalidates that entry.</claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00010\" num=\"10\"><claim-text>10. The apparatus of <claim-ref idref=\"US-6516405-B1-CLM-00009\">claim 9</claim-ref> wherein the recorded information is stored in a modified compare operand buffer, the modified compare operand buffer includes the entry, the entry corresponding to one of the set of instructions which modifies its zero flag, the entry has:</claim-text><claim-text>a set of operands; and </claim-text><claim-text>a valid field indicating whether the entry is valid. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00011\" num=\"11\"><claim-text>11. The apparatus of <claim-ref idref=\"US-6516405-B1-CLM-00010\">claim 10</claim-ref> wherein the set of operands for the entry has:</claim-text><claim-text>an architectural register id. field that is the architectural register for one of the set of operands; and </claim-text><claim-text>a physical register id. field that is the physical register for another of the set of operands. </claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00012\" num=\"12\"><claim-text>12. The apparatus of <claim-ref idref=\"US-6516405-B1-CLM-00011\">claim 11</claim-ref> wherein the architectural register for one of the set of operands is the architectural register for a predicted latest defined operand and the physical register for one of the set of operands is the physical register for a predicted earliest defined operand.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00013\" num=\"13\"><claim-text>13. A method for collapsing a set of operands, comprising:</claim-text><claim-text>upon decoding one of the set of instructions that modifies its zero flag when executed, recording information in a first entry about a set of operands for that particular one of the set of instructions; </claim-text><claim-text>upon decoding one of a set of instructions that is at least one of a branch if equal and predicted as taken, and a branch if not equal and predicted as not taken, copying the recorded information in the first entry to one of a set of second entries; and </claim-text><claim-text>collapsing the set of operands for each one of the set of instructions if information is recorded about the set of operands in one of the set of second entries and that recorded information is valid. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00014\" num=\"14\"><claim-text>14. The method of <claim-ref idref=\"US-6516405-B1-CLM-00013\">claim 13</claim-ref> further comprising upon decoding one of the set of instructions that writes to one of the set of operands whose information was recorded in at least one of the first entry and one of the set of second entries, disabling the collapsing of the set of operands for that particular one of the set of operands.</claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00015\" num=\"15\"><claim-text>15. The method of <claim-ref idref=\"US-6516405-B1-CLM-00014\">claim 14</claim-ref> wherein recording information in the first entry about the set of operands for one of the set of instructions that modifies its zero flag includes creating a compare operand buffer that includes the first entry, the first entry corresponding to one of the set of instructions that modifies the zero flag, the first entry having:</claim-text><claim-text>a valid field indicating whether the first entry is valid; </claim-text><claim-text>a register number field including an architectural register for one of the set of operands; </claim-text><claim-text>an immediate value/register number field including at least one of an immediate value and an architectural register for another of the set of operands; and </claim-text><claim-text>a register/immediate field indicating whether the immediate value/register number field includes the architectural register or the immediate value. </claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00016\" num=\"16\"><claim-text>16. The method of <claim-ref idref=\"US-6516405-B1-CLM-00015\">claim 15</claim-ref> wherein copying the recorded information in the first entry to one of the set of second entries includes creating a register translation table that includes a set of second entries, one second entry for each of a set of architectural registers, each of the set of second entries having:</claim-text><claim-text>a valid field indicating whether the particular one of the set of second entries is valid; </claim-text><claim-text>an immediate value/register number field inlcuding at least one of the immediate value and an architectural register for one of the set of operands; and </claim-text><claim-text>a register/immediate field indicating whether the immediate value/register number field contains the architectural register for one of the set of operands or the immediate value. </claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00017\" num=\"17\"><claim-text>17. The method of <claim-ref idref=\"US-6516405-B1-CLM-00016\">claim 16</claim-ref> wherein upon decoding one of the set of instructions that modifies its zero flag, a first operand of the particular one of the set of instructions is stored in the register number field of the first entry, a second operand of the particular one of the set of instructions is stored in the immediate value/register number field of the compare operand buffer, the register/immediate field of the first entry is set to at least one of \u201c1\u201d if the immediate value/register number field contains a register and \u201c0\u201d if the immediate value/register number field contains an immediate value, and the valid field of the first entry is set to valid.</claim-text></claim>"}, {"num": 18, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00018\" num=\"18\"><claim-text>18. The method of <claim-ref idref=\"US-6516405-B1-CLM-00017\">claim 17</claim-ref> wherein upon decoding one of the set of instructions that is at least one of the branch if equal and predicted as taken and the branch if not equal and predicted as not taken, fmding for the first entry, a replacement operand that is at least one of an immediate value and a predicted earliest defined operand, and a former operand that is a predicted latest defined operand.</claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00019\" num=\"19\"><claim-text>19. The method of <claim-ref idref=\"US-6516405-B1-CLM-00018\">claim 18</claim-ref> wherein upon decoding one of the set of branch instructions that is at least one of the branch if equal and predicted as taken and the branch if not equal and predicted as not taken, the set of second entries is modified such that one of the set of second entries is a new entry, the new entry is indexed in the set of second entries by the former operand, and the replacement operand is copied from the first entry to the immediate value/register number field of the new entry, the valid field of the new entry is set to valid, and if the immediate value/register number field for the new entry contains an immediate value, then the register/immediate field is set to \u201c0\u201d, otherwise, the register/immediate field is set to \u201c1\u201d.</claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00020\" num=\"20\"><claim-text>20. The method of <claim-ref idref=\"US-6516405-B1-CLM-00019\">claim 19</claim-ref> wherein upon decoding one of a set of instructions whose one of a set of operands indexes one of the set of second entries and the corresponding one of the set of second entries has the valid field set to valid, then the particular one of the set of operands is replaced with the contents of the immediate value/register number field of the corresponding one of the set of second entries.</claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00021\" num=\"21\"><claim-text>21. The method of <claim-ref idref=\"US-6516405-B1-CLM-00020\">claim 20</claim-ref> wherein upon decoding a one of the set of instructions which writes to one of its operands and that particular one of the set of operands is found in at least one of the register number field and the immediate value/register number field of the first entry, disabling data collapsing for that particular one of the set of operands by setting the valid field in the first entry to invalid.</claim-text></claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00022\" num=\"22\"><claim-text>22. The method of <claim-ref idref=\"US-6516405-B1-CLM-00021\">claim 21</claim-ref> wherein upon decoding the one of the set of instructions which writes to one of its operands and that particular one of the set of operands is indexing one of the set of second entries, disabling data collapsing for that particular one of the set of operands by setting the valid field to invalid for the corresponding one of the set of second entries.</claim-text></claim>"}, {"num": 23, "parent": 22, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00023\" num=\"23\"><claim-text>23. The method of <claim-ref idref=\"US-6516405-B1-CLM-00022\">claim 22</claim-ref> wherein upon decoding the one of the set of instructions which writes to one of its operands and that particular one of the set of operands is found in the immediate value/register number field of one of the set of second entries, disabling data collapsing for that particular one of the set of operands by setting the valid field of the corresponding one of the set of second entries to invalid.</claim-text></claim>"}, {"num": 24, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00024\" num=\"24\"><claim-text>24. A method for collapsing a set of operands, comprising:</claim-text><claim-text>upon decoding one of a set of instructions that modifies its zero flag when executed, recording information in an entry about a set of operands for that particular one of the set of instructions that modifies its zero flag; and </claim-text><claim-text>remapping an architectural register for one of the set of operands to a physical register for another of the set of operands upon decoding at least one of a branch if equal and predicted as taken and a branch if not equal and predicted as not taken, and the recorded information in the entry is valid. </claim-text></claim>"}, {"num": 25, "parent": 24, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00025\" num=\"25\"><claim-text>25. The method of <claim-ref idref=\"US-6516405-B1-CLM-00024\">claim 24</claim-ref> wherein recording information in the entry about the set of operands for one of the set of instructions that modifies its zero flag includes creating a modified compare operand buffer which includes the entry, the entry corresponding to one of the set of instructions that modifies its zero flag, the entry having:</claim-text><claim-text>a valid field indicating whether the entry is valid; </claim-text><claim-text>an architectural register id. field including an architectural register for one of the set of operands; and </claim-text><claim-text>a physical register id. field including one of a set of physical registers for another of the set of operands. </claim-text></claim>"}, {"num": 26, "parent": 25, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00026\" num=\"26\"><claim-text>26. The method of <claim-ref idref=\"US-6516405-B1-CLM-00025\">claim 25</claim-ref> wherein upon decoding one of the set of instructions that modifies its zero flag, if one of the set of operands for the particular one of the set of instructions that modifies its zero flag is an immediate value then if the immediate value is stored in one of the set of physical registers then that particular one of the set of physical registers for the immediate value is stored in the physical register id. field of the entry, and the architectural register for another one of the set of operands is stored in the architectural register id. field of the entry and the valid field of the entry is set to valid, otherwise, if the immediate value is not in one of the set of physical registers, then no information is recorded in the entry for the particular one of the set of instructions that modifies its zero flag.</claim-text></claim>"}, {"num": 27, "parent": 25, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00027\" num=\"27\"><claim-text>27. The method of <claim-ref idref=\"US-6516405-B1-CLM-00025\">claim 25</claim-ref> wherein upon decoding one of the set of instructions that modifies its zero flag, if none of the set of operands is an immediate value then the architectural register id. field includes an architectural register for a predicted latest defined operand and the physical register id. field includes one of the set of physical registers for a predicted earliest defined operand, and the valid field of the entry is set to valid.</claim-text></claim>"}, {"num": 28, "parent": 25, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00028\" num=\"28\"><claim-text>28. The method of <claim-ref idref=\"US-6516405-B1-CLM-00025\">claim 25</claim-ref> wherein upon decoding one of the set of instructions that is at least one of a branch if equal and predicted as taken and a branch if not equal and predicted as not taken, remapping the architectural register in the architectural register id. field of the entry to the particular one of the set of physical registers in the physical register id. field of the entry.</claim-text></claim>"}, {"num": 29, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00029\" num=\"29\"><claim-text>29. A method, comprising:</claim-text><claim-text>upon encountering an instruction that modifies its zero flag, storing a set of operands of that instruction; and </claim-text><claim-text>after encountering a branch if not equal instruction that is predicted as not taken, replacing one of operands of a particular one of a set of decoded instructions with one of the set of operands that is stored. </claim-text></claim>"}, {"num": 30, "parent": 29, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00030\" num=\"30\"><claim-text>30. The method of <claim-ref idref=\"US-6516405-B1-CLM-00029\">claim 29</claim-ref> wherein the one of the set of operands that is stored is a predicted earliest defined operand.</claim-text></claim>"}, {"num": 31, "parent": 29, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00031\" num=\"31\"><claim-text>31. The method of <claim-ref idref=\"US-6516405-B1-CLM-00029\">claim 29</claim-ref> wherein the one of the set of operands of the particular one of the set of decoded instructions is replaced if that operand is the same as the one of the set of operands that is stored, and the one of the set of operands that is stored is valid.</claim-text></claim>"}, {"num": 32, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00032\" num=\"32\"><claim-text>32. A method, comprising:</claim-text><claim-text>upon encountering an instruction that modifies its zero flag, storing a set of operands of that instruction; and </claim-text><claim-text>after encountering a branch if equal instruction that is predicted as taken, replacing one of a set of operands of a particular one of a set of decoded instructions with one of the set of operands that is stored. </claim-text></claim>"}, {"num": 33, "parent": 32, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00033\" num=\"33\"><claim-text>33. The method of <claim-ref idref=\"US-6516405-B1-CLM-00032\">claim 32</claim-ref> wherein the one of the set of operands that is stored is a predicted earliest defined operand.</claim-text></claim>"}, {"num": 34, "parent": 32, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00034\" num=\"34\"><claim-text>34. The method of <claim-ref idref=\"US-6516405-B1-CLM-00032\">claim 32</claim-ref> wherein the one of the set of operands of the particular one of the set of decoded instructions is replaced if that operand is the same as the one of the set of operands that is stored, and the one of the set of operands that is stored is valid.</claim-text></claim>"}, {"num": 35, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00035\" num=\"35\"><claim-text>35. A processor, comprising:</claim-text><claim-text>a post-decode unit, which </claim-text><claim-text>upon encountering an instruction that modifies its zero flag, stores a set of operands of that instruction; and </claim-text><claim-text>after encountering at least one of a branch if not equal instruction which is predicted as not taken and a branch if equal instruction that is predicted as taken, replaces one of a set of operands of a particular one of a set of decoded instructions with one of the set of operands that is stored. </claim-text></claim>"}, {"num": 36, "parent": 35, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00036\" num=\"36\"><claim-text>36. The processor of <claim-ref idref=\"US-6516405-B1-CLM-00035\">claim 35</claim-ref> wherein a branch prediction unit predicts at least one of the branch if not equal instruction will not be taken and the branch if equal instruction will be taken.</claim-text></claim>"}, {"num": 37, "parent": 35, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00037\" num=\"37\"><claim-text>37. The processor of <claim-ref idref=\"US-6516405-B1-CLM-00035\">claim 35</claim-ref> wherein the one of the set of operands that is stored is a predicted earliest defined operand.</claim-text></claim>"}, {"num": 38, "parent": 35, "type": "dependent", "paragraph_markup": "<claim id=\"US-6516405-B1-CLM-00038\" num=\"38\"><claim-text>38. The processor of <claim-ref idref=\"US-6516405-B1-CLM-00035\">claim 35</claim-ref> wherein the one of the set of operands of the particular one of the set of decoded instructions is replaced if that operand is the same as the one of the set of operands that is stored, and the one of the set of operands that is stored is valid.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53872173\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>I. Field of the Invention</p><p>This invention relates generally to computer technology, and more particularly, to improving processor performance in a computer system.</p><p>II. Background Information</p><p>Processors execute a series of program instructions. Some processors achieve high performance by executing multiple instructions per clock cycle. The term \u201cclock cycle\u201d refers to an interval of time accorded to various stages of an instruction processing pipeline within the processor. The term \u201cinstruction processing pipeline\u201d refers to the logic circuits employed to process instructions in a pipelined fashion. Although the pipeline may be divided into any number of stages at which portions of instruction processing are performed, instruction processing generally comprises fetching the instruction, decoding the instruction, executing the instruction, and storing the execution results in the destination identified by the instruction.</p><p>A branch instruction is an instruction which typically causes subsequent instructions to be fetched from one of at least two addresses: a sequential address identifying an instruction stream beginning with instructions which directly follow the branch instruction; and a target address identifying an instruction stream beginning at another location in memory. When it is known whether or not an instruction being processed in the pipeline will cause a branch, and to what address the instruction will cause a branch, the branch is resolved. Branch instructions typically are not resolved until after the execution stage. Waiting for the branch instruction to be resolved would starve the pipeline and severely impact performance because it is unknown which instructions to load into the pipeline until after the branch is resolved. In order to maintain optimum performance of the processor, it is necessary to predict the instruction subsequent in program order to the control-flow instruction and dispatch that instruction into the instruction processing pipeline.</p><p>A branch prediction mechanism indicates a predicted direction (taken or not-taken) for a branch instruction, allowing subsequent instruction fetching to continue within the predicted instruction stream indicated by the branch prediction. In this way, branch prediction allows program execution to be done in greater parallel. When using branch prediction, instructions from the predicted instruction stream may be placed into the instruction processing pipeline prior to execution of the branch instruction.</p><p>Branch prediction allows for greater processor performance (and thus greater computer system performance) by preventing the pipeline from being idle until the branch is resolved. That is, branch prediction allows for instructions to be fetched, decoded, and executed in the direction of a predicted instruction stream even before the branch is resolved thus preventing the processor from being idle until the branch is resolved. If the predicted instruction stream is correct, then the number of instructions executed per clock cycle is advantageously increased. However, if the predicted instruction stream is incorrect (i.e. one or more branch instructions are predicted incorrectly), then the instructions from the incorrectly predicted instruction stream are discarded from the instruction processing pipeline and the number of instructions executed per clock cycle is decreased.</p><p>Well known techniques for branch prediction exist. Some use static information, such as the direction and the distance of the branch, others use run time information which consists of prior history as to whether branches were taken or not to predict whether or not future branches will be taken.</p><p>As described earlier, branch prediction is one way to improve processor performance. Another technique for improving processor performance is data speculation. Data speculation, among other things, addresses the problem of the growing gap between main memory and processor clock speeds. As a result of this gap, computer system performance is increasingly dominated by the latency of servicing memory accesses, particularly those accesses which are not easily predicted by the temporal and spatial locality captured by conventional cache memory organizations. Temporal locality describes the likelihood that a recently-referenced address will be referenced again soon, while spatial locality describes the likelihood that a close neighbor of a recently-referenced address will be referenced soon. If data can be correctly predicted then the processor is spared the time required for memory access (i.e., access to the cache, main memory, disk drive, etc.) in order to get that data.</p><p>Current data speculation methods include load value prediction where the results of loads are predicted at dispatch by exploiting the affinity between load instruction addresses and the data the loads produce. This method takes advantage of the fact that memory loads in many programs demonstrate a significant degree of data locality.</p><p>Branch prediction gives us insights into data values so that data speculation can be efficiently performed. Further, this data speculation is \u201csafe\u201d because a branch misprediction causes the pipeline to be flushed thus discarding all the instructions involved in the incorrect data speculation. The problem with current methods of data speculation, however, is that they do not exploit the insights provided by branch prediction in order to increase processor performance.</p><p>For the foregoing reasons, data dependency collapsing based on control-flow speculation can enhance processor performance.</p><h4>SUMMARY OF THE INVENTION</h4><p>The present invention is directed to an apparatus and method for collapsing one or more operands. An embodiment of the present invention includes a post-decode unit which upon decoding an instruction that modifies its zero flag when executed, records information in a first entry about the operands for that particular instruction. Upon decoding an instruction that is either a branch if equal instruction and predicted as taken or a branch if not equal instruction and predicted as not taken, the post-decode unit copies the recorded information in the first entry to one of the second entries. The post-decode unit also translates the operands of an instruction if information is recorded about the operands in one of the second entries and that recorded information is valid.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1<i>a </i>is a block diagram illustrating the hardware involved in one embodiment of the present invention.</p><p>FIG. 1<i>b </i>is a block diagram illustrating the hardware involved in a second embodiment of the present invention.</p><p>FIG. 2 is a flowchart illustrating the general pipeline steps involved in performing safe dependency collapsing based on control-flow speculation for one embodiment of the present invention.</p><p>FIG. 3<i>a </i>is a flowchart illustrating the record keeping steps required in order to collapse data dependencies based on control-flow speculation in one embodiment of the present invention using an architectural register translation scheme.</p><p>FIG. 3<i>b </i>is a flowchart illustrating the steps required in order to actually collapse data dependencies based on control-flow speculation in one embodiment of the present invention using an architectural register translation scheme.</p><p>FIG. 3<i>c </i>is a flowchart illustrating the steps required in order to disable data dependency collapsing based on control-flow speculation in one embodiment of the present invention using an architectural register translation scheme.</p><p>FIG. 4<i>a </i>is a flowchart illustrating the record keeping steps required in order to collapse data dependencies based on control-flow speculation in a second embodiment of the present invention using a physical register reuse scheme.</p><p>FIG. 4<i>b </i>is a flowchart illustrating the steps required in order to disable data dependency collapsing based on control-flow speculation in a second embodiment of the present invention using a physical register reuse scheme.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION</h4><h4>I. Overview</h4><p>The present invention uses control-flow speculation to perform safe data dependency collapsing. Because conditional branch outcomes are resolved based on actual data values, performing control-flow speculation gives some insights into these data values. Embodiments of the present invention are shown that focus on the two cases where the conditional branch is either a branch if equal instruction and this instruction is predicted as taken (\u201cbranch if equal and predicted as taken\u201d), or branch if not equal instruction and this instruction is predicted as not taken (\u201cbranch if not equal and predicted as not taken\u201d). If a branch if equal and predicted as taken or a branch if not equal and predicted as not taken then it can be safely predicted that the two operands used to determine the branch condition are equal.</p><p>The invention is described with regards to Intel Architecture 32-bit (\u201cIA-32\u201d) instruction set in which the branch if equal instruction is implemented using the \u201cje\u201d instruction and the branch if not equal instruction is implemented using the \u201cjne\u201d instruction. As used herein, the \u201cje\u201d instruction when predicted as taken is represented as \u201cje and taken\u201d and the \u201cjne\u201d instruction when predicted as not taken is represented as \u201cjne and not taken\u201d. The invention is described with regards to the IA-32 instruction set, however, this invention is not limited to the use of that instruction set.</p><p>Control-flow speculation is defined herein as speculating or predicting the direction to which control will be transferred. Examples of control-flow speculation instructions are the conditional branch instructions. Data collapsing is defined herein as replacing an operand with a predicted value in order to potentially save having to access memory where this access causes a reduction in processor performance.</p><p>Operands, as used herein, are the objects of a computer instruction. Most instructions operate on several source operands and generate results. The operands refer to source and destination locations where values are read from or written to. Depending upon the processor architecture employed, the operand may be either a logical register or a location in memory. The operand may also be an immediate value. An immediate value, as used herein, is a data value that is contained in the instruction itself rather than pointed to by an address in the instruction. Generally, a source operand is a value operated upon by a processor in response to an instruction to produce a result. The result is stored in a destination operand specified by the instruction. Hence, a source operand has its contents read, whereas, data is written into the destination operand.</p><p>Predicting je and taken or jne and not taken is implicitly predicting relationships between the values that cause the setting of the zero flag. The prediction that the two operands are equal, can be used by data dependent instructions that follow the branch instruction. This data dependency collapsing is safe since a data misprediction means a control-flow misprediction, and whenever a control-flow misprediction occurs, the pipeline is flushed thus resulting in the removal from the pipeline of all the instructions occurring after the branch instruction, including the data mispredicted once. The following code fragment example illustrates the main principle of the invention:</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"63pt\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"112pt\"></colspec><thead><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry><entry>load eax, A</entry><entry></entry></row><row><entry></entry><entry>cmp eax, 4</entry></row><row><entry></entry><entry>jne label</entry><entry>/* branch to label if eax is not</entry></row><row><entry></entry><entry>add eax, ebx</entry><entry>equal to 4 */</entry></row><row><entry></entry><entry>\u2003.</entry></row><row><entry></entry><entry>\u2003.</entry></row><row><entry></entry><entry>\u2003.</entry></row><row><entry>label: . . . .</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>In this example the content of memory location A is loaded into the register eax and its value is compared against the immediate value <b>4</b>. If register eax is not equal to 4 then the processor jumps to \u201clabel\u201d, otherwise the processor executes the add instruction following the branch instruction. If the branch instruction is predicted as \u201cnot-taken\u201d by the branch predictor, it implies that the value of the eax register, which is used by the add instruction, is 4 even if this value has not already been loaded yet from the memory by the prior load instruction. If the prediction that register eax equals 4 is incorrect, then the add instruction would be flushed because there was a branch misprediction (i.e., the prediction that the branch would not be taken was a misprediction and this misprediction causes the pipeline to be flushed).</p><p>Two embodiments of this invention performing safe data dependency collapsing based on control-flow speculation are presented. The first embodiment performs pre-renaming work by translating architectural registers. The second embodiment performs the data dependency collapsing directly in the renaming stage. The number of architectural registers available depends on the instruction set.</p><p>This invention applies when the je instruction is predicted to be taken or the jne instruction is predicted to be not taken. In IA-32, these branch instructions are actually broken into two macro-instructions: a compare instruction followed by a conditional flow redirection instruction. In other instruction sets, however, the actions associated with both the compare and conditional flow redirection instructions are done atomically. The compare instruction, upon execution, sets various instruction flags and, in particular, sets the zero flag. The je and the jne instructions use the zero flag to determine whether or not to branch. Because this invention utilizes the je instruction (i.e., je and taken) and jne instruction (i.e., jne and not taken), it makes use of only the zero flag. If the two operands of the compare instruction are equal then the zero flag is set to one (\u201c1\u201d), but if the two operands are not equal then the zero flag is set to zero (\u201c0\u201d).</p><p>The compare operation and the setting of the zero flag, however, may be performed by other instructions which are not an explicit compare instruction. These instructions which modify the zero flag but are not explicit compare instructions will be referred to hereinafter as implicit compare instructions. These implicit compare instructions compare the destination register with zero after executing the instruction. For example, from the perspective of the zero flag, the instruction \u201cadd eax, 4\u201d is the same as the instructions \u201cadd eax, 4\u201d and \u201ccmp eax, 0\u201d. Because this invention may be practiced using either an explicit compare instruction or an implicit compare instruction, we will not differentiate between the two and will simply refer to these instructions that modify the zero flag as compare instructions.</p><p>As stated earlier, the operands of a compare instruction may be a register or an immediate value. The compare instruction may be of two types. The first type compares a register with an immediate value, e.g., cmp eax, 2. In this case the value of the register eax is compared with the immediate value <b>2</b>. The second type compares two registers, e.g., cmp eax, ebx. The present invention uses the information captured via the compare instruction and the control-flow speculation to collapse the data dependency graph by replacing an unavailable value of a source register with either an immediate value or a likely to be generated earlier register. When the compare instruction specifies two registers for the comparison, we safely predict that the values in the two registers are equal. This is helpful especially when the value for one register is generated and is thus available much earlier than the value for another register.</p><p>One method to find the register which should be replaced is to predict which of the two compare operands is the early register and which one is the late register. The register holding the value generated first is known as the early register, while the other is called the late register. Upon predicting which operand is the early register and which operand is the late register, we can translate any reference to the late register towards the early register. One way to predict the early and late registers is to set the register defined most recently (appears later in the program order) as the late register. This implementation requires a least recently used (\u201cLRU\u201d) mechanism to keep track of the order among the architectural registers. Another method for predicting the early and late registers is to employ a binary predictor to make this decision.</p><p>Knowing which register is the early register is beneficial because there is a higher probability that the early register will be \u201cdefined\u201d before the late register. The term \u201cdefined\u201d, as used in this context, means that the register (operand) contains a value which is the proper value for the instruction to use. Predicted earliest defined operand, as used herein, is the early register and predicted latest defined operand, as used herein, is the late register.</p><p>Another method to determine which register should be replaced is to determine whether any of the two register involved in the compare instruction was previously initialized by a move-immediate instruction. If one of the registers of the compare instruction was previously assigned to an immediate value by such a move instruction, then it is preferable to translate the other operand to that immediate value, even if that other operand is earlier. The latter method can be illustrated by the following example:</p><p><tables id=\"TABLE-US-00002\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"offset\" colwidth=\"77pt\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"28pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"112pt\"></colspec><thead><row><entry></entry><entry align=\"center\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry><entry>add</entry><entry>ebx, 4</entry></row><row><entry></entry><entry>move</entry><entry>eax, 2</entry></row><row><entry></entry><entry>cmp</entry><entry>eax, ebx</entry></row><row><entry></entry><entry align=\"center\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>In this example, although ebx is defined earlier (the architectural register ebx has a value written to it earlier than the architectural register eax) than eax, it is preferable to translate ebx to eax because eax contains an immediate value (in this example, eax contains the immediate value <b>2</b>).</p><h4>II. Hardware Involved in the Architectural Register Translation Scheme</h4><p>Referring to the figures in which like numerals indicate like elements, FIG. 1<i>a </i>is a block diagram illustrating the hardware required for one embodiment of the present invention using an architectural register translation scheme. The architectural register translation scheme applies to both in-order and out-of-order processors. A processor <b>10</b> shown in FIG. 1 includes an instruction cache <b>110</b>, a branch prediction unit <b>115</b>, an instruction fetch unit <b>120</b>, a decode unit <b>125</b>, a post-decode unit <b>130</b>, and an execution unit <b>135</b>.</p><p>Instruction cache <b>110</b> is a high-speed cache memory for storing instructions which are fetched from main memory. Instruction cache <b>110</b> stores commonly or recently accessed blocks of data. The cache may be structured in any suitable manner, including set associative or direct mapped structures.</p><p>Branch prediction unit <b>115</b>, in general, generates branch predictions for the branch instructions, directs the instruction fetch unit <b>120</b> to retrieve the program instructions in an order corresponding to the branch predictions, and redirects the instruction fetch unit <b>120</b> based on a branch misprediction. Branch prediction unit <b>115</b> performs a branch prediction whenever a branch instruction is fetched.</p><p>If a branch prediction was incorrect, the instructions subsequent to the mispredicted branch that have entered the instruction processing pipeline are flushed, and the correct instructions are fetched from instruction cache <b>110</b>. In such situations, results of instructions in the original program sequence which occur after the mispredicted branch instruction are discarded.</p><p>Instruction fetch unit <b>120</b> retrieves program instructions from instruction cache <b>110</b>. The program instructions may include compare, add, and branch instructions. Which program instruction is retrieved is determined by whether a control flow instruction such as a branch is involved. If the branch instruction is not involved then instructions are fetched sequentially from instruction cache <b>110</b>. However, a branch instruction (or a prediction that a branch will occur) causes instructions to be fetched in a non-sequential manner with branch prediction unit <b>115</b> providing to instruction fetch unit <b>120</b> the address (i.e., branch prediction unit provides the \u201ctarget\u201d address which is embedded in the instruction) for the next instruction to be fetched from instruction cache <b>110</b>.</p><p>Decode unit <b>125</b> decodes into microcode each instruction fetched from instruction fetch unit <b>120</b>. Decode unit <b>125</b> receives the instruction encoding value from instruction fetch unit <b>110</b>, and prepares the instruction encoding value by translating the instruction encoding value into a format which can be executed. The microcodes for instructions implementing this invention (compare, branch, and other instructions such as the add instruction which modify the zero flag, i.e., the zero bit) include for the compare instruction, the source register operands which are compared; for the branch instruction, the target address; and for the instructions that modify the zero flag, the source operands and the destination operand to which the result is stored. Once the instruction has been decoded into a usuable format, the decoded instruction is sent to post-decode unit <b>130</b>.</p><p>Post-decode unit <b>130</b> modifies the instructions and creates the necessary storage items needed to modify those instructions so that the data dependencies after a branch instruction can be collapsed. Post-decode unit <b>130</b> performs the record keeping needed for data dependency collapsing using the following two data stores: a compare operand buffer (\u201cCOB\u201d) <b>145</b> and a register translation table (\u201cRTT\u201d) <b>150</b>. COB <b>145</b> stores operand information for the most recent instruction that modified its zero flag. COB <b>145</b> has only one entry, i.e., COB <b>145</b> has operand information stored for only one instruction at a time. The entry in COB <b>145</b> has the following format:</p><p><tables id=\"TABLE-US-00003\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"offset\" colwidth=\"14pt\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"28pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"63pt\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"42pt\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"70pt\"></colspec><thead><row><entry></entry><entry align=\"center\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry><entry>Valid</entry><entry>Register Number</entry><entry>Register/</entry><entry>Immediate Value/</entry></row><row><entry></entry><entry></entry><entry></entry><entry>Immediate</entry><entry>Register Number</entry></row><row><entry></entry><entry align=\"center\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>COB <b>145</b> has the following fields:</p><p>(1) A one bit \u201cvalid\u201d field indicating whether the information in the entry is valid. The field is set to valid (\u201c1\u201d) when a new entry is inserted but is set to invalid (\u201c0\u201d) when a branch misprediction occurs, or either of the architectural registers (i.e., the architectural register number for operand #<b>1</b> or the immediate value/architectural register number for operand #<b>2</b>) is killed.</p><p>(2) A \u201cregister number\u201d field containing the architectural register identifier of the first operand.</p><p>(3) A one bit \u201creg/imm\u201d field indicating whether the second operand of the instruction modifying its zero flag is a register or an immediate value. If the second operand is a register then the bit is set to \u201c1\u201d but if the second operand is an immediate value then the bit is set to</p><p>(4) An \u201cimmediate value/register number\u201d field containing the immediate value or the architectural register identifier of the instruction's second operand.</p><p>Instruction information is inserted into RTT <b>150</b> upon encountering je and taken or jne and not taken. RTT <b>150</b> contains a subset of the information in COB <b>145</b>. RTT <b>150</b> has the following format:</p><p><tables id=\"TABLE-US-00004\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"56pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"63pt\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"98pt\"></colspec><thead><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry>Valid</entry><entry>Register/Immediate</entry><entry>Immediate Value/</entry></row><row><entry></entry><entry></entry><entry>Register Number</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>RTT <b>150</b> has the following fields:</p><p>(1) A one bit \u201cvalid\u201d field indicating whether the information for the entry in the buffer is valid. The field is set to valid (\u201c1\u201d) when a new entry is inserted but is set to invalid (\u201c0\u201d) when a branch misprediction occurs or an instruction writes to either of the architectural registers (i.e., the architectural register indexing RTT <b>150</b> or the architectural register found in RTT <b>150</b>).</p><p>(2) A one bit \u201cregister/immediate\u201d field indicating whether the entry in the \u201cimmediate value/register number\u201d field is an architectural register or an immediate value. If the entry is an architectural register then the bit is set to \u201c1\u201d but if it is an immediate value then it is set to \u201c0\u201d.</p><p>(3) An \u201cimmediate value/register number\u201d field containing an immediate value or the architectural register identifier for the early register.</p><p>The RTT format is similar to the COB format, however, one difference being that only one entry is provided for each architectural register, since register/immediate or register-late/register-early pairs may be alive at the same time for all architectural registers. As explained earlier, the number of architectural registers depends on the instruction set. For example, in the IA-32 instruction set, there are eight general purpose architectural registers and thus eight corresponding entries in RTT <b>150</b>. If a je and taken or jne and not taken is encountered and COB <b>145</b> is valid (i.e., valid field of COB <b>145</b> is set to \u201c1\u201d), then RTT <b>150</b> is modified such that operand information is copied from COB <b>145</b> to RTT <b>150</b> and the valid field for the RTT entry corresponding to the COB entry is set to \u201c1\u201d. RTT <b>150</b> is indexed either with the register number from operand one, if the second operand is an immediate value, otherwise, with the register number corresponding to the predicted late register. Because one of the operands from the COB entry is used as an index, RTT <b>150</b> needs only to store the other operand. If a RTT entry is valid, then the indexing register can be safely translated into the recorded information, i.e., either to an immediate value or to another earlier defined architectural register.</p><p>Once data dependencies in the instructions have been collapsed, those instructions are sent to the execution unit <b>135</b>. Execution unit <b>135</b> executes the instructions which are decoded by instruction decode unit <b>125</b>. Execution unit <b>135</b> can be for example, an arithmetic logic unit or the like.</p><h4>III. Hardware Involved in the Physical Register Reuse Scheme</h4><p>FIG. 1<i>b </i>is a block diagram illustrating the hardware required for one embodiment of the present invention using a register reuse scheme. The register reuse scheme applies to out-of-order processors. In this embodiment, a modified register renamer <b>140</b> performs register renaming and also data collapsing. Register renaming is a well known technique that permits parallelism by dynamic allocation of a set of registers. Renaming an architectural register may involve mapping an architectural register to a physical register. In this embodiment, these mappings may be stored in a Register Alias Table (\u201cRAT\u201d) <b>150</b>. RAT <b>150</b> maintains the latest mapping for each architectural register. RAT <b>150</b> is indexed by architectural registers, and provides mapping to corresponding physical registers.</p><p>In this embodiment, modified register renamer <b>140</b> does the register renaming and also the data collapsing as compared to the first embodiment where the data collapsing was done using post-decode unit <b>130</b>. Instead of translating the architectural registers as proposed in the first embodiment, here, the data dependency collapsing is performed by modified register renamer <b>140</b>.</p><p>Modified register renamer <b>140</b> is used to identify a group of registers that are available for the execution of a particular computing task, the identification done by using some sort of mapping scheme. In a typical register renaming scheme, register numbers appearing in instructions fetched from memory are mapped to a set of physical registers. In this particular embodiment, architectural registers are mapped to physical registers in RAT <b>150</b>. Whenever data dependency collapsing can be performed, modified register renamer <b>140</b> implements the data dependency collapsing by remapping architectural registers to physical registers which contain immediate values or earlier defined (and hopefully available) register values. In the first embodiment described in FIG. 1<i>a, </i>the renaming was performed by execution unit <b>135</b>, that is, the renamer was embedded in execution unit <b>135</b>. The technique of register renaming utilizing a renamer device is well-known in the prior art.</p><p>In this second embodiment, modified register renamer <b>140</b> uses a modified compare operand buffer (\u201cMCOB\u201d) <b>155</b> in order to perform the record keeping required to implement data collapsing using the register reuse scheme. MCOB <b>155</b> has only one entry at a time. The entry has the following format:</p><p><tables id=\"TABLE-US-00005\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"49pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"77pt\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"91pt\"></colspec><thead><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry>Valid</entry><entry>Architectural Register Id.</entry><entry>Physical Register Id.</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>MCOB <b>155</b> has the following fields:</p><p>(1) A one bit \u201cvalid\u201d field indicating whether the information for the entry in the buffer is valid. The field is set to valid (\u201c1\u201d) when a new entry is inserted but is set to invalid (\u201c0\u201d) when a branch misprediction occurs, the pointed physical register is reclaimed, or the architectural register is killed.</p><p>(2) An \u201carchitectural register id\u201d field containing the architectural register identifier of the late register.</p><p>(3) A \u201cphysical register id\u201d field containing the physical register where the immediate value or the early register is located.</p><p>If the MCOB entry is valid, then the architectural register id. can be safely translated to the physical register id.</p><h4>IV. General Steps Involved in Data Dependency Collapsing Based on Control Flow Speculation</h4><p>FIG. 2 is a flowchart illustrating the general pipeline steps involved in one embodiment of the present invention. In step <b>200</b>, instruction fetch unit <b>120</b> gets the next instruction to be processed. Instruction fetch unit <b>120</b> fetches the instruction from instruction cache <b>110</b>. If a branch prediction has been made, then branch prediction unit <b>115</b> supplies the target address from where instruction cache <b>110</b> should get the next instruction. In step <b>225</b>, decode unit <b>125</b> decodes the instruction fetched by instruction fetch unit <b>120</b>. Decoding the instruction involves converting the instruction into microcode. In step <b>230</b>, processor <b>10</b> determines if an instruction which modifies its zero flag or a je and taken or a jne and not taken have been encountered. If such an instruction has been encountered then in step <b>235</b>, processor <b>10</b> performs the record keeping required for safe data dependency collapsing based on control flow speculation. The required record keeping will be discussed in greater detail below.</p><p>In step <b>240</b>, processor <b>10</b> determines if the operands of an instruction can be collapsed. If the operands can be collapsed, then in step <b>245</b>, post-decode unit <b>130</b> or modified register renamer <b>140</b> performs the safe data dependency collapsing, i.e., appropriate operands of instructions subsequent to the branch instruction are replaced by other operands which are predicted to equal the replaced operand. This collapsing feature is especially useful when the replacing operand equals an immediate value or an earlier defined, available operand. The collapsing feature will be discussed in greater detail below.</p><p>In step <b>250</b>, processor <b>10</b> determines if the relationship required for data collapsing has been destroyed. If this relationship has been destroyed, then in step <b>255</b>, post-decode unit <b>130</b> disables the data collapsing. The disabling of data collapsing will be discussed in greater detail below. In step <b>260</b>, the instruction is executed. In step <b>265</b>, branch prediction unit <b>115</b> determines if a branch misprediction occurred. If a branch misprediction occurred then in step <b>270</b>, the pipeline is flushed meaning that the instructions subsequent to the mispredicted branch that have entered the instruction processing pipeline are removed, and the required instructions are fetched from instruction cache <b>110</b>. All entries in the RTT and COB, or the MCOB are invalidated (i.e., the valid field is set to \u201c0\u201d) in the case of any pipeline flush (e.g. mispredicted branch, context switch, etc.).</p><h4>V. Steps Involved in Data Dependency Collapsing Based on Control-Flow Speculation Using the Architectural Register Translation Scheme</h4><p>One embodiment of the present invention uses an architectural register translation scheme to perform the data collapsing. The data collapsing includes the three basic phases that are performed after the decode stage and before the execution stage. The first two phases refer to the process of performing the data prediction itself (the detection action), while the third phase refers to the potential use of this prediction (note that in architectures providing atomic compare-and-branch instructions, the first two phases are combined). This embodiment translates source architectural registers before execution. If an out-of-order processor is employed, then the translation is done before register renaming.</p><p>In the first phase, whenever a compare instruction is decoded, the information corresponding to the compare instruction is stored in COB <b>145</b>. Whenever a compare instruction is decoded, the valid field of COB <b>145</b> is set to \u201c1\u201d and the corresponding fields are updated according to the operands. As explained earlier, the compare instruction includes both explicit and implicit compare instructions. The COB entry is turned invalid whenever an instruction is decoded that writes into one of the architectural registers stored in either the \u201cregister number\u201d field or the \u201cimmediate value/register number\u201d field of COB <b>145</b>.</p><p>In the second phase, whenever a \u201cbranch if equal\u201d or a \u201cbranch if not equal\u201d instruction is decoded and the \u201cbranch if equal\u201d instruction is predicted as taken or the \u201cbranch if not equal\u201d is predicted as not taken, and the COB entry is valid, then RTT <b>150</b> is modified. RTT <b>150</b> is modified such that operand information is copied from COB <b>145</b> to RTT <b>150</b> and the valid field for the RTT entry corresponding to the COB entry is set to \u201c1\u201d. RTT <b>150</b> is indexed either with the register number from operand one, if the second operand is an immediate value, otherwise, with the register number corresponding to the predicted late register. Because one of the operands from the COB entry is used as an index, RTT <b>150</b> needs only to store the other operand. If a RTT entry is valid, then the indexing register can be safely translated into the recorded information, i.e., either to an immediate value or to another earlier defined architectural register.</p><p>RTT <b>150</b> basically describes all the possible translations (i.e., all the possible data collapsing). If an RTT entry is valid, it means that the indexing register can be safely translated into the recorded information, i.e. either to an immediate value or to another (earlier defined) architectural register. The lifetime of an RTT entry starts from the decoding of the je and taken or jne and not taken and ends (i.e., the entry is invalidated) when a decoded instruction writes into one of the operands recorded in COB <b>145</b> (i.e., the decoded instruction writes into an architectural register in either the \u201cregister number\u201d field or the \u201cimmediate value/register number\u201d field of COB <b>145</b>). Invalidation of entries is performed by setting the \u201cvalid\u201d field of that entry to 0. Details as to invalidating the COB entry or RTT entries are provided below. The whole RTT and the COB are invalidated in the case of any pipeline flush (e.g., mispredicted branch, context switch, etc.).</p><p>The third phase of this technique uses the information in RTT <b>150</b> for data dependency collapsing. Any decoded instruction performs a RTT lookup for each of its source operand. If a valid entry is found, the immediate value or the architectural register in RTT <b>150</b> replaces the corresponding source operand; this operation is termed register translation. The following example illustrates data collapsing using the architectural register translation scheme:</p><p>1. cmp eax, #2</p><p>2. je [branch predictor predicts that this branch is taken]</p><p>3. add eax, ebx</p><p>4. add ecx, eax</p><p>5. add edx, #4</p><p>6. cmp ecx, edx</p><p>7. jne [branch predictor predicts that this branch is not taken]</p><p>8. add edx, ebx</p><p>When instruction 1, the compare instruction which modifies the zero flag, is decoded, COB <b>145</b> is updated with the following information: valid=1; register number=eax; register/immediate=\u201c0\u201d; immediate value/register number=2. The decoding of instruction 2 modifies RTT 150 such that operand information is copied from the COB entry into a corresponding RTT entry. Instruction 2 causes RTT <b>150</b> to be updated with the following information: valid=1; register/immediate=\u201c0\u201d; immediate value register number=2. Because the second operand of the compare instruction contains an immediate value, the RTT entry corresponding to this instruction is indexed by the architectural register (the first operand, in this case register eax). For instruction 3, the source register eax is translated to the immediate value <b>2</b> since its corresponding entry in the RTT is valid. Instruction 3 also specifies eax as a destination register and this remains unaffected by the translation operation. However, because instruction 3 specified eax as a destination register, the valid field for the entry in COB <b>145</b> is set to \u201c0\u201d and the valid field for the RTT entry indexed by eax is also set to \u201c0\u201d. In addition, all RTT entries which have eax in its \u201cimmediate value/register number\u201d field are also set to \u201c0\u201d to indicate that the entry is no longer valid. As a result of the invalidation, instruction 4 misses in the RTT for eax. Instruction 5 misses edx as well.</p><p>Instruction 6 is a compare instruction which modifies its zero flag and thus the information corresponding to the instruction is input into COB <b>145</b>. Instruction 6 causes COB <b>145</b> to have the following information: valid=1; register number=ecx; register/immediate=\u201c1\u201d; immediate value/register number=edx. If we use the static predictor described above, edx is considered to be the late register because architectural register edx in instruction 5 is written after architectural register ecx in instruction 4. Instruction 7 is a branch if not equal instruction and is predicted as not taken. This instruction causes RTT <b>150</b> to be modified such that operand information for the COB entry is copied to an edx RTT entry. Instruction 7 causes RTT <b>150</b> to be updated with the following information: valid=1; register/immediate=\u201c1\u201d; immediate value/register number=ecx. This entry in RTT <b>150</b> is indexed with the architectural register edx. Instruction 8 translates the source edx into ecx.</p><p>RTT <b>150</b> may have more than one valid entry at any given time. For example, in the above sequence of instructions, if instruction 3 was deleted, then after instruction 7, RTT <b>150</b> would have the following two valid entries: an entry indexed by eax; and an entry indexed by edx.</p><p>FIG. 3<i>a </i>is a flowchart illustrating the record keeping steps required in order to collapse data dependencies based on control-flow speculation in one embodiment of the present invention using an architectural register translation scheme. FIG. 3<i>a </i>further elaborates on steps <b>230</b> and <b>235</b> of FIG. <b>2</b>. In step <b>300</b>, post-decode unit <b>130</b> determines if an instruction which modifies the zero flag has been decoded. In IA-32, such instructions include the compare and the add instructions. If the decoded instruction does not modify the zero flag, then record keeping is not performed and thus COB <b>145</b> and RTT <b>150</b> are not modified. However, if an instruction which modifies the zero flag is decoded, then in step <b>303</b>, the valid field in COB <b>145</b> is set to valid (\u201c1\u201d) to indicate that the entry is valid. In step <b>306</b>, the first operand of the instruction which modifies the zero flag is copied into the register number field of COB <b>145</b>. In step <b>309</b>, post-decode unit <b>130</b> determines if the second operand of the instruction is an immediate value. If the second operand is an immediate value, then in step <b>312</b>, the register/immediate field of COB <b>145</b> is set to zero (\u201c0\u201d) to indicate that the second operand is an immediate value. In step <b>315</b>, the immediate value of the second operand is copied into the immediate value/register number field of COB <b>145</b>. If the second operand is not an immediate value, but rather a register number then in step <b>318</b>, the register/immediate field of COB <b>145</b> is set to one (\u201c1\u201d) to indicate that the second operand is a register. In step <b>321</b>, the register number of the second operand is copied into the immediate value/register number field of COB <b>145</b>.</p><p>In step <b>324</b>, post-decode unit <b>130</b> determines if the instruction decoded is a conditional branch instruction. If a conditional branch instruction has been decoded, then in step <b>327</b>, post-decode unit <b>130</b> determines if the instruction decoded is a je and predicted as taken or a jne and predicted as not taken.</p><p>If the decoded instruction is either je and taken or jne and not taken, then in step <b>330</b>, post-decode unit <b>130</b> determines if the entry in COB <b>145</b> is valid (i.e., the valid field is set to \u201c1\u201d). If the entry is not valid (i.e., the valid field is set to \u201c0\u201d), then the entry is not moved to RTT <b>150</b>. If the decoded instruction is either a je and taken or jne and not taken and the COB entry is valid, then RTT <b>150</b> is modified such that an entry in RTT <b>150</b> corresponds to the entry in COB <b>145</b>.</p><p>In step <b>333</b>, post-decode unit <b>130</b> determines if the second operand is an immediate value. If the second operand is an immediate value then in step <b>336</b>, RTT <b>150</b> is indexed using the first operand of the instruction whose zero flag was modified (i.e., the instruction having the entry in COB <b>145</b>). In step <b>339</b>, the second operand (which is an immediate value) of the instruction whose zero flag was modified is copied from COB <b>145</b> to the \u201cimmediate value/register number\u201d field of RTT <b>150</b>. In step <b>357</b>, the \u201cregister/immediate\u201d field of RTT <b>150</b> is set to zero to indicate that an immediate value is in the \u201cimmediate value/register number\u201d field of RTT <b>150</b>. In step <b>360</b>, the \u201cvalid\u201d field is set to \u201c1\u201d to indicate that the RTT entry corresponding to the COB entry is valid.</p><p>If the second operand of the instruction whose zero flag is modified (i.e., the instruction having the entry in COB <b>145</b>) is a register rather than an immediate value then in step <b>342</b>, the early operand and the late operand are found by using any of the techniques previously described. In step <b>345</b>, RTT <b>150</b> is indexed using the late operand of the instruction whose zero flag was modified. In step <b>348</b>, the early operand is copied from COB <b>145</b> to the \u201cimmediate value/register number\u201d field of RTT <b>150</b>. In step <b>351</b>, the register/immediate field of RTT <b>150</b> is set to \u201c1\u201d to indicate that a register is in the immediate value/register number field of RTT <b>150</b>. In step <b>354</b>, the valid field is set to \u201c1\u201d to indicate that the entry is valid.</p><p>FIG. 3<i>b </i>is a flowchart illustrating the steps required in order to actually collapse data dependencies based on control-flow speculation in one embodiment of the present invention using an architectural register translation scheme. FIG. 3<i>b </i>further elaborates on steps <b>240</b> and <b>245</b> of FIG. <b>2</b>. In step <b>366</b>, post-decode unit <b>130</b> determines if any of the source operands of the decoded instruction is indexing RTT <b>150</b>. A source operand is an operand whose value is read but not written as opposed to a destination operand which is written. If none of the source operands are indexing RTT <b>150</b> then no data collapsing is performed for that decoded instruction.</p><p>If one or more of the source operands for the decoded instruction indexes RTT <b>150</b>, then for each of those source operands, steps <b>368</b> to <b>378</b> are performed. In step <b>368</b>, post-decode unit <b>130</b> determines if the RTT entry indexed by one of the source operands is valid. The check for validity is done by making sure that the entry that the particular one of the source operands indexes has its valid field set to \u201c1\u201d. If the RTT entry is not valid then data collapsing for that decoded instruction is not performed. If the RTT entry is valid, then in step <b>370</b>, post-decode unit <b>130</b> determines if the register/immediate field in RTT <b>150</b> corresponding to the source operand is set to \u201c1\u201d. If the register/immediate field is set to \u201c1\u201d then the value in the immediate value/register number field is an architectural register and in step <b>374</b>, the source operand for the decoded instruction is replaced with the architectural register found in the immediate value/register number field of RTT <b>150</b>. If the register/immediate field is set to \u201c0\u201d then the value in the immediate value/register number field is an immediate value and in step <b>372</b>, the source operand for the decoded instruction is replaced with the immediate value found in the immediate value/register number field of RTT <b>150</b>. In step <b>376</b>, post-decode unit <b>130</b> determines if any other source operands are indexing RTT <b>150</b>. If no other source operands are indexing RTT <b>150</b>, then data collapsing for the decoded instruction is complete. However, if other source operands are also indexing RTT <b>150</b>, then in step <b>378</b>, the next source operand is obtained and steps <b>368</b> to <b>374</b> are repeated for this source operand to possible collapse it.</p><p>FIG. 3<i>c </i>is a flowchart illustrating the steps required in order to disable data dependency collapsing based on control-flow speculation in one embodiment of the present invention using an architectural register translation scheme. FIG. 3<i>c </i>further elaborates on steps <b>250</b> and <b>255</b> of FIG. <b>2</b>. In step <b>380</b>, post-decode unit <b>130</b> determines if any of the decoded instructions write to one of its operands. If the decoded instruction does not write to any of its operands, then neither the entry in COB <b>145</b> nor the entries in RTT <b>150</b> are invalidated.</p><p>If the decoded instruction has a destination register, then in step <b>382</b>, post-decode unit <b>130</b> determines if this destination is found in the register number field or the immediate value/register number field of COB <b>145</b>. If the decoded instruction does write to operands found in either of those two fields of COB <b>145</b> then in step <b>384</b>, the valid field in COB <b>145</b> is set to indicate that the entry is invalid (i.e., the valid field is set to \u201c0\u201d). In step <b>390</b>, post-decode unit <b>130</b> determines if the written operand indexes any of the entries in RTT <b>150</b>. If RTT <b>150</b> indexes any of the entries in RTT <b>150</b>, then in step <b>392</b>, the valid field in RTT <b>150</b> of the entry indexed is set to indicate that the entry is invalid (i.e., the valid field is set to \u201c0\u201d). In step <b>394</b>, post-decode unit <b>130</b> determines if any of the operands in the immediate value/register number field of RTT <b>150</b> equals the written operand. If any of the operands in the immediate value/register number field of RTT <b>150</b> equals the written operand, then in step <b>388</b>, the valid fields of the corresponding RTT entries are set to indicate that they are invalid (i.e., the valid fields are set to \u201c0\u201d).</p><p>If the decoded instruction does not write to operands found in either the register number field or the immediate value register number field of COB <b>145</b>, then the entry in COB <b>145</b> is not invalidated. In step <b>390</b>, post-decode unit <b>130</b> determines if the written operand indexes any of the entries in RTT <b>150</b>. If RTT <b>150</b> indexes any of the entries in RTT <b>150</b>, then in step <b>392</b>, the valid field in RTT <b>150</b> of the entry indexed is set to indicate that the entry is invalid (i.e., the valid field is set to \u201c0\u201d). In step <b>394</b>, post-decode unit <b>130</b> determines if any of the operands in the immediate value/register number field of RTT <b>150</b> equals the written operand. If any of the operands in the immediate value/register number field of RTT <b>150</b> equals the written operand, then in step <b>388</b>, the valid fields of the corresponding RTT entries are set to indicate that they are invalid (i.e., the valid fields are set to \u201c0\u201d).</p><p>If the written operand does not index any of the entries in RTT <b>150</b>, then in step <b>394</b>, post-decode unit <b>130</b> determines if any of the operands in the immediate value/register number field of RTT <b>150</b> equals the written operand. If any of the operands in the immediate value/register number field of RTT <b>150</b> equals the written operand, then in step <b>388</b>, the valid fields of the corresponding RTT entries are set to indicate that they are invalid (i.e., the valid fields are set to \u201c0\u201d).</p><h4>VI. Steps Involved in Data Dependency Collapsing Based on Control-Flow Speculation Using the Physical Register Reuse Scheme</h4><p>The second embodiment uses the physical register reuse scheme in order to perform the data collapsing. In a physical register reuse scheme, the main idea is to record several results into only one physical register whenever all these results are identical. The physical register reuse scheme complies with the concept of this invention that the two operands of a compare instruction are equal and thus the two registers hold the same value. Instead of translating the architectural registers as in the previous embodiment, the data collapsing is performed in modified register renamer <b>140</b>. In this embodiment, modified register renamer <b>140</b> re-maps the late register to the physical register associated with the early register or to a physical register associated with an immediate value. This embodiment requires MCOB <b>155</b> but not COB <b>145</b> or RTT <b>150</b>. The following example illustrates this embodiment (assume that architectural register eax is the late register and that architectural registers eax and ecx are mapped to memory locations pr<b>23</b> and pr<b>19</b> respectively):</p><p>1. cmp eax, ecx</p><p>2. je [branch predictor predicts that this branch is taken]</p><p>3. add eax, ebx</p><p>Upon decoding the compare instruction (instruction one), the following information corresponding to that instruction is inserted into MCOB <b>155</b>: (1) the valid field is set to \u201c1\u201d; (2) the late register eax is inserted into the \u201carchitectural register id.\u201d field; and (3) the physical address for the early register ecx is inserted into the \u201cphysical register id.\u201d field. That is, after decoding instruction one, MCOB <b>155</b> is updated with the following entry: valid=\u201c1\u201d; architectural register id.=eax; physical register id.=pr<b>19</b>. The branch instruction of instruction 2 is predicted as taken by branch prediction unit <b>115</b>. Because the MCOB entry is valid, modified register renamer <b>140</b> re-maps the late architectural register eax to the physical register associated with the early register. In this example, eax is re-mapped to pr<b>19</b>. As a result, instruction 3 is no longer dependent on eax but on ecx.</p><p>In order to handle compare-with-immediate instructions, a physical register must be located containing the same immediate value. In order to find a physical register containing the same immediate value, modified register renamer <b>140</b> can perform a lookup into the register file or a value-matching cache. In one embodiment using a register file (i.e., a plurality of registers organized into a \u201cregister file\u201d), the register file is searched for the immediate value. If the immediate value is not found in the register file, then MCOB <b>155</b> is not updated with the instruction's entry, however, if the immediate value is found in the register file, then MCOB <b>155</b> is updated with the instruction's entry.</p><p>In another embodiment using a value-matching cache, the entries in that cache are indexed by immediate values, where a cache entry associates an immediate value with a physical register storing that value. If there is a match between the immediate value and the value in the cache, then the architectural register of the compare instruction is mapped to the physical register indicated by the value-matching cache. If the immediate value of a compare instruction is not found in the value-matching cache, then MCOB <b>155</b> is not updated with the instruction's entry.</p><p>FIG. 4<i>a </i>is a flowchart illustrating the record keeping steps required in order to collapse data dependencies based on control-flow speculation in a second embodiment of the present invention using a physical register reuse scheme. FIG. 4<i>a </i>further elaborates on steps <b>230</b> and <b>235</b> of FIG. <b>2</b>. In step <b>400</b>, post-decode unit <b>130</b> determines whether an instruction which modifies the zero flag has been decoded. If the decoded instruction does not modify the zero flag, then record keeping need not be performed and thus MCOB <b>155</b> is not modified. However, if an instruction which modifies the zero flag is decoded, then in step <b>403</b>, the decoded instruction's early operand and late operand are found by using any of the techniques previously described. In step <b>406</b>, modified register renamer <b>140</b> inserts the architectural register of the late operand into the architectural register id field of MCOB <b>155</b>. In step <b>409</b>, modified register renamer <b>140</b> inserts the physical address of the early operand or an immediate value into the \u201cphysical register id\u201d field of MCOB <b>155</b>. The physical register for an immediate value can be found by either of the techniques described earlier. In step <b>412</b>, modified register renamer <b>140</b> sets the valid field in MCOB <b>155</b> to \u201c1\u201d to indicate that the entry is valid.</p><p>In step <b>415</b>, modified register renamer <b>140</b> determines if a conditional branch instruction has been decoded. If a conditional branch instruction has been decoded then in step <b>418</b>, modified register renamer <b>140</b> determines if the conditional branch instruction is a branch if equal instruction which is predicted as taken or a branch if not equal instruction which is predicted as not taken. In step <b>421</b>, modified register renamer <b>140</b> checks the entry in MCOB <b>155</b> to ensure that it is valid (i.e., the valid field is set to \u201c1\u201d). If the entry in MCOB <b>155</b> is valid then in step <b>423</b>, modified register renamer <b>140</b> re-maps the late architectural register found in the architectural register id. field of MCOB <b>155</b> to the physical register found in the physical register id. field which is associated with either the early register or the immediate value.</p><p>FIG. 4<i>b </i>is a flowchart illustrating the steps required in order to disable data dependency collapsing based on control-flow speculation in the second embodiment of the present invention using a physical register reuse scheme. FIG. 4<i>b </i>further elaborates on steps <b>250</b> and <b>255</b> of FIG. <b>2</b>. In step <b>483</b>, modified register renamer <b>140</b> determines if the decoded instruction writes to an operand. If the decoded instruction does not write to any of its operands, then the entry in MCOB <b>155</b> remains valid. If the decoded instruction writes to one of its operands then in step <b>486</b>, modified register renamer <b>140</b> determines if the operand which is written into by the decoded instruction is found in the architectural register id. field of MCOB <b>155</b>. If the decoded instruction does not write to this field, then the entry in MCOB <b>155</b> remains valid. If the decoded instruction does write to this field, then in step <b>489</b>, the valid field in MCOB <b>155</b> is set to indicate that the entry is no longer valid (i.e., the valid field is set to \u201c0\u201d).</p><p>Although embodiments are specifically illustrated and described herein, it will be appreciated that modifications and variations of the present invention are covered by the above teachings and within the purview of the appended claims without departing from the spirit and intended scope of the invention.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Stephan J.", "last_name": "Jourdan", "name": ""}, {"first_name": "Freddy", "last_name": "Gabbay", "name": ""}, {"first_name": "Ronny", "last_name": "Ronen", "name": ""}, {"first_name": "Adi", "last_name": "Yoaz", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTEL CORPORATION"}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/45"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/38        20060101A I20051008RMEP"}, {"label": "G06F   9/32        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712216"}, {"primary": false, "label": "712E09079"}, {"primary": false, "label": "712E09047"}, {"primary": false, "label": "712E0905"}, {"primary": false, "label": "712226"}, {"primary": false, "label": "712E09061"}], "ecla_classes": [{"label": "G06F   9/38E1R"}, {"label": "G06F   9/30B"}, {"label": "G06F   9/38E2"}, {"label": "G06F   9/38D2"}, {"label": "G06F   9/38H2"}], "cpc_classes": [{"label": "G06F   9/30181"}, {"label": "G06F   9/384"}, {"label": "G06F   9/3863"}, {"label": "G06F   9/3842"}, {"label": "G06F   9/383"}, {"label": "G06F   9/3832"}, {"label": "G06F   9/30094"}, {"label": "G06F   9/384"}, {"label": "G06F   9/3863"}, {"label": "G06F   9/3832"}, {"label": "G06F   9/30094"}, {"label": "G06F   9/3842"}, {"label": "G06F   9/383"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1999-12-30", "application_date": "1999-12-30", "family_members": [{"ucid": "US-6516405-B1", "titles": [{"lang": "EN", "text": "Method and system for safe data dependency collapsing based on control-flow speculation"}]}, {"ucid": "US-20030154362-A1", "titles": [{"lang": "EN", "text": "Method and system for safe data dependency collapsing based on control-flow speculation"}]}, {"ucid": "US-7284116-B2", "titles": [{"lang": "EN", "text": "Method and system for safe data dependency collapsing based on control-flow speculation"}]}]}