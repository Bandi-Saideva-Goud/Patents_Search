{"patent_number": "US-6539457-B1", "publication_id": 73355475, "family_id": 24030090, "publication_date": "2003-03-25", "titles": [{"lang": "EN", "text": "Cache address conflict mechanism without store buffers"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11492727\" source=\"national office\"><p>The inventive cache manages address conflicts and maintains program order without using a store buffer. The cache utilizes an issue algorithm to insure that accesses issued in the same clock are actually issued in an order that is consistent with program order. This is enabled by performing address comparisons prior to insertion of the accesses into the queue. Additionally, when accesses are separated by one or more clocks, address comparisons are performed, and accesses that would get data from the cache memory array before a prior update has actually updated the cache memory in the array are canceled. This provides a guarantee that program order is maintained, as an access is not allowed to complete until it is assured that the most recent data will be received upon access of the array.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50467379\"><p>The inventive cache manages address conflicts and maintains program order without using a store buffer. The cache utilizes an issue algorithm to insure that accesses issued in the same clock are actually issued in an order that is consistent with program order. This is enabled by performing address comparisons prior to insertion of the accesses into the queue. Additionally, when accesses are separated by one or more clocks, address comparisons are performed, and accesses that would get data from the cache memory array before a prior update has actually updated the cache memory in the array are canceled. This provides a guarantee that program order is maintained, as an access is not allowed to complete until it is assured that the most recent data will be received upon access of the array.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00001\" num=\"1\"><claim-text>1. A computer system comprising:</claim-text><claim-text>a processor that executes instructions; and </claim-text><claim-text>a multi-level cache structure accessible by said processor to satisfy memory access requests, wherein said multi-level cache structure is configured to receive multiple memory access requests and to process the multiple requests in parallel to determine whether one of said multiple levels is capable of satisfying the multiple received memory access requests; </claim-text><claim-text>wherein one level of the multi-level cache structure comprises: </claim-text><claim-text>a queue for holding entries of address information for data accesses; </claim-text><claim-text>conflict logic for checking each access request with the entries of the queue for conflicts prior to insertion of each access request into the queue, for inserting an access with a conflict into the queue, and for inserting information describing the conflict into the queue; and </claim-text><claim-text>issue logic for determining which entries to issue from the queue based on the results of the conflict logic. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00002\" num=\"2\"><claim-text>2. The system of <claim-ref idref=\"US-6539457-B1-CLM-00001\">claim 1</claim-ref> wherein one level of the multi-level cache structure comprises a memory array for storing data that is arranged in a plurality of banks;</claim-text><claim-text>wherein the conflict logic is bank conflict logic for checking each access request with the entries of the queue for bank conflicts prior to insertion of each access request into the queue, wherein a bank conflict arises when an access request is to the same memory bank as an entry, wherein the access inserted into the queue comprises an access with a bank conflict and wherein the information inserted into the queue comprises information describing the bank conflict; and </claim-text><claim-text>wherein the issue logic issues the access and conflicting entry from the queue at different cycles based on the information describing the conflict. </claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00003\" num=\"3\"><claim-text>3. The system of <claim-ref idref=\"US-6539457-B1-CLM-00002\">claim 2</claim-ref> wherein:</claim-text><claim-text>the information describing the conflict is associated with the conflicting entry in the queue. </claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00004\" num=\"4\"><claim-text>4. The system of <claim-ref idref=\"US-6539457-B1-CLM-00001\">claim 1</claim-ref> wherein:</claim-text><claim-text>the conflict logic is address conflict logic for checking each access request with the entries of the queue for address conflicts prior to insertion of each access request into the queue, wherein an address conflict arises when an access request involves the same memory location as an entry, wherein the access inserted into the queue comprises an access with an address conflict, and wherein the information inserted into the queue comprises information describing the conflict; and </claim-text><claim-text>the issue logic issues the access and conflicting entry from the queue at different cycles based on the information describing the conflict. </claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00005\" num=\"5\"><claim-text>5. The system of <claim-ref idref=\"US-6539457-B1-CLM-00004\">claim 4</claim-ref> wherein:</claim-text><claim-text>the information describing the conflict is associated with the access in the queue. </claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00006\" num=\"6\"><claim-text>6. The system of <claim-ref idref=\"US-6539457-B1-CLM-00001\">claim 1</claim-ref> wherein the multi-level cache structure processes the accesses in a plurality of pipeline stages, the accesses comprise at least one load access and one store access, and the load access is operative on the multi-level cache structure in an earlier stage than the store access, and the multi-level cache structure further comprises:</claim-text><claim-text>load conflict logic for checking for load conflicts between an earlier issued store access and a later issued load access, wherein a load conflict arises when the earlier issued store access and the later issued load access involve the same memory location, and the pipeline stage of the later issued load access is located proximate to the pipeline stage of the earlier issued store access such that the later load access would be operative on the multi-level cache structure prior to the earlier store access; and </claim-text><claim-text>cancellation logic for canceling the later issued load access if the load conflict logic determines a load conflict for the load access. </claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00007\" num=\"7\"><claim-text>7. The system of <claim-ref idref=\"US-6539457-B1-CLM-00006\">claim 6</claim-ref> wherein the load conflict logic comprises:</claim-text><claim-text>logic for determining whether a load access that has a load conflict is within one clock cycle of not having a load conflict; and </claim-text><claim-text>delay logic for delaying a load access for one clock cycle that is within one clock cycle of not having a load conflict. </claim-text></claim>"}, {"num": 8, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00008\" num=\"8\"><claim-text>8. The system of <claim-ref idref=\"US-6539457-B1-CLM-00006\">claim 6</claim-ref> wherein the multi-level cache structure further comprises:</claim-text><claim-text>store conflict logic for checking for store conflicts between an earlier issued access and a later issued store access, wherein a store conflict arises when the earlier issued access and the later issued store access involve the same memory location, and the earlier issued access has been canceled such that the later store access would be operative on the multi-level cache structure prior to the earlier canceled access; and </claim-text><claim-text>cancellation logic for canceling the later issued store access if the store conflict logic determines a store conflict. </claim-text></claim>"}, {"num": 9, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00009\" num=\"9\"><claim-text>9. A method of accessing a multi-level cache of a computer system, the method comprising:</claim-text><claim-text>receiving multiple memory access requests into a multi-level cache structure; </claim-text><claim-text>processing the multiple requests in parallel to determine whether one of said multiple levels is capable of satisfying the multiple received memory access requests, and </claim-text><claim-text>if determined that at least one of the memory access requests can be satisfied by a level of the multi-level cache structure, then satisfying the one memory access request by the level of the multi-level cache structure; </claim-text><claim-text>holding address information for accesses in a queue; </claim-text><claim-text>checking each access request with the entries of the queue for conflicts prior to insertion of each access request into the queue; </claim-text><claim-text>inserting an access with a conflict into the queue; </claim-text><claim-text>inserting information describing the conflict into the queue; and </claim-text><claim-text>determining which entries to issue from the queue based on the results of the conflict logic. </claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00010\" num=\"10\"><claim-text>10. The method of <claim-ref idref=\"US-6539457-B1-CLM-00009\">claim 9</claim-ref> wherein one level of the multi-level cache structure includes a memory array for storing data that is arranged in a plurality of banks;</claim-text><claim-text>wherein the step of checking comprises checking each access request with the entries of the queue for bank conflicts prior to insertion of each access request into the queue, </claim-text><claim-text>wherein a bank conflict arises when an access request is to the same memory bank as an entry; </claim-text><claim-text>wherein the step of inserting an access comprises inserting a bank conflict into the queue; </claim-text><claim-text>wherein the step of inserting information comprises inserting information describing the bank conflict into the queue; and </claim-text><claim-text>wherein the method further comprises issuing the access and conflicting entry from the queue at different cycles based on the information describing the conflict. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00011\" num=\"11\"><claim-text>11. The method of <claim-ref idref=\"US-6539457-B1-CLM-00010\">claim 10</claim-ref> wherein the step of inserting information comprises the step of:</claim-text><claim-text>associating the information describing the conflict with the conflicting entry in the queue. </claim-text></claim>"}, {"num": 12, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00012\" num=\"12\"><claim-text>12. The method of <claim-ref idref=\"US-6539457-B1-CLM-00009\">claim 9</claim-ref> wherein the step of checking comprises checking each access request with the entries of the queue for address conflicts prior to insertion of each access request into the queue, wherein an address conflict arises when an access request involves the same memory location as an entry;</claim-text><claim-text>wherein the step of inserting comprises inserting an access with an address conflict into the queue; </claim-text><claim-text>wherein the step of inserting information comprises inserting information describing the address conflict into the queue; and </claim-text><claim-text>wherein the method further comprises issuing the access and conflicting entry from the queue at different cycles based on the information describing the conflict. </claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00013\" num=\"13\"><claim-text>13. The method of <claim-ref idref=\"US-6539457-B1-CLM-00012\">claim 12</claim-ref> wherein the step of inserting information comprises the step of:</claim-text><claim-text>associating the information describing the conflict with the access in the queue. </claim-text></claim>"}, {"num": 14, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00014\" num=\"14\"><claim-text>14. The method of <claim-ref idref=\"US-6539457-B1-CLM-00009\">claim 9</claim-ref> wherein the multi-level cache structure processes the accesses in a plurality of pipeline stages, the accesses comprise at least one load access and one store access, and the load access is operative on the multi-level cache structure in an earlier stage than the store access, and the method further comprises the steps of:</claim-text><claim-text>checking for load conflicts between an earlier issued store access and a later issued load access, wherein a load conflict arises when the earlier issued store access and the later issued load access involve the same memory location, and the pipeline stage of the later issued load access is located proximate to the pipeline stage of the earlier issued store access such that the later load access would be operative on the multi-level cache structure prior to the earlier store access; and </claim-text><claim-text>canceling the later issued load access if the step of checking for load conflicts determines a load conflict for the load access. </claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00015\" num=\"15\"><claim-text>15. The method of <claim-ref idref=\"US-6539457-B1-CLM-00014\">claim 14</claim-ref> wherein the step of checking for load conflicts comprises the steps of:</claim-text><claim-text>determining whether a load access that has a load conflict is within one clock cycle of not having a load conflict; and </claim-text><claim-text>delaying a load access for one clock cycle that is within one clock cycle of not having a load conflict. </claim-text></claim>"}, {"num": 16, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00016\" num=\"16\"><claim-text>16. The method of <claim-ref idref=\"US-6539457-B1-CLM-00014\">claim 14</claim-ref> further comprising the steps of:</claim-text><claim-text>checking for store conflicts between an earlier issued access and a later issued store access, wherein a store conflict arises when the earlier issued access and the later issued store access involve the same memory location, and the earlier issued access has been canceled such that the later store access would be operative on the multi-level cache structure prior to the earlier canceled access; and </claim-text><claim-text>canceling the later issued store access if the store conflict logic determines a store conflict. </claim-text></claim>"}, {"num": 17, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00017\" num=\"17\"><claim-text>17. A computer system comprising:</claim-text><claim-text>a processor that executes instructions; </claim-text><claim-text>means for receiving multiple memory access requests into a multi-level cache structure; </claim-text><claim-text>means for processing the multiple requests in parallel to determine whether one of said multiple levels is capable of satisfying the multiple received memory access requests, and if determined that at least one of the memory access requests can be satisfied by a level of the multi-level cache structure, then satisfying the one memory access request by the level of the multi-level cache structure; </claim-text><claim-text>a queue for holding address information for accesses; </claim-text><claim-text>means for checking each access request with the entries of the queue for conflicts prior to insertion of each access request into the queue, said means for checking comprising </claim-text><claim-text>means for inserting an access with a conflict into the queue; </claim-text><claim-text>means for inserting information describing the conflict into the queue and associating the information describing the conflict with the access in the queue; and </claim-text><claim-text>means for determining which entries to issue from the queue based on the results of the conflict logic. </claim-text></claim>"}, {"num": 18, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00018\" num=\"18\"><claim-text>18. The system of <claim-ref idref=\"US-6539457-B1-CLM-00017\">claim 17</claim-ref> wherein one level of the multi-level cache structure includes a memory array for storing data that is arranged in a plurality of banks;</claim-text><claim-text>wherein the means for checking comprises means for checking each access request with the entries of the queue for bank conflicts prior to insertion of each access request into the queue, wherein a bank conflict arises when an access request is to the same memory bank as an entry, wherein the access inserted into the queue comprises an access with a bank conflict, and wherein the information inserted into the queue and associated with the conflicting entry comprises information describing the bank conflict; and </claim-text><claim-text>wherein the system further comprises means for issuing the access and conflicting entry from the queue at different cycles based on the information describing the conflict. </claim-text></claim>"}, {"num": 19, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00019\" num=\"19\"><claim-text>19. The system of <claim-ref idref=\"US-6539457-B1-CLM-00017\">claim 17</claim-ref> wherein the means for checking comprises means for checking each access request with the entries of the queue for address conflicts prior to insertion of each access request into the queue, wherein an address conflict arises when an access request involves the same memory location as an entry, wherein the access inserted into the queue comprises an access with an address conflict, and wherein the information inserted into the queue and associated with the access comprises information describing the address conflict; and</claim-text><claim-text>wherein the system further comprises means for issuing the access and conflicting entry from the queue at different cycles based on the information describing the conflict. </claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00020\" num=\"20\"><claim-text>20. The system of <claim-ref idref=\"US-6539457-B1-CLM-00019\">claim 19</claim-ref> wherein the multi-level cache structure processes the accesses in a plurality of pipeline stages, the accesses comprise at least one load access and one store access, and the load access is operative on the multi-level cache structure in an earlier stage than the store access, and the system further comprises:</claim-text><claim-text>means for checking for load conflicts between an earlier issued store access and a later issued load access, wherein a load conflict arises when the earlier issued store access and the later issued load access involve the same memory location, and the pipeline stage of the later issued load access is located proximate to the pipeline stage of the earlier issued store access such that the later load access would be operative on the multi-level cache structure prior to the earlier store access; </claim-text><claim-text>means for canceling the later issued load access if the step of checking for load conflicts determines a load conflict for the load access; </claim-text><claim-text>means for checking for store conflicts between an earlier issued access and a later issued store access, wherein a store conflict arises when the earlier issued access and the later issued store access involve the same memory location, and the earlier issued access has been canceled such that the later store access would be operative on the multi-level cache structure prior to the earlier canceled access; and </claim-text><claim-text>means for canceling the later issued store access if the store conflict logic determines a store conflict. </claim-text></claim>"}, {"num": 21, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00021\" num=\"21\"><claim-text>21. The method of <claim-ref idref=\"US-6539457-B1-CLM-00010\">claim 10</claim-ref> wherein said one level of the multi-level cache structure including said memory array that is arranged in said plurality of banks is said level of the multi-cache structure determined to be able to satisfy said at least one of the memory access requests.</claim-text></claim>"}, {"num": 22, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539457-B1-CLM-00022\" num=\"22\"><claim-text>22. The system of <claim-ref idref=\"US-6539457-B1-CLM-00018\">claim 18</claim-ref> wherein said one level of the multi-level cache structure that includes said memory array that is arranged in said plurality of banks is said level of the multi-cache structure determined to be able to satisfy said at least one of the memory action requests.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53896269\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><h4>RELATED APPLICATIONS</h4><p>This application is related to co-pending and commonly assigned patent application Ser. No. 09/501,396 entitled \u201cMETHOD AND SYSTEM FOR EARLY TAG ACCESSES FOR LOWER-LEVEL CACHES IN PARALLEL WITH FIRST-LEVEL CACHE,\u201d co-pending and commonly assigned patent application Ser. No. 09/510,283 entitled CACHE CHAIN STRUCTURE TO IMPLEMENT HIGH BANDWIDTH LOW LATENCY CACHE MEMORY SUBSYSTEM,\u201d co-pending and commonly assigned U.S. patent application Ser. No. 09/510,973 entitled \u201cMULTIPLE ISSUE ALGORITHM WITH OVERSUBSCRIPTION AVOIDANCE FEATURES TO GET HIGH BANDWIDTH THROUGH CACHE PIPELINE,\u201d co-pending and commonly assigned U.S. patent application Ser. No. 09/510,285 entitled \u201cL1 CACHE MEMORY,\u201d and co-pending and commonly assigned U.S. patent application Ser. No. 09/507,333 entitled \u201cMULTI-PORTED REGISTER STRUCTURES WITH A PULSE WRITE MECHANISM,\u201d the disclosures of which are hereby incorporated herein by reference.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>TECHNICAL FIELD</h4><p>This invention relates in general to computer systems, and in specific to an arrangement for a cache memory system.</p><h4>BACKGROUND</h4><p>Computer systems may employ a multi-level hierarchy of memory, with relatively fast, expensive but limited-capacity memory at the highest level of the hierarchy and proceeding to relatively slower, lower cost but higher-capacity memory at the lowest level of the hierarchy. The hierarchy may include a small fast memory called a cache, either physically integrated within a processor or mounted physically close to the processor for speed. The computer system may employ separate instruction caches and data caches. In addition, the computer system may use multiple levels of caches. The use of a cache is generally transparent to a computer program at the instruction level and can thus be added to a computer architecture without changing the instruction set or requiring modification to existing programs.</p><p>Computer processors typically include cache for storing data. When executing an instruction that requires access to memory (e.g., read from or write to memory), a processor typically accesses cache in an attempt to satisfy the instruction. Of course, it is desirable to have the cache implemented in a manner that allows the processor to access the cache in an efficient manner. That is, it is desirable to have the cache implemented in a manner such that the processor is capable of accessing the cache (i.e., reading from or writing to the cache) quickly so that the processor may be capable of executing instructions quickly. Caches have been configured in both on chip and off-chip arrangements. On-processor-chip caches have less latency, since they are closer to the processor, but since on-chip area is expensive, such caches are typically smaller than off-chip caches. Off-processor-chip caches have longer latencies since they are remotely located from the processor, but such caches are typically larger than on-chip caches.</p><p>A prior art solution has been to have multiple caches, some small and some large. Typically, the smaller caches would be located on-chip, and the larger caches would be located off-chip. Typically, in multi-level cache designs, the first level of cache (i.e., LO) is first accessed to determine whether a true cache hit for a memory access request is achieved. If a true cache hit is not achieved for the first level of cache, then a determination is made for the second level of cache (i.e., L<b>1</b>), and so on, until the memory access request is satisfied by a level of cache. If the requested address is not found in any of the cache levels, the processor then sends a request to the system's main memory in an attempt to satisfy the request. In many processor designs, the time required to access an item for a true cache hit is one of the primary limiters for the clock rate of the processor if the designer is seeking a single-cycle cache access time. In other designs, the cache access time may be multiple cycles, but the performance of a processor can be improved in most cases when the cache access time in cycles is reduced. Therefore, optimization of access time for cache hits is critical for the performance of the computer system.</p><p>Prior art cache designs for computer processors typically require \u201ccontrol data\u201d or tags to be available before a cache data access begins. The tags indicates whether a desired address (i.e., an address required for a memory access request) is contained within the cache. Accordingly, prior art caches are typically implemented in a serial fashion, wherein upon the cache receiving a memory access request, a tag is obtained for the request, and thereafter if the tag indicates that the desired address is contained within the cache, the cache's data array is accessed to satisfy the memory access request. Thus, prior art cache designs typically generate tags indicating whether a true cache \u201chit\u201d has been achieved for a level of cache, and only after a true cache hit has been achieved is the cache data actually accessed to satisfy the memory access request. A true cache \u201chit\u201d occurs when a processor requests an item from a cache and the item is actually present in the cache. A cache \u201cmiss\u201d occurs when a processor requests an item from a cache and the item is not present in the cache. The tag data indicating whether a \u201ctrue\u201d cache hit has been achieved for a level of cache typically comprises a tag match signal. The tag match signal indicates whether a match was made for a requested address in the tags of a cache level. However, such a tag match signal alone does not indicate whether a true cache hit has been achieved.</p><p>As an example, in a multi-processor system, a tag match may be achieved for a cache level, but the particular cache line for which the match was achieved may be invalid. For instance, the particular cache line may be invalid because another processor has snooped out that particular cache line. As used herein a \u201csnoop\u201d is an inquiry from a first processor to a second processor as to whether a particular cache address is found within the second processor. Accordingly, in multi-processor systems a MESI signal is also typically utilized to indicate whether a line in cache is \u201cModified, Exclusive, Shared, or Invalid.\u201d Therefore, the control data that indicates whether a true cache hit has been achieved for a level of cache typically comprises a MESI signal, as well as the tag match signal. Only if a tag match is found for a level of cache and the MESI protocol indicates that such tag match is valid, does the control data indicate that a true cache hit has been achieved. In view of the above, in prior art cache designs, a determination is first made as to whether a tag match is found for a level of cache, and then a determination is made as to whether the MESI protocol indicates that a tag match is valid. Thereafter, if a determination has been made that a true tag hit has been achieved, access begins to the actual cache data requested.</p><p>Turning to FIG. 7, an example of a typical cache design of the prior art is shown. Typically, when an instruction requires access to a particular address, a virtual address is provided from the processor to the cache system. As is well-known in the art, such virtual address typically contains an index field and a virtual page number field. The virtual address is input into a translation look-aside buffer (\u201cTLB\u201d) <b>710</b>. TLB <b>710</b> is a common component of modern cache architectures that is well known in the art. TLB <b>710</b> provides a translation from the received virtual address to a physical address. Within a computer system, the virtual address space is typically much larger than the physical address space. The physical address space is the actual, physical memory address of a computer system, which includes cache, main memory, a hard drive, and anything else that the computer can access to retrieve data. Thus, for a computer system to be capable of accessing all of the physical address space, a complete physical mapping from virtual addresses to physical addresses is typically provided.</p><p>Once the received virtual address is translated into a physical address by the TLB <b>710</b>, the index field of such physical address is input into the cache level's tag(s) <b>712</b>, which may be duplicated N times for N \u201cways\u201d of associativity. As used herein, the term \u201cway\u201d refers to a partition of the cache. For example, the cache of a system may be partitioned into any number of ways. Caches are commonly partitioned into four ways. The physical address index is also input to the cache level's data array(s) <b>716</b>, which may also be duplicated N times for N ways of associativity.</p><p>From the cache level's tag(s) <b>712</b>, a way tag match signal is generated for each way. The way tag match signal indicates whether a match for the physical address was made within the cache level's tag(s) <b>712</b>. As discussed above, in multi-processor systems, a MESI protocol is typically utilized to indicate whether a line in cache is modified and exclusive, shared, or invalid. Accordingly, in such multi-processor systems the MESI protocol is combined with the way tag match signal to indicate whether a \u201ctrue\u201d tag hit has been achieved for a level of cache. Thus, in multi-processor systems a true tag hit is achieved when both a tag match is found for tag(s) <b>712</b> and the MESI protocol indicates that such tag match is a valid match. Accordingly, in FIG. 7, MESI circuitry <b>714</b> is utilized to calculate a \u201ctrue\u201d tag hit signal to determine whether a true tag hit has been achieved for that level of cache. Once it is determined from the MESI <b>714</b> that a \u201ctrue\u201d tag hit has been achieved for that level of cache, then that cache level's data array(s) <b>716</b>, which may also be duplicated N times for N ways of associativity, are accessed to satisfy the received memory access request. More specifically, the true tag hit signal may be used to control a multiplexer (\u201cMUX\u201d) <b>718</b> to select the appropriate data array way to output data to satisfy the received memory access request. The selected data from data array(s) <b>716</b> is output to the chip's core <b>720</b>, which is the particular execution unit (e.g., an integer execution unit or floating point execution unit) that issued the memory access request to the cache.</p><p>In view of the above, prior art caches are typically implemented in a serial fashion, with each subsequent cache being connected to a predecessor cache by a single port. Thus, prior art caches have been only able to handle limited numbers of requests at one time. Therefore, the prior art caches have not been able to provide high enough bandwidth back to the CPU core, which means that the designs of the prior art increase latency in retrieving data from cache, which slows the execution unit within the core of a chip.</p><p>In prior art systems, program ordering has been maintained by handling address conflicts using store buffers, such that as store operations are processed, and before they are actually updated into the cache memory array, the data resides in a store buffer. Control logic with address comparators are used to determine if a later load or store needs the data from one of those stores that has not been updated into the cache memory array. If there is a detection that the data is needed, then that data is read out and combined with data from the cache memory, and the combination is provided as the load data back to the CPU core. The main problem with this arrangement is the high level of complexity. A store buffer structure with these read points is very complicated. Also, this arrangement requires a large amount of surface area as many components are required for its operations, e.g. comparators, and MUXes, particularly to perform the merging of the buffer data and the cache data.</p><h4>SUMMARY OF THE INVENTION</h4><p>These and other objects, features and technical advantages are achieved by a system and method which uses an L<b>1</b> cache that has multiple ports. The inventive cache uses separate queuing structures for data and instructions, thus allowing out-of-order processing. The inventive cache uses ordering mechanisms that guarantee program order when there are address conflicts and architectural ordering requirements. The queuing structures are snoopable by other processors of a multiprocessor system. This is required because the tags are before the queues in the pipeline. Note that this means the queue contains tag state including hit/miss information. When a snoop is performed on the tags, if it is not also performed on the queue, the queue would believe it has a hit for a line no longer present in the cache. Thus, the queue must be snoopable by other processors in the system.</p><p>The inventive cache has a tag access bypass around the queuing structures, to allow for speculative checking by other levels of cache and for lower latency if the queues are empty. The inventive cache allows for at least four accesses to be processed simultaneously. The results of the access can be sent to multiple consumers. The multiported nature of the inventive cache allows for a very high bandwidth to be processed through this cache with a low latency.</p><p>The inventive cache manages address conflicts and maintains program order without using a store buffer. The cache utilizes an issue algorithm to insure that accesses issued in the same clock are actually issued in an order that is consistent with program order. This is enabled by performing address comparisons prior to insertion of the accesses into the queue. Additionally, when accesses are separated by one or more clocks, address comparisons are performed, and accesses that would get data from the cache memory array before a prior update has actually updated the cache memory in the array are canceled. This provides a guarantee that program order is maintained, as an access is not allowed to complete until it is assured that the most recent data will be received upon access of the array.</p><p>It is a technical advantage of the invention to be able to have multiple accesses to the data array in each clock cycle.</p><p>It is another technical advantage of the invention to manage address conflicts and maintain program order without using a store buffer.</p><p>It is a further technical advantage of the invention to manage address conflicts and maintain program order with a cache that requires less complexity and less surface area of the CPU.</p><p>The foregoing has outlined rather broadly the features and technical advantages of the present invention in order that the detailed description of the invention that follows may be better understood. Additional features and advantages of the invention will be described hereinafter which form the subject of the claims of the invention. It should be appreciated by those skilled in the art that the conception and specific embodiment disclosed may be readily utilized as a basis for modifying or designing other structures for carrying out the same purposes of the present invention. It should also be realized by those skilled in the art that such equivalent constructions do not depart from the spirit and scope of the invention as set forth in the appended claims.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWING</h4><p>For a more complete understanding of the present invention, and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawing, in which:</p><p>FIG. 1 is a block diagram depicting the inventive cache arrangement;</p><p>FIGS. 2A and 2B depict the internal elements of the L<b>1</b> cache of FIG. 1 used in a store operation;</p><p>FIG. 3 depicts the stages wherein access entries are issued from the queues;</p><p>FIGS. 4A and 4B depicts the portions of the issue algorithm for the L<b>1</b> cache of FIG. 1;</p><p>FIG. 5 is a flow diagram depicting the pipeline operations of the L<b>1</b> cache for a series of access requests;</p><p>FIGS. 6A and 6B depicts the cancellation logic that cancels access that follow other accesses; and</p><p>FIG. 7 depicts a prior art arrangement for a cache structure.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION</h4><p>FIG. 1 is a block diagram depicting the arrangement <b>100</b> of the L<b>1</b> cache <b>101</b> with the L<b>0</b> instruction cache <b>102</b>, L<b>0</b> data cache <b>103</b>, CPU <b>104</b>, and the L<b>2</b> cache <b>105</b> and the information pathways between the caches, CPU <b>104</b>, and system bus <b>106</b>.</p><p>The L<b>1</b> cache <b>101</b>, which is a combined data and instruction cache, receives access requests from the L<b>0</b> data cache <b>103</b>. Included in that L<b>1</b> cache are queuing structures that hold the tags and the data for information stored in the cache. The L<b>1</b> cache is configured to be able to receive, every clock cycle, 4 accesses or access requests from the L<b>0</b> data cache, via 4 ports <b>107</b>. The accesses may be stores or loads. A store is a memory access request desiring to write data to cache. A load is a memory access request desiring to read data from the cache. L<b>1</b> cache uses a pipeline and two queues to manage the access requests. The accesses can be pulled from the pipeline or the queues for processing. The L<b>1</b> cache may supply up to two integer results per clock, via two ports <b>108</b>, to the L<b>0</b> data (L<b>0</b>d) cache <b>103</b>. These integer results may be sent by the L<b>0</b>d cache to the integer general registers in the CPU core <b>104</b>. The L<b>1</b> cache can also supply up to 4 floating point results per clock, via four ports <b>109</b>, directly to the floating point registers of the CPU core <b>104</b>. The L<b>1</b> cache can also send 256 bits of instruction data to the L<b>0</b>i cache via return bus <b>110</b>. The interfaces permit the L<b>1</b> cache to communicate with the other caches, CPU, and other elements coupled to the bus <b>106</b>. Bus <b>113</b> provides multi-processor support, by allowing snoop requests from other processors to access the L<b>0</b> cache. Note that a snoop request will be passed onto L<b>1</b> cache as if the snoop was a CPU request.</p><p>Path <b>114</b>, between L<b>0</b> instruction cache and L<b>0</b> data cache, is for instruction fetch requests that have missed the L<b>0</b> instruction cache. The L<b>0</b>i cache makes a request of the L<b>0</b> data cache for a line of memory containing instructions to execute. The L<b>0</b> data cache utilizes an unused one of the 4 ports <b>107</b> to send the instruction request to the L<b>1</b> cache <b>101</b>.</p><p>Path <b>112</b> is actually 2 paths. The request part of path <b>112</b> is used for sending data or instruction accesses to the L<b>2</b> cache <b>105</b>. These requests may be speculatively sent, i.e. before knowledge of an access miss of the L<b>1</b> cache in order to minimize the latency of accessing the L<b>2</b> cache. The L<b>2</b> provides a full line of data in 4 clocks over the data return bus <b>111</b> to the L<b>1</b> cache <b>101</b>. The L<b>1</b> cache fills the full line of data into the L<b>1</b> cache and can bypass the result to the necessary consumer which could be any of <b>102</b>, <b>103</b>, or <b>104</b>. The other path of path <b>112</b> is the snoop response path. For a snoop of the L<b>1</b> cache, the L<b>1</b> provides a report to the L<b>2</b>/Bus Cluster regarding the status of the line in the L<b>1</b> cache. This result is provided utilizing the snoop response path part of path <b>112</b>.</p><p>Note that instruction return bus <b>110</b>, new access ports <b>107</b>, integer return ports <b>108</b>, and fp return ports <b>109</b>, L<b>2</b> request port <b>112</b>, and data return bus <b>111</b> can all be active at the same time with some restrictions. The biggest restriction is on the fp return ports <b>109</b>, integer return ports <b>108</b>, and instruction return ports <b>110</b>. There are several possible maximal combinations of activity that can be supported. The limitations are based upon the 4 access per clock limitation for data accesses, and the array limitations of only being able to supply 512 bits per clock, and the oversubscribe logic which can alleviate resource conflict blockages to some extent. The possible simultaneous port usage from L<b>1</b> return ports <b>109</b>, <b>108</b>, and <b>10</b>, is as follows:</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"offset\" colwidth=\"21pt\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"35pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"98pt\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"63pt\"></colspec><thead><row><entry></entry><entry align=\"center\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\"></entry></row><row><entry></entry><entry>FP Ports</entry><entry>Integer Ports</entry><entry>Instruction</entry></row><row><entry></entry><entry align=\"center\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry><entry>2</entry><entry>2</entry><entry>yes</entry></row><row><entry></entry><entry>4</entry><entry>0</entry><entry>yes</entry></row><row><entry></entry><entry>4</entry><entry>2</entry><entry>no</entry></row><row><entry></entry><entry align=\"center\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>Note that the two integer ports with the four fp ports are really using the integer ports to send a line of data to the L<b>0</b>d cache.</p><p>The arrangement <b>100</b> would operates as follows. For example, the CPU <b>104</b> issues an integer load type instruction, which is sent to the L<b>0</b> data cache and to the L<b>1</b> cache in parallel. The tags of each cache are accessed in parallel. Note that the tags of the L<b>1</b> cache are being accessed speculatively, in other words assuming that the L<b>0</b> data cache does not have the data and will miss. If the L<b>0</b> data cache does miss, then the L<b>1</b> will use the results of that speculative tag access to determine if it has the data or not. If the L<b>0</b> data cache does have the requested data, then the L<b>0</b> will return the data to the CPU core register file, and the L<b>1</b> will halt accessing, even though it has speculatively accessed the tags and may have also speculatively accessed the data. The L<b>0</b> data cache sends a signal to the L<b>1</b> cache to inform the L<b>1</b> cache of a hit or miss. If the L<b>0</b> data cache has a miss, and the Li cache has a hit, then the integer data is returned to the L<b>0</b> data cache <b>103</b>, via ports <b>108</b>. The data could be used in moving a line of data up to the L<b>0</b> data cache, or sent to, via the L<b>0</b> data cache, to the CPU core integer register file, or both.</p><p>After the L<b>1</b> cache receives the speculative request from the L<b>0</b> cache, the L<b>1</b> cache sends a speculative request to the L<b>2</b> cache. If the L<b>1</b> cache misses, then the L<b>1</b> cache allocates a line in its array, in anticipation of a data return from L<b>2</b> cache. Note that bus <b>112</b>, which carries the speculative request to the L<b>2</b> cache is a single port bus, capable of carrying one request per clock cycle, so priority select structures are used to connect the appropriate L<b>2</b> cache structures to the bus. If the L<b>2</b> cache has the data, and assuming that the L<b>0</b> cache and the L<b>1</b> cache do not, then the L<b>2</b> cache will send that data back to the L<b>1</b> cache. The L<b>1</b> cache will fill that data into the L<b>1</b> cache. First, it buffers up an entire line, including the requested data, and then it writes the line into the L<b>1</b> cache array. In parallel with the buffering, the cache also sends the requested data to the L<b>0</b> data cache, and/or the CPU core. If the L<b>2</b> misses, the L<b>2</b> uses its BRQ structure, or Bus Request Queue, to send a request onto the processor interface memory bus <b>106</b> or system bus. This request will retrieve a line from RAM memory. Note that the L<b>2</b> cache may be larger than the L<b>1</b> cache, and the L<b>1</b> cache may be larger then the combination of L<b>0</b> instruction cache and L<b>0</b> data cache. Also note that the L<b>0</b> cache is split so that the relevant portions are located closer to the processor consumer components that use the respective cache portions, thereby reducing latency. Further note that L<b>0</b>, L<b>1</b> and L<b>2</b> may all be located on the processor chip to reduce latency.</p><p>FIG. 2A depicts the address information path for a store operation. This flow arrangement <b>300</b> begins with the tag access and ends with storing the data to the memory array of the L<b>1</b> cache <b>201</b>. An access, including the physical address, is sent from the L<b>0</b> data cache to the L<b>1</b> cache, wherein the tags are accessed <b>205</b> to determine if there is a hit. If there is a hit, the access is sent to either the instruction queue <b>206</b> or the data queue <b>209</b>.</p><p>Priority logic (not shown) controls the MUX <b>220</b>, and thereby chooses one of the data queue <b>209</b> or the bypass as the source of the address information. The address information comprises an address or index, way, and read/write (load/store) information. Note that up to four access can be handled in the same cycle. The latches <b>221</b>, <b>222</b>, <b>223</b> are used for timing purposes in moving the data along the pipeline. MUX <b>224</b> permits addresses for fills to be brought in from port <b>111</b>. The selected address is used as the address for the store into the array <b>201</b>.</p><p>The MUX <b>210</b> is used for selecting the following: data Q accesses; instruction accesses; bypass accesses (from <b>107</b>/<b>205</b>); store accesses (from <b>223</b> and <b>224</b>); and fill accesses (from <b>223</b> and <b>224</b>). Note that the loads and stores originates at port <b>107</b>.</p><p>Note that there is a window between the stores and loads. Because some stores also do loads, stores cannot write their data to the memory array until they have been combined with load data and have had new ECC generated. Thus, the stores cannot occur until 3 pipe stages after the earliest time a load could be done. Loads are allowed to issue before stores, since this would penalize loads and force them to wait until a store would be done. (Note that this would also complicate small stores, which are stores that need to be combined with load data and have ECC generated.) Thus, loads are allowed to access the data arrays as soon as they possibly can, and stores are made to update the array as soon as the slowest store possibly can. The slowest store is a small store that must be combined with a load before generating ECC. Therefore, there are 3 clocks between the pipeline stage of a load and that of a store impacting the array. This is why there are the extra pipeline latches <b>221</b>, <b>222</b>, <b>223</b> shown in FIG. <b>2</b>A.</p><p>FIG. 2B depicts the flow of data in a store operation. This flow begins with rotator MUX <b>301</b>, which puts the register file data into memory format. The latches <b>302</b>, <b>303</b>, <b>304</b>, <b>305</b> are used to maintain timing in the pipeline. After rotation, the data is placed into data queue <b>306</b>, which is different from data queue <b>209</b>. Data queue <b>209</b> holds an address, while data queue <b>306</b> hold the data to be associated with the address. Note that a maximum of 2 stores per cycle are received, but a total of 4 accesses total per cycle may be received. Thus, the MUX/latch/queue <b>301</b>, <b>302</b>, and <b>306</b> are designed to only accept 2 accesses per clock, the specific 2 stores possible per clock. MUX <b>215</b> allows for data loaded for a read/modify/write operation from P<b>0</b>-P<b>3</b> to be stored. ECC is generated for the data, which is then stored into the array <b>201</b> along with the data.</p><p>FIG. 3 depicts the flow of information for data inserts into the queues of the L<b>1</b> cache <b>101</b>. The upper pipeline <b>402</b> is the main CPU pipeline and comprises the EXE (execution), DET (exception detection), and WB (write-back) stages. The physical address <b>404</b> of the access request is received in the L<b>0</b>M stage. The store data <b>405</b> is sent by CPU in the EXE stage. The inserts occur in stage L<b>0</b>W. The L<b>1</b> cache uses five queues.</p><p>The first queue is the data queue <b>306</b>, which holds the actual data used in the store operation. The data is inserted into the queue in stage L<b>0</b>W <b>403</b>. This data will be read out later for the store into the L<b>1</b> array. The next queue is the fill buffer <b>505</b>. This queue is used to hold information about requests made to the L<b>2</b> cache or bus cluster. Such requests are processed when there is a miss for the L<b>1</b> cache. The information in the queue is used in processing data returns from the L<b>2</b> cache or bus cluster, and for managing address conflicts. The third queue is data queue <b>209</b>, which holds the address and other information, such as control and ordering information, that is associated with the write data that is being stored into queue <b>306</b>. Control information includes whether the access is a L<b>1</b> cache hit, a L<b>1</b> cache miss, or a re-circulate. Other information includes memory type, whether the access is a write-back, write-through, or uncacheable, also whether or not to fill the L<b>0</b> cache, and if so information regarding the fill associated with this access. Further information details whether the access has been successfully retired from the CPU pipeline, which applies if the access does not have any faults or trapping indications that would prevent it from updating memory or returning data to a target register (for a load). The queue can hold 32 entries. This information is used in accessing the L<b>1</b> cache, issuing data to the L<b>2</b> cache, and ordering and address conflict management. The next queue is the instruction queue <b>206</b>. Instructions, when they arrive in the L<b>1</b> cache are routed to the instruction queue. The instruction queue is managed with a different algorithm than the data queue <b>209</b>, because the ordering requirements for instruction accesses are different than for data accesses.</p><p>The arrangement of FIG. 3 operates as follows. The store data enters through rotator <b>301</b> in DET stage. The store data is then stored <b>403</b> into data queue <b>306</b>, via latch <b>302</b>, in the WRB stage of CPU pipeline <b>402</b>. These steps format the store data into memory format and insert the data into the data queue <b>306</b>. The physical address <b>404</b> from the TLB and the other access information <b>406</b> is received in the L<b>0</b>M stage. The other access information comprises op code, data size, and miscellaneous information from the TLB such as memory attribute type. CAM checks <b>407</b>, <b>408</b>, or content addressable memory, is performed on the Fill Buffer <b>505</b> and the Data Queue <b>209</b> to determine whether there are any conflicts with other pending access requests in the next stage, namely L<b>0</b>D. A cam check compares the address of the access request with the addresses of the access entries in the queues.</p><p>If there are misses on both the fill buffer and the data queue cams, then there are no conflicts with queue entries and the queues are filled as needed.</p><p>If there is a hit on the fill buffer cam, then a prior request missed in L<b>1</b> cache, and a request entry is pending for the data from either L<b>2</b> cache or the bus cluster. Note that a hit on the fill buffer cam does not necessarily mean that there will be hit in the data queue <b>209</b> cam as well. The access request that matched is inserted as a re-circulate entry into either the data queue or the instruction queue, as appropriate. The re-circulated entry will not access the cache until the prior miss is returned.</p><p>If there is a hit on the data queue cam, then its disposition depends on the L<b>1</b> tag match information of both the access and the entry. If both the access and the conflicting entry have L<b>1</b> hits, then the access is inserted into the data queue as a L<b>1</b> hit entry. If the access has an L<b>1</b> miss and the entry has an L<b>1</b> hit, then the access is inserted into the data queue as a L<b>1</b> miss entry. An illegal state is where the access has an L<b>1</b> hit and the entry has an L<b>1</b> miss, as this combination cannot occur. If both the access and the entry are L<b>1</b> misses, then the access is inserted into the data queue as a re-circulate entry.</p><p>Hits in the L<b>1</b> cache are managed according to their access type, e.g. load or store, and access size. If one (or both) of the matching accesses, old or new, is a store, then conflict information regarding the matching addresses is stored in the queue along with the newer access. The conflict information invokes a special architectural ordering mechanism called Effective Release. The issue algorithm uses this mechanism to ensure that the newer access is not issued before the older access. Specifically, when one of the accesses is a store, then the accesses are issued in order. If both of the matching accesses are loads, then they can be issued in any order.</p><p>Size of the different conflicting accesses is taken into account. For example, one request is a load request (read operation) that is promoting a cache line from the L<b>1</b> cache into the L<b>0</b> data cache, i.e. a fill for the L<b>0</b> data cache, and a second request is a store operation that is stored data into a portion of the cache line of the load access. Size works to enable or disable particular address bits in the CAM, which will be detected by the CAM checks. Size can be viewed as a mask on the CAM function.</p><p>There are three states for an access in both the data queue <b>209</b> and the instruction queue <b>206</b>, specifically, L<b>1</b> hit, L<b>1</b> miss and re-circulate. The fill buffer has one state, namely L<b>1</b> miss. Re-circulation is a stalling mechanism that routes the one of the four accesses back to the L<b>0</b>M stage, wherein the tags are re-accessed. Re-circulation allows for accesses to be stalled, for example, if an access has a conflict with a previous miss, which is waiting for data to return from L<b>2</b> cache or the bus cluster, then the newer access can be re-circulated until the data arrives. Re-circulation is unlimited in terms of the number of times that an access may be re-circulated. Note that hit and miss here mean hit and miss as determined by the L<b>1</b> tag access check, not the fill buffer and data queue cam checks. The L<b>1</b> tag access check is performed in parallel with the L<b>0</b> TLB access. A \u201cmiss\u201d is sent to the L<b>2</b> cache or the bus cluster, while a \u201chit\u201d indicates that the data is in the L<b>1</b> cache, and can be retrieved from the L<b>1</b> cache.</p><p>When attempting to insert an access into the data queue <b>401</b>, in addition to the ordering and address information, bank conflict information <b>409</b> is also determined in order to optimize the issuing algorithm. This information is related to the design of the cache memory array. Ideally, in processing multiple accesses simultaneously, each access would be accessing different memory banks, as two accesses involving the same bank cannot be processed in the same cycle (note that one or more banks may be involving in an access). Thus, accesses involving the same memory bank(s) are assigned different issuing cycles to improve performance. Any bank conflicts are stored along with the access into the data queue <b>209</b>. Note that inserts of instructions <b>206</b> are not checked, as only one instruction can be stored or loaded in one cycle, whereas multiple data accesses (four) can be performed in a single cycle, so there are no ordering conflicts with instructions. However, instructions will have address conflict checks similar to those performed for data, e.g. cam <b>408</b>, so that only one miss is tracked at a time for a given line address.</p><p>As shown in FIGS. 2A and 2B, the data queue <b>306</b> can issue 4 accesses per clock down the pipeline, with FIG. 2A depicting the address path and FIG. 2B depicting the data path. However, multiple accesses (loads or stores) cannot access the same bank of memory at the same time. The cache memory array <b>201</b> is organized into 16 banks. Each bank has separate access logic or circuitry. Thus, the logic can only satisfy one access at a time (per clock). The bank identification for an access is part of the memory address, e.g. bits <b>7</b> through <b>4</b> of the access address. Thus, if two store access were sent down the pipeline, with the first accessing banks <b>1</b>-<b>3</b> and the second accessing banks <b>3</b>-<b>5</b>, then since the accesses overlap, i.e. bank <b>3</b>, then both of the accesses can not be completed.</p><p>Prior to inserting the accesses into the queues, i.e. the data queue <b>209</b>, the cache performs a cam check to determine bank conflicts, <b>409</b>. This cam check compares the bank numbers of each new access with the accesses stored in the queue. Since multiple accesses can be inserted in one clock cycle, the cam check also compares the bank numbers of each new access with the other new accesses in the same clock cycle. Each old access that has a conflict is tagged with conflict information indicating that it has a bank conflict and include information identifying the conflicting younger accesses.</p><p>FIG. 4A depicts the portion of the issue algorithm that manages cache memory bank conflicts, specifically the portion of logic for entry C of the data queue. This logic is replicated for each entry in the queue. Thus, if the queue has 32 entries, then this logic is replicated 32 times. Note that each entry can only be tagged with a conflict for the next younger 15 neighboring entries, however more bits can be added to cover the remaining entries. In FIG. 4A, three access entries are shown, A, B, C, with A being older than B, and B being older than C. Suppose, entry A has a conflict with entry C, then entry A is tagged with a bit <b>503</b> indicated a conflict with entry C Note that C is not tagged, this issue mechanism operates because entries are issued in program order. Each entry has an AND gate <b>501</b> that is connected to a request line <b>502</b> and the conflict bit line <b>503</b>. The request line indicates that a particular entry is attempting (or has been nominated) to issue. Suppose entry A and entry C are attempting to issue. Thus, AND gate <b>501</b> with both inputs high will go high, and provide the high input to OR gate <b>504</b>. With one of its inputs high, OR gate <b>504</b> goes high. Since both of the inputs to AND gate <b>505</b> are high, then AND gate <b>505</b> will cause arbitrate signal <b>506</b> to go low on the next cycle. The arbitrate signal indicates that the find-first-four-logic <b>507</b> should decide which entry A or C should issue. Note that each of the 32 entries has an arbitrate signal, which must be high if an access is to issue. Each entry's arbitrate signal is ANDed with the requesting signal, and the output is fed into the find first four logic. If an arbitrate signal is deasserted for an entry, then the input to the find first four logic for that entry indicates the entry cannot issue in that clock. Other entries that can issue are considered, and will be allowed to issue.</p><p>The logic <b>507</b> determines which is older, and allows that entry to issue. Since C cannot issue, the logic <b>507</b> determines three other accesses that can issue, and allows A and the three others to issue. Thus, this logic prevents a bank conflict by preventing two (or more) accesses from issuing that will access the same cache memory bank. Note that the logic determines which is the oldest because the entries are filled in a deterministic manner in a queue, i.e. oldest first then youngest. Note that this logic operates in a single clock cycle. This logic resides in data queue <b>209</b> and operates in stages L<b>1</b>N and L<b>1</b>I, even though it operates in a single cycle that is split between two clock cycles. Note that the arbitrate logic resides in L<b>1</b>N, however, the first four logic operates at the beginning of L<b>1</b>I. Further note that this logic has prevented the access entry C from issuing. This entry could be considered for issue again in the next clock cycle.</p><p>As shown in FIG. 3, prior to inserting the accesses into the queues, i.e. the data queue <b>209</b>, the cache performs a cam check to determine address conflicts, <b>408</b>. This cam check compares the addresses of each new access with the accesses stored in the queue. Since multiple accesses can be inserted in one clock cycle, the cam check also compares the addresses of each new access with the other new accesses in the same clock cycle. Each new access that has a conflict is tagged with conflict information indicating that it has a conflict and include information identifying the conflicting older access(es). Note this is different than bank conflicts. This tagging is done with the \u201ceffective release\u201d notation. Further note that a bank conflict is two accesses that require the same memory bank in to complete. An address conflict is two accesses where the younger must complete after the older in order. If the accesses do not complete in order, then either memory or a CPU register will be updated with the wrong information.</p><p>FIG. 4B depicts the portion of the issue algorithm that manages cache memory address conflicts, specifically the portion of logic for entry C of the data queue. This logic is replicated for each entry in the queue. Thus, if the queue has 32 entries, then this logic is replicated 32 times. In FIG. 4B, three access entries are shown, A, B, C, with A being older than B, B being older than C. Suppose, A, B, and C are attempting to issue, with B and C attempting to address the same location, and A and B having a bank conflict. For the address conflict, the effective release bit <b>513</b> is set on the younger access, here entry C. This bit causes the entry to be treated like a release operation. The release operation defines the entry as not being able to complete until older accesses have been completed. Note that completion means processed to a point where the access cannot be prevented from completing. For the bank conflict, the logic of FIG. 4A would invoke the arbitrate signal for entry B. The inhibit signal <b>508</b> indicates that an entry has been prevented from issuing, and is based on the arbitrate signal. Thus, the inhibit signal would be active for entry B. With both inputs high, the AND gate <b>509</b> goes high. With one of its inputs high, the OR gate <b>510</b> goes high. The issue H bit or signal <b>512</b> indicates whether the particular access entry is associated is actually going to issue. Since all three inputs are now high, the AND gate <b>511</b> goes high indicating a bad release <b>514</b> for entry C. Note that the effective release <b>513</b> is not an architectural release, but rather is a hardware addition to the ordering model. This allows the issue algorithm to operate in an out of order manner, and yet still be able to guarantee that accesses will issue in order when ordering constraints need to be imposed. Note that this logic operates in a single clock cycle. This logic resides in data queue <b>209</b> and operates in stages L<b>1</b>. Note that access entry C has issued. The bad release bit <b>514</b> causes the access to be switched to invalid. The access continues to travel down the pipeline invalid, and is thrown away when the access reaches the array <b>201</b>. Thus, less than four accesses will be processes with the array <b>201</b>.</p><p>Another conflict problem is a store/load conflict. This conflict is best understood in terms of an example, which is depicted in FIG. <b>5</b>. This FIGURE has the pipeline stages <b>515</b> across the FIGURE and time <b>516</b> down the FIGURE. FIG. 5 involves two stores and four loads being sequentially processed down the pipeline, in the order of Storel, LdA, LdB, LdC, LdD, and Store <b>2</b>, one per clock cycle. All of these accesses overlap, and affect the same portion of cache memory. Also all of these accesses have issued. Note that only one entry per clock cycle has been shown for simplicity. The pipeline stages are shown in FIGS. 2A and 2B, with stages L<b>1</b>N and L<b>1</b>I being inside data queue <b>209</b>. The specific accesses that cause address conflicts are a store followed by a load, a store followed by a store, or a load followed by a store. Note that a store followed by a store is a problem for two reasons. If they are done out of order, then memory reflects the value of the older store, not the younger after both complete. In addition, if the second store requires a read-modify-write operation (is a 1 byte or a 2 byte store for our processor), then the read part of the read-modify-write store must read the up to date value of memory. The conflict arises because loads and stores are processed at a different point in the pipeline, specifically loads are read in L<b>1</b>M, while stores are written in L<b>1</b>W. Thus, Store will not be processed until L<b>1</b>W, however loads LdA, LdB, and LdC will have passed the L<b>1</b>M stage before Store<b>1</b> has been completed. Thus, unless LdA, LdB, and LdC are canceled, they will read incorrect data, i.e. old data. LdD will see the proper data as it reaches the L<b>1</b>M stage in clock <b>8</b>, which is after Store<b>1</b> has completed, and thus is allowed to complete. The loads LdA, LdB, and LdC will be re-circulated and allowed to complete after Store<b>1</b> has completed. Note that Store<b>2</b> will have to be canceled until LdA, LdB, and LdC have completed, otherwise the loads will be reading the data of Store<b>2</b> not Store<b>1</b>. The logic in FIGS. 6A and 6B accomplishes these cancels.</p><p>Note that stores (writes) require more steps than loads (reads). For example, stores need ECC to be generated for the store data. Also stores may involve a read of other data and merge of the other data with the new data to form a cache line. These steps require additional time not needed for load operation. To prevent unnecessarily delaying all loads, load operations are allowed to access the data array in the pipeline earlier than store operations are ready to access the data array.</p><p>FIG. 6A depicts the cancellation logic <b>600</b> that cancels loads following a store operation. If there is a store operation in L<b>1</b>A, L<b>1</b>M, L<b>1</b>D, or L<b>1</b>C stage that matches the address (which comprises the index and way information) of a load operation in L<b>1</b>A stage, then the load in L<b>1</b>A is canceled. This prevents the loads LdA, LdB, and LdC from operating before Store<b>1</b> has operated in FIG. <b>5</b>. Note that since multiple accesses can issue in the same cycle, a store in L<b>1</b>A is compared to a load in L<b>1</b>A. Note that the index and way is a full address comparison. Further note that stores that attempt to issue together in the same clock are dealt by the bank conflict logic. The canceled accesses are switched to invalid. The accesses continue to travel down the pipeline invalid, and are thrown away when the accesses reaches the array <b>201</b>.</p><p>An alternative embodiment to that of FIG. 6A is to not have the Store L<b>1</b>C comparison. In this case, since a load in L<b>1</b>A is only one clock cycle away from being permissible to process, this access could be delayed from issuing for one clock cycle, and then allowed to issue. Thus, circuitry similar to that of FIG. 4A could be used to inhibit the release of the load in L<b>1</b>A. The bits <b>503</b> would be set for an address conflict, specifically a bank conflict, that is three clocks away. Since the queue is not updated until the store is completed, then a comparison could be made between loads L<b>1</b>N stage and inflight stores in the L<b>1</b>M stage. Then all loads to the same bank as the store would be inhibited. Loads in the L<b>1</b>N stage are used, since this is the stage in which the arbitrate is checked. Thus LdC is inhibited (or delayed) and not canceled (or invalidated). Thus, LdC would be delayed one clock, and would become the same timing as LdD, so LdD and LdC might issue together, as long as they do not access the same bank.</p><p>FIG. 6B depicts the cancellation logic <b>601</b> that cancels stores following a canceled load or store operation. If there is a store operation in LlA stage that matches the address of any canceled access (load or store) in stages L<b>1</b>M, L<b>1</b>D, or L<b>1</b>C, then the L<b>1</b>A store is canceled. This prevents the Store<b>2</b> in FIG. 5 from operating before loads LdA, LdB, and LdC have operated. Note that canceled prior stores will also cause a subsequent store to be canceled. Suppose in FIG. 5, the first store is canceled for a particular reason, if the second store is then written, the first store will pass back through and overwrite the second store. Thus the cache has incorrect data, as the data from the second store should be overwriting the first store. Consequently, the second store must be canceled, thereby allowing the first store to pass back through and write, and then the second store will pass back through and overwrite the first store.</p><p>Thus the inventive cache guarantees the processing of address conflict accesses in order, as well as bank conflicts.</p><p>Although the present invention and its advantages have been described in detail, it should be understood that various changes, substitutions and alterations can be made herein without departing from the spirit arid scope of the invention as defined by the appended claims. Moreover, the scope of the present application is not intended to be limited to the particular embodiments of the process, machine, manufacture, composition of matter, means, methods and steps described in the specification. As one of ordinary skill in the art will readily appreciate from the disclosure of the present invention, processes, machines, manufacture, compositions of matter, means, methods, or steps, presently existing or later to be developed that perform substantially the same function or achieve substantially the same result as the corresponding embodiments described herein may be utilized according to the present invention. Accordingly, the appended claims are intended to include within their scope such processes, machines, manufacture, compositions of matter, means, methods, or steps.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Dean A.", "last_name": "Mulla", "name": ""}, {"first_name": "Reid James", "last_name": "Riedlinger", "name": ""}, {"first_name": "Thomas", "last_name": "Grutkowski", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "HEWLETT-PACKARD COMPANY"}, {"first_name": "", "last_name": "HEWLETT PACKARD ENTERPRISE DEVELOPMENT LP", "name": ""}, {"first_name": "", "last_name": "HEWLETT-PACKARD DEVELOPMENT COMPANY, L.P.", "name": ""}, {"first_name": "", "last_name": "HEWLETT-PACKARD COMPANY", "name": ""}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711131"}, {"primary": false, "label": "711E12043"}, {"primary": false, "label": "711119"}, {"primary": false, "label": "711117"}], "ecla_classes": [{"label": "G06F  12/08B22L"}], "cpc_classes": [{"label": "G06F  12/0897"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "2000-02-21", "application_date": "2000-02-21", "family_members": [{"ucid": "US-6539457-B1", "titles": [{"lang": "EN", "text": "Cache address conflict mechanism without store buffers"}]}, {"ucid": "DE-10045188-A1", "titles": [{"lang": "EN", "text": "Cache address conflict device without storage buffer for computer systems, has plane of multi-level/plane structure provided with a queue for holding entries of address information for data access"}, {"lang": "DE", "text": "Cacheadresskonfliktvorrichtung ohne Speicherpuffer"}]}, {"ucid": "DE-10045188-B4", "titles": [{"lang": "EN", "text": "Cache device address conflict"}, {"lang": "DE", "text": "Cacheadresskonfliktvorrichtung"}]}]}