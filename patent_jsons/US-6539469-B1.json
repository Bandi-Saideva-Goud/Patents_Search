{"patent_number": "US-6539469-B1", "publication_id": 73355463, "family_id": 23649844, "publication_date": "2003-03-25", "titles": [{"lang": "EN", "text": "Rotator circular buffer with entries to store divided bundles of instructions from each cache line for optimized instruction supply"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50467367\"><p>A processor comprises an instruction cache that stores a cache line of instructions and an execution engine for executing the instructions, along with a buffer to store a plurality of entries. A first logic circuit divides the cache line into instruction bundles, each of which gets written into an entry of the buffer. A second logic circuit reads out a number of consecutive instruction bundles from the buffer for dispersal to the execution engine to optimize speculative fetching and maximizing instruction supply to the execution resources of the processor.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00001\" num=\"1\"><claim-text>1. A processor comprising:</claim-text><claim-text>an instruction cache that stores a cache line of instructions; </claim-text><claim-text>an execution engine for executing the instructions; </claim-text><claim-text>a circular buffer having a plurality of entries; </claim-text><claim-text>a first logic circuit that divides the cache line into instruction bundles, each of which is written into an entry of the circular buffer; and </claim-text><claim-text>a second logic circuit that reads out a number of consecutive instruction bundles from the circular buffer for dispersal to the execution engine. </claim-text></claim>"}, {"num": 2, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00002\" num=\"2\"><claim-text>2. A processor comprising:</claim-text><claim-text>an instruction cache that stores a cache line of instructions; </claim-text><claim-text>an execution engine for executing the instructions; </claim-text><claim-text>a buffer having a starting write pointer and a starting read pointer; </claim-text><claim-text>a first logic circuit that divides the cache line into instruction bundles, each of which is written into an entry of the buffer; and </claim-text><claim-text>a second logic circuit that reads out a number of consecutive instruction bundles from the buffer for dispersal to the execution engine. </claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00003\" num=\"3\"><claim-text>3. The processor of <claim-ref idref=\"US-6539469-B1-CLM-00001\">claim 1</claim-ref> wherein the number of consecutive instruction bundles is equal to 4.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00004\" num=\"4\"><claim-text>4. The processor of <claim-ref idref=\"US-6539469-B1-CLM-00001\">claim 1</claim-ref> further comprising an instruction bypass path coupled between the first and second logic circuits.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00005\" num=\"5\"><claim-text>5. The processor of <claim-ref idref=\"US-6539469-B1-CLM-00001\">claim 1</claim-ref> wherein the plurality of entries is equal to 8 and the cache line comprises 32 bytes.</claim-text></claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00006\" num=\"6\"><claim-text>6. A processor comprising:</claim-text><claim-text>an instruction cache that stores a cache line of instructions; </claim-text><claim-text>an execution core for executing the instructions; </claim-text><claim-text>a first multiplexer circuit that divides the cache line into instruction bundles; </claim-text><claim-text>a N-entry buffer having a plurality of entries and a single read port, the buffer being organized such that every ith entry shares the single read port, the buffer including a fill pointer that points to a starting entry for filling with an instruction bundle provided by the first logic circuit; and </claim-text><claim-text>a second multiplexer circuit that aligns and presents each instruction bundle to the execution core; </claim-text><claim-text>drain control logic that selects an appropriate number of instruction bundles read out from the buffer. </claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00007\" num=\"7\"><claim-text>7. The processor of <claim-ref idref=\"US-6539469-B1-CLM-00006\">claim 6</claim-ref> wherein the cache line comprises 32 bytes.</claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00008\" num=\"8\"><claim-text>8. The processor of <claim-ref idref=\"US-6539469-B1-CLM-00007\">claim 7</claim-ref> wherein N=8 and i=4.</claim-text></claim>"}, {"num": 9, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00009\" num=\"9\"><claim-text>9. The processor of <claim-ref idref=\"US-6539469-B1-CLM-00006\">claim 6</claim-ref> wherein the number of consecutive instructions is equal to 4.</claim-text></claim>"}, {"num": 10, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00010\" num=\"10\"><claim-text>10. The processor of <claim-ref idref=\"US-6539469-B1-CLM-00006\">claim 6</claim-ref> further comprising an instruction bypass path coupled between the first and second multiplexer circuits.</claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00011\" num=\"11\"><claim-text>11. The processor of <claim-ref idref=\"US-6539469-B1-CLM-00010\">claim 10</claim-ref> wherein the instruction bypass path transfers a pair of instruction bundles.</claim-text></claim>"}, {"num": 12, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00012\" num=\"12\"><claim-text>12. The processor of <claim-ref idref=\"US-6539469-B1-CLM-00006\">claim 6</claim-ref> wherein the second multiplexer circuit includes latches that latch the instruction bundles prior to dispersal to the execution core.</claim-text></claim>"}, {"num": 13, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00013\" num=\"13\"><claim-text>13. The processor of <claim-ref idref=\"US-6539469-B1-CLM-00010\">claim 10</claim-ref> wherein the instruction bypass path transfers a pair of instruction bundles.</claim-text></claim>"}, {"num": 14, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00014\" num=\"14\"><claim-text>14. The processor of <claim-ref idref=\"US-6539469-B1-CLM-00010\">claim 10</claim-ref> wherein the buffer comprises a circular buffer.</claim-text></claim>"}, {"num": 15, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00015\" num=\"15\"><claim-text>15. A logic circuit which supplies instructions from an instruction cache to the execution core of a processor comprising:</claim-text><claim-text>a circular buffer having N-entries and a read pointer and a write pointer, the circular buffer having a pair of write ports and a single read port, the circular buffer being organized such that every ith entry shares the single read port; </claim-text><claim-text>way multiplexer logic for dividing a cache line of the instruction cache into first and second instruction bundles, the first and second instruction bundles being written into consecutive entries of the circular buffer starting from the write pointer; </claim-text><claim-text>alignment multiplexer logic for aligning and presenting individual ones of the instruction bundles to the execution core of the processor, wherein j consecutive instruction bundles are read out of the circular buffer at a time starting from the read pointer; and </claim-text><claim-text>control logic for selecting instruction bundles to be output from the alignment multiplexer logic. </claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00016\" num=\"16\"><claim-text>16. The logic circuit of <claim-ref idref=\"US-6539469-B1-CLM-00015\">claim 15</claim-ref> wherein the alignment multiplexer logic comprises:</claim-text><claim-text>first and second latches; and </claim-text><claim-text>first and second multiplexers coupled to the single read port of the circular buffer, the first and second multiplexers each outputting an instruction bundle which is respectively latched in the first and second latches prior to dispersal to the execution core. </claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00017\" num=\"17\"><claim-text>17. The logic circuit of <claim-ref idref=\"US-6539469-B1-CLM-00016\">claim 16</claim-ref> further comprising:</claim-text><claim-text>an instruction bypass path coupled between the way multiplexer logic and the alignment multiplexer logic; and </claim-text><claim-text>wherein the control logic selects appropriate instruction bundles to be output from the first and second multiplexers depending on a number of instruction bundles consumed by the execution core, and a number of instruction bundles available from the circular buffer. </claim-text></claim>"}, {"num": 18, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00018\" num=\"18\"><claim-text>18. The logic circuit of <claim-ref idref=\"US-6539469-B1-CLM-00017\">claim 17</claim-ref> wherein the number of instruction bundles consumed by the execution core in a clock cycle is at most 2.</claim-text></claim>"}, {"num": 19, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6539469-B1-CLM-00019\" num=\"19\"><claim-text>19. The logic circuit of <claim-ref idref=\"US-6539469-B1-CLM-00017\">claim 17</claim-ref> wherein the number of instruction bundles available from the circular buffer in a clock cycle is at most 4.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53896257\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>FIELD OF THE INVENTION</h4><p>This invention relates to the field of microprocessors fabricated on an integrated circuit or chip. More specifically, the invention relates to methods and apparatus for improved instruction throughput in a high-performance processor.</p><h4>BACKGROUND OF THE INVENTION</h4><p>Microprocessors are typically divided into functional blocks or stages through which instructions are propagated and processed. This allows for pipelining of instructions such that when one instruction has completed the first stage of processing and moves on to the second stage, a second instruction may begin the first stage. Thus, even where each instruction requires a number of clock cycles to complete all stages of processing, pipelining provides for the completion of instructions on every clock cycle. This single-cycle throughput of a pipelined processor greatly increases the overall performance of computer systems. Superscalar processors are capable of initiating more than one instruction at the initial stage of the pipeline per clock cycle. Frequently, more than one instruction completes on each given clock cycle of the machine.</p><p>Many modem processors employ a separate instruction cache for storing instructions to be executed by the program or code sequence running on the computer system. Usually, a fast, local instruction cache memory (L<b>0</b>), which is incorporated on the same integrated circuit as the processor itself, is utilized for this purpose. In many cases, a processor includes an instruction fetch unit that is responsible for deciding which instruction cache entry ought to be accessed next to maximize program performance. To operate efficiently, the instruction fetch unit should provide a continual stream of instructions from the instruction cache memory to the pipeline, where they eventually get dispersed to the processor's execution core.</p><p>Difficulties arise in computer systems that attempt to take advantage of the parallelism present in a program by executing instructions based on data dependencies and resource availability. These types of machines are referred to as \u201cout-of-order\u201d computing machines. The term \u201cout-of-order\u201d means not necessarily executed in the same sequence implied by the source program. Moreover, there exists a further problem in keeping track of pending instruction fetch requests from in the face of mispredicted branches. In some instances, instructions are fetched speculatively, based on a predicted program execution path. These machines place enormous performance demands on the fetch logic circuitry of the processor.</p><h4>SUMMARY OF THE INVENTION</h4><p>The present invention is useful in optimizing the speculative fetching engine of a high-performance processor and advantageously maximizes the supply of instructions to the processor's execution core. In one embodiment, the invention comprises an instruction cache that stores a cache line of instructions and an execution engine for executing the instructions. A buffer is provided to store a plurality of entries. A first logic circuit divides the cache line into instruction bundles, each of which gets written into an entry of the buffer. A second logic circuit reads out a number of consecutive instruction bundles from the buffer for dispersal to the execution engine.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>The present invention is illustrated by way of example, and not limitation, in the Figures of the accompanying drawings, wherein:</p><p>FIG. 1 is a functional block diagram of one embodiment of the rotator buffer logic circuitry of the present invention.</p><p>FIG. 2 is diagram illustrating the shared read port bus implemented in one embodiment of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION</h4><p>Throughout the following description specific details are set forth such as file sizes, logic circuit types, byte sizes, etc., in order to provide a thorough understanding of the invention. It should be understood, however, that the invention might be practiced without these particulars. In other instances, well known elements have not been shown or described in detail to avoid unnecessarily obscuring the present invention.</p><p>The processor the present invention includes a first-in-first-out (FIFO) queuing storage unit which occupies the rotate (ROT) pipeline stage of the processor. Referring to FIG. 1, the rotator buffer logic associated with the rotate pipeline stage of the processor is shown. The rotate pipeline stage is shown between dashed lines <b>20</b> and <b>30</b>, which lines represent the clock transition edges of a single clock cycle. In other words, all of logic shown in FIG. 1 fits into a single CPU clock cycle of the processor.</p><p>The rotate pipeline stage of the processor takes the 32-byte instruction cache line output from the four-way, L<b>0</b> instruction way multiplexer <b>21</b> and divides the cache line into two 16-byte instruction bundles. Way multiplexer <b>21</b> a shown coupled to a first level (L<b>0</b>) instruction cache <b>11</b>, which in the particular embodiment described, resides on the same integrated circuit as the processor. The two 16-byte instruction bundles are denoted as B<b>0</b> and B<b>1</b> provided at the output of way multiplexer <b>21</b> in FIG. <b>1</b>. In addition, two additional bundles may be provided from next level cache (e.g., L<b>1</b>) in the memory hierarchy. This is indicated in FIG. 1 by the bypass path output from way multiplexer <b>21</b>.</p><p>Assuming that there are no bundles available in the first level cache memory (i.e., L<b>0</b> is empty), fetching may occur from the next level cache. That is, instructions may be fetched directly from the second level cache (L<b>1</b>) and bypassed directly to way multiplexer <b>21</b>. In this manner, cache line readout may either take place from the L<b>0</b> instruction cache <b>11</b>, or bypassed directly from L<b>1</b> instruction cache (not shown).</p><p>Following way multiplexer <b>21</b>, the instruction cache line (or the two bundles) enters the rotate pipeline stage. To provide the bundles to the execution core, the alignment multiplexers <b>31</b> and <b>32</b> can select among two bypass bundles from the multiplexer output, and four consecutive bundles from buffer <b>24</b>. If there are less than two bundles available in buffer <b>24</b> and there are bundles available at multiplexer <b>21</b>, then alignment multiplexers <b>31</b> and <b>32</b> may select bundles from multiplexer <b>21</b> for bypass to the execution core. Practitioners in the computer arts will appreciate that this bypass scheme implemented in the rotate pipeline stage achieves a maximum throughput that avoids empty pipe stages in the execution core.</p><p>As discussed above, instructions are encoded in bundles according to one embodiment of the processor of the present invention. Each bundle includes a plurality of instructions and a template field grouped together in a N-bit field. The instructions are located in instruction slots of the N-bit field, with the template field specifying a mapping of the instruction slots to the execution unit types. Other encodings or grouping of instructions are also possible, and are considered within the scope of the present invention.</p><p>With continuing reference to the embodiment of FIG. 1, the input to rotator buffer <b>24</b> can be zero, one, or two instruction bundles. The number of bundles issued to the EXP stage that are consumed by the execution core may also be zero, one, or two bundles. Note, however, that information about number of bundles available in the number of bundles consumed by the execution core is not available to the rotate pipeline stage logic until the middle of the CPU clock cycle.</p><p>Rotate buffer <b>24</b> is organized as a circular, wrap-around buffer, which is implemented in the embodiment of FIG. 1 with eight entries, labeled IB<sub>0</sub>-IB<sub>7</sub>. Rotate buffer <b>24</b> has an associated starting write pointer <b>23</b> that points to a starting entry for filling (i.e., writing) of instruction bundles into the buffer. Fill operations are controlled by fill control logic block <b>22</b>. Filling operations take place in-order; that is, according to the original code sequence of the program. After each entry location of buffer <b>24</b> gets written with an instruction bundle, fill pointer <b>23</b> advances in one position in the buffer stack.</p><p>On the readout side, a starting read pointer (i.e., drain pointer) <b>25</b> is also associated with buffer <b>24</b>. FIG. 1 shows the starting read pointer point to IB<sub>0</sub>, with up to four instruction bundles (IB<sub>0</sub>-IB<sub>3</sub>) being read out each clock cycle. The speculative read of the buffer is performed by reading out four consecutive bundles starting from the starting read pointer location, and sending the instruction data to the alignment multiplexers <b>26</b> and <b>27</b>. Depending on the number of bundles consumed by the execution core, the number of bundles available from buffer <b>24</b>, and the number read from cache <b>11</b>, the appropriate bundles from the speculative read and the bypass case are selected from each alignment multiplexer.</p><p>According to the embodiment of FIG. 1, the number of bundles consumed by the execution core is at most two; the number of bundles read from buffer <b>24</b> is at most four; and the number read from cache <b>11</b> is at most two. Drain control logic unit <b>28</b> receives information about the number of bundles consumed in the execution core. Once the bundle consumption information becomes available, two different bypass combinations and four consecutive bundles from rotator buffer <b>24</b> are speculatively read out and then selected.</p><p>Alignment multiplexers <b>26</b> and <b>27</b> are an in-order output to the dispersal stage to maintain the FIFO scheme. The alignment multiplexers perform any needed rotation, selecting the appropriate bundles to be latched in dispersal latches <b>31</b> &amp; <b>32</b>, respectively. Each of the alignment multiplexers has six inputs, two of which are the instruction cache way multiplexer (21) outputs, with each bypass instance consisting of two instruction bundles. Also included among the inputs to the alignment multiplexers are the four other consecutive instruction bundles read out from rotator buffer <b>24</b>.</p><p>As the execution engine of the processor consumes instruction bundles, next in-order bundles get consecutively latched into the dispersal latches through the alignment multiplexers. In operation, drain pointer <b>25</b> basically trails fill pointer <b>23</b>, wrapping around the end of the rotate buffer <b>24</b>.</p><p>With reference to FIG. 2, the bus wire routing of the single read port of rotate buffer <b>24</b> is shown. Due to the speculative read, the wiring bundles, and their associated tagging information, an ordinary practitioner might expect that a large routing area would be required to implement the logic of the rotate buffer pipestage. One of the important aspects of the present invention is that rotate buffer <b>24</b> utilizes a shared read port design that optimizes usage of silicon area. In other words, the single read port buffer <b>24</b> is used to read out four consecutive instruction bundles to alignment multiplexers <b>26</b> and <b>27</b>; however, the number of read ports of the register file memory cells is reduced from two ports per cell to one per cell. This reduces the transistor count from twenty transistors per cell to fourteen transistors per memory cell, and also reduces the number of read enables that need to be routed to each cell from four to one. Altogether, for the described embodiment, there are eight buffers per bit, with a total of 2032 memory cells and eight (rather than thirty-two) read enables.</p><p>As can be seen in FIG. 2, the 8-entry register file of buffer <b>24</b> is organized such that every fourth entry shares the single read port bus. For example, IB<sub>0 </sub>shares the bus with IB<sub>4</sub>, IB<sub>1 </sub>shares the bus with IB<sub>5</sub>, IB<sub>2 </sub>shares the bus with IB<sub>6</sub>, and IB<sub>3 </sub>shares the bus with IB<sub>7</sub>. This approach optimizes area savings of by taking advantage of the consecutive entries read from the buffer.</p><p>Instead of implementing buffer <b>24</b> as a register file, it could also be implemented as a memory array, with an associated address index. Use further appreciated that the concept of the present invention can be extended to include a single write port, rather than the dual write port scheme shown in FIG. <b>1</b>. In the case of a single write port a simple on/even scheme may be employed in which odd entries (IB<sub>1</sub>, IB<sub>3</sub>, IB<sub>5</sub>, and IB<sub>7</sub>) are organized in one group, and even entries (IB<sub>0</sub>, IB<sub>2</sub>, IB<sub>4</sub>, and IB<sub>6</sub>) are organized in another group.</p><p>It should be understood that although the present invention has been described in conjunction with specific embodiments, numerous modifications and alterations could be made without departing from the scope of the present invention. Accordingly, the specification and drawings are to be regarded in an illustrative rather than a restrictive sense.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Jesse", "last_name": "Pan", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTEL CORPORATION"}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/38"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712205"}, {"primary": false, "label": "712E09054"}, {"primary": false, "label": "712206"}, {"primary": false, "label": "712214"}, {"primary": false, "label": "712215"}, {"primary": false, "label": "711110"}, {"primary": false, "label": "712E09055"}, {"primary": false, "label": "712204"}], "ecla_classes": [{"label": "G06F   9/38B"}, {"label": "G06F   9/38B8"}, {"label": "G06F   9/38E6"}], "cpc_classes": [{"label": "G06F   9/3853"}, {"label": "G06F   9/3802"}, {"label": "G06F   9/3814"}, {"label": "G06F   9/3853"}, {"label": "G06F   9/3802"}, {"label": "G06F   9/3814"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1999-10-12", "application_date": "1999-10-12", "family_members": [{"ucid": "US-6539469-B1", "titles": [{"lang": "EN", "text": "Rotator circular buffer with entries to store divided bundles of instructions from each cache line for optimized instruction supply"}]}]}