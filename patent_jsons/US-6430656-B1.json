{"patent_number": "US-6430656-B1", "publication_id": 73113252, "family_id": 23541457, "publication_date": "2002-08-06", "titles": [{"lang": "EN", "text": "Cache and management method using combined software and hardware congruence class selectors"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50359068\"><p>A cache memory provides a mechanism for storing and retrieving values wherein a hardware mechanism such as a partial address field selector is combined with an software generated selector in order to access specific congruence classes within a cache. Assignment of software generated selectors to specific types of data can be made in order to allow an operating system or application to efficiently manage cache usage.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00001\" num=\"1\"><claim-text>1. A computer system, comprising:</claim-text><claim-text>a processor that executes program instructions; </claim-text><claim-text>data storage including a plurality of congruence classes containing a plurality of sets; and </claim-text><claim-text>a cache controller that controls access to values stored within said data storage, </claim-text><claim-text>wherein said cache controller accesses said values using a combination of a portion of a memory address and a group selector to select a congruence class, and </claim-text><claim-text>wherein said combination is formed by a first bit field from said memory address and a second bit field formed said group selector, the bits of said second bit field being exclusive of said first bit field, and said combination of said first bit field and said second bit field form a congruence class selector for selecting said congruence class. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00002\" num=\"2\"><claim-text>2. The computer system of <claim-ref idref=\"US-6430656-B1-CLM-00001\">claim 1</claim-ref>, wherein said processor includes a special purpose register, and the contents of said special purpose register are communicated to said cache controller to produce said group selector.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00003\" num=\"3\"><claim-text>3. The computer system of <claim-ref idref=\"US-6430656-B1-CLM-00001\">claim 1</claim-ref>, wherein said processor supplies said group selector to said cache controller from a data access instruction containing said group selector in a bit field.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00004\" num=\"4\"><claim-text>4. The computer system of <claim-ref idref=\"US-6430656-B1-CLM-00001\">claim 1</claim-ref>, wherein said processor includes a general purpose register associated with a base register and the contents of said general purpose register are communicated to said cache controller to produce said group selector when an instruction that references said base register is processed by said processor.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00005\" num=\"5\"><claim-text>5. The computer system of <claim-ref idref=\"US-6430656-B1-CLM-00001\">claim 1</claim-ref>, wherein said group selector is associated with a particular application type of value and values of said particular application type are accessed from at least one congruence class associated with said group selector.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00006\" num=\"6\"><claim-text>6. The computer system of <claim-ref idref=\"US-6430656-B1-CLM-00001\">claim 1</claim-ref>, wherein said processor processes a request to allocate a memory block and further assigns said group selector associated with said memory block.</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00007\" num=\"7\"><claim-text>7. The computer system of <claim-ref idref=\"US-6430656-B1-CLM-00006\">claim 6</claim-ref>, wherein said group selector is. further stored in a data structure in memory that describes said memory block.</claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00008\" num=\"8\"><claim-text>8. The computer system of <claim-ref idref=\"US-6430656-B1-CLM-00001\">claim 1</claim-ref>, where said processor initializes a plurality of heaps and creates at least one group selector in association with each of said heaps.</claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00009\" num=\"9\"><claim-text>9. The computer system of <claim-ref idref=\"US-6430656-B1-CLM-00008\">claim 8</claim-ref>, wherein said processor accesses a value on a given one of said heaps and a heap group selector associated with said heap is embedded in a request for said value and communicated to said cache controller.</claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00010\" num=\"10\"><claim-text>10. A storage system, comprising:</claim-text><claim-text>data storage including a plurality of congruence classes containing a plurality of sets; and </claim-text><claim-text>a data storage controller that controls access to values stored within said data storage, </claim-text><claim-text>wherein said cache controller accesses said values using a combination of a portion of a memory address and a group selector to select a congruence class, and </claim-text><claim-text>wherein said combination is formed by a first bit field from said memory address and a second bit field formed said group selector, the bits of said second bit field being exclusive of said first bit field, and said combination of said first bit field and said second bit field form a congruence class selector for selecting said congruence class. </claim-text></claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00011\" num=\"11\"><claim-text>11. A method of accessing a cache memory in a computer system, said method comprising:</claim-text><claim-text>receiving a request to access a plurality of values, said request containing a representation of a non-address group selector and an address; </claim-text><claim-text>combining said group selector and a portion of said address to produce a congruence class selector, wherein said combining step combines a first bit field from said address and a second bit field formed by said group selector, the bits of said second bit field being exclusive of said first bit field, wherein the combination of said first and said second bit field form said congruence class selector; </claim-text><claim-text>selecting a congruence class based on said congruence class selector; and </claim-text><claim-text>in conformance with said selecting step, accessing said plurality of values from a set within said congruence class. </claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00012\" num=\"12\"><claim-text>12. The method of <claim-ref idref=\"US-6430656-B1-CLM-00011\">claim 11</claim-ref>, further comprising the step of determining said group selector from a special register in said processor.</claim-text></claim>"}, {"num": 13, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00013\" num=\"13\"><claim-text>13. The method of <claim-ref idref=\"US-6430656-B1-CLM-00011\">claim 11</claim-ref>, further comprising the steps of:</claim-text><claim-text>decoding a data access instruction; and </claim-text><claim-text>deriving said group selector from a field within an instruction executed by said processor. </claim-text></claim>"}, {"num": 14, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00014\" num=\"14\"><claim-text>14. The method of <claim-ref idref=\"US-6430656-B1-CLM-00011\">claim 11</claim-ref>, further comprising the steps of:</claim-text><claim-text>decoding a data access instruction; and </claim-text><claim-text>determining said group selector from a general purpose register associated with a base register specified by said instruction. </claim-text></claim>"}, {"num": 15, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00015\" num=\"15\"><claim-text>15. The method of <claim-ref idref=\"US-6430656-B1-CLM-00011\">claim 11</claim-ref>, further comprising the step of associating said group selector with a particular application type of value, and said accessing step further accesses a plurality of values of said particular application type.</claim-text></claim>"}, {"num": 16, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00016\" num=\"16\"><claim-text>16. The method of <claim-ref idref=\"US-6430656-B1-CLM-00011\">claim 11</claim-ref>, further comprising the steps of:</claim-text><claim-text>determining that an allocation of a memory block is for a particular application type; </claim-text><claim-text>allocating said memory block; and </claim-text><claim-text>responsive to said determining step, assigning at least one group selector for said memory block. </claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00017\" num=\"17\"><claim-text>17. The method of <claim-ref idref=\"US-6430656-B1-CLM-00016\">claim 16</claim-ref>, further comprising the step of storing said group selector in a data structure in memory that describes said memory block.</claim-text></claim>"}, {"num": 18, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00018\" num=\"18\"><claim-text>18. The method of <claim-ref idref=\"US-6430656-B1-CLM-00011\">claim 11</claim-ref>, further comprising the steps of:</claim-text><claim-text>initializing a plurality of heaps; and </claim-text><claim-text>creating at least one group selector associated with each of said heaps. </claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6430656-B1-CLM-00019\" num=\"19\"><claim-text>19. The method of <claim-ref idref=\"US-6430656-B1-CLM-00018\">claim 18</claim-ref>, further comprising the steps of:</claim-text><claim-text>accessing values allocated from one of said plurality of heaps, in response to an access direction; and </claim-text><claim-text>embedding an index value associated with said given heap in a result of said access direction to produce said request. </claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53612513\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>The present invention is related to the following application filed concurrently with this application: U.S. patent application Ser. No. 09/435,950 entitled \u201cPARTITIONED CACHE AND MANAGEMENT METHOD FOR SELECTIVELY CACHING DATA BY TYPE\u201d.</p><p>The present invention is a continuation to U.S. patent application Ser. No. 09/390,186 entitled \u201cCACHE MANAGEMENT MECHANISM TO ENABLE INFORMATION-TYPE DEPENDANT CACHE POLICIES\u201d filed Sep. 7, 1999 and assigned to the same assignee. The specification is incorporated herein by reference.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention generally relates to computer systems, and more specifically to an agent and method for managing a cache memory in a computer system. In particular, the present invention makes more efficient use of a cache by allocating specific class sets to specific types of program data and instructions.</p><p>2. Description of Related Art</p><p>The basic structure of a conventional computer system includes one or more processing units connected to various input/output devices for the user interface (such as a display monitor, keyboard and graphical pointing device), a permanent memory device (such as a hard disk, or a floppy diskette) for storing the computer's operating system and user programs, and a temporary memory device (such as random access memory or RAM) that is used by the processor(s) in carrying out program instructions. The evolution of computer processor architectures has transitioned from the now widely-accepted reduced instruction set computing (RISC) configurations, to so-called superscalar computer architectures, wherein multiple and concurrently operable execution units within the processor are integrated through a plurality of registers and control mechanisms.</p><p>The objective of superscalar architecture is to employ parallelism to maximize or substantially increase the number of program instructions (or \u201cmicro-operations\u201d) simultaneously processed by the multiple execution units during each interval of time (processor cycle), while ensuring that the order of instruction execution as defined by the programmer is reflected in the output. For example, the control mechanism must manage dependencies among the data being concurrently processed by the multiple execution units, and the control mechanism must ensure the integrity of data that may be operated on by multiple processes on multiple processors and potentially contained in multiple cache units. It is desirable to satisfy these objectives consistent with the further commercial objectives of increasing processing throughput, minimizing electronic device area and reducing complexity.</p><p>Both multiprocessor and uniprocessor systems usually use multi-level cache memories where typically each higher level is smaller and has a shorter access time. The cache accessed by the processor, and typically contained within the processor component of present systems, is typically the smallest cache.</p><p>Both operand data and instructions are cached, and data and instruction cache entries are typically loaded before they are needed by operation of prefetch units and branch prediction units. Called \u201cstreams\u201d, groups of instructions associated with predicted execution paths can be detected and loaded into cache memory before their actual execution. Likewise data patterns can be predicted by stride detection circuitry and loaded before operations requiring the data are executed.</p><p>Cache memories are typically organized in a matrix arrangement. One direction in the matrix corresponds to congruence classes and the other, equivalent sets within each congruence class. The congruence class partitioning divides the use of the cache with respect to information type, typically a portion of the address field of a memory location is used to partition the distribution of values from memory across the congruence class sets. In this way, it is only necessary to examine the entries within a given class in order to determine memory conflicts or whether a particular value at a given address is present or absent from the cache.</p><p>By dividing the cache into congruence classes, the efficiency of access to the cache is improved, but memory organization within a computer system may not provide for an efficient distribution of reuse patterns in the cache if the typical method of using a portion of a memory address as a class selector is followed. Such a method tends to randomize the association of memory with congruence classes rather than to optimize them. Increasing associativity is one solution, but a fully associative cache, which would be the ideal extreme solution, is not efficient in that a separate tag comparison is required for every entry in the cache when an entry is identified. To do this simultaneously requires a hardware comparator for every entry in the cache. The advantage of a cache with reduced associativity, is that a particular class selector can be used to reduce the number of locations for which a tag must be compared, and thus the number of comparators or comparison cycles required.</p><p>As semiconductor processes have improved, processor clock frequencies have generally increased more significantly than the latencies incurred when processors retrieve operand data and instructions from memory have decreased (i.e., decreases in memory access time). As measured in processor clock ticks, these latencies have increased significantly.</p><p>Processor architects have addressed this problem by incorporating several levels of cache to retain frequently used data and instructions closer to the processor (from a latency perspective), as well as using techniques to hide or overlap the incurred latencies, e.g., prefetching, speculative execution, out-of-order execution, and multi-threading.</p><p>These approaches have achieved varying success in alleviating the negative effects of waiting for retrieval of operand data and instructions from memory (or, in the case of multi-level cache hierarchies, from a more distant level in the hierarchy). Since processor core performance has improved, and a portion of the latency problem has been alleviated, the remaining cache misses have a greatly amplified negative impact on performance. Therefore, current trends strongly indicate an opportunity to improve performance by reducing the number of remaining cache misses.</p><p>Also, as semiconductor processes have improved, cache sizes have generally increased more than processor clock frequency. Caches typically retain more of the operand data and instructions used by the processor within a window determined by a number of processor clock ticks. In general, processor architects have implemented cache management methods that rely upon data and instruction usage patterns from the recent past as a predictor of data and instruction usage patterns in the near future. These techniques are based upon the principles of temporal and spatial locality, which state that within a given span of time, there is an increased probability that spatially localized regions of data and instructions will be reused.</p><p>While these methods generally improve performance for a wide variety of applications, they produce diminishing returns once a cache is large enough to hold a significant portion of the working set (or footprint) of the instructions and operand data for a given application. In general purpose, time sharing, multi-programmed computer systems, caches contain the working sets of multiple applications, middleware, and operating system code. As caches become larger, more of the operand data and code in these working sets can be retained within the cache. Current cache management methods that favor recently used instructions and operand data, may allow a less valuable \u201cfringe\u201d part of a currently executing working set to displace a highly valuable \u201ccore\u201d of a currently dormant working set that will resume execution in the near future.</p><p>In light of the foregoing, given the increasing positive impact of cache miss reduction on computer system performance, and given the decreasing returns yielded by presently used cache management methods, it would be desirable to implement a cache method and a cache architecture that will advantageously manage the retention of operand data and instructions within a cache to improve availability and latency.</p><h4>SUMMARY OF THE INVENTION</h4><p>It is therefore one object of the present invention to provide an improved cache memory for a computer system.</p><p>It is another object of the present invention to provide a computer system using such a cache memory.</p><p>It is yet another object of the present invention to provide a computer system and processor that provide more efficient caching of instruction and data values by selectively assigning cache class sets to particular types of instruction and data values.</p><p>The foregoing objects are achieved in a method and apparatus for operating a cache memory in a computer system wherein the congruence class selector is formed by a portion of a memory address combined with a group selector. The group selector may be provided by a special purpose register in a processor in the computer system, may be provided by an immediate operand field, or may be provided by a general purpose register associated with a base register referenced by a data access instruction. A collection of heaps may be created for memory allocation and one or more group selectors associated with the heaps. The group selector may be stored in a structure describing an allocated memory block for retrieval by the processor when accessing that block. The congruence class selector may be a combination of a partial address bit mask and the group selector.</p><p>The above as well as additional objectives, features, and advantages of the present invention will become apparent in the following detailed written description.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives, and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:</p><p>FIG. 1 is an electrical block diagram of a multiprocessor computing system in which the present invention may be practiced, depicting core execution units, system memory, buses and bus bridges;</p><p>FIG. 2 is a pictoral diagram depicting information in a cache memory in accordance with an embodiment of the present invention;</p><p>FIG. 3 is a pictoral diagram depicting the relationship between cache data storage and physical memory in accordance with an embodiment of the present invention; and</p><p>FIG. 4 is a pictoral diagram depicting the relationship between virtual, real and physical memory in accordance with an embodiment of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DESCRIPTION OF THE ILLUSTRATIVE EMBODIMENTS</h4><p>With reference now to the figures, and in particular with reference to FIG. 1, one embodiment of a multiprocessor computing system is shown in which the present invention can be practiced. The computing system is a connection of local processor groups <b>78</b> that perform program operations. This arrangement is particularly useful for general purpose computing for both commercial and scientific/engineering applications. Local processor groups comprise cores <b>60</b> that may contain caches or other local storage and the processor groups share a level of L<b>2</b> cache <b>66</b>A, that can be accessed by all of the processors in a group, and optionally by other local processing groups through bridges <b>76</b>.</p><p>Referring now to FIG. 2, information elements within cache <b>10</b> are depicted. Directory <b>20</b> stores information about values stored in information array <b>25</b>. This information is not limited to, but includes address information and status of the values, including whether a value has been modified since it was loaded into cache <b>10</b>. The information array consists of congruence classes <b>24</b> (depicted as horizontal rows) and associativity sets <b>22</b> (depicted as columns). By using an address field <b>13</b> from a complete address <b>11</b>, values can be pigeonholed into particular congruence classes. The lower portion <b>14</b> of address <b>11</b> is used to select a particular address from the entry in cache <b>10</b>, in this example 256 values are stored in each cache entry since there are <b>8</b> bits in the lower portion of the address. This addressing method produces an assignment of congruence classes <b>24</b> that is evenly distributed among addresses, but does not take in to account that particular address ranges may be more frequently needed. The repetitive nature of striping that occurs due to the repeating occurrence of address field <b>13</b> for every value of the upper portion <b>12</b> of address <b>11</b>, causes each congruence class to be used for more than one address range in memory, so if two frequently used groups of values are located in regions in memory that map to the same congruence class in cache <b>10</b> they may alternatively force the other out of cache <b>10</b> while some other values in cache may be accessed much less frequently, but due to their location in memory, they will not be rolled out of cache to advantageously supply storage for one of the two frequently used groups. Therefore, existing systems do not effectively control the relationship of the congruence classes <b>24</b>, with the partitioning of information in memory.</p><p>Sometimes it is advantageous for groups of values to cause other groups of values to be rolled out of cache <b>10</b>. This is true when the groups of values are from applications that are mutually exclusive. When instructions or data from applications will not be needed at the same time, it would be advantageous to arrange the cache storage so as to have one application value group replace a second application value group.</p><p>Another application in which encouraging cache rollout provides an advantage is for data that is only used once. In this extreme example, the cache is actually providing no advantage, since the data will always be rolled out without being reused. If a small region of cache is assigned to allocations for this type of data, the rollout will occur earlier than for random allocations, and this type of data can be prevented from polluting the other regions of cache where reusable values are being stored.</p><p>Within the exemplary computer system, three memory address models are used. Physical memory refers to memory locations that are actually populated with storage locations capable of storing values. The physical memory is addressed by the use of logic signals that correspond to a physical address. Real memory corresponds to the entire address space that may be populated by physical memory and encompasses the entire memory space that may be addressed by a processor or other execution unit. The real memory may incorporate address translation, in which case the physical addresses and real addresses might differ for an actual physical memory location, but that is not a critical distinction for understanding the operation of the invention. The real address space is generally larger than the physical address space unless the real address space is fully populated with physical memory storage devices.</p><p>Virtual memory is generally an arbitrary address space that is much larger that the real address space. A virtual memory manager maps the pages in real memory to address regions in virtual memory, although in some systems the virtual memory manager may directly map physical addresses to address regions in virtual memory. Generally, virtual pages can be mapped to any real page and multiple virtual pages can be mapped to the same real page.</p><p>Referring now to FIG. 3, the relationship of the congruence classes and physical memory is depicted. For systems in which a real-to-physical address translation occurs, the mapping shown would correspond to real addresses only, as the physical pages could be in different order. In accordance with the invention, partition <b>26</b> is created for storing values associated with a particular application type. The application type of a value in cache is not restricted to \u201capplications\u201d or user programs, but is used herein to mean any type of program instructions or data. For example, the values might be the instructions for a frequently used operating system routine that the system's developer wants to keep pinned in cache. For example, the application type of value may be helper operating systems routines or data used by the operating system, it could be application data or routines run by the operating system, firmware shadow images in memory, video memory or any other code or operand data that is stored in the memory of the computer system.</p><p>In the exemplary embodiment, 16 congruence classes have been grouped in partition <b>26</b>. Since the entry size is 256 words for the exemplary cache, this yields a partition size that is 4096 words, which is the page size associated with the operating system of the exemplary embodiment. Partition <b>26</b> maps to more than one page in physical memory <b>28</b>. Blocks <b>0</b>, <b>64</b> and <b>128</b> are illustrated as mapping to partition <b>26</b> and other blocks at intervals of 64 pages in memory will likewise map to the partition. This creates a striping effect through memory. An N-way associative cache can support N pages mapped in this fashion without causing any of the values to be rolled out of the cache when other pages are requested. So, for this example, 8 pages can be assigned from address regions corresponding to partition <b>26</b> without causing a page to roll out when another page is loaded.</p><p>In order to maintain critical blocks pinned in partition <b>26</b>, the other blocks in excess of the associativity number that are mapped to partition <b>26</b> should be unused, or the loading of values from the other blocks may cause the values from the pinned block to be overwritten (victimized and flushed from the cache).</p><p>In one embodiment of the invention, the above described relationship of congruence classes and real pages is used to maintain blocks pinned in cache. Referring to FIG. 4, a relationship of memory maps is demonstrated. To efficiently utilize memory, the ability to selectively map physical pages to real addresses provided in computers with memory banking controllers is used to advantage. By selectively placing physical memory pages at only N locations within a stripe associated with a given congruence class, where N is the associativity number, that congruence class can be associated exclusively with N pages in memory. As long as those pages remain pinned in memory, the cache will retain the values corresponding to those pages.</p><p>Although the ability to map physical pages out of regions where striping would cause potential undesired rollout from cache is advantageous, the option of leaving regions of memory unused will still produce the beneficial results of the present invention, albeit with some reduction in available physical memory.</p><p>There are other variations on this technique that will benefit other computer system uses. For example, groups of related applications or related subroutines from one application may be loaded into the cache partition, while another group from an unrelated application may be located in memory pages associated with the same partition so as to cause the values from the first group to roll out when the second group is loaded. This is a useful control when the first group of values is not needed at the same time as the second group of values. Controlling the rollout in this way improves over the quasi-random results that would have been obtained through traditional techniques.</p><p>Real memory map <b>34</b> shows the presence of blocks <b>0</b>, <b>64</b>, and <b>128</b> that are associated with partition <b>26</b> of the preferred embodiment. Physical memory map <b>32</b>, shows that blocks <b>64</b> and <b>128</b> can be absent from the physical memory, eliminating the problem of unused pages that would occur in the operation of this embodiment.</p><p>Virtual memory map <b>36</b> shows how block <b>0</b> from the real memory map <b>34</b> can be located arbitrarily in virtual memory. This allows the operating system to assign memory pages in such a way that cache rollout can be prevented or encouraged by the above described techniques. In a virtual memory managed operating system, there is generally a much larger virtual address space than the real address space. Also, the real address space can often be larger than the physical memory installed. Pages in virtual memory can be mapped in any order and at any location to pages in real memory. By selecting an area in virtual memory in which to map the stripes of a partition, the partition's memory can be made contiguous or placed in areas where the operating system can easily keep track of the partition's values.</p><p>Referring again to FIG. 2, a second embodiment of the invention removes problems associated with striping and provides an alternative technique for preventing or encouraging cache rollout for particular application type of values. Within address <b>11</b>, address field <b>13</b> that was used to select the congruence class in the prior example can be reduced to field <b>16</b>. Address field <b>16</b> can then be used as a congruence class selector for the cache in combination with a group selector that replaces the bits that were supplied by the remaining bits of address field <b>13</b> in the previous embodiment. In order to access the values in cache, the group selector as well as the address must be known by the software or hardware accessing the cache.</p><p>The group selector acts in conjunction with load or store operations and may be supplied as an immediate bit field or value in an instruction sequence, may be supplied by a special purpose register in a processor, or by a general purpose register that is associated with a base register and whose contents are then passed to the cache when the base register is referenced. Alternatively other techniques commonly used in the art to produce address indexing might be used. It should be noted, however, that this group selector is not an address in that the selector can be arbitrary and does not correspond to a location in memory and it is used in conjunction with a portion of the address in order to access values in a particular congruence class.</p><p>This embodiment of the invention does not have the striping problem of the first embodiment. Here, the assignment of a unique group selector for a partition of one or more congruence classes prevents the overlapping regions due to the relationship of the address and the congruence class selector. The unique group selector provides a mechanism for avoiding a conflict, so the operating system or other mechanism can easily manage the pinning and releasing of blocks of memory in cache and can easily prevent or encourage rollout as described in association with the first embodiment. In addition, there is no restriction in the second embodiment with respect to the size of the memory blocks. Since the paging architecture is not being used to produce the relationship of memory to cache, the block sizes are not restricted to pages. In general, assignment of the same group selector to groups of values in excess of the associativity number of the cache will encourage rollout and assignment of different group selectors will prevent rollout.</p><p>Within an operating system, memory is generally managed in terms of heaps and page pools. By providing an operating system interface that can allow an application and the operating system itself to control memory allocation in the manner described by the invention, better control of the cache is achieved. The page manager may store the group selector within the information describing a memory block, the operating system or applications may initialize a number of heaps, where each heap is associated with a given group selector and therefore partition. This can allow the operating system or applications to effectively control rollout from the cache. The group selector can be embedded in the data structure describing the heap or associated with pointers allocated by heap allocation routines to allow the automatic loading of the group selector when referencing values on the heap. In this way, the special purpose register, general purpose register or immediate instructions described above can be used in conjunction with the virtual memory manager or a page manager to communicate the group selector to the cache.</p><p>While the above techniques apply to computer systems with cache memories, and specifically, to a processor system with cache memories, they are adaptable and contemplated to be useful in conjunction with other memory structures and other storage devices within a computer system. For example, the method might be used for partitioning caches in direct access storage devices, as well as the cache of the illustrative embodiments.</p><p>Although the invention has been described with reference to specific embodiments, this description is not meant to be construed in a limiting sense. Various modifications of the disclosed embodiments, as well as alternative embodiments of the invention, will become apparent to persons skilled in the art upon reference to the description of the invention. It is therefore contemplated that such modifications can be made without departing from the spirit or scope of the present invention as defined in the appended claims.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Ravi Kumar", "last_name": "Arimilli", "name": ""}, {"first_name": "Bryan Ronald", "last_name": "Hunt", "name": ""}, {"first_name": "William John", "last_name": "Starke", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTERNATIONAL BUSINESS MACHINES CORPORATION"}, {"first_name": "", "last_name": "INTERNATIONAL BUSINESS MACHINES CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/06"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/12        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711128"}, {"primary": false, "label": "711145"}, {"primary": false, "label": "711129"}, {"primary": false, "label": "711E1207"}], "ecla_classes": [{"label": "G06F  12/12B"}], "cpc_classes": [{"label": "G06F  12/121"}, {"label": "G06F  12/121"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1999-09-07", "application_date": "1999-11-09", "family_members": [{"ucid": "US-6430656-B1", "titles": [{"lang": "EN", "text": "Cache and management method using combined software and hardware congruence class selectors"}]}, {"ucid": "US-6425058-B1", "titles": [{"lang": "EN", "text": "Cache management mechanism to enable information-type dependent cache policies"}]}]}