{"patent_number": "US-20020042871-A1", "publication_id": 75758087, "family_id": 16012633, "publication_date": "2002-04-11", "titles": [{"lang": "EN", "text": "DATA PROCESSOR HAVING AN INSTRUCTION DECODER"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA48321198\"><p id=\"A-0001\">In a data processor, using a format field which specifies the number of operation fields of an instruction code and an order of execution of operations, the number of operations and the order of operation executions are-flexibly controlled and the necessity of a null operation is reduced, and decoders operate in parallel each decoding only one operation having a specific function which has a dependency on an operation execution mechanism, so that the operation fields of the instruction code are decoded in parallel by a number of decoders. While the data processor is basically a VLIW type data processor, more types of operations can be specified by the operation fields, and coding efficiency of instructions is improved since the number of operation fields and the order of operation executions are flexibly controlled and the necessity of a null operation is reduced by means of the format field which specifies the number of the operation and the order of the operation executions. </p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20020042871-A1-CLM-00001\" num=\"1\"><claim-text><b>1</b>. A data processor, comprising: \n<claim-text>an instruction decoder for decoding an instruction code and outputting a control signal, said instruction code consisting of at least one operation field which specifies the type of an operation to be executed and a format field which specifies the number of said operation field; and </claim-text><claim-text>a plurality of operating means for, which are connected to said instruction decoder, executing the instruction in accordance with the control signal outputted from said instruction decoder; </claim-text><claim-text>wherein when said instruction decoder decodes a first instruction code including a first number of operation fields, \n<claim-text>said instruction decoder outputs a first control signal, and </claim-text>\n<claim-text>said plurality of operating means execute said first number of operations in accordance with said first control signal, and </claim-text>\n</claim-text><claim-text>when said instruction decoder decodes a second instruction code including a second number of operation fields and having the same code length with said first instruction code, said second number being different from said first number, \n<claim-text>said instruction decoder outputs a second control signal different from said first control sig-nal, and </claim-text>\n<claim-text>said plurality of operating means execute said second number of operations in accordance with said second control signal. </claim-text>\n</claim-text></claim-text></claim>"}, {"num": 2, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20020042871-A1-CLM-00002\" num=\"2\"><claim-text><b>2</b>. A data processor, comprising: \n<claim-text>an instruction decoder for decoding an instruction code; </claim-text><claim-text>a control unit for, which is connected to said instruction decoder, outputting a control signal in accordance with a decoded result by said instruction decoder; and </claim-text><claim-text>first operating means and second operating means for, which are connected to said control unit, executing an instruction in accordance with the control signal outputted from said control unit; </claim-text><claim-text>wherein when said instruction decoder decodes an instruction code consisting of at least a first operation field and a second operation field, each specifying a type of an operation to be executed, and a format field specifying the number of operation fields and an order of execution of operations specified by the operation fields, </claim-text><claim-text>said control unit outputs a first control signal and a second control signal depending on operation types specified by said first operation field and said second operation field, respectively, and in accordance with the order of execution of operations specified by said format field, </claim-text><claim-text>said first operating means executes a first operation in accordance with said first control signal, and </claim-text><claim-text>said second operating means executes a second operation in accordance with said second control signal. </claim-text></claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-20020042871-A1-CLM-00003\" num=\"3\"><claim-text><b>3</b>. The data processor as set forth in <claim-ref idref=\"US-20020042871-A1-CLM-00002\">claim 2</claim-ref>, wherein \n<claim-text>when said instruction decoder decodes a first instruction code in which sequential execution of the first operation specified by said first operation field and the second operation specified by said second operation field is specified by said format field, \n<claim-text>said instruction decoder outputs a first decoded result while said control unit outputs the first control signal at a first time point in accordance with said first decoded result and then outputs the second control signal at a second time point in accordance with said first decoded result, so that said first operating means executes said first operation in accordance with said first control signal and said second operating means thereafter executes said second operation in accordance with said second control signal, and </claim-text>\n</claim-text><claim-text>when said instruction decoder decodes a second instruction code in which simultaneous execution of a third operation specified by said first operation field and a fourth operation specified by said second operation field is specified by said format field, \n<claim-text>said instruction decoder outputs a second decoded result while said control unit outputs a third control signal and a fourth control signal at the same time in accordance with said second decoded result, so that said first operating means and said second operating means simultaneously execute said third operation and said fourth operation in accordance with said third control signal and said fourth control signal, respectively. </claim-text>\n</claim-text></claim-text></claim>"}, {"num": 4, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20020042871-A1-CLM-00004\" num=\"4\"><claim-text><b>4</b>. A data processor, comprising: \n<claim-text>a first decoder for decoding a predetermined field of an instruction code and outputting a control signal; </claim-text><claim-text>a first operation execution unit which is connected to said first decoder, and operates in accordance with the control signal outputted from said first decoder; </claim-text><claim-text>a second decoder for decoding said predetermined field and outputting a control signal; and </claim-text><claim-text>second operation execution unit which is connected to said second decoder, and operates in accordance with the control signal outputted from said second decoder; </claim-text><claim-text>wherein when a first instruction code in which a first type of operation is specified by said predetermined field is decoded, \n<claim-text>said first and said second decoders decode said predetermined field at the same time, and said first decoder outputs a first control signal while said second decoder outputs a second control signal which is different from said first control signal, </claim-text>\n<claim-text>said first operation execution unit executes a first operation in accordance with said first control signal, and said second operation execution unit executes no operation in accordance with said second control signal, and </claim-text>\n</claim-text><claim-text>when a second instruction code in which a second type of operation is specified by said predetermined field, \n<claim-text>said first and said second decoders decode said predetermined field at the same time, and said first decoder outputs a third control signal while said second decoder outputs a fourth control signal which is different from said third control signal, and </claim-text>\n<claim-text>said first operation execution unit executes no operation in accordance with said third control signal, and said second operation execution unit executes a second operation in accordance with said fourth control signal. </claim-text>\n</claim-text></claim-text></claim>"}, {"num": 5, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20020042871-A1-CLM-00005\" num=\"5\"><claim-text><b>5</b>. A data processor, comprising: \n<claim-text>a first decoder for decoding a first operation field of an instruction code and outputting a first control signal; </claim-text><claim-text>a second decoder for decoding a second operation field of an instruction code which is different from said first operation field and outputting a second control signal; </claim-text><claim-text>an output processing unit which is connected to said first and said second decoders, inputs both said first and said second control signals and selectively outputs one of said first and said second control signals; and </claim-text><claim-text>an operation execution unit which is connected to said output processing unit, and operates in accordance with a control signal outputted from said output processing unit; </claim-text><claim-text>wherein when a first instruction code in which a first operation is specified by said first operation field and a second operation is specified by said second operation field is decoded, said first decoder decodes said first operation field and said second decoder decodes said second operation field at the same time, said first decoder outputs the first control signal and said second decoder outputs the second control signal, and said output processing unit selectively outputs said first control signal to said operation execution unit, </claim-text><claim-text>and when a second instruction code in which a third operation is specified by said first operation field and said first operation is specified by said second operation field, said first decoder decodes said first operation field and said second decoder decodes said second operation field at the same time, said first decoder outputs a third control signal and said second decoder outputs a fourth control signal, and said output processing unit selectively outputs said fourth control signal to said operation execution unit, </claim-text><claim-text>whereby said operation execution unit executes said first operation both when said first operation is specified by said first operation field and when said first operation is specified by said second operation field.</claim-text></claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES68346408\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><summary-of-invention><h4>BACKGROUND OF THE INVENTION </h4><p id=\"P-0001\" num=\"0001\">[0001] 1. Field of the invention </p><p id=\"P-0002\" num=\"0002\">[0002] The present invention relates to a data processor for performing a plurality of operations in parallel, and more particularly to a data processor for performing a plurality of operations in parallel at a high efficiency by executing a so-called VLIW (Very Long Instruction Word) type instruction which specifies a plurality of operations by one instruction. </p><p id=\"P-0003\" num=\"0003\">[0003] 2. Description of Related Art </p><p id=\"P-0004\" num=\"0004\">[0004] As a data processor for performing operations at a high speed utilizing parallelism of instruction levels, data processors adopting superscalar type or VLIW type parallel operation techniques have been already proposed. So-called superscalar is a parallel operation technique in which parallelism of instruction levels is detected by hardware from an instruction stream and a plurality of instructions are then executed in parallel. </p><p id=\"P-0005\" num=\"0005\">[0005] On the other hand, the VLIW technique is a parallel operation technique in which one instruction consists of a plurality of parallel executable operations which are detected and encoded by a compiler at compiling time. A plurality of operations which are specified by this long instruction word are executed in parallel. These types of conventional data processors are described in detail in \u201cInstruction-Level Parallelism\u201d, B. R. Rau and J. A. Fisher, The Journal of Supercomputing, Vol. 7, No. 1/2, 1993, for example. </p><p id=\"P-0006\" num=\"0006\">[0006] The conventional superscalar type data processor is advantageous in being capable of executing instructions that were generated in the past without translating. However, since the number of instructions which are executable in parallel is not constant, it is necessary to specify instructions which are executable in parallel or to align instructions which are to be inputted to an instruction decoder in accordance with the number of instructions which are executable in parallel. This imposes a large load on the decoder hardware. </p><p id=\"P-0007\" num=\"0007\">[0007] Further, since the conventional VLIW type data processor guarantees that instructions have the same length and all of a plurality of operations which are described within one instruction can be executed in parallel, the problem of an increased load on the decoder hardware is not generated unlike in the conventional superscalar type data processor as mentioned above. However, since the conventional VLIW type data processor consumes one instruction even when there is no operations which can be executed in parallel, a number of operation fields specifying null operations (No Operation: NOP) are generated, whereby the amount of instruction code becomes very big. In addition, in the conventional VLIW type data processor, types of operations which can be specified by respective operation fields are limited to simplify the instruction decoder and the operation mechanism. Because of the standardized method of specifying operation, flexibility of assigning operations within one instruction is small, and therefore the instruction code efficiency is poor. </p><h4>SUMMARY OF THE INVENTION </h4><p id=\"P-0008\" num=\"0008\">[0008] The present invention has been made to overcome these disadvantages of the prior art as mentioned above. The present invention therefore aims to obtain a data processor which is basically of the VLIW type but achieves an improved instruction code efficiency, in which the necessity of specifying null operations is reduced by flexibly controlling the number and the order of operations, using a format field which specifies the number of the operation fields and the order of the operations. At the same time, decoders decode only operations of specific functions depending on executing mechanisms in parallel. With decoding the respective operation fields by a number of simple decoders, the present invention increases the number of operations which can be specified by the respective operation fields. </p><p id=\"P-0009\" num=\"0009\">[0009] A data processor according to the present invention comprises: an instruction decoder for decoding an instruction code consisting at least one operation field-which specifies the type of an operation to be executed and a format field which specifies the number of the operation fields and outputting control signals; and a plurality of operating means which are connected to the instruction decoder for executing the instruction in accordance with the control signals outputted from the instruction decoder. In the data processor, when the instruction decoder decodes a first instruction code which includes a first number of operation fields, the instruction decoder outputs a first set of control signals, and the plurality of operating means execute the first number of operations in accordance with the first set of control signals, and when the instruction decoder decodes a second instruction code which includes a second number of operation fields and has the same code length with the first instruction code, the second number being different from the first number, the instruction decoder outputs a second set of control signals different from the first set of control signals, and the plurality of operating means execute the second number of operations in accordance with the second set of control signals. </p><p id=\"P-0010\" num=\"0010\">[0010] A data processor according to the present invention comprises: an instruction decoder for decoding an instruction code; a control unit which is connected to the instruction decoder to output control signals in accordance with decoded results by the instruction decoder; and first operating means and second operating means which are connected to the instruction decoder for executing an instruction in accordance with the control signals outputted from the control unit. In the data processor, when the instruction decoder decodes an instruction code which consists of at least a first operation field and a second operation field, each specifying an operation to be executed, and a format field which specifies the number of operation fields and the order of executing operations specified by the operation fields, the control unit outputs a first control signal and a second control signal in accordance with the order of executing operations specified by the format field and operation types specified by the first operation field and the second operation field, the first operating means executes the first operation in accordance with the first control signal, and the second operating means executes the second operation in accordance with the second control signal. </p><p id=\"P-0011\" num=\"0011\">[0011] In the data processor having the configuration as mentioned above, when the instruction decoder decodes a first instruction code in which sequential execution of the first operation specified by the first operation field and the second operation specified by second operation field is specified by the format field, the instruction decoder outputs a first decoded result while the control unit outputs the first control signal at a first time point and then outputs the second control signal at a second time point in accordance with the first decoded result, so that the first operating means executes the first operation in accordance with the first control signal and the second operating means thereafter executes the second operation in accordance with the second control signal, and when the instruction decoder decodes a second instruction code in which simultaneous execution of a third operation specified by the first operation field and a fourth operation specified by the second operation field is specified by the format field, the instruction decoder outputs a second decoded result while the control unit outputs a third control signal and a fourth control signal at the same time in accordance with the second decoded result, so that the first operating means and the second operating means simultaneously execute the third operation and the fourth operation in accordance with the third control signal and the fourth control signal, respectively. </p><p id=\"P-0012\" num=\"0012\">[0012] A data processor according to the present invention comprises: a first decoder for decoding a predetermined field of an instruction code and outputting a control signal; a first operation execution unit which is connected to the first decoder to operate in accordance with the control signal outputted from the first decoder; a second decoder for decoding the predetermined field and outputting a control signal; and a second operation execution unit which is connected to the second decoder to operate in accordance with the control signal outputted from the second decoder. In the data processor, when a first instruction code in which a first type of operation is specified by the predetermined field is decoded, the first and the second decoders decode the predetermined field at the same time, the first decoder outputs a first control signal while the second decoder outputs a second control signal different from the first control signal, the first operation execution unit executes a first operation in accordance with the first control signal, the second operation execution unit executes no operation in accordance with the second control signal, and when a second instruction code in which a second type of operation is specified by the predetermined field is decoded, the first and the second decoders decode the predetermined field at the same time, the first decoder outputs a third control signal while the second decoder-outputs a fourth control signal which is different from the third control signal, the first operation execution unit executes no operation in accordance with the third control signal, the second operation execution unit executes a second operation in accordance with the fourth control signal. </p><p id=\"P-0013\" num=\"0013\">[0013] A data processor according to the present invention comprises: a first decoder for decoding a first operation field of an instruction code and outputting a first control signal; a second decoder for decoding a second operation field different from the first operation field and outputting a second control signal; an output processing unit which is connected to the first and the second decoders to input both the first and the second control signals and selectively outputs one of the first and the second control signals; and an operation execution unit which is connected to the output processing unit to operate in accordance with a control signal outputted from the output processing unit. In the data processor, when a first instruction code in which a first operation is specified by the first operation field and a second operation is specified by the second operation field is decoded, the first decoder decodes the first operation field and the second decoder decodes the second operation field at the same time, the first decoder outputs the first control signal and the second decoder outputs the second control signal, and the output processing unit selectively outputs the first control signal to the operation execution unit, and when a second instruction code in which a third operation is specified by the first operation field and the first operation-is specified by the second operation field is decoded, the first decoder decodes the first operation field and the second decoder decodes the second operation field at the same time, the first decoder outputs a third control signal and the second decoder outputs a fourth control signal, and the output processing unit selectively outputs the fourth control signal to the operation execution unit, whereby the operation execution unit executes the first operation both when the first operation is specified by the first operation field and when the first operation is specified by the second operation field. </p><p id=\"P-0014\" num=\"0014\">[0014] The above and further objects and features of the invention will more fully be apparent from the following detailed description with accompanying drawings.</p></summary-of-invention><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS </h4><p id=\"P-0015\" num=\"0015\">[0015]FIG. 1 is a schematic diagram showing an instruction format used in a data processor according to a first embodiment of the present invention; </p><p id=\"P-0016\" num=\"0016\">[0016]FIG. 2 is a list showing values and meanings of format fields of FIG. 1; </p><p id=\"P-0017\" num=\"0017\">[0017]FIG. 3 is a schematic diagram showing operation codes of a short format which can be specified by operation fields of the instruction format of FIG. 1; </p><p id=\"P-0018\" num=\"0018\">[0018]FIG. 4 is a schematic diagram showing operation codes of a long format which can be specified by operation fields of the instruction format of FIG. 1; </p><p id=\"P-0019\" num=\"0019\">[0019]FIG. 5 is a list showing addressing modes which can be specified by an operation code field of the long format of FIG. 4; </p><p id=\"P-0020\" num=\"0020\">[0020]FIG. 6 is a list showing the contents of a field which specifies truth/false judging conditions of a comparison operation; </p><p id=\"P-0021\" num=\"0021\">[0021]FIG. 7 is a schematic diagram showing a register configuration used in the data processor of the present invention; </p><p id=\"P-0022\" num=\"0022\">[0022]FIG. 8 is a schematic diagram showing a configuration of a first half portion of a processor status word used in the data processor of the present invention; </p><p id=\"P-0023\" num=\"0023\">[0023]FIG. 9 is a schematic diagram showing a configuration of a last half portion of a processor status word used in the data processor of the present invention; </p><p id=\"P-0024\" num=\"0024\">[0024]FIG. 10 is a block diagram showing an example of an overall configuration of the data processor according to the first embodiment of the present invention; </p><p id=\"P-0025\" num=\"0025\">[0025]FIG. 11 is a block diagram showing an example of a configuration of an instruction mapper and an instruction decoder of the data processor according to the first embodiment of the present invention; </p><p id=\"P-0026\" num=\"0026\">[0026]FIG. 12 is a schematic diagram showing an example of a program which is executed by the data processor according to the present invention, e.g., a source program described in the FORTRAN language for calculating the sum of products of elements belonging to arrays A and B; </p><p id=\"P-0027\" num=\"0027\">[0027]FIG. 13 is a schematic diagram showing an assembler program which is obtained by translating the source program shown in FIG. 12 into an assembler language; </p><p id=\"P-0028\" num=\"0028\">[0028]FIG. 14 is a schematic diagram showing an assembler program which is obtained by translating the source program shown in FIG. 12 by unrolling loops of the source program shown in FIG. 12 in such a manner that the four loops of the source program are translated into one loop; </p><p id=\"P-0029\" num=\"0029\">[0029]FIG. 13 is a schematic diagram showing an example of a program which is executed by the data processor according to the present invention, e.g., a source program for examining elements of an array X and counting the number of elements whose values exceed a constant value (XLIMIT); </p><p id=\"P-0030\" num=\"0030\">[0030]FIG. 16 is a schematic diagram showing an assembler program which is obtained by translating the source program shown in FIG. <b>15</b> into an assembler language; </p><p id=\"P-0031\" num=\"0031\">[0031]FIG. 17 is a schematic diagram showing an example of a program which is executed by the data processor according to the present invention, e.g., a source program described in the C-language for manipulating pointer; </p><p id=\"P-0032\" num=\"0032\">[0032]FIG. 18 is a schematic diagram showing an assembler program which is obtained by translating the source program shown in FIG. 17 into an assembler language; </p><p id=\"P-0033\" num=\"0033\">[0033]FIG. 19 is a schematic diagram showing an example of a program which is executed by the data processor according to the present invention, e.g., a source program described in the C-language in which conditional statements (if statements) are nested; </p><p id=\"P-0034\" num=\"0034\">[0034]FIG. 20 is a schematic diagram showing an assembler program which is obtained by translating the source program shown in FIG. 19 into an assembler language; </p><p id=\"P-0035\" num=\"0035\">[0035]FIG. 21 is a schematic diagram showing an instruction format used in a data processor according to a second embodiment of the present invention; </p><p id=\"P-0036\" num=\"0036\">[0036]FIG. 22 is a list showing values and meanings of format fields shown FIG. 21; </p><p id=\"P-0037\" num=\"0037\">[0037]FIG. 23 is a block diagram showing an example of an overall configuration of the data processor according to the second embodiment of the present invention; </p><p id=\"P-0038\" num=\"0038\">[0038]FIG. 24 is a block diagram showing an example of a configuration of an instruction mapper and an instruction decoder of the data processor according to the second embodiment of the present invention; </p><p id=\"P-0039\" num=\"0039\">[0039]FIG. 25 is a schematic diagram showing an instruction format used in a data processor according to a third embodiment of the present invention; </p><p id=\"P-0040\" num=\"0040\">[0040]FIG. 26 is a list showing values and meanings of format fields shown in FIG. 20; and </p><p id=\"P-0041\" num=\"0041\">[0041]FIG. 27 is a block diagram showing an example of an overall configuration of the data processor according to the third embodiment of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DESCRIPTION OF THE PREFERRED EMBODIMENTS </h4><p id=\"P-0042\" num=\"0042\">[0042] In the following, a data processor according to the present invention will be described with reference to drawings showing preferred embodiments. </p><p id=\"P-0043\" num=\"0043\">[0043] [First Embodiment]</p><p id=\"P-0044\" num=\"0044\">[0044] (1) \u201cInstruction Set and Register\u201d</p><p id=\"P-0045\" num=\"0045\">[0045]FIG. 1 shows an instruction format used in a data processor according to a first embodiment of the present invention. Two types of instruction formats are prepared to be used in the data processor according to the present invention. </p><p id=\"P-0046\" num=\"0046\">[0046] In FIG. 1, reference numeral <b>1</b> designates a format of a 3-operation instruction consisting of one format field (FM) <b>10</b> and three operation fields <b>11</b>, <b>12</b> and <b>13</b>, and reference numeral <b>2</b> designates a format of a 2-operation instruction consisting of one format field <b>10</b> and two operation fields <b>14</b> and <b>15</b>. Instructions used in the data processor according to the present invention have a fixed length of eight bytes (64 bits). Both the 3-operation instruction of a format <b>1</b> and the 2-operation instruction of a format <b>2</b> shown in FIG. 1 each have a length of eight bytes in total. </p><p id=\"P-0047\" num=\"0047\">[0047] In the 3-operation instruction of the format <b>1</b>, the three operation fields <b>11</b>, <b>12</b> and <b>13</b> each specify one operation code (operation<sub>\u2014</sub>0, operation<sub>\u2014</sub>1 or operation<sub>\u2014</sub>2) of a 20-bit short format. In the 2-operation instruction of the format <b>2</b>, the two operation fields <b>14</b> and <b>15</b> specify two operations in total, i.e., the operation field <b>14</b> specifies one operation code of the 20-bit short format (operation<sub>\u2014</sub>0) while the operation field <b>15</b> specifies one operation code of a 40-bit long format (operation<sub>\u2014</sub>1). </p><p id=\"P-0048\" num=\"0048\">[0048]FIG. 2 is a list showing the contents of the format field <b>10</b>, that is, detailed values and meanings of the format field <b>10</b>. In the first embodiment, the format field <b>10</b> has a 4-bit configuration and it is classified into sixteen types. In the list, \u201c2-ops.\u201d indicates the 2-operation instruction, \u201c3-ops.\u201d indicates the 3-operation instruction, \u201c1st\u201d indicates that an operation designated in that column (operation<sub>\u2014</sub>0, operation<sub>\u2014</sub>1, or operation<sub>\u2014</sub>2) must be executed first, \u201c2nd\u201d indicates that an operation designated in that column must be executed second, and \u201c3rd\u201d indicates that an operation designated in that column must be executed third. The symbol \u201c---\u201d indicates that there is no operation designated in that column. </p><p id=\"P-0049\" num=\"0049\">[0049] In the format field <b>10</b>, not only the 3-operation instruction of the format <b>1</b> and the 2-operation instruction of the format <b>2</b> are distinguished from each other, but also the order of the operations is specified. The specifying order of the operations as herein termed includes an order for a case in which the operations are to be executed sequentially and an order for a case in which two or three operations are to be executed in parallel. </p><p id=\"P-0050\" num=\"0050\">[0050] For instance, when the value of the format field <b>10</b> is \u201cFM=0100\u201d, the instruction is a 3-operation instruction and therefore operation<sub>\u2014</sub>0 specified by the operation field <b>11</b> and operational specified by the operation field <b>12</b> are executed in parallel first, and then operation<sub>\u2014</sub>2 specified by the operation field <b>13</b> is executed. In this case, since operation<sub>\u2014</sub>0 and operation<sub>\u2014</sub>1 are executed in parallel, it is necessary that the software guarantees no conflict exists between operands of operation<sub>\u2014</sub>0 and operation<sub>\u2014</sub>1. </p><p id=\"P-0051\" num=\"0051\">[0051] On the other hand, the hardware guarantees that operation<sub>\u2014</sub>0 and operation<sub>\u2014</sub>2 are executed sequentially and also that operation<sub>\u2014</sub>1 and operation<sub>\u2014</sub>2 are executed sequentially. Sequential execution as herein termed is an execution in which, in the same way as in the conventional data processors which execute instructions one by one sequentially, a result of an operation by an instruction to be executed first is reflected in an instruction which will be executed next. </p><p id=\"P-0052\" num=\"0052\">[0052]FIG. 3 is a schematic diagram showing details of operation codes of a short format. There are five types of the short format, i.e., an SB format <b>31</b>, an SR format <b>32</b>, an SM-1 format <b>33</b>, an SM-2 format <b>34</b> and an SI format <b>35</b>. </p><p id=\"P-0053\" num=\"0053\">[0053] The five types of the short format <b>31</b>, <b>32</b>, <b>33</b>, <b>34</b>, and <b>35</b> are each formed by combining a 4-bit execution condition field (&lt;cond&gt;) <b>20</b>, a 5-bit operation code field <b>21</b>, or a 6-bit operation code field <b>23</b> each specifying the type of an operation, an 11-bit displacement field (DISP) <b>22</b> which specifies a branch width of a branch instruction, a o-bit register field <b>24</b> which specifies an operand on a register, 5-bit indirect address fields <b>25</b> and <b>26</b> each of which specifies a register number for holding an address of an operand on a memory, and a 5-bit immediate field <b>27</b> which specifies a 5-bit immediate. Each one of the five types of the format <b>31</b>, <b>32</b>, <b>33</b>, <b>34</b>, and <b>33</b> includes the execution condition field <b>20</b> so that all operations are validated only when an execution condition specified by the execution condition field <b>20</b> is true. As herein termed, a valid operation is an operation which ensures that a result of the operation is reflected in a register, a memory, or a flag. </p><p id=\"P-0054\" num=\"0054\">[0054] Operations which can be specified by the short type SB format <b>31</b> are branches and subroutine branches within a range which can be expressed by 11 bits of branch width specified by the DISP field <b>22</b>. In the first embodiment, since the instructions each have a length of eight bytes, lower three bits of an instruction address are always \u201c0\u201d. In this case therefore, it is possible to specify a branch width up to fourteen (=3+11) bits, that is, 16K bytes. </p><p id=\"P-0055\" num=\"0055\">[0055] Operations which can be specified by the short type SR format <b>32</b> are sixteen types of register-register operations, including arithmetic operations such as addition and subtraction, logical operations, shift operations, bit manipulations, and so on. </p><p id=\"P-0056\" num=\"0056\">[0056] Operations which can be specified by the short type SM-1 format <b>33</b> are sixteen types of loading or storing. An address of a memory operand is stored in a register which has a register number of &lt;Rb&gt; indicated in the indirect address field <b>25</b>. When the register number of &lt;Rb&gt; which is indicated in the indirect address field <b>25</b> is \u201c0\u201d, an addressing mode of an operand of the memory side becomes pop mode from a stack at loading, and an addressing mode of an operand of the memory side becomes push mode at storing. </p><p id=\"P-0057\" num=\"0057\">[0057] Operations which can be specified by the short type SM-2 format <b>34</b> are sixteen types of loading and storing. An address of a memory operand is the sum of the contents of a register which has the register number of &lt;Rb&gt; indicated by the indirect address field <b>26</b> and the contents of a register which has a register number being larger than the register number &lt;Rb&gt; by a value \u201c1\u201d. </p><p id=\"P-0058\" num=\"0058\">[0058] Operations which can be specified by the short type SI format <b>35</b> are twelve types of operations, including various operations such as an arithmetic operation between a 5-bit immediate of the immediate field <b>27</b> and a register, logical operations, bit a manipulations, loading of an immediate, a null operation, and so on. </p><p id=\"P-0059\" num=\"0059\">[0059]FIG. 4 is a schematic diagram showing details of operation codes of a long format. There are eight types of long format, i.e., an LB format <b>71</b>, an LM-1 format <b>72</b>, an LM-2 format <b>73</b>, an LI-R format <b>74</b>, an LR-R format <b>75</b>, an LR-C format <b>76</b>, an LI-C format <b>77</b>, and an MISC format <b>78</b> for executing various operations such as loading, storing, register-register operations, comparison, and jumps. Each one of the formats <b>71</b> to <b>78</b> includes the execution condition field <b>20</b> so that all operations are validated only when an execution condition specified by the execution condition field <b>20</b> is true in the same way as in operations specified by the short formats <b>31</b> to <b>35</b> mentioned above. </p><p id=\"P-0060\" num=\"0060\">[0060] The long LB format <b>71</b> is a format for calculating a branch and a subroutine branch. </p><p id=\"P-0061\" num=\"0061\">[0061] The long LM-1 format <b>72</b> is a format for a load operation and a store operation. In the long LM-1 format <b>72</b>, an address of a memory operand is given by a value which is obtained by adding a signed binary value expressed by 18-bit and indicated by a field <b>38</b> to the contents of a register indicated by the field <b>35</b>. </p><p id=\"P-0062\" num=\"0062\">[0062] The long LM-2 format <b>73</b> is also a format for a load operation and a store operation. In the long LM-2 format <b>73</b>, an address of a memory operand is defined in accordance with an addressing mode indicated by a 2-bit field <b>41</b>. FIG. 5 is a list showing types of the addressing mode specified by the field <b>41</b>. </p><p id=\"P-0063\" num=\"0063\">[0063] In FIG. 5, a value obtained by adding up a displacement and a sign-extended value becomes the address when a value of the field <b>41</b> is \u201c&lt;ea&gt;=00\u201d, a value obtained by adding up a PC value and a value of a register Rc becomes the address when a value of the field <b>41</b> is \u201c&lt;ea&gt;=01\u201d and a value obtained by adding up a PC value and a value of a register Rc becomes the address when a value of the field <b>41</b> is \u201c&lt;ea&gt;=10\u201d. When a value of the field <b>41</b> is \u201c&lt;ea&gt;=11\u201d, the mode becomes a pop mode or a push mode. </p><p id=\"P-0064\" num=\"0064\">[0064] The LI-R format <b>74</b> and the LR-R format <b>75</b> of the long type are formats for register-register 3-operand operations such as an arithmetic operation, a logical operation, shift operation, etc., of three operands, or for operations between one immediate which is expressed in sixteen bits and two register operands. </p><p id=\"P-0065\" num=\"0065\">[0065] The long LR-C format <b>76</b> is a format for a comparison operation. The LR-C format <b>76</b> specifies a comparison operation between a register operand indicated by a field <b>48</b> and a register operand indicated by a field <b>55</b>. </p><p id=\"P-0066\" num=\"0066\">[0066] The long LI-C format <b>77</b> is also a format for a comparison operation. The LI-C format <b>77</b> specifies a comparison operation between a register operand indicated by a field <b>48</b> and an immediate operand indicated by a field <b>62</b>. A field <b>57</b> is a field which specifies a truth/false judging condition for a comparison operation, and details of the field <b>57</b> are shown in the list in FIG. 6. A comparison is executed on two operands under a condition which is indicated by the field <b>57</b>, and truth/false is judged. A field <b>68</b> specifies the flag number of a flag in which the result of the truth/false judgment is to be reflected. There are eight flags. A flag which has the number specified by the field <b>58</b> changes to \u201c11\u201d or \u201c10\u201d. A field <b>59</b> is a field which is used at accumulation of results of truth/false judgment on a plurality of comparison operations. The field <b>59</b> consists of four bits and specifies the number of a flag from which a logical product is yielded with a result of judgment on a condition which is specified by the field <b>58</b>, and the field <b>59</b> also specifies invert/non-invert of a truth/false value of the flag. Bits <b>1</b> to <b>3</b> specify the number of a flag from which a logical product is to be yielded. A bit <b>0</b> specifies whether to use the flag after inverting truth/false of an inputted flag value or to use the flag without inverting truth/false of the inputted flag value. </p><p id=\"P-0067\" num=\"0067\">[0067] The long type MISC format <b>78</b> is a format used for operations which process a number of operands such as bit and string manipulations, or for privileged operations such as a null operation and control register manipulations. </p><p id=\"P-0068\" num=\"0068\">[0068] The data processor according to the present invention allows to specify at most one jump operation per one instruction so that decoding of the instruction is simple. While a jump operation may be included in each one of two operation fields within a 2-operation instruction, a jump operation can be included only in the field <b>11</b> in case of a 3-operation instruction. </p><p id=\"P-0069\" num=\"0069\">[0069]FIG. 7 is a schematic diagram showing a register configuration used in the data processor of the present invention. The first embodiment uses thirty-two general purpose registers (R<b>0</b> to R<b>31</b>) <b>81</b> each having a bit length of 32 bits, thirty-two floating-point registers (FR<b>0</b> to FR<b>31</b>) <b>83</b> each having a bit length of 64 bits, and ten control registers <b>82</b> each having a bit length of 32 bits. </p><p id=\"P-0070\" num=\"0070\">[0070] The zero-th general purpose register (R<b>0</b>) <b>80</b> ignores a value which is written therein and always outputs \u201c0\u201d when read. The thirty-first general purpose register (R<b>31</b>) <b>84</b> includes a user stack pointer (USP), a system stack pointer (SSP), and an interruption stack pointer (ISP), and one of which becomes valid by switching a stack pointer mode. </p><p id=\"P-0071\" num=\"0071\">[0071] The control registers <b>82</b> includes a processor status word (PSW) <b>85</b>, a program counter (PC) <b>86</b>, a floating-point operation exception control register (FEIT) <b>87</b>, an address translation base register (UATB) <b>88</b>, an exceptional processing table base register (EITVB) <b>89</b>, debug support registers (DBC, BPA<b>0</b>, BPA<b>1</b>, BMC) <b>90</b>. </p><p id=\"P-0072\" num=\"0072\">[0072] The floating-point registers <b>83</b> stores a short floating-point number (32-bit length) or a double-precision floating-point number (64-bit length) which is an operand for a floating-point operation. </p><p id=\"P-0073\" num=\"0073\">[0073]FIG. 8 and FIG. 9 are schematic diagrams showing detailed contents of the processor status word (PSW) <b>85</b>. FIG. 8 shows detailed contents of a first half of the processor status word (PSW) <b>85</b>, while FIG. 9 shows detailed contents of a second half of the processor status word (PSW) <b>85</b>. </p><p id=\"P-0074\" num=\"0074\">[0074] In FIG. 8, a 2-bit RNG field <b>91</b> is a field for determining a mode of a processor. In the first embodiment, the processor enters the interrupt mode when \u201cRNG=00\u201d, the system mode when \u201cRNG=10\u201d, and the user mode when \u201cRNG=11\u201d. An AT field <b>92</b> is a field for switching an address translation on and off. A 1-bit DB field <b>93</b> is a field for switching ON/OFF of a debug mechanism. A 1-bit X field <b>96</b> is a carry flag, and is used for arithmetic operation of extending significant digit number of an integer. A 1-bit V field <b>97</b> is an overflow flag, and is set when an overflow occurs by an integer arithmetic operation but is reset when there is no overflow. A 3-bit IMASK field <b>94</b> is a field for controlling a mask condition of an external interruption. Eight condition flags <b>95</b> are each formed of two bits. Each condition flag <b>95</b> is read or a value is written into the flag <b>95</b> by explicitly specifying the flag number by a comparison instruction. Further, each condition flag <b>95</b> is referred or updated when the content of the processor status word <b>85</b> is read or rewritten into response to a control register access instruction. </p><p id=\"P-0075\" num=\"0075\">[0075] The condition flags <b>95</b> shown in FIG. 9 play an important role to determine whether operations included in the instruction of the data processor of the present invention are valid or invalid. In the first embodiment, the bit <b>1</b> to bit <b>3</b> of the 4-bit execution condition field <b>20</b> included in each format of an instruction specify the flag number of one of the eight condition flags <b>95</b>, and the bit <b>0</b> of the 4-bit execution condition field <b>20</b> indicates whether to validate an operation when the flag which is specified by the bit <b>1</b> to bit <b>3</b> is \u201cfalse=10\u201d or to validate the operation when the flag which is specified by the bit <b>1</b> to bit <b>3</b> is \u201ctrue=11\u201d. When the flag specified by the bit <b>0</b> to bit <b>3</b> is \u201cundefined=00 or 01\u201d or when specified content is different from the flag value, the operation is invalidated. An initial value of a flag F<b>0</b> of the condition flags <b>95</b> is \u201cfalse=10\u201d but other flags have an initial value of \u201cundefined=00\u201d. The initial value of the flag F<b>0</b> is \u201c10\u201d in order to unconditionally validate each operation, determining that the condition field <b>20</b> of each instruction format indicates that \u201can operation is valid when 1000=F<b>0</b> is false\u201d in an initial condition. Each flag can be a target flag which reflects an operation result of the condition specified by the field <b>57</b> of the LR-C and the LI-C formats, and only specific one of the flags specified by the field <b>58</b> changes. However, three of the flags may change at the same time depending on a result of addition or an general purpose comparison operation, etc. In addition, a VA(F<b>4</b>) flag is also \u201ctrue=11\u201d when an overflow occurs in an integer operation after initializing at a particular time. </p><p id=\"P-0076\" num=\"0076\">[0076] (2) \u201cHardware Configuration\u201d</p><p id=\"P-0077\" num=\"0077\">[0077]FIG. 10 is a block diagram showing an overall configuration of the data processor according to the first embodiment of the present invention. </p><p id=\"P-0078\" num=\"0078\">[0078] Reference numeral <b>107</b> designates a bus interface unit which connects the data processor according to the present invention and an external memory by means of an address bus, a data bus and a control signal. </p><p id=\"P-0079\" num=\"0079\">[0079] Reference numeral <b>105</b> designates an instruction fetch unit which comprises an instruction cash and an instruction address translation buffer (ITLB). The instruction fetch unit <b>105</b> fetches an instruction from the instruction cash or the external memory through a bus interface unit <b>107</b>, and transfers the instruction to an instruction mapper <b>101</b> via a 64-bit II bus <b>68</b>. </p><p id=\"P-0080\" num=\"0080\">[0080] Reference numeral <b>106</b> designates an operand access unit which comprises a data cash and a data address translation buffer (DTLB). The operand access unit <b>106</b> fetches a data from the data cash or the external memory through the bus interface unit <b>107</b> and then transfers the data to a memory access unit <b>125</b>, or writes data transferred from the memory access unit <b>125</b> into the external memory through the bus interface unit <b>107</b>. </p><p id=\"P-0081\" num=\"0081\">[0081] The instruction mapper <b>101</b> decomposes a 64-bit instruction which has been transferred from the instruction fetch unit <b>105</b> into operation fields in accordance with the contents of the format field <b>10</b> which is the first four bits of the 64-instruction, and transfers the operation fields in a specified order to an instruction decoder <b>102</b>. During this procedure, the instruction mapper <b>101</b> rearranges and transfers the operation fields to a decoder in a corresponding one of six decoders <b>111</b> to <b>116</b> in accordance with types of the operations. </p><p id=\"P-0082\" num=\"0082\">[0082] The instruction decoder <b>102</b> is configured by: a PCD <b>111</b> which decodes a field of jump operation of a short format <b>31</b> or a long format <b>71</b>; an IAD <b>112</b>, an IBD <b>113</b>, and an ICD <b>114</b> which decode a field for operations regarding an operand held in the general purpose registers such as an integer arithmetic operation of short formats <b>32</b> and <b>34</b>, or long formats <b>74</b> to <b>78</b>; an MD <b>115</b> which decodes a field of load/store operation of a short format <b>33</b> or long formats <b>72</b> and <b>73</b>; and an FD <b>116</b> which decodes a field of a floating-point operation of long formats <b>72</b> to <b>77</b>. </p><p id=\"P-0083\" num=\"0083\">[0083] A control circuit <b>103</b> includes the flags <b>95</b> of the processor status word <b>85</b>, and controls the operation unit <b>104</b> in accordance with a decoded result by the instruction decoder <b>102</b> and the contents of the flags <b>95</b>. </p><p id=\"P-0084\" num=\"0084\">[0084] The operation unit <b>104</b> is configured by six portions, i.e. a PC unit <b>121</b>, an integer operation unit <b>120</b> which consists of three portions, a memory access unit <b>125</b>, and a floating-point operation unit <b>126</b>, corresponding to the six decoders <b>111</b> to <b>116</b> of the instruction decoder <b>102</b>. </p><p id=\"P-0085\" num=\"0085\">[0085] The PC unit <b>121</b> includes a program counter and an adder. For an instruction except for a jump instruction, the PC unit <b>121</b> adds \u201c8\u201d to a PC value of an executed instruction to calculate a PC value of an instruction to be executed next. For a jump instruction, the PC unit <b>121</b> adds a branch displacement to a PC value of the executed jump instruction or calculates in accordance with an addressing mode specified by the instruction, thereby getting a PC value of an instruction at a jump destination. </p><p id=\"P-0086\" num=\"0086\">[0086] The integer operation unit <b>120</b> includes the multiple-port general purpose registers <b>81</b> and the control registers <b>82</b> shown in FIG. 7, three shifters and three ALUs. The integer operation unit <b>120</b> is configured by three integer operation mechanisms (IA, IB, IC) <b>122</b>, <b>123</b>, and <b>124</b> for executing three integer operations in parallel. </p><p id=\"P-0087\" num=\"0087\">[0087] The floating-point operation unit <b>126</b>, including the floating-point registers <b>83</b> shown in FIG. 7 and operation mechanisms such as a floating-point adder and a floating-point multiplier, executes a floating-point operation. The PC unit <b>121</b>, the integer operation mechanisms <b>122</b>, <b>123</b>, and <b>124</b>, and the floating-point operation unit <b>126</b> operate independently of each other. At need, data can be transferred between these units through buses. </p><p id=\"P-0088\" num=\"0088\">[0088] The memory access unit <b>125</b> cooperatively operates with the other portions <b>121</b>, <b>120</b>, and <b>126</b> of the operation unit <b>104</b>. Data are transferred between the memory access unit <b>125</b> and the operand access unit <b>106</b>. </p><p id=\"P-0089\" num=\"0089\">[0089] The operation unit <b>104</b> is connected with the instruction fetch unit <b>105</b> and the operand access unit <b>106</b> by a JA bus, an AA bus and a DD bus. The instruction fetch unit <b>105</b> and the operand access unit <b>106</b> transfer an instruction address, a data address, and data to and from the operation unit <b>104</b>. </p><p id=\"P-0090\" num=\"0090\">[0090] (3) \u201cInstruction Mapper and Instruction Decoder\u201d</p><p id=\"P-0091\" num=\"0091\">[0091]FIG. 11 is a block diagram showing an example of specific configuration of the instruction mapper <b>101</b> and the instruction decoder <b>102</b>. The instruction mapper <b>101</b> is configured by: an operation field extraction unit <b>200</b> for extracting the format field <b>10</b> and the operation fields <b>11</b> to <b>15</b> from a 64-bit instruction code which is outputted to the II bus <b>108</b>; and an FM decoder <b>221</b> for decoding the format field <b>10</b>. </p><p id=\"P-0092\" num=\"0092\">[0092] Each one of extraction units <b>201</b> to <b>213</b> of the operation field extraction unit <b>200</b> extracts some of bit fields of an instruction code on the II bus <b>108</b>, and outputs a bit string of each operation field corresponding to each one of the decoders <b>111</b> to <b>116</b> which form the instruction decoder <b>102</b>. Of the 64 bits on the II bus <b>108</b>, the extraction unit <b>201</b> extracts bit <b>0</b> to bit <b>3</b>, the extraction unit <b>202</b> extracts bit <b>4</b> to bit <b>23</b>, the extraction unit <b>203</b> extracts bit <b>24</b> to bit <b>63</b>, the extraction unit <b>204</b> extracts bit <b>4</b> to bit <b>23</b>, the extraction unit <b>205</b> extracts bit <b>24</b> to bit <b>43</b>, the extraction unit <b>206</b> extracts bit <b>24</b> to bit <b>63</b>, the extraction unit 207 extracts bit <b>44</b> to bit <b>63</b>, the extraction unit <b>208</b> extracts bit <b>4</b> to bit <b>23</b>, the extraction unit <b>209</b> extracts bit <b>24</b> to bit <b>43</b>, the extraction unit <b>210</b> extracts bit <b>44</b> to bit <b>63</b>, the extraction unit <b>211</b> extracts bit <b>24</b> to bit <b>63</b>, the extraction unit <b>212</b> extracts bit <b>4</b> to bit <b>23</b>, and the extraction unit <b>213</b> extracts bit <b>24</b> to bit <b>63</b>. Extracted bits are outputted to the instruction decoder <b>102</b>. </p><p id=\"P-0093\" num=\"0093\">[0093] The instruction decoder <b>102</b> (PCD <b>111</b>, IAD <b>112</b>, IBD <b>113</b>, ICD <b>114</b>, MD <b>115</b>, FD <b>116</b>) is configured by a decoder unit <b>220</b> and an output processing unit <b>240</b>. More specifically, the PCD <b>111</b> is configured by a PCS decoder <b>222</b> for decoding a jump operation code of the short format extracted by the extraction unit <b>202</b>, a PCL decoder <b>223</b> for decoding a jump operation code of the long format extracted by the extraction unit <b>203</b>, and an output processing unit <b>241</b>. To the control circuit <b>103</b>, the output processing unit <b>241</b> outputs a control signal which instructs for executing a jump operation according to an output from the PCS decoder <b>222</b> or the PCL decoder <b>223</b>, a non-jump operation for adding \u201c8\u201d to a current PC value, or a null operation, in accordance with a decoded result performed by the three decoders, i.e., the PCS decoder <b>222</b>, the PCL decoder <b>223</b>, and the FM decoder <b>221</b>. </p><p id=\"P-0094\" num=\"0094\">[0094] The IAD <b>112</b> is configured by an IS decoder <b>224</b> for decoding an integer operation code of the short format extracted by the extraction unit <b>204</b> and an output processing unit <b>242</b>. To the control circuit <b>103</b>, the output processing unit <b>242</b> outputs a control signal which instructs for executing an integer operation according to an output from the IS decoder <b>224</b> or a null operation, in accordance with decoded results performed by the IS decoder <b>224</b> and the FM decoder <b>221</b>. </p><p id=\"P-0095\" num=\"0095\">[0095] The IBD <b>113</b> is configured by an IS decoder <b>220</b> for decoding an integer operation code of the short format extracted by the extraction unit <b>205</b>, an IL decoder <b>226</b> for decoding an integer operation code of the long format extracted by the extraction unit <b>206</b>, and an output processing unit <b>243</b>. To the control circuit <b>103</b>, the output processing unit <b>243</b> outputs a control signal which instructs for executing an integer operation according to an output from the IS decoder <b>225</b>, the IL decoder <b>226</b>, or a null operation, in accordance with a decoded result performed by the IS decoder <b>225</b>, the IL decoder <b>226</b> and the FM decoder <b>221</b>. </p><p id=\"P-0096\" num=\"0096\">[0096] The ICD <b>114</b> is configured by an IS decoder <b>227</b> for decoding an integer operation code of the short format extracted by the extraction unit <b>207</b> and an output processing unit <b>244</b>. To the control circuit <b>103</b>, the output processing unit <b>244</b> outputs a control signal which instructs for executing an integer operation according to an output from. the IS decoder <b>227</b> or a null operation, in accordance with a decoded result performed by the IS decoder <b>227</b> and the FM decoder <b>221</b>. </p><p id=\"P-0097\" num=\"0097\">[0097] The ICD <b>115</b> is configured by MS decoders <b>228</b>, <b>229</b>, and <b>230</b> for decoding memory access operation codes of the short format extracted by the extraction units <b>208</b>, <b>209</b>, and <b>210</b> respectively, an ML decoder <b>231</b> for decoding memory access operation codes of the long format extracted by the extraction unit <b>211</b>, and an output processing unit <b>245</b>. To the control circuit <b>103</b>, the output processing unit <b>245</b> outputs a control signal which instructs for executing a memory access operation according to an output from one of the MS decoders <b>228</b>, <b>229</b>, and <b>230</b> and the ML decoder <b>231</b> or a null operation, in accordance with results of decoding performed by the five decoders, i.e., the MS decoders <b>228</b>, <b>229</b>, and <b>230</b>, the ML decoder <b>231</b>, and the FM decoder <b>221</b>. </p><p id=\"P-0098\" num=\"0098\">[0098] The FD <b>116</b> is configured by an FS decoder <b>232</b> for decoding a floating-point operation code of the short format extracted by the extraction unit <b>212</b>, an FL decoder <b>233</b> for decoding a floating-point operation code of the long format extracted by the extraction unit <b>213</b>, and an output processing unit <b>246</b>. To the control circuit <b>103</b>, the output processing unit <b>246</b> outputs a control signal which instructs for executing a floating-point operation according to an output from one of the FS decoder <b>232</b> and the FL decoder <b>233</b> or a null operation, in accordance with decoded results performed by the FS decoder <b>232</b>, the FL decoder <b>233</b>, and the FM decoder <b>221</b>. </p><p id=\"P-0099\" num=\"0099\">[0099] Outputs from the output processing unit <b>240</b> (<b>241</b> to <b>246</b>) are inputted to the control circuit <b>103</b> and used to control an operation performed by the operation unit <b>104</b>. More particularly, an output from the output processing unit <b>241</b> is used to control a PC calculation by the PC unit <b>121</b>. Outputs from the output processing units <b>242</b>, <b>243</b>, and <b>244</b> are used to control integer operations performed by the integer operation mechanisms (IA, IB, IC) <b>122</b>, <b>123</b>, and <b>124</b> of the integer operation unit <b>120</b>, respectively. An output from the output processing unit <b>245</b> is used to control a memory access operation performed by the memory access unit <b>125</b>. An output from the output processing unit <b>246</b> is used to control a floating-point operation performed by the floating-point operation unit <b>126</b>. </p><p id=\"P-0100\" num=\"0100\">[0100] A decoded result performed by the FM decoder <b>221</b> is outputted partly to the instruction fetch unit <b>105</b> to control the output timing of the next instruction code to the II bus <b>108</b>. When an instruction requires sequential execution of two or three operations, a value of the II bus <b>108</b> is held for two or three clock cycles, whereby output from each output processing unit <b>241</b> to <b>246</b> is controlled in accordance with an operation order specified by the format field <b>10</b>. As a result, to the operation unit corresponding to an operation field which is valid at the timing of a clock, a control signal corresponding to a decoded result of that operation field is outputted from the output processing units <b>241</b> to <b>246</b>, while to the operation unit according to an operation field which is invalid at the timing of a clock, a control signal which instructs a null operation is outputted from the output processing units <b>241</b> to <b>246</b>. </p><p id=\"P-0101\" num=\"0101\">[0101] The tables below list operations which can be specified only by the short format, operations which can be specified both by the short format and the long format, operations which can be specified only in the long format, and information regarding the decoders which execute the respective operations. </p><p id=\"P-0102\" num=\"0102\">[0102] Table 1 is a list of operations which can be specified by operation codes of only the short format. There are twenty-four types of such operations. Table 2 is a list of operations which can be specified both in the short format and the long format. There are nineteen types of such operations. Table 3 is lists of operations which can-be specified by operation codes of only the long format. There are seventy-four types of such operations. </p><p id=\"P-0103\" num=\"0103\">[0103] In Table 1 to Table 3, the column \u201cmnemonic\u201d shows abbreviations and operands of operations and the column \u201cfunction\u201d shows the meanings of the operations. The column \u201ctype\u201d shows types of decoders to which the instruction mapper <b>101</b> distributes the operations. That is, the instruction mapper <b>101</b> distributes operation codes of the type \u201cPC\u201d to the PCS decoder <b>222</b> or the PCL decoder <b>223</b>, codes of the type \u201cInteger\u201d to the IS decoder <b>224</b>, the IS decoder <b>225</b>, the IL decoder <b>226</b>, or the IS decoder <b>227</b>, codes of the type \u201cMemory\u201d to the MS decoder <b>228</b>, the MS decoder <b>229</b>, the MS decoder <b>230</b>, or the ML decoder <b>231</b>, codes of the type \u201cFloating point (FP)\u201d to the FS decoder <b>232</b> or the FL decoder <b>233</b>, depending on whether the format is the short format or the long format and a field position on an instruction. </p><p id=\"P-0104\" num=\"0104\">[0104] In the column \u201cformat\u201d, the symbol SR denotes \u201cShort Register\u201d, the symbol SI denotes \u201cShort Immediate\u201d, the symbol SM denotes \u201cShort Memory\u201d, the symbol SB denotes \u201cShort Branch\u201d, the symbol LR denotes \u201cLong Register\u201d, the symbol LI denotes \u201cLong Immediate\u201d, the symbol LM denotes \u201cLong Memory\u201d and the symbol LB denotes \u201cLong Branch\u201d. </p><p id=\"P-0105\" num=\"0105\">[0105] (4) \u201cExample of Instruction Execution\u201d</p><p id=\"P-0106\" num=\"0106\">[0106]FIG. 12 to FIG. 20 are views showing examples of a program used in the data processor according to the present invention. These examples show source programs described in the FORTRAN and the C-language and assembler programs which are obtained by describing the source programs in an assembler language of the data processor according to the present invention. </p><p id=\"P-0107\" num=\"0107\">[0107] In each assembler program, two or three operations are grouped. Two or three operations of each group are encoded into the format <b>1</b> or <b>2</b> shown in FIG. 1, and processed as one instruction in the data processor according to the present invention. </p><p id=\"P-0108\" num=\"0108\">[0108]FIG. 12 shows a source program described in the FORTRAN for calculating the sum of products of elements which are included in arrays A and B. FIG. 13 shows an assembler program which is obtained by translating this source program into an assembler language. The first three instructions of the assembler program are initial setting of a loop and the last three instructions form the loop. Since execution of the loop spends most of an execution time of this program, it is important to execute the last three instructions at high speed. In the data processor according to the present invention, eight operations included within a loop are encoded into three instructions and three or two operations are executed in parallel in each instruction, and loop operation is executed at high speed. </p><p id=\"P-0109\" num=\"0109\">[0109] An instruction <b>301</b> is a 2-operation instruction for executing two operations in parallel, i.e., an operation (FLD) <b>303</b> for loading a floating point from a memory to a floating-point register FR<b>1</b> (this operation is encoded into the long format) and an operation (LDI) <b>304</b> for loading an immediate to a general purpose register R<b>1</b> (this operation is encoded into the short format). An instruction <b>302</b> is a 3-operation instruction for executing three operations in parallel, i.e., an operation (FLD) <b>305</b> for loading a floating point from a memory to a floating-point register FR<b>2</b> (this operation is encoded into the short format), an operation (ADDI) <b>306</b> for adding an immediate to a general purpose register R<b>1</b> (this operation is encoded into the short format) and an operation (ADDI) <b>307</b> for adding an immediate to a general purpose register R<b>2</b> (this operation is encoded into the short format). </p><p id=\"P-0110\" num=\"0110\">[0110] A description \u201cICOF\u201d designated by numeral <b>313</b> is a field which indicates the timing and a condition of executing the operation (FLD) <b>303</b>. The first number \u201c1\u201d indicates that this operation is issued immediately after decoding and the following \u201cCOF\u201d indicates that this operation is valid when the condition flag F<b>0</b> is \u201cfalse=10\u201d. The issuing timing \u201c1\u201d of the operation of the field <b>313</b> and the issuing timing \u201c1\u201d of an operation of a field <b>314</b> are encoded into the format field <b>10</b> of an instruction code of the format <b>1</b>, with a fact that this instruction is a 2-operation instruction. Execution conditions \u201cCOF\u201d for the fields <b>313</b> and <b>314</b> are encoded into the respective execution condition field <b>20</b> corresponding to the operation (FLD) <b>303</b> and operation (LDI) <b>304</b>. </p><p id=\"P-0111\" num=\"0111\">[0111] At processing of the instruction <b>301</b>, an operation code of the operation (FLD) <b>303</b> is cut out by the extraction unit <b>211</b> of the instruction mapper <b>101</b>, decoded by the ML decoder <b>231</b>, supplied to the control circuit <b>103</b> through the output processing unit <b>245</b>, and executed by the memory access unit <b>125</b>. An operation code of the operation (LDI) <b>304</b> is cut out by the extraction unit <b>204</b> of the instruction mapper <b>101</b>, decoded by the IS decoder <b>224</b>, supplied to the control circuit <b>103</b> through the output processing unit <b>242</b>, and executed by the IA <b>122</b>. Assuming that the flag F<b>0</b> is \u201c10\u201d, both the operation (FLD) <b>303</b> and the operation (LDI) <b>304</b> are valid and both timing designations are \u201c1\u201d. Hence, the operation (FLD) <b>303</b> and the operation (LDI) <b>304</b> are executed in parallel without any delay, and operation results are reflected in the registers FR<b>1</b> and R<b>1</b>. </p><p id=\"P-0112\" num=\"0112\">[0112] Since the instruction <b>301</b> is an instruction in which operation fields of the short format are assigned to the bit <b>4</b> to bit <b>23</b> and operation fields of the long format are assigned to the bit <b>24</b> to bit <b>63</b>, bit strings cut out by the extraction units <b>205</b>, <b>207</b>, <b>209</b>. and <b>210</b> which correspond to the remaining operation fields are not valid. Hence, the FM decoder <b>221</b> outputs an invalidating signal and decoded results are invalidated at the output processing unit <b>240</b>. Since operation codes cut out by the extraction units <b>202</b>, <b>203</b>, <b>206</b>, <b>208</b>, <b>212</b>, and <b>213</b> and then transferred to the decoder unit <b>220</b> are not operation codes which are to be decoded by the respective decoders, the decoder unit <b>220</b> changes these operation codes into null operation codes, and outputs them. </p><p id=\"P-0113\" num=\"0113\">[0113] At processing of the instruction <b>302</b>, an operation code of the operation (FLD) <b>305</b> is cut out by the extraction unit <b>208</b>, decoded by the MS decoder <b>228</b>, supplied to the control circuit <b>103</b> through the output processing unit <b>245</b>, and executed by the memory access unit <b>125</b>. Operation codes of the operation (ADDI) <b>306</b> and (ADDI) <b>307</b> are cut out by the extraction units <b>205</b> and <b>207</b>, decoded by the IS decoders <b>225</b> and <b>227</b>, supplied to the control circuit <b>103</b> through the output processing units <b>243</b> and <b>244</b>, and executed by the IB <b>123</b> and IC <b>124</b>, respectively. Assuming that the flag F<b>0</b> is \u201c10\u201d, the operation (FLD) <b>305</b> and the operations (ADDI) <b>306</b> and the operation (ADDI) <b>307</b> are all valid and all the timing designation are \u201c1\u201d. Hence, the three operations are executed in parallel without any delay, and the operation results are reflected in the registers FR<b>2</b>, R<b>1</b>, and R<b>2</b>. </p><p id=\"P-0114\" num=\"0114\">[0114] Since the instruction <b>302</b> is an instruction in which operation fields of the short format are assigned to the bit <b>4</b> to bit <b>23</b>, bit <b>24</b> to bit <b>43</b>, and bit <b>44</b> to bit <b>63</b>, bit strings cut out by the extraction units <b>203</b>, <b>206</b>, <b>211</b>, and <b>213</b> corresponding to the remaining operation fields are not valid. Hence, the FM decoder <b>221</b> outputs an invalidating signal and decoded results are invalidated by the output processing unit <b>240</b>. Operation codes cut out by the extraction units <b>202</b>, <b>204</b>, <b>209</b>, <b>210</b>, and <b>212</b> and then supplied to the decoder unit <b>220</b> are not operation codes which are to be decoded by the respective decoders, the decoder unit <b>220</b> changes these operation codes into null operations and outputs them. </p><p id=\"P-0115\" num=\"0115\">[0115]FIG. 14 shows an assembler program which is obtained by unrolling loops of the source program shown in FIG. 12 in such a manner that the four iterations of the source program are translated into one iteration. The purpose of unrolling the loops is to reduce the execution time of the program. While three instructions correspond to an operation of one iteration of the source program in the assembler program shown in FIG. 13, six instructions realize four iterations of the source program in the assembler program shown in FIG. 14. </p><p id=\"P-0116\" num=\"0116\">[0116] The reduction in the number of instructions is attributed to a reduction in branch operations BRA and to a use of an operation (FLD<b>4</b>) <b>309</b> for loading four data into four registers from a continuous area of the memory. In the data processor according to the present invention, since an execution time of the operation (FLD<b>4</b>) <b>309</b> for loading four data from the memory takes two clock cycles, the effect of reducing the number of operation does not always contribute directly a reduction in the execution time. However, since the assembler program shown in FIG. 14 requires that an operation of four iterations of the source program is executed in nine clock cycles (the branch operation BRA and the operation FLD<b>4</b> are executed in two clock cycles each, and the remaining operations are executed in one clock cycle each), the assembler program shown in FIG. 14 is at least twice faster than the assembler program shown in FIG. 13 in which an operation of one iteration of the source program is executed in five clock cycles (the branch operation BRA is executed in two clock cycles and the remaining operations are executed in one clock cycle each). </p><p id=\"P-0117\" num=\"0117\">[0117]FIG. 15 and FIG. 16 are schematic diagrams showing programs for examining elements of an array X and counting the number of elements whose values exceed a constant value (XLIMIT). FIG. 15 shows such a source program and FIG. 16 shows an assembler program which is obtained by translating the source program. </p><p id=\"P-0118\" num=\"0118\">[0118] The last three instructions of the assembler program of FIG. 16 form a loop. An instruction <b>320</b> in the loop is consists of an operation (ADDI) <b>321</b> for adding an immediate to the register R<b>1</b>, a branch operation (BRA) <b>323</b>, and a null operation (NOF) <b>325</b>. The operation (ADDI) <b>321</b> is valid when a flag F<b>4</b> is \u201ctrue=11\u201d in accordance with a value \u201cC4T\u201d of an execution condition field <b>322</b>, and a new value is written into a register R<b>3</b>. Since the flag F<b>4</b> becomes \u201c11\u201d when the value of the element of the array X is larger than XLIMIT or \u201c10\u201d when the value of the element of the array X is equal to or smaller than XLIMIT by a result of an operation (FCGT) <b>326</b>, the operation (ADDI) <b>321</b> consequently counts the number of elements of the array X whose values exceed XLIMIT. The branch operation (BRA) <b>323</b> branches to a label L<b>1</b> when a flag F<b>3</b> is \u201cfalse=10\u201d in accordance with a value \u201cC3F\u201d of an execution condition <b>324</b>. The flag F<b>3</b> becomes \u201c11\u201d when the operation (CMP) <b>327</b> is done for the last element of the array X and becomes \u201c10\u201d in other cases. That is, the branch operation (BRA) <b>323</b> is used to control the DO loop of FIG. 15. </p><p id=\"P-0119\" num=\"0119\">[0119]FIG. 17 is a schematic diagram showing a source program described in the C-language for executing a pointer manipulation, and FIG. 18 is a schematic diagram showing an assembler program which is obtained by translating the source program of FIG. 17. </p><p id=\"P-0120\" num=\"0120\">[0120] An instruction <b>330</b> executes three store operations (STW) <b>331</b>, <b>333</b>, and <b>335</b>. Values \u201c1\u201d, \u201c2\u201d, and \u201c3\u201d at the beginning of fields <b>332</b>, <b>334</b>, and <b>336</b> specify the timing of issuing the three store operations (STW) <b>331</b>, <b>333</b> and <b>335</b> in this instruction, respectively, these three store operations are executed sequentially. The operations <b>331</b>, <b>333</b>, and <b>335</b> are cut out by the extraction units <b>208</b>, <b>209</b>, and <b>210</b> of the instruction mapper <b>101</b>, respectively, decoded by the MS decoders <b>228</b>, <b>229</b>, and <b>230</b>, respectively, and outputted to the output processing unit <b>245</b>, respectively. The output processing unit <b>245</b> delays decoded results of the MS decoder <b>229</b> and <b>230</b> by one and two clock cycles, and supplies the delayed decoded results to the control circuit <b>103</b>, respectively, in accordance with a decoded result of the format field <b>10</b> which specifies the timing of issuing the respective operations. Hence, the three store operations (STW) <b>331</b>, <b>333</b>, and <b>335</b> are sequentially executed by the memory access unit <b>125</b>. </p><p id=\"P-0121\" num=\"0121\">[0121] An instruction <b>340</b> executes a load operation (LDW) <b>341</b>, a comparison operation (CMP) <b>343</b>, and a branch operation (BRA) <b>345</b>. Values \u201c1\u201d, \u201c2\u201d, and \u201c3\u201d at the beginning of fields <b>342</b>, <b>344</b>, and <b>346</b> specify the timing of issuing the three operations in this instruction, respectively. These three operations are executed sequentially. The operations <b>341</b>, <b>343</b>, and <b>345</b> are encoded into three operation fields <b>12</b>, <b>13</b>, and <b>14</b> of the format <b>1</b>, respectively, cut out by the extraction units <b>209</b>, <b>207</b>, and <b>202</b> of the instruction mapper <b>101</b>, respectively, decoded by the MS decoder <b>229</b>, the IS decoder <b>227</b>, and the PCS decoder <b>222</b>, respectively, and outputted to the output processing units <b>245</b>, <b>244</b>, and <b>241</b>, respectively. In accordance with a decoded result of the format field <b>10</b> which specifies the timing of issuing the respective operations, the output processing units <b>244</b> and <b>241</b> delay the decoded results one and two clock cycles, respectively, and output the delayed results to the control circuit <b>103</b> in a specified order. Hence, the operation (LDW) <b>341</b> is executed first, the operation (CMP) <b>343</b> is executed next,-and the operation (BRA) <b>345</b> is executed last. The operation (CMP) <b>343</b> uses the value which is loaded into the register R<b>1</b> as a result of the operation (LDW) <b>341</b>. The operation (BRA) <b>345</b> performs processing depending on the value of the flag F<b>3</b> which changes with a result of the operation (CMP) <b>343</b>. Therefore, the result of parallel execution of these three operation is different from the result of sequential execution of these three operations. </p><p id=\"P-0122\" num=\"0122\">[0122]FIG. 19 is a schematic diagram showing a source program described in the C-language in which conditional statements (if statements) are nested, and FIG. 20 is a schematic diagram showing an assembler program which is obtained by translating the source program of FIG. 19 into an assembler language. </p><p id=\"P-0123\" num=\"0123\">[0123] This program requires to perform special processing when a value of an element of an array is \u201c2\u201d, but otherwise it requires that elements of two arrays are scanned sequentially and either \u201c1\u201d or \u201c\u22121\u201d is returned depend on which array has a larger element value. </p><p id=\"P-0124\" num=\"0124\">[0124] An operation (IFG) <b>350</b> is an instruction for initializing a flag. When this operation is executed, only the flag F<b>0</b> becomes \u201cfalse=10\u201d and the other flags F<b>1</b> to F<b>7</b> become \u201cundefined=00\u201d. Since each operation has an execution condition in the data processor according to the present invention, a valid operation cannot be executed under a condition that all flags have the value \u201c00\u201d. Hence, only the flag F<b>0</b> is set to become \u201c10\u201d in an initial state so that an operation is executed on a premise that the flag F<b>0</b> has the value \u201c10\u201d in the most part of the program. </p><p id=\"P-0125\" num=\"0125\">[0125] An operation (CNE) <b>351</b> examines whether a value of the register R<b>3</b> and a value of the register R<b>4</b> are not equal to each other (\u201cnot equal\u201d), and reflects the result in the flag F<b>6</b>. </p><p id=\"P-0126\" num=\"0126\">[0126] An operation (CLT) <b>352</b> examines whether a value of the register R<b>3</b> is smaller than a value of the register R<b>4</b> (\u201cless than\u201d), and reflects the result in the flag F<b>7</b>. Since an execution condition of this instruction is specified as \u201cC6T\u201d, the flag F<b>7</b> is changed to \u201c11\u201d or \u201c10\u201d only when the flag F<b>6</b> is \u201ctrue=11\u201d. That is, when the flag F<b>6</b> is \u201cfalse=10\u201d, the flag F<b>7</b> is kept \u201cundefined=00\u201d. </p><p id=\"P-0127\" num=\"0127\">[0127] An operation (LDI) <b>353</b> is an operation whose result is validated when the flag F<b>7</b> is \u201c11\u201d so that a value \u201c\u22121\u201d is written into the register R<b>15</b>. </p><p id=\"P-0128\" num=\"0128\">[0128] An operation (LDI) <b>354</b> is an operation whose result is validated when the flag F<b>7</b> is \u201c10\u201d so that a value \u201c1\u201d is written into the register R<b>15</b>. </p><p id=\"P-0129\" num=\"0129\">[0129] An operation (JMP) <b>350</b> is an instruction which returns control to the caller routine when the flag F<b>6</b> is \u201c11\u201d. When \u201caa\u2260bb\u201d, a value \u201c1\u201d or \u201c\u22121\u201d is returned to the caller routine as a result of these three operations. When \u201caa=bb\u201d, no value is written into the register R<b>15</b> and control is not returned to the caller routine. </p><p id=\"P-0130\" num=\"0130\">[0130] [Other Embodiments]</p><p id=\"P-0131\" num=\"0131\">[0131] The first embodiment described above is related to a data processor in which the format field <b>10</b> of an instruction consists of four bits and an instruction which specifies two or three operations despite being one instruction is executed. However, it is possible to realize a data processor for executing an instruction which includes a format field specifying the format of the instruction and the sequence of operations even when the bit number of the format field or the number of operations which can be specified with one instruction is different from that of the first embodiment. </p><p id=\"P-0132\" num=\"0132\">[0132]FIG. 21 is a schematic diagram showing an instruction format used in a data processor according to a second embodiment of the present invention, in which the format field consists of two bits and one instruction includes one or two operation fields. </p><p id=\"P-0133\" num=\"0133\">[0133] The second embodiment uses two types of instruction formats. Reference numeral <b>401</b> is a format of a 2-operation instruction which is formed of one format field (FM) <b>410</b> and two operation fields <b>411</b> and <b>412</b>. Numeral <b>402</b> specifies a format of a 1-operation instruction which is formed of one format field (FM) <b>410</b> and one operation field <b>413</b>. In the second embodiment, an instruction has a fixed length of four bytes (thirty-two bits). Both the 2-operation instruction of the format <b>401</b> and the 1-operation instruction of the format <b>402</b> shown in FIG. 21 each have a length of four bytes in total. </p><p id=\"P-0134\" num=\"0134\">[0134] In the 2-operation instruction of the format <b>401</b>, the two operation fields <b>411</b> and <b>412</b> each specify one operation code of a 15-bit short format. In the 1-operation instruction of the format <b>402</b>, the one operation field <b>413</b> specifies one operation code of a 30-bit long format. </p><p id=\"P-0135\" num=\"0135\">[0135]FIG. 22 is a list showing the contents of the format field <b>410</b>, that is, detailed values and meanings of the format field <b>410</b>. In the second embodiment, the format field <b>410</b> has a 2-bit configuration and there are four types of the format field <b>410</b>. </p><p id=\"P-0136\" num=\"0136\">[0136] In the list, the symbols \u201c1st\u201d, \u201c2nd\u201d and \u201c---\u201d express similar meanings as those used in the first embodiment shown in FIG. 2. </p><p id=\"P-0137\" num=\"0137\">[0137] The format field <b>410</b> not only distinguishes the 2-operation instruction of the format <b>401</b> from the 1-operation instruction of the format <b>402</b> but also specifies the order of two operations. The order of the operations as herein termed includes an order for a case in which two operations are to be executed sequentially and an order for a case in which two operations are to be executed in parallel as shown in FIG. 22. </p><p id=\"P-0138\" num=\"0138\">[0138] A hardware configuration of the second embodiment is shown in FIG. 23. The hardware configuration is similar to the hardware configuration of the first embodiment shown in FIG. 10. A principal difference is that the instruction decoder and the integer operation unit for an integer operation are formed of two sub-blocks rather than of three sub-blocks. To be more specific, of the three sets designated by <b>112</b>, <b>113</b>, <b>114</b> and <b>122</b>, <b>123</b>, <b>124</b> in FIG. 10, the two sets designated by <b>112</b>, <b>113</b> and <b>122</b>, <b>123</b> form the instruction decoder and the integer operation unit for an integer operation. Another principal difference is that the instruction decoder <b>116</b> and the operation unit <b>126</b> for a floating-point operation are omitted. </p><p id=\"P-0139\" num=\"0139\">[0139]FIG. 24 is a block diagram showing a specific configuration of the instruction mapper <b>101</b> and the instruction decoder <b>102</b> which corresponds to the block diagram in FIG. 23. </p><p id=\"P-0140\" num=\"0140\">[0140] The instruction mapper <b>101</b> is configured by: the operation field extraction unit <b>200</b> for extracting the format field <b>410</b> and the operation fields <b>411</b> to <b>413</b> from a 32-bit instruction code outputted to the II bus <b>108</b>; and an FM decoder <b>621</b> for decoding the format field <b>410</b>. </p><p id=\"P-0141\" num=\"0141\">[0141] Each one of extraction units <b>601</b> to <b>613</b> of the operation field extraction unit <b>200</b> extracts some of bit fields of an instruction code on the II bus <b>108</b> and outputs a bit string of each operation field corresponding to each one of the decoders <b>111</b> to <b>113</b> and <b>115</b> configuring the instruction decoder <b>102</b>. Of the thirty-two bits on the II bus <b>108</b>, the extraction unit <b>601</b> extracts bit <b>0</b> to bit <b>1</b>, the extraction unit <b>602</b> extracts bit <b>2</b> to bit <b>16</b>, the extraction unit <b>603</b> extracts bit <b>17</b> to bit <b>31</b>, the extraction unit <b>604</b> extracts bit <b>2</b> to bit <b>31</b>, the extraction unit <b>605</b> extracts bit <b>2</b> to bit <b>16</b>, the extraction unit <b>606</b> extracts bit <b>17</b> to bit <b>31</b>, the extraction unit <b>607</b> extracts bit <b>2</b> to bit <b>31</b>, the extraction unit <b>608</b> extracts bit <b>2</b> to bit <b>16</b>, the extraction unit <b>609</b> extracts bit <b>17</b> to bit <b>31</b>, the extraction unit <b>610</b> extracts bit <b>2</b> to bit <b>31</b>, the extraction unit <b>611</b> extracts bit <b>2</b> to bit <b>16</b>, the extraction unit <b>612</b> extracts bit <b>17</b> to bit <b>31</b>, and the extraction unit <b>613</b> extracts bit <b>2</b> to bit <b>31</b>. Extracted bits are outputted to the instruction decoder <b>102</b>. </p><p id=\"P-0142\" num=\"0142\">[0142] The instruction decoder <b>102</b> (PCD <b>111</b>, IAD <b>112</b>, IBD <b>113</b>, MD <b>115</b>) is configured by the decoder unit <b>220</b> and the output processing unit <b>240</b>. More specifically, the PCD <b>111</b> is configured by a PCS decoder <b>622</b> for decoding a jump operation code of the short format extracted by the extraction unit <b>602</b>, a PCS decoder <b>623</b> for decoding a jump operation code of the short format extracted by the extraction unit <b>603</b>, a PCL decoder <b>624</b> for decoding a jump operation code of the long format extracted by the extraction unit <b>604</b>, and an output processing unit <b>641</b>. To the control circuit <b>103</b>, the output processing unit <b>641</b> outputs control signals which instruct for executing a jump operation according to an output from the PCS decoder <b>622</b>, <b>623</b> or the PCL decoder <b>624</b>, a non-jump operation for adding \u201c8\u201d to a current PC value, or a null operation, in accordance with decoded results performed by the four decoders, i.e., the PCS decoders <b>622</b> and <b>623</b>, the PCL decoder <b>624</b>, and the FM decoder <b>621</b>. </p><p id=\"P-0143\" num=\"0143\">[0143] The IAD <b>112</b> is configured by an IS decoder <b>625</b> for decoding an integer operation code of the short format extracted by the extraction unit <b>605</b>, an IS decoder <b>626</b> for decoding an integer operation code of the short format extracted by the extraction unit <b>606</b>, an IL decoder <b>627</b> for decoding an integer operation code of the long format extracted by the extraction unit <b>607</b>, and an output processing unit <b>642</b>. To the control circuit <b>103</b>, the output processing unit <b>642</b> outputs control signals which instruct for executing an integer operation according to an output from the IS decoder <b>625</b>, <b>626</b> or the IL decoder <b>627</b>, or a null operation, in accordance with decoded results performed by the four decoders, i.e., the IS decoders <b>625</b> and <b>626</b>, the IL decoder <b>627</b>, and the FM decoder <b>621</b>. </p><p id=\"P-0144\" num=\"0144\">[0144] The IBD <b>113</b> is configured by an IS decoder <b>628</b> for decoding an integer operation code of the short format extracted by the extraction unit <b>608</b>, an IS decoder <b>629</b> for decoding an integer operation code of the short format extracted by the extraction unit <b>609</b>, an IL decoder <b>630</b> for decoding an integer operation code of the long format extracted by the extraction unit <b>610</b> and an output processing unit <b>643</b>. To the control circuit <b>103</b>, the output processing unit <b>643</b> outputs control signals which instruct for executing an integer operation according to an output from the IS decoder <b>628</b>, <b>629</b> or the IL decoder <b>630</b>, or a null operation, in accordance with decoded results performed by the four decoders, i.e., the IS decoders <b>628</b> and <b>629</b>, the IL decoder <b>630</b>, and the FM decoder <b>621</b>. </p><p id=\"P-0145\" num=\"0145\">[0145] The MD <b>115</b> is configured by MS decoders <b>631</b> and <b>632</b> for decoding memory access operation codes of the short format extracted by the extraction units <b>611</b> and <b>612</b>, an ML decoder <b>633</b> for decoding memory access operation codes of the long format extracted by the extraction unit <b>613</b>, and an output processing unit <b>644</b>. To the control circuit <b>103</b>, the output processing unit <b>644</b> outputs control signals which instruct for executing a memory access operation according to an output from the MS decoder <b>631</b>, <b>632</b> or the ML decoder <b>633</b>, or a null operation, in accordance with decoded results performed by the four decoders, i.e., the MS decoders <b>631</b> and <b>632</b>, the ML decoder <b>633</b>, and the FM decoder <b>621</b>. </p><p id=\"P-0146\" num=\"0146\">[0146] Outputs from the output processing unit <b>640</b> (<b>641</b> to <b>644</b>) are inputted to the control circuit <b>103</b> and used to control an operation performed by the operation unit <b>104</b>. More particularly, an output from the output processing unit <b>641</b> is used to control of a PC calculation performed by the PC unit <b>121</b>. Outputs from the output processing units <b>642</b> and <b>643</b> are used to control integer operations performed by the integer operation mechanisms (IA, IB) <b>122</b> and <b>123</b> of the integer operation unit <b>120</b>, respectively. An output from the output processing unit <b>644</b> is used to control a memory access operation performed by the memory access unit <b>125</b>. </p><p id=\"P-0147\" num=\"0147\">[0147]FIG. 25 is a schematic diagram showing an instruction format used in a data processor according to a third embodiment of the present invention, in which one or two 1-bit format fields are used and one instruction includes one or two operation fields. </p><p id=\"P-0148\" num=\"0148\">[0148] The third embodiment uses two types of instruction formats. Reference numeral <b>501</b> is a format of a 2-operation instruction which is formed of two format fields (FM) <b>505</b> and <b>506</b> each consisting of one bit, and two operation fields <b>511</b> and <b>512</b> each consisting of fifteen bits. Numeral <b>502</b> designates a format of a 1-operation instruction which is formed of one format field <b>505</b> consisting of one bit and one operation field <b>513</b> consisting of thirty-one bits. In the third embodiment, an instruction has a fixed length of four bytes (thirty-two bits). Both the 2-operation instruction of the format <b>501</b> and the 1-operation instruction of a format <b>502</b> shown in FIG. 25 each have a length of four bytes in total. </p><p id=\"P-0149\" num=\"0149\">[0149] In the 2-operation instruction of the format <b>501</b>, the two operation fields <b>511</b> and <b>512</b> each designate one operation code of a 15-bit short format. In the 1-operation instruction of the format <b>502</b>, the one operation field <b>513</b> specifies one operation code of a 31-bit long format. </p><p id=\"P-0150\" num=\"0150\">[0150]FIG. 26 is a list showing the contents of the format fields <b>505</b> and <b>506</b>, that is, detailed values and meanings of the format fields <b>505</b> and <b>506</b>. In the third embodiment, the format fields <b>505</b> and <b>506</b> each have a 1-bit configuration. Three types can be specified by total, i.e., two types can be specified for the instruction format <b>501</b> and one type can be specified for the instruction format <b>502</b>. In the list, the symbols \u201c1st\u201d, \u201c2nd\u201d and \u201c\u2014---\u201d express similar meanings as those used in the first and the second embodiments shown in FIG. 2 and FIG. 22 described earlier. </p><p id=\"P-0151\" num=\"0151\">[0151] The format fields <b>505</b> and <b>506</b> in the instruction formats used in the third embodiment are obtained by reducing and dividing the format field <b>410</b> which is in the instruction formats used in the second embodiment described above. The format field (FM) of the 2-operation instruction format <b>501</b> is divided into two fields <b>505</b> and <b>506</b> in the third embodiment. As compared with the second embodiment, in the third embodiment, the number of combinations of the format of an instruction and the sequence of executing operations which can be specified by the format fields <b>505</b> and <b>506</b> is reduced to three from four. However, instead of this, the length of the operation field <b>513</b> of the instruction format <b>502</b> of the long type is increased from thirty bits to thirty-one bits, and in addition, the operation fields <b>511</b> and <b>512</b> of the instruction format <b>501</b> of the short type are allocated in such a manner that the operation fields <b>511</b> and <b>512</b> do not cross a 16-bit boundary between the bit <b>15</b> and the bit <b>16</b>. </p><p id=\"P-0152\" num=\"0152\">[0152] The hardware configuration of the third embodiment is similar to the hardware configuration of the second embodiment which is shown in FIG. 23. </p><p id=\"P-0153\" num=\"0153\">[0153]FIG. 27 is a block diagram showing an example of a specific configuration of the instruction mapper <b>101</b> and the instruction decoder <b>102</b> corresponding to the hardware configuration according to the third embodiment of the present invention. </p><p id=\"P-0154\" num=\"0154\">[0154] The instruction mapper <b>101</b> is configured by: the operation field extraction unit <b>200</b> for extracting the format fields <b>505</b> and <b>506</b> and the operation fields <b>511</b> to <b>513</b> from a 32-bit instruction code outputted to the II bus <b>108</b>; and an FM decoder <b>721</b> for decoding the format fields <b>505</b> and <b>506</b>. </p><p id=\"P-0155\" num=\"0155\">[0155] Each one of extraction units <b>701</b> to <b>713</b> of the operation field extraction unit <b>200</b> extracts some of bit fields of an instruction code on the II bus <b>108</b> and outputs a bit string of each operation field which corresponds to each one of the decoders <b>111</b> to <b>113</b> and <b>115</b> configuring the instruction decoder <b>102</b>. Of the thirty-two bits on the II bus <b>108</b>, the extraction unit <b>701</b> extracts bit <b>0</b> and bit <b>16</b>, the extraction unit <b>702</b> extracts bit <b>1</b> to bit <b>15</b>, the extraction unit <b>703</b> extracts bit <b>17</b> to bit <b>31</b>, the extraction unit <b>704</b> extracts bit <b>1</b> to bit <b>31</b>, the extraction unit <b>705</b> extracts bit <b>1</b> to bit <b>15</b>, the extraction unit <b>706</b> extracts bit <b>17</b> to bit <b>31</b>, the extraction unit <b>707</b> extracts bit <b>1</b> to bit <b>31</b>, the extraction unit <b>708</b> extracts bit <b>1</b> to bit l<b>5</b>, the extraction unit <b>709</b> extracts bit <b>17</b> to bit <b>31</b>, the extraction unit <b>710</b> extracts bit <b>1</b> to bit <b>31</b>, the extraction unit <b>711</b> extracts bit <b>1</b> to bit <b>15</b>, the extraction unit <b>712</b> extracts bit <b>17</b> to bit <b>31</b>, and the extraction unit <b>713</b> extracts bit <b>1</b> to bit <b>31</b>. Extracted bits are outputted to the instruction decoder <b>102</b>. </p><p id=\"P-0156\" num=\"0156\">[0156] The instruction decoder <b>102</b> (PCD <b>111</b>, IAD <b>112</b>, IBD <b>113</b>, MD <b>115</b>) is configured by the decoder unit <b>220</b> and the output processing unit <b>240</b>. More specifically, the PCD <b>111</b> is configured by a PCS decoder <b>722</b> for decoding a jump operation code of the short format extracted by the extraction unit <b>702</b>, a PCS decoder <b>723</b> for decoding a jump operation code of the short format extracted by the extraction unit <b>703</b>, a PCL decoder <b>724</b> for decoding a jump operation code of the long-format extracted by the extraction unit <b>704</b>, and an output processing unit <b>741</b>. To the control circuit <b>103</b>, the output processing unit <b>741</b> outputs control signals which instruct for executing a jump operation according to an output from the PCS decoder <b>722</b>, <b>723</b>, or the PCL decoder <b>724</b>, a non-jump operation for adding \u201c8\u201d to a current PC value, or a null operation, in accordance with decoded results performed by the four decoders, i.e., the PCS decoders <b>722</b> and <b>723</b>, the PCL decoder <b>724</b>, and the FM decoder <b>721</b>. </p><p id=\"P-0157\" num=\"0157\">[0157] The IAD <b>112</b> is configured by an IS decoder <b>725</b> for decoding an integer operation code of the short format extracted by the extraction unit <b>705</b>, an IS decoder <b>726</b> for decoding an integer operation code of the short format extracted by the extraction unit <b>706</b>, an IL decoder <b>727</b> for decoding an integer operation code of the long format extracted by the extraction unit <b>707</b>, and an output processing unit <b>742</b>. To the control circuit <b>103</b>, the output processing unit <b>742</b> outputs control signals which instruct for executing an integer operation according to an output from the IS decoder <b>725</b>, <b>726</b>, or the IL decoder <b>727</b>, or a null operation, in accordance with decoded results performed by the four decoders, i.e., the IS decoders <b>725</b> and <b>726</b>, the IL decoder <b>727</b>, and the FM decoder <b>721</b>. </p><p id=\"P-0158\" num=\"0158\">[0158] The IBD <b>113</b> is configured by an IS decoder <b>728</b> for decoding an integer operation code of the short format extracted by the extraction unit <b>708</b>, an IS decoder <b>729</b> for decoding an integer operation code of the short format extracted by the extraction unit <b>709</b>, an IL decoder <b>730</b> for decoding an integer operation code of the long format extracted by the extraction unit <b>710</b>, and an output processing unit <b>743</b>. To the control circuit <b>103</b>, the output processing unit <b>743</b> outputs control signals which instruct for executing an integer operation according to an output from the IS decoder <b>728</b>, <b>729</b>, or the IL decoder <b>730</b>, or a null operation, in accordance with results of decoding performed by the four decoders, i.e., the IS decoders <b>728</b> and <b>729</b>, the IL decoder <b>730</b>, and the FM decoder <b>721</b>. </p><p id=\"P-0159\" num=\"0159\">[0159] The MD <b>115</b> is configured by MS decoders <b>731</b> and <b>732</b> for decoding memory access operation codes of the short format extracted by the-extraction units <b>711</b> and <b>712</b>, an ML decoder <b>733</b> for decoding memory access operation codes of the long format extracted by the extraction unit <b>713</b>, and an output processing unit <b>744</b>. To the control circuit <b>103</b>, the output processing unit <b>744</b> outputs control signals which instruct for executing a memory access operation according to an output from one of the MS decoders <b>731</b>, <b>732</b>, and the ML decoder <b>733</b> or a null operation, in accordance with results of decoding performed by the four decoders, i.e., the MS decoders <b>731</b> and <b>732</b>, the ML decoder <b>733</b>, and the FM decoder <b>721</b>. </p><p id=\"P-0160\" num=\"0160\">[0160] Outputs from the output processing unit <b>740</b> (<b>741</b> to <b>744</b>) are inputted to the control circuit <b>103</b> and used to control an operation performed by the operation unit <b>104</b>. More particularly, an output from the output processing unit <b>41</b> is used to control a PC calculation performed by the PC unit <b>121</b>. Outputs from the output processing units <b>742</b> and <b>743</b> are used to control integer operations performed by the integer operation mechanisms (IA, IB) <b>122</b> and <b>123</b> of the integer operation unit <b>120</b>, respectively. An output from the output processing unit <b>744</b> is used to control a memory access operation performed by the memory access unit <b>125</b>. </p><p id=\"P-0161\" num=\"0161\">[0161] Each embodiment described above is related to a case where the types of operations arranged in operation fields are not limited as much as possible. However, as far as the types of operations which are arranged in operation fields may be limited, the data processor according to the present invention is realized with a hardware configuration being much simpler than that shown in FIG. 10. </p><p id=\"P-0162\" num=\"0162\">[0162] For example, when the symmetry of operations which can be arranged in the operation fields <b>511</b> and <b>512</b> of the third embodiment is eliminated, and the format fields <b>505</b> and <b>506</b> are \u201c01\u201d, operations are executed in parallel only when one of the operations is a null operation (i.e., there is no parallel operation in reality and parallel decoding alone is necessary) by limiting that a null operation only can be arranged in the operation field <b>512</b>. Then the operation fields <b>511</b> and <b>512</b> are always decoded sequentially by one instruction decoder. The scale of the hardware can be reduced to approximately half that of a case where operations can be arranged in both operation fields <b>511</b> and <b>512</b>. </p><p id=\"P-0163\" num=\"0163\">[0163] A data processor according to the present invention comprises an instruction decoder for decoding an instruction and. outputting control signals and a plurality of operating means, which are connected to the instruction decoder, for executing the instruction in accordance with the control signals. In the data processor, the instruction decoder outputs control signals for executing two operations while two operating means execute the operations when a 64-bit 2-operation instruction which consists of two operation fields and a format field is executed, for example, whereas the instruction decoder outputs control signals for executing three operations while three operating means execute the operations when a 64-bit 3-operation instruction which consists of three operation fields and a format field is executed, for example. Thus, in the data processor according to the present invention, by adjusting the number of operations which can be specified with one instruction while maintaining the length of instructions constant, an operation which includes a large quantity of necessary information, such as the register number and an immediate and in which operation codes are long, and an operation which includes a small quantity of the necessary information in which operation codes are short can be encoded into instruction codes having a fixed length. Hence, since processing for specifying an instruction length is not necessary and boundaries between instructions are always located at aligned address boundaries, instruction decoding becomes easy and a program can be described at an improved coding efficiency. </p><p id=\"P-0164\" num=\"0164\">[0164] Further, a data processor according to the present invention comprises an instruction decoder for decoding an instruction and outputting control signals and a plurality of operating means, which are connected to the instruction decoder, for executing the instruction in accordance with the control signals. In the data processor, when a plural operation instruction consisting of two or three operation fields and a format field which specifies the number of operation fields and an order of executing operations specified by the operation fields is executed, for instance, the instruction decoder decodes a plural operation instruction and outputs two or three control signal groups in an order specified by the format field while two or three operating means execute operations specified by the respective control signal group. Thus, in the data processor according to the present invention, it is possible to change the number of operations which can be encoded with one instruction and the order of execution of encoded operations. Hence, a program can be described at an improved coding efficiency, using a fixed length plural operation instruction which determine the order of execution of the operations without using useless null operations. </p><p id=\"P-0165\" num=\"0165\">[0165] Further, a data processor according to the present invention comprises an instruction decoder for decoding an instruction and outputting control signals and a plurality of operating means, which are connected to the instruction decoder, for executing the instruction in accordance with the control signals. In the data processor, when a plural operation instruction consisting of two or three operation fields and a format field which specifies the number of operation fields and an order of execution of operations specified by the operation fields is executed, for instance, the instruction decoder decodes a plural operation instruction and outputs two or three control signal groups in an order specified by the format field while two or three operating means sequentially execute operations specified by the respective control signal group, or when a plurality of operation instruction consisting of two or three operation fields and a format field which specifies the number of operation fields and simultaneous execution of operations specified by the operation fields is executed, the instruction decoder decodes a plural operation instruction and concurrently outputs two or three control signal groups while two or three operating means simultaneously execute operations specified by the control signal groups. Thus, it is possible to specify the number of operations which can be encoded with one instruction and to specify whether to simultaneously execute encoded operations or to sequentially execute encoded operations in the data processor according to the present invention. Hence, when operations which can be simultaneously executed in response to a fixed length plural operation instruction are simultaneously encoded and executed at high speed while operations which need be arranged in an order are encoded without using useless null operations at better coding efficiency and sequentially executed, a compact, high-speed program can be described. </p><p id=\"P-0166\" num=\"0166\">[0166] Further, a data processor according to the present invention comprises an integer operation decoder for decoding a first operation field of an instruction and outputting control signals regarding an integer operation, an integer operation execution unit which is connected to the decoder to operate in accordance with the control signals regarding the integer operation, a memory access operation decoder for decoding the same operation field of the instruction and outputting control signals regarding memory accessing, and a memory access unit which is connected to the decoder to operate in accordance with the control signals regarding the memory accessing. In the data processor, when an instruction which specifies an integer addition by an operation field is processed, both the integer operation decoder and the memory access operation decoder decode the operation fields which specify the integer addition at the same time, the integer operation decoder outputs the control signals regarding the integer operation, the memory access operation decoder outputs the control signals regarding a null operation, the integer operation execution unit executes the integer-addition and the memory access unit does not execute a valid memory access operation. Then an instruction which specifies a load operation of loading data into a register from a memory in an operation field is processed, both the integer operation decoder and The memory access operation decoder decode the operation field which specifies the load operation simultaneously, the integer operation decoder outputs the control signals regarding a null operation, the memory access operation decoder outputs the control signals regarding a load operation, and the memory access unit executes the load operation. Thus, in the data processor according to the present invention, since one of two different operation execution units executes a valid operation for one operation field specified by the instruction while the other one of the two different operation units does not execute a valid operation, the two types of the operation execution units each operates in accordance with the control signal outputted from the-exclusive decoder to process the instruction, depending on the type of the operation. Hence, the wiring of control signals connecting the decoders and the operation execution units becomes simple, thereby making it easy to design the circuit configuration. Further, each decoder has a simple function and can decode at high speed. </p><p id=\"P-0167\" num=\"0167\">[0167] Further, a data processor according to the present invention comprises a first decoder for decoding a first operation field of an instruction and outputting a first control signal, a second decoder for decoding a second operation field and outputting a second control signal, an output processing unit which is connected to the first and the second decoders to receive both the first and the second control signals and selectively outputs one of the first and the second control signals, and a memory access unit which is connected to the output processing unit to operate in accordance with the control signal which is outputted from the output processing unit. In order to process a first instruction in which a load operation of loading data from a memory is specified by a first operation field and an addition of integers is specified by a second operation field, for instance, the first and the second decoders decode the first and the second operation fields at the same time, the first decoder outputs a control signal regarding the load operation, the second decoder outputs a control signal regarding a null operation, the output processing unit selectively outputs the control signal regarding the load operation to the memory access unit, the memory access unit executes the load operation, and in order to process a second instruction in which a right shift operation is specified by the first operation field and a load operation is specified by the second operation field, the first and the second decoders decode the first and the second operation fields in parallel, the first decoder outputs the control signal regarding a null operation, the second decoder outputs the control signal regarding the load operation, the output processing unit selectively outputs the control signal regarding the load operation to the memory access unit, the memory access unit executes the load operation. Thus, in the data processor according to the present invention, the plurality of decoders decode operation fields in parallel regardless of which one of a plurality of operation fields included in an instruction specifies an operation, the output processing unit eliminates a null operation from a result of the decoding and selectively outputs a valid operation to the operation units, and the same operation execution unit executes the specified operation. Hence, a data processor which executes an operation specified by operation fields whose number is larger than that of the operation execution units at high speed can be realized at an inexpensive cost. </p><p id=\"P-0168\" num=\"0168\">[0168] As this invention may be embodied in several forms without departing from the spirit of essential characteristics thereof, the present embodiments are therefore illustrative and not restrictive, since the scope of the invention is defined by the appended claims rather than by the description preceding them, and all changes that fall within the metes and bounds of the claims, or equivalence of such metes and bounds thereof are therefore intended to be embraced by the claims.  \n<tables id=\"TABLE-US-00001\" num=\"1\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"28PT\"></colspec><thead><row><entry></entry><entry align=\"center\" nameend=\"4\" namest=\"OFFSET\">TABLE 1</entry></row><row><entry></entry><entry></entry></row><row><entry></entry><entry align=\"center\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\"></entry></row><row><entry></entry><entry>MNEMONIC</entry><entry>FUNCTION</entry><entry>FORMAT</entry><entry>TYPE</entry></row><row><entry></entry><entry align=\"center\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"56PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry>\u20021</entry><entry>MOV Rm, Rd</entry><entry>Copy word from a reg. to</entry><entry>SR</entry><entry>Integer</entry></row><row><entry></entry><entry></entry><entry>another reg.</entry></row><row><entry>\u20022</entry><entry>CMP/f Rm, Rn</entry><entry>Compare general</entry><entry>SR</entry><entry>Integer</entry></row><row><entry>\u20023</entry><entry>CMPI/f exp, Rm</entry><entry>Compare general immediate</entry><entry>SI</entry><entry>Integer</entry></row><row><entry>\u20024</entry><entry>ADD Rm, Rd</entry><entry>Add</entry><entry>SR</entry><entry>Integer</entry></row><row><entry>\u20025</entry><entry>ADDI exp, Rd</entry><entry>Add immediate</entry><entry>SI</entry><entry>Integer</entry></row><row><entry>\u20026</entry><entry>MUL Rm, Rd</entry><entry>Multiply</entry><entry>SR</entry><entry>Integer</entry></row><row><entry>\u20027</entry><entry>SUB Rm, Rd</entry><entry>Subtract</entry><entry>SR</entry><entry>Integer</entry></row><row><entry>\u20028</entry><entry>SHLI exp, Rd</entry><entry>Shift left immediate</entry><entry>SI</entry><entry>Integer</entry></row><row><entry>\u20029</entry><entry>SHRAI exp, Rd</entry><entry>Shift right arithmetic</entry><entry>SI</entry><entry>Integer</entry></row><row><entry></entry><entry></entry><entry>immediate</entry></row><row><entry>10</entry><entry>SHRLI exp, Rd</entry><entry>Shift right logical</entry><entry>SI</entry><entry>Integer</entry></row><row><entry></entry><entry></entry><entry>immediate</entry></row><row><entry>11</entry><entry>SHVL Rm, Rd</entry><entry>Shift logical</entry><entry>SR</entry><entry>Integer</entry></row><row><entry>12</entry><entry>AND Rm, Rd</entry><entry>Logical AND</entry><entry>SR</entry><entry>Integer</entry></row><row><entry>13</entry><entry>NOT Rm, Rd</entry><entry>Logical NOT</entry><entry>SR</entry><entry>Integer</entry></row><row><entry>14</entry><entry>OR Rm, Rd</entry><entry>Logical OR</entry><entry>SR</entry><entry>Integer</entry></row><row><entry>15</entry><entry>XOR Rm, Rd</entry><entry>Logical exclusive OR</entry><entry>SR</entry><entry>Integer</entry></row><row><entry>16</entry><entry>BCLR Rm, Rd</entry><entry>Clear a bit</entry><entry>SR</entry><entry>Integer</entry></row><row><entry>17</entry><entry>BCLRI exp, Rd</entry><entry>Clear a bit immediate</entry><entry>SI</entry><entry>Integer</entry></row><row><entry>18</entry><entry>BNOT Rm, Rd</entry><entry>Invert a bit</entry><entry>SR</entry><entry>Integer</entry></row><row><entry>19</entry><entry>BNOTI exp, Rd</entry><entry>Invert a bit immediate</entry><entry>SI</entry><entry>Integer</entry></row><row><entry>20</entry><entry>BSET Rm, Rd</entry><entry>Set a bit</entry><entry>SR</entry><entry>Integer</entry></row><row><entry>21</entry><entry>BSETI exp, Rd</entry><entry>Set a bit</entry><entry>SI</entry><entry>Integer</entry></row><row><entry>22</entry><entry>BTST Rm, Rn</entry><entry>Test a bit</entry><entry>SR</entry><entry>Integer</entry></row><row><entry>23</entry><entry>BTSTI exp, Rn</entry><entry>Test a bit</entry><entry>SI</entry><entry>Integer</entry></row><row><entry>24</entry><entry>FMOV FRm.</entry><entry>Copy data from a floating-</entry><entry>SR</entry><entry>FP</entry></row><row><entry></entry><entry>FRd</entry><entry>point reg. to another</entry></row><row><entry></entry><entry></entry><entry>floating-point reg.</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables>\n</p><p id=\"P-0169\" num=\"0169\">[0169]<tables id=\"TABLE-US-00002\" num=\"2\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"35PT\"></colspec><thead><row><entry></entry><entry align=\"center\" nameend=\"4\" namest=\"OFFSET\">TABLE 2</entry></row><row><entry></entry><entry></entry></row><row><entry></entry><entry align=\"center\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\"></entry></row><row><entry></entry><entry>MNEMONIC</entry><entry>FUNCTION</entry><entry>FORMAT</entry><entry>TYPE</entry></row><row><entry></entry><entry align=\"center\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"35PT\"></colspec><tbody valign=\"top\"><row><entry>\u20021</entry><entry>LDB src, Rd</entry><entry>Load one byte to a reg.</entry><entry>SM, LM</entry><entry>Memory</entry></row><row><entry></entry><entry></entry><entry>with extension</entry></row><row><entry>\u20022</entry><entry>LDBU src, Rd</entry><entry>Load one byte to a reg.</entry><entry>SM, LM</entry><entry>Memory</entry></row><row><entry></entry><entry></entry><entry>with zero extension</entry></row><row><entry>\u20023</entry><entry>LDH src, Rd</entry><entry>Load one halfword to a</entry><entry>SM, LM</entry><entry>Memory</entry></row><row><entry></entry><entry></entry><entry>reg. with sign extension</entry></row><row><entry>\u20024</entry><entry>LDHU src, Rd</entry><entry>Load one halfword to a</entry><entry>SM, LM</entry><entry>Memory</entry></row><row><entry></entry><entry></entry><entry>reg. with zero extension</entry></row><row><entry>\u20025</entry><entry>LDI exp, Rd</entry><entry>Load immediate with sign</entry><entry>SI, LI</entry><entry>Integer</entry></row><row><entry></entry><entry></entry><entry>extension</entry></row><row><entry>\u20026</entry><entry>LDIU src, Rd</entry><entry>Load immediate with zero</entry><entry>SI, LI</entry><entry>Integer</entry></row><row><entry></entry><entry></entry><entry>extension</entry></row><row><entry>\u20027</entry><entry>LDW src, Rd</entry><entry>Load one word to a reg.</entry><entry>SM, LM</entry><entry>Memory</entry></row><row><entry>\u20028</entry><entry>LDW2 src, Rd</entry><entry>Load two words to</entry><entry>SM, LM</entry><entry>Memory</entry></row><row><entry></entry><entry></entry><entry>registers</entry></row><row><entry>\u20029</entry><entry>STB Rm, dest</entry><entry>Store one byte from a reg.</entry><entry>SM, LM</entry><entry>Memory</entry></row><row><entry>10</entry><entry>STH Rm, dest</entry><entry>Store one halfword from a</entry><entry>SM, LM</entry><entry>Memory</entry></row><row><entry></entry><entry></entry><entry>reg.</entry></row><row><entry>11</entry><entry>STW Rm, dest</entry><entry>Store one word from a reg.</entry><entry>SM, LM</entry><entry>Memory</entry></row><row><entry>12</entry><entry>STW4 Rm,</entry><entry>Store four words from</entry><entry>SM, LM</entry><entry>Memory</entry></row><row><entry></entry><entry>dest</entry><entry>registers</entry></row><row><entry>13</entry><entry>BRA pcdisp</entry><entry>Branch (PC-relative)</entry><entry>SB, LB</entry><entry>PC</entry></row><row><entry>14</entry><entry>BSR pcdisp</entry><entry>Branch to subroutine</entry><entry>SB, LB</entry><entry>PC</entry></row><row><entry></entry><entry></entry><entry>(PC-relative)</entry></row><row><entry>15</entry><entry>JMP pcadr</entry><entry>Jump</entry><entry>SM, LM</entry><entry>PC</entry></row><row><entry>16</entry><entry>JSR pcadr</entry><entry>Jump to subroutine</entry><entry>SM, LM</entry><entry>PC</entry></row><row><entry>17</entry><entry>NOP</entry><entry>NO operation</entry><entry>SB, LB</entry><entry>Integer</entry></row><row><entry>18</entry><entry>FLD/s src, FRd</entry><entry>Load data to a floating-</entry><entry>SM, LM</entry><entry>Memory</entry></row><row><entry></entry><entry></entry><entry>point reg.</entry></row><row><entry>19</entry><entry>FST/s FRm,</entry><entry>Store data from a float-</entry><entry>SM, LM</entry><entry>Memory</entry></row><row><entry></entry><entry>dest</entry><entry>ing-point reg.</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p id=\"P-0170\" num=\"0170\">[0170]<tables id=\"TABLE-US-00003\" num=\"3\"><table colsep=\"0\" frame=\"none\" pgwide=\"1\" rowsep=\"0\"><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"35PT\"></colspec><thead><row><entry></entry><entry align=\"center\" nameend=\"4\" namest=\"OFFSET\">TABLE 3</entry></row><row><entry></entry><entry></entry></row><row><entry></entry><entry align=\"center\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\"></entry></row><row><entry></entry><entry>MNEMONIC</entry><entry>FUNCTION</entry><entry>FORMAT</entry><entry>TYPE</entry></row><row><entry></entry><entry align=\"center\" nameend=\"4\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"35PT\"></colspec><tbody valign=\"top\"><row><entry>\u20021</entry><entry>IFG</entry><entry>Initialize flags</entry><entry>MISC</entry><entry>Integer</entry></row><row><entry>\u20022</entry><entry>LDILH src, Rd</entry><entry>Load immediate to lower</entry><entry>LI</entry><entry>Integer</entry></row><row><entry></entry><entry></entry><entry>halfword</entry></row><row><entry>\u20023</entry><entry>LDIUH src, Rd</entry><entry>Load immediate to upper</entry><entry>LI</entry><entry>Memory</entry></row><row><entry></entry><entry></entry><entry>halfword</entry></row><row><entry>\u20024</entry><entry>LDW3 src, Rd</entry><entry>Load three words to</entry><entry>LM</entry><entry>Memory</entry></row><row><entry></entry><entry></entry><entry>registers</entry></row><row><entry>\u20025</entry><entry>LDW4 src, Rd</entry><entry>Load four words to</entry><entry>LM</entry><entry>Memory</entry></row><row><entry></entry><entry></entry><entry>registers</entry></row><row><entry>\u20026</entry><entry>MFFG Rd</entry><entry>Move from flags</entry><entry>MISC</entry><entry>Integer</entry></row><row><entry>\u20027</entry><entry>MTFG Rm</entry><entry>Move to flags</entry><entry>MISC</entry><entry>Integer</entry></row><row><entry>\u20028</entry><entry>STW2 Rm, dest</entry><entry>Store two words from</entry><entry>LM</entry><entry>Memory</entry></row><row><entry></entry><entry></entry><entry>registers</entry></row><row><entry>\u20029</entry><entry>STW3 Rm, dest</entry><entry>Store three words from</entry><entry>LM</entry><entry>Memory</entry></row><row><entry></entry><entry></entry><entry>registers</entry></row><row><entry>10</entry><entry>CAcc/c Rm</entry><entry>Compare and logical AND</entry><entry>LR</entry><entry>Integer</entry></row><row><entry></entry><entry>Rn, Fs, Fd</entry></row><row><entry>11</entry><entry>CAIcc/c exp,</entry><entry>Compare immediate and</entry><entry>LI</entry><entry>Integer</entry></row><row><entry></entry><entry>Rm, Fs, Fd</entry><entry>logical AND</entry></row><row><entry>12</entry><entry>Ccc Rm, Rn, Fd</entry><entry>Compare</entry><entry>LR</entry><entry>Integer</entry></row><row><entry>13</entry><entry>CIcc exp, Rm, Fd</entry><entry>Compare immediate</entry><entry>LI</entry><entry>Integer</entry></row><row><entry>14</entry><entry>CSTRcc Rm,</entry><entry>Compare byte strings</entry><entry>LR</entry><entry>Integer</entry></row><row><entry></entry><entry>Rn, Fd</entry></row><row><entry>15</entry><entry>CUAcc/c Rm.</entry><entry>Compare unsigned and log-</entry><entry>LR</entry><entry>Integer</entry></row><row><entry></entry><entry>Rn, Fs, Fd</entry><entry>ical AND</entry></row><row><entry>16</entry><entry>CUAIcc/c exp,</entry><entry>Compare immediate unsigned</entry><entry>LI</entry><entry>Integer</entry></row><row><entry></entry><entry>Rm, Fs, Fd</entry><entry>and logical AND</entry></row><row><entry>17</entry><entry>CUcc Rm, Rn, Fd</entry><entry>Compare unsigned</entry><entry>LR</entry><entry>Integer</entry></row><row><entry>18</entry><entry>CUIcc exp,</entry><entry>Compare immediate unsigned</entry><entry>LI</entry><entry>Integer</entry></row><row><entry></entry><entry>Rm, Fd</entry></row><row><entry>19</entry><entry>ADD3 Rm, Rn, Rd</entry><entry>Add with three operands</entry><entry>LR</entry><entry>Integer</entry></row><row><entry>20</entry><entry>ADDI3 exp,</entry><entry>Add immediate with three</entry><entry>LI</entry><entry>Integer</entry></row><row><entry></entry><entry>Rm, Rd</entry><entry>operands</entry></row><row><entry>21</entry><entry>ADDX Rm, Rn, Rd</entry><entry>Add with carry</entry><entry>LR</entry><entry>Integer</entry></row><row><entry>22</entry><entry>DIV Rm, Rn, Rd</entry><entry>Divide</entry><entry>LR</entry><entry>Integer</entry></row><row><entry>23</entry><entry>MAD Rk,</entry><entry>Multiply and add</entry><entry>LR</entry><entry>Integer</entry></row><row><entry></entry><entry>Rm, Rn, Rd</entry></row><row><entry>24</entry><entry>MULUX Rm,</entry><entry>Multiply unsigned with</entry><entry>LR</entry><entry>Integer</entry></row><row><entry></entry><entry>Rn, Rd</entry><entry>extended precision</entry></row><row><entry>25</entry><entry>REM Rm, Rn, Rd</entry><entry>Get remainder and quotient</entry><entry>LR</entry><entry>Integer</entry></row><row><entry>26</entry><entry>SUB3 Rm, Rn, Rd</entry><entry>Subtract with three</entry><entry>LR</entry><entry>Integer</entry></row><row><entry></entry><entry></entry><entry>operands</entry></row><row><entry>27</entry><entry>SUBI3 exp,</entry><entry>Subtract immediate with</entry><entry>LI</entry><entry>Integer</entry></row><row><entry></entry><entry>Rm, Rd</entry><entry>three operands</entry></row><row><entry>28</entry><entry>SUBX Rm, Rn, Rd</entry><entry>Subtract with borrow</entry><entry>LR</entry><entry>Integer</entry></row><row><entry>29</entry><entry>ROT3 Rm, Rn, Rd</entry><entry>Rotate with three operands</entry><entry>LR</entry><entry>Integer</entry></row><row><entry>30</entry><entry>ROTI3 exp,</entry><entry>Rotate immediate with</entry><entry>LI</entry><entry>Integer</entry></row><row><entry></entry><entry>Rm, Rd</entry><entry>three operands</entry></row><row><entry>31</entry><entry>SHVAI3 exp,</entry><entry>Shift arithmetic immediate</entry><entry>LI</entry><entry>Integer</entry></row><row><entry></entry><entry>Rm, Rd</entry><entry>with three operands</entry></row><row><entry>32</entry><entry>SHVC Rm, Rn, Rd</entry><entry>Shift concatenated reg-</entry><entry>LR</entry><entry>Integer</entry></row><row><entry></entry><entry></entry><entry>isters</entry></row><row><entry>33</entry><entry>SHVC4 Rm, Rn, Rd</entry><entry>Shift concatenated four</entry><entry>LR</entry><entry>Integer</entry></row><row><entry></entry><entry></entry><entry>registers</entry></row><row><entry>34</entry><entry>SHVL3 Rm, Rn, Rd</entry><entry>Shift logical with three</entry><entry>LR</entry><entry>Integer</entry></row><row><entry></entry><entry></entry><entry>operands</entry></row><row><entry>35</entry><entry>SHVLI3 exp,</entry><entry>Shift logical immediate</entry><entry>LI</entry><entry>Integer</entry></row><row><entry></entry><entry>Rm, Rd</entry><entry>with three operands</entry></row><row><entry>36</entry><entry>ANDI3 exp,</entry><entry>Logical AND immediate</entry><entry>LI</entry><entry>Integer</entry></row><row><entry></entry><entry>Rm, Rd</entry></row><row><entry>37</entry><entry>ORI3 exp, Rm, Rd</entry><entry>Logical OR immediate</entry><entry>LI</entry><entry>Integer</entry></row><row><entry>38</entry><entry>XORI3 exp,</entry><entry>Logical exclusive OR</entry><entry>LI</entry><entry>Integer</entry></row><row><entry></entry><entry>Rm, Rd</entry><entry>immediate</entry></row><row><entry>39</entry><entry>BSCH/b Rm,</entry><entry>Search for a bit</entry><entry>MISC</entry><entry>Integer</entry></row><row><entry></entry><entry>Rn, Rd</entry></row><row><entry>40</entry><entry>LDCTX Rd</entry><entry>Load a context</entry><entry>MISC</entry><entry>Memory</entry></row><row><entry>41</entry><entry>MFC CRm, Rd</entry><entry>Move from a control reg.</entry><entry>MISC</entry><entry>Integer</entry></row><row><entry>42</entry><entry>MTC Rm, CRd</entry><entry>Move to a control reg.</entry><entry>MISC</entry><entry>Integer</entry></row><row><entry>43</entry><entry>REIT</entry><entry>Return from EIT</entry><entry>MISC</entry><entry>PC</entry></row><row><entry>44</entry><entry>STCTX Rm</entry><entry>Store the current context</entry><entry>MISC</entry><entry>Memory</entry></row><row><entry>45</entry><entry>TRAP vector</entry><entry>Trap</entry><entry>MISC</entry><entry>PC</entry></row><row><entry>46</entry><entry>WAIT imask</entry><entry>Set an interrupt mask and</entry><entry>MISC</entry><entry>Integer</entry></row><row><entry></entry><entry></entry><entry>wait</entry></row><row><entry>47</entry><entry>SCMP Rs1, Rs2,</entry><entry>Compare strings</entry><entry>MISC</entry><entry>Memory</entry></row><row><entry></entry><entry>Rc, Fd</entry></row><row><entry>48</entry><entry>SMOV Rs, Rd,</entry><entry>Move a string</entry><entry>MISC</entry><entry>Memory</entry></row><row><entry></entry><entry>Rc, Rd</entry></row><row><entry>49</entry><entry>SSCH Rs, Rc</entry><entry>Search for an element in a</entry><entry>MISC</entry><entry>Memory</entry></row><row><entry></entry><entry>Rm, Ru, Fd</entry><entry>string</entry></row><row><entry>50</entry><entry>SSTR Rs, Rc,</entry><entry>Fill a string with an</entry><entry>MISC</entry><entry>Memory</entry></row><row><entry></entry><entry>Ru, Fd</entry><entry>element</entry></row><row><entry>51</entry><entry>BVMAP Rsb, Rso, Rdb,</entry><entry>Manipulate bit fields</entry><entry>MISC</entry><entry>Memory</entry></row><row><entry></entry><entry>Rdo, Rp, Rw, Rh, Rtw</entry></row><row><entry>52</entry><entry>BVPAT Rs, Rdb</entry><entry>Manipulate bit fields</entry><entry>MISC</entry><entry>Memory</entry></row><row><entry></entry><entry>Rdo, Rp, Rw, Rh, Rtw</entry></row><row><entry>53</entry><entry>BVSCH/b Rm, Rn, Rd</entry><entry>Search for a bit in a</entry><entry>MISC</entry><entry>Memory</entry></row><row><entry></entry><entry></entry><entry>bit field</entry></row><row><entry>54</entry><entry>FLD2/s src,</entry><entry>Load two data to floating-</entry><entry>LM</entry><entry>Memory</entry></row><row><entry></entry><entry>FRd</entry><entry>point registers</entry></row><row><entry>55</entry><entry>FLD3/s src,</entry><entry>Load three data to float-</entry><entry>LM</entry><entry>Memory</entry></row><row><entry></entry><entry>FRd</entry><entry>ing point registers</entry></row><row><entry>56</entry><entry>FLD4/s src,</entry><entry>Load four data to float-</entry><entry>LM</entry><entry>Memory</entry></row><row><entry></entry><entry>FRd</entry><entry>ing point registers</entry></row><row><entry>57</entry><entry>FST2/s FRm,</entry><entry>Store two data from float-</entry><entry>LM</entry><entry>Memory</entry></row><row><entry></entry><entry>dest</entry><entry>ing point registers</entry></row><row><entry>58</entry><entry>FST3/s FRm,</entry><entry>Store three data from</entry><entry>LM</entry><entry>Memory</entry></row><row><entry></entry><entry>dest</entry><entry>floating-point registers</entry></row><row><entry>59</entry><entry>FST4/s FRm,</entry><entry>Store four data from</entry><entry>LM</entry><entry>Memory</entry></row><row><entry></entry><entry>dest</entry><entry>floating-point registers</entry></row><row><entry>60</entry><entry>FCAcc/c/s FRm,</entry><entry>Compare real and logical</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>FRn, Fs, Fd</entry><entry>AND</entry></row><row><entry>61</entry><entry>FCcc/s FRm,</entry><entry>Compare real</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>FRn, Fd</entry></row><row><entry>62</entry><entry>FABS/f/s</entry><entry>Negate real</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>FRm, FRd</entry></row><row><entry>63</entry><entry>FADD/f/s FRm,</entry><entry>Add real</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>FRn, FRd</entry></row><row><entry>64</entry><entry>FCDTS/f FRm,</entry><entry>Convert double to single</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>FRd</entry></row><row><entry>65</entry><entry>FCFI/f/s Rm,</entry><entry>Convert a signed data from</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>FRd</entry><entry>integer to floating point</entry></row><row><entry>66</entry><entry>FCFIU/f/s Rm,</entry><entry>Convert an unsigned data</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>FRd</entry><entry>from integer to floating-</entry></row><row><entry></entry><entry></entry><entry>point</entry></row><row><entry>67</entry><entry>FCSTD/f FRm,</entry><entry>Convert single to double</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>FRd</entry></row><row><entry>68</entry><entry>FCTI/f/s FRm,</entry><entry>Convert a signed data from</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>Rd</entry><entry>floating-point to integer</entry></row><row><entry>69</entry><entry>FCTIU/f/s FRm,</entry><entry>Convert an unsigned data</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>Rd</entry><entry>from floating-point to</entry></row><row><entry></entry><entry></entry><entry>integer</entry></row><row><entry>70</entry><entry>FDIV/f/s FRm,</entry><entry>Divide real</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>FRn, FRd</entry></row><row><entry>71</entry><entry>FMAD/f/s FRk,</entry><entry>Multiply and add real</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>FRm, FRn, FRd</entry></row><row><entry>72</entry><entry>FMUL/f/s FRm,</entry><entry>Multiply real</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>FRn, FRd</entry></row><row><entry>73</entry><entry>FNEG/f/s FRm,</entry><entry>Negate real</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>FRd</entry></row><row><entry>74</entry><entry>FSUB/f/s FRm,</entry><entry>Subtract real</entry><entry>LR</entry><entry>FP</entry></row><row><entry></entry><entry>FRn, FRd</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Toyohiko", "last_name": "Yoshida", "name": ""}], "assignees": [{"first_name": "", "last_name": "RENESAS ELECTRONICS CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  15/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/32        20060101ALI20051220RMJP"}, {"label": "G06F   9/30        20060101A I20051008RMEP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712212"}, {"primary": false, "label": "712E09071"}, {"primary": false, "label": "712E09028"}, {"primary": false, "label": "712E09054"}, {"primary": false, "label": "712E0905"}], "ecla_classes": [{"label": "G06F   9/30T4T"}, {"label": "G06F   9/38E2"}, {"label": "G06F   9/38T"}, {"label": "G06F   9/30T"}, {"label": "G06F   9/38E6"}], "cpc_classes": [{"label": "G06F   9/3885"}, {"label": "G06F   9/30145"}, {"label": "G06F   9/30145"}, {"label": "G06F   9/3842"}, {"label": "G06F   9/3853"}, {"label": "G06F   9/3853"}, {"label": "G06F   9/3842"}, {"label": "G06F   9/30167"}, {"label": "G06F   9/3885"}, {"label": "G06F   9/30167"}], "f_term_classes": [], "legal_status": "Granted", "priority_date": "1995-07-12", "application_date": "2000-02-22", "family_members": [{"ucid": "JP-H0926878-A", "titles": [{"lang": "JA", "text": "\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "DATA PROCESSOR"}]}, {"ucid": "US-6397323-B1", "titles": [{"lang": "EN", "text": "Data processor having an instruction decoder"}]}, {"ucid": "US-6115806-A", "titles": [{"lang": "EN", "text": "Data processor having an instruction decoder and a plurality of executing units for performing a plurality of operations in parallel"}]}, {"ucid": "US-5761470-A", "titles": [{"lang": "EN", "text": "Data processor having an instruction decoder and a plurality of executing units for performing a plurality of operations in parallel"}]}, {"ucid": "US-20020042871-A1", "titles": [{"lang": "EN", "text": "DATA PROCESSOR HAVING AN INSTRUCTION DECODER"}]}, {"ucid": "JP-H11194939-A", "titles": [{"lang": "JA", "text": "\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "DATA PROCESSOR"}]}, {"ucid": "JP-3741551-B2", "titles": [{"lang": "JA", "text": "\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Data processing device"}]}, {"ucid": "JP-2931890-B2", "titles": [{"lang": "JA", "text": "\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Data processing device"}]}]}