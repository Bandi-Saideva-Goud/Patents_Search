{"patent_number": "US-6604191-B1", "publication_id": 73502697, "family_id": 23983079, "publication_date": "2003-08-05", "titles": [{"lang": "EN", "text": "Method and apparatus for accelerating instruction fetching for a processor"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50531718\"><p>An instruction fetching system (and/or architecture) which may be utilized by a high-frequency short-pipeline microprocessor, for efficient fetching of both in-line and target instructions. The system contains an instruction fetching unit (IFU), having a control logic and associated components for controlling a specially designed instruction cache (I-cache). The I-cache is a sum-address cache, i.e., it receives two address inputs, which compiled by a decoder to provide the address of the line of instructions desired fetch. The I-cache is designed with an array of cache lines that can contain 32 instructions, and three buffers that each have a capacity of 32 instructions. The three buffers include a Predicted (PRED) buffer that holds the instructions which are currently being executed, a NEXT buffer that holds the instructions which are to be executed after the instructions in the PRED buffer, and an ALT buffer that holds the alternate set of instructions when a branch is predicted taken/not taken and is utilized along with the PRED buffer to permit branch target retrieval within I-cache prior to a prediction.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00001\" num=\"1\"><claim-text>1. A system for delivering instructions to a processor comprising:</claim-text><claim-text>an instruction fetching unit (IFU); </claim-text><claim-text>a sum-addressed instruction cache (I-cache) coupled to said IFU, said I-cache having a cache array and a plurality of line buffers with capacity for holding, a line of multiple instructions, including a PRED buffer utilized to produce in-line instructions to an instruction buffer, a NEXT buffer utilized to allow a state machine to find idle cache bandwidth to pre-fetch a next cache line prior to a completion of the line of instructions in the PRED buffer, and an ALT buffer utilized for fetching targets of branch instructions; </claim-text><claim-text>means for fetching said instructions from said I-cache to provide both target and in-line path; and </claim-text><claim-text>means for late selecting between target and in-line path instructions. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00002\" num=\"2\"><claim-text>2. The system of <claim-ref idref=\"US-6604191-B1-CLM-00001\">claim 1</claim-ref>, wherein said capacity of said plurality of line buffers is a line of 32 instructions, said I-cache further comprises:</claim-text><claim-text>means for delivering a full line of said cache array to one of said buffers in two cycles; and </claim-text><claim-text>means for providing up to four instructions aligned to an instruction boundary to an instruction buffer. </claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00003\" num=\"3\"><claim-text>3. The system of <claim-ref idref=\"US-6604191-B1-CLM-00001\">claim 1</claim-ref>, wherein:</claim-text><claim-text>said IFU further contains means for sending an instruction fetch address (IFA) to said I-cache as two operands; and </claim-text><claim-text>said I-cache further comprises: </claim-text><claim-text>means for receiving said two operands; </claim-text><claim-text>means for summing said two operands together to produce said IFA; and </claim-text><claim-text>means for issuing a line of instructions corresponding to said IFA to one of said plurality of line buffers within said I-cache. </claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00004\" num=\"4\"><claim-text>4. The system of <claim-ref idref=\"US-6604191-B1-CLM-00001\">claim 1</claim-ref>, wherein said I-cache has a PRED formatter, and wherein further said I-cache comprises means for receiving instructions from said PRED buffer into said PRED formatter.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00005\" num=\"5\"><claim-text>5. The system of <claim-ref idref=\"US-6604191-B1-CLM-00004\">claim 4</claim-ref>, wherein said receiving means further includes means for selecting said up to four instructions from a 32 instruction line of said PRED buffer.</claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00006\" num=\"6\"><claim-text>6. The system of <claim-ref idref=\"US-6604191-B1-CLM-00005\">claim 5</claim-ref>, wherein said selecting means includes:</claim-text><claim-text>a 5-bit index located in a 64-bit PREDA register, said register holding the address of the line of instructions present in the PRED buffer, and said 5-bit index providing the specific location within said line at which an instruction to be loaded into said instruction buffer is located; and </claim-text><claim-text>means for updating a value of said 5-bit index to provide a continuous stream of instructions to said instruction buffers. </claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00007\" num=\"7\"><claim-text>7. The system of <claim-ref idref=\"US-6604191-B1-CLM-00001\">claim 1</claim-ref>, wherein said ALT buffer and said PRED buffer are utilized by said IFU to accelerate branch processing, said system further comprising:</claim-text><claim-text>means for scanning ahead a number of cycles to determine if a branch is present in said instruction buffer; </claim-text><claim-text>means, responsive to said scanning means, for automatically fetching a line of instructions containing said target when said branch is present; and </claim-text><claim-text>means for storing said target line, wherein said target line is stored in the PRED buffer if the branch is predicted taken and in the ALT buffer if said branch is predicted not taken or the target arrives before it is needed. </claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00008\" num=\"8\"><claim-text>8. The system of <claim-ref idref=\"US-6604191-B1-CLM-00007\">claim 7</claim-ref>, further comprising:</claim-text><claim-text>means for issuing a selected target instruction directly to said instruction buffers from said cache array; </claim-text><claim-text>means for controlling whether an instruction loaded into said instruction buffer is loaded from said selected target or said in-line instructions, wherein said instruction is load from said selected target instruction when a branch instruction is predicted taken. </claim-text></claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00009\" num=\"9\"><claim-text>9. The system of <claim-ref idref=\"US-6604191-B1-CLM-00007\">claim 7</claim-ref>, further comprising means for swapping a content of the PRED buffer with that of the ALT buffer when a branch direction is reversed.</claim-text></claim>"}, {"num": 10, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00010\" num=\"10\"><claim-text>10. The system of <claim-ref idref=\"US-6604191-B1-CLM-00001\">claim 1</claim-ref>, further comprising:</claim-text><claim-text>means for monitoring when a line of instructions in sad PRED buffer is near completion; </claim-text><claim-text>means responsive to said monitoring means for initiating a fetch of a next sequential line of instructions into said NEXT buffer; and </claim-text><claim-text>means for transferring said next sequential line of instructions into said PRED buffer when said line of instructions in said PRED buffer is completed. </claim-text></claim>"}, {"num": 11, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00011\" num=\"11\"><claim-text>11. The system of <claim-ref idref=\"US-6604191-B1-CLM-00001\">claim 1</claim-ref>, further comprising means for saving a next in-line address in a register to enable efficient, lower latency restarts after a pipeline break.</claim-text></claim>"}, {"num": 12, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00012\" num=\"12\"><claim-text>12. The system of <claim-ref idref=\"US-6604191-B1-CLM-00001\">claim 1</claim-ref>, further comprising means for saving a next in-line address in a register when an instruction is emulated, thus providing higher accuracy and lower latency restart after emulation.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00013\" num=\"13\"><claim-text>13. A data processing system for delivering instructions to a processor comprising:</claim-text><claim-text>an instruction fetching unit (IFU); </claim-text><claim-text>a sum-addressed instruction cache (I-cache) coupled to said IFU, said I-cache having a cache array and a plurality of line buffers with capacity for holding a line of multiple instructions, including a PRED buffer utilized to produce in-line instructions to an instruction buffer, a NEXT buffer utilized to allow a state machine to find idle cache bandwidth to pre-fetch a next cache line prior to a completion of the line of instructions in the PRED buffer, and an ALT buffer utilized for fetching targets of branch instructions; </claim-text><claim-text>means for fetching said instructions from said I-cache to provide both target and in-line path; </claim-text><claim-text>means for late selecting between target and in-line path instructions; </claim-text><claim-text>means for delivering a full line of said cache array to one of said buffers in two cycles; and </claim-text><claim-text>means for providing up to four instructions aligned to an instruction boundary to an instruction buffer. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00014\" num=\"14\"><claim-text>14. The data processing system of <claim-ref idref=\"US-6604191-B1-CLM-00013\">claim 13</claim-ref>, wherein:</claim-text><claim-text>said IFU further contains means for sending an instruction fetch address (IFA) to said I-cache as two operands; and </claim-text><claim-text>said I-cache further comprises: </claim-text><claim-text>means for receiving said two operands; </claim-text><claim-text>means for summing said two operands together to produce said IFA; and </claim-text><claim-text>means for issuing a line of instructions corresponding to said IFA to one of said plurality of line buffers within said I-cache. </claim-text></claim>"}, {"num": 15, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00015\" num=\"15\"><claim-text>15. The data processing system of <claim-ref idref=\"US-6604191-B1-CLM-00013\">claim 13</claim-ref>, wherein said I-cache has a PRED formatter, and wherein further said I-cache comprises means for receiving instructions from said PRED buffer into said PRED formatter.</claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00016\" num=\"16\"><claim-text>16. The data processing system of <claim-ref idref=\"US-6604191-B1-CLM-00015\">claim 15</claim-ref>, wherein said receiving means further includes means for selecting said up to four instructions from a 32 instruction line of said PRED buffer.</claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00017\" num=\"17\"><claim-text>17. The data processing system of <claim-ref idref=\"US-6604191-B1-CLM-00016\">claim 16</claim-ref>, wherein said selecting means includes:</claim-text><claim-text>a 5-bit index located in a 64-bit PREDA register, said register holding the address of the line of instructions present in the PRED buffer, and said 5-bit index providing the specific location within said line at which an instruction to be loaded into said instruction buffer is located; and </claim-text><claim-text>means for updating a value of said 5-bit index to provide a continuous stream of instructions to said instruction buffers. </claim-text></claim>"}, {"num": 18, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00018\" num=\"18\"><claim-text>18. The data processing system of <claim-ref idref=\"US-6604191-B1-CLM-00013\">claim 13</claim-ref>, wherein said ALT buffer and said PRED buffer are utilized by said IFU to accelerate branch processing, said system further comprising:</claim-text><claim-text>means for scanning ahead a number of cycles to determine if a branch is present in said instruction buffer; </claim-text><claim-text>means, responsive to said scanning means, for automatically fetching a line of instructions containing said target when said branch is present; and </claim-text><claim-text>means for storing said target line, wherein said target line is stored in the PRED buffer if the branch is predicted taken and in the ALT buffer if said branch is predicted not taken or the target arrives before it is needed. </claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00019\" num=\"19\"><claim-text>19. The data processing system of <claim-ref idref=\"US-6604191-B1-CLM-00018\">claim 18</claim-ref>, further comprising:</claim-text><claim-text>means for issuing a selected target instruction directly to said instruction buffers from said cache array; </claim-text><claim-text>means for controlling whether an instruction loaded into said instruction buffer is loaded from said selected target or said in-line instructions, wherein said instruction is load from said selected target instruction when a branch instruction is predicted taken. </claim-text></claim>"}, {"num": 20, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00020\" num=\"20\"><claim-text>20. The data processing system of <claim-ref idref=\"US-6604191-B1-CLM-00018\">claim 18</claim-ref>, further comprising means for swapping a content of the PRED buffer with that of the ALT buffer when a branch direction is reversed.</claim-text></claim>"}, {"num": 21, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00021\" num=\"21\"><claim-text>21. The data processing system of <claim-ref idref=\"US-6604191-B1-CLM-00013\">claim 13</claim-ref>, further comprising:</claim-text><claim-text>means for monitoring when a line of instructions in said PRED buffer is near completion; </claim-text><claim-text>means responsive to said monitoring means for initiating a fetch of a next sequential line of instructions into said NEXT buffer; and </claim-text><claim-text>means for transferring said next sequential line of instructions into said PRED buffer when said line of instructions in said PRED buffer is completed. </claim-text></claim>"}, {"num": 22, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00022\" num=\"22\"><claim-text>22. The data processing system of <claim-ref idref=\"US-6604191-B1-CLM-00013\">claim 13</claim-ref>, further comprising means for saving a next in-line address in a register to enable efficient, lower latency restarts after a pipeline break.</claim-text></claim>"}, {"num": 23, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00023\" num=\"23\"><claim-text>23. The data processing system of <claim-ref idref=\"US-6604191-B1-CLM-00013\">claim 13</claim-ref>, further comprising means for saving a next in-line address in a register when an instruction is emulated, thus providing higher accuracy and lower latency restart after emulation.</claim-text></claim>"}, {"num": 24, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00024\" num=\"24\"><claim-text>24. An instruction fetching mechanism of a processor comprising:</claim-text><claim-text>an instruction fetching unit (IFU); </claim-text><claim-text>an instruction cache (I-cache) coupled to said IFU, wherein said I-cache includes: </claim-text><claim-text>sum address buffers which provide said I-cache with a line address based on two address operands received from said IFU; </claim-text><claim-text>a 64 byte cache array, having a plurality of instruction lines with a capacity for 32 instructions per line; </claim-text><claim-text>an array formatter for providing a target instruction directly from said cache array to an instruction buffer during branch processing; </claim-text><claim-text>a PRED buffer, which holds a line of instructions presently being completed; </claim-text><claim-text>a PRED formatter for providing up to four in-line instructions to said instruction buffer; </claim-text><claim-text>an ALT buffer, which holds the target line of instructions, wherein said target line of instructions is fetched prior to a resolution of a corresponding branch instruction in the instruction buffer; and </claim-text><claim-text>a NEXT buffer, which holds the next line of instructions required until a present line of instructions in the PRED buffer is completed. </claim-text></claim>"}, {"num": 25, "parent": 24, "type": "dependent", "paragraph_markup": "<claim id=\"US-6604191-B1-CLM-00025\" num=\"25\"><claim-text>25. The instruction fetching mechanism of <claim-ref idref=\"US-6604191-B1-CLM-00024\">claim 24</claim-ref>, wherein said IFU includes:</claim-text><claim-text>control logic for determining which line of instructions is loaded into one of said line buffers; </claim-text><claim-text>address registers for tracking said line of instruction presently loaded into each respective line buffer, wherein said address registers include an index for identifying which instruction is currently being completed; and </claim-text><claim-text>a last correct instruction register for enabling a restart after a stoppage in the processing of instructions.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53966475\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Technical Field</p><p>The present invention relates in general to data processing systems and in particular to a mechanism for fetching instructions within a data processing system. Still more particularly, the present invention relates to a method and apparatus for accelerating instruction fetching for a microprocessor in which both in-line and target instructions are provided in an efficient manner.</p><p>2. Description of the Related Art</p><p>A conventional processor may include an instruction fetch unit (IFU) for requesting instructions to be loaded, an instruction cache for storing instructions, an instruction buffer for temporarily storing instructions fetched from the instruction cache for execution, a number of execution units for executing sequential instructions, a branch processing unit (BPU) for executing branch instructions, a dispatch unit for dispatching sequential instructions from the instruction buffer to particular execution units, and a completion buffer for temporarily storing instructions that have finished execution, but have not been completed.</p><p>Conventional methods of fetching instructions using the above processor components are known in the art. Typically, these methods often result in cycle delays due to incorrectly fetched in-line instructions or incorrect predictions during branch processing. For example, during branch processing, if the branch that was predicted as taken is resolved as mis-predicted, a mis-predict penalty of several cycles is incurred by the processor due to the cycle time required to restore the sequential execution stream following the branch instructions (i.e., the processor has to abandon any result that the speculative instruction produced and begin executing the path that should have been taken). Another example occurs during in-line fetching, when an instruction is emulated (e.g., when a different set of code is utilized to perform the same function as the instruction) and/or an instruction fetch is temporarily halted. The IFU has to generate a return stack which takes a relatively long time to store values and read values prior to and after emulation.</p><p>Conventional instruction caches are typically large static blocks of temporarily stored instructions. The cache typically has very little functional logic and is designed solely to issue instructions out of a cache line once a corresponding line address is provided. The cache plays no part in the actual selection of instructions, branch processing, fetching branch targets, etc.</p><p>The present invention recognizes that it would be desirable and beneficial to have a system or processor architecture for effectively handling the fetching of instructions for a high-frequency, short pipeline processor. A system which also supported branch/target fetching without leading to process stalls or loss of cycles when target direction is incorrectly predicted would be a welcomed improvement. It would be further be desirable to have such a system which also permitted for fast restart of a process after instruction emulation. These and other benefits are presented in the invention described herein.</p><h4>SUMMARY OF THE INVENTION</h4><p>An instruction fetching system (and/or architecture) is disclosed, which may be utilized by a high-frequency short-pipeline microprocessor, for efficient fetching of both in-line and target instructions. The system contains an instruction fetching unit (IFU), having a control logic and associated components for controlling a specially designed instruction cache (I-cache). The I-cache is a sum-address cache, i.e., it receives two address inputs, which compiled by a decoder to provide the address of the line of instructions desired fetch. The I-cache is designed with an array of cache lines that can contain 32 instructions, and three buffers that each have a capacity of 32 instructions. The three buffers include a Predicted (PRED) buffer that holds the instructions which are currently being executed, a NEXT buffer that holds the instructions which are to be executed after the instructions in the PRED buffer, and an ALT buffer that holds the alternate set of instructions when a branch is predicted taken/not taken and is utilized along with the PRED buffer to permit branch target retrieval within I-cache prior to a prediction.</p><p>When a branch is encountered, instruction lines of both paths (taken/not taken) are sent to the instruction buffers and no stall occurs on the pipeline if the prediction is correct.</p><p>Address registers hold the line addresses of the instructions in each of the PRED. NEXT and ALT buffers and a 5-bit address corresponding to the specific instruction within the line to be sent to the instruction buffers. Up to four instructions are selected at a time from the instruction line in the PRED, ALT or NEXT buffer and sent to the instruction buffers. These instructions are typically selected sequentially (in-line). Use of the IFU and the I-cache provides a continuous supply of instructions to the processor pipeline without interruptions. Also, the invention supports efficient restart after a bad instruction is encountered or an instruction is emulated</p><p>The above as well as additional objects, features, and advantages of the present invention will become apparent in the following detailed written description.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself however, as well as a preferred mode of use, further objects and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:</p><p>FIG. 1 is a block diagram of a data processing system utilized in one embodiment of the present invention;</p><p>FIG. 2 is a block diagram of a processor utilized in a preferred embodiment of the present invention;</p><p>FIG. 3 is a block diagram of the component parts of an instruction fetching system depicting the flow of instructions and instruction addresses through the hardware and logic components of the processor in accordance with a preferred implementation of the present invention; and</p><p>FIG. 4 is a block diagram of the 64-bit PREDA instruction address according to a preferred embodiment of the invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENT</h4><p>With reference now to the figures and in particular with reference to FIG. 1, there is illustrated a block diagram of the basic structure of a data processing system <b>100</b> utilized in an embodiment of the invention. Data processing system <b>100</b> has at least one processor <b>10</b> which is connected to several peripheral devices, including input/output devices <b>114</b> (such as a display monitor, keyboard, and graphical pointing device) for user interface, a permanent memory device <b>116</b> (such as a hard disk) for storing the data processing system's operating system and applications, and a temporary memory device <b>118</b> (such as random access memory or RAM) that is utilized by processor <b>10</b> in execution of current program instructions. Processor <b>10</b> communicates with the peripheral devices by various means, including a bus <b>120</b> or a direct channel <b>122</b> (more than one bus may be provided utilizing a bus bridge).</p><p>Those skilled in the art will further appreciate that there are other components that might be utilized in conjunction with those shown in the block diagram of FIG. 1; for example, a display adapter connected to processor <b>10</b> might be utilized to control a video display monitor, and a memory controller may be utilized as an interface between temporary memory device <b>118</b> and processor <b>10</b>. Data processing system <b>100</b> also includes firmware <b>124</b> whose primary purpose is to seek out and load an operating system from one of the peripherals (usually permanent memory device <b>116</b>) whenever data processing system <b>100</b> is powered. In the preferred embodiment, processor <b>10</b> of data processing system <b>100</b> is a high-frequency short-pipelined processor.</p><p>FIG. 2 is a high level block diagram of an embodiment of processor <b>10</b>, according to a preferred embodiment of the present invention. Processor <b>10</b> may be located within data processing system <b>100</b> as depicted in FIG. <b>1</b>. In the preferred embodiment, processor <b>10</b> is a single integrated circuit, high-frequency, short-pipelined processor. Accordingly, as discussed further below, processor <b>10</b> includes various execution units, registers, buffers, memories, and other functional units, which are all formed by integrated circuitry. As depicted in FIG. 2, processor <b>10</b> is coupled to system bus <b>120</b> via a bus interface unit BIU <b>12</b> within processor <b>10</b>. BIU <b>12</b> controls the transfer of information between processor <b>10</b> and other devices coupled to system bus <b>120</b> such as a main memory <b>116</b>. Processor <b>10</b>, system bus <b>120</b>, and the other devices coupled to system bus <b>120</b> together form a data processing system.</p><p>BIU <b>12</b> is connected to instruction cache <b>14</b> and data cache <b>16</b> within processor <b>10</b>. High speech caches, such as instruction cache <b>14</b> and data cache <b>16</b>, enable processor <b>10</b> to achieve relatively fast access time to a subset of instructions or data previously transferred from main memory to instruction cache <b>14</b> and data cache <b>16</b>, thus improving the speed of operation of the data processing system.</p><p>Instruction cache <b>14</b> is further coupled to instruction fetch unit <b>17</b>, which fetches instructions from instruction cache <b>14</b> during each cycle for execution by execution circuitry within processor <b>10</b>. Branch unit (BU) is connected in parallel with execution circuitry and provides a check function for validity of instructions in the pipeline.</p><p>In the depicted embodiment, the execution circuitry of processor <b>10</b> comprises multiple execution units, including fixed-point unit (FXU) <b>22</b>, load/store unit (LSU) <b>28</b>, and floating-point unit (FPU) <b>30</b>. As is well known by those skilled in the art, each of execution units FXU <b>22</b>, LSU <b>28</b>, and FPU <b>30</b> executes one or more instructions within a particular class of sequential instructions during each processor cycle. For example, FXU <b>22</b> performs fixed-point mathematical operations such as addition, subtraction, ANDing, ORing, and XORing utilizing source operands received from specified general purpose registers (GPRs) <b>32</b>. Following the execution of a fixed point instruction, FXU <b>22</b> outputs the data results of the instruction to one or more of GPRs <b>32</b>. Conversely, FPU <b>30</b> performs floating-point operations, such as floating-point multiplication and division, on source operands received from floating-point registers FPRs <b>36</b>. FPU <b>30</b> outputs data resulting from the execution of floating-point instructions to selected FPRs <b>36</b>. As its name implies, LSU <b>28</b> executes floating-point and fixed-point instructions which either load data from memory (i.e., either data cache <b>16</b> or main memory) into selected GPRs <b>32</b> or FPRs <b>36</b> or which store data from a selected GPRs <b>32</b> or FPRs <b>36</b> to memory.</p><p>Instructions are processed by each of FXU <b>22</b>, LSU <b>28</b> and FPU <b>30</b> at a sequence of pipeline stages. As is typical of high performance processors, each instruction is processed at a number of pipeline stages, for example, fetch, decode/dispatch, execute, and write.</p><p>The present invention provides a novel processor system (and/or architecture) for providing instructions to a processor pipeline. This system is designed to deliver a steady stream of instructions to the execution circuitry of the processor through the instruction buffers. The architecture supports conditional branch prediction, branch address prediction and branch mis-prediction recovery. The architecture's control scheme provides that signals entering dynamic macros do so at the beginning of the cycle. In the preferred embodiment, an IFU is designed with specialized control logic and a plurality of multiplexor-latches (MUX-latches), which interacts with a specially designed I-cache to provide the instruction fetching, address resolution, branch processing and instruction queuing functions, without a branch unit, instruction queue or other hardware components utilized in traditional instruction fetch architectures.</p><p>The preferred embodiment includes control hardware circuitry components within the IFU and a new I-cache design. These circuit components include a plurality of MUX-latches and programmable logic arrays (PLAs). The MUXes are attached to edge-triggered flip-flops which copies to the associated output every cycle. Use of PLAs enables all inputs to be made available coming out of a latch at the beginning of a cycle.</p><p>More specifically, in the preferred embodiment, the I-cache is a 64 kilobyte cache having cache lines that are 32 instructions wide. Each cache line has an identifying effective (or virtual) address. Additionally, the I-cache also contains at least three internal buffers capable of holding a cache line of 32 instructions. Other components within the I-cache include a PRED formatter and an Array formatter which control which instructions are sent to the instruction buffers.</p><p>Branch processing is automatically completed within the I-cache. The special design of the I-cache permits both the target and in-line paths to be available for late selection. A target is always fetched when a branch is detected. Additionally, as a sum-addressed I-cache, the I-cache is able to simultaneously resolve and fetch a relative branch address and reduce the latency of the instruction fetch by at least one cycle. Other features of this new architecture are described further herein with reference to the FIG. <b>3</b>.</p><p>FIG. 3 as presented combines these various components as blocks within a block diagram, which illustrates the process of instruction fetching and branch resolution, etc. The logic blocks (MUX-latches and PLAS) located at the bottom of FIG. 3, are a part of the IFU <b>17</b> control logic.</p><h4>IN-LINE INSTRUCTION FETCH</h4><p>Instruction fetch requests are transmitted to the I-cache from the IFU <b>17</b>. The basic function of IFU <b>17</b> is to fetch instructions from the I-cache <b>14</b> and provide the instruction paired with the address of the instruction to the execution circuitry. IFU <b>17</b> also provides an address valid bit (within the instruction fetch address register (IFA) register) which is set (1) when the instruction corresponds to the address and is cleared (0) when it does not.</p><p>Instruction cache <b>14</b> has two latch-controlled inputs, Addr-A <b>329</b> and Addr-B <b>331</b>. The I-cache's decoder implicitly sums the operands of Addr-A <b>329</b> and Addr-B <b>331</b> to determine the address of the line to read out of the cache array <b>307</b>. Thus, I-cache <b>14</b> is also referred to as a sum-address I-cache.</p><p>At the same time, adder <b>323</b> is utilized to resolve the read address in parallel with the I-cache access by summing the operands of Addr-A <b>329</b> and Addr-B <b>331</b>. This read address is stored in the FABF register <b>325</b>.</p><p>I-cache <b>14</b> also contains a NEXT buffer <b>309</b>, an ALT buffer <b>311</b>, and a PRED buffer <b>313</b>. PRED buffer is a line buffer that contains a line full of instructions along the currently predicted path and is used to service in-line instruction sequencing. ALT buffer is a line buffer that contains a line full of instructions along the currently not predicted path (i.e., the alternate path) and is used to service branch prediction reversal and cases where in-line instruction sequencing does not keep up with the branch target processing. NEXT buffer is a line buffer that contains a line full of instructions along the currently predicted path, but is one line past the contents of the PRED buffer. NEXT buffer is used to hold the results of in-line pre-fetches and to satisfy in-line instruction sequencing when the PRED buffer is exhausted.</p><p>Finally, I-cache <b>14</b> contains two 32 input multiplexors, array formatter <b>315</b> and PRED formatter <b>317</b>, which select a particular set of 4 instructions from a line of instructions.</p><p>Each of the three line buffers has a corresponding address tag register. Thus, NextA <b>310</b>, AltA <b>312</b>, and. PredA <b>314</b> each contain the line address for the instruction in the NEXT <b>309</b>, ALT <b>311</b>, and PRED <b>313</b> buffers, respectively. The address tag register also contains an instruction index field and an instruction valid bit. FIG. 4 illustrates the fields of the PredA register <b>314</b> from the most significant bit (msb) to the least (lsb).</p><p>PRED buffer <b>313</b> is used to produce in-line instruction sequences. The output of the PRED buffer is sent through PRED formatter <b>317</b> which selects up to four of the 32 instructions to be loaded into the instruction buffers (IB<b>0</b> to IB<b>3</b>) <b>319</b>, (hereinafter referred to as IB <b>319</b>). PRED formatter <b>317</b> routes one of the 32 instructions into IB<b>0</b> according to the 5 bit index (which represents a line position, <b>0</b>-<b>31</b>) located in instruction index field of PredA register <b>314</b>. The 5 bit field is provided as an input to the PRED formatter <b>317</b> and controls which instruction from the instruction line is sent to the instruction buffer <b>319</b>. Thus, IB<b>0</b> is loaded with the instruction at the position of the 5-bit index, IB<b>1</b> is loaded with the instruction one position after the index, etc. If the index is within 3 instructions of the end of the line, one or more of IB<b>1</b> through IB<b>3</b> will be empty. The instruction buffer is advanced in-line by incrementing the 5-bit index field with a 5-bit incrementer each cycle. When data from the PRED buffer <b>313</b> is latched into the IB <b>319</b>, the PredA output is latched into instruction fetch address register (IFAR) <b>321</b>.</p><p>The NEXT buffer <b>309</b> holds in-line pre-fetches until the instructions are needed to continue filling the in-line path. IFU <b>17</b> supports two different in-line pre-fetches, one during run mode and another during restart.</p><p>A run mode in-line pre-fetch is initiated when instructions are being fetched from the last quarter of the line in the PRED buffer <b>313</b> and the instruction cache array <b>307</b> is idle. IFU's control logic initiates the fetch by: (1) asserting an array activation signal, \u2018use line <b>1</b>\u2019 (USEL<b>1</b>), corresponding to the line of instructions in the array; (2) selecting the PredA input to Addr-A <b>329</b>, to load the line index of the PRED buffer <b>313</b>; and (3) selecting <b>128</b> (corresponding to the value required to skip to the address of the first instruction at the next line from the address of the currently executing line) as the input to Addr-B <b>331</b>.</p><p>Thus, a read of the I-cache <b>14</b> is started at the address of the line sequentially after the line being executed. During the first cycle of the read, the array loads a line into an internal latch while an external adder (L<b>1</b>I$A+) <b>323</b> generates the read address which is latched into FABF register <b>325</b>. In the second cycle of the read, the FABF instruction index (which will be zero, corresponding to the first instruction of the next line) is applied to the array formatter <b>315</b>. The controller zeros out the 5 bit field in PREDA and adds 128 to select the first instruction on the next sequential line. I-cache <b>14</b> inputs to the NEXT buffer <b>309</b>, next formatted buffer (N<b>0</b>-N<b>3</b>) <b>327</b>, and NextA <b>310</b> are selected so that at the end of the second cycle, NEXT buffer <b>309</b> is filled with the line of instructions and ready to be forwarded to the instruction buffers <b>319</b> and PRED buffers <b>313</b>.</p><p>When IFAR <b>321</b> is ready to-wrap around from the last instruction (instruction <b>31</b>) of the line in the PRED buffer <b>313</b> into instruction <b>0</b> of the line in the NEXT buffer <b>309</b>, IFU's control logic sets the selects on the Mux-latches of IB <b>319</b>, IFA <b>321</b>, PRED <b>313</b>, and PredA <b>314</b> to receive data from the Mux-latches of NEXT <b>309</b>, N<b>0</b>-N<b>3</b><b>327</b>, and NextA <b>310</b>. Since the instruction in N<b>0</b> will be decoded in the next cycle, the values of N<b>0</b>-N<b>3</b><b>327</b> will be transferred into IB<b>0</b>-IB<b>3</b><b>319</b> and NextA <b>310</b> into IFA <b>321</b>. In the second cycle, because instruction <b>1</b> comes from the PRED formatter <b>317</b>, the NEXT line is loaded into the PRED buffer <b>313</b> and NextA+1 is loaded into PredA <b>314</b>. This increment is only a 5-bit increment on the instruction index field.</p><p>Thus, according to the present invention, the PRED <b>313</b> and NEXT buffers <b>309</b> allow IFU <b>17</b> to stream an in-line sequence of instructions through the IB <b>319</b> without interruption.</p><h4>BRANCH INSTRUCTION FETCH</h4><p>Branch instruction prediction and target fetching feature of the invention is now presented. In the preferred embodiment, the instructions are pre-decoded from 32 bits to 39 bits before they are loaded into I-cache <b>14</b>. One of the seven additional bits is referred to as the IS_BRANCH bit. This bit allows a PLA-based controller to react to the presence of a branch in IB<b>2</b> of IB <b>319</b>. Branch processing begins with the instruction in IB<b>2</b>. If a branch is detected in IB<b>2</b>, the sequencer's control logic automatically initiates a target fetch by asserting USEL<b>1</b>, which enables a read from the I-cache array <b>307</b>, and the branch target selection (TgtSel) <b>333</b>. TgtSel <b>333</b> is a PLA that computes select signals for the multiplexors of Addr-A <b>329</b> and Addr-B <b>331</b>. The target address is selected on Addr-A <b>329</b> and Addr-B <b>331</b> based upon a decode of the branch instruction in IB<b>2</b>. If IB<b>2</b> holds a branch relative, IB<b>2</b>_PC is selected into Addr-A <b>329</b>. Whenever none of the selects are asserted (i.e., an absolute branch, branch to register, or microcode entry), 0 is loaded into Addr-A <b>329</b>. Addr-B <b>331</b> is then loaded with a sign extended immediate (IB<b>2</b>_Imm), a microcode entry point (IB<b>2</b>_UVec), or one of several register values. These register values correspond to the types of branch targets selected and include, for example, exception return (ER/SRR<b>0</b>), and link control (Lnk/Cnt).</p><p>If a cache miss occurs, the line buffer is marked as invalid and pre-fetch is initiated at the address stored in the FABF <b>325</b>, allowing fetch exceptions to be processed at the correct place in the instruction stream.</p><p>In the first cycle of the fetch, the target line is read from the array <b>307</b> into an internal latch, and the fetch address is summed into the FABF latch <b>325</b>. At the same time, assuming in-line operation is uninterupted, the branch instruction moves into IB<b>1</b>. During cycle two, the array formatter <b>315</b> prepares the target instruction group for direct bypassing into IB <b>319</b>. Array formatter <b>315</b> is a MUX which is provided with a 5 bit address. The five bit address corresponds to one of the 32 instructions in the target line. During the second cycle, array formatter <b>315</b> sends four instructions as input to the instruction buffer <b>319</b>. The MUX of IB <b>319</b> receives a control input which indicates wether to select the instructions received from the array formatter <b>315</b> (i.e., the target instructions) or the instructions from the PRED formatter <b>317</b> (i.e., the in-line instructions). Assuming instructions are streaming normally, the branch moves into location IB<b>0</b> after the second cycle of the target fetch.</p><p>At this point, IFU's control logic performs one of the following series of steps:</p><p>(1) predict the branch in IB<b>0</b> will be taken and</p><p>a. select output of the array formatter <b>315</b> into IB <b>319</b> so that the target instruction can be decoded in the next cycle,</p><p>b. IFA <b>321</b> latches FABF <b>325</b>,</p><p>c. PRED buffer <b>313</b> grabs the line read from the array <b>317</b>,</p><p>d. PredA <b>314</b> stores the value in FABF <b>325</b> with the instruction index incremented,</p><p>e. ALT buffer <b>311</b> latches the line in the PRED buffer <b>313</b>,</p><p>f. A<b>0</b>-A<b>2</b><b>335</b> stores IB<b>1</b>-IB<b>3</b><b>319</b>, and</p><p>g. AltA <b>312</b> stores PredA <b>314</b> with the instruction index incremented; or</p><p>(2) predict the branch in IB <b>319</b> will not be taken and</p><p>a. select the output of the PRED formatter <b>317</b> into IB <b>319</b> so that in-line execution continues,</p><p>b. IFA <b>321</b> latches PredA <b>314</b>,</p><p>c. increment the PredA instruction index,</p><p>d. ALT buffer <b>311</b> retrieves the line read from the array <b>307</b>,</p><p>e. A<b>0</b>-A<b>3</b><b>335</b> receives the output of the array formatter <b>315</b>, and</p><p>f. AltA <b>312</b> latches FABF <b>325</b>; or</p><p>(3) not detect a branch in IB<b>0</b>, because in-line streaming was interrupted. In this case:</p><p>a. ALT buffer <b>311</b> selects the line read from the cache array <b>307</b>,</p><p>b. A<b>0</b>-A<b>3</b><b>335</b> receives the output of array formatter <b>315</b>,</p><p>c. AltA <b>312</b> latches FABF <b>325</b>,</p><p>d. Later, when a branch is detected in IB<b>0</b> that is predicted to go to the target and no target is in the second cycle of the read pipeline, the actions in case (a) above will take place with ALT <b>311</b>, A<b>0</b>-A<b>3</b><b>335</b>, and AltA <b>312</b> replacing the cache array <b>307</b>, array formatter <b>315</b> and FABF <b>325</b> as the source of the target line.</p><p>While the PRED buffer <b>313</b> holds the instructions on the predicted path, the ALT buffer <b>311</b> holds the instructions along the alternate branch path. Thus, ALT buffer <b>311</b> is used to facilitate incorrectly scheduled or predicted branch processing. If another unit in the system detects that a conditional branch direction was likely mis-predicted then IFU <b>17</b> can resume streaming from ALT buffer <b>311</b>. ALT buffer <b>311</b>, like NEXT buffer <b>309</b> does not have a formatter. It has instead registers A<b>0</b>-A<b>3</b><b>335</b> to hold previously formatted instruction groups.</p><h4>FETCH ON RE-START</h4><p>As another feature of the invention, IFU <b>17</b> provides a restart mechanism. If the BU <b>18</b> detects that the IFU is providing an incorrect sequence of instructions it asserts a \u2018bad instruction\u2019 (IBAD) signal. IBAD signal causes IFU's control logic to kill instructions in the write-back stage, initiate a fetch/read from the I-cache array <b>307</b> by asserting USEL<b>1</b>, selecting fix address, RealPC, into Addr-A <b>329</b> and a value of 0 into Addr-B <b>331</b>. RealPC is an input from BU <b>18</b>, allowing BU <b>18</b> to control the start address of the new sequence. As restart proceeds, a second in-line fetch is initiated. IFU <b>17</b> initiates an in-line pre-fetch during a restart by selecting the previous cycle's line index from the FABF <b>325</b> into Addr-A <b>329</b> and a value of <b>128</b> into Addr-B <b>331</b>. Then, as the instructions corresponding to the restart address appear at the output of the array formatter <b>315</b>, the formatter output is latched into IB <b>319</b> and PRED <b>313</b>, FABF <b>325</b> is loaded into IFAR <b>321</b>, and FABF <b>325</b> with the instruction index field incremented is loaded into PredA <b>314</b>. If a second in-line fetch is started, the NEXT buffer <b>309</b> will latch the output of cache array <b>307</b>.</p><p>As another related feature, IFU <b>17</b> also facilitates microcode return address speculation through the microcode return address guess register (UretG) <b>337</b>. When the instruction in IB<b>0</b> is decoded to be branch to microcode, the IFU latches IFA+4 <b>339</b> into UretG <b>337</b>. Thus, in the next cycle, the return address will be available to a microcode-return instruction in IB<b>2</b>. This greatly improves the accuracy of the branch address speculation on the microcode return.</p><p>The I-cache design of the present invention provides the fetching mechanism of the processor with a number of advanced features, which include: (1) The address is presented to the cache in the form of two operands that when summed produce the required address; (2) The cache array delivers a full 32 instruction wide line to its output in two cycles; (3) Reads and writes are fully pipelined; (4) The cache array can load a full 32 instruction wide line in two cycles; (5) There are three full 32 instruction wide line buffers; and (6) The formatters deliver up to four instructions aligned to an instruction boundary to the instruction buffer.</p><p>While the invention has been particularly shown and described with reference to a preferred embodiment, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. For example, although the invention has been described with specific reference to a high-frequency processor, the invention is capable of being implemented in any processor.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Brian King", "last_name": "Flacks", "name": ""}, {"first_name": "David", "last_name": "Meltzer", "name": ""}, {"first_name": "Joel Abraham", "last_name": "Silberman", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTERNATIONAL BUSINESS MACHINES CORPORATION"}, {"first_name": "", "last_name": "INTERNATIONAL BUSINESS MACHINES CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMEP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712207"}, {"primary": false, "label": "712235"}, {"primary": false, "label": "712E09056"}, {"primary": false, "label": "712E09055"}, {"primary": false, "label": "711E1202"}], "ecla_classes": [{"label": "G06F   9/38B"}, {"label": "G06F   9/38B8"}, {"label": "G06F   9/38B2"}, {"label": "G06F  12/08B14"}], "cpc_classes": [{"label": "G06F   9/3814"}, {"label": "G06F   9/3804"}, {"label": "G06F   9/3802"}, {"label": "G06F  12/0875"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "2000-02-04", "application_date": "2000-02-04", "family_members": [{"ucid": "IL-140764-A", "titles": [{"lang": "EN", "text": "Method and apparatus for accelerating instruction fetching for a processor"}]}, {"ucid": "IL-140764-D0", "titles": []}, {"ucid": "US-6604191-B1", "titles": [{"lang": "EN", "text": "Method and apparatus for accelerating instruction fetching for a processor"}]}, {"ucid": "IL-140764-A0", "titles": [{"lang": "EN", "text": "METHOD AND APPARATUS FOR ACCELERATING INSTRUCTION FETCHING FOR A PROCESSOR"}]}]}