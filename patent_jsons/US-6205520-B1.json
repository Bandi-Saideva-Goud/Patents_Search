{"patent_number": "US-6205520-B1", "publication_id": 72604309, "family_id": 21983870, "publication_date": "2001-03-20", "titles": [{"lang": "EN", "text": "Method and apparatus for implementing non-temporal stores"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11153673\" source=\"national office\"><p>A processor is disclosed. The processor includes a decoder to decode instructions and a circuit, in response to a decoded instruction, detects an incoming write back or write through streaming store instruction that misses a cache and allocates a buffer in write combining mode. The circuit, in response to a second decoded instruction, detects either an uncacheable speculative write combining store instruction or a second write back streaming store or write through streaming store instruction that hits the buffer and merges the second decoded instruction with the buffer.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72527374\"><p>A processor is disclosed. The processor includes a decoder to decode instructions and a circuit, in response to a decoded instruction, detects an incoming write back or write through streaming store instruction that misses a cache and allocates a buffer in write combining mode. The circuit, in response to a second decoded instruction, detects either an uncacheable speculative write combining store instruction or a second write back streaming store or write through streaming store instruction that hits the buffer and merges the second decoded instruction with the buffer.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00001\" num=\"1\"><claim-text>1. A processor comprising:</claim-text><claim-text>a decoder to decode instructions and to identify a first instruction as being associated with a first write back or write through non-temporal store, a non-temporal store comprising data that is to be utilized by the processor no more than a limited amount of number of times within a predetermined period; and </claim-text><claim-text>a circuit, in response to the decoded first instruction, to, </claim-text><claim-text>detect the first write back or write through non-temporal store that misses a cache, and </claim-text><claim-text>allocate a buffer for the first write back or write through non-temporal store in write combining mode. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00002\" num=\"2\"><claim-text>2. The processor of claim <b>1</b> wherein the circuit, in response to a second decoded instruction identified as being associated with a second write back or write through non-temporal store, to,</claim-text><claim-text>detect the second write back or write through non-temporal store that hits the buffer, and </claim-text><claim-text>merge the second write back or write through non-temporal store with the buffer. </claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00003\" num=\"3\"><claim-text>3. The processor of claim <b>1</b> wherein the circuit, in response to a second decoded instruction identified as being associated with a uncacheable speculative write combining store, to,</claim-text><claim-text>detect the uncacheable speculative write combining store that hits the buffer, and </claim-text><claim-text>merge the uncacheable speculative write combining store with the buffer. </claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00004\" num=\"4\"><claim-text>4. The processor of claim <b>1</b> wherein when the buffer is full, the circuit to issue a bus request to write the contents of the buffer to external memory.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00005\" num=\"5\"><claim-text>5. The processor of claim <b>1</b> wherein the circuit, in response to a second decoded instruction, to,</claim-text><claim-text>evict the buffer, and </claim-text><claim-text>block the second decoded instruction until the buffer is deallocated. </claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00006\" num=\"6\"><claim-text>6. The processor of claim <b>5</b> wherein the second decoded instruction is a strongly ordered instruction.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00007\" num=\"7\"><claim-text>7. The processor of claim <b>1</b> wherein the circuit is a cache controller.</claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00008\" num=\"8\"><claim-text>8. The processor of claim <b>1</b> wherein the buffer is a fill buffer.</claim-text></claim>"}, {"num": 9, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00009\" num=\"9\"><claim-text>9. A method for implementing non-temporal stores in a processor, the method comprising:</claim-text><claim-text>detecting a first instruction associated with a first write-back or write-through store; </claim-text><claim-text>determining whether the first write-back or write-through store is temporal or non-temporal, a temporal store comprising data that is likely to be utilized repeatedly within a predetermined period, a non-temporal store comprising data that is likely to be utilized no more than a few times within the predetermined period; </claim-text><claim-text>determining whether the first write-back or write-through store hits or misses the cache closest to the processor; </claim-text><claim-text>if the first write-back or write-through is non-temporal and misses the cache, allocating a buffer in write combining mode; and </claim-text><claim-text>writing the first write-back or write-through store in the buffer. </claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00010\" num=\"10\"><claim-text>10. The method of claim <b>9</b>, further comprising:</claim-text><claim-text>detecting a second instruction associated with a second write-back or write-through store; </claim-text><claim-text>determining whether the second write-back or write-through store is temporal or non-temporal; and </claim-text><claim-text>if the second write-back or write-through store is non-temporal, misses the cache, and hits the buffer, merging the second write-back or write-through store into the write combining buffer. </claim-text></claim>"}, {"num": 11, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00011\" num=\"11\"><claim-text>11. The method of claim <b>9</b>, further comprising:</claim-text><claim-text>if the first write-back or write-through store is non-temporal and hits the cache, updating the cache. </claim-text></claim>"}, {"num": 12, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00012\" num=\"12\"><claim-text>12. The method of claim <b>9</b>, further comprising:</claim-text><claim-text>detecting a second instruction associated with a second write-back or write-through store; </claim-text><claim-text>determining whether the second write-back or write-through store is temporal or non-temporal; </claim-text><claim-text>if the second write-back or write-through store is temporal and hits the buffer, blocking the second write-back or write-through store; and </claim-text><claim-text>evicting the data associated with the first write-back or write-through store along with any other data merged into the write combining buffer in write combining mode. </claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00013\" num=\"13\"><claim-text>13. The method of claim <b>12</b>, further comprising:</claim-text><claim-text>allocating the buffer in non-write combining mode; and </claim-text><claim-text>writing the second write-back or write-through store to the buffer in non-write combining mode. </claim-text></claim>"}, {"num": 14, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00014\" num=\"14\"><claim-text>14. The method of claim <b>9</b>, further comprising:</claim-text><claim-text>flushing all data written to the write combining buffer from at least one lower level cache. </claim-text></claim>"}, {"num": 15, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00015\" num=\"15\"><claim-text>15. The method of claim <b>9</b>, wherein an incoming load hits the buffer, further comprising:</claim-text><claim-text>blocking the incoming load; </claim-text><claim-text>evicting the write-back or write-through store; and </claim-text><claim-text>writing the write-back or write-through store to main memory. </claim-text></claim>"}, {"num": 16, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00016\" num=\"16\"><claim-text>16. A method for implementing non-temporal stores in a processor, the method comprising:</claim-text><claim-text>detecting an instruction associated with a non-temporal write-back store; </claim-text><claim-text>determining that the non-temporal write-back store hits on a non-write combining fill buffer; </claim-text><claim-text>merging the non-temporal write-back store with the non-write combining fill buffer if one of the following conditions is met, </claim-text><claim-text>a) the non-write combining fill buffer is currently servicing a write-back store, </claim-text><claim-text>b) the non-write combining fill buffer is globally observed in the modified state, and </claim-text><claim-text>c) the non-write combining fill buffer is globally observed in the exclusive state and the buffer is ready to write the data contained within the buffer to the cache level closest to the processor. </claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00017\" num=\"17\"><claim-text>17. The method of claim <b>16</b>, wherein the none of the conditions are met, further comprising:</claim-text><claim-text>blocking the non-temporal write-back store. </claim-text></claim>"}, {"num": 18, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00018\" num=\"18\"><claim-text>18. A method for implementing non-temporal stores in a processor, the method comprising:</claim-text><claim-text>detecting an instruction associated with a non-temporal write-through store; </claim-text><claim-text>determining that the non-temporal write-through store hits on a non-write combining fill buffer; </claim-text><claim-text>merging the non-temporal write-through store with the non-write combining fill buffer if one of the following conditions is met, </claim-text><claim-text>a) the non-write combining fill buffer is currently servicing a write-back store, </claim-text><claim-text>b) the non-write combining fill buffer is globally observed in the modified state. </claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205520-B1-CLM-00019\" num=\"19\"><claim-text>19. The method of claim <b>18</b>, wherein the none of the conditions are met, further comprising:</claim-text><claim-text>blocking the non-temporal write-through store.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54513360\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates generally to the field of processors, and specifically, to a method and apparatus for implementing non-temporal stores.</p><p>2. Background Information</p><p>The use of a cache memory with a processor is well known in the computer art. A primary purpose of utilizing cache memory is to bring the data closer to the processor in order for the processor to operate on that data. It is generally understood that memory devices closer to the processor operate faster than memory devices farther away on the data path from the processor. However, there is a cost trade-off in utilizing faster memory devices. The faster the data access, the higher the cost to store a bit of data. Accordingly, a cache memory tends to be much smaller in storage capacity than main memory, but is faster in accessing the data.</p><p>A computer system may utilize one or more levels of cache memory. Allocation and de-allocation schemes implemented for the cache for various known computer systems are generally similar in practice. That is, data that is required by the processor is cached in the cache memory (or memories). If a cache miss occurs, then an allocation is made at the entry indexed by the access. The access can be for loading data to the processor or storing data from the processor to memory. The cached information is retained by the cache memory until it is no longer needed, made invalid or replaced by other data, in which instances the cache entry is de-allocated.</p><p>Recently, there has been an increase in demand on processors to provide high performance for graphics applications, especially three-dimensional graphics applications. The impetus behind the increase in demand is mainly due to the fact that graphics applications tend to cause the processor to move large amounts of data (e.g., display data) from cache and/or system memory to a display device. This data, for the most part, is used once or at most only a few times (referred to as \u201cnon-reusable data\u201d).</p><p>For example, assume a cache set with two ways, one with data A and another with data B. Assume further that data A, data B, and data C target the same cache set, and also assume that a program reads and writes data A and data B multiple times. In the middle of the reads and writes of data A and data B. if the program performs an access of non-reusable data C, the cache will have to evict, for example, data A from line one and replace it with data C. If the program then tries to access data A again, a cache \u201cmiss\u201d occurs, in which case data A is retrieved from external memory and data B is evicted from line two and replaced with data A. If the program then tries to access data B again, another cache \u201cmiss\u201d occurs, in which case data B is retrieved from external memory and data C is evicted from line one and replaced with data B. Since data C is non-reusable by the program, this procedure wastes a considerable amount of clock cycles, decreases efficiency, and pollutes the cache.</p><p>Therefore, there is a need in the technology for a method and apparatus to efficiently write non-reusable data to external memory without polluting cache memory.</p><p>A further bottle neck in data intensive applications such as three-dimensional applications, in addition to the processor, is the memory and bus bandwidth. That is, data intensive applications require a considerable amount of bus transactions to and from system memory.</p><p>Therefore, there is an additional need in the technology for a method and apparatus to efficiently write non-reusable data to external memory without polluting cache memory while minimizing bus transactions.</p><h4>SUMMARY OF THE INVENTION</h4><p>In one embodiment, the present invention is a processor that includes a decoder to decode instructions and a circuit. The circuit, in response to a decoded instruction, detects an incoming write back or write through streaming store instruction that misses a cache and allocates a buffer in write combining mode.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>The features and advantages of the present invention will become apparent from the following detailed description of the present invention in which:</p><p>FIG. 1 illustrates an exemplary embodiment of a computer system in accordance with the teachings of the present invention.</p><p>FIG. 2 illustrates exemplary structures of the CPU where a multiple cache arrangement is implemented.</p><p>FIG. 3 illustrates exemplary logical units of the memory ordering unit and the L1 cache controller and the interconnection therebetween according to one embodiment of the present invention.</p><p>FIG. 4 illustrates various control fields of an exemplary fill buffer suitable for use with the present invention.</p><p>FIG. 5 is a flow diagram illustrating an exemplary process of implementing the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION</h4><p>The present invention is a method and apparatus for implementing non-temporal stores. In the following description, for purposes of explanation, numerous details are set forth in order to provide a thorough understanding of the present invention. However, it will be apparent to one skilled in the art that these specific details are not required in order to practice the present invention.</p><p>As hereinafter described, non-temporal data refers to data that is intended to be used once or at most a limited number of times by the processor whereas temporal data is data that is intended to be used more than non-temporal data (e.g., used repeatedly). Moreover, weakly-ordered instructions are instructions that can be executed out of program order, i.e., a M-th sequential instruction in a program may be executed before a (M\u2212N)-th sequential instruction (where M and N are positive whole numbers and M&gt;N). On the other hand, strongly ordered instructions are instructions that are executed in program order. A line of data refers to thirty-two bytes of data, as presently utilized in microprocessor-based systems, although it is within the scope of the present invention if a line of data refers to more or less bytes of data.</p><p>A cache \u201chit\u201d occurs when the address of an incoming instruction matches one of the valid entries in the cache. For example, in the MESI protocol, a line in the cache has a valid entry when it is in modified \u201cM\u201d, exclusive \u201cE\u201d, or shared \u201cS\u201d state. A cache \u201cmiss\u201d occurs when the address of an incoming instruction does not match any valid entries in the cache. For sake of clarity, the cache is described with respect to the MESI protocol, however, any other protocol or cache consistency model may be used. A fill buffer in normal mode is referred to as a non-write combining fill buffer (\u201cNWCFB\u201d) and a fill buffer in write combining mode is referred to as a write combining fill buffer (\u201cWCFB\u201d). Write combining is the process of combining writes to the same line of data in the buffer, thereby diminishing the number of external bus transactions required.</p><p>FIG. 1 illustrates an exemplary embodiment of a computer system <b>100</b> in accordance with the teachings of the present invention. Referring to FIG. 1, computer system <b>100</b> comprises one or more central processing units (\u201cCPUs\u201d) <b>110</b><sub>1</sub>-<b>110</b><sub>P </sub>(where P is a positive whole number), coupled to a bridge <b>120</b> by way of a host bus <b>115</b>. Each CPU <b>110</b> is also coupled to a Level 2 (\u201cL2 \u201d) cache <b>130</b> by way of a backside bus <b>125</b>. Each CPU <b>110</b> may be of any type, such as a complex instruction set computer (\u201cCISC\u201d), reduced instruction set computer (\u201cRISC\u201d), very long instruction word (\u201cVLIW\u201d), or hybrid architecture. In addition, each CPU <b>110</b> could be implemented on one or more chips. Through an AGP port, the bridge <b>120</b> may be coupled to a graphics module <b>150</b> by way of a graphics bus <b>145</b>. The bridge is also coupled to external memory <b>140</b> (e.g., static random access memory \u201cSRAM\u201d, dynamic RAM \u201cDRAM\u201d, etc.) by way of an external bus <b>135</b> and an expansion bus <b>155</b>. In one embodiment, the expansion bus <b>155</b> is, for example, a peripheral component interconnect (\u201cPCI\u201d) bus, an Extended Industry Standard Architecture (\u201cEISA\u201d) bus, or a combination of such busses.</p><p>A number of peripheral devices including an image capture card <b>160</b>, fax/modem card <b>165</b>, input/output (\u201cI/O\u201d) card <b>170</b>, audio card <b>175</b>, network card <b>180</b>, and the like, may be optionally coupled to the expansion bus <b>155</b>. The image capture card <b>160</b> represents one or more devices for digitizing images (i.e., a scanner, camera, etc.). The fax/modem card <b>165</b> represents a fax and/or modem for receiving and/or transmitting analog signals representing data. The audio card <b>175</b> represents one or more devices for inputting and/or outputting sound (e.g., microphones, speakers, etc.). The network card <b>180</b> represents one or more network connections (e.g., an Ethernet connection). However, it must be noted that the architecture of computer system <b>100</b> is exemplary and is apparent to one skilled in the art that such architecture is not critical in practicing the present invention.</p><p>FIG. 2 illustrates exemplary structures of the CPU <b>110</b> implementing a multiple cache arrangement. Referring to FIG. 2, the CPU <b>110</b> includes, among other things, a decoder unit <b>205</b>, a processor core <b>208</b>, execution units <b>220</b>, a memory cluster <b>225</b> having a memory ordering unit (\u201cMOU\u201d) <b>230</b> and a Level 1 (\u201cL1\u201d) cache controller <b>235</b>, and a bus controller <b>245</b> having a L2 cache controller <b>255</b> and an external bus controller <b>260</b>. In one embodiment, the CPU <b>110</b> is an out-of-order processor, in which case the processor core <b>208</b> includes a reservation station <b>210</b> and a logical block having a reorder buffer and a register file <b>215</b>. It is to be noted that there are other well known or new out-of-order execution architectures. However, in another embodiment, the CPU <b>110</b> is an in-order processor, in which case the reservation station <b>210</b> and/or the reorder buffer may not be needed. In either case, the present invention operates with any type of processor (e.g., out-of-order, in-order, etc.). For clarity sake, all references made to the reorder buffer and/or the register file will be designated by numeral <b>215</b>, even though they are separate logical units within the logical block <b>215</b>. The register file <b>215</b> includes a plurality of general purpose registers. It is to be appreciated that the CPU <b>110</b> actually includes many more components than just the components shown. Thus, only those structures useful to the understanding of the present invention are shown in FIG. <b>2</b>.</p><p>The decoder unit <b>205</b> decodes instructions and forwards them to the reservation station <b>210</b> and the reorder buffer <b>215</b> of the processor core <b>208</b>. The processor core <b>208</b> is coupled to the execution units <b>220</b> and the memory cluster <b>225</b> for dispatching instructions to the same. The memory cluster <b>225</b> writes back information to the processor core <b>208</b> by way of a writeback bus <b>240</b>. The L1 cache controller <b>235</b> is coupled to the L2 cache controller <b>255</b> and the external bus controller by way of a bus <b>250</b>. The L2 cache controller <b>255</b> controls the L2 cache <b>130</b>, and the external bus controller <b>260</b> interfaces with external memory <b>140</b> through the bridge <b>120</b>.</p><p>FIG. 3 illustrates exemplary logical units of the memory ordering unit <b>230</b> and the L1 cache controller <b>235</b> and the interconnection therebetween according to one embodiment of the present invention. Referring to FIG. 3, the MOU <b>230</b> includes a load buffer <b>305</b> which buffers a plurality (e.g., 16 entries) of load (or read) instructions (or requests) and a store buffer <b>310</b> which buffers a plurality (e.g., 12 entries) of store (or write) instructions. Alternatively, the MOU <b>230</b> may use a single unified buffer which buffers both load and store instructions. The addresses of the load and store instructions are transmitted to, among other things, a hit/miss detection logic <b>315</b> of the L1 cache controller <b>235</b>. The hit/miss detection logic <b>315</b> is coupled to a L1 cache <b>320</b>, a plurality of L1 cache controller buffers <b>325</b> (each hereinafter referred to as a \u201cfill buffer\u201d), a write back buffer (\u201cWBB\u201d) <b>340</b>, and a snoop buffer (\u201cSB\u201d) <b>345</b>. The hit/miss detection logic <b>315</b> determines whether the incoming instruction (e.g., load, store, etc.) \u201chits\u201d either the L1 cache <b>320</b>, fill buffers <b>325</b>, WBB <b>340</b>, or SB <b>345</b> (performs an address comparison).</p><p>The L1 cache <b>320</b> and the fill buffers <b>325</b> (e.g., four) are coupled to a selector <b>330</b> (e.g., a multiplexer) for returning load request data back to the reservation station <b>210</b> and/or the reorder buffer and register file <b>215</b> of the processor core <b>208</b>. The fill buffers <b>325</b> are also coupled to the L1 cache <b>320</b> by way of path A (bus <b>335</b> ) to write data to the L1 cache <b>320</b>. The L1 cache <b>320</b> is also coupled to the WBB <b>340</b> and the SB <b>345</b>. In addition, the fill buffers <b>325</b>, WBB <b>340</b>, and SB <b>345</b> are coupled to a second selector <b>355</b> for writing data to the bus controller <b>245</b>. The bus controller <b>345</b> is coupled to the fill buffers <b>325</b> for loading data into the same. That is, in this embodiment, load requests to the bus controller <b>245</b> are always brought into the fill buffers <b>325</b>.</p><p>Continuing to refer to FIG. 3, the WBB <b>340</b> is used to write a line of data in the M state from the L1 cache <b>320</b>, which has been evicted, to external memory <b>140</b>. The SB <b>345</b> is used when the CPU <b>110</b> receives an external snoop from another CPU in the system (e.g., CPUs <b>110</b><sub>2</sub>-<b>110</b><sub>P</sub>), and the result of the snoop is that it \u201chits\u201d a line in M state in the L1 cache <b>320</b> (i.e., L1 cache of CPU <b>110</b> ). The external snoop is the result of another CPU in the system trying to access the same line that is in the M state in the L1 cache of CPU <b>110</b>. After the snoop \u201chit\u201d, the CPU <b>110</b> places the M line in the SB <b>345</b>, and from there, sends it to external memory. The other CPU in the system, from where the snoop originated, can now access the line from external memory <b>140</b>.</p><p>Loads and stores, which are dispatched to the L1 cache controller <b>235</b>, have an associated memory type. In one embodiment, each CPU <b>110</b> supports five memory types including write back (\u201cWB\u201d), write through (\u201cWT\u201d), uncacheable speculative write combining (\u201cUSWC\u201d), uncacheable (\u201cUC\u201d), and write protected (\u201cWP\u201d). An example of a UC memory type is an access to memory mapped I/O. WB memory type is cacheable whereas USWC and UC memory types are uncacheable. WP writes are uncacheable, but WP reads are cacheable. WT reads are also cacheable. WT writes that \u201chit\u201d the L1 cache <b>320</b> update both the L1 cache and external memory, whereas WT writes that \u201cmiss\u201d the L1 cache <b>320</b> only update external memory. USWC writes are weakly ordered, which means that subsequent instructions may execute out of order with respect to a USWC write or the USWC write may execute out of order with respect to previous instructions. On the other hand, UC stores are strongly ordered, and they execute in program order with respect to other stores.</p><p>FIG. 4 illustrates various control fields of an exemplary fill buffer <b>325</b> suitable for use with the present invention. Referring to FIG. 4, each fill buffer <b>325</b> includes, among other fields, the following control fields: (i) \u201cIn Use\u201d control field <b>405</b> which is set when the fill buffer is allocated (e.g., on a L1 read \u201cmiss\u201d) and cleared when it is deallocated; (ii) \u201cRepEn\u201d field <b>410</b> which specifies whether a line of data that is returned from the bus controller <b>245</b> is to be written into the L1 cache <b>320</b>; (iii) Address field <b>415</b> which includes the address of the request; (iv) Data field <b>420</b> which includes the data that is returned to the fill buffer on a load request and contains valid data to be written on a store request; (v) Byte written (\u201cBW\u201d) field <b>425</b> which includes one bit for each byte in the Data field and, for all writes, including those in write combining mode, indicates the bytes within the line which are written by a store from the processor core <b>208</b> (e.g., a register); (vi) Write Combining Mode (\u201cWCM\u201d) field <b>430</b> which specifies whether the fill buffer is in write combining mode; (vii) Write Combining Buffer (\u201cWCB\u201d) field <b>435</b> which specifies that the buffer is a write combining buffer; and (viii) Write Combining Evicted (\u201cWCE\u201d) field <b>440</b> which specifies whether the write combining buffer is evicted. In this embodiment, the WCM bit is always cleared on eviction or when the fill buffer is fully written (i.e., all BW bits are set) from start of eviction until the buffer is allocated again to service another write combining instruction.</p><p>Upon allocating a fill buffer, if the WCB bit is cleared, the fill buffer is a NWCFB and if the WCB bit is set the fill buffer is a WCFB. In write combining mode, cacheable non-temporal stores behave as weakly-ordered write-combining stores in that they can be executed out of order with respect to cacheable instructions and non-strongly ordered uncacheable instructions. Moreover, if a fill buffer is allocated in write-combining mode for a USWC or non-temporal store instruction (WCFB), the buffer remains allocated and will write combine with other write combinable stores of the same type until either all bytes in the fill buffer are written (i.e., all BW bits are set) or there is an eviction condition, in which case the fill buffer initiates a request to the bus controller <b>245</b> to write the line of data to external memory <b>140</b>. Strongly ordered uncacheable store and fencing instructions are examples of instructions that are strongly ordered and cause eviction of a WCFB. The fencing instruction is described in U.S. Pat. No. 6,073,210 entitled \u201cSynchronization of Weakly Ordered Write Combining Operations Using a Fencing Mechanism\u201d by Salvador Palanca et al., issued May 6, 2000 and assigned to the assignee of the present invention.</p><p>If a NWCFB is allocated, it could be to service either loads or stores. Therefore, the request could be to receive data from or send data to the bus controller <b>245</b>. On cacheable loads (e.g., WB, WT, or WP) or cacheable temporal stores (e.g., temporal WB stores), the line of data is placed in a fill buffer from either the L2 cache <b>130</b> or external memory <b>140</b>. Thereafter, the data is written to the L1 cache <b>320</b>. On uncacheable reads (e.g., USWC or UC), only the requested data, not the whole line is brought into the fill buffer from external memory. Thereafter, the data is forwarded to the processor core <b>208</b> (e.g., register file). In this case, data is not placed in the L1 cache <b>320</b>. On a NWCFB servicing WT, WP, or UC stores, only the requested data, not the whole line, is transferred from the fill buffer to external memory. In either case, once the instruction is completed, the NWCFB is deallocated. On the other hand, if a WCFB is allocated, the fill buffer will remain in write combine mode and not issue a bus request until either the fill buffer is full (i.e., all BW bits are set) or there is an eviction condition. If subsequent writes, which are write-combinable, \u201chit\u201d the fill buffer, the writes combine. That is, data (e.g., one, two, four, eight bytes) is transferred from the processor core <b>208</b> to the corresponding bytes in the fill buffer <b>350</b> and the corresponding BW bits are set. If the fill buffer is full, a single transaction is performed to write the entire line of data to memory. If the fill buffer is not full upon detection of an eviction condition, the required write transactions are performed to update external memory depending on the BW bits which are set.</p><p>Referring back to FIGS. 2 and 3, two separate cache memories <b>320</b> and <b>130</b> are shown. The caches memories <b>320</b> and <b>130</b> are arranged serially and each is representative of a cache level, referred to as L1 cache and L2 cache, respectively. Furthermore, the L1 cache <b>320</b> is shown as part of the CPU <b>110</b>, while the L2 cache <b>130</b> is shown external to the CPU <b>110</b>. This structure exemplifies the current practice of placing the L1 cache on the processor chip while higher level caches are placed external to it. The actual placement of the various cache memories is a design choice or dictated by the processor architecture. Thus, it is appreciated that the L1 cache <b>320</b> could be placed external to the CPU <b>110</b>. The caches can be used to cache data, instructions or both. In some systems, the L1 (and/or L2 ) cache is actually split into two sections, one section for caching data and one section for caching instructions. However, for simplicity of explanation, the various caches described in the Figures are shown as single caches with data.</p><p>As noted, only two caches <b>320</b> and <b>130</b> are shown. However, the computer system need not be limited to only two levels of cache. For example, a third level (\u201cL3\u201d) cache may be used. In one embodiment, cache memories are serially arranged so that data cached in the L1 cache is also cached in the L2 cache. If there happens to be a L3 cache, then data cached in the L2 cache is typically cached in the L3 cache as well. Thus, data cached at a particular cache level is also cached at all higher levels of the cache hierarchy.</p><p>As shown in FIG. 1, the computer system <b>100</b> may include more than one CPU (i.e., P&gt;1), typically coupled to the system by way of bus <b>115</b>. In such a system, it is typical for multiple CPUs to share the external memory <b>140</b>. The present invention can be practiced in a single CPU computer system or in a multiple CPU computer system. It is further noted that other types of units (other than processors) which access external memory can function equivalently to the CPUs described herein and, therefore, are capable of performing the memory accessing functions similar to the described CPUs. For example, direct memory accessing (\u201cDMA\u201d) devices can readily access memory similar to the processors described herein. Thus, a computer system having one CPU, but one or more of the memory accessing units would function equivalent to the multiple processor system described herein.</p><p>Generally, the decoder unit <b>205</b> fetches instructions from a storage location (such as external memory <b>140</b> ) holding the instructions of a program that will be executed and decodes these instructions. The decoder unit <b>205</b> forwards the instructions to the processor core <b>208</b>. In the embodiment shown, the instructions are forwarded to the reservation station <b>210</b> and the reorder buffer <b>215</b>. The reorder buffer <b>215</b> keeps a copy of the instructions in program order (in the case of an out-of-order processor). Each entry in the reorder buffer, which corresponds to a micro-instruction, includes a control field with one bit being a write-back data valid bit. The write-back data valid bit indicates whether an instruction can been retired. The reorder buffer <b>215</b> retires the instruction when the instruction has its write-back data valid bit set and when all previous instructions in the reorder buffer have been retired (i.e., in-order retirement). The reservation station <b>210</b> receives the instructions and determines their type (e.g., arithmetic logic unit \u201cALU\u201d instruction, memory instruction, etc.). In one embodiment, the reservation station <b>210</b> dispatches instructions in an out of order manner.</p><p>For example, for an ALU instruction, the reservation station <b>210</b> dispatches the instruction to the execution units <b>220</b>. The execution units <b>220</b> execute the instruction and return the result back to the reorder buffer and the register file <b>215</b> so that the result can be written to a register in the register file and the instruction can be retired. Memory instructions are dispatched to the MOU <b>230</b>. Load instructions are placed in the load buffer <b>305</b> while store instructions are placed in the store buffer <b>310</b>. The MOU <b>230</b> will throttle the processor core <b>208</b> and not accept an instruction if the buffer that the instruction is destined for (e.g., load or store buffer) is full, if there is an abort condition, or on other conditions.</p><p>The MOU <b>230</b> dispatches instructions (load, store, etc.) to the L1 cache controller <b>235</b>. Generally, in certain situations the MOU <b>230</b> may dispatch instructions out of order. For example, if instruction two is dependent on instruction one and instruction three is independent of both instructions one and two, instruction two has to wait until the result of instruction one is available but instruction three can go ahead since it has no dependencies. Therefore, the MOU <b>230</b> may dispatch instruction one, then instruction three, and then instruction two (<b>1</b>, <b>3</b>, <b>2</b>).</p><p>Each instruction is forwarded to the L1 cache controller <b>235</b>. The hit/miss detection logic <b>315</b> determines, among other things, whether the incoming instruction \u201chits\u201d the L1 cache <b>320</b>, fill buffers <b>325</b>, WBB <b>340</b>, or SB <b>345</b>. The L1 cache controller <b>235</b> determines, among other things, whether the instruction is cacheable and whether the instruction is a load or store instruction.</p><p>Furthermore, in one embodiment, at least one CPU <b>110</b> supports temporal and non-temporal store instructions. Cacheable temporal store instructions follow temporal store semantics, i.e., they update the L1 cache <b>320</b>. Similarly, cacheable non-temporal stores (also hereinafter referred to as \u201cstreaming stores\u201d) that \u201chit\u201d a line in the L1 cache follow temporal semantics, although a biased LRU algorithm is used to minim ize pollution in the L1 cache, as described in copending U.S. patent application No. 09/053,386 entitled \u201cShared Cache Structure for Temporal and Non-Temporal Instructions\u201d by Salvador Palanca et al. and assigned to the assignee of the present invention. However, cacheable (WB and WT) non-temporal stores that \u201cmiss\u201d the L1 cache follow non-temporal semantics (i.e., they are weakly ordered write combining and only update external memory), as will be described in the following paragraphs with respect to the present invention.</p><p>If a WB temporal store instruction \u201chits\u201d a M or an E line in the L1 cache <b>320</b>, the L1 cache is updated with the data and the line is updated to M state (if in the E state). However, if the instruction \u201chits\u201d a S line in the L1 cache, the line is invalidated, a fill buffer <b>325</b> is allocated, and the data from the instruction (e.g., register) is placed in the fill buffer. The fill buffer <b>325</b> then issues a bus request to the bus controller <b>245</b> to retrieve the rest of the line of data. When the store request is granted, the bus controller <b>245</b> first checks the L2 cache <b>130</b> to determine whether the data is in the same. If the data is in the L2 cache <b>130</b>, a L2 cache \u201chit\u201d occurs and the bus controller <b>245</b> retrieves the line of data from the L2 cache <b>130</b>. If the data is not in the L2 cache <b>130</b>, a L2 cache \u201cmiss\u201d occurs and the bus controller <b>245</b> retrieves the line of data from external memory <b>140</b>. In either case, the line of data is sent back to the fill buffer <b>325</b> and placed in the fill buffer in those bytes not written to by the WB temporal store instruction. The resulting line of data is placed back into the L1 cache by way of bus <b>335</b> and the line is updated to M state.</p><p>Table 1 illustrates the behavior of streaming stores for each memory type that \u201chit\u201d and/or \u201cmiss\u201d the L1 cache. The \u201cOp\u201d column defines the type of incoming instruction, in this case, streaming stores (i.e., non-temporal stores). The \u201cMem type\u201d column describes the memory type, the \u201cState\u201d column describes the state of the line of data, and the \u201cHit/Miss\u201d column describes whether there is a \u201chit\u201d or a \u201cmiss\u201d to the L1 cache. A \u201cHit L1\u201d means a hit to L1 cache whereas a \u201cMiss L1\u201d means a miss to L1 cache <b>320</b>, fill buffers <b>325</b>, WBB <b>340</b>, and SB <b>345</b>.</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" pgwide=\"1\" rowsep=\"0\"><tgroup align=\"left\" cols=\"7\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"6\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"7\" colwidth=\"70PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE 1</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Mem</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Row</entry><entry morerows=\"0\" valign=\"top\">Op</entry><entry morerows=\"0\" valign=\"top\">type</entry><entry morerows=\"0\" valign=\"top\">State</entry><entry morerows=\"0\" valign=\"top\">Hit/Miss</entry><entry morerows=\"0\" valign=\"top\">Action</entry><entry morerows=\"0\" valign=\"top\">Comments</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">WB</entry><entry morerows=\"0\" valign=\"top\">M,</entry><entry morerows=\"0\" valign=\"top\">Hit L1</entry><entry morerows=\"0\" valign=\"top\">Write to L1 cache, using</entry><entry morerows=\"0\" valign=\"top\">Update line to M if in</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">E</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">biased LRU algorithm.</entry><entry morerows=\"0\" valign=\"top\">E state.</entry></row><row><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">WB</entry><entry morerows=\"0\" valign=\"top\">S</entry><entry morerows=\"0\" valign=\"top\">Hit L1</entry><entry morerows=\"0\" valign=\"top\">Invalidate line in cache, issue</entry><entry morerows=\"0\" valign=\"top\">Same behavior as</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">request to bus controller, bring</entry><entry morerows=\"0\" valign=\"top\">temporal stores, but</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">line from L2 cache or external</entry><entry morerows=\"0\" valign=\"top\">using a biased LRU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">memory and send external</entry><entry morerows=\"0\" valign=\"top\">algorithm to</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">snoop. Line in L1 cache is</entry><entry morerows=\"0\" valign=\"top\">minimize pollution in</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">updated to M state.</entry><entry morerows=\"0\" valign=\"top\">the L1 cache.</entry></row><row><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">WB</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Miss L1</entry><entry morerows=\"0\" valign=\"top\">Allocate fill buffer in write</entry><entry morerows=\"0\" valign=\"top\">Behavior follows non-</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">combining (WC) Mode, send</entry><entry morerows=\"0\" valign=\"top\">temporal semantics</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Flush L2 attribute (self</entry><entry morerows=\"0\" valign=\"top\">(WC).</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">snoop).</entry></row><row><entry morerows=\"0\" valign=\"top\">4</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">WT</entry><entry morerows=\"0\" valign=\"top\">M</entry><entry morerows=\"0\" valign=\"top\">Hit L1</entry><entry morerows=\"0\" valign=\"top\">Write to L1 cache using biased</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LRU algorithm.</entry></row><row><entry morerows=\"0\" valign=\"top\">5</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">WT</entry><entry morerows=\"0\" valign=\"top\">S,</entry><entry morerows=\"0\" valign=\"top\">Hit L1</entry><entry morerows=\"0\" valign=\"top\">Send Flush L2 attribute (self</entry><entry morerows=\"0\" valign=\"top\">Same behavior as</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">E</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">snoop). Update both L1 cache</entry><entry morerows=\"0\" valign=\"top\">temporal stores, but</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">and external memory.</entry><entry morerows=\"0\" valign=\"top\">use biased LRU</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">algorithm.</entry></row><row><entry morerows=\"0\" valign=\"top\">6</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">WT</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Miss L1</entry><entry morerows=\"0\" valign=\"top\">Allocate fill buffer in WC</entry><entry morerows=\"0\" valign=\"top\">Behavior follows non-</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Mode, send Flush L2 attribute</entry><entry morerows=\"0\" valign=\"top\">temporal semantics</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">(self snoop).</entry><entry morerows=\"0\" valign=\"top\">(WC).</entry></row><row><entry morerows=\"0\" valign=\"top\">7</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">USWC</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Allocate fill buffer in WC</entry><entry morerows=\"0\" valign=\"top\">No self snoop</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Mode.</entry><entry morerows=\"0\" valign=\"top\">directives sent</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">because USWC is not</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">aliased in this</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">embodiment.</entry></row><row><entry morerows=\"0\" valign=\"top\">8</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">WP</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Allocate fill buffer in non-WC</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Mode, send Flush L1 and</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Flush L2 (self snoop).</entry></row><row><entry morerows=\"0\" valign=\"top\">9</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">UC</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Allocate fill buffer in non-WC</entry><entry morerows=\"0\" valign=\"top\">It maintains strong</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Mode.</entry><entry morerows=\"0\" valign=\"top\">ordering. Self snoop</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">directives only sent in</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">the case of memory</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">aliasing.</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"7\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>On an incoming WB streaming store that \u201chits\u201d a line of data in the L1 cache (Row 1), temporal store semantics are followed. That is, if the line of data is in the M or E state, the data is written to the L1 cache and the line is updated to the M state (if in the E state). On the other hand, if the line of data is in the S state, the line is invalidated and a fill buffer is allocated (Row 2). The fill buffer <b>325</b> issues a request to the bus controller <b>245</b> which brings the line of data from the L2 cache <b>130</b> or, if not in the L2 cache, from external memory <b>140</b>. Other CPUs in the system, if any, are snooped for the line of data. If the line is in another processor's cache and is in the E or S state, it is invalidated, otherwise, if in the M state, the line is first written to external memory <b>140</b> from the snooped processor and then the line of data is written back to the fill buffer <b>325</b> from which the request originated. The line of data is then placed in the L1 cache <b>320</b> and updated to the M state. To minimize cache pollution on a WB streaming store that \u201chits\u201d the L1 cache (Rows 1 &amp; 2), a biased LRU algorithm is used.</p><p>On an incoming WB streaming store that \u201cmisses\u201d the L1 cache (Row 3), non-temporal semantics are followed. In particular, a fill buffer <b>325</b> is allocated in write combining mode (i.e., WCFB). Once the WCFB is allocated, it does not issue a bus request to the bus controller <b>245</b> to write the line of data to external memory <b>140</b>. Rather, the WCFB write combines with other weakly-ordered write combinable store instructions of the same type (e.g., a WB or WT streaming store that \u201cmisses\u201d the L1 cache) that \u201chit\u201d the fill buffer until all bytes in the WCFB are written (i.e., all BW bits are set) or there is an eviction condition, in which case the fill buffer issues a request to the bus controller <b>245</b> to write the line to external memory <b>140</b>. The L2 cache is snooped and flushed when the request is issued to the bus controller <b>245</b>. That is, if the line of data is in the L2 cache and in M state, the line is written to external memory <b>140</b> and then invalidated, otherwise the line is invalidated. This procedure will be described in detail with respect to Table 2.</p><p>On an incoming WT streaming store that \u201chits\u201d a M line in the L1 cache (Row 4), the L1 cache controller follows temporal store semantics as described with respect to Row 1. Moreover, on an incoming WT streaming store that \u201chits\u201d a S or an E line in the L1 cache (Row 5), the L1 cache controller follows WT temporal store semantics. That is, both L1 cache and external memory are updated and the L2 cache is snooped and flushed, as described with respect to Row 3. However, on an incoming WT streaming store that \u201cmisses\u201d the L1 cache (Row 6), the L1 cache controller follows non-temporal store semantics, as described with respect to Row 3.</p><p>On an incoming USWC streaming store (Row 7), a fill buffer <b>325</b> is allocated in write combining mode (i.e., WCFB). The L1 cache controller neither checks L1 cache nor issues snooping because a USWC streaming store is not memory aliased. Memory aliasing occurs when the same line of data can be accessed by two instructions having different memory types. Since USWC is not aliased and always writes to external memory, it implies that a USWC request can never \u201chit\u201d the caches. Therefore, no self-snooping is needed upon issuing the request to the bus controller <b>245</b>. If other embodiment allow USWC aliasing, self-snooping directives to flush the L1 cache and L2 cache would be necessary. On an incoming WP streaming store (Row 8), a fill buffer is allocated (NWCFB) and both L1 and L2 are snooped and flushed. On an incoming UC streaming store (Row 9), the L1 cache controller allocates a fill buffer (NWCFB). This instruction is strongly ordered and causes eviction of allocated WCFBs.</p><p>Table 2 illustrates the behavior of streaming stores for each memory type that \u201chit\u201d a WBB <b>340</b> and/or SB <b>345</b>, NWCFB, and WCFB.</p><p><tables id=\"TABLE-US-00002\"><table colsep=\"0\" frame=\"none\" pgwide=\"1\" rowsep=\"0\"><tgroup align=\"left\" cols=\"6\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"6\" colwidth=\"70PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"6\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE 2</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"6\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Mem</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Row</entry><entry morerows=\"0\" valign=\"top\">Op</entry><entry morerows=\"0\" valign=\"top\">type</entry><entry morerows=\"0\" valign=\"top\">Hit/Miss</entry><entry morerows=\"0\" valign=\"top\">Action</entry><entry morerows=\"0\" valign=\"top\">Comments</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"6\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">All</entry><entry morerows=\"0\" valign=\"top\">Hit WBB</entry><entry morerows=\"0\" valign=\"top\">Block incoming SS.</entry><entry morerows=\"0\" valign=\"top\">No change with</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">or SB</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">respect to regular or</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">temporal stores.</entry></row><row><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">WB</entry><entry morerows=\"0\" valign=\"top\">Hit</entry><entry morerows=\"0\" valign=\"top\">Merge if fill buffer that was</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NWCFB</entry><entry morerows=\"0\" valign=\"top\">hit is: (1) WB store before</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">global observation (2)</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">globally observed in M state,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">or (3) globally observed in E</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">state and RepEn control field</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">is set.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Otherwise, block incoming SS.</entry></row><row><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">WT</entry><entry morerows=\"0\" valign=\"top\">Hit</entry><entry morerows=\"0\" valign=\"top\">Merge if fill buffer that was</entry><entry morerows=\"0\" valign=\"top\">WT streaming stores</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NWCFB</entry><entry morerows=\"0\" valign=\"top\">hit is: (1) WB store before</entry><entry morerows=\"0\" valign=\"top\">will only merge with</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">global observation or (2)</entry><entry morerows=\"0\" valign=\"top\">a NWCFB if there is</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">globally observed in M state.</entry><entry morerows=\"0\" valign=\"top\">memory aliasing.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Otherwise, block incoming SS.</entry></row><row><entry morerows=\"0\" valign=\"top\">4</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">USWC</entry><entry morerows=\"0\" valign=\"top\">Hit</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">USWC streaming</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NWCFB</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">stores should never</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">hit a combinable</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NWCFB since USWC</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">is not memory</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">aliased.</entry></row><row><entry morerows=\"0\" valign=\"top\">5</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">WP,</entry><entry morerows=\"0\" valign=\"top\">Hit</entry><entry morerows=\"0\" valign=\"top\">Block incoming streaming</entry><entry morerows=\"0\" valign=\"top\">No change with</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">UC</entry><entry morerows=\"0\" valign=\"top\">NWCFB</entry><entry morerows=\"0\" valign=\"top\">store.</entry><entry morerows=\"0\" valign=\"top\">respect to temporal</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">stores.</entry></row><row><entry morerows=\"0\" valign=\"top\">6</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">WB,</entry><entry morerows=\"0\" valign=\"top\">Hit</entry><entry morerows=\"0\" valign=\"top\">Write combine until eviction.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WT,</entry><entry morerows=\"0\" valign=\"top\">WCFB</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">USWC</entry></row><row><entry morerows=\"0\" valign=\"top\">7</entry><entry morerows=\"0\" valign=\"top\">SS</entry><entry morerows=\"0\" valign=\"top\">WP,</entry><entry morerows=\"0\" valign=\"top\">Hit</entry><entry morerows=\"0\" valign=\"top\">Block incoming streaming</entry><entry morerows=\"0\" valign=\"top\">No change with</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">UC</entry><entry morerows=\"0\" valign=\"top\">WCFB</entry><entry morerows=\"0\" valign=\"top\">store. Evict WCFB.</entry><entry morerows=\"0\" valign=\"top\">respect to regular</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">stores.</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"6\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>An incoming streaming store that \u201chits\u201d either the WBB <b>340</b> or SB <b>345</b> (Row 1), irrespective of the memory type, is blocked until the WBB <b>340</b> or SB <b>345</b> is deallocated. On an incoming WB streaming store that \u201chits\u201d a NWCFB (Row 2), if the the memory and instruction type in the NWCFB is a WB store, the incoming WB streaming store will merge (write to the bytes addressed by the incoming WB streaming store) with the original WB store for which the NWCFB was allocated (see items (1) and (2) in \u201cAction\u201d field). The line of data brought from the bus controller <b>245</b> does not overwrite the bytes written from the processor core <b>208</b> on an incoming store instruction (in the case where the line of data is brought into the fill buffer after the bytes are written from the core). However, the bytes written from the processor core <b>208</b> do overwrite the corresponding bytes of the line of data brought into the fill buffer (in the case where the line of data is brought into the fill buffer before the bytes are written from the core).</p><p>Additionally, an incoming WB streaming store that \u201chits\u201d a NWCFB will merge with the same if the NWCFB is globally observed in the E state and the \u201cRepEn\u201d bit is set (e.g., the NWCFB is globally observed in the E state and was originally allocated to service a WB load, which is not a prefetch to L2 cache). Otherwise, on other WB streaming store hits to a NWCFB, the WB streaming store is blocked until the NWCFB has been deallocated. Global observation occurs when the line of data (1) is found in the L2 cache, (2) is found in a cache of another processor (in the case of a multi-processor system), or (3) when the line is neither found in the L2 cache nor in a cache of another processor (i.e., the data is in external memory).</p><p>On an incoming WT streaming store that \u201chits\u201d a NWCFB (Row 3), the WT streaming store merges with the NWCFB if it is globally observed in the M state or the NWCFB is servicing a WB store, otherwise the incoming WT streaming store is blocked. In one embodiment, where only WB is globally observed in M state, it implies that upon a hit, a WT streaming store can only merge with a NWCFB servicing a WB store.</p><p>It is to be noted that an incoming USWC streaming store (based on this embodiment) will never \u201chit\u201d a NWCFB because a USWC instruction is not memory aliased (Row 4). An incoming WP or UC streaming store that \u201chits\u201d a NWCFB is blocked because each is a strongly ordered instructions with respect to other NWCFB instructions (Row 5). An incoming WB and WT streaming stores and an incoming USWC streaming store that \u201chits\u201d a WCFB, write combine with the WCFB (Row 6). The WCFB remains in write combining mode and will not issue a request to the bus controller <b>245</b> to write the line of data to external memory until the WCFB is full (i.e., all BW bits are set) or there is an eviction condition (e.g., detection of a UC instruction). Finally, an incoming UC or WP streaming store that \u201chits\u201d a WCFB causes eviction of the WCFB and is blocked until the WCFB is deallocated (Row 7).</p><p>Table 3 illustrates the behavior of a fill buffer allocated for a streaming store upon an incoming load or store instruction. Under the \u201cHit/Miss\u201d heading two possibilities exist. A \u201cHit SS WCFB\u201d is a fill buffer that is allocated for a USWC streaming store, or a WB or WT streaming store that \u201cmissed\u201d the L1 cache. A \u201cHit SS NWCFB\u201d is a fill buffer that is allocated for a UC or WP streaming store, a WB streaming store that \u201chits\u201d a S line in the L1 cache, or a WT streaming store that \u201chits\u201d an E or a S line in the L1 cache.</p><p><tables id=\"TABLE-US-00003\"><table colsep=\"0\" frame=\"none\" pgwide=\"1\" rowsep=\"0\"><tgroup align=\"left\" cols=\"6\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"21PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"5\" colwidth=\"98PT\"></colspec><colspec align=\"left\" colname=\"6\" colwidth=\"70PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"6\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE 3</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"6\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Mem</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Row</entry><entry morerows=\"0\" valign=\"top\">Op</entry><entry morerows=\"0\" valign=\"top\">type</entry><entry morerows=\"0\" valign=\"top\">Hit/Miss</entry><entry morerows=\"0\" valign=\"top\">Action</entry><entry morerows=\"0\" valign=\"top\">Comments</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"6\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">Load</entry><entry morerows=\"0\" valign=\"top\">All</entry><entry morerows=\"0\" valign=\"top\">Hit SS</entry><entry morerows=\"0\" valign=\"top\">Evict WCFB and block</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WCFB</entry><entry morerows=\"0\" valign=\"top\">incoming load.</entry></row><row><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">Load</entry><entry morerows=\"0\" valign=\"top\">All</entry><entry morerows=\"0\" valign=\"top\">Hit SS</entry><entry morerows=\"0\" valign=\"top\">Block incoming load.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NWCFB</entry></row><row><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">Store</entry><entry morerows=\"0\" valign=\"top\">WB,</entry><entry morerows=\"0\" valign=\"top\">Hit SS</entry><entry morerows=\"0\" valign=\"top\">Block incoming store, unless it</entry><entry morerows=\"0\" valign=\"top\">If incoming store is a</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WT</entry><entry morerows=\"0\" valign=\"top\">WCFB</entry><entry morerows=\"0\" valign=\"top\">is a streaming store. If</entry><entry morerows=\"0\" valign=\"top\">streaming store, write</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">blocked, evict WCFB.</entry><entry morerows=\"0\" valign=\"top\">combine until eviction.</entry></row><row><entry morerows=\"0\" valign=\"top\">4</entry><entry morerows=\"0\" valign=\"top\">Store</entry><entry morerows=\"0\" valign=\"top\">USWC</entry><entry morerows=\"0\" valign=\"top\">Hit SS</entry><entry morerows=\"0\" valign=\"top\">Write combine incoming store.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WCFB</entry></row><row><entry morerows=\"0\" valign=\"top\">5</entry><entry morerows=\"0\" valign=\"top\">Store</entry><entry morerows=\"0\" valign=\"top\">WP,</entry><entry morerows=\"0\" valign=\"top\">Hit SS</entry><entry morerows=\"0\" valign=\"top\">Block incoming store. Evict</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">UC</entry><entry morerows=\"0\" valign=\"top\">WCFB</entry><entry morerows=\"0\" valign=\"top\">WCFB.</entry></row><row><entry morerows=\"0\" valign=\"top\">6</entry><entry morerows=\"0\" valign=\"top\">Store</entry><entry morerows=\"0\" valign=\"top\">All</entry><entry morerows=\"0\" valign=\"top\">Hit SS</entry><entry morerows=\"0\" valign=\"top\">Block incoming store, unless</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NWCFB</entry><entry morerows=\"0\" valign=\"top\">the NWCFB has a WB SS</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">and the incoming store is a</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WB store, including SS, or it is</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">a WT SS.</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"6\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>An incoming load instruction that \u201chits\u201d a streaming store WCFB (Row 1), irrespective of the memory type, causes eviction of the WCFB and the incoming load is blocked until the WCFB is deallocated. An incoming load instruction that \u201chits\u201d a streaming store NWCFB (Row 2), irrespective of memory type, is blocked until the NWCFB is deallocated. An incoming WB or WT store instruction that \u201chits\u201d a streaming store WCFB (Row <b>3</b> ) is blocked, unless it is a streaming store instruction, in which case the incoming streaming store write combines with the WCFB. If the store is blocked, it evicts the WCFB. An incoming USWC store that \u201chits\u201d a streaming store WCFB write combines with the WCFB (Row 4).</p><p>Moreover, an incoming WP or UC store that \u201chits\u201d a streaming store WCFB (Row 5) causes eviction of the WCFB and is blocked until the WCFB is deallocated. Finally, an incoming store that \u201chits\u201d a streaming store NWCFB (Row 6) is blocked, unless the NWCFB has a WB streaming store (i.e., hit S line in L1 cache) and the incoming store is a WB store, including a streaming store, or a WT streaming store.</p><p>FIG. 5 is a flow diagram illustrating an exemplary process <b>500</b> of implementing the present invention. Referring to FIG. 5, the process <b>500</b> commences at block <b>502</b> where an incoming streaming store instruction is detected (e.g., by the L1 cache controller <b>235</b> ). On a WP or UC streaming store, the process moves to block <b>504</b> where a fill buffer is allocated (NWCFB) and, at block <b>506</b>, a bus request is issued to the bus controller to write the line of data to external memory. At block <b>508</b>, the line of data is written to external memory and, at block <b>510</b>, the operation is completed with the deallocation of the fill buffer.</p><p>At block <b>502</b>, if the incoming streaming store instruction is a USWC or a WB or WT that \u201cmissed\u201d the L1 cache and fill buffers, the process moves to block <b>512</b> where a fill buffer is allocated in write combining mode (i.e., WCFB). The process then moves to block <b>514</b> where a determination is made as to whether there is a new incoming instruction and whether the new incoming instruction is a USWC store, or a WB or WT streaming store instruction that \u201chit\u201d the WCFB. If so, the process continues to block <b>516</b>, otherwise the process moves to block <b>518</b>. At block <b>516</b> the new incoming store instruction is write combined with the WCFB. At block <b>518</b>, a determination is made as to whether the line of data in the WCFB is full (i.e., whether all the BW bits are set). If the WCFB is not full the process moves to block <b>520</b>, otherwise the process moves to block <b>524</b>.</p><p>At block <b>520</b>, if there is a load \u201chit\u201d, a WP or UC store \u201chit\u201d, or a temporal WB or WT store \u201chit\u201d to the WCFB, the process moves to block <b>521</b>, otherwise the process moves to block <b>522</b>. At block <b>521</b>, the incoming instruction is blocked and the WCFB is marked for eviction. At block <b>522</b>, if there is any other eviction condition, the process continues to block <b>524</b>, otherwise the process moves back to block <b>514</b> for detection of a new incoming store instruction. At block <b>524</b>, in response to the eviction condition, a bus request is issued to write the line of data in the WCFB to external memory.</p><p>Referring back to block <b>502</b>, if the incoming streaming store instruction is a WB that \u201chit\u201d a S line in the L1 cache, the process moves to block <b>526</b>. At block <b>526</b>, the line in the L1 cache is invalidated, a fill buffer is allocated (i.e., NWCFB), and a bus request is issued to the bus controller to bring the line of data from the L2 cache or external memory (this may takes dozens of clock cycles). At block <b>528</b>, if while the NWCFB is allocated, a new incoming WB, temporal or non-temporal, or WT streaming store \u201chits\u201d the NWCFB, the incoming store instruction merges with the NWCFB. Other incoming stores and all load hits are blocked. At block <b>530</b>, the line of data is placed in the L1 cache and the NWCFB is deallocated.</p><p>Referring back to block <b>502</b> again, if the incoming streaming store instruction is a WT that \u201chit\u201d a S or an E line in the L1 cache, the process moves to block <b>532</b> where a fill buffer is allocated (NWCFB) and a bus request is issued to the bus controller to write the line of data to external memory and update the L1 cache (this may takes dozens of clock cycles). At block <b>534</b>, while the NWCFB is allocated, all new loads and stores that \u201chit\u201d the NWCFB are blocked until the NWCFB is deallocated.</p><p>At block <b>502</b>, if the incoming streaming store instruction is a WB that \u201chit\u201d a M or an E line or a WT that \u201chit\u201d a M line in the L1 cache, the process moves to block <b>538</b>. At block <b>538</b>, the L1 cache is updated using a biased LRU algorithm to reduce pollution of the cache and the line transitions to M state.</p><p>The present invention provides several advantages over prior art architectures. Specifically, the present invention provides for non-temporal semantics which reduces cache pollution. In addition, the present invention allows certain instructions to be weakly-ordered and write combinable with other instructions up to a line of data to minimize bus transactions while preserving ordering with respect to memory mapped I/O or strongly ordered instructions. Moreover, an application programmer can choose between caching data or writing data directly to external memory.</p><p>While certain exemplary embodiments have been described and shown in the accompanying drawings, it is to be understood that such embodiments are merely illustrative of and not restrictive on the broad invention, and that this invention not be limited to the specific constructions and arrangements shown and described, since various other modifications may occur to those ordinarily skilled in the art.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Salvador", "last_name": "Palanca", "name": ""}, {"first_name": "Vladimir", "last_name": "Pentkovski", "name": ""}, {"first_name": "Steve", "last_name": "Tsai", "name": ""}, {"first_name": "Subramaniam", "last_name": "Maiyuran", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTEL CORPORATION"}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711138"}, {"primary": false, "label": "711E12021"}, {"primary": false, "label": "711145"}, {"primary": false, "label": "711137"}, {"primary": false, "label": "711160"}, {"primary": false, "label": "711129"}, {"primary": false, "label": "711128"}, {"primary": false, "label": "711125"}, {"primary": false, "label": "711E1204"}, {"primary": false, "label": "711133"}, {"primary": false, "label": "711E12043"}, {"primary": false, "label": "711118"}], "ecla_classes": [{"label": "G06F   9/38E2"}, {"label": "G06F   9/38D"}, {"label": "G06F  12/08B18"}, {"label": "G06F  12/08B22L"}, {"label": "G06F  12/08B2"}], "cpc_classes": [{"label": "G06F  12/0804"}, {"label": "G06F  12/0897"}, {"label": "G06F   9/3842"}, {"label": "G06F  12/0804"}, {"label": "G06F  12/0888"}, {"label": "G06F   9/3824"}, {"label": "G06F   9/3842"}, {"label": "G06F  12/0888"}, {"label": "G06F   9/3824"}, {"label": "G06F  12/0897"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1998-03-31", "application_date": "1998-03-31", "family_members": [{"ucid": "US-6205520-B1", "titles": [{"lang": "EN", "text": "Method and apparatus for implementing non-temporal stores"}]}]}