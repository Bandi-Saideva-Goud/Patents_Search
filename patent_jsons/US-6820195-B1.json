{"patent_number": "US-6820195-B1", "publication_id": 74024696, "family_id": 23625197, "publication_date": "2004-11-16", "titles": [{"lang": "EN", "text": "Aligning load/store data with big/little endian determined rotation distance control"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11760181\" source=\"national office\"><p>Embodiments of the present invention are directed to an architecture structured to handle unaligned memory references. In one embodiment, a method for loading unaligned data stored in a plurality of memory locations comprises loading a first part of the unaligned data into a first storage location; rotating and sign-extending the first part of the unaligned data in the first storage location from a first position to a second position; loading a second part of the unaligned data into a second storage location; rotating the second part of the unaligned data in the second storage location from a third position to a fourth position; and combining the first storage location with the second location using a logical operation into a result storage location.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50748336\"><p>Embodiments of the present invention are directed to an architecture structured to handle unaligned memory references. In one embodiment, a method for loading unaligned data stored in a plurality of memory locations comprises loading a first part of the unaligned data into a first storage location; rotating and sign-extending the first part of the unaligned data in the first storage location from a first position to a second position; loading a second part of the unaligned data into a second storage location; rotating the second part of the unaligned data in the second storage location from a third position to a fourth position; and combining the first storage location with the second location using a logical operation into a result storage location.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6820195-B1-CLM-00001\" num=\"1\"><claim-text>1. A method for accessing a datum stored in a memory comprising:</claim-text><claim-text>accessing the memory to read out a first portion of the datum, the first portion comprising one or more first bytes; </claim-text><claim-text>performing a first rotation operation on the first bytes to produce rotated first bytes, wherein a rotate distance of the first rotation operation is based on whether the datum stored in the memory is stored in Big Endian order or in Little Endian order; </claim-text><claim-text>replacing portions of the rotated first bytes with binary zeroes to produce aligned first bytes; </claim-text><claim-text>storing the aligned first bytes to a first data store; </claim-text><claim-text>accessing the memory to read out a second portion of the datum, the second portion comprising one or more second bytes; </claim-text><claim-text>performing a second rotation operation on the second bytes to produce rotated second bytes, wherein a rotate distance of the second rotation operation is based on whether the datum stored in the memory is stored in Big Endian order or in Little Endian order; </claim-text><claim-text>replacing portions of the rotated second bytes with binary zeroes to produce aligned second bytes; </claim-text><claim-text>storing the aligned second bytes to a second data store; and </claim-text><claim-text>performing an OR operation of the content of the first data store and the second data store to produce the datum. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6820195-B1-CLM-00002\" num=\"2\"><claim-text>2. The method of <claim-ref idref=\"US-6820195-B1-CLM-00001\">claim 1</claim-ref> wherein the datum as stored in the memory can be an aligned datum or an unaligned datum.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6820195-B1-CLM-00003\" num=\"3\"><claim-text>3. The method of <claim-ref idref=\"US-6820195-B1-CLM-00001\">claim 1</claim-ref> wherein the step of replacing portions of the rotated first bytes with binary zeroes includes performing a masking operation.</claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6820195-B1-CLM-00004\" num=\"4\"><claim-text>4. The method of <claim-ref idref=\"US-6820195-B1-CLM-00003\">claim 3</claim-ref> wherein the step of replacing portions of the rotated second bytes with binary zeroes includes performing a sign extension operation.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6820195-B1-CLM-00005\" num=\"5\"><claim-text>5. The method of <claim-ref idref=\"US-6820195-B1-CLM-00001\">claim 1</claim-ref> wherein the datum is one of a 16-bit datum, a 32-bit datum, and a 64-bit datum.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6820195-B1-CLM-00006\" num=\"6\"><claim-text>6. The method of <claim-ref idref=\"US-6820195-B1-CLM-00001\">claim 1</claim-ref> further comprising storing the datum to a third data store subsequent to performing the OR operation.</claim-text></claim>"}, {"num": 7, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6820195-B1-CLM-00007\" num=\"7\"><claim-text>7. A CPU having a circuit configured to access a datum stored in a memory comprising:</claim-text><claim-text>a data input for receiving a portion of the datum from the memory; </claim-text><claim-text>a rotator circuit coupled to the data input and having a rotator output, the rotator circuit configured to perform a rotation operation of data on the input and to produce rotated data at the output; </claim-text><claim-text>a distance control circuit having a control signal coupled to the rotator circuit, wherein the control signal is dependent on whether the datum that is stored in the memory is stored in Big Endian order or in Little Endian order, wherein an amount of rotation performed by the rotator circuit is dependent on the control signal; and </claim-text><claim-text>a zero-filling circuit coupled to the rotator output and configured to replace one or more bit positions of a datum on the rotator output with binary zeroes. </claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6820195-B1-CLM-00008\" num=\"8\"><claim-text>8. The circuit of <claim-ref idref=\"US-6820195-B1-CLM-00007\">claim 7</claim-ref> wherein the datum stored in the memory can be an aligned datum or an unaligned datum.</claim-text></claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6820195-B1-CLM-00009\" num=\"9\"><claim-text>9. The circuit of <claim-ref idref=\"US-6820195-B1-CLM-00007\">claim 7</claim-ref> wherein the datum stored in the memory comprises a first portion of one or more bytes of data and a second portion of one or more bytes of data, wherein the first portion is processed by the circuit to produce a first result and the second portion is processed by the circuit to produce a second result, wherein an OR operation performed on the first result and the second result produces the datum stored in the memory.</claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6820195-B1-CLM-00010\" num=\"10\"><claim-text>10. A data processor system comprising:</claim-text><claim-text>a memory, wherein a first datum is stored in the memory, wherein the first datum can be an aligned datum or an unaligned datum; </claim-text><claim-text>a data input for receiving a portion of the first datum from the memory; </claim-text><claim-text>a rotator circuit coupled to the data input and having a rotator output, the rotator circuit configured to perform a rotation operation of data on the input and to produce rotated data at the output; </claim-text><claim-text>a distance control circuit having a control signal coupled to the rotator circuit, wherein the control signal is dependent on whether the first datum is stored in the memory in Big Endian order or in Little Endian order, wherein an amount of rotation performed by the rotator circuit is dependent on the control signal; and </claim-text><claim-text>a zero-filling circuit coupled to the rotator output and configured to replace one or more bit positions of a datum on the rotator output with binary zeroes. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6820195-B1-CLM-00011\" num=\"11\"><claim-text>11. The data processor system of <claim-ref idref=\"US-6820195-B1-CLM-00010\">claim 10</claim-ref> wherein the datum stored in the memory comprises a first portion of one or more bytes of data and a second portion of one or more bytes of data, wherein the first portion is processed by the circuit to produce a first result and the second portion is processed by the circuit to produce a second result, wherein an OR operation performed on the first result and the second result produces the datum stored in the memory.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54332834\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>The present invention relates generally to microprocessor or microcontroller architecture, and particularly to an architecture structured to handle unaligned memory references.</p><p>In computer architecture over the past decade RISC (Reduced Instruction Set Computer) devices, in which each instruction is ideally performed in a single operational cycle, have become popular. The RISC architecture has advantages over computers having standard architecture and instruction sets in that they were capable of much higher data processing speeds due to their ability to perform frequent operations in shorter periods of time. The RISC devices began with 16-bit instruction sets, and grew to 32-bit instruction set architectures having graphics capabilities. With such thirty-two bit instruction set architectures and more complex applications, there was a requirement for larger memory sizes, e.g., words two, four, or eight bytes in length (i.e., words of 16, 32, or 64 bits each). However, certain peripheral devices and applications generate or accept data of only one or two bytes. One result of this type of data is that it produces an unaligned word reference. Other examples, include some compressed data streams, which may pack data in ways that require access to unaligned data.</p><p>To understand what an unaligned word reference is, there needs to be a description of an aligned word reference. If a data object is of size N bytes at address A, then the object is aligned if A mod N=0. Table 1 shows examples of aligned and unaligned accesses of data, were the byte offsets are specified for the low-order three bits of the address (Computer Architecture A Quantitative Approach, John Hennessy and David Patterson, Morgan Kaufmann, Publishers, Inc., Copyright 1990, page 96, herein referred to as \u201cHennessy\u201d).</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77pt\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"77pt\"></colspec><thead><row><entry nameend=\"3\" namest=\"1\" rowsep=\"1\">TABLE 1</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Object Addresses</entry><entry>Aligned by byte offsets</entry><entry>Unaligned at byte Offset</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry>byte (8-bits)</entry><entry>0, 1, 2, 3, 4, 5, 6, 7</entry><entry>(never)</entry></row><row><entry>word (16-bits)</entry><entry>0, 2, 4, 6</entry><entry>1, 3, 5, 7</entry></row><row><entry>long word (32-bits)</entry><entry>0, 4</entry><entry>1, 2, 3, 5, 6, 7</entry></row><row><entry>quad-word (64-bits)</entry><entry>0</entry><entry>1, 2, 3, 4, 5, 6, 7</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>Hence, for a machine capable of handling 4 byte long words, if incoming data is loaded sequentially as 2 bytes of data followed by 2 more bytes of data, the 4 bytes of data cannot be retrieved or stored in a single cycle because it would overlap a word boundary within memory. Thus, some prior art RISC devices either do not accept data in this form, in which case special procedures must be used to ensure that all data is aligned at word boundaries, or programming is required which uses up at least two consecutive instruction cycles. One way to ensure, for example, that all data is aligned in word boundaries would be to add extra bits to data of shorter length usually known as bit stuffing. Whether bit stuffing is used or the programming is altered, the unaligned references degrade the performance of these prior art RISC devices.</p><p>To handle the loading and storing of unaligned data words in a system, i.e., a data word which straddles a word boundary in memory (Table 1), prior art machines have also used either an alignment network to load or store bytes in a word or a shifter, which shifts the data only in those cases where alignment is required (Hennessy, ibid., pages 95-97).</p><p>FIG. 1 illustrates a prior art alignment network <b>114</b>. In FIG. 1, memory <b>100</b> shows eight consecutive bytes (i.e., a byte equals 8 bits): Y<b>3</b>, Y<b>2</b>, Y<b>1</b>, D<b>4</b>, D<b>3</b>, D<b>2</b>, D<b>1</b>, and X<b>4</b>. Each byte in memory <b>100</b> is given an address which ranges from <b>0</b> to <b>7</b>. For example, address <b>2</b> in memory <b>100</b> has memory contents Y<b>1</b>. The desired data bytes that are used in this and the following examples are D<b>4</b> at address <b>3</b>, D<b>3</b> at address <b>4</b>, D<b>2</b> at address <b>5</b>, and D<b>1</b> at address <b>6</b>. Each of these desired data bytes are to be loaded and stored to and from register R <b>110</b>. Register R <b>110</b> has 4 byte positions: P<b>4</b>, P<b>3</b>, P<b>2</b>, and P<b>1</b>. Memory slice <b>112</b> of memory <b>100</b> shows a desired data byte D<b>4</b> at address <b>3</b>. D<b>4</b> could be loaded from memory slice <b>112</b> through the alignment network <b>114</b> into register R <b>115</b> at positions P<b>4</b>, P<b>3</b>, P<b>2</b>, or P<b>1</b>. In this case D<b>4</b> is loaded from memory slice <b>112</b> at address <b>3</b> to P<b>4</b> in register R <b>115</b> through alignment network <b>114</b>. Similarly, desired data bytes D<b>3</b>, D<b>2</b>, and D<b>1</b> located in memory <b>100</b> addresses <b>4</b>, <b>5</b>, and <b>6</b> can be loaded through a similar alignment network to positions P<b>3</b>, P<b>2</b>, and P<b>1</b> in register R <b>115</b> to give register R <b>110</b>. This type of hardware alignment network <b>114</b> could be seen in Intel's 8086 and 8088 which came out in the late 1970s. The Intel 8088 was word and byte addressable. The 8088 used a cross-bar switch to swap bytes (Structured Computer Organization, 3<sup>rd </sup>Edition, Andrew Tanenbaum, Copyright 1990, pages 215-217, pages 230-237). Note that Intel 8088 instruction set had separate instructions for shifting and rotating as these were considered different operations. For example, shifting one bit left would discard the leftmost bit, while rotating left would cycle the leftmost bit around to the rightmost bit.</p><p>FIG. 2 illustrates a prior art example of aligning a misaligned data word using shifting operations. An example can be seen in U.S. Pat. No. 4,814,976, RISC Computer With Unaligned Reference Handling And Method For The Same, Hansen, et al., issued Mar. 21, 1989 (herein referred to as \u201cHansen\u201d). The contents of memory <b>100</b> at address <b>0</b>-<b>3</b> are loaded into register <b>120</b>, locations PA<b>4</b> to PA<b>1</b>. The contents of memory <b>100</b> in addresses <b>4</b> to <b>7</b> are loaded into register B <b>130</b> at locations PB<b>4</b> to PB<b>1</b>. Register A <b>120</b> is then shifted left three places, so that D<b>4</b> is in position PA<b>4</b>. Register B <b>130</b> is shifted right one place so that D<b>3</b> is in location PB<b>3</b>, D<b>2</b> is in PB<b>2</b>, and D<b>1</b> is in PB<b>1</b>. Register A <b>122</b> is merged <b>144</b> with register B <b>132</b> to give the desired data located in the proper position in register R <b>110</b>. The merge <b>144</b> was done by either overwriting locations PA<b>3</b> to PA<b>1</b> in register A <b>122</b> with locations PB<b>3</b> to PB<b>1</b> in register B <b>132</b> or the appropriate positions in register B <b>132</b> were overwritten by the appropriate places in register A <b>122</b>. In the alternative, the merge <b>144</b> may copy the contents of PA<b>4</b> in register A <b>122</b> to position P<b>4</b> in register R <b>110</b> and may copy the contents of PB<b>3</b>, PB<b>2</b>, and PB<b>1</b> of register B <b>132</b> into locations P<b>3</b>, P<b>2</b>, and P<b>1</b> of register R <b>110</b>.</p><p>Thus, unaligned words in memory were loaded and aligned in the microprocessor and aligned words in the microprocessor were unaligned and stored in memory using either an alignment network <b>114</b> of FIG. 1 or a shift left, shift right, and merge <b>144</b> of FIG. <b>2</b>. These techniques were used, for example, on 32-bit words being loaded and stored from a 32-bit computer architecture. There are new problems which arise in a 64 bit architecture which loads and stores 32, 16, and 8 data bits. A 64 bit memory system requires twice as many alignment paths for bytes and half-words as a 32-bit memory system, as well as two 32-bits alignment pads for word accesses. Thus, the alignment network of the prior art becomes a complicated and expensive solution. Also, in FIG. 2, the merge <b>144</b> becomes more complicated as it must handle many more don't cares <b>116</b> that are shifted into the registers. In addition, such prior art as Hansen, et al. does not disclose how sign extension is done in going from 32 to 64 bit words. FIG. 2 either has two M-bit shifters or a shift left and a shift right or a more complicated M-bit bi-directional shifter. Thus, as computer architectures go from 32 bit to 64 and maybe 128 bits, there needs to be a better method of handling unaligned data, which includes proper sign extension.</p><h4>SUMMARY OF THE INVENTION</h4><p>The present invention discloses a method for loading unaligned data stored in several memory locations, including a step of loading a first part of the unaligned data into a first storage location and rotating the first part from a first position to a second position in the first memory location. Next a second part of the unaligned data is loaded into a second storage location and rotated from one position to another position. Then the first storage location is combined with the second storage location using a logical operation into a result storage location. The storage locations may be, for example, 64-bit registers. The logical operation may be a bit-wise OR operation. The method may optionally include, performing masking, zero-extending and/or sign extending operations on the first storage location, when the first part of the unaligned data is in the second position of the first storage location.</p><p>The present invention also discloses a method for storing data into an unaligned plurality of memory locations, including rotating a first part of the data in a first storage location from a first position to a second position, and storing the data located in the second position to the unaligned plurality of memory locations at an address given by a first pointer. Then rotating a second part of the data in a second storage location from a third position to a forth position; and storing the data located in the forth position to the unaligned plurality of memory locations at an address given by a second pointer. The first pointer may, for example, include a high address and the second pointer include a low address.</p><p>These and other advantages and features of the present invention will become apparent to those skilled in this art upon a reading of the following detailed description which should be taken in conjunction with the accompanying drawings.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 illustrates a prior art alignment network;</p><p>FIG. 2 illustrates a prior art example of aligning a unaligned data word using shifting operations;</p><p>FIG. 3 illustrates a specific embodiment showing a load of an unaligned data word from memory to a register of the present invention;</p><p>FIG. 4 illustrates a specific embodiment of storing a value in a register to an unaligned memory location of the present invention;</p><p>FIG. 5 illustrates another specific embodiment of a load of an unaligned memory word to a register including sign extension of the present invention;</p><p>FIG. 6 illustrates a simplified format of the instructions used in a specific embodiment of the present invention;</p><p>FIG. 7 illustrates an example of the top level partitioning of the Core;</p><p>FIG. 8 illustrates a simplified block diagram of a specific embodiment of the LSU of the present invention;</p><p>FIG. 9 illustrates the pipeline behavior for a load with a cache hit in a specific embodiment of the present invention;</p><p>FIG. 10 shows the pipeline behavior for a store with a cache hit in a specific embodiment of the present invention;</p><p>FIG. 11 illustrates a simplified block diagram of the align and sign extension block;</p><p>FIG. 12 shows a specific embodiment of a 8 byte Right Rotator <b>800</b> of the present invention;</p><p>FIG. 13 shows an example of how a 4-byte unaligned word load instruction achieves alignment in different Endianness;</p><p>FIG. 14 shows an example of alignment of a 4-byte unaligned store instruction in different Endianness;</p><p>FIG. 15 illustrates a simplified block diagram of the Sign selection block <b>680</b> of the present invention;</p><p>FIG. 16 illustrates a simplified block diagram of the Sign (zero) Extension Block <b>690</b> of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DESCRIPTION OF THE SPECIFIC EMBODIMENTS</h4><p>The invention relates broadly to moving data in a microprocessor or microcontroller to and from memory, and particularly to loading and storing unaligned memory references.</p><p>FIG. 3 illustrates a specific embodiment showing a load of an unaligned data word from memory to a register of the present invention. In FIG. 3, memory <b>100</b> shows the four desired data bytes, D<b>4</b>, D<b>3</b>, D<b>2</b>, and D<b>1</b> that are to be moved into register R <b>110</b>. A pointer <b>150</b> gives the address of the lowest byte D<b>1</b>, i.e., the address equals 6 in memory <b>100</b>\u2032 (which is the same as memory <b>100</b> in FIG. <b>2</b>). The memory <b>100</b>\u2032 word boundary <b>152</b> is between addresses <b>3</b> and <b>4</b>. D<b>4</b> as the lower byte of the word from addresses <b>0</b>-<b>3</b> in memory <b>100</b>\u2032, is loaded into register A <b>124</b> at location PA<b>1</b>, and then rotated right one byte to give its new position PA<b>4</b> in register A <b>124</b> in FIG. <b>3</b>. Bytes to the right of D<b>4</b> have been zero masked so that locations PA<b>3</b> down to PA<b>1</b> contains 0. Similarly, bytes D<b>3</b>, D<b>2</b> and D<b>1</b> in memory <b>100</b>\u2032 are loaded into register B <b>134</b> at locations PB<b>4</b>, PB<b>3</b>, and PB<b>2</b> and rotated right one byte to positions PB<b>3</b> down to PB<b>1</b> in register B <b>134</b>. Bytes to the left of D<b>3</b> are 0 extended so that location PB<b>4</b> contains 0. Register A <b>124</b> is bit-wise \u201cOR'd\u201d <b>160</b> with register B <b>134</b> to give the result in register R <b>110</b>. The rotation right of FIG. 3 is simpler and may require less hardware than either the dual M-bit shifters or M-bit bi-directional shifter of FIG. <b>2</b>. In addition, the bit-wise OR <b>160</b> of FIG. 3 allows reuse of a logical operation already performed in the Integer Multimedia Unit (IMU), rather than needing a special merge unit <b>144</b> as in FIG. <b>2</b>. Thus, FIG. 3 represents a simpler hardware implementation of a load of a unaligned word from memory <b>100</b> to register R <b>110</b> than that in the prior art.</p><p>FIG. 4 illustrates a specific embodiment of storing a value in a register to an unaligned memory location of the present invention. In FIG. 4, the register <b>210</b> contains 8 bytes numbered from <b>7</b> down to <b>0</b> (Little Endian format). Bytes addressed <b>3</b> down to <b>0</b> of register <b>210</b> contain the bytes labeled w, x, y, and z (the contents of addresses <b>7</b>-<b>4</b> are don't care, \u201c*\u201d). These four aligned bytes in first register <b>210</b> are going to be stored via <b>214</b> in locations <b>4</b>-<b>1</b> containing E, D, C, and B in memory <b>218</b>. The first byte B in memory <b>218</b> is pointed to by pointer <b>216</b> which represents an address in a second register. In the memory <b>218</b>\u2032, byte w of first register <b>210</b> has overwritten E in location <b>4</b>. This is an address that is offset by 3 bytes from pointer <b>216</b>. An example instruction is illustrated in <b>222</b>. In memory <b>218</b>\u2033, bytes x, y, and z of register <b>210</b> have overwritten D ,C ,B in locations <b>3</b>-<b>1</b>. The starting point for this store is given by the pointer <b>216</b> offset by 0 bytes, and the example instruction is shown in <b>226</b>. Thus, a little Endian store of 4 bytes from register <b>210</b> to memory <b>218</b> starts at pointer <b>216</b> and proceeds 4 bytes, including the pointer <b>216</b>, to the left. Memory <b>218</b>\u2033 shows the bytes w, x, y, z located at addresses <b>4</b> down to <b>1</b>.</p><p>FIG. 5 illustrates another specific embodiment of a load of an unaligned memory word to a register including sign extension of the present invention. In FIG. 5, memory <b>230</b> shows the long word (32-bits) boundaries at address <b>8</b>, address <b>4</b> and address <b>0</b>. The unaligned word is given by bytes E, D, C and B in memory <b>230</b>. A pointer <b>232</b>, which is an address put in the second register, points to the first byte B to be loaded from memory <b>230</b>. The byte E in memory <b>230</b> represents the highest byte located by adding the pointer <b>232</b> with address <b>1</b> plus an offset of <b>3</b> to give an address of <b>4</b> in memory <b>230</b>. Byte E in memory <b>230</b> is then loaded into hi register <b>234</b> at address <b>0</b> and rotated right to an address <b>3</b> in hi register <b>234</b>. The bytes to the right of byte E in <b>234</b> have been <b>0</b> masked and the bytes to the left of byte E in hi register <b>234</b> have been sign-extended, i.e., \u201cssss\u201d. Instruction <b>236</b> gives an example of load high unaligned word with offset of 3 to a \u201chi\u201d register. Bytes D, C, and B of memory <b>230</b> are loaded into register <b>238</b> starting at address <b>1</b> and rotated right to occupy addresses <b>2</b>, <b>1</b> and <b>0</b> of low register <b>238</b>. An example instruction <b>240</b> shows load lo unaligned word with offset <b>0</b> to a \u201clo\u201d register. The bytes to the left of D in lo register <b>238</b> have been <b>0</b> extended. Register <b>242</b> shows the result of bit-wise ORing hi register <b>234</b> with lo register <b>238</b>. The result is a sign-extended word with E, D, C, and B being aligned in result register <b>242</b>. A sample instruction <b>244</b> shows the bit-wise ORing of the hi register <b>234</b> with the lo register <b>238</b> to give the result register <b>242</b>.</p><p>In the specific embodiments illustrated, memory is byte addressed. The load and store instructions provide access to data using Little-Endian or Big-Endian representations. In a specific embodiment, the endianness of load and store instructions is specified at power-on reset, and does not change thereafter.</p><p>Note that Little Endian byte order puts the byte address whose address is zero at the least significant position in the word (the little end). Big Endian byte order puts the byte address whose address is zero at the most significant position in the word (the big end). Thus, in a Big Endian computer architecture, bits of data are thought of as being lined up from left to right, the lowest number and most significant bit being on the left, and in a Little Endian architecture, the bits are numbered right to left, the least significant bit and lowest number being located on the right.</p><p>In a specific embodiment, the load and store instructions transfer data between a register and memory, where some load instructions have signed and unsigned variants to perform the correct extension into the register. For byte (8-bit) and word (16-bit) object sizes, both signed and unsigned loads may exist. For long-word (32-bit) object sizes, only signed loads may be provided. This is because all 32-bit objects may be held in a sign-extended form in registers regardless of sign. For quad-word (64-bit) object sizes, there may be no distinction between signed and unsigned loads.</p><p>In the above specific embodiment two different sets of load and store instructions are provided:</p><p>The first set are: Aligned Load And Store Instructions and support naturally aligned data. This is where the address of the data is an exact multiple of the width of the access. If one of these instructions attempts a unaligned access, it will cause a misalignment exception.</p><p>The second set are: Unaligned Access Support. An example is software which may want to access objects that are unaligned(packed data structures for example). Instructions have been included that may be used to construct efficient sequences for loading objects that are unaligned, or with unknown alignment.</p><p>Instructions for loading and storing unaligned long-words and quad-words are provided. Instructions for accessing unaligned words (16-bits) may use existing aligned store and arithmetic instructions: For example:</p><p><tables id=\"TABLE-US-00002\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"offset\" colwidth=\"42pt\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"175pt\"></colspec><thead><row><entry></entry><entry align=\"center\" nameend=\"1\" namest=\"offset\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry><entry>/* little Endian example */</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"offset\" colwidth=\"42pt\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"112pt\"></colspec><tbody valign=\"top\"><row><entry></entry><entry>LD.B</entry><entry>Rbase, #0, Rtmp0</entry></row><row><entry></entry><entry>LD.B</entry><entry>Rbase, #1, Rtmp1</entry></row><row><entry></entry><entry>SHLLI</entry><entry>Rtmp1 #8, Rtmp1</entry></row><row><entry></entry><entry>OR</entry><entry>Rtmp0, Rtmp1, Result</entry></row><row><entry></entry><entry align=\"center\" nameend=\"2\" namest=\"offset\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>where LD.B loads a byte from the effective address formed by adding the first source operand to a 10-bit immediate constant (Table 2). The byte is sign-extended into the result register; and</p><p><tables id=\"TABLE-US-00003\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 2</entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry><chemistry id=\"CHEM-US-00001\"><attachments><attachment attachment-type=\"cdx\" file=\"US06820195-20041116-C00001.CDX\" idref=\"CHEMCDX-00001\"></attachment><attachment attachment-type=\"mol\" file=\"US06820195-20041116-C00001.MOL\" idref=\"CHEMMOL-00001\"></attachment></attachments></chemistry></entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>where the SHLLI instruction logically left shifts R<sub>m </sub>by S<sub>&lt;0 FOR 6&gt;</sub> and stores the result in R<sub>d </sub>(Table 3); and</p><p><tables id=\"TABLE-US-00004\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 3</entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry><chemistry id=\"CHEM-US-00002\"><attachments><attachment attachment-type=\"cdx\" file=\"US06820195-20041116-C00002.CDX\" idref=\"CHEMCDX-00002\"></attachment><attachment attachment-type=\"mol\" file=\"US06820195-20041116-C00002.MOL\" idref=\"CHEMMOL-00002\"></attachment></attachments></chemistry></entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>where the OR instruction performs the bitwise-or of the contents of R<sub>m </sub>and R<sub>n </sub>and stores the result in the register R<sub>d </sub>(Table 4):</p><p><tables id=\"TABLE-US-00005\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 4</entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry><chemistry id=\"CHEM-US-00003\"><attachments><attachment attachment-type=\"cdx\" file=\"US06820195-20041116-C00003.CDX\" idref=\"CHEMCDX-00003\"></attachment><attachment attachment-type=\"mol\" file=\"US06820195-20041116-C00003.MOL\" idref=\"CHEMMOL-00003\"></attachment></attachments></chemistry></entry></row><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>FIG. 6 illustrates a simplified format of the instructions used in a specific embodiment of the present invention. In FIG. 6, location <b>310</b> contains the operation or op code. Location <b>312</b> contains the base register, \u201cm,\u201d which when added to the offset constant, \u201cs,\u201d give an address of either the highest or lowest byte in the unaligned object. The result of the load operation is stored in a destination register \u201cd.\u201d For a store operation the resulting value to be stored is in a register \u201cy.\u201d</p><p>The instructions described in this embodiment can be used to load a unaligned long-word or quad-word object in 3 instructions. Storing a unaligned long-word or quad-word takes 2 instructions.</p><p>Instruction sequences for unaligned long-word loads return a sign-extended result. If zero extension is required, this may be performed in software, at the cost of an extra instruction.</p><p>An example of a unaligned load sequence is as follows:</p><p>LDHI.L ptr, #off+3, Rhi</p><p>LDLO.L ptr, #off, Rlo</p><p>OR Rhi, Rlo, result</p><p>The address of the highest byte in the unaligned object is passed to the \u201cload high part\u201d instruction (LDHI.L), while the address of the lowest byte in the unaligned object is passed to the \u201cload low part\u201d instruction (LDHI.L). Typically, the immediate operand to the high part instruction is (n\u22121) more than the immediate operand to the low part instruction, where \u201cn\u201d is the object size in bytes.</p><p>An example of a unaligned store sequence is as follows:</p><p>STHI.L ptr, #off+3, value</p><p>STLO.L ptr, #off, value</p><p>As for the unaligned load sequence, the address (e.g., ptr+#off+3) passed to the high part instruction (STHI.L) should point to the highest byte of the unaligned object, while the address passed to the low part instruction (STHO.L) should point to the lowest byte of the unaligned object (e.g., ptrt #off).</p><p>Table 5 shows examples of load and store instructions of a specific embodiment.</p><p><tables id=\"TABLE-US-00006\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"offset\" colwidth=\"56pt\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"161pt\"></colspec><thead><row><entry></entry><entry nameend=\"1\" namest=\"offset\" rowsep=\"1\">TABLE 5</entry></row><row><entry></entry><entry align=\"center\" nameend=\"1\" namest=\"offset\" rowsep=\"1\"></entry></row><row><entry></entry><entry>Description</entry></row><row><entry></entry><entry align=\"center\" nameend=\"1\" namest=\"offset\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"56pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"161pt\"></colspec><tbody valign=\"top\"><row><entry>Un-Aligned Load</entry><entry></entry></row><row><entry>Instructions</entry></row><row><entry>LDHI.L</entry><entry>Load the high part of a unaligned, signed long-word</entry></row><row><entry></entry><entry>from memory to a general-purpose register.</entry></row><row><entry>LDLO.L</entry><entry>Load the low part of a unaligned, signed long-word</entry></row><row><entry></entry><entry>from memory to a general-purpose register.</entry></row><row><entry>LDHI.Q</entry><entry>Load the high part of a unaligned quad-word from</entry></row><row><entry></entry><entry>memory to a general-purpose register (sign may be</entry></row><row><entry></entry><entry>unimportant for objects the same size as a register).</entry></row><row><entry>LDLO.Q</entry><entry>Load the low part of a unaligned quad-word from</entry></row><row><entry></entry><entry>memory to a general-purpose register (sign may be</entry></row><row><entry></entry><entry>unimportant for objects the same size as a register)</entry></row><row><entry>Un-Aligned Store</entry></row><row><entry>Instructions</entry></row><row><entry>STHI.L</entry><entry>Unaligned store of the high part of a long-word from a</entry></row><row><entry></entry><entry>general-purpose register to memory.</entry></row><row><entry>STLO.L</entry><entry>Unaligned store of the low part of a long-word from a</entry></row><row><entry></entry><entry>general-purpose register to memory.</entry></row><row><entry>STHI.Q</entry><entry>Unaligned store of the high part of a quad-word from a</entry></row><row><entry></entry><entry>general-purpose register to memory.</entry></row><row><entry>STLO.Q</entry><entry>Unaligned store of the low part of a quad-word from a</entry></row><row><entry></entry><entry>general-purpose register to memory.</entry></row><row><entry align=\"center\" nameend=\"2\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><h4>Specific Embodiments of Hardware Implementations</h4><p>In a specific embodiment, the present invention may be implemented in a CPU having a core unit <b>200</b> at the zero or root hierarchy level. The Core <b>400</b> may include six units at the hierarchy level <b>1</b>, plus an optional detachable Floating Point Unit (FPU). FIG. 7 illustrates an example of the top level partitioning of the Core <b>400</b>. Table 5 describes the functions of each unit in the core.</p><p><tables id=\"TABLE-US-00007\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"35pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"56pt\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"35pt\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"91pt\"></colspec><thead><row><entry nameend=\"4\" namest=\"1\" rowsep=\"1\">TABLE 5</entry></row><row><entry align=\"center\" nameend=\"4\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Hierarchy</entry><entry></entry><entry></entry><entry></entry></row><row><entry>Level</entry><entry>Unit</entry><entry>Acronym</entry><entry>Description</entry></row><row><entry align=\"center\" nameend=\"4\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry>0</entry><entry>S5 Core 400</entry><entry>S5</entry><entry>Top level core block</entry></row><row><entry>1</entry><entry>Bus interface unit</entry><entry>BIU</entry><entry>Controls bus access to</entry></row><row><entry></entry><entry>405</entry><entry></entry><entry>external modules such as</entry></row><row><entry></entry><entry></entry><entry></entry><entry>peripheral modules and</entry></row><row><entry></entry><entry></entry><entry></entry><entry>external memory interface.</entry></row><row><entry>1</entry><entry>Instruction Flow</entry><entry>IFU</entry><entry>The front end of the CPU</entry></row><row><entry></entry><entry>Unit 410</entry><entry></entry><entry>pipe: fetch, decode, issue &amp;</entry></row><row><entry></entry><entry></entry><entry></entry><entry>branch. Also contains</entry></row><row><entry></entry><entry></entry><entry></entry><entry>mode B emulation.</entry></row><row><entry>1</entry><entry>Instruction</entry><entry>IMU</entry><entry>Handles all integer and multi-</entry></row><row><entry></entry><entry>multimedia unit</entry><entry></entry><entry>media instructions. The</entry></row><row><entry></entry><entry>420</entry><entry></entry><entry>main CPU datapath.</entry></row><row><entry>1</entry><entry>Instruction cache</entry><entry>ICU</entry><entry>Comprises the Instruction</entry></row><row><entry></entry><entry>Unit 430</entry><entry></entry><entry>Cache and the Instruction</entry></row><row><entry></entry><entry></entry><entry></entry><entry>Translation Lookaside Buffer</entry></row><row><entry></entry><entry></entry><entry></entry><entry>(TLB)</entry></row><row><entry>1</entry><entry>Load Store Unit</entry><entry>LSU</entry><entry>Handles all memory</entry></row><row><entry></entry><entry>440</entry><entry></entry><entry>instructions and Data</entry></row><row><entry></entry><entry></entry><entry></entry><entry>cache control.</entry></row><row><entry>1</entry><entry>Data cache Unit</entry><entry>DCU</entry><entry>Comprises the Data Cache</entry></row><row><entry></entry><entry>450</entry><entry></entry><entry>and the Data Translation</entry></row><row><entry></entry><entry></entry><entry></entry><entry>Lookaside Buffer (TLB)</entry></row><row><entry>1</entry><entry>Floating Point</entry><entry>FPU</entry><entry>Detachable Floating point</entry></row><row><entry></entry><entry>Unit (not shown)</entry><entry></entry><entry>decoder, pipe control and</entry></row><row><entry></entry><entry></entry><entry></entry><entry>execution pipe (not shown in</entry></row><row><entry></entry><entry></entry><entry></entry><entry>FIG. 7).</entry></row><row><entry align=\"center\" nameend=\"4\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>In a specific embodiment the load/store unit (LSU) <b>440</b> performs the functions of: executing all memory related instructions, handling snoop requests from the BIU <b>405</b>, handling access to configuration registers, handling access to debug registers via configuration space requests from the BIU <b>403</b>, maintaining data cache, e.g., cache coherency, line-fill, and/or writeback, checking access permissions, supporting data watchpoints, performing load and store on behalf of the FPU, and performing some data transfer between the FPU and the Core <b>400</b>.</p><p>FIG. 8 illustrates a simplified block diagram of a specific embodiment the LSU <b>440</b> of the present invention. The LSU <b>440</b> includes 8 functional blocks given at hierarchy level <b>2</b> in Table 7.</p><p><tables id=\"TABLE-US-00008\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35pt\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"35pt\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"105pt\"></colspec><thead><row><entry nameend=\"4\" namest=\"1\" rowsep=\"1\">TABLE 7</entry></row><row><entry align=\"center\" nameend=\"4\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry></entry><entry></entry><entry>Hierarchy</entry><entry></entry></row><row><entry>Acronym</entry><entry>Name</entry><entry>level</entry><entry>Description</entry></row><row><entry align=\"center\" nameend=\"4\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry>lsp 510</entry><entry>lspipe</entry><entry>2</entry><entry>Load/Store Pipeline Control Block</entry></row><row><entry>dcc 515</entry><entry></entry><entry>2</entry><entry>Data Cache Controller</entry></row><row><entry>drf 520</entry><entry>drefill</entry><entry>2</entry><entry>Drefill Block</entry></row><row><entry>cfgrq 530</entry><entry></entry><entry>2</entry><entry>Configuration block requester</entry></row><row><entry>cfgrp 535</entry><entry></entry><entry>2</entry><entry>Configuration block responder</entry></row><row><entry>snp 540</entry><entry>snoop</entry><entry>2</entry><entry>Snoop block</entry></row><row><entry>dwp 545</entry><entry>datawp</entry><entry>2</entry><entry>Data watchpoint</entry></row><row><entry>lsdp 550</entry><entry>lsdatapath</entry><entry>2</entry><entry>LSU datapath block</entry></row><row><entry>lspalgn 554</entry><entry></entry><entry>3</entry><entry>Align, (Sign/Zero) extend block</entry></row><row><entry align=\"center\" nameend=\"4\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>The lspipe block, lsp <b>510</b>, controls the load/store pipeline. This block coordinates and sequences all core memory accesses. lspipe <b>510</b> receives a data value for the current instruction via a path through the IFU <b>410</b> which utilizes the existing result bus in the main IMU <b>420</b> datapath. The lspipe block <b>510</b> handles the CPU pipeline aspects of the LSU unit. It is responsible for holding the required data at the start of the EX<b>1</b>, EX<b>2</b> and EX<b>3</b> stages of the pipeline and controls the stalling of CPU execution. In additional trace information is passed to the trace channel at the EX<b>4</b> (WB) stage.</p><p>The dcc block <b>515</b> is the main data cache controller block. It contains the FSMs which sequence operations on the data cache arrays to implement the various operations. It includes a FSM that receives requests from the lspipe/IFU to execute instructions. The FSM sequences the series of requests to the cache and drefill, etc. required to execute the instruction. Additionally, the dcc block <b>515</b> receives the cache requests from all other blocks (drefill <b>520</b>, snoop <b>540</b>, cfgrp <b>535</b>) and arbitrates between these and requests generated by a FSM to determine which resource access the cache in any given cycle</p><p>The drefill block, drf <b>520</b> on behalf of LSU <b>440</b> interfaces to the BIU <b>405</b> including, cache related cycles like cache line-fill, and non-cacheable memory accesses. The drf <b>520</b> can access the cache data array \u2018on demand\u2019 to perform write-back and fill activities. It contains buffering for 4 pending cache writes and address buffers for 2 BIU <b>405</b> accesses and 2 pending store buffer writes into the data array\u2014this enables stores to be fully pipelined.</p><p>The config request block, cfgrq <b>530</b>, handles the interface between the LSU and the configuration bus. The configuration bus provides the mechanism for the CPU to access configuration registers and cache/TLB state as well as allowing the debug controller to access the debug registers via the BIU <b>405</b>. The \u2018request\u2019 side, i.e., cfgrq block <b>530</b>, accepts configuration requests from either the lspipe <b>510</b> or drefill <b>520</b> blocks, and places these on the bus and waits for a response</p><p>Config responder block, cfgrp <b>535</b>, receives requests made by the config request block <b>530</b> for access to the data cache configuration space. The cfgrp <b>535</b> makes the relevant request to the dcc <b>515</b> and returns the result on the config bus.</p><p>The datawatchpoint block, dwp <b>545</b>, compares access addresses with the two data watchpoint ranges and signals any hit to the lspipe block <b>510</b>, which in turn determines whether a watchpoint and/or exception is triggered depended on control signals associated with that access received from the IFU <b>410</b>. The address ranges are setup via the configuration bus.</p><p>The snp block <b>540</b> is a block that receives snoop requests from the BIU <b>405</b> and then sequences through the locations in the cache where the supplied physical address could reside. If it finds a hit it will request the drf <b>520</b> to write back any dirty data, and if there was a write snoop request, it will then invalidate the line.</p><p>Load/store datapath block, lsdp <b>550</b>, includes the operations relating to 64 bit data in the main execution datapath. The data aligner, lsalgn <b>554</b>, is here along with the data elements of the store buffer <b>556</b>. Results are returned to the pipefile via a result bus which is shared with the IMU <b>420</b> E<b>3</b> stage. This path is also used to pass data from the datapath to the main LSU block through the IFU <b>410</b>.</p><p>The lspalgn block <b>554</b> is the byte alignment and sign/zero extension block. All memory operands go through this block. This block also supports little Endian mode and big Endian mode. This block <b>554</b> is part of lsdp <b>550</b> and handles the data alignment required for data load and store operations</p><p>In a specific embodiment the LSU may include a single aligner to perform the alignment rotates and sign/byte selection required for load and store operations, rather than having a separate rotator on each of the load and store paths. In a specific embodiment only a right rotator is used, since a left rotate of k bytes is equivalent to a right rotate of (8-k) bytes for a 64-bit architecture. In an alternative embodiment a bi-directional rotator is used. In both embodiments the two operations share the same resource to reduce area. The minor cost of this is that the alignment step of both load and store has to occur in the same pipeline stage to avoid resource hazards. This results in a store operation requiring 1 extra cycle before the data is stored into the cache. This extra cycle is hidden by pipelining and there is little effect on performance unless the code immediately requires reloading data that has just been stored. However, in this case a compiler should be able to reuse data from the original register.</p><p>The path which is of major concern in the LSU is that of data being read from the data array which then may be passed through the aligner/sign-extension logic <b>554</b> before being sent to the various forwarding points in the IMU <b>420</b> and pipefile. Since it is desirable to minimize the length of this path, the aligner <b>554</b> may be placed inside the IMU <b>420</b> datapath.</p><p>The LSU <b>440</b> may use 3 pipeline stages to access the cache:</p><p>1) E<b>1</b>: Address is calculated (handled by IMU on behalf of LSU).</p><p>2) E<b>2</b>: Virtual tag (vtag) comparison is made and, for load operations, data read.</p><p>3) E<b>3</b>: For loads, data selected on the basis of comparison results and is aligned and sign extended. For stores, data is aligned and sent to the pending store buffer, if data cannot be written immediately.</p><p>This behavior may be fully pipelined\u2014an instruction may be at each pipeline stage simultaneously and, assuming all accesses \u201chit\u201d using virtual tag (vtag) comparison, execute in one instruction per cycle.</p><p>For store operations where data enters the store buffer at the end of the E<b>3</b> stage, the data is yet to be written to the data array, however from a pipeline perspective the instruction is complete.</p><p>There is also an E<b>4</b>/WB stage in the lspipe block <b>510</b> that may be used to pass data to the trace channel and may not contribute to instruction execution.</p><p>The drefill block <b>520</b> contains a store buffer that contains upto 2 pending stores. The drefill <b>520</b> and dcc <b>515</b> may use \u2018free cycles\u2019 where the data array is not being otherwise accessed to write this data to the cache.</p><p>Memory operations that are received while stores are pending in this buffer are checked for address match\u2014if this following operation \u2018collides\u2019 with a pending store then it is stalled until the store has been written to the cache to ensure correct execution of load/store actions.</p><p>The dependency check between items in the store buffer and a subsequent memory access is done on the basis of the 64-bit word address (i.e. bits [<b>32</b>:<b>3</b>] of the address). This may be extended to include an upper/lower 32-bit word clash check to aid 32 bit software\u2014in this case a load from the opposite half of the 64-bit word to that in which there is a pending 32-bit store would be permitted to continue.</p><p>The LSU <b>440</b> may handle 2 outstanding BIU <b>405</b> (i.e. external memory) fill accesses (caused by prefetch instructions or cache misses) or non-cacheable loads. Additionally the LSU <b>440</b> provides buffering for write-back and stores.</p><p>Prefetch instructions do not block execution and execution resumes as soon as a line file and, if required, write back request, has been issued to the BIU <b>405</b>.</p><p>A Load miss may stall the pipeline until the critical word is received. Store may only stall the pipeline until the critical word has been written back (assuming writeback is required). At this point the pipeline will restart while the rest of the fill continues.</p><p>Further memory operations can occur while an outstanding request is still filling a line. If such a memory request causes a cache miss then a second fill request may be sent to the BIU. As with the first fill request, the cache is blocked from any access until the second fill request is acknowledged by the BIU. The CPU pipe is again stalled until the first critical word returns. Further memory request from CPU pipe may be accepted as long as they can be serviced from the cache. If a third miss occurs then this is blocked until the first fill completes.</p><p>The LSU controls a virtual cache. There may be problems inherent in a virtually tagged (vtag) cache due to synonyms\u2014data referenced by one virtual address may also be referenced by other synonymous virtual addresses. Thus the cache contains a separate record of the physical tag (ptag) for all data and this is used in conjunction with TLB translation to check for a synonym hit if the initial virtual tag based look up fails.</p><p>A software requirement is that for any two virtual address that map to the same object (i.e. physical address) then the virtual indexing map both to the same cache set. For 16 kB pages and above there may be no issue as no bit subject to address translation is used to index the cache. However, for 4 kB pages some index bits are subject to translation. Because of this it is necessary for software to ensure that all virtual addresses that map to the same physical address have the same values for bits [<b>13</b>:<b>12</b>]. This requirement may be needed for any cache (virtual or physical) that uses virtual indexing.</p><p>Due to the cache being based on virtual tagging then no reference needs to be made to the TLB in case of a (virtual tag) cache hit. Therefore, the virtual tag array also contains a copy of the page permission and other page based information from the appropriate TLB entry to enable access permissions etc. to be checked at the same time as the tag comparison. This ensures that any access violation is detected without the need to consult the TLB.</p><p>The LSU supports a full LRU replacement policy which can be augmented by control register bits which can \u2018lock\u2019 some of the cache ways (on a per cache basis). Data can be loaded into a locked way through a special mode of prefetch. Other than data update through store hit an entry in a locked way cannot be modified.</p><p>Data read into the CPU may have its bytes re-ordered so that they are arranged as a 64 bit quantity with, for example, the most significant byte in byte position <b>7</b> and the least significant byte in byte position <b>0</b>.</p><p>This ensures that all 64 bit data is in a consistent Endian-ness internally. Sub-word selection performed by the align/sign-extend block will take system Endian-ness into account and select the correct sub-word by xor-ing the bottom 3 bits of address used to select the data with the appropriate mask.</p><p>In a specific embodiment of the LSU works with cache sizes of 16 kB, 32 kB or 64 kB. Because of this the LSU takes into account all three cache sizes. For example, 9 bits will be passed as a set index which is required for a 64 kB cache; a 32 kB cache will ignore the most significant bit, while a 16 kB cache will ignore the 2 most significant bits. Similarly the tag passed for comparison may be based around the requirements for a 16 kB cache with redundant bits in the 32 kB and 64 kB cases. The set-based address clash detection may perform a 7 bit comparison to handle set clashes in a 16 kB cache which may report false clashes in 32 kB and 64 kB caches.</p><p>FIG. 9 illustrates the pipeline behavior for a load with a cache hit in a specific embodiment of the present invention. This assumes that there are no other load/store operations in the preceding or following instructions. Vtag comparison <b>604</b> is done in parallel with data extraction <b>606</b> and the match signals are used to select the correct data in the next cycle. Data is returned in 3 cycles causing a 2 instruction load/use penalty. This scheme shows the store buffer/fill clash checking <b>602</b> being done in E<b>2</b>. This ensures all information required to determine if a stall is required is available at the start of the E<b>3</b> stage. In E<b>3</b> the data, if necessary, is aligned.</p><p>An aliased hit occurs when there is a miss on the vtag comparison but when the subsequent ptag comparison (using the physical address translated by the DTLB) returns a hit. Again it is assumed that there are no load or store instructions in the preceding or following cycles. This sequence causes a 3 cycle pipeline stall while the initial vtag miss is handled.</p><p>The vtag line for the aliased hit should be updated to refer to the most recent alias (as locality of reference suggests that this is the must likely alias to be used next to refer to this data\u2014note that this update is not \u2018necessary\u2019 for correct behavior but should aid performance).</p><p>When the cache controller determines that there is both a vtag and ptag miss then a request is made to the drefill block <b>520</b> for a line refill. The drefill block <b>520</b> then controls the write-back and fill activities while the pipeline control part of the cache controller waits for the critical word to appear.</p><p>To avoid any danger of data to be written back from the cache being over-written by fill data before being written back it is important that the read for write-back happens in the 4 cycles following the burst read request\u2014this ensures no danger exists. In this specific embodiment this is not an issue as any fill request will take around 16 cycles to be serviced. In an alternative embodiment the dcc <b>515</b> may warn the drefill <b>520</b> block of the probability of an miss to allow the first read to be started speculatively.</p><p>During the cycle where the miss is detected (after the ptag comparison) the dcc state machine will move into a holding cycle if the drefill block is indicating that the fill request cannot be accepted. Note that the dcc needs to know if fill with writeback is required to determine this. The writeback is determined form the valid bit and the dirty state bit which may already have been read. The pipeline is stalled as soon as the vtag miss is detected. The dcc <b>515</b> holds the stall until it completes setting up the fill. For normal loads it then maintains the stall until critical word data is received.</p><p>FIG. 10 shows the pipeline behavior for a store with a cache hit in a specific embodiment of the present invention. When the cache hit is detected then store data (aligned to the correct alignment for the store along with byte-select values) is either written directly to the data array or placed into the store buffer depending on whether the data array is required for a following load or whether there already is data in the store buffer. If data is placed in the store buffer then it will be taken from there and written to the data array in the next available cycle (i.e. the next cycle in which no data array access occurs).</p><p>For the aliased hit the aligned data is sent to the store buffer instead of being send back to write-back as is the case for loads.</p><p>For the store miss the pipeline store waits until any writeback from the word where the data is to be stored has occurred and then sends data to the store buffer.</p><h4>An Example Byte Alignment and Sign-extension Block (lspalgn)</h4><p>A specific embodiment of the lspalgn block <b>554</b> does byte alignment and sign-extension operations on 8-byte data (64-bits) loaded from/stored to the cache to extract valid byte parts that corresponds to the final result of a Load-Store instruction. As this block forms part of a critical timing path it is a special datapath block and thus is separated out from the rest of the lspipe <b>510</b>. However some of the control logic remains in the lspipe and passes control signals to the datapath a cycle ahead of when they are needed.</p><p>FIG. 11 illustrates a simplified block diagram of the align and sign extension block, lsalgn <b>554</b>. In FIG. 11 the Byte selection Decoder <b>652</b> determines which bytes in the destination 8 byte word are updated by a store. For example, a store of a byte to the 3rd byte in the word would yield a byte select mask of 0000100. The inputs to the Decoder <b>652</b> are: s<b>5</b>_littleendian <b>654</b> which is <b>1</b> for a little Endian system; lsp_opc_ex<b>2</b>[<b>3</b>:<b>0</b>], which comes from lspipe <b>510</b> and is the opcode of the instruction in the E<b>2</b>; and lsp_addr_ex<b>2</b>[<b>2</b>:<b>0</b>] <b>658</b> which is the address of the highest/lowest byte of the bytes that are to be rotated in a 8 byte part. The input data arrives through a selector <b>676</b> which chooses the 64-bit data from either the lsp <b>510</b>, lsp_algh_data <b>672</b> or from the DCU <b>450</b>, i.e., dcu_lsu_ddata <b>674</b>. The selected data, lspalgn_data <b>678</b>, goes into a Back-phase rotator <b>670</b>. The rotation is controlled by bits rc[<b>1</b>:<b>0</b>] <b>668</b> which come from the Rotate Distance Controller <b>662</b>. The Rotate Distance Controller <b>662</b> sends lsp_dodd_ex<b>2</b><b>664</b> and lsp_dodd_ex<b>2</b><b>666</b> to the DCU <b>450</b>, which is then multiplexed to select the lsu_dcu_dodd signal. This signal provides rc[<b>3</b>]. For the typical case, where the vtag and data array are read in the E<b>2</b> phase, then it is lsp_dodd_ex<b>2</b> that is used. However, if there is a vtag miss and then a ptag hit then the data array is read a second time (to read the data selected by the ptag hit) and now the instruction is in the E3 stage so the lsp_dodd_ex<b>3</b> signal would be selected. Similarly if there was a cache miss then when the data returned from the BIU, the lsp_dodd_ex<b>3</b> signal would be used to perform first stage of rotation that is needed before the main rotate block on that path to match the stage that is in the data from the cache path</p><p>The output of the rotator <b>670</b> is lsp_ddata_ex<b>3</b><b>686</b> and for a store operation, represents the bytes to be stored, i.e., the Sign Ext. block <b>690</b> is a pass through. No sign or zero extension is needed for store. For a load instruction Sign (zero) extension <b>690</b> is performed on lsp_ddata_ex<b>3</b><b>686</b> depending on the value of lspalgn_signbit <b>684</b> from the sign selection block <b>680</b>.</p><p>The Sign Selection block <b>680</b> produces the sign bit <b>684</b> for the muxes in the sign/zero extend block <b>690</b>. There is an input lsp_type_ex<b>2</b><b>682</b> into block <b>680</b>, which gives the type as one of signed/unsigned byte, signed/unsigned (16 bit) word, signed/unsigned (32 bit) long word or (64 bit) quadword. The Sign Selection block <b>680</b> determines the sign bit of the result (from the sign bits of the bytes in the data and the result size), and the Sign/zero Extend block <b>690</b>, on a per byte basis, selects whether the result in that byte position comes from either: 1) the byte from the rotate output <b>686</b>, 2) sign extension byte <b>684</b> (determined by the sign bit), or 3) 0 byte <b>688</b>, i.e., <b>8</b>b\u2032<b>0</b>, (for zero extension). An example of the use of the 0 byte is for a unaligned 32 bit load of the upper part of a long word, e.g., byte H, where the lower 3 bytes are <b>0</b>. If the word at that address is ABCDEFGH then the rotated output will be DEFGHABC (as the H from position <b>0</b> has been moved to the correct place in the result 32 bit word). The sign selection block produces controls to the sign/zero extension so that bytes <b>7</b>-<b>4</b> are selected by the sign bit of H. Byte <b>3</b> is the result from the rotator (i.e. H) and bytes <b>2</b>-<b>0</b> are <b>0</b>. I.e. the result is SSSSH000 where S is the sign extension of H.</p><p>FIG. 12 shows a specific embodiment of a 8 byte Right Rotator <b>800</b> of the present invention. The input is 8 bytes in Little Endian format with each byte put in a latch: in_data<b>7</b><b>802</b> downto latch in_data<b>0</b><b>804</b>. The byte <b>0</b> in latch in_data<b>0</b><b>804</b> is from bit <b>7</b> downto bit <b>0</b>; byte <b>7</b> in latch in_data<b>7</b><b>802</b> is from bit <b>63</b> to bit <b>55</b> and so on. The rc[<b>2</b>:<b>0</b>] <b>850</b>, <b>852</b>, and <b>854</b>, are the rotate distance control signals. The path for data from the most significant word <b>802</b> in the cached data to the rotated data output, o_data latches <b>860</b>, is shown in bold lines to demonstrate how each byte in the input can be switched to any output byte. For example, the output <b>810</b> of in_data<b>7</b><b>802</b> is split to goto multiplexers <b>814</b> and <b>812</b> in the first stage <b>801</b> (DCU). The output of mux <b>814</b> is then split into muxs <b>816</b> and <b>818</b> (in the Back-Phase Rotator <b>660</b>). Or, depending on the select signal rc[<b>2</b>] <b>850</b>, the output <b>810</b> of may be split by mux <b>812</b> in the DCU <b>801</b> to muxes <b>820</b> and <b>822</b> in the Back-Phase Rotator <b>660</b> (LSU). The muxes <b>816</b> and <b>818</b> are controlled by rc[<b>1</b>] <b>852</b>. The output of mux <b>816</b> may go to muxes <b>824</b> and <b>826</b>, and depending on the select signal rc[<b>0</b>] <b>854</b>, the input data byte <b>802</b> may go to latches o_data<b>7</b><b>862</b> or o_data<b>6</b><b>864</b>.</p><p>In a specific embodiment, for timing reason, the 8-byte rotator may be split into front-phase rotator <b>801</b>, which rotates the double word input data in DCU <b>450</b>, and back-phase rotator <b>660</b>, which does byte and word rotates in LSU <b>440</b>. In an alternative embodiment the 8-byte rotator is not split, but included in the front phase rotator <b>801</b>. In another embodiment the 8-byte rotator is not split, but included in the back phase rotator <b>670</b>. The input data of the rotator is [7,6,5,4,3,2,1,0] which means the order is byte<b>7</b>, byte<b>6</b>, byte<b>5</b> . . . etc. For example, rc[<b>2</b>:<b>0</b>] is <b>3</b>\u2032b<b>010</b> which makes in_data[<b>63</b>:<b>0</b>] rotate rightward for 2 bytes. The result is [1,0,7,6,5,4,3,2] which means in_data byte <b>1</b> rotate to MSB and in_data byte <b>2</b> rotate to LSB. The possible rotations are shown in Table 6.</p><p><tables id=\"TABLE-US-00009\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"offset\" colwidth=\"42pt\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"63pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"112pt\"></colspec><thead><row><entry></entry><entry nameend=\"2\" namest=\"offset\" rowsep=\"1\">TABLE 6</entry></row><row><entry></entry><entry align=\"center\" nameend=\"2\" namest=\"offset\" rowsep=\"1\"></entry></row><row><entry></entry><entry>rc[2:0]</entry><entry>o_datat[byte]</entry></row><row><entry></entry><entry align=\"center\" nameend=\"2\" namest=\"offset\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry><entry>3\u2032b000</entry><entry>[7, 6, 5, 4, 3, 2, 1, 0]</entry></row><row><entry></entry><entry>3\u2032b001</entry><entry>[0, 7, 6, 5, 4, 3, 2, 1]</entry></row><row><entry></entry><entry>3\u2032b010</entry><entry>[1, 0, 7, 6, 5, 4, 3, 2]</entry></row><row><entry></entry><entry>3\u2032b011</entry><entry>[2, 1, 0, 7, 6, 5, 4, 3]</entry></row><row><entry></entry><entry>3\u2032b100</entry><entry>[3, 2, 1, 0, 7, 6, 5, 4]</entry></row><row><entry></entry><entry>3\u2032b101</entry><entry>[4, 3, 2, 1, 0, 7, 6, 5]</entry></row><row><entry></entry><entry>3\u2032b110</entry><entry>[5, 4, 3, 2, 1, 0, 7, 6]</entry></row><row><entry></entry><entry>3\u2032b111</entry><entry>[6, 5, 4, 3, 2, 1, 0, 7]</entry></row><row><entry></entry><entry align=\"center\" nameend=\"2\" namest=\"offset\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>FIG. 13 shows an example of how a 4-byte unaligned word load instruction achieves alignment in different Endianness. In Little Endian order <b>905</b>, there are 4 data bytes (<b>1</b>,<b>2</b>,<b>3</b>,<b>4</b>) between addresses <b>110</b> and <b>011</b> in memory <b>910</b>. This data is mirrored in cache <b>912</b> (<b>1</b>,<b>2</b>,<b>3</b>,<b>4</b>). The low part of the data <b>914</b> (<b>4</b>) rotates 3 bytes toward the right <b>916</b> and the high part of the data <b>918</b> (<b>1</b>,<b>2</b>,<b>3</b>) rotates 3 bytes toward the right <b>920</b>. The result is an aligned long word in Register <b>922</b>. In the Big Endian order <b>930</b>, in this specific embodiment the data is stored in the cache <b>934</b> in Little Endian order. The low part <b>935</b> rotates 1 byte toward the right <b>936</b> and high part <b>938</b> rotates 1 bytes toward the right <b>940</b>. The detailed rotate distances of different Endianness for 8-byte and 4-byte loads are shown in Table 7 and Table 8. The rotate distances control rc[<b>1</b>:<b>0</b>] in the 4-byte case are analogous to the 8-byte case with the back-phase rotator in the LSU.</p><p><tables id=\"TABLE-US-00010\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 7</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Right rotate distance for unaligned 8-byte load instruction</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"49pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"4\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"5\" colwidth=\"42pt\"></colspec><tbody valign=\"top\"><row><entry>lsp_addr_ex2</entry><entry>Low Part</entry><entry>High Part</entry><entry></entry><entry></entry></row><row><entry>[2:0]</entry><entry>(Little</entry><entry>(Little</entry><entry>Low Part</entry><entry>High Part</entry></row><row><entry>(In Memory)</entry><entry>Endian)</entry><entry>Endian)</entry><entry>(Big Endian)</entry><entry>(Big Endian)</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>000</entry><entry>0</entry><entry>1</entry><entry>0</entry><entry>7</entry></row><row><entry>001</entry><entry>1</entry><entry>2</entry><entry>7</entry><entry>6</entry></row><row><entry>010</entry><entry>2</entry><entry>3</entry><entry>6</entry><entry>5</entry></row><row><entry>011</entry><entry>3</entry><entry>4</entry><entry>5</entry><entry>4</entry></row><row><entry>100</entry><entry>4</entry><entry>5</entry><entry>4</entry><entry>3</entry></row><row><entry>101</entry><entry>5</entry><entry>6</entry><entry>3</entry><entry>2</entry></row><row><entry>110</entry><entry>6</entry><entry>7</entry><entry>2</entry><entry>1</entry></row><row><entry>111</entry><entry>7</entry><entry>0</entry><entry>1</entry><entry>0</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p><tables id=\"TABLE-US-00011\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 8</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Right rotate distance for unaligned 4-byte load instruction</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"49pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"4\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"5\" colwidth=\"42pt\"></colspec><tbody valign=\"top\"><row><entry>lsp_addr_ex2</entry><entry>Low Part</entry><entry>High Part</entry><entry></entry><entry></entry></row><row><entry>[2:0]</entry><entry>(Little</entry><entry>(Little</entry><entry>Low Part</entry><entry>High Part</entry></row><row><entry>(In Memory)</entry><entry>Endian)</entry><entry>Endian)</entry><entry>(Big Endian)</entry><entry>(Big Endian)</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>000</entry><entry>0</entry><entry>5</entry><entry>4</entry><entry>7</entry></row><row><entry>001</entry><entry>1</entry><entry>6</entry><entry>3</entry><entry>6</entry></row><row><entry>010</entry><entry>2</entry><entry>7</entry><entry>2</entry><entry>5</entry></row><row><entry>011</entry><entry>3</entry><entry>0</entry><entry>1</entry><entry>4</entry></row><row><entry>100</entry><entry>4</entry><entry>1</entry><entry>0</entry><entry>3</entry></row><row><entry>101</entry><entry>5</entry><entry>2</entry><entry>7</entry><entry>2</entry></row><row><entry>110</entry><entry>6</entry><entry>3</entry><entry>6</entry><entry>1</entry></row><row><entry>111</entry><entry>7</entry><entry>4</entry><entry>5</entry><entry>0</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>FIG. 14 shows an example of alignment of a 4-byte unaligned store instruction in different Endianness. The 4 bytes of data (<b>1</b>,<b>2</b>,<b>3</b>,<b>4</b>) are shown in register <b>951</b>. In Little Endian order <b>950</b>, the low part of data (<b>4</b>) <b>952</b> rotates <b>5</b> toward the right <b>954</b> and the high part (<b>1</b>,<b>2</b>,<b>3</b>) rotates <b>5</b> toward the right. Then with the introduction of the byte enable signal lsp_dbsel_ex<b>3</b> the valid data is kept, i.e., written to cache <b>960</b> and to memory <b>962</b> at addresses <b>110</b> downto <b>011</b>. In the Big Endian order <b>970</b>, the low part rotates <b>7</b> toward the right <b>974</b> and the high part rotates 7 toward the right <b>978</b>, then the lsp_dbsel_ex<b>3</b> allows storage of the valid data. The detailed rotate distances of different Endianness for 8-byte, 4-byte stores are shown in Table 9 and Table 10.</p><p><tables id=\"TABLE-US-00012\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 9</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Right rotate distance for unaligned 8-byte store instruction</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"49pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"4\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"5\" colwidth=\"42pt\"></colspec><tbody valign=\"top\"><row><entry>lsp_addr_ex2</entry><entry>Low Part</entry><entry>High Part</entry><entry></entry><entry></entry></row><row><entry>[2:0]</entry><entry>(Little</entry><entry>(Little</entry><entry>Low Part</entry><entry>High Part</entry></row><row><entry>(In Memory)</entry><entry>Endian)</entry><entry>Endian)</entry><entry>(Big Endian)</entry><entry>(Big Endian)</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>000</entry><entry>0</entry><entry>7</entry><entry>0</entry><entry>1</entry></row><row><entry>001</entry><entry>7</entry><entry>6</entry><entry>1</entry><entry>2</entry></row><row><entry>010</entry><entry>6</entry><entry>5</entry><entry>2</entry><entry>3</entry></row><row><entry>011</entry><entry>5</entry><entry>4</entry><entry>3</entry><entry>4</entry></row><row><entry>100</entry><entry>4</entry><entry>3</entry><entry>4</entry><entry>5</entry></row><row><entry>101</entry><entry>3</entry><entry>2</entry><entry>5</entry><entry>6</entry></row><row><entry>110</entry><entry>2</entry><entry>1</entry><entry>6</entry><entry>7</entry></row><row><entry>111</entry><entry>1</entry><entry>0</entry><entry>7</entry><entry>0</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p><tables id=\"TABLE-US-00013\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 10</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Right rotate distance for unaligned 4-byte store instruction</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"49pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"4\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"5\" colwidth=\"42pt\"></colspec><tbody valign=\"top\"><row><entry>lsp_addr_ex2</entry><entry>Low Part</entry><entry>High Part</entry><entry></entry><entry></entry></row><row><entry>[2:0]</entry><entry>(Little</entry><entry>(Little</entry><entry>Low Part</entry><entry>High Part</entry></row><row><entry>(In Memory)</entry><entry>Endian)</entry><entry>Endian)</entry><entry>(Big Endian)</entry><entry>(Big Endian)</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>000</entry><entry>0</entry><entry>3</entry><entry>4</entry><entry>1</entry></row><row><entry>001</entry><entry>7</entry><entry>2</entry><entry>5</entry><entry>2</entry></row><row><entry>010</entry><entry>6</entry><entry>1</entry><entry>6</entry><entry>3</entry></row><row><entry>011</entry><entry>5</entry><entry>0</entry><entry>7</entry><entry>4</entry></row><row><entry>100</entry><entry>4</entry><entry>7</entry><entry>0</entry><entry>5</entry></row><row><entry>101</entry><entry>3</entry><entry>6</entry><entry>1</entry><entry>6</entry></row><row><entry>110</entry><entry>2</entry><entry>5</entry><entry>2</entry><entry>7</entry></row><row><entry>111</entry><entry>1</entry><entry>4</entry><entry>3</entry><entry>0</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>The byte selection for 4-byte, 2-byte, and 1-byte store instructions are in Table 11, Table 12, and Table 13 below.</p><p><tables id=\"TABLE-US-00014\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 11</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Byte selection for 4-byte store instruction</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"5\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"49pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"4\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"5\" colwidth=\"42pt\"></colspec><tbody valign=\"top\"><row><entry>lsp_addr_ex2</entry><entry>Low Part</entry><entry>High Part</entry><entry></entry><entry></entry></row><row><entry>[2:0]</entry><entry>(Little</entry><entry>(Little</entry><entry>Low Part</entry><entry>High Part</entry></row><row><entry>(In Memory)</entry><entry>Endian)</entry><entry>Endian)</entry><entry>(Big Endian)</entry><entry>(Big Endian)</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>000</entry><entry>00001111</entry><entry>00000001</entry><entry>11110000</entry><entry>10000000</entry></row><row><entry>001</entry><entry>00001110</entry><entry>00000011</entry><entry>01110000</entry><entry>11000000</entry></row><row><entry>010</entry><entry>00001100</entry><entry>00000111</entry><entry>00110000</entry><entry>11100000</entry></row><row><entry>011</entry><entry>00001000</entry><entry>00001111</entry><entry>00010000</entry><entry>11110000</entry></row><row><entry>100</entry><entry>11110000</entry><entry>00010000</entry><entry>00001111</entry><entry>00001000</entry></row><row><entry>101</entry><entry>11100000</entry><entry>00110000</entry><entry>00000111</entry><entry>00001100</entry></row><row><entry>110</entry><entry>11000000</entry><entry>01110000</entry><entry>00000011</entry><entry>00001110</entry></row><row><entry>111</entry><entry>10000000</entry><entry>11110000</entry><entry>00000001</entry><entry>00001111</entry></row><row><entry align=\"center\" nameend=\"5\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p><tables id=\"TABLE-US-00015\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 12</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Byte selection for 2-byte store instruction</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"98pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"77pt\"></colspec><tbody valign=\"top\"><row><entry>lsp_addr_ex2 [2:0]</entry><entry></entry><entry></entry></row><row><entry>(In Memory)</entry><entry>Little Endian</entry><entry>Big Endian</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>000</entry><entry>00000011</entry><entry>11000000</entry></row><row><entry>010</entry><entry>00001100</entry><entry>00110000</entry></row><row><entry>100</entry><entry>00110000</entry><entry>00001100</entry></row><row><entry>110</entry><entry>11000000</entry><entry>00000011</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p><tables id=\"TABLE-US-00016\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 13</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Byte selection for 1-byte store instruction</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"98pt\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"42pt\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"77pt\"></colspec><tbody valign=\"top\"><row><entry>lsp_addr_ex2 [2:0]</entry><entry></entry><entry></entry></row><row><entry>(In Memory)</entry><entry>Little Endian</entry><entry>Big Endian</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>000</entry><entry>00000001</entry><entry>10000000</entry></row><row><entry>001</entry><entry>00000010</entry><entry>01000000</entry></row><row><entry>010</entry><entry>00000100</entry><entry>00100000</entry></row><row><entry>011</entry><entry>00001000</entry><entry>00010000</entry></row><row><entry>100</entry><entry>00010000</entry><entry>00001000</entry></row><row><entry>101</entry><entry>00100000</entry><entry>00000100</entry></row><row><entry>110</entry><entry>01000000</entry><entry>00000010</entry></row><row><entry>111</entry><entry>10000000</entry><entry>00000001</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>In a specific embodiment sign extension or zero extension is the step following the byte-rotating operation for the load instruction. There is no need to do the extension for store instructions because the store width is based on the instruction instead of the 8-byte width. The mask signal is for masking valid bytes of unaligned data with load instruction, then the size is used to determine if the result in a given byte position is taken from sign/zero extension or from the rotated output. These signals are used to select the inputs of mux of producing the lsu_result_ex<b>3</b>. A unaligned 4-byte load which produces the lower order bytes (LDLO in little Endian mode and LDHI in big Endian) always zero extends. For unaligned 4-byte store, the sign bit is located at the offset address of the load-high instruction for Little Endian and at the offset address of the load-low instruction for Big Endian.</p><p>FIG. 15 illustrates a simplified block diagram of the Sign Selection block <b>680</b> of the present invention. FIG. 15 shows how the lspalgn_signbit <b>684</b> is determined from the operation, address and endianness in a specific embodiment. The inputs to block <b>1012</b> generate a select signal, sel[<b>2</b>:<b>0</b>], <b>1016</b> which controls a 8-to-1 mux <b>1020</b> on the signbits (<b>63</b>, <b>55</b>, <b>47</b>, <b>39</b>, <b>31</b>, <b>23</b>, <b>15</b>, <b>7</b>) from the input word, lspalgn_data. Note if the result type is unsigned, a signbit <b>684</b> of 0 is returned.</p><p>FIG. 16 illustrates a simplified block diagram of the Sign (zero) Extension Block <b>690</b> of the present invention. FIG. 16 shows how each byte in the output is selected in a mux (<b>1030</b>, <b>1032</b>, <b>1034</b>, <b>1036</b>) from \u201c0\u201d <b>688</b>, rotate output <b>686</b> or signbit <b>684</b>, depending on the size, e.g. size[<b>2</b>:<b>0</b>] <b>1042</b>, the mask (for unaligned loads), e.g., mask[<b>1</b>] <b>1040</b>, and opcode (the signal lsp_opc_ex<b>3</b>, although not shown is an input to each control block <b>1040</b>, <b>1042</b>, <b>1044</b>, and <b>1046</b>). The size array is an encoding:</p><p>'define LSU_SIZE_<b>8</b><b>3</b>\u2032b<b>111</b></p><p>'define LSU_SIZE_<b>4</b><b>3</b>\u2032b<b>011</b></p><p>'define LSU_SIZE_<b>2</b><b>3</b>\u2032b<b>001</b></p><p>'define LSU_SIZE_<b>1</b><b>3</b>\u2032b<b>000</b></p><p>where LSU_SIZE_n is the encoding of data of size n bytes. The mask is used to mask the rotate output <b>686</b> (on a per byte basis), so that for unaligned loads, bytes below the lowest byte read are masked to \u201c0\u201d. This masking is merged in the same step as the sign/zero extension <b>690</b>.</p><h4>Conclusion</h4><p>In the foregoing specification, the invention has been described with reference to specific exemplary embodiments thereof. Other embodiments will be apparent to those of ordinary skill in the art. For example, the instructions may be 16 or 64 bits in length and the microprocessor may operate with 8, 16, 32, or 128 bit busses and words. Thus it is evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the appended claims and their full scope of equivalents.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "David E.", "last_name": "Shepherd", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "HITACHI, LTD."}, {"first_name": "", "last_name": "RENESAS ELECTRONICS CORPORATION", "name": ""}, {"first_name": "", "last_name": "RENESAS TECHNOLOGY CORPORATION", "name": ""}, {"first_name": "", "last_name": "HITACHI LTD.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/315"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/315       20060101ALI20051220RMJP"}, {"label": "G06F  12/00        20060101A I20051110RMEP"}, {"label": "G06F  12/04        20060101ALI20051220RMJP"}, {"label": "G06F   9/34        20060101AFI20051220RMJP"}, {"label": "G06F   9/38        20060101A I20080531RMEP"}, {"label": "G06F   9/312       20060101A I20080531RMEP"}], "national_classes": [{"primary": true, "label": "712300"}, {"primary": false, "label": "712225"}, {"primary": false, "label": "712E09047"}, {"primary": false, "label": "712E09034"}, {"primary": false, "label": "711201"}, {"primary": false, "label": "712E09033"}], "ecla_classes": [{"label": "G06F   9/30A2L"}, {"label": "G06F   9/30A1M"}, {"label": "G06F   9/38B9"}, {"label": "G06F   9/38D2"}], "cpc_classes": [{"label": "G06F   9/3816"}, {"label": "G06F   9/30189"}, {"label": "G06F   9/30032"}, {"label": "G06F   9/383"}, {"label": "G06F   9/30043"}, {"label": "G06F   9/30"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1999-10-01", "application_date": "1999-10-01", "family_members": [{"ucid": "US-20050071583-A1", "titles": [{"lang": "EN", "text": "Aligning load/store data with big/little endian determined rotation distance control"}]}, {"ucid": "JP-2001142776-A", "titles": [{"lang": "JA", "text": "\u30c7\u30fc\u30bf\u3092\u30ed\u30fc\u30c9\u3059\u308b\u65b9\u6cd5\u53ca\u3073\u30c7\u30fc\u30bf\u3092\u30b9\u30c8\u30a2\u3059\u308b\u65b9\u6cd5"}, {"lang": "EN", "text": "METHOD FOR LOADING DATA AND METHOD FOR STORING DATA"}]}, {"ucid": "KR-20010050793-A", "titles": [{"lang": "KO", "text": "\ucef4\ud4e8\ud130 \uc2dc\uc2a4\ud15c\uc5d0\uc11c \ub370\uc774\ud0c0\ub97c \ub85c\ub529\ud558\uace0 \uc800\uc7a5\ud558\uae30 \uc704\ud55c \ubc29\ubc95"}, {"lang": "EN", "text": "A METHOD FOR LOADING AND STORING DATA IN A COMPUTER SYSTEM"}]}, {"ucid": "US-7254699-B2", "titles": [{"lang": "EN", "text": "Aligning load/store data using rotate, mask, zero/sign-extend and or operation"}]}, {"ucid": "US-6820195-B1", "titles": [{"lang": "EN", "text": "Aligning load/store data with big/little endian determined rotation distance control"}]}, {"ucid": "TW-497034-B", "titles": [{"lang": "EN", "text": "A method for loading and storing data in a computer system"}]}]}