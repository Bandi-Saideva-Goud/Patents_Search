{"patent_number": "US-6625693-B2", "publication_id": 73552721, "family_id": 23176248, "publication_date": "2003-09-23", "titles": [{"lang": "EN", "text": "Fast exception processing"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50553308\"><p>Fast exception processing is disclosed. In one embodiment, a system includes a splice cache, an exception logic, and an instrumentation mechanism. The splice cache contains one or more lightweight handlers. The exception logic is coupled to the splice cache and determines whether the corresponding lightweight handler for an exception is located in the splice cache. The instrumentation mechanism is coupled to the splice cache. The instrumentation mechanism inserts the lightweight handler into an execution stream.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00001\" num=\"1\"><claim-text>1. A method of operating a data processor, comprising:</claim-text><claim-text>executing instructions of an application program at least partly from a writable cache loaded from a memory; </claim-text><claim-text>loading some of a plurality of exception handlers to the writable cache according to a dynamic criterion that is independent of a criterion for loading the application program instructions; </claim-text><claim-text>receiving an indication of an exception; </claim-text><claim-text>executing one exception handler associated with the exception from the writable cache if the associated exception handler is loaded in the cache. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00002\" num=\"2\"><claim-text>2. The method of <claim-ref idref=\"US-6625693-B2-CLM-00001\">claim 1</claim-ref> further comprising calling an operating system to execute the associated exception handler if it is not loaded in the writable cache.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00003\" num=\"3\"><claim-text>3. The method of <claim-ref idref=\"US-6625693-B2-CLM-00001\">claim 1</claim-ref> where the exception handlers are loaded into an instruction cache for the application program.</claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00004\" num=\"4\"><claim-text>4. The method of <claim-ref idref=\"US-6625693-B2-CLM-00003\">claim 3</claim-ref> where instructions of the exception handler carry an identifying designation in the writable cache.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00005\" num=\"5\"><claim-text>5. The method of <claim-ref idref=\"US-6625693-B2-CLM-00001\">claim 1</claim-ref> where the exception handlers are loaded separately from an instruction cache for the application program.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00006\" num=\"6\"><claim-text>6. The method of <claim-ref idref=\"US-6625693-B2-CLM-00001\">claim 1</claim-ref> where the criterion is selected by a user.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00007\" num=\"7\"><claim-text>7. The method of <claim-ref idref=\"US-6625693-B2-CLM-00001\">claim 1</claim-ref> where the criterion is selected by the application program.</claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00008\" num=\"8\"><claim-text>8. The method of <claim-ref idref=\"US-6625693-B2-CLM-00001\">claim 1</claim-ref> further comprising tracking the occurrence of exceptions, and where the criterion is to load handlers associated with the most frequently occurring exceptions.</claim-text></claim>"}, {"num": 9, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00009\" num=\"9\"><claim-text>9. The method of <claim-ref idref=\"US-6625693-B2-CLM-00001\">claim 1</claim-ref> where the application program instructions and the one exception handler are both executed from the same pipeline of the processor.</claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00010\" num=\"10\"><claim-text>10. The method of <claim-ref idref=\"US-6625693-B2-CLM-00009\">claim 9</claim-ref> where the exception handler is executed without flushing the application programs from the pipeline.</claim-text></claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00011\" num=\"11\"><claim-text>11. A computer system comprising:</claim-text><claim-text>a processor to execute an application program and a plurality of exception handlers associated with a plurality of different exception signals; </claim-text><claim-text>a writable cache to store both portions of the application program and some but not all of the exception handlers simultaneously; </claim-text><claim-text>a determiner to load certain of the handlers into the writable cache according to a dynamic criterion that is independent of a criterion to load the application program portions in the writable cache; </claim-text><claim-text>an instrumentation mechanism responsive to the exception signals to execute the associated exception handlers directly from the writable cache, when the associated handlers are in the writable cache. </claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00012\" num=\"12\"><claim-text>12. The system of <claim-ref idref=\"US-6625693-B2-CLM-00011\">claim 11</claim-ref> where the writable cache is an instruction cache to store both the instruction application program portions and the certain handlers.</claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00013\" num=\"13\"><claim-text>13. The system of <claim-ref idref=\"US-6625693-B2-CLM-00012\">claim 12</claim-ref> where the certain handlers carry indicia differentiating them in the instruction cache from the application program portions.</claim-text></claim>"}, {"num": 14, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00014\" num=\"14\"><claim-text>14. The system of <claim-ref idref=\"US-6625693-B2-CLM-00011\">claim 11</claim-ref> where the certain handlers and the application program portions are separate from each other in the writable cache.</claim-text></claim>"}, {"num": 15, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00015\" num=\"15\"><claim-text>15. The system of <claim-ref idref=\"US-6625693-B2-CLM-00011\">claim 11</claim-ref> where the criterion is selected by a user.</claim-text></claim>"}, {"num": 16, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00016\" num=\"16\"><claim-text>16. The system of <claim-ref idref=\"US-6625693-B2-CLM-00011\">claim 11</claim-ref> where the criterion is selected by the application program.</claim-text></claim>"}, {"num": 17, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00017\" num=\"17\"><claim-text>17. The system of <claim-ref idref=\"US-6625693-B2-CLM-00011\">claim 11</claim-ref> further comprising a logic unit to track exception, and where the criterion is to load handlers associated with the most frequently occurring exceptions.</claim-text></claim>"}, {"num": 18, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00018\" num=\"18\"><claim-text>18. The system of <claim-ref idref=\"US-6625693-B2-CLM-00011\">claim 11</claim-ref> where the processor has a pipeline to contain both portions of the application and the certain handlers, and where the instrumentation mechanism loads the associated handlers from the writable cache directly into the pipeline without flushing the pipeline.</claim-text></claim>"}, {"num": 19, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00019\" num=\"19\"><claim-text>19. A method of operating a data processor, comprising:</claim-text><claim-text>loading instructions of an application program from a writable cache to a pipeline of the processor according to a first criterion; </claim-text><claim-text>loading instructions of some of a plurality of exception handlers according to a dynamic criterion to the writable cache according to a second criterion that is independent of the first criterion; </claim-text><claim-text>receiving an indication of one of a plurality of exceptions; </claim-text><claim-text>determining whether one of the handlers associated with the one exception is loaded in the cache; </claim-text><claim-text>if so, loading at least one instruction of the associated handler from the writable cache directly to the same pipeline without flushing the application program instructions from the pipeline. </claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00020\" num=\"20\"><claim-text>20. The method of <claim-ref idref=\"US-6625693-B2-CLM-00019\">claim 19</claim-ref> further comprising stalling the pipeline while loading the at least one handler instruction into the pipeline.</claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00021\" num=\"21\"><claim-text>21. The method of <claim-ref idref=\"US-6625693-B2-CLM-00020\">claim 20</claim-ref> where all the application program instructions in the pipeline at the time of receiving the exception signal remain in the pipeline when the at least one handler instruction is loaded thereinto.</claim-text></claim>"}, {"num": 22, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00022\" num=\"22\"><claim-text>22. A computer system comprising:</claim-text><claim-text>a processor to produce a plurality of different exception signals; </claim-text><claim-text>a writable cache to store instructions of an application program loaded according to a first criterion; </claim-text><claim-text>a plurality of exception handlers associated with respective ones of the exception signals; </claim-text><claim-text>a determiner to load certain of the handlers into the writable cache according to a dynamic criterion that is independent of the first criterion; </claim-text><claim-text>a pipeline having multiple stages to execute both the application program instructions and the exception handlers; </claim-text><claim-text>an instrumentation mechanism responsive to the exception signals to load the associated handlers from the writable cache directly into the pipeline without flushing the pipeline, when the associated handlers are loaded in the writable cache. </claim-text></claim>"}, {"num": 23, "parent": 22, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00023\" num=\"23\"><claim-text>23. The system of <claim-ref idref=\"US-6625693-B2-CLM-00022\">claim 22</claim-ref> further comprising exception logic to determine when the associated handlers are loaded in the writable cache.</claim-text></claim>"}, {"num": 24, "parent": 22, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00024\" num=\"24\"><claim-text>24. The system of <claim-ref idref=\"US-6625693-B2-CLM-00022\">claim 22</claim-ref> where the instrumentation logic includes selection logic to select either a previous stage in the pipeline or the writable cache.</claim-text></claim>"}, {"num": 25, "parent": 22, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00025\" num=\"25\"><claim-text>25. The system of <claim-ref idref=\"US-6625693-B2-CLM-00022\">claim 22</claim-ref> where the instrumentation mechanism stalls the pipeline in response to the exception signals.</claim-text></claim>"}, {"num": 26, "parent": 22, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00026\" num=\"26\"><claim-text>26. The system of <claim-ref idref=\"US-6625693-B2-CLM-00022\">claim 22</claim-ref> where the pipeline is a pool.</claim-text></claim>"}, {"num": 27, "parent": 22, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00027\" num=\"27\"><claim-text>27. The system of <claim-ref idref=\"US-6625693-B2-CLM-00022\">claim 22</claim-ref> where the pipeline is a queue.</claim-text></claim>"}, {"num": 28, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00028\" num=\"28\"><claim-text>28. A computer system comprising:</claim-text><claim-text>at least one interface; </claim-text><claim-text>at least one memory; </claim-text><claim-text>a processor to execute an application program and a plurality of exception handlers associated with a plurality of different exception signals; </claim-text><claim-text>a writable cache to store both portions of the application program and some but not all of the exception handlers simultaneously; </claim-text><claim-text>a determiner to exchange certain of the handlers into the writable cache according to a dynamic criterion that is independent of the application program portions in the writable cache; </claim-text><claim-text>a pipeline having multiple stages to execute both instructions of the application program and the exception handlers; </claim-text><claim-text>an instrumentation mechanism responsive to the exception signals to load the associated handlers from the writable cache directly into the pipeline without flushing the pipeline, when the associated handlers are loaded in the writable cache; </claim-text><claim-text>a bus coupling the interface, the memory, and the processor. </claim-text></claim>"}, {"num": 29, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00029\" num=\"29\"><claim-text>29. The system of <claim-ref idref=\"US-6625693-B2-CLM-00028\">claim 28</claim-ref> where the user determines the dynamic criterion to load the exception handlers into the writable cache.</claim-text></claim>"}, {"num": 30, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00030\" num=\"30\"><claim-text>30. The system of <claim-ref idref=\"US-6625693-B2-CLM-00028\">claim 28</claim-ref> where the instrumentation mechanism stalls the pipeline in response to the exception signals.</claim-text></claim>"}, {"num": 31, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00031\" num=\"31\"><claim-text>31. The system of <claim-ref idref=\"US-6625693-B2-CLM-00028\">claim 28</claim-ref> where the interface is operable by a user of the system to specify the criterion.</claim-text></claim>"}, {"num": 32, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00032\" num=\"32\"><claim-text>32. The system of <claim-ref idref=\"US-6625693-B2-CLM-00028\">claim 28</claim-ref> where the memory holds the application program and the exception handlers.</claim-text></claim>"}, {"num": 33, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6625693-B2-CLM-00033\" num=\"33\"><claim-text>33. The system of <claim-ref idref=\"US-6625693-B2-CLM-00028\">claim 28</claim-ref> where the memory includes a mass storage device.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53989762\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>FIELD</h4><p>This invention relates generally to exception processing, and more particularly to fast exception processing in the context of pipelined processors.</p><h4>BACKGROUND</h4><p>The speeds at which processors perform are increasing due to constantly increasing computing needs. There are a number of ways to increase the speed of the processor, such as decreasing cycle time and reducing the average number of cycles required to execute many instructions collectively.</p><p>A well known way of increasing performance in processors and microcontrollers is to overlap the steps of different instructions using a technique called pipelining. To pipeline instructions, the various steps of instruction execution are performed by independent units called pipeline stages. As the number of stages is increased, while keeping the work done by any given instruction constant, the processor is said to be more heavily pipelined. Each instruction progresses from stage to stage, ideally with another instruction progressing in lock step only one stage behind. Thus, there can be as many instructions in execution, as there are pipeline stages. Each stage of execution is designed to perform its work within the processor's basic machine cycle. Thus, although each instruction requires as many cycles to perform as there are pipeline stages, a pipelined processors throughput is one instruction per cycle. In this manner, pipelining reduces the average number of cycles required to execute many instructions collectively, though it does not reduce the total amount of time required to execute any single instruction, by permitting the processor to handle more than one instruction at a time. Thus, pipelining is an architectural technique for improving performance over what can be achieved via processor circuit design improvements alone.</p><p>When a processor is executing, exceptions may occur. An exception is a special condition or event that unpredictably changes the normal flow of control in a program. The software that handles an exception is typically called an exception handler or handler. Generally, exceptions are either fatal or non fatal. A fatal exception is an exception which results in abrupt termination of execution. A non fatal exception does not result in abrupt termination of execution.</p><p>When a non-fatal exception occurs, typically the operating system (OS) must be called and the pipeline is flushed. This causes a severe degradation of performance depending on the type of application the processor is engaged in. If the non-fatal exception is occurring frequently, severe degradation of performance occurs.</p><p>One solution has been to hardwire exception processing. This can result in the instruction pointer not changing and as a result no flushing of the pipeline occurs. An example of this solution is Intel Corporation's 32-bit form iA32 of the industry standard architecture (ISA). When a translation look aside buffer (TLB) miss occurs, the ISA actually handles the translation cache miss in hardware, by performing \u201cpage table walk\u201d in microcode, as it attempts to find the missing translation. A TLB is a table used in a virtual memory system, which lists the physical address page number associated with each virtual address page number. A TLB is used in conjunction with a cache whose tags are based on virtual addresses. The virtual address is presented simultaneously to the TLB and to the cache so that cache access and virtual to physical address translation can proceed in parallel (the translation is done \u201con the side\u201d). If the requested address is not cached then the physical address is used to locate the data in main memory. The alternative would be to place the translation table between the cache and main memory so that it will only be activated once there was a cache miss. Since the code to handle the TLB miss event is \u201chardwired\u201d, no instruction fetch is needed to retrieve the instructions needed for the handler. As a result, no pipeline flush is needed since there is no change in the instruction pointer as a result of the TLB miss event. This approach eliminates the performance degradation caused by the pipeline being flushed. This works but has some drawbacks. One drawback to hardwired control is that only a limited number of exceptions may be hardwired. This approach is not entirely satisfactory because processors generally do not perform the same function all the time. For example, having the TLB miss hardwired does not benefit some applications such as one where only numerical calculations are involved. Another drawback to hardwired control is that hardwired control is fixed and therefore inflexible.</p><p>Other architectures such as the reduced instruction computing (RISC) architectures call the operating system more often in the event of an exception. This allows software to determine how to handle the exception but at the cost of performance. The present invention handles exceptions in a faster and more flexible manner.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 shows a diagram of a system according to an embodiment of the invention;</p><p>FIG. 2 shows a diagram of an instruction cache according to an embodiment of the invention;</p><p>FIG. 3 shows a flowchart of a method according to an embodiment of the invention; and,</p><p>FIG. 4 shows a diagram of splice cache system according to an embodiment of the invention;</p><p>FIG. 5 shows a diagram of a computer in conjunction with which an embodiment of the invention may be practiced.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION</h4><p>In the following detailed description of exemplary embodiments of the invention, reference is made to the accompanying drawings which form a part hereof, and in which are shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention, and it is to be understood that other embodiments may be utilized and that logical, mechanical, electrical and other changes may be made without departing from the spirit or scope of the present invention. The following detailed description is, therefore, not to be taken in a limiting sense, and the scope of the present invention is defined only by the appended claims.</p><p>Referring to FIG. 1, a system according to an embodiment of the invention is shown. The system includes a splice cache <b>101</b>, one or more lightweight handlers <b>102</b>, an exception logic <b>103</b>, and an instrumentation mechanism. The splice cache <b>101</b> exists as a block of memory containing the plurality of lightweight handlers <b>102</b>. The splice cache <b>101</b> may be of any size. Each lightweight handler is microcode for handling an exception. The exception is any unpredictable event.</p><p>The exception logic <b>103</b> is coupled to the splice cache. The exception logic <b>103</b> determines whether an exception has a corresponding lightweight handler in the splice cache <b>101</b>. The lightweight handlers are exception handlers. The exceptions that are covered may be fatal or non-fatal. In one implementation, only non-fatal exceptions will be handled by the lightweight handler. In other implementations, any exceptions can be handled by the lightweight handler. If the exception is fatal, execution of that program stops. If the exception is one covered by a lightweight handler, then the appropriate lightweight handler in the splice cache handles the exception. Generally, this results in avoiding a full pipeline flush.</p><p>When a lightweight handler from the splice cache <b>101</b> handles an exception, the pipeline <b>105</b> is able to continue normal operation without flushing the pipeline. In one implementation, the pipeline is stalled and the lightweight handler inserted into the pipeline. The stall is much less performance costly than fully flushing the pipeline. For a frequently occurring exception, this can increase performance significantly.</p><p>The instrumentation mechanism <b>106</b> inserts the lightweight handler into an execution stream. The execution stream may be a pipeline or execution stream pipeline.</p><p>One way the lightweight handler may be inserted is to stall the processor and insert the instructions for the lightweight handler into the pipeline. Selection logic such as a multiplexor can be used to select what is coming down from a previous stage or the splice cache. This may be the implementation for an in-order machine. An in-order machine is a process that executes instructions sequentially, that is, in the programmer-specified order. Another way for injecting handlers may be used for out-of-order machines. In an \u201cout-of-order\u201d machine, the instructions are not executed sequentially. An \u201cout-of-order\u201d machine is also known as a dynamically scheduled machine. The instructions to be executed are put into a pool and the processor executes them without regard to the programmer-specified order. For an out-of-order machine, the instructions for the lightweight handler may be inserted into the pool without stalling or blocking the processor pipeline. Another way for injecting handlers may be used for machines that are between \u201cin-order\u201d and \u201cout-of-order\u201d. These types of machines are known as decoupled. It keeps a queue of instructions that have already been fetched and are waiting to execute. The fetching of instructions operates asynchronously from the executing of instructions. In this type of machine, the instructions may be inserted into the queue or pool without stalling the pipeline.</p><p>Another embodiment of this invention includes a dynamic handler determiner <b>104</b>. The dynamic handler determiner <b>104</b> tracks the occurrence of exceptions. The dynamic handler determiner <b>104</b> inserts lightweight handlers into the splice cache <b>101</b> based on some dynamic criteria. The dynamic criteria may be to insert lightweight handlers for the most frequently occurring exceptions into the splice cache <b>101</b>. The dynamic criteria may be based on the most recently occurring exception. The dynamic handler determiner <b>104</b> could be implemented by hardware or software. The dynamic handler determiner <b>104</b> allows a system to maximize the use of its splice cache <b>101</b> so that the most frequently occurring non-fatal exceptions are handled by the plurality of lightweight handlers <b>102</b> in the splice cache <b>101</b>. This permits a processor to achieve a high level of performance for various uses. The dynamic handler determiner may insert handlers or have the instrumentation mechanism insert the handlers.</p><p>The lightweight handlers <b>102</b> may also be determined by a user. The user can determine which exceptions she would like handled by the lightweight handlers <b>102</b>. This allows the users to determine how to balance the resources according to their needs.</p><p>The lightweight handlers <b>102</b> may also be determined by an application. One application could encounter a large number of floating point exceptions and determine that a lightweight handler for it should be placed in the splice cache <b>101</b>. Another application may rarely encounter a floating point exception so it would not place a lightweight handler for it in the splice cache <b>101</b>. Applications may be controlled by a user.</p><p>In another embodiment, a pipeline <b>105</b> is coupled to the splice cache <b>101</b>. The pipeline <b>105</b> has earlier stages that must be blocked so that the lightweight handler <b>102</b> can be inserted without flushing the pipeline.</p><p>In another embodiment, a pipeline <b>105</b> is coupled to the splice cache <b>101</b> and the pipeline <b>105</b> has a pool so that a lightweight handler may be added to the pool without flushing the pipeline <b>105</b>. The pool is an instruction pool used in \u201cout-of-order\u201d machines and other types of machines.</p><p>In another embodiment, the splice cache <b>101</b> is a separate cache. In another, as shown in FIG. 2, the splice cache <b>101</b> is located within an instruction cache <b>201</b>. The instruction cache <b>201</b> is used to cache instructions to be executed by a processor. An extra bit could be tacked on to splice cache instructions to signal exception processing. The system can be implemented either way to make the best use of available resources.</p><p>Referring to FIG. 3, a method according to an embodiment of the invention is described. A determination may be made whether the exception is fatal or nonfatal. A fatal exception is one that will cause a current program to halt. A non-fatal exception will not cause a program to halt. A check is done to see if the exception is covered by any of the lightweight handlers in a splice cache <b>301</b>. If it is not, typically, a call to the operating system is made to handle the exception and the pipeline is flushed. If the exception is covered by a lightweight handler in the splice cache, the appropriate lightweight handler will process the exception <b>302</b>.</p><p>In another embodiment, the occurrence of exceptions are tracked. When the occurrence of a exception exceeds a predetermined amount, a lightweight handler for it may be added to the splice cache. Then, a less frequently or less recently used lightweight handler would be removed from the splice cache. This embodiment allows the dynamic alteration of the contents of the splice cache so as to allow the best use of the splice cache.</p><p>In other embodiments, a user, an application, or a processor may determine which lightweight handlers occupy the splice cache.</p><p>Referring to FIG. 4, a splice cache system according to an embodiment of the invention is disclosed. The splice cache system includes a storage structure <b>401</b>, one or more lightweight handlers <b>402</b>, and a logic unit <b>403</b>. The storage structure <b>401</b> can be made out of any type of memory or storage medium. For example, the storage structure could be an allocation of virtual memory or space on a hard drive. The storage structure <b>401</b> may exist in its own space or it may exist as part of a larger memory.</p><p>The lightweight handlers <b>402</b> are located withing the memory space <b>401</b>. Each lightweight handler is capable of handling an exception. This allows the exception to be handled while avoiding a full pipeline flush.</p><p>The logic unit <b>403</b> is coupled to the storage structure. It may be capable of adding and removing lightweight handlers to the storage structure <b>401</b>. This allows the lightweight handlers used to vary. The logic <b>403</b> may be controlled by a user, an application, or a processor. Thus, the plurality of lightweight handlers <b>402</b> can vary according to the use or application. The logic unit <b>403</b> may also track the occurrence of exceptions and add and remove lightweight handlers according to standard replacement algorithms.</p><p>In another embodiment, a pipeline <b>404</b> is coupled to the storage structure <b>401</b>. The pipeline <b>404</b> has a number of stages. The number of stages may vary. A number of stages are blocked or stalled to allow the lightweight handler to enter the pipeline <b>404</b>. The pipeline <b>404</b> may also have a pool and the lightweight handler is then added to the pool instead of blocking stages.</p><p>FIG. 5 is a block diagram of a computer system <b>500</b> of an example embodiment of the present invention. The computer system <b>500</b> comprises bus <b>505</b>, keyboard interface <b>501</b>, external memory <b>502</b>, mass storage device <b>503</b> and processor <b>504</b>. Bus <b>505</b> can be a single bus or a combination of multiple buses. Bus <b>505</b> provides communication links between components in the computer system. Keyboard interface <b>501</b> can be a dedicated device or can reside in another device such as a bus controller or other controller. Keyboard interface <b>501</b> allows coupling of a keyboard to the computer system and transmits signals from a keyboard to the computer system. External memory <b>502</b> can comprise a dynamic random access memory (DRAM) device, a static random access memory (SRAM) device, or other memory devices. External memory <b>502</b> stores information from mass storage device <b>503</b> and processor <b>504</b> for use by processor <b>504</b>. Mass storage device <b>503</b> can be a hard disk drive, a floppy disk drive, a CD-ROM device, or a flash memory device. Mass storage device <b>503</b> provides information to external memory <b>502</b>.</p><p>Processor <b>504</b> includes a single register file containing both speculative values and architecturally visible values. The processor <b>504</b> may be compatible with, but is not limited to, processors such as an Intel\u00ae architecture processor, manufactured by Intel Corporation of Santa Clara, Calif., the assignee of the present invention. In alternate embodiments, the processor <b>504</b> is compatible with a PowerPC\u2122 architecture processor, an Alpha\u2122 architecture processor, and the like. It is appreciated that at least some embodiments of the processor of the present invention are pipelined.</p><p>The various embodiments may be used or implemented on the computer system described. Other computer systems may also be used.</p><p>The various embodiments described above allow exceptions to be handled in a flexible and fast manner, unlike the prior art. Unlike exception handlers that were hardwired, the exception handling in this invention may be modified while providing the same performance. Unlike exception handling that was previously done by operating systems and software, the exception handling in this invention does not require flushing the pipeline causing a degradation in performance. This allows the instruction stream to continue uninterrupted which will yield higher performance.</p><p>Fast exception processing has been described. Although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that any arrangement which is calculated to achieve the same purpose may be substituted for the specific embodiments shown. This application is intended to cover any adaptations or variations of the present invention. Therefor, it is manifestly intended that this invention be limited only by the following claims and equivalents thereof.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Ken", "last_name": "Arora", "name": ""}, {"first_name": "Harshvardhan", "last_name": "Sharangpani", "name": ""}, {"first_name": "Gary", "last_name": "Hammond", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTEL CORPORATION"}, {"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711125"}, {"primary": false, "label": "712E0906"}, {"primary": false, "label": "712244"}, {"primary": false, "label": "711140"}], "ecla_classes": [{"label": "G06F   9/38H"}], "cpc_classes": [{"label": "G06F   9/3861"}, {"label": "G06F   9/3861"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1999-05-04", "application_date": "1999-05-04", "family_members": [{"ucid": "US-6625693-B2", "titles": [{"lang": "EN", "text": "Fast exception processing"}]}, {"ucid": "US-20020052992-A1", "titles": [{"lang": "EN", "text": "FAST EXCEPTION PROCESSING WITH MULTIPLE CACHED HANDLERS"}]}]}