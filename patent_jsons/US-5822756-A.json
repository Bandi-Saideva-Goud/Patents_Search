{"patent_number": "US-5822756-A", "publication_id": 71838102, "family_id": 23259176, "publication_date": "1998-10-13", "titles": [{"lang": "EN", "text": "Microprocessor cache memory way prediction based on the way of a previous memory read"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA37827196\"><p>In a microcomputer system using a multiple-way cache memory subsystem, the way of the next microprocessor operation is predicted, and either the output enables of the cache are predriven, or, in a single-bank multiple-way cache, the address bit which acts as a way selection is appropriately set. The way prediction used is based not on the address being accessed in the cache, but instead on the last processor code read, or the last processor code or data read. This permits the cache memory subsystem to respond more quickly on hits to the appropriate way, and also allows for slower cache memories to be used without reducing performance.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. A system using a multiple-way cache memory system using way prediction, the system comprising:<claim-text>a processor bus including an address strobe for initiating a memory operation and executing memory read operations;</claim-text><claim-text>a processor coupled to said processor bus;</claim-text><claim-text>a multiple-way cache memory system comprising:<claim-text>cache data memory corresponding to a first way;</claim-text><claim-text>cache data memory corresponding to a second way; and</claim-text><claim-text>a cache memory controller comprising:<claim-text>way selection logic for selecting between the first way and the second way in response to a way selection signal;</claim-text><claim-text>hit logic determining a hit to the first way or the second way on a memory operation;</claim-text><claim-text>way storage storing the way used on a first memory operation;</claim-text><claim-text>way prediction logic providing the way selection signal at a level corresponding to the way stored by said way storage before the hit logic determines a hit to the first way or the second way or neither way in response to a second memory operation;</claim-text><claim-text>wherein said way prediction logic determines whether said second memory operation is a hit to the way provided by said way prediction logic responsive to the hit logic; and</claim-text><claim-text>wherein said way prediction logic provides the way selection signal to the way other than the stored way if it was not determined the second memory operation is a hit to the way provided as the way selection signal by said way prediction logic;</claim-text></claim-text></claim-text><claim-text>a peripheral bus coupled to said processor bus and said multiple-way cache memory system, said peripheral bus for communicating data found from said processor bus;</claim-text><claim-text>system memory coupled to said multiple-way cache memory system; and</claim-text><claim-text>a disk storage system coupled to said system memory and said processor.</claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. The system of claim 1, wherein said way storage further comprises a way storage storing the way used only on a memory code read operation.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. The system of claim 1, wherein said disk storage system includes at least one hard disk drive.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. The system of claim 1, wherein the memory operation is a memory code read operation or a memory data read operation.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. The system of claim 1, wherein said cache data memories form a single-bank cache.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. The system of claim 1, wherein said cache data memories form a dual-bank cache.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. The system of claim 1, wherein the memory operation is pipelined.</claim-text></claim>"}, {"num": 8, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. A system using a multiple way cache memory system using way prediction, the system comprising:<claim-text>a processor bus including an address strobe for initiating a memory operation and executing memory read operations;</claim-text><claim-text>a processor coupled to said processor bus;</claim-text><claim-text>a multiple-way cache memory system comprising:<claim-text>cache data memory corresponding to a first way;</claim-text><claim-text>cache data memory corresponding to a second way; and</claim-text><claim-text>a cache memory controller comprising:<claim-text>way selection logic selecting between the first way and the second way in response to selection signal;</claim-text><claim-text>hit logic determining a tag hit to the first way or the second way on a memory operation;</claim-text><claim-text>way storage storing the way used on a first memory operation;</claim-text><claim-text>a cache tag memory corresponding to the first way and a cache tag memory corresponding to the second way, said cache tag memories for receiving an address strobe initiating a second memory operation;</claim-text><claim-text>way prediction logic providing the way selection signal at a level corresponding to the way stored by said way storage before the hit logic determines a hit to the first way or the second way or neither way in response to a second memory operation;</claim-text><claim-text>wherein said way prediction logic determines whether said second memory operation is a hit to the way provided by said way prediction logic responsive to the hit logic; and</claim-text><claim-text>wherein said way prediction logic provides the way selection signal to the way other than the stored way if it was not determined the second memory operation is a hit to the way provided as the way selection signal by said way prediction logic;</claim-text></claim-text></claim-text><claim-text>a peripheral bus coupled to said processor bus and said multiple-way cache memory system, said peripheral bus for communicating data found from said processor bus;</claim-text><claim-text>system memory coupled to said multiple way cache memory system; and</claim-text><claim-text>a disk storage system coupled to said system memory and said processor.</claim-text></claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. The system of claim 8, wherein said way storage storing the way used on a first memory operation further comprises way storage storing the way used only on a memory code read operation.</claim-text></claim>"}, {"num": 10, "parent": 8, "type": "dependent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. The system of claim 8, wherein said disk storage system includes at least one hard disk drive.</claim-text></claim>"}, {"num": 11, "parent": 8, "type": "dependent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. The system of claim 8, wherein the memory operation is a memory code read operation or a memory data read operation.</claim-text></claim>"}, {"num": 12, "parent": 8, "type": "dependent", "paragraph_markup": "<claim num=\"12\"><claim-text>12. The system of claim 8, wherein said cache data memories form a single-bank cache.</claim-text></claim>"}, {"num": 13, "parent": 8, "type": "dependent", "paragraph_markup": "<claim num=\"13\"><claim-text>13. The system of claim 8, wherein said cache data memories form a dual-bank cache.</claim-text></claim>"}, {"num": 14, "parent": 8, "type": "dependent", "paragraph_markup": "<claim num=\"14\"><claim-text>14. The system of claim 8, wherein the memory operation is pipelined.</claim-text></claim>"}, {"num": 15, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"15\"><claim-text>15. A system using a multiple-way cache memory system using way prediction, the system comprising:<claim-text>a processor bus including an address strobe for initiating a memory operation and executing memory read operations;</claim-text><claim-text>a processor coupled to said processor bus;</claim-text><claim-text>a multiple-way cache memory system comprising:<claim-text>cache data memory corresponding to a first way;</claim-text><claim-text>cache data memory corresponding to a second way; and</claim-text><claim-text>a cache memory controller comprising:<claim-text>way selection logic for selecting between the first way and the second way in response to a way selection signal;</claim-text><claim-text>hit logic for determining a tag hit to the first way or the second way on a memory operation;</claim-text><claim-text>way storage storing the way used on a first memory operation;</claim-text><claim-text>a cache tag memory corresponding to the first way and a cache tag memory corresponding to the second way, said cache tag memories for receiving an address strobe initiating a second memory operation;</claim-text><claim-text>way prediction logic providing the way selection signal at a level corresponding to the way stored by said way storage before the hit logic determines a hit to the first way or the second way or neither way in response to a second memory operation;</claim-text><claim-text>wherein said way prediction logic determines whether said second memory operation is a hit to the way provided by said way prediction logic responsive to the hit logic; and</claim-text><claim-text>wherein said way prediction logic provides the way selection signal to the way other than said stored way if it was not determined the second memory operation is a hit to the way provided as the way selection signal by said way prediction logic;</claim-text></claim-text></claim-text><claim-text>a peripheral bus coupled to said processor bus and said multiple-way cache memory system, said peripheral bus for communicating data found from said processor bus;</claim-text><claim-text>system memory coupled to said multiple-way cache memory system; and</claim-text><claim-text>a video subsystem coupled to said peripheral bus.</claim-text></claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim num=\"16\"><claim-text>16. The system of claim 15, wherein said way storage further comprises a way storage storing the way used only on a memory code read operation.</claim-text></claim>"}, {"num": 17, "parent": 15, "type": "dependent", "paragraph_markup": "<claim num=\"17\"><claim-text>17. The system of claim 15, wherein the processor bus includes an address strobe for initiating a first memory operation.</claim-text></claim>"}, {"num": 18, "parent": 15, "type": "dependent", "paragraph_markup": "<claim num=\"18\"><claim-text>18. The system of claim 15, wherein the memory operation is a memory code read operation or a memory data read operation.</claim-text></claim>"}, {"num": 19, "parent": 15, "type": "dependent", "paragraph_markup": "<claim num=\"19\"><claim-text>19. The system of claim 15, wherein said cache data memories form a single-bank cache.</claim-text></claim>"}, {"num": 20, "parent": 15, "type": "dependent", "paragraph_markup": "<claim num=\"20\"><claim-text>20. The system of claim 15, wherein said cache data memories form a dual-bank cache.</claim-text></claim>"}, {"num": 21, "parent": 15, "type": "dependent", "paragraph_markup": "<claim num=\"21\"><claim-text>21. The system of claim 15, wherein the memory operation is pipelined.</claim-text></claim>"}, {"num": 22, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"22\"><claim-text>22. A multiple way cache memory system using a way prediction, comprising:<claim-text>cache data memory corresponding to a first way;</claim-text><claim-text>cache data memory corresponding to a second way; and</claim-text><claim-text>a cache memory controller comprising:<claim-text>way selection logic selecting between the first way and the second way in response to a way selection signal;</claim-text><claim-text>hit logic determining a tag hit to the first way or the second way on a memory operation;</claim-text><claim-text>way storage storing the way used on a first memory operation;</claim-text><claim-text>way prediction logic providing the way selection signal at a level corresponding to the way stored by said way storage before the hit logic determines a hit to the first way or the second way or neither way in response to a second memory operation;</claim-text><claim-text>wherein said way prediction logic determines whether said second memory operation is a hit to the way provided by said way prediction logic responsive to the hit logic determines a hit to the first way or the second way or neither in response to the second memory operation; and</claim-text><claim-text>wherein the way prediction logic provides said way selection signal to the way other than said stored way if it was not determined the second memory operation is a hit to the way provided as the way selection signal by said way prediction logic.</claim-text></claim-text></claim-text></claim>"}, {"num": 23, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"23\"><claim-text>23. The system of claim 22, wherein said way storage storing the way used on a first memory operation further comprises way storage storing the way used only on a memory code read operation.</claim-text></claim>"}, {"num": 24, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"24\"><claim-text>24. The system of claim 22, the cache memory controller being in a system having a processor bus, wherein the processor bus includes an address strobe for initiating a first memory operation.</claim-text></claim>"}, {"num": 25, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"25\"><claim-text>25. The system of claim 22, wherein the memory operation is a memory code read operation or a memory data read operation.</claim-text></claim>"}, {"num": 26, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"26\"><claim-text>26. The system of claim 22, wherein said cache data memories form a single-bank cache.</claim-text></claim>"}, {"num": 27, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"27\"><claim-text>27. The system of claim 22, wherein said cache data memories form a dual-bank cache.</claim-text></claim>"}, {"num": 28, "parent": 22, "type": "dependent", "paragraph_markup": "<claim num=\"28\"><claim-text>28. The system of claim 22, wherein the memory operation is pipelined.</claim-text></claim>"}, {"num": 29, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"29\"><claim-text>29. A cache memory controller, comprising:<claim-text>way selection logic selecting between the first way and the second way in response to a way selection signal;</claim-text><claim-text>hit logic for determining a tag hit to the first way or the second way on a memory operation;</claim-text><claim-text>way storage storing the way used on a first memory operation;</claim-text><claim-text>cache tag memory corresponding to the first way and a cache tag memory corresponding to the second way, said cache tag memories for receiving an address strobe initiating a second memory operation;</claim-text><claim-text>way prediction logic providing the way selection signal at a level corresponding to the way stored by said way storage before the hit logic determines a hit to the first way or the second way or neither way in response to a second memory operation;</claim-text><claim-text>wherein said way prediction logic determines whether said second memory operation is a hit to the way provided by said way prediction logic responsive to the hit logic; and</claim-text><claim-text>wherein said way prediction logic provides the way selection signal to the way other than said stored way if it was not determined the second memory operation is a hit to the way provided as the way selection signal by said way prediction logic.</claim-text></claim-text></claim>"}, {"num": 30, "parent": 29, "type": "dependent", "paragraph_markup": "<claim num=\"30\"><claim-text>30. The cache memory controller of claim 29, wherein said way storage further comprises way storage storing the way used only on a memory code read operation.</claim-text></claim>"}, {"num": 31, "parent": 29, "type": "dependent", "paragraph_markup": "<claim num=\"31\"><claim-text>31. The cache memory controller of claim 29, wherein said way prediction logic providing the way selection signal at a level corresponding to said stored way is independent of the address strobe initiating a second memory operation to be received by said cache tag memories.</claim-text></claim>"}, {"num": 32, "parent": 29, "type": "dependent", "paragraph_markup": "<claim num=\"32\"><claim-text>32. The cache controller of claim 29, wherein the first memory read operation is a memory code read operation or a memory data read operation.</claim-text></claim>"}, {"num": 33, "parent": 29, "type": "dependent", "paragraph_markup": "<claim num=\"33\"><claim-text>33. The cache controller of claim 29, wherein the memory operation is pipelined.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES67188468\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This application is a continuation of U.S. application Ser. No. 08/323,432, filed Oct. 14, 1994, now U.S. Pat. No. 5,640,532.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>SPECIFICATION</h4><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The invention relates to microcomputer systems employing cache memory, and more specifically relates to a method of and apparatus for using cache way prediction in a multiple-way cache to increase the performance of such cache memories.</p><p>2. Description of the Related Art</p><p>The field of microcomputer design has seen tremendous advances in the past decade. Microcomputer systems have undergone revolutionary changes since the introduction of the original Personal Computer by International Business Machines using an 8088 microprocessor by Intel Corporation. Systems today include multiple buses, extremely wide data paths, huge addressing spaces, and processor speeds of over 50 MHz.</p><p>In the course of improving these microcomputer systems, designers of both the chips and the systems themselves resorted to cache technology to more efficiently couple the higher speed processors with lower speed memory. These caches have evolved into multiple level caches, with both data and code caches in the microprocessor, and a second level (L2) cache coupling the microprocessor host bus to slower speed system memory.</p><p>The purpose of a cache is to eliminate wait states. A processor running at 50 Mhz only has 20 nanoseconds seconds per clock cycle, and only more expensive static random access memory (SRAM) can respond to memory operations in that amount of time without wait states. Main memory is usually implemented using less expensive dynamic random access memory (DRAM), which is slower and requires the processor to wait additional clock cycles for a response. A cache provides an intermediate store of much higher speed memory, relatively smaller than main memory, that permits a processor to run with fewer wait states when the needed data is stored in the cache memory. When the data is not stored in the cache memory, a cache controller then retrieves that data from main memory.</p><p>Cache design is well known to the microcomputer art and includes a number of configurations. Two popular configurations are a direct mapped cache and a multiple-way cache. In a direct mapped cache, a certain portion of the memory address is stored in a cache tag RAM as a tag. This tag indicates to what block of main memory the data stored in the cache data RAM corresponds. A second portion of the processor provided memory address, known as the index, then addresses the cache data RAM when the corresponding tag in the tag RAM matches a valid tag portion of the processor address bus. For example, assume a simple memory system using 16 bit addressing, providing 64 kilobytes of memory. Assume that the high speed cache data RAM provides 8 kilobytes of high speed cache memory. The lower 8 bits of the memory address then acts as an index into both the cache data RAM and the cache tag RAM, while the top 8 address bits are then stored in the indexed location in the tag RAM. When the microprocessor seeks to access a certain memory location, the top 8 address bits are compared to the data stored in the indexed location of the tag RAM. If the tag matches those bits, then the indexed cache data memory location contains the data from main memory corresponding to the processor provided memory address.</p><p>This example illustrates a direct mapped cache. A problem with such a direct mapped cache is that if two memory locations are accessed which are one cache page apart--i.e., they have the same index--they could only occupy the same location in the cache data RAM. Thus, on alternating accesses to such locations, the cache must be updated from or to main memory resulting in a cache miss.</p><p>To provide for a greater hit percentage, designers implemented multi-way set-associative caches. A typical example is a two-way set-associative cache. In such a cache, each cache index has two corresponding cache data RAM storage locations and two corresponding tags in the cache tag RAM. If one indexed way is already occupied by data corresponding to another tag, then the second way can be used to store and retrieve the main memory data. When yet a third location of main memory needs to be stored in the cache, various algorithms are used to determine in which way of the cache to replace data, such as a least recently used algorithm.</p><p>Both of these types of cache designs are well known in the art of microcomputer design. There are implementation details of such caches, however, that can effect system speed. Advances have become incremental in recent years, with the savings of even a single wait state becomming important to improving system performance.</p><p>In a two-way set-associative cache, one of the ways must be chosen during a microprocessor read operation. The index portion of the asserted address is latched to the cache data and tag RAMs, and then when the cache tag RAMs return signals indicating a hit or miss to a first or second way, the output enables of the appropriate bank of cache data RAM corresponding to that way is enabled. But when running at 50 MHz, even the act of enabling the output buffers of the appropriate way of the cache can require a wait state. Cache designers have therefore implemented way prediction algorithms based on which way of the cache was most recently used. Then, when an address is strobed onto the processor host bus by the processor for a read operation, this most recently used way prediction logic predicts which way will be needed and enables that way s cache output enable. This occurs even before other more complicated circuitry determines which, if any, way is actually a hit, saving precious time in enabling the output of the cache data RAM.</p><p>This causes a problem, however, should the way be a miss. In such a case, the output enables of the bank that forms the first way must be disabled and only then the other way s output enables enabled. This will typically require extra wait states. But, because the way prediction logic will be correct at least half of the time, this generally improves system performance, allowing no wait state operation in at least half of the cases. But in high speed systems, the cache data RAM s output enables cannot wait on a read of the tag RAM to generate the most recently used bit. That is, the most recently used bit will not become available from the most recently used logic and the cache tag RAMs in time to enable the cache output enables in anticipation of a cache data RAM read. In such a case, only the use of extremely high speed SRAMs would allow no wait state operation.</p><p>Therefore, it would be desirable if other efficient way prediction algorithms could be developed that would allow no wait state operation in a majority of cases without using prohibitively expensive cache data SRAMs.</p><p>As noted above, a multi-way set-associative cache has historically been implemented using a separate physical bank of cache data RAM for each way, with the output enables being used for way selection.</p><p>In a two-way set-associative cache, at least two banks of memory would be required. Assuming a 64-bit-wide data bus and 32-bit-wide burst SRAMs, this would mean four physical chips. It would be greatly desirable to allow implementation of multi-way caches without these minimum requirements of memory banks, allowing less expensive cache memory systems to be designed. Generally, the only alternative in the past has been using a direct mapped cache memory subsystem.</p><p>To maintain coherency between the cache memory and main memory, cache tag RAMs typically have a number of bits of information associated with the state of the corresponding data in the cache data RAM. For example, a valid bit is typically used to indicate whether a particular line of a cache contains valid data. Further, in a writeback cache, in which data written from the processor to the cache is not updated to main memory until necessary, a modified bit indicates that the processor has written to a particular line of the cache data RAM, but that line has not been subsequently written back to main memory.</p><p>These bits typically provide another source of system delays. When the processor writes to a line of cache memory in the writeback cache that has not been modified, that modified bit must be updated to reflect the modified status of the corresponding line in the cache data RAM. This will typically take an extra clock cycle except in complicated, and expensive, multi-ported cache memory systems. In a cache memory system where the memory is only accessed through one bus, however, a write to an unmodified valid line in the cache data RAM typically requires extra clock cycles to update the modified bit in the cache tag RAM.</p><p>When the processor writes to the cache and the indexed line in both ways of the cache data RAM is not valid, or if both ways result in cache tag misses, then the cache does not contain the line of memory to which the processor is attempting to write. This condition instigates an allocation cycle for writeback caches. If the line of data in the chosen way of the cache data RAM is valid but a tag miss, that data must first be written back to main memory before the appropriate line of main memory is read into the cache, whereas, if the line of data in the cache data RAM is invalid, no writeback is needed. After such a writeback, if needed, the cache memory controller allocates a line in the cache data RAM for the addressed memory location. This line of data is read from main memory, and the corresponding index location of the tag RAM is updated to include the tag and the various valid and modified bits. A read allocation cycle is typically just a cache linefill, so the corresponding valid bits are set to true and the modified bits would be set to unmodified. The processor write operation that instigated the allocate is then permitted to restart, whereupon the appropriate data is written into the cache and the modified bit for that line of the cache is then asserted.</p><p>But as noted above, the assertion of this bit requires an extra clock cycle. Therefore, in single-ported cache memory systems, a write allocation cycle typically requires an extra wait state for the cache memory controller to set the appropriate modified bits on the subsequent write from the microprocessor. It would be desirable to eliminate such wait states.</p><h4>SUMMARY OF THE INVENTION</h4><p>In a computer system according to the invention, a cache memory controller implements an improved method of way prediction that is not dependent upon the address asserted by the microprocessor. Instead of using a most recently used algorithm, for example, based upon the least recently used bits stored within the cache tag memory, a computer system according to the invention predicts which cache way will be used for the next operation based on a last microprocessor memory operation, preferably the last microprocessor code read way or a last microprocessor code or data read way.</p><p>This results in the advantages of a greater way hit percentage and less wait states even in systems that would otherwise not have time to implement other sorts of way prediction. In higher speed systems, using way prediction based on the address that the microprocessor asserts necessarily results in wait states, because the cache tag memory must be accessed with that asserted address to appropriately predict the way, such as using the least recently used bits. But in higher speed systems, there is insufficient time to access such a tag memory and then address the cache data memory before a response is needed by the microprocessor, at least not without using extremely high speed cache data memories and cache tag memories.</p><p>Further according to the invention, on pipelined memory operations, the way of the previous operation is chosen in the second operation of a pipelined operation in a two-bank two-way cache no matter what the way prediction circuitry would otherwise indicate. This is because if the way prediction circuitry predicts to the other way, that prediction circuitry will not result in the saving of a wait state should it be correct. Thus, the only way a cycle is saved is if the second memory operation in a pipelined situation is to the same way as the previous operation.</p><p>Therefore, according to the invention, way prediction can be used and zero wait state operation achieved while using slower cache data memories or cache tag memories.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>A better understanding of the present invention can be obtained when the following detailed description of the preferred embodiment is considered in conjunction with the following drawings, in which:</p><p>FIG. 1 is a block diagram of a system board of a computer system according to the preferred embodiment;</p><p>FIG. 2 is a block diagram of a processor board according to the present invention for use with the computer system of FIG. 1;</p><p>FIG. 3A is a block diagram illustrating a single-bank two-way cache implemented according to the invention;</p><p>FIG. 3B is a block diagram illustrating a two-bank two-way cache implementing certain features according to the invention;</p><p>FIGS. 3C and 3D are block diagrams of a cache and memory controller according to the invention showing specific logical modules and blocks within that controller;</p><p>FIGS. 4A-4C and 5A-5F are schematic illustrations of circuitry used to generate the single-bank two-way cache way prediction signal according to the invention;</p><p>FIGS. 6A-6K and 7A-7G are schematic illustrations of circuitry used to assert the output enables to separate banks of the two-bank two-way cache according to the invention based on way prediction;</p><p>FIG. 8 is a state diagram illustrating the operation of a read hit module in the cache and memory controller according to the invention;</p><p>FIGS. 9A-9D are schematic illustrations of circuitry used by the module employing the state diagram of FIG. 8;</p><p>FIG. 10 is a state diagram of a level 2 cache writeback state machine implemented in the cache and memory controller according to the invention;</p><p>FIGS. 11A-11C are schematic illustrations of circuitry used within the module implementing the state machine of FIG. 10;</p><p>FIG. 12 is a state diagram of a local memory write state machine implemented in the cache and memory controller according to the invention;</p><p>FIGS. 13A-13F are schematic illustrations of circuitry used by the module implementing the state machine of FIG. 12;</p><p>FIG. 14 is a state diagram of a cache data RAM allocation state machine implemented the cache and memory controller according to the invention;</p><p>FIGS. 15A-15E and 16A-16B are schematic illustrations of circuitry used within the module implementing the state machine of FIG. 14;</p><p>FIG. 17 is a state diagram illustrating a cache tag memory implemented in the cache and memory controller according to the invention;</p><p>FIG. 18 is a schematic illustration of circuitry used in the module implementing the state machine of FIG. 17;</p><p>FIG. 19 is a schematic illustration of cycle request logic;</p><p>FIGS. 20A-20K are schematic illustrations of the circuitry used to create various signals used by the request module, principally relating to cache control;</p><p>FIGS. 21A-21D are schematic illustrations of circuitry used to generate various signals in the request block, including memory read, allocation, and back-off signals;</p><p>FIGS. 22A-22B are schematic illustrations of circuitry used to generate various signals relating to cache output enables and read hits;</p><p>FIGS. 23A-23G are schematic illustrations of circuitry used to generate various cache write related signals;</p><p>FIGS. 24A-24G are schematic illustrations of circuitry used to create various signal relating to the cache tag memory;</p><p>FIGS. 25A-25F are schematic illustrations of various circuitry used to generate signals for control of the cache data RAMs;</p><p>FIGS. 26A-26H are schematic illustrations of circuitry used to generate various cache chip select signals;</p><p>FIGS. 27A-27C are schematic illustrations of circuitry used to create various address strobes and allocation status signals;</p><p>FIG. 28 is a block diagram illustrating the cache tag RAM implemented in the cache and memory controller according to the invention;</p><p>FIG. 29A is a state diagram of a state machine implemented within the cache and memory controller according to the invention that tracks writes to the cache tag memory;</p><p>FIGS. 29B-31J are schematic illustrations of circuitry used in implementing the state machine of FIG. 29A;</p><p>FIG. 32 is a timing diagram illustrating the write allocate direct to modified operation according to the invention;</p><p>FIG. 33 is a timing diagram illustrating last code way prediction in a two-bank two-way cache according to the invention;</p><p>FIG. 34 is a timing diagram illustrating last code way prediction in one-bank two-way cache according to the invention; and</p><p>FIGS. 35A and 35B are timing diagrams illustrating the difference between the timing of a one-bank two-way cache and a two-bank two-way cache according to the invention during pipelined memory operations.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF PREFERRED EMBODIMENT</h4><p>The following disclosures are hereby incorporated by reference:</p><p>U.S. application Ser. No. 08/324,016, entitled Single Bank, Multiple Way Cache Memory, by Sompong P. Olarig, Jens K. Ramsey, and Michael J. Collins, filed Oct. 14, 1994;</p><p>U.S. application Ser. No. 08/324,246, entitled Memory Controller With Write Posting Queues for Processor and I/O Bus Operations and Ordering Logic for Controlling the Queues, by Michael J. Collins, Gary W. Thome, Michael Moriarty, Jens K. Ramsey, and John E. Larson, filed Oct. 14, 1994;</p><p>U.S. application Ser. No. 08/323,263, entitled Data Error Detection and Correction System, by William J. Walker and Alan L. Goodrum, filed Oct. 14, 1994;</p><p>U.S. application Ser. No. 08/324,020, entitled Circuit for Invalidating Portions of a Cache Memory if a Write Occurs to a Write Protected Area of Main Memory by Jens K. Ramsey, filed Oct. 14, 1994;</p><p>U.S. application Ser. No. 08/323,110, entitled Circuit for Placing a Cache Memory Into Low Power Mode in Response to Special Bus Cycles, by Jens K. Ramsey, and Jeffrey C. Stevens, filed Oct. 14, 1994; and</p><p>U.S. application Ser. No. 08/324,011, entitled System for Arbitrating Access to Memory by John E. Larson, Michael Moriarty, Michael J. Collins and Gary W. Thome, filed Oct. 14, 1994; all of which are assigned to the assignee of this invention.</p><h4>System Overview</h4><p>Referring to FIG. 1, the system board S of a computer system according to the present invention is shown. In the preferred embodiment, the system boards contain circuitry and slots for receiving interchangeable circuit boards. In the preferred embodiment, there are two primary buses located on the system board S. The first bus is the PCI or Peripheral Component Interconnect bus P which includes address/data portion 100, control and byte enable portion 102 and control signal portion 104. The second primary bus on the system board S is the EISA bus E. The EISA bus E includes LA address portion 106, SA address portion 108, SD data portion 110 and EISA/ISA control signal portion 112. The PCI and EISA buses P and E form the backbones of the system board S.</p><p>A CPU connector 114 is connected to the PCI bus P to receive interchangeable processor cards, such as the one shown in FIG. 2. A PCI graphics connector 116 is connected to the PCI bus P to receive a video graphics card as shown in FIG. 3. A PCI option connector 118 is also connected to the PCI bus P to receive any additional cards designed according to the PCI standard. In addition, a SCSI and network interface (NIC) controller 120 is connected to the PCI bus P. Preferably the controller 120 is a single integrated circuit and includes the capabilities necessary to act as a PCI bus master and slave and the circuitry to act as a SCSI controller and an Ethernet interface. A SCSI connector 122 is connected to the controller 120 to allow connection of various SCSI devices, such as hard disk drives and CD-ROM drives. An Ethernet connector 124 is provided on the system board S and is connected to filter and transformer circuitry 126, which in turn is connected to the controller 120. This forms a network or Ethernet connection for connecting the system boards and computer to a local area network (LAN).</p><p>A PCI-EISA bridge 130 is provided to convert signals between the PCI bus P and the EISA bus E. The PCI-EISA bridge 130 includes the necessary address and data buffers and latches, arbitration and bus master control logic for the PCI bus, EISA arbitration circuitry, and EISA bus controller as conventionally used in EISA systems and a DMA controller. Preferably the PCI-EISA bridge 130 is a single integrated circuit, but other combinations are possible. A miscellaneous system logic chip 132 is connected to the EISA bus E. The miscellaneous system logic chip 132 contains a digital audio interface, counters and timers as conventionally present in personal computer systems, an interrupt controller for both the PCI and EISA buses P and E and power management logic, as well as other miscellaneous circuitry. A series of four EISA slots 134 are connected to the EISA bus E to receive ISA and EISA adapter cards. A combination I/O chip 136 is connected to the EISA bus E. The combination I/O chip 136 preferably includes a floppy disk controller, real time clock (RTC)/CMOS memory, two UARTs, a parallel port and various address decode logic. A floppy disk connector 138 for receiving a cable to a floppy disk drive is connected to the combination I/O chip 136. A pair of serial port connectors are also connected to the combination I/O chip 136, as is a parallel port connector 142. A buffer 144 is connected to both the EISA bus E and the combination I/O chip 136 to act as a buffer between the EISA bus E and a hard disk drive connector 146 to allow connection of an IDE-type hard disk drive.</p><p>A non-volatile random access memory (NVRAM) 148 is connected to the EISA bus E and receives its control signals from the combination I/O chip 136. An address latch 150 is connected to the EISA bus E and controlled by the combination I/O chip 136 to provide additional addressing capability for the NVRAM 148. Preferably the NVRAM 148 is used to contain certain system information. A data buffer 152 is connected to the SD portion of the EISA bus E to provide an additional data bus XD for various additional components of the computer system. The NVRAM 148 is connected to the XD data bus to receive its data bits. A flash ROM 154 receives its control and address signals from the EISA bus E and is connected to the XD bus for data transfer. Preferably the flash ROM 154 contains the BIOS information for the computer system and can be reprogrammed to allow for revisions of the BIOS. An 8742 or keyboard controller 156 is connected to the XD bus and EISA address and control portions 108 and 112. The keyboard controller 156 is of conventional design and is connected in turn to a keyboard connector 158 and a mouse or pointing device connector 160.</p><p>The computer system of the preferred embodiment also includes audio capabilities. To this end a CODEC chip 162 is connected to the miscellaneous system logic chip 132 and to an analog amplifier and mixer chip 164. An FM synthesizer chip 166 is connected to the analog amplifier and mixer 164 and receives digital information from the XD bus. The FM synthesizer 166 is also connected to the control and data portions 110 and 112 of the EISA bus E and is controlled by the miscellaneous system logic chip 132. An audio connector 168 is provided to allow external audio connections to the computer and is connected to the outputs and inputs of the analog amplifier and mixer.</p><p>Referring now to FIG. 2, the processor board P is shown. In the processor board P of FIG. 2, the CPU or processor 200 can be any of a plurality of processors, such as the 486DX/33, 486DX2/66, 486DX4/50-100, 486DX4/33-100, 486DX4/33-83, P24T, Pentium 50/75, Pentium 60/90, and Pentium 66/100, and other similar and compatible processors. The processor 200 provides data, address and control portions 202, 204 and 206 to form a processor bus PB. A level 2 (L2) or external cache memory system 208 is connected to the processor bus PB to provide additional caching capabilities to improve performance of the computer system. The L2 cache 208 can be organized as a 128 kbyte direct mapped cache or 256 kbyte two-way set associative cache when used with 486 family processor and as a 256 or 512 kbyte direct mapped or two-way set associative cache when used with Pentium family processors. In the preferred embodiment, however, the L2 cache 208 is implemented in the two-way set-associative mode. A cache and memory controller (CMC) and PCI bridge chip 210, is connected to the control portion 206 and to the address portion 204. The CMC 210 is connected to the L2 cache 208 as it incorporates the cache controller and therefore controls the operations of the cache memory devices in the L2 cache 208. The CMC 210 is also connected to control a series of address and data buffers 212. The data buffers 212 are utilized to handle memory data to a main memory array 214. The data buffers 212 are connected to the processor data portion 202 and receive control signals from the CMC 210. The data buffers 212 provide a memory address bus 216 and a memory data bus 218 to the memory array 214. A memory control signal bus 220 and memory address bus 216 is provided from the CMC 210. Clock distribution and generation circuitry 222 is associated with the processor card P and is connected to the CMC 210. A processor connector 224, such as a card edge, is provided to be mateably received by the processor connector 114. The processor connector 224 is connected to the CMC 210, the data buffers 212 and the clock distribution circuitry 222 to provide clocks to the computer system and to provide a PCI interface to allow the processor 200 to access the PCI and EISA buses P and E and to allow PCI and EISA bus masters to access the main memory array 214.</p><h4>Cache Memory Controller Overview</h4><p>Hardware Configuration</p><p>Turning to FIGS. 3A to 3C, further details of the CMC 210 and its connections to the L2 cache 208 are shown. Turning to FIG. 3A, the L2 cache 208 includes two 32-bit wide synchronous burst SRAMs 300 and 302. These are preferably MT58LCK36B2 32K by 36 synchronous burst SRAMs by Micron Semiconductor, Inc. Two burst SRAMs 300 and 302 are used in the disclosed embodiment because the processor data bus is 64 bits wide. The burst SRAM 300 is connected to the processor 200 data bus lines PD 63:48, 31:16!, while the burst SRAM 302 is connected to lines PD 47:32, 15:0!. Thus, each of the burst SRAMs 300 and 302 provides half of the data to and from the processor 200 data bus. The processor 200 address bus PA, however, is identically connected to each of the burst SRAMs 300 and 302. PA 16:3! is provided to fourteen address inputs of each of the burst SRAMs 300 and 302, thus providing a 14-bit index. The fifteenth address input A 14! of the burst SRAMs 300 and 302, however, is provided by a cache memory way selection signal CMWAY, which according to the invention, provides for a two-way cache using the single bank of cache data memory. This signal is generated by the CMC 210, and will be discussed below in conjunction with FIGS. 4A-4C. Other inputs provided by the CMC 210 to the burst SRAMs 300 and 302 are an active low output enable signal COE0* that is provided to the chip output enable inputs, a cache address strobe signal CADS0* that is provided to the controller address strobe input of the burst SRAMs 300 and 302, a cache chip select signal CCS0* that is provided to the chip enable input of the burst SRAMs 300 and 302, a cache advance strobe CADV* that is provided to the cache advance input of the burst SRAMs 300 and 302, and cache write enable signals CWE* 7:0!, the appropriate ones of which are provided to each of the burst SRAMs 300 and 302 corresponding to the data lines PD to which the burst SRAMs 300 and 302 are connected. These signals are further described below in conjunction with FIGS. 4, 6, and 25.</p><p>Certain signals in the computer system S according to the invention are physically manifested as active low signals. That is, when the physical signal is logical low, it is considered true. Such signals are generally designated by being following with an asterisk, *. When discussing these signals in a logical sense, they will often be referred to without the asterisk, *, which indicates a corresponding active high logical signal. A logical negation operation, as opposed to the logic sense of a physical signal, is delineated by placing an exclamation point, |, in front of the signal. In the figures, this technique is used to reduce drawing complexity that would be necessitated by showing the inverters necessary with this convention.</p><p>In prior art systems, if the burst SRAMs 300 and 302 were used to implement a two-way set-associative cache, four such chips would be necessary. FIG. 3B illustrates such a system. This is an alternative embodiment for implementing one aspect according to the invention. FIG. 3B illustrates a first bank 310 of such a two-way set-associative cache. In such a two-bank mode, all 15 bits of the first bank 310 address inputs are connected to PA 17:3!, with the CMC 210 providing COE0* as before to the first bank 310, but now providing a second enable signal COE1* as the chip output enable to the second way, formed by a second bank 320. Similarly, a second chip select signal CCS1* is provided to the second bank 320, and now each bank requires two burst SRAMs 312 and 314, and 322 and 324, to handle the 64-bit data path of PD 63:0!. Even in such a prior art system, advantages can result when the last code read or last code plus data read way prediction according to the invention is used. This is further discussed below, especially in conjunction with FIG. 33. Selection in FIG. 3B between the two ways formed by banks 310 and 320 requires either waiting until tag RAMS 364 or 366 in the CMC 210 have returned a hit to one way or the other way and then selecting the appropriate way of the banks 310 or 320 using COE0* or COE1*, or alternatively, predicting which way of the banks 310 or 320 the next processor 200 operation would be directed to, typically based on a least recently used algorithm from data in the tag RAMs 364 or 366. In either case, however, a separate physical bank of chips would be necessary for each way.</p><p>According to one aspect of the invention, however, the CMC 210 provides CMWAY to the burst SRAMs 300 and 302. In this manner, the appropriate way of the burst SRAMs 300 or 302 is then selected not by enabling one bank or another as would be the case in FIG. 3B, but instead by using a single address line. This cuts in half the number of chips required for a two-way set-associative cache.</p><p>A further advantage is that should the way prediction logic in the CMC 210 used to generate CMWAY be incorrect, no delay is necessary for disabling the first bank 310 of FIG. 3B, and then enabling the second bank 320. Instead, CMWAY can simply be changed to the appropriate way and the address restrobed, with no wait states need to avoid bus contention as could occur between the two ways of the banks 310 and 320 of FIG. 3B. In prior art systems, the output enables of the first bank 310 would have to be deselected and then the second bank 320 output enables selected after an appropriate delay, thus adding wait states to the cache operation.</p><p>One problem with using CMWAY as the way selection line is that the index cannot be strobed into the burst SRAMs 300 and 302 until CMWAY is valid. In prior systems as shown in FIG. 3B, the entire index PA 17:3! was strobed into both banks 310 and 320, and then the appropriate COE0* or COE1* would be used to select between one way or the other. Using such a two-bank system, the way selection could occur very late in the cache memory read or write cycle, well after the address strobe. Using the single-bank two-way cache as shown in FIG. 3A, however, CMWAY must be selected by the time an address strobe signal PADS* from the processor 200 occurs.</p><p>This means that most-recently-used way selection algorithms are not appropriate. Using such an algorithm, CMWAY would not be available until after the tag RAMs 364 and 366 in the CMC 210 had been strobed with PADS*. But by that time, the selection of CMWAY would be too late, and a wait state would always be necessary.</p><p>According to the invention, instead of using most-recently-used way prediction or no prediction, the appropriate way is predicted based on either the last code read operation or the last code or data read operation. This is not based on the memory address PA asserted by the microprocessor 200, so such prediction can be provided as CMWAY before the microprocessor 200 asserts PADS*.</p><p>Logical Blocks of the CMC</p><p>Turning to FIG. 3C, logical blocks implemented within the CMC 210 are shown. The state machines and other related circuitry of these various blocks is discussed below as appropriate. A memory interface 350, a PCI bus interface 352, and a processor interface 354 are all coupled in a delta configuration by queues 356, 358, and 360. Further, glue logic 362 communicates with the PCI interface 352 and the memory interface 350 and provides signals to the microprocessor interface 354. The memory interface 350 couples the CMC 210 with the memory array 214, the PCI interface 352 couples the CMC 210 with the PCI bus, and the microprocessor interface 354 connects the CMC 210 to the microprocessor 200.</p><p>The processor interface 354 is of principal interest, because it controls the L2 cache 208 through a number of submodules, including the tag RAMs 364 and 366 coupled to a tag RAM controller module 368. The tag RAM controller module 368 is not a separate physical part, but is instead a module implemented in the application specific integrated circuit of the CMC 210. The tag RAM controller module 368 communicates various signals with an L2 cache controller module 370. The L2 cache controller module 370 communicates with a CPU cycle tracking module 372 that tracks the CPU cycles as is well known to the art, and further communicates with a processor address control module and L1 cache interface 374.</p><p>The CPU cycle tracking module 372 includes a number of state machines for tracking system operation, including a processor state machine, which provides signals indicative of the current type of cycle running in the processor 200 and a CPU request queue state machine, which tracks outstanding processor cycle requests. It also includes a memory read state machine, which tracks processor to memory reads. The memory read state machine tracks both burst and non-burst memory reads, and if a read has been committed to the memory system through the queue 360, and it is then backed off by assertion of a processor backoff signal PBOFF* to the microprocessor 200, a standard microprocessor signal in the Pentium\u00ae, the memory read state machine tracks that backed off memory cycle and recognizes that cycle when the microprocessor 200 restarts it.</p><p>The CPU tracking module 372 also includes a local write state machine that tracks local memory write cycles, discussed below in conjunction with FIG. 12. Also included is a PCI read state machine and a PCI write state machine. A ready state machine generates processor PRDY* and PBRDY* signals, only the latter of which is used when the processor 200 is a Pentium\u00ae processor. Finally, the CPU cycle tracking module 372 further includes control logic for the data buffers 212 and 213.</p><p>Turning to FIG. 3D, the principal logic of interest is in the L2 cache controller 370. Included in this module is a read hit module 380, discussed below in conjunction with FIG. 8, which tracks L2 cache 208 read hits. Also contained is an L2 writeback module 382, which tracks writebacks of the L2 cache 208 to the memory array 214, as discussed below in conjunction with FIG. 10. Also included are allocate data and tag modules 384, which are responsible for performing allocate cycles to the L2 cache 208 and also for allocating tags in the tag RAMs 364 and 366. This logic is discussed below in conjunction with FIGS. 14 and 17. The L2 cache control module 370 also contains snoop tracking module 386 for tracking the states of both L1 and L2 snoops, and a locked cycle module 388. The implementation of the modules 386 and 388 is well known to the art, and any changes will be readily apparent from the discussion of the other logic implemented in the L2 cache control module 370.</p><p>In the discussion that follows, an effort has been made to focus on various signals most pertinent to various aspects of the invention. To that end, for clarity, certain states and state machines have been omitted, as has the generation of certain signals and the use of certain signals as inputs to various gates.</p><p>Specifically, the following assumptions are made in the discussion that follows. All memory cycles are cachable, all caches are implemented as writeback rather than write-through caches, all writes are to local memory rather than to the PCI bus, all memory locations are writebackable, all of the queues 356, 358, and 360 are empty, there is no write-protected memory, reset logic has been omitted, snoop logic has been omitted, flush logic has been omitted, locked cycles are excluded, and the generation of well known signals has been omitted. Further, all caches are on. Inclusion of these alternatives into the disclosed logic can be readily performed by those skilled in the art.</p><h4>Way Selection Circuitry</h4><p>Turning to FIGS. 4A-4C, the circuitry for generating CMWAY is shown. CMWAY is provided by a multiplexer 400, which is switched by a new processor cycle available and valid signal NCV, discussed below in conjunction with FIGS. 27A-27C. NCV is true at the start of each new processor operation. When NCV is true, or high, CMWAY is provided by an allocation way signal ALLOCWAY<sub>--</sub> 1. When NCV is false, the multiplexer 400 provides CMWAY from the output of a second multiplexer 402.</p><p>The select input of the multiplexer 402 is provided by a synchronous cache address strobe signal SYNC<sub>--</sub> CADS. SYNC<sub>--</sub> CADS is true in synchronization with the system clock CLK whenever the cache address strobes are being asserted. When SYNC<sub>--</sub> CADS is false, the multiplexer 402 provides a last read way signal LASTRDWAY on its zero input to the one input of the multiplexer 400. LASTRDWAY reflects either the way of the last code read or the way of the last code or data read, depending which mode is enabled. When SYNC<sub>--</sub> CADS is true, the multiplexer 402 provides a signal from the Q output of a flip-flop 404 to the one input of the multiplexer 400. The flip-flop 404 is clocked by a system clock signal CLK, typically 50 MHz, and as its D input receives the output of an OR gate 406, which receives as inputs a number of single-bank way signals D<sub>--</sub> ALLOCD<sub>--</sub> SBWAY (see FIG. 14), D<sub>--</sub> L2<sub>--</sub> SBWAY (see FIG. 10), D<sub>--</sub> RDHIT<sub>--</sub> SBWAY (see FIG. 8), D<sub>--</sub> REQ<sub>--</sub> SBWAY (see FIG. 19), D<sub>--</sub> LOCWR<sub>--</sub> SBWAY (see FIG. 12). These signals are provided by various other logical blocks in the CMC 210, and will be further described below. To summarize, however, each of these blocks when active drives the appropriate way of CMWAY. These signals are provided by these blocks when the actual cache way is known, whereas LASTRDWAY and ALLOCWAY<sub>--</sub> 1 are provided respectively by the way prediction logic and the line allocation logic in the CMC 210.</p><p>SYNC<sub>--</sub> CADS is provided by a flip-flop 408 that is clocked by CLK and as a D input receives an input D<sub>--</sub> SYNC<sub>--</sub> CADS, which is provided by the output of an OR gate 410. The inputs of the OR gate 410 include D<sub>--</sub> RDHIT<sub>--</sub> CADS (see FIG. 8), D<sub>--</sub> L2WB<sub>--</sub> CADS (see FIG. 10), D<sub>--</sub> ALLOCD<sub>--</sub> CADS (see FIG. 14), D<sub>--</sub> REQ<sub>--</sub> CADS (see FIG. 19), and D<sub>--</sub> LOCWR<sub>--</sub> CADS (see FIG. 12). These signals are again provided by various blocks of the CMC 210 discussed below, and are generated by state machines that determine when to strobe the cache address strobe to the burst SRAMs 300 and 302.</p><p>Of note, a number of signals have been omitted. For example, the CMC 210 includes locked cycle logic as well as snooping logic which also may generate corresponding SBWAY and CADS signals. The implementation of such blocks is well known to the art of cache design, and one skilled in the art would readily understand from the following disclosure how to implement the SBWAY and CADS signals out of these blocks.</p><p>Also shown in FIGS. 4A-4C is circuitry used to generate LASTRDWAY. This signal is synchronized to the system clock by a flip-flop 412, which as a D input receives the output of a multiplexer 414. When the select line of the multiplexer 414 is high, a signal RDHITB<sub>--</sub> REQ (discussed in conjunction with FIGS. 5A-5F) indicating a read hit to way 1 (also called way B), is provided to the flip-flop 412. When the select input to the multiplexer 414 is low, the output of a multiplexer 416 is selected instead. When the select input of the multiplexer 416 is low, LASTRDWAY is provided through feedback to the multiplexer 414 zero input. When the select input of the multiplexer 416 is high, ALLOCWAY<sub>--</sub> 1 is provided to the zero input of the multiplexer 414.</p><p>The select input of the multiplexer 414 is driven by the output of an AND gate 418, which as inputs receives a read way hit true signal RDHIT<sub>--</sub> REQ, discussed below in conjunction with FIGS. 5A-5F. As a second input, the AND gate 418 receives the output of an OR gate 420, which as inputs receives the inverse of a processor data/code signal PDC, as well as a registered signal S<sub>--</sub> PREDLASTDATA, an I/O register signal set by startup software, which when true indicates that way prediction is based on both last code and data reads, rather than just last code reads.</p><p>The multiplexer 416 select input is driven by an AND gate 442, which as inputs receives a line allocation request signal ALLOC<sub>--</sub> REQ, discussed in conjunction with FIGS. 5A-5F, as well as the output of the OR gate 420. ALLOC<sub>--</sub> REQ becomes true when a line must be allocated in the cache, either because of a write to an invalid line, a write to a valid line that is a tag miss, or a read tag miss.</p><p>The output of the OR gate 420 is true when either code and data reads are to be used for way prediction, or when a code read is occurring. The AND gates 418 and 422 then select the appropriate way prediction, which is the last read way on a read hit request or the line allocation way on an allocation request.</p><p>ALLOCWAY<sub>--</sub> 1 is provided by the output of an OR gate 424, which as inputs receives a way B match signal T<sub>--</sub> MATCHB as well as the output of an AND gate 426. The AND gate 426 receives as inputs a way A match signal T<sub>--</sub> MATCHA and the output an XOR gate 428. T<sub>--</sub> MATCHA and T<sub>--</sub> MATCHB are true when the label being output from the appropriate tag RAM 364 or 366 is equal to the label being input. The XOR gate 428 receives as inputs two least recently used signals R<sub>--</sub> LRUQA and R<sub>--</sub> LRUQB, which are provided as outputs of the tag RAMs 364 and 366 in the CMC 210. Those tag RAMs 364 and 366 are discussed below in conjunction with FIG. 28. As an ultimate result, ALLOCWAY<sub>--</sub> 1 either selects way 0 if there is a match to way A, way 1 if there is a match to way B, or the least recently used way otherwise. This is the appropriate way to allocate. If a tag match, of course one should refill to that line and if no match, one should allocate to the least recently used way.</p><p>ALLOCWAY<sub>--</sub> 1 is also latched through the one input of a multiplexer 430, whose output is provided as the D input of a CLK clocked flip-flop 432. The Q output of flip-flop 448 is provided as a latched allocate way signal P<sub>--</sub> ALLOCWAY. The multiplexer 432 select input is driven by ALLOC<sub>--</sub> REQ and when that signal is low, P<sub>--</sub> ALLOCWAY remains unchanged. So on an allocate request, P<sub>--</sub> ALLOCWAY is latched to the value of ALLOCWAY<sub>--</sub> 1.</p><p>In operation, ALLOCWAY<sub>--</sub> 1 provides either the way to which the tag RAMS 364 and 366 indicate a match, or if no match, the way to which an allocate cycle should write data. So, on a valid new cycle indicated by NCV, CMWAY is provided by ALLOCWAY<sub>--</sub> 1. This is appropriate, because NCV immediately follows the standard processor address strobe PADS, so if CMWAY is strobed in by the cache address strobes on the cycle following PADS, it should be strobed to the correct way as actually determined by ALLOCWAY<sub>--</sub> 1.</p><p>When NCV is false, LASTRDWAY is provided as CMWAY when SYNC<sub>--</sub> CADS is false. This is appropriate, because this would be the predicted way. When SYNC<sub>--</sub> CADS is true, the burst SRAMs 300 and 302 are being strobed with CADS*, so when NCV is false and the burst SRAMs 300 and 302 are being strobed with CADS*, the way selected is the appropriate SBWAY signal from the various control blocks of the CMC 210.</p><p>Turning to FIGS. 5A-5F, the circuitry for generating RDHIT<sub>--</sub> REQ, a read hit way signal RDHIT<sub>--</sub> WAY, and ALLOC<sub>--</sub> REQ is shown.</p><p>RDHIT<sub>--</sub> REQ is provided by the output of an OR gate 434, which receives as inputs RDHITA<sub>--</sub> REQ and RDHITB<sub>--</sub> REQ, which are the outputs of an AND gate 436 and an AND gate 438. The AND gate 436 receives as inputs a hit to way A signal T<sub>--</sub> HITA and a cachable read on a valid new cycle signal NCV<sub>--</sub> CACHABLE<sub>--</sub> READ, generated by logic not shown. The AND gate 438 similarly receives a hit to way B signal T<sub>--</sub> HITB and NCV<sub>--</sub> CACHABLE<sub>--</sub> READ. Because all reads are assumed cachable, NCV<sub>--</sub> CACHABLE<sub>--</sub> READ will be true on all reads when NCV is true.</p><p>ALLOC<sub>--</sub> REQ is provided by the output of an AND gate 440, which as inputs receives NCV, a tag miss signal TAGMISS, and a signal indicating a read or write cycle READ<sub>--</sub> OR<sub>--</sub> WRITE<sub>--</sub> CYC, generated by circuitry not shown. ALLOC<sub>--</sub> REQ is thus true on a new cycle which is a memory read or write cycle and is a tag miss. In such case, a line must be allocated in the L2 cache 208.</p><p>RDHIT<sub>--</sub> WAY indicates to which cache way a read has hit, and is provided by the output of a flip-flop 442, which is clocked by CLK and receives as its D input RDHITB<sub>--</sub> REQ from the one input of a multiplexer 444 when the multiplexer select input is driven high by a RDHIT<sub>--</sub> REQ. Otherwise, the multiplexer 444 provides RDHIT<sub>--</sub> WAY to the D input of the flip-flop 508.</p><p>T<sub>--</sub> HITA is provided as the output of an AND gate 446, which receives as inputs a tag RAM way A label comparison signal LABELACMPR (which is the equivalent of T<sub>--</sub> MATCHA) and a tag RAM way A current line valid signal LINEVALIDA, discussed below in conjunction with FIGS. 31A-31J. LABELACMPR is provided by the output of a comparator 448, which as inputs receives tag RAM way A label input signals T<sub>--</sub> LABELDA 10:0!, as well as tag RAM way A label output signals R<sub>--</sub> LABELQA 10:0!, discussed below in conjunction with FIG. 28. Thus, LABELACMPR is true when the label being driven to the way A tag RAM 364 is the same as the label actually in the tag RAM 364. T<sub>--</sub> HITB is generated in a similar way using way B signals with circuitry not shown.</p><p>TAGMISS, which is true on a miss to the tag RAMS 364 and 366, is provided by the output of an AND gate 450, which receives as inputs the inverse of T<sub>--</sub> HITA and T<sub>--</sub> HITB. Similarly, a tag match signal TAGMATCH is provided by the output of an OR gate 452 which receives as inputs LABELACMPR and LABELBCMPR.</p><h4>Cache Output Enables for Dual Bank Cache</h4><p>Turning to FIGS. 6A-6K, circuitry is shown illustrating the generation to the two banks 310 and 320 of the two bank, two way cache of FIG. 3B are shown. In the disclosed embodiment, COE0 is used as the cache output enable for the single-bank two-way cache of FIG. 3A, whereas both COE0 and COE1 are used in the two bank, two way cache.</p><p>COE0 is provided by an OR gate 550, which receives as inputs a predict pipelined way 0 hit signal PIP<sub>--</sub> PRED<sub>--</sub> COE0, a predict last way 0 hit signal LASTWAY<sub>--</sub> PRED<sub>--</sub> COE0, an early single bank output enable signal EARLY<sub>--</sub> 1B<sub>--</sub> COE0, an early way miss signal EARLY<sub>--</sub> WAYMISS<sub>--</sub> COE0, an early cache enable on read hit signal RDHIT<sub>--</sub> EARLY<sub>--</sub> PIP<sub>--</sub> COE0 (see FIGS. 9A-9D), and a synchronized way 0 cache enable signal SYNC<sub>--</sub> COE0. The generation of these signals will be further described below.</p><p>An OR gate 552 provides a corresponding signal COE1, which is the equivalent of COE0, with the exception that EARLY<sub>--</sub> 1B<sub>--</sub> COE1 does not exist. This is because COE1 is not used in the single bank, two way case. Otherwise, all signals merely substitute for corresponding way 0 signals.</p><p>SYNC<sub>--</sub> COE0 is the synchronized combination of COE signals from a number of modules, and is provided by the output of a flip-flop 554, clocked to CLK, whose D input receives the output of an OR gate 556. The OR gate 556 as inputs receives cache output enable way request signals from various of the modules to be discussed below, including a read hit way 0 request signal D<sub>--</sub> RDHIT<sub>--</sub> COE0 (see FIG. 8), an L2 writeback way 0 request signal D<sub>--</sub> L2WB<sub>--</sub> COE0 (see FIG. 10), and a cycle request logic way 0 request signal D<sub>--</sub> REQ<sub>--</sub> COE0 (see FIG. 19). SYNC<sub>--</sub> COE1 is provided in a similar manner by a flip-flop 558 and OR gate 560.</p><p>A delayed COE0 signal COE0<sub>--</sub> DLY is provided by the output of a flip-flop 562, clocked to CLK, which receives the output of an OR gate 564 as its D input. The OR gate 564 receives as its inputs SYNC<sub>--</sub> COE0 and the output of an AND gate 566, which receives as inputs NCV and COE0. A corresponding signal COE1<sub>--</sub> DLY is provided by similar circuitry using a flip-flop 568, an OR gate 569, and an AND gate 570.</p><p>LASTWAY<sub>--</sub> PRED<sub>--</sub> COE0 is provided by the output of an AND gate 572, which receives as inputs an enable two bank COE prediction signal EN<sub>--</sub> 2B<sub>--</sub> PRED<sub>--</sub> COE, the inverse of SYNC<sub>--</sub> COE1, the inverse of an asynchronous COE way 0 disable signal TURN<sub>--</sub> OFF<sub>--</sub> ASYNC<sub>--</sub> COE0, a lengthened address strobe signal P2DLY, the inverse of a processor write signal PWR, and the inverse of LASTRDWAY. P2DLY is provided by the output of an OR gate 573, which as inputs receives a processor address strobe signal PADS, a delayed address strobe signal DLY<sub>--</sub> PADS, and a double delayed address strobe signal DLY2<sub>--</sub> PADS. The corresponding way 1 signal LASTWAY<sub>--</sub> PRED<sub>--</sub> COE1 is provided by similar circuitry out of an AND gate 574, which combines the corresponding way 1 signals. Thus, LASTWAY<sub>--</sub> PRED<sub>--</sub> COE0 is true when way 0 is the predicted way based upon the last read way, and it has not been determined that there is a way miss to way 0.</p><p>EN<sub>--</sub> 2B<sub>--</sub> PRED<sub>--</sub> COE is provided by the output of a negative edge clocked flip-flop 576, which is clocked on the falling edge of CLK. As its D input, it receives the output of an AND gate 577, which receives as inputs the inverse of SYNC<sub>--</sub> COE0, the inverse of SYNC<sub>--</sub> COE1, and a two-way two-bank enabled signal S<sub>--</sub> MODE2BANK, which is accessed via an I/O register.</p><p>EARLY<sub>--</sub> 1B<sub>--</sub> COE0 is provided by the output of an AND gate 578, which as inputs receives the inverse of S<sub>--</sub> MODE2BANK, P2DLY, and the inverse of PWR. EARLY<sub>--</sub> 1B<sub>--</sub> COE0 will only be true in the single bank two-way case, whereas the signal EN<sub>--</sub> 2B<sub>--</sub> PRED<sub>--</sub> COE will only be true in the two bank, two way case.</p><p>DLY<sub>--</sub> PADS is provided by the Q output of a flip-flop 580, clocked by CLK, which receives as its D input PADS. DLY<sub>--</sub> 2PADS is provided by the Q output of a flip-flop 581, which receives as its D input DLY<sub>--</sub> PADS and which is clocked on the negative edge of CLK.</p><p>Turning to FIG. 7, further circuitry for generating the L2 cache 208 output enables is shown. PIP<sub>--</sub> PRED<sub>--</sub> COE is provided by the output of an AND gate 582, which as inputs receives the inverse of TURN<sub>--</sub> OFF<sub>--</sub> ASYNC<sub>--</sub> COE0, P2DLY, and the inverse of PWR. It also as an input receives the Q output of a flip-flop 583 which as its D input receives SYNC<sub>--</sub> COE0, and which is clocked on the negative edge of CLK. PIP<sub>--</sub> PRED<sub>--</sub> COE1 is provided by an AND gate 584 and a flip-flop 585 implemented in a manner similar to PIP<sub>--</sub> PRED<sub>--</sub> COE0, with the way 1 signals substituted for the way 0 signals.</p><p>EARLY<sub>--</sub> WAYMISS<sub>--</sub> COE0 is provided by an AND gate 586 that receives as inputs T<sub>--</sub> HITA and a way miss enable signal EN<sub>--</sub> WAYMISS<sub>--</sub> COE, while EARLY<sub>--</sub> WAYMISS<sub>--</sub> COE1 is provided by an AND gate 587 that receives as its inputs EN<sub>--</sub> WAYMISS<sub>--</sub> COE and T<sub>--</sub> HITB. EARLY<sub>--</sub> WAYMISS<sub>--</sub> COE0 thus goes true immediately after PADS when it is determined that the operation was actually a tag hit to way 0.</p><p>TURN<sub>--</sub> OFF<sub>--</sub> ASYNC<sub>--</sub> COE0 is provided by the output of an AND gate 588, which receives as its inputs T<sub>--</sub> HITB and the output of an OR gate 589. This signal is used to turn off the wrong bank 310 or 320 if it was turned on using way prediction. This is done on a hit to the other way. The OR gate 589 receives as its inputs EN<sub>--</sub> WAYMISS<sub>--</sub> COE and the output of an AND gate 590, which in turn receives as inputs NCV, the inverse of CLK, and S<sub>--</sub> MODE2BANK. TURN<sub>--</sub> OFF<sub>--</sub> ASYNC<sub>--</sub> COE0 goes true when it is determined that the current operation is a way miss to way 0, thus turning off COE0 immediately.</p><p>TURN<sub>--</sub> OFF<sub>--</sub> ASYNC<sub>--</sub> COE1 is provided by the output of an AND gate 591, which receives as its inputs T<sub>--</sub> HITA and the output of an OR gate 592. This OR gate 592 receives as its inputs EN<sub>--</sub> WAYMISS<sub>--</sub> COE and the output of an AND gate 593, which in turn receives as its inputs NCV and the inverse of CLK.</p><p>EN<sub>--</sub> WAYMISS<sub>--</sub> COE is provided by the output of a flip-flop 594, which is clocked on the negative edge of CLK. As its D input, the flip-flop 594 receives the output of an AND gate 595. The AND gate 595 receives as its inputs NCV, the inverse of SYNC<sub>--</sub> COE0, the inverse of SYNC<sub>--</sub> COE1, the inverse of PWR, and S<sub>--</sub> MOD2BANK. EN<sub>--</sub> WAYMISS<sub>--</sub> COE thus enables the logic that determines whether there was a way hit or a way miss, allowing COEs to be switched if necessary.</p><p>A way prediction signal PREDICT<sub>--</sub> WAY1 is provided by the output of a multiplexer 596, whose select input is driven by the output of an OR gate 597. The OR gate 597 receives as its inputs a registered single bank, two way signal SB2WAY and the output of an AND gate 598, which receives as its inputs the inverse of COE0<sub>--</sub> DLY and the inverse of COE1<sub>--</sub> DLY. The zero input of the multiplexer 596 is provided by COE1<sub>--</sub> DLY, while the one input is provided by LASTRDWAY. PREDICT<sub>--</sub> WAY1 provides LASTRDWAY in a single bank system or if both delayed COEs are false, whereas it provides the delayed COE1 otherwise.</p><p>The various timings of COE0 and COE1 are discussed below in conjunction with FIG. 33. When in two-bank, two-way mode, either COE0 or COE1 is predriven based on a prediction of what the next memory operation way will be. If that prediction fails, COE0 and COE1 are switched, allowing access to the proper way, albeit after a wait state.</p><h4>Various Modules of the CMC</h4><p>L2 Cache Read Hit Module</p><p>Turning to FIG. 8, the read hit state machine for a hit to the L2 cache 208 logic is shown. This state machine is clocked to the system clock CLK. Of note, other synchronous way prediction logic related to read hits is included in the cycle request logic discussed below in conjunction with FIGS. 19-27C. Further, many of the signals discussed in conjunction with FIG. 8 are further discussed in conjunction with FIGS. 9A-9D. For clarity, the illustrated state machine omits a number of states and associated signals not necessary to an understanding of the invention. For example, a wait state for pipelined read hits is not shown, as well as states related to locked and snooped cycles. These could of course be added by one skilled in the art of cache system design.</p><p>From state A, when RDHIT<sub>--</sub> REQ is true, the processor is in a T2P cycle of a read operation as indicated by a signal RT2P, a synchronous ready signal SYNC<sub>--</sub> PRDY is true, a signal indicating a zero wait state pipelined read hit REQ<sub>--</sub> PIP<sub>--</sub> RDHIT<sub>--</sub> OWS (see FIGS. 22A-22B) is false, and a L1 linefill signal L1<sub>--</sub> LINEFILL is true, the state machine proceeds to the B state. L1<sub>--</sub> LINEFILL is generated by circuitry not shown, and is true on a code fetch by the processor 200 to its internal cache when that fetch is allocatable. State B is the wait for a pipelined burst read hit state (an L1 cache linefill is always a burst read).</p><p>From state B, the state machine proceeds to state C, which is the first data state of a burst read, and then to state D which is the second data state of a burst read, and then to state E which is the third data state of a burst read. The state machine then proceeds to state A, which, although the idle state, is the fourth data state of a burst read.</p><p>From state A, when RDHIT<sub>--</sub> REQ is true, RT2P is true, a synchronous ready signal SYNC<sub>--</sub> PRDY is true, REQ<sub>--</sub> PIPRDHIT<sub>--</sub> 0WS is true, and L1<sub>--</sub> LINEFILL is true, the state machine proceeds from state A to state C. This is a pipelined burst read with no wait states.</p><p>The first read, whose data is ready in state C, is initiated by logic in the cycle request block to be discussed in conjunction with FIG. 19. That block handles timing critical cycle requests.</p><p>If from state A all the conditions are true for proceeding to state B but L1<sub>--</sub> LINEFILL is false, the state machine proceeds to state G, a wait state on a pipelined read hit where a valid address is not yet in the L2 cache 208. From state G, when the processor is driving its PA outputs as indicated by a signal GOOD<sub>--</sub> PA being true and a latched linefill signal RDHIT<sub>--</sub> LINEFILL is true, the processor proceeds from state G to state B. GOOD<sub>--</sub> PA is true when the processor 200 is providing a valid address on PA, and is generated by circuitry not shown. When GOOD<sub>--</sub> PA is true but RDHIT<sub>--</sub> LINEFILL is false, the state machine proceeds from state G to state E for a single read. From state A to either state B or state G, a set early COE request signal D<sub>--</sub> SET<sub>--</sub> EARLY<sub>--</sub> PIP<sub>--</sub> COE is set true, indicating that the read hit module is requesting the COE logic illustrated in FIGS. 6A-6K and 7A-7G to initiate an early COE.</p><p>From state A, when RDHIT<sub>--</sub> REQ is true, on a T2 read cycle indicated by a signal RT2 (i.e. not a pipelined cycle), and L1<sub>--</sub> LINEFILL is true, the state machine proceeds to state C if a signal REQ<sub>--</sub> RDHIT<sub>--</sub> READY (discussed below in conjunction with FIG. 22) is false, but proceeds to state D if REQ<sub>--</sub> RDHIT<sub>--</sub> READY is true.</p><p>From states A and G, if none of the specified conditions are true, the state machine remains in that particular state on the next clock cycle, or possibly moves to another state not illustrated that is not important here.</p><p>The output variables of the state machine are illustrated below the state diagram. Of particular interest, D<sub>--</sub> RDHIT<sub>--</sub> SBWAY is true when the state machine is in the E state and LASTRDWAY is true, or when the state machine is in the G state and RDHIT<sub>--</sub> WAY is true.</p><p>D<sub>--</sub> RDHIT<sub>--</sub> COE0 is true in states B, C, D, E, or G, as long as RDHIT<sub>--</sub> WAY and 2BANK<sub>--</sub> 2WAY when AND d together are not true. D<sub>--</sub> RDHIT<sub>--</sub> COE1 is true in the same states, but only when RDHIT<sub>--</sub> WAY and 2BANK<sub>--</sub> 2WAY are both true.</p><p>A read hit state machine request cache address strobe signal D<sub>--</sub> RDHIT<sub>--</sub> CADS is true in state E when the processor 200 is a Pentium\u00ae P54C processor, and is true in state G when GOOD<sub>--</sub> PA is true.</p><p>A block cache address strobe request signal RDHIT<sub>--</sub> BLK<sub>--</sub> PADSEN is true in state C or D. A next address request signal D<sub>--</sub> RDHIT<sub>--</sub> PNA is true in the B state.</p><p>Certain states have been omitted from this state machine, including states related to snooping as well as states related to locked writes.</p><p>Turning to FIGS. 9A-9D, circuitry used to generate certain of the signals used by the state machine of FIG. 8 are shown. A latched read hit way signal RDHIT<sub>--</sub> WAY is provided by the output of a flip-flop 600, clocked by CLK, which as its D input receives the output of a multiplexer 602. The multiplexer 602 select input is driven by the output of an OR gate 604, which as inputs receives RDHITA<sub>--</sub> REQ and RDHITB<sub>--</sub> REQ. The one input of the multiplexer 602 is provided by RDHITB<sub>--</sub> REQ, and the zero input is tied to RDHIT<sub>--</sub> WAY. A cache output enable way signal RDHIT<sub>--</sub> COE<sub>--</sub> WAY is provided by the output of an AND gate 606, which receives as inputs RDHIT<sub>--</sub> WAY and 2BANK<sub>--</sub> 2WAY.</p><p>RDHIT<sub>--</sub> EARLY<sub>--</sub> PIP<sub>--</sub> COE0 is provided by the output of an AND gate 608, while the corresponding signal RDHIT<sub>--</sub> EARLY<sub>--</sub> PIP<sub>--</sub> COE1 is provided by the output of an AND gate 610. As inputs, both of these AND gates 608 and 610 receive a signal EARLY<sub>--</sub> PIP<sub>--</sub> COE, while the AND gate 608 also receives the inverse of RDHIT<sub>--</sub> COE<sub>--</sub> WAY, while the AND gate 610 receives that signal in a non-inverted state.</p><p>EARLY<sub>--</sub> PIP<sub>--</sub> COE is provided by the output of a flip-flop 612, clocked on the negative edge of CLK, whose D input is in turn driven by the output of a flip-flop 614, clocked to CLK. As its D input, the flip-flop 614 receives D<sub>--</sub> SET<sub>--</sub> EARLY<sub>--</sub> PIP<sub>--</sub> COE.</p><p>RDHIT<sub>--</sub> LINEFILL is provided by the output of a flip-flop 616, clocked by CLK, which as its D input receives the output of a multiplexer 618. The select input of the multiplexer 618 is provided by RDHIT<sub>--</sub> REQ, the one input is provided by L1<sub>--</sub> LINEFILL, and the zero input is provided by RDHIT<sub>--</sub> LINEFILL.</p><p>SYNC<sub>--</sub> PRDY is provided by the output of a flip-flop 620, clocked to CLK, whose D input is driven by the output of an OR gate 622. As inputs, the OR gate receives D<sub>--</sub> RDHIT<sub>--</sub> PRDY, a signal D<sub>--</sub> LOCWR<sub>--</sub> PRDY (see FIG. 12), and a signal D<sub>--</sub> MEMRD<sub>--</sub> PRDY (generated by circuitry not shown). SYNC<sub>--</sub> PRDY is thus true when these modules have indicated a RDY input to a 486 series processor should be asserted.</p><p>L2 Cache Writeback Module</p><p>Turning to FIG. 10, the state machine for the level two write back module is shown. Again, the state machine is clocked by the system clock CLK, and a number of the signals pertaining to this state machine are further described in conjunction with FIGS. 11A-11C. Beginning from the idle state A, the state machine proceeds to the G state on a writeback request being indicated by a writeback request signal WBREQ being asserted. In all other cases, the state machine stays in state A on its next transition. WBREQ is asserted by various other modules, including the allocation module, L2 snoop module and a flush module. Specifically, WBREQ is asserted when a signal ALLOCD<sub>--</sub> WBREQ is asserted, indicating the allocation module is requesting a writeback. The allocation module is described in conjunction with FIGS. 14 and 17. The L2 snoop module and flush modules are not described, but are well known to those skilled in the art of cache design.</p><p>The WBREQ signal is asserted when the CMC 210 detects the need to writeback a line in the L2 cache 208. From state G, the state machine remains in state G if a signal Q<sub>--</sub> P2MWBFULL is true. This signal is true when the queue 360 between the memory interface 350 and the processor interface 354 is full, and is generated by circuitry not shown. Because multiple lines could be written back sequentially, this queue 360 would likely fill up.</p><p>When Q<sub>--</sub> P2MWBFULL is false, the state machine proceeds through states B, C, D, E, and F, and in states B, C, D, and E, writes from the cache to main memory are posted to the processor to main memory writeback queue 360 by circuitry not shown.</p><p>From state F, the state machine proceeds to state A if there are no more lines to write back. If there are more lines to write back as indicated by a more lines variable MORE<sub>--</sub> LINES, the state machine again proceeds to state G. MORE<sub>--</sub> LINES is set by circuitry not shown to indicate that more modified lines remain to be written back to main memory in the current block that is being written back. Lines in the L2 cache 208 are preferably allocated in blocks of four, so if it is determined that one line within such a block must be written back, the rest of the lines within that block should also be written back to main memory if they have been modified.</p><p>Referring to the state variables, a cache advance request signal D<sub>--</sub> L2WB<sub>--</sub> CADV is true in states B, C, and D, indicating the burst SRAMs 300 and 302 should be advanced in the next cycle. A cache address strobe request signal D<sub>--</sub> L2WB<sub>--</sub> CADS is true in state G, indicating that the address should be strobed into the burst SRAMs 300 and 302. D<sub>--</sub> L2<sub>--</sub> SBWAY is set to L2WB<sub>--</sub> WAY in state G, which will be discussed below. D<sub>--</sub> L2WB<sub>--</sub> COE0 and D<sub>--</sub> L2WB<sub>--</sub> COE1 are set to the negation of L2WB<sub>--</sub> WAY ANDed with 2BANK<sub>--</sub> 2WAY or to L2WB<sub>--</sub> WAY ANDed with 2BANK<sub>--</sub> 2WAY, respectively, in states B, C, D, and E. An L2 writeback acknowledge signal L2WB<sub>--</sub> ACK is true in state B when a current writeback acknowledge signal CURWB<sub>--</sub> ACKED is false. An L2 writeback done signal L2WB<sub>--</sub> DONE is true in state E when MORE<sub>--</sub> LINES is false.</p><p>Turning to FIGS. 11A-11C, the logic for generating L2WB<sub>--</sub> WAY and CURWB<sub>--</sub> ACKED is shown. L2WB<sub>--</sub> WAY is provided as the output of a flip-flop 800, which is clocked by CLK. The D input to the flip-flop 800 is provided by the output of a multiplexer 802, which when the one input is selected provides a writeback way signal WBWAY to the D input of the flip-flop 800. When the zero input of the multiplexer 800 is selected, L2WB<sub>--</sub> WAY is provided to the D input of the flip-flop 800. The select line of the multiplexer 802 is provided by the output of an AND gate 804, which receives as inputs WBREQ and a signal L2WB<sub>--</sub> STATE<sub>--</sub> A which is true when the L2 writeback state machine of FIG. 10 is in state A.</p><p>WBWAY is provided by the output of a multiplexer 806, which selects an allocation data way signal ALLOCD<sub>--</sub> WAY when a select signal ALLOCD<sub>--</sub> WBREQ is true, selects a signal FLSH<sub>--</sub> WBWAY when a signal FLSH<sub>--</sub> WBREQ is true, and selects a signal SNP<sub>--</sub> WAY when a signal SNP<sub>--</sub> WBREQ is true. That is, WBWAY is set to the way selection signal provided by either the allocate, flush, or snoop modules, depending on which of those modules instigated the writeback request. The signals ALLOCD<sub>--</sub> WAY and ALLOCD<sub>--</sub> WBREQ are discussed below in conjunction with FIGS. 14 and 15A-15E, and the flush and snoop signals are similarly developed.</p><p>The signal CURWB<sub>--</sub> ACKED is provided by the output of a flip-flop 808, clocked by CLK, which at its D input receives the output of an OR gate 810. The OR gate 810 receives as inputs L2WB<sub>--</sub> ACK and the output of an AND gate 812. The AND gate 812 receives as inputs the negation of L2WB<sub>--</sub> STATE<sub>--</sub> A and CURWB<sub>--</sub> ACKED.</p><p>Local Memory Write Module</p><p>Turning now to FIG. 12, a state machine illustrating the state transitions in the local memory write module is shown. Note that a number of states have been omitted because they pertain to aspects of the CMC 210 that are not related to the invention. For example, the full state machine includes states for waiting for the queues 358 and 360 between the processor logic and the memory logic or the processor logic and the PCI bus logic to clear. These queues are assumed to always be clear. Similarly, states relating to writes to write protected memory have not been shown, as we have assumed for clarity that all writes are to non-protected memory.</p><p>Turning to FIG. 12, the state machine proceeds from state A to state B when a memory write signal MWR<sub>--</sub> REQ is true and a write hit signal WRHIT<sub>--</sub> REQ is false. MWR<sub>--</sub> REQ, generated by circuitry not shown, is true on a memory write cycle. WRHIT<sub>--</sub> REQ is true on a write cache hit, and is discussed in conjunction with FIGS. 13A-13F. This condition would be true on a memory write that is not a write hit in the L2 cache 208. From state B, the state machine returns to state A on the next cycle when the write is complete, and otherwise remains in state B. On a burst write, indicated by a signal BWRT2 being true, and either MWR<sub>--</sub> REQ or WRHIT<sub>--</sub> REQ being true, the state machine proceeds from state A to state E, the burst write state. When the burst write is completed, as indicated by a signal BURST<sub>--</sub> DONE being true, the state machine returns to the idle state A. BURST<sub>--</sub> DONE is generated by circuitry not shown, and becomes true when all of the data writes within a burst write have been completed. On a pipelined write that is a write hit indicated by a signal WT2P being true, WRHIT<sub>--</sub> REQ being true, and SYNC<sub>--</sub> PRDY being true, the state machine proceeds from state A to state G, the pipelined write hit with a valid new cycle state. From this state, the state machine returns to state A. On a pipelined write hit in which SYNC<sub>--</sub> PRDY is not true, the state machine proceeds to state H, where the cache tags must be reread from the tag RAM 364 or 366. In this transition, a local write tag chip select signal D<sub>--</sub> LOCWR<sub>--</sub> TAGCS is set to true. If the processor is backed off, indicated by a standard processor backoff signal PBOFF being true, the state machine proceeds from state H back to state A, because the write has been aborted. Otherwise, the state machine proceeds to state I when the address on the processor address bus is not held (as indicated by GOOD<sub>--</sub> PA) and TD is true, or WT2 is true, or WT2P and SYNC<sub>--</sub> PRDY are true. From state I, the state machine returns to state A when T<sub>--</sub> HITVALID is true and TAGHIT is true, indicating the tags have been updated.</p><p>Turning to the state variables, a block cache chip select way 0 signal D<sub>--</sub> LOCWR<sub>--</sub> BLK<sub>--</sub> CCS0 is true in state G when a way signal LOCWR<sub>--</sub> WAY is true, and in state H when the next state is going to be state I and LOCWR<sub>--</sub> WAY is true. A block cache chip select way 1 signal D<sub>--</sub> LOCWR<sub>--</sub> BLK<sub>--</sub> CCS1 is true in the same states as D<sub>--</sub> LOCWR<sub>--</sub> BLK<sub>--</sub> CCS0, with the exception that the inverse of LOCWR<sub>--</sub> WAY is used. D<sub>--</sub> LOCWR<sub>--</sub> SBWAY is true in the same states as D<sub>--</sub> LOCWR<sub>--</sub> BLK<sub>--</sub> CCS0. An assert ready signal D<sub>--</sub> LOCWR<sub>--</sub> PRDY is true in state B when a memory write has been posted to the queue 360 by circuitry not shown, as indicated by a posted signal POSTED, and in state E when BURST<sub>--</sub> DONE is not true and a signal BURST2 is true, which indicates two writes of a burst write have been completed in state G, or in state I, when the next state is going to be the idle state A. An assert BRDY signal D<sub>--</sub> LOCWR<sub>--</sub> PBRDY is true in the same states as D<sub>--</sub> LOCWR<sub>--</sub> PRDY, with the exception that in the E state, the signal is true whenever BURST<sub>--</sub> DONE is false.</p><p>A cache advance request signal D<sub>--</sub> LOCWR<sub>--</sub> CADV is true in the E state when BURST<sub>--</sub> DONE is false and LOCWR<sub>--</sub> WRHIT is true. A cache address strobe request signal D<sub>--</sub> LOCWR<sub>--</sub> CADS is true in state G or state H when the next state is going to be state I. D<sub>--</sub> LOCWR<sub>--</sub> CWE0 is set to the inverse of a cache write enable way signal CWE<sub>--</sub> WAY when in state E with BURST<sub>--</sub> DONE false and LOCWR<sub>--</sub> HIT true, when in state G, or when in state I where the next state will be state A. D<sub>--</sub> LOCWR<sub>--</sub> CWE1 is set during the same states as D<sub>--</sub> LOCWR<sub>--</sub> CWE0, with the exception that it is set to CWE<sub>--</sub> WAY rather than the inverse of that signal.</p><p>A request tag chip select signal D<sub>--</sub> LOCWR<sub>--</sub> TAGCS is true in state H. A tag request signal LOCWR<sub>--</sub> PTAGREQ is true in state H when the next state is going to be state I.</p><p>From states A, B, E, H, and I, the state machine, on transition conditions other than those specified, either remains in its present state or moves to states not shown that are not particularly pertinent here.</p><p>Turning to FIGS. 13A-13F, logic is shown to provide certain of the signals discussed in the state machine of FIG. 12. TAGHIT is provided by the output of an OR gate 850, which, as inputs, receives T<sub>--</sub> HITA and T<sub>--</sub> HITB. It thus goes true on a tag hit. WRHIT<sub>--</sub> REQ is provided by the output of an OR gate 852, which receives as its inputs two write hit signals WRHITA<sub>--</sub> REQ and WRHITB<sub>--</sub> REQ discussed below in conjunction with FIGS. 20A-20K. It thus goes high on a write hit. CWE<sub>--</sub> WAY is provided by the output of an AND gate 854 which receives as inputs LOCWR<sub>--</sub> WAY and 2BANK<sub>--</sub> 2WAY. REQ<sub>--</sub> CWE<sub>--</sub> WAY is provided by the output of an AND gate 856, which receives as inputs WRHITB<sub>--</sub> REQ and 2BANK<sub>--</sub> 2WAY. LOCWR<sub>--</sub> WAY is provided by the output of a flip-flop 858, clocked by CLK, whose D input is provided by the output of a multiplexer 860. The zero input of the multiplexer 860 is provided by LOCWR<sub>--</sub> WAY, while WRHITB<sub>--</sub> REQ is provided as the one input to the multiplexer 860. The multiplexer 860 select input is true when the local write state machine of FIG. 12 is in state A.</p><p>LOCWR<sub>--</sub> WRHIT is provided by the output of a flip-flop 862, clocked by CLK, whose D input receives the output of a multiplexer 864. The zero input of the multiplexer 864 is provided by LOCWR<sub>--</sub> WRHIT, while the one input is provided by WRHIT<sub>--</sub> REQ. As with the multiplexer 860, the multiplexer 864 select input is true when the local write state machine is in state A.</p><p>Cache Data and Tag Ram Allocation Modules</p><p>Turning to FIG. 14, the L2 cache 208 data ram allocation state machine is shown. This state machine controls line allocation in the burst SRAMs 300 and 302. Again, it is clocked by CLK. For clarity, the illustrated state machine omits some states and associated signals not necessary to an understanding of the invention. For example, a wait state that waits for the memory interface to be ready is not shown. These could of course be added by one skilled in the art of cache system design.</p><p>A number of the signals discussed in conjunction with FIG. 14 are further described in FIGS. 15A-18. From all states except state F, the state machine remains in its present state if the indicated transition conditions are not met.</p><p>From state A, the idle state, the state machine proceeds to state D when a start allocation signal START<sub>--</sub> ALLOC is true, which indicates that start of an allocation cycle. when a latched match signal ALLOCT<sub>--</sub> LAT<sub>--</sub> MATCH is false, which indicates that a tag allocation state machine has indicated a tag miss, and when a latched cache line modified signal ALLOCT<sub>--</sub> LAT<sub>--</sub> CLINEMOD is true, indicating that some of the lines in the current way are modified, and thus need to be written back. In state D, a writeback of the L2 cache is instigated in the L2 writeback module of FIG. 10, and when that writeback is acknowledged by L2WB<sub>--</sub> ACK true, the state machine proceeds to state E. At state E, the state machine waits for the writeback to be completed as indicated by L2WB<sub>--</sub> DONE true, and then the state machine proceeds to state F. From state F, if there are no more lines to write back, as indicated by ALLOCD<sub>--</sub> WBLINES being false, the state machine proceeds to state C.</p><p>At state C, all writebacks have been completed, so the allocation state machine proceeds to allocate the line. When a cache write enable signal ALLOCD<sub>--</sub> CWE, provided true by a memory read module when a memory request from the memory array 214 is available, goes true, this indicates that the appropriate CWE signals are asserted to the cache, so the state machine proceeds to state K where it remains until the memory read--i.e., the allocation--is completed, as indicated by a memory read done signal MEMRD<sub>--</sub> BDONE, provided by the memory read module. The state machine then proceeds from state K to state A. From state C, if the memory read is aborted for any reason, as indicated by a signal MEMRD<sub>--</sub> ABORTED, the state machine proceeds from state C to state A.</p><p>MEMRD<sub>--</sub> BDONE and MEMRD<sub>--</sub> ABORTED are generated by a memory read state machine that is not shown. MEMRD<sub>--</sub> BDONE goes true when a burst memory read has been completed. MEMRD<sub>--</sub> ABORTED goes true when the memory read stat machine aborts a memory read, such as on a snoop cycle.</p><p>The state machine goes directly from state A to state C on the start of an allocation cycle as indicated by START<sub>--</sub> ALLOC, but where the tag allocation state machine indicates a match as indicated by ALLOCT<sub>--</sub> LAT<sub>--</sub> MATCH and there are no lines to writeback, as indicated by ALLOCD<sub>--</sub> WBLINES being false. In such a case, state C directly proceeds with the read allocation.</p><p>In all other cases on START<sub>--</sub> ALLOC, the state machine proceeds from state A to state H, where the state machine then goes to state A on MEMRD<sub>--</sub> ABORTED, or to state I when a memory read is completed, as indicated by MEMRD<sub>--</sub> BDONE. In state I, writebacks are requested of the L2 writeback module, and when acknowledged, as indicated by L2WB<sub>--</sub> ACK, the state machine proceeds to state J. From state J, the state machine proceeds to state A when L2WB<sub>--</sub> DONE is true, indicating the writeback has been completed.</p><p>Note from state F, the state machine proceeds to state H if there are additional lines to writeback, as indicated by ALLOCD<sub>--</sub> WBLINES. State H would be entered, for example, if the processor 200 needed to read allocate a single line in a block, but the CMC 210 had to write back all four lines of that block because they were modified. For example, if the second line of the block was to be read allocated, the state machine would first proceed to state E, where the second line would be written back in the L2 cache 208 to the memory array 214, then to state H, where that line would be allocated from the memory array 214 into the L2 cache 208. The state machine would then proceed to state J, where the remaining three lines of the block would be written back from the L2 cache 208 to the memory array 214. Thus, the H state is entered when multiple lines must be written back with an intervening allocate. State H is specifically entered to perform an allocate when write backs will be needed after the read is done, while state C is entered for an allocate when no more write backs will be needed after the read is done. That is, state C would be entered, for example, if the remaining lines of the block had not been modified.</p><p>The equations for the state variables are indicated below the state machine. A latch write strobe signal D<sub>--</sub> LATCH<sub>--</sub> WRALLOC, which indicates that a write allocation should be performed, is true in all cases except in state A when an allocation is not starting as indicated by START<sub>--</sub> ALLOC being false, in state J when a writeback is completed as indicated L2WB<sub>--</sub> DONE, and in state K when a memory read is completed as indicated by MEMRD<sub>--</sub> BDONE.</p><p>An allocate module request backoff signal D<sub>--</sub> ALLOCD<sub>--</sub> PBOFF is true in state A when a signal ALLOCT<sub>--</sub> LAT<sub>--</sub> WRALLOC<sub>--</sub> REQ is true, indicating the tag allocation state machine discussed below in conjunction with FIG. 17 has requested a write allocation, and true in states C, D, E, and F when a latched write allocate signal LAT<sub>--</sub> WRALLOC is true, and in states H, I, J, and K when MEMRD<sub>--</sub> BDONE is false and either LAT<sub>--</sub> WRALLOC is true or the processor 200 is idle (i.e., a Ti state) as indicated by a signal PROCESSOR<sub>--</sub> IDLE which is true when the processor is in an idle state.</p><p>A cache address strobe request signal D<sub>--</sub> ALLOCD<sub>--</sub> CADS is true in states H and C when an address has not been driven to the burst SRAMs 300 and 302 as indicated by a signal GOOD<sub>--</sub> ALLOCA<sub>--</sub> IN<sub>--</sub> CRAM being false (see discussion of FIGS. 27A-27C), GOOD<sub>--</sub> PA is true, and a synchronous cache address strobe signal SYNC<sub>--</sub> CADS is false.</p><p>D<sub>--</sub> ALLOCD<sub>--</sub> SBWAY is set to ALLOCD<sub>--</sub> WAY in states C and H when GOOD<sub>--</sub> ALLOCA<sub>--</sub> IN<sub>--</sub> CRAM is false, GOOD<sub>--</sub> PA is true, and SYNC<sub>--</sub> CADS is false.</p><p>An allocation state machine idle signal ALLOCD<sub>--</sub> IDLE is true in state A when START<sub>--</sub> ALLOC is false.</p><p>ALLOCD<sub>--</sub> WBREQ is true in states D and I when the processor address and processor data bus are in an appropriate state for a writeback as indicated by a signal PA<sub>--</sub> PD<sub>--</sub> OK<sub>--</sub> FOR<sub>--</sub> WBREQ. It is true when the state machine is requesting the L2 writeback state machine of FIG. 10 to write back a line of the L2 cache.</p><p>ALLOCD<sub>--</sub> HOLD<sub>--</sub> TAGUPD is true in state D and in state E when a signal SEL<sub>--</sub> WBA<sub>--</sub> TO<sub>--</sub> PAOUT<sub>--</sub> DLY is true. This latter signal is created by the L2 writeback state machine of FIG. 10 by logic not shown, and is a synchronous, delayed signal that is true when that state machine still has write operations to perform of the currently pending writeback.</p><p>Turning to FIGS. 15A-15E, circuitry for generating various of the above mentioned signals is shown. A series of writeback needed line indicator signals ALLOCD<sub>--</sub> WBLINES 3:0! are provided as the output of a series of circuits illustrated by a multiplexer 900, which as a select input receives a signal ALLOCD<sub>--</sub> STATE<sub>--</sub> D which is true when the allocation state machine of FIG. 14 is in the D state. When the one input of the multiplexer 900 is selected, the output of an AND gate 902 is driven as ALLOCD<sub>--</sub> WBLINES 3:0!. The inputs of the AND gate 902 are a series of cache line mask signals CLINMASK 3:0! and latched modified bit signals ALLOCT<sub>--</sub> LAT<sub>--</sub> MODLINES 3:0!, which are line modified outputs of the tag RAM 364 or 366 as provided by the tag allocation state machine of FIG. 17. When the multiplexer 900 zero input is selected, the output of an AND gate 904 is provided as ALLOCD<sub>--</sub> WBLINES 3:0!. The AND gate 904 ANDs together ALLOCT<sub>--</sub> LAT<sub>--</sub> MODLINES 3:0! with the inverted CLINMASK 3:0! signals. ALLOCD<sub>--</sub> WBLINES is provided as the output of an OR gate 905, which ORs together all of the individual lines of ALLOCD<sub>--</sub> WBLINES 3:0!.</p><p>PA<sub>--</sub> PD<sub>--</sub> OK<sub>--</sub> FOR<sub>--</sub> WBREQ is provided by an AND gate 906, which receives as inputs GOOD<sub>--</sub> PA, a processor hold signal PAHOLD generated by logic not shown, and the inverse of a hold line writeback signal ALLOCT<sub>--</sub> HOLD<sub>--</sub> CLINWB, which when true indicates that the tag allocation state machine is holding up the line writebacks.</p><p>ALLOCD<sub>--</sub> WAY is provided by the Q output of a flip-flop 908, clocked by CLK, which as its D input receives the output of a multiplexer 910, an unlatched signal D<sub>--</sub> ALLOCD<sub>--</sub> WAY. The multiplexer 910 has select inputs ALLOC<sub>--</sub> REQ and ALLOCD<sub>--</sub> STATE<sub>--</sub> A. When ALLOCD<sub>--</sub> STATE<sub>--</sub> A is false, indicating the data allocation state machine is not in the idle state, ALLOCD<sub>--</sub> WAY is provided as the output of the multiplexer 910. Otherwise, when ALLOC<sub>--</sub> REQ is true, ALLOCWAY<sub>--</sub> 1 is provided as the output of the multiplexer 910, and when ALLOC<sub>--</sub> REQ is false, P<sub>--</sub> ALLOCWAY is provided as the output of the multiplexer 910. Thus, when an allocation is requested, the allocation way signal is chosen, whereas when an allocation is not requested, allocation way prediction is selected.</p><p>LAT<sub>--</sub> WRALLOC is provided as the output of a multiplexer 912, which receives as a select input the output of a flip-flop 914, clocked by CLK, with D<sub>--</sub> LATCH<sub>--</sub> WRALLOC as its D input. When the one input is selected on the multiplexer 912, LAT<sub>--</sub> WRALLOC is provided to itself. When the zero input is selected, ALLOCT<sub>--</sub> LAT<sub>--</sub> WRALLOC<sub>--</sub> REQ is provided as LAT<sub>--</sub> WRALLOC.</p><p>START<sub>--</sub> ALLOC is provided by the output of an OR gate 916, which has as inputs a start of a pipelined allocate signal START<sub>--</sub> PIP<sub>--</sub> ALLOC, and a start of a non-pipelined allocate signal START<sub>--</sub> NPIP<sub>--</sub> ALLOC.</p><p>START<sub>--</sub> NPIP<sub>--</sub> ALLOC is provided by the output of a flip-flop 918, clocked by CLK and receiving as a D input a non-pipelined request signal NPIP<sub>--</sub> ALLOC<sub>--</sub> REQ. This signal is provided by an AND gate 920, which as inputs receives ALLOC<sub>--</sub> REQ as well as the output of an OR gate 922. The OR gate 922 receives as inputs the inverse of T2P, as well as a signal SYNC<sub>--</sub> ENDPCYC<sub>--</sub> NOSWB, generated by circuitry not shown, which indicates this is not a snoop writeback cycle.</p><p>START<sub>--</sub> PIP<sub>--</sub> ALLOC is provided by an AND gate 924, which receives as inputs the SYNC<sub>--</sub> ENDPCYC<sub>--</sub> NOSWB signal as well as the output of a flip-flop 926, which is clocked by CLK. The flip-flop 926 receives as its D input the output of an AND gate 928, which receives as inputs an inverted allocation tag updated abort signal ALLOCT<sub>--</sub> TAGUPD<sub>--</sub> ABORTED, the inverse of SYNC<sub>--</sub> ENDPCYC<sub>--</sub> NOSWB, and the output of an OR gate 930. The OR gate 930 has as inputs the Q output of the flip-flop 926 and the output of an AND gate 932, which receives as inputs ALLOC<sub>--</sub> REQ and T2P. ALLOCT<sub>--</sub> TAGUD<sub>--</sub> ABORTED goes true when a tag update is aborted because of an aborted memory read, and is provided by the tag state machine.</p><p>Turning to FIGS. 16A and 16B, further circuitry for generating the allocation module signals is shown. D<sub>--</sub> ALLOCD<sub>--</sub> BLK<sub>--</sub> CCS0 is provided by the output of an AND gate 934, while D<sub>--</sub> ALLOCD<sub>--</sub> BLK<sub>--</sub> CCS1 is provided by the output of an AND gate 936. Both the AND gates 934 and 936 receive as inputs an allocate in process signal D<sub>--</sub> ALLOCD<sub>--</sub> IP, and the AND gate 934 also receives D<sub>--</sub> ALLOCD<sub>--</sub> WAY, whereas the AND gate 936 receives as an input the inverse of that signal.</p><p>The signal D<sub>--</sub> ALLOCD<sub>--</sub> IP is provided by the output of an OR gate 938, which has as inputs START<sub>--</sub> PIP<sub>--</sub> ALLOC, START<sub>--</sub> NPIP<sub>--</sub> ALLOC, NPIP<sub>--</sub> ALLOC<sub>--</sub> REQ, and the inverse of ALLOCD<sub>--</sub> IDLE. D<sub>--</sub> ALLOCD<sub>--</sub> IP is thus true when the data allocation state machine is not idle.</p><p>Turning to FIG. 17, the tag allocation state machine is shown. This state machine controls the cycle timing of allocations within the tag RAMs 364 and 366. From all states but state E, the state machine remains in its present state when the illustrated transition conditions are not met.</p><p>Beginning at state A, the idle state, the state machine proceeds to state B when ALLOC<sub>--</sub> REQ is true. In state B, if a memory read is aborted, as indicated by MEMRD<sub>--</sub> ABORTED, the state machine proceeds back to state A, setting ALLOCT<sub>--</sub> TAGUPD<sub>--</sub> ABORTED to true.</p><p>In state B, ALLOCT<sub>--</sub> HOLD<sub>--</sub> PA<sub>--</sub> IF<sub>--</sub> REQACK is set to true. From state B, when a memory read module acknowledge read request signal M<sub>--</sub> PREQACK becomes true, the state machine proceeds from state B to state C, setting D<sub>--</sub> ALLOCT<sub>--</sub> TAGCS true, which requests the appropriate tag RAM 364 or 366 chip select be enabled. In state C, D<sub>--</sub> ALLOCT<sub>--</sub> TAGCS is set to true and the state machine proceeds to state D when GOOD<sub>--</sub> PA is true, when processor address hold is true as indicated by PAHOLD, and when ALLOCD<sub>--</sub> HOLD<sub>--</sub> TAGUPD, provided by the L2 cache 208 allocation state machine of FIG. 14, is false. On the transition from C to D, ALLOCT<sub>--</sub> HOLD<sub>--</sub> CLINEWB is set true, as is a request tag signal ALLOCT<sub>--</sub> PTAGREQ and a set allocation signal SET<sub>--</sub> P<sub>--</sub> CPUALLOC. These signals hold the data allocation state machine, request a tag, and cause the subsequently written tag to be to the modified state.</p><p>In state D, ALLOCT<sub>--</sub> HOLD<sub>--</sub> CLINWB and SET<sub>--</sub> P<sub>--</sub> CPUALLOC are set true. From state D, the state machine proceeds to state E when T<sub>--</sub> HITVALID becomes true, and from state E, in all cases, the state machine proceeds to state A.</p><p>Turning to FIG. 18, circuitry used by the state machines of FIGS. 14 and 17 is shown. ALLOCT<sub>--</sub> LAT<sub>--</sub> MATCH is provided by the output of a flip-flop 940, which is clocked by CLK. The D input to the flip-flop 940 is provided by the output of multiplexer 942, which as its one input receives TAGMATCH and as its zero input receives ALLOCT<sub>--</sub> LAT<sub>--</sub> MATCH. The multiplexer 942 receives as its select input ALLOC<sub>--</sub> REQ. ALLOCT<sub>--</sub> LAT<sub>--</sub> WRALLOC<sub>--</sub> REQ is provided by the output of a flip-flop 944, which is clocked by CLK. As its D input, the flip-flop 944 receives the output of a multiplexer 946, which receives as its one input PWR and as its zero input ALLOCT<sub>--</sub> LAT<sub>--</sub> WRALLOC<sub>--</sub> REQ. The select input of the multiplexer 946 is provided as ALLOC<sub>--</sub> REQ. A latched tag label signal ALLOCT<sub>--</sub> LAT<sub>--</sub> TAGLABEL 10:0! is provided by the output of a series of flip-flops illustrated by a flip-flop 948. The flip-flop 948 receives as its input the output of a multiplexer 950, which receives as its zero input ALLOCT<sub>--</sub> LAT<sub>--</sub> TAGLABEL 10:0!. As its one input, the multiplexer 950 receives the output of a multiplexer 952, which as its one input receives tag label outputs T<sub>--</sub> LABELQB 10:0! and as its zero input receives tag label outputs T<sub>--</sub> LABELQA 10:0!. The multiplexer 950 select input is provided by ALLOC<sub>--</sub> REQ, and the multiplexer 952 select input is provided by a tag allocation signal ALLOCTAG<sub>--</sub> B, discussed below in conjunction with FIGS. 24A-24G. This signal provides the allocation tag B way as true when the allocate module should allocate to that way. It will be appreciated that the flip-flop 948 and the multiplexers 950 and 952 are actually a series of flip-flops and multiplexers sufficient to provide all eleven signals of ALLOCT<sub>--</sub> LAT<sub>--</sub> TAGLABEL 10:0!.</p><p>ALLOCT<sub>--</sub> LAT<sub>--</sub> MODLINES 3:0! are provided by the output of a flip-flop 954, which again represents a series of flip-flops. The flip-flop 954 is clocked by CLK, and receives as its D input the output of the multiplexer 956, which receives as its zero input ALLOCT<sub>--</sub> LAT<sub>--</sub> MODLINES 3:0! and as its one input a series of modified line signals REQ<sub>--</sub> MODLINES 3:0!, which is provided by the request module and is discussed below in conjunction with FIGS. 24A-24G. The select input of the multiplexer 956 is provided as ALLOC<sub>--</sub> REQ.</p><p>ALLOCT<sub>--</sub> LAT<sub>--</sub> CLINMOD is provided by the output of a flip-flop 958, which is clocked by CLK. The D input to the flip-flop 958 is provided by the output of a multiplexer 960, which as its zero input receives ALLOCT<sub>--</sub> LAT<sub>--</sub> CLINMOD. As its one input, the multiplexer 960 receives a cache line modified signal REQ<sub>--</sub> CLINMOD, which is again provided by the request module and is discussed below. The select input of the multiplexer 960 is provided by ALLOC<sub>--</sub> REQ.</p><p>Critical Timing Cycle Request Module</p><p>Turning to FIG. 19, critical cycle request logic is shown. This request logic requests that certain signals be asserted, and is provided by multiplexers rather than through state machines because of tight timing requirements. A multiplexer 1000 provides as outputs signals D<sub>--</sub> REQ<sub>--</sub> PRDY, D<sub>--</sub> REQ<sub>--</sub> PBRDY, D<sub>--</sub> REQ<sub>--</sub> COE0, D<sub>--</sub> REQ<sub>--</sub> COE1, D<sub>--</sub> REQ<sub>--</sub> SBWAY, D<sub>--</sub> REQ<sub>--</sub> CADS, D<sub>--</sub> REQ<sub>--</sub> CADV, and D<sub>--</sub> REQ<sub>--</sub> PNA.</p><p>The multiplexer 1000 is driven according to the cycle type of the processor 200. These cycle types shown are standard for a Pentium\u00ae. On a TD cycle, the multiplexer 1000 provides as its output the output of a multiplexer 1002, on an RT2 (T2 on a read) cycle provides the output of a multiplexer 1004, on a RT2P (T2P on a read) cycle and where SYNC<sub>--</sub> PRDY is true provides the output of a multiplexer 1006, on a burst write cycle indicated by a signal BWRCYC (T2 on a write) provides the output of a multiplexer 1008, and on a WT2 cycle provides the output of a multiplexer 1010.</p><p>The multiplexer 1002 has as select inputs MWR<sub>--</sub> REQ and WRHIT<sub>--</sub> REQ, and as outputs provides the signals indicated that correspond to the output of the multiplexer 1000. The multiplexer 1004 has as its select input RDHIT<sub>--</sub> REQ, and when that signal is false, provides all zeros, but when that signal is true, provides the outputs of a multiplexer 1012, which as its select inputs receives L1<sub>--</sub> LINEFILL and REQ<sub>--</sub> RDHIT<sub>--</sub> READY, which select the indicated signals as outputs. The multiplexer 1006 as its select input receives RDHIT<sub>--</sub> REQ, and when that signal is false, provides all zero outputs. When that signal is true, the output of a multiplexer 1014 is provided as the output of the multiplexer 1006. The multiplexer 1014 has as its select inputs L1<sub>--</sub> LINEFILL and REQ<sub>--</sub> PIPRDHIT<sub>--</sub> 0WS. These again select the indicated signals. The multiplexer 1008 has as its select input the output of an OR gate 1016, which has as inputs the signals MWR<sub>--</sub> REQ and WRHIT<sub>--</sub> REQ. When the output of the OR gate 1016 is false, all zeros are provided as the outputs of the multiplexer 1008. When the output of the OR gate 1016 is true, the indicated signals are provided as the outputs of the multiplexer 1008. The multiplexer 1010 has as its select input the output of an AND gate 1018, which has as inputs NCV and WRHIT<sub>--</sub> TAGUPD. When the output of the AND gate 1018 is false, all zeros are provided as the output of the multiplexer 1010. When the output of the AND gate 1018 is true, the indicated signals are provided as the output of the multiplexer 1010.</p><p>Turning to FIGS. 20A-20K, additional circuitry provided by the request module is shown. A cachable write signal CABLEWR<sub>--</sub> REQ is provided by the output of an AND gate 1020, which receives as its inputs the signals NCV, a standard processor signal PCACHE*, PWR, and a standard processor signal PMIO. WRHITA<sub>--</sub> REQ is provided by the output of an AND gate 1022, which receives as its inputs CABLEWR<sub>--</sub> REQ and T<sub>--</sub> HITA. WRHITB<sub>--</sub> REQ is provided by the output of an AND gate 1024, which receives as its inputs CABLEWR<sub>--</sub> REQ and T<sub>--</sub> HITB.</p><p>A cache way enable match signal D<sub>--</sub> REQ<sub>--</sub> CWE<sub>--</sub> MATCH is provided by the output of an AND gate 1026, which receives as its inputs NCV, PWR, PCACHE*, and a standard processor hit to modified signal PHITM*.</p><p>A cache write enable hit signal D<sub>--</sub> REQ<sub>--</sub> CWE<sub>--</sub> HIT is provided by the output of an AND gate 1028, which receives as its inputs CABLEWR<sub>--</sub> REQ and TD.</p><p>D<sub>--</sub> REQ<sub>--</sub> CWE0 is provided by the output of an OR gate 1030, which receives as its inputs the output of an AND gate 1032 and the output of an AND gate 1034. The AND gate 1032 receives as its inputs D<sub>--</sub> REQ<sub>--</sub> CWE<sub>--</sub> HIT and the output of an OR gate 1036, which receives as its inputs T<sub>--</sub> HITA and the output of an AND gate 1038. The AND gate 1038 receives as its input T<sub>--</sub> HITB and the inverse of 2BANK<sub>--</sub> 2WAY. The AND gate 1034 receives as its inputs D<sub>--</sub> REQ<sub>--</sub> CWE<sub>--</sub> MATCH and the output of an OR gate 1040. The OR gate 1040 receives as its inputs T<sub>--</sub> MATCHA and the output of an AND gate 1042. The AND gate 1042 receives as its inputs the inverse of 2BANK<sub>--</sub> 2WAY and T<sub>--</sub> MATCHB.</p><p>D<sub>--</sub> REQ<sub>--</sub> CWE1 is provided by the output of an OR gate 1044, which receives as its inputs the outputs of an AND gate 1046 and an AND gate 1048. The AND gate 1046 receives as its inputs D<sub>--</sub> REQ<sub>--</sub> CWE<sub>--</sub> HIT, T<sub>--</sub> HITB, and 2BANK<sub>--</sub> 2WAY. The AND gate 1048 receives as its inputs D<sub>--</sub> REQ<sub>--</sub> CWE<sub>--</sub> MATCH, T<sub>--</sub> MATCHB, and 2BANK<sub>--</sub> 2WAY.</p><p>RDHITA<sub>--</sub> REQ is provided by the output of an AND gate 1050, while RDHITB<sub>--</sub> REQ is provided by the output of an AND gate 1052. As inputs, the AND gate 1050 receives T<sub>--</sub> HITA, while the AND gate 1052 receives T<sub>--</sub> HITB, and both the AND gates 1050 and 1052 receive as inputs a cachable read signal CABLERD<sub>--</sub> REQ which is provided by the output of an AND gate 1054. The AND gate 1054 receives as inputs NCV, the inverse of PWR, and PMIO.</p><p>An enable asynchronous read BRDY signal EN<sub>--</sub> ASYNC<sub>--</sub> RDBRDY is provided by the output of an AND gate 1056, which receives as inputs the inverse of PWR and PMIO. An enable asynchronous read RDY signal EN<sub>--</sub> ASYNC<sub>--</sub> RDRDY is provided by the output of an AND gate 1058, which receives as its inputs the inverse of PWR, PMIO, and the inverse of a level one cache allocatable memory location signal L1<sub>--</sub> ALLOCABLE, which is always assumed to be true. Three cache way hit A read enable signals, EN<sub>--</sub> ASYNC<sub>--</sub> RDRDY<sub>--</sub> HITA, EN<sub>--</sub> ASYNC<sub>--</sub> PNA<sub>--</sub> HITA, and EN<sub>--</sub> ASYNC<sub>--</sub> RDBRDY<sub>--</sub> HITA, are provided by the output of an AND gate 1060. These signals are equivalent because, as with a number of the other signals provided by the various modules, certain non-essential signals have been eliminated. That is, for example, EN<sub>--</sub> ASYNC<sub>--</sub> RDRDY generally includes the inverse of L1<sub>--</sub> ALLOCABLE while EN<sub>--</sub> ASYNC<sub>--</sub> RDBRDY does not. Because we have assumed that all memory operations are allocatable in the L1 cache, the signals thus might become equivalent. The inputs to the AND gate 1060 are EN<sub>--</sub> ASYNC<sub>--</sub> RDBRDY and the inverse of PREDICT<sub>--</sub> WAY1. Similar signals for way B are provided by the output of an AND gate 1062, which receives as inputs EN<sub>--</sub> ASYNC<sub>--</sub> RDBRDY and PREDICT<sub>--</sub> WAY1.</p><p>Turning to FIGS. 21A-21D, the creation of further signals is shown. MRD<sub>--</sub> REQ is provided by an AND gate 1064, which receives as its inputs NCV and the output of an OR gate 1066. The OR gate receives as its inputs the output of an AND gate 1068 and the output of an AND gate 1070. The AND gate 1068 receives as its inputs PMIO, the inverse of PWR, and TAGMISS. The AND gate 1070 receives as its inputs PMIO, PWR, PCACHE*, the inverse of the standard processor signal PWT, the inverse of PCD, and TAGMISS. Note that again, write through cycles are generally assumed not allowed for simplicity, but the use of the processor write through signal PWT is here illustrated.</p><p>A memory read line fill signal MRD<sub>--</sub> LF is provided by the output of an OR gate 1072, which receives as its inputs the output of an AND gate 1074 and the output of an AND gate 1076. The AND gate 1074 receives as its inputs the inverse of PWR, the inverse of PCD, and PMIO. The AND gate 1076 receives as its inputs PWR, PMIO, PCACHE*, the inverse of PCD, and the inverse of PWT.</p><p>ALLOC<sub>--</sub> REQ is provided by the output of an AND gate 1078, which receives as its inputs NCV and the output of an OR gate 1080. The OR gate 1080 receives as its inputs the output of an AND gate 1082 and the output of an AND gate 1084. The AND gate 1082 receives as its inputs PMIO, the inverse of PWR, the inverse of PCD, and TAGMISS. The AND gate 1084 receives as its inputs PMIO, PWR, the inverse of PWT, the inverse of PCD, PCACHE*, and TAGMISS.</p><p>A back-off request signal D<sub>--</sub> REQ<sub>--</sub> BOFF is provided by the output of an AND gate 1086, which receives as its inputs NCV, the output of an OR gate 1088, PMIO, PWR, the inverse of PWT, the inverse of PCD, PCACHE*, and TAGMISS. The OR gate 1088 receives as its inputs the inverse of T2P and SYNC<sub>--</sub> PRDY.</p><p>Turning to FIGS. 22A-22B, further signals produced by the request block are shown. REQ<sub>--</sub> RDHIT<sub>--</sub> READY is provided by the output of an OR gate 1090, which receives as its inputs the outputs of two AND gates 1092 and 1094. The AND gate 1092 receives as its inputs EN<sub>--</sub> ASYNC<sub>--</sub> RDBRDY<sub>--</sub> HITA, T<sub>--</sub> HITA, and NCV, while the AND gate 1094 receives the equivalent signals for way B.</p><p>A read hit cache output enable way signal REQ<sub>--</sub> RDHITCOE<sub>--</sub> WAY is provided by the output of an AND gate 1096, which receives as its inputs T<sub>--</sub> MATCHB and 2BANK<sub>--</sub> 2WAY. The output of the AND gate 1096 is also provided as the select input of a multiplexer 1098, which as its zero input receives SYNC<sub>--</sub> COE1 and as its one input receives SYNC<sub>--</sub> COE0. The multiplexer 1096 provides a pipelined cache output enable O.K. signal REQ<sub>--</sub> PIP<sub>--</sub> COE<sub>--</sub> OK, and a pipelined read hit with no wait state signal REQ<sub>--</sub> PIPRDHIT<sub>--</sub> 0WS. These two signals are equivalent because of the elimination of irrelevant conditions.</p><p>Turning to FIGS. 23A-23G, further signals generated by the request module are shown. A write hit enable ready signal EN<sub>--</sub> WRHIT<sub>--</sub> RDY is provided by the output of an AND gate 1100, which receives as its inputs NCV and WT2. Two signals, a write hit BRDY and write hit RDY signal EN<sub>--</sub> ASYNC<sub>--</sub> WRBRDY<sub>--</sub> HIT and EN<sub>--</sub> ASYNC<sub>--</sub> WRRDY<sub>--</sub> HIT are provided by the output of an AND gate 1102, which receives as its inputs PWR, PCACHE*, PMIO, the inverse of PWT, and the inverse of PCD.</p><p>An asynchronous write hit cache write enable signal EN<sub>--</sub> ASYNC<sub>--</sub> WRCWE<sub>--</sub> HIT is provided by the output of an AND gate 1104, which receives as its inputs PWR, PCACHE*, and PMIO. An enable asynchronous write BRDY with no tag match and writeback buffer not full signal EN<sub>--</sub> ASYNC<sub>--</sub> WRBRDY<sub>--</sub> NOMATCH<sub>--</sub> NOTWBFULL is provided by the output of an OR gate 1106, which receives as its inputs the output of an AND gate 1108 and the output of an AND gate 1110. The AND gate 1108 receives as its inputs the inverse of a signal REQ<sub>--</sub> P2MN0POST, which when true indicates that a write cannot be posted to memory, PWR, PCACHE, and PHITM*. The AND gate 1110 receives as its inputs PHITM, and the inverse of a snoop write signal M<sub>--</sub> SNPWR. Note that both REQ<sub>--</sub> P2MNOPOST and M<sub>--</sub> SNPWR are both illustrated, although such signals and logic pertaining to snooping and memory posting have been otherwise eliminated for simplicity.</p><p>An asynchronous write BRDY with match signal EN<sub>--</sub> ASYN<sub>--</sub> WRBRDY<sub>--</sub> MATCH is provided by the output of an AND gate 1112, which receives as its inputs PWR, PCACHE, and PHITM*. An asynchronous write BRDY with match and writeback buffer not full signal EN<sub>--</sub> ASYNC<sub>--</sub> WRBRDY<sub>--</sub> MATCH<sub>--</sub> NOTWBFULL is provided by the output of an OR gate 1114, which receives as its inputs the output of AND gates 1116 and 1118. The AND gate 1116 receives as its inputs the inverse of REQ<sub>--</sub> P2MNOPOST, PWR, PCACHE, and PHITM*. The AND gate 1118 receives as its input PWR, PHITM, and the inverse of M<sub>--</sub> SNPWR.</p><p>An asynchronous write BRDY with no buffer full signal REQ<sub>--</sub> ASYNC<sub>--</sub> WRBRDY<sub>--</sub> NOTWBFULL is provided by the output of an OR gate 1120, which receives as its inputs the output of an AND gate 1122 and the inverse of REQ<sub>--</sub> P2MNOPOST. The AND gate 1122 receives as its inputs PWR and PCACHE.</p><p>Turning to FIGS. 24A-24G, certain other way related signals are shown. WAYHIT is provided by the output of a multiplexer 1150, which receives as its zero input T<sub>--</sub> HITA and as its one input T<sub>--</sub> HITB. The select input of the multiplexer 1150 is provided as PREDICT<sub>--</sub> WAY1.</p><p>REQ<sub>--</sub> MODLINES 3:0! are provided by the output of a multiplexer 1152, which receives as its one input R<sub>--</sub> MODQB 3:0!, and as its select zero input R<sub>--</sub> MODQA 3:0!. The select input of the multiplexer 1152 is provided by ALLOCTAG<sub>--</sub> B. Of course, in actual practice the multiplexer 1152 represents four multiplexers. A demultiplexed line select signal LINEBIT 3:0! is provided by the output of a multiplexer 1154, which receives as its select inputs PALINE 1:0!, which correspond to the appropriate processor address bus PA bits that select the cache lines, here PA 5:4! for a 486 processor and PA 6:5! for a Pentium\u00ae. The multiplexer 1154 provides LINEBIT 3:0! with the corresponding bit of LINEBIT set that corresponds to PALINE 1:0!.</p><p>REQ<sub>--</sub> CLINEMOD is provided by the output of a multiplexer 1156, which as its one input receives LINEMODB and as its zero input receives LINEMODA. The select input of the multiplexer 1156 is provided as ALLOCTAG<sub>--</sub> B. Note that ALLOCTAG<sub>--</sub> B is the equivalent of ALLOCWAY<sub>--</sub> 1.</p><p>An end of process or cycle signal ENDPCYC is provided by the output of an OR gate 1158, which receives as its input PRDY and SYNC<sub>--</sub> CYCLE<sub>--</sub> ABORTED.</p><p>WRHIT<sub>--</sub> TAGUPD is provided by the output of an AND gate 1160, which receives as its input a line writebackable signal WRBACKABLE, which is always assumed to be true, as well as the output of an OR gate 1162, which receives as its input the output of an AND gate 1164 and the output of an AND gate 1166. The AND gate 1164 receives its inputs THIT<sub>--</sub> A and the inverse of LINEMODA, while AND gate 1166 receives a corresponding way B inputs.</p><p>Turning to FIGS. 25A-25F, circuitry used to generate CADS*, CAPU*, and PNA is shown.</p><p>CADS* is provided by an inverter 1500, which receives as its input the output of an OR gate 1502. The OR gate 1502 receives as inputs an asynchronous cache address strobe signals SYNC<sub>--</sub> CADS and the output of an AND gate 1504. The AND gate 1504 receives as inputs NCV and the output of an OR gate 1506. The OR gate 1506 receives as inputs an asynchronous cache address strobe signal REQ<sub>--</sub> ASYNC<sub>--</sub> CADS and an asynchronous memory write cache address strobe signal ASYNC<sub>--</sub> MWR<sub>--</sub> CADS.</p><p>REQ<sub>--</sub> ASYNC<sub>--</sub> CADS is provided by the output of an AND gate 1508, which receives as inputs PADSEN and the output of an OR gate 1510. The OR gate 1510 receives as inputs TAGMISS, the inverse of PADSEN<sub>--</sub> DLY, and the output of an AND gate 1512. The AND gate 1512 receives as inputs SB2WAY and the inverse of WAYHIT.</p><p>ASYNC<sub>--</sub> MWR<sub>--</sub> CADS is provided by the output of an OR gate 1514, which receives as inputs WT2 and the output of an AND gate 1516, which receives as inputs PWR and PCACHE.</p><p>SYNC<sub>--</sub> CADS is provided by the output of a flip-flop 1518, clocked to CLK, which receives as its D input a signal D<sub>--</sub> SYNC<sub>--</sub> CADS, which is provided by the output of an OR gate 1520, which receives as inputs D<sub>--</sub> RDHIT<sub>--</sub> CADS, D<sub>--</sub> L2WB<sub>--</sub> CADS, D<sub>--</sub> ALLOCD<sub>--</sub> CADS, D<sub>--</sub> REQ<sub>--</sub> CADS, and D<sub>--</sub> LOCWR<sub>--</sub> CADS. These of course are the cache address strobe signals from the various logical modules in the CMC 210, and are generated by the state machines within those modules.</p><p>In this way, CADS* is generated at appropriate times allow the address on the burst SRAMs 300 and 302 address inputs to be strobed in for a subsequent read.</p><p>On burst reads, the address in the burst SRAMs 300 and 302 must be advanced at appropriate times. This is provided by CADV*, which is provided by the output of an OR gate 1522, which receives as inputs the output of a flip-flop 1524, an AND gate 1526, and an AND gate 1528. The flip-flop 1524 is clocked to CLK, and receives as its D input the output of an OR gate 1530, which receives as inputs a memory read cache advance signal D<sub>--</sub> MEMRD<sub>--</sub> CADV, D<sub>--</sub> L2WB<sub>--</sub> CADV, D<sub>--</sub> LOCWR<sub>--</sub> CADV, D<sub>--</sub> RDHIT<sub>--</sub> PBRDY, and D<sub>--</sub> REQ<sub>--</sub> CADV. These signals advance the cache burst SRAMs 300 and 302 address during a burst read or write. D<sub>--</sub> MEMRD<sub>--</sub> CADV is generated by a state machine in the memory read module, which is not illustrated.</p><p>The AND gate 1526 receives as inputs NCV<sub>--</sub> EN<sub>--</sub> RHITA<sub>--</sub> RDY, EN<sub>--</sub> ASYNC<sub>--</sub> RDBRDY<sub>--</sub> HITA, and T<sub>--</sub> HITA. The AND gate 1528 receives as inputs NCV<sub>--</sub> EN<sub>--</sub> RHITB<sub>--</sub> RDY, EN<sub>--</sub> ASYNC<sub>--</sub> RDBRDY<sub>--</sub> HITB, and T<sub>--</sub> HITB.</p><p>The processor next address signal PNA is used for pipelining when the processor 200 is a Pentium\u00ae P54 processor. PNA is provided by the output of an OR gate 1530, which receives as inputs asynchronous PNA signals SYNC<sub>--</sub> PNA, provided by the output of an AND gate 1532, the output of an AND gate 1534, and the output of an AND gate 1536. The AND gate 1532 receives as inputs the output of an OR gate 1534, the inverse of a signal NOPIPE<sub>--</sub> ADDR, which indicates that the current address is not a pipelined address when true, and S<sub>--</sub> P54C, a registered signal which indicates the processor is a Pentium\u00ae P54. The OR gate 1534 receives as inputs a memory read PNA request signal D<sub>--</sub> MEMRD<sub>--</sub> PNA, D<sub>--</sub> RDHIT<sub>--</sub> PNA, a PCI read request signal D<sub>--</sub> PCIRD<sub>--</sub> PNA, and D<sub>--</sub> REQ<sub>--</sub> PNA. It will be understood that the various modules request PNA be asserted through these signals from their state machines, with the memory read state machine producing D<sub>--</sub> MEMRD<sub>--</sub> PNA and the PCI read state machine producing D<sub>--</sub> PCIRD<sub>--</sub> PNA not being illustrated.</p><p>The AND gate 1534 receives as inputs NCV<sub>--</sub> EN<sub>--</sub> RHITA<sub>--</sub> RDY, EN<sub>--</sub> ASYNC<sub>--</sub> PNA<sub>--</sub> HITA, and T<sub>--</sub> HITA. The AND gate 1536 receives as inputs NCV<sub>--</sub> EN<sub>--</sub> RHITB<sub>--</sub> RDY, EN<sub>--</sub> ASYNC<sub>--</sub> PNA<sub>--</sub> HITB, and T<sub>--</sub> HITB.</p><p>The generation of PNA is well known to the art, but this circuitry serves to further illustrate how the CMC 210 generates it according to the invention.</p><p>Turning to FIGS. 26A-26H, circuitry for generating chip select strobes CCS0* and CCS1* when a two-bank two-way cache is implemented is shown. As will be understood, when a single-bank two-way cache is implemented, only one of these signals, CCS0*, is used. A chip select block signal REQ<sub>--</sub> BLK<sub>--</sub> CCS0 is provided by the output of an AND gate 1538, which receives as inputs NCV, the inverse of SB2WAY, and ALLOCWAY<sub>--</sub> 1. The corresponding way 1 signal REQ<sub>--</sub> BLK<sub>--</sub> CCS1 is provided by the output of an AND gate 1540, which receives as inputs NCV and the inverse of ALLOCWAY<sub>--</sub> 1.</p><p>A synchronous block chip select signal SYNC<sub>--</sub> BLK<sub>--</sub> CCS0 is provided by the output of a flip-flop 1542, clocked to CLK, which receives its D input from the output of an OR gate 1544, which in turn receives as inputs the output of an AND gate 1546 and the output of an AND gate 1548. The AND gate 1546 receives as inputs the inverse of SB2WAY and the output of an OR gate 1550. The OR gate 1550 receives as inputs D<sub>--</sub> ALLOCD<sub>--</sub> BLK<sub>--</sub> CCS0, a synchronous cache write enable signal D<sub>--</sub> SYNC<sub>--</sub> CWE1, and D<sub>--</sub> LOCWR<sub>--</sub> BLK<sub>--</sub> CCS0. The AND gate 1548 receives as inputs the inverse of D<sub>--</sub> PADSEN and the inverse of D<sub>--</sub> SYNC<sub>--</sub> CADS. SYNC<sub>--</sub> BLK<sub>--</sub> CCS0 blocks the cache way 0 chip select when that is not the appropriate way.</p><p>A corresponding way 1 signal SYNC<sub>--</sub> BLK<sub>--</sub> CCS1 is provided by the output of a flip-flop 1552, clocked to CLK, which receives as its D input the output of an OR gate 1554. The OR gate 1554 receives as inputs the output of an OR gate 1556, and the output of an AND gate 1558. The OR gate 1556 receives as inputs D<sub>--</sub> ALLOCD<sub>--</sub> BLK<sub>--</sub> CCS1, a cache write enable signal D<sub>--</sub> SYNC<sub>--</sub> CWE0, and D<sub>--</sub> LOCWR<sub>--</sub> BLK<sub>--</sub> CCS1.</p><p>D<sub>--</sub> SYNC<sub>--</sub> CWEO is provided by the output of an OR gate 1560, which receives as inputs D<sub>--</sub> LOCWR<sub>--</sub> CWE0, and D<sub>--</sub> REQ<sub>--</sub> CWE0. The corresponding way 1 signal D<sub>--</sub> SYNC<sub>--</sub> CWE1 is provided by the output of an OR gate 1562, which receives as inputs D<sub>--</sub> LOCWR<sub>--</sub> CWE1 and D<sub>--</sub> REQ<sub>--</sub> CWE1. CWE* 7:0! are controlled in part using these signals and in part using other circuitry not shown. The generation of the appropriate cache byte way enables is well known to the art, and is done to write the data on PD into the cache burst SRAMS 300 and 302. They would appropriately be enabled on any allocation cycles, processor write hits, and other cycles well understood by those skilled in the art.</p><p>From all of these signals, CCS0* is provided by the output of an OR gate 1564, which receives as inputs REQ<sub>--</sub> BLK<sub>--</sub> CCS0 and SYNC<sub>--</sub> BLK<sub>--</sub> CCS0. Corresponding way 1 signal CCS1* is provided by the output of an OR gate 1566, which receives as inputs REQ<sub>--</sub> BLK<sub>--</sub> CCS1 and SYNC<sub>--</sub> BLK<sub>--</sub> CCS1.</p><p>Miscellaneous Signals</p><p>Turning to FIGS. 27A-27C, the generation of various miscellaneous signals is shown. GOOD<sub>--</sub> ALLOCA<sub>--</sub> IN<sub>--</sub> CRAM is provided by the output of a multiplexer 1200. The select input of the multiplexer 1200 is provided by D<sub>--</sub> REQ<sub>--</sub> GOOD<sub>--</sub> ALLOCA<sub>--</sub> IN<sub>--</sub> CRAM. This signal is provided by the output of an AND gate 1201, which receives as inputs ALLOC<sub>--</sub> REQ, the inverse of REQ<sub>--</sub> CLINMOD, and PADSEN. Thus, D<sub>--</sub> REQ<sub>--</sub> GOOD<sub>--</sub> ALLOCA<sub>--</sub> IN<sub>--</sub> CRAM is true on an allocation request when no cache lines are modified.</p><p>The one input of the multiplexer 1200 is driven true. The zero input is provided by the output of a second multiplexer 1202, whose select input is provided as SYNC<sub>--</sub> CADS. The one input of the multiplexer 1202 is driven by the output of an AND gate 1204, having as inputs the inverse of ALLOCD<sub>--</sub> IDLE and the inverse of a signal SEL<sub>--</sub> WBA<sub>--</sub> TO<sub>--</sub> PAOUT. SEL<sub>--</sub> WBA<sub>--</sub> TO<sub>--</sub> PAOUT is provided by the L2 writeback state machine of FIG. 10 through logic not shown, and is true whenever that state machine still has data pending to writeback of the current writeback cycle. The zero input of the multiplexer 1202 is provided by the output of a third multiplexer 1206, whose select input is driven by the output of an OR gate 1208. The OR gate 1208 has as inputs NEW<sub>--</sub> ADR<sub>--</sub> IN<sub>--</sub> CRAM (true when PADS and PADSEN are both true, and created by circuitry not shown) and the output of an AND gate 1210, which has as inputs the inverse of ALLOCD<sub>--</sub> IDLE, and MEMRD<sub>--</sub> BDONE. The one input of the multiplexer 1206 is driven false and the zero input is provided by GOOD<sub>--</sub> ALLOCA<sub>--</sub> IN<sub>--</sub> CRAM.</p><p>A flip-flop 1212 provides PADSEN, which is also provided to the D input of a flip-flop 1214, the output of which is PADSEN<sub>--</sub> DLY. Both flip-flops 1212 and 1214 are clocked by CLK, and flip-flop 1212 receives as its D input a signal D<sub>--</sub> PADSEN output by D<sub>--</sub> PADSEN an by NOR gate 1216. The inputs to the NOR gate 1216 are ALLOCD<sub>--</sub> BLK<sub>--</sub> PADSEN and RDHIT<sub>--</sub> BLK<sub>--</sub> PADSEN. The latter signal is provided by the read hit state machine of FIG. 8, while the former is provided through circuitry not shown by the allocation state machine of FIG. 14.</p><p>Various new cycle valid signals NCV, B<sub>--</sub> NEWCYC<sub>--</sub> VALID, and NEWCYC<sub>--</sub> VALID are provided by the output of a flip-flop 1218, clocked by CLK. As its D input, the flip-flop 1218 receives a signal D<sub>--</sub> NEWCYC<sub>--</sub> VALID, which is provided by the output of an AND gate 1220, which receives as its input PADS as well as the output of an OR gate 1222. As inputs, the OR gate 1222 receives the inverse of PAHOLD, as well as that signal delayed by one clock cycle, indicated by PAHOLD<sub>--</sub> DLY.</p><p>Cache Tag Memory</p><p>Turning to FIG. 28, the tag RAM 364 is shown as logically implemented in the CMC 210. Shown is way A, or way 0, of the tag RAM 364. Way B of the tag RAM 366 would be the equivalent, with A being substituted for B in the various tag memory inputs and outputs. As inputs, the tag RAM 364 includes tag label write enable signals T<sub>--</sub> LABELWEA 10:0!, modified line bit write enable signals T<sub>--</sub> MODWEA 3:0!, valid bit write enable signals T<sub>--</sub> VALIDWEA 3:0!, LRU bit write enable signal T<sub>--</sub> LRUWEA, chip select signal T<sub>--</sub> TAGCSA, label data signals T<sub>--</sub> LABELDA 10:0!, modified bit data signals T<sub>--</sub> MODD 3:0!, valid bit data signals T<sub>--</sub> VALIDD 3:0!, and LRU data signal T<sub>--</sub> LRUDA. Also driven into the tag RAM 365 is the index, which is processor address lines 16 through 7 when using a Pentium\u00ae processor, indicated by PA 16:7!.</p><p>As outputs, the tag RAM 364 provides label output data signals R<sub>--</sub> LABELQA 10:0!, modified bit output data signals R<sub>--</sub> MODQA 3:0!, valid bit output data signals R<sub>--</sub> VALIDQA 3:0!, and LRU output data signals R<sub>--</sub> LRUQA. Of note, the tag RAM 364 implements the modified, shared, and invalid states, but does not implement the exclusive state of the MESI standard because the CMC 210 is not intended to operate in a multiprocessor environment with other caches. Therefore, cache coherency requiring the exclusive state is not needed.</p><p>Proceeding to FIGS. 29A-29K, a state machine for updating the tags in the tag RAMs 364 and 366 is shown, as well as various circuitry for creating signals needed by the tag RAMs 364 and 366 and the tag RAM state machine. One state associated with a forced wait state is omitted, as in the preferred embodiment, operation is without a forced wait state. State S0 is the idle state, and it proceeds to state S1 on a tag request signal P<sub>--</sub> TAGREQ being true or on a new tag cycle signal NEWTAGCYC being true. When P<sub>--</sub> TAGREQ is not true, the tag write state machine remains in state S0. From state 1, the state machine proceeds to state 0 if a tag write (i.e., a tag update) is not needed, as indicated by TAGWRITEA and TAGWRITEB being false. If either TAGWRITEA or TAGWRITEB is true, the state machine instead proceeds to state S2, where the tags are rewritten. After state S2, the state machine returns to state S0. Of note, NEWTAGCYC is the equivalent of D<sub>--</sub> NEWCYC<sub>--</sub> VALID.</p><p>A tag latch signal TAGLATCH is provided by the output of a flip-flop 1302, clocked by CLK, which receives its D input true when the state machine is not in state S1.</p><p>P<sub>--</sub> CPU<sub>--</sub> ALLOC is provided by flip-flop 1304, clocked by CLK, which as its D input receives SET<sub>--</sub> P<sub>--</sub> CPUALLOC. It is true when a tag allocation is needed.</p><p>P<sub>--</sub> TAGREQ is provided by the output of an OR gate 1306, which receives as inputs ALLOCT<sub>--</sub> PTAGREQ, L2SNP<sub>--</sub> PTAGREQ, LOCWR<sub>--</sub> PTAGREQ, and FLSH<sub>--</sub> PTAGREQ. The signals L2SNP<sub>--</sub> PTAGREQ and FLSH<sub>--</sub> PTAGREQ are tag requests from the L2 snoop logic and the cache flush logic, which is not illustrated. It will be readily understood that when these state machines need new tags, they would assert this corresponding signal.</p><p>A modified bit update signal P<sub>--</sub> MODUPD is provided by the output of an OR gate 1308, which receives as inputs WT2, TD, and the output of an AND gate 1310, which in turn receives as inputs WT2P and SYNC<sub>--</sub> PRDY.</p><p>An assert tag chip select signal D<sub>--</sub> TAGCS is provided by the output of an OR gate 1312, which receives as inputs D<sub>--</sub> ALLOCT<sub>--</sub> TAGCS, D<sub>--</sub> L2SNP<sub>--</sub> TAGCS, D<sub>--</sub> LOCWR<sub>--</sub> TAGCS, and D<sub>--</sub> FLSH<sub>--</sub> TAGCS. Again, the snoop and flush logic would provide the L2SNP and FLSH tag chip select variables.</p><p>A writeback state signal P<sub>--</sub> CPUWRBK is provided by the output of an AND gate 1314, which receives as inputs NCV and WBT2. A cache least recently used way signal C<sub>--</sub> LRU<sub>--</sub> WAY is provided by the output of an exclusive OR gate 1316, which receives as inputs R<sub>--</sub> LRUQA and R<sub>--</sub> LRUQB.</p><p>A processor write signal P<sub>--</sub> CPUWR is provided by the output of an OR gate 1318, which receives as inputs LOCWR<sub>--</sub> CPUWR and the output of two AND gates 1320 and 1322. The AND gate 1320 receives as inputs P<sub>--</sub> CPU<sub>--</sub> ALLOC and ALLOCT<sub>--</sub> LAT<sub>--</sub> WRALLOC<sub>--</sub> REQ. The AND gate 1322 receives as inputs NCV and the output of an OR gate 1324. The OR gate 1324 receives as inputs WBT2 (writeback T2 cycle), WT2, TD, and the output of an AND gate 1326, which receives as inputs WT2P and SYNC<sub>--</sub> PRDY.</p><p>A processor read signal P<sub>--</sub> CPURD is provided by the output of an OR gate 1328, which as inputs receives the outputs of AND gates 1330 and 1332. The AND gate 1330 receives as inputs P<sub>--</sub> CPUALLOC and the inverse of ALLOCT<sub>--</sub> LAT<sub>--</sub> WRALLOC<sub>--</sub> REQ. The AND gate 1332 receives as inputs the inverse of PWR and NCV.</p><p>Proceeding to FIGS. 30A-30I, various logic for use in driving the tag RAMs 364 and 366 is shown. Way allocate signals ALLOCATE<sub>--</sub> WAYA and ALLOCATE<sub>--</sub> WAYB are provided by the outputs of two AND gates 1350 and 1352. The AND gate 1350 receives as inputs the inverse of P<sub>--</sub> ALLOCWAY as well as the output of an AND gate 1354. The AND gate 1352 receives as inputs the output of the AND gate 1354 and P<sub>--</sub> ALLOCWAY. The AND gate 1354 receives as inputs the inverse of T<sub>--</sub> MATCHA, the inverse of T<sub>--</sub> MATCHB, and P<sub>--</sub> CPUALLOC.</p><p>Set validate bit signals VALIDATE<sub>--</sub> WAYA and VALIDATE<sub>--</sub> WAYB are provided by the outputs of AND gates 1356 and 1358. The AND gate 1356 receives as inputs the output of an AND gate 1360, which receives as inputs T<sub>--</sub> MATCHA, the inverse of LINEVALIDA, and the output of an OR gate 1362. The OR gate 1362 receives as inputs P<sub>--</sub> CPUALLOC and P<sub>--</sub> CPUWRBK.</p><p>The AND gate 1358 receives as inputs the output of the OR gate 1362 and the output of an AND gate 1364, which receives as inputs T<sub>--</sub> MATCHB and the inverse of LINEVALIDB. Invalidate tag RAM signals INVALIDATE<sub>--</sub> WAYA and INVALIDATE<sub>--</sub> WAYB are provided by the outputs of AND gates 1366 and 1368. Both of these AND gates receive as inputs the output of an AND gate 1370, which receives as inputs P<sub>--</sub> SNPWR and the inverse of a snoop writeback signal P<sub>--</sub> SNPWRBK, generated by circuitry not shown.</p><p>The AND gate 1366 further receives as an input the output of an AND gate 1372, which receives as inputs T<sub>--</sub> MATCHA and LINEVALIDA. The AND gate 1368 further receives as an input the output of an AND gate 1374, which receives as inputs T<sub>--</sub> MATCHB and LINEVALIDB.</p><p>The AND gate 1376 provides as an output a way modify signal MODIFY<sub>--</sub> WAYA. It receives as inputs T<sub>--</sub> MATCHA, the inverse of LINEMODA, and the output of an OR gate 1378. The OR gate 1378 receives as inputs P<sub>--</sub> CPUALLOC, P<sub>--</sub> CPUWRBK, and an AND gate 1380. The AND gate 1380 receives as inputs P<sub>--</sub> CPUWR, P<sub>--</sub> MODUPD, the inverse of PWP, and LINEVALIDA. MODIFY<sub>--</sub> WAYB, the way B modified signal, is generated using the same logic, but substituting the way B signals for the way A signals.</p><p>Two unmodify signals UNMODIFY<sub>--</sub> WAYA and UNMODIFY<sub>--</sub> WAYB are provided by AND gates 1382 and 1384, both of which receive as inputs the output of an AND gate 1386. The AND gate 1386 receives as inputs P<sub>--</sub> SNPWRBK inverted along with the output of an OR gate 1388. The OR gate 1388 receives as inputs P<sub>--</sub> SNPRD and P<sub>--</sub> SNPWR. The AND gate 1382 further receives as inputs LINEMODB and T<sub>--</sub> MATCHB, and the AND gate 1384 further receives as inputs T<sub>--</sub> MATCHA and LINEMODA.</p><p>A new least recently used signal NEWLRU<sub>--</sub> WAYA is provided by the output of an AND gate 1390. The AND gate 1390 receives as inputs T<sub>--</sub> MATCHA along with the inverse of C<sub>--</sub> LRU<sub>--</sub> WAY and the output of an OR gate 1392. The OR gate 1392 receives as inputs P<sub>--</sub> CPUWRBK, P<sub>--</sub> CPUALLOC, and the output of an AND gate 1394. The AND gate 1394 receives as its inputs LINEVALIDA, P<sub>--</sub> LRUUPD (a signal generated by circuitry not shown which indicates that the LRU bit should be updated), and the output of an OR gate 1396. The OR gate 1396 receives as inputs P<sub>--</sub> CPURD and P<sub>--</sub> CPUWR.</p><p>A way B new least recently used bit signal NEWLRU<sub>--</sub> WAYB uses the same circuitry as NEWLRU<sub>--</sub> WAYA, with the exceptions that the way B signals are substituted for the way A signals shown, and the non-inverted value of C<sub>--</sub> LRU<sub>--</sub> WAY is used by the equivalent of the AND gate 1390.</p><p>A tag write to way A variable TAGWRITEA is provided by the output of an OR gate 1398. The OR gate 1398 receives as inputs P<sub>--</sub> TAGFLSH, ALLOCATE<sub>--</sub> WAYA, VALIDATE<sub>--</sub> WAYA, INVALIDATE<sub>--</sub> WAYA, MODIFY<sub>--</sub> WAYA, UNMODIFY<sub>--</sub> WAYA, and NEWLRU<sub>--</sub> WAYA. The occurrence of any of these signals and would indicate a tag write, forcing the state machine from state S1 to state S2. The way B tag write signal TAGWRITEB is generated in the same way as TAGWRITEA except that the way B signals are substituted for the way A signals.</p><p>A signal indicating that any lines of the currently selected block of the tag RAM 364 are modified ANYMODA is provided by the output of an OR gate 1400 which has as inputs each of the lines of T<sub>--</sub> MODQA 3:0!. An OR gate 1402 similarly provides the way B corresponding signal ANYMODB.</p><p>Proceeding to FIGS. 31A-31J, further circuitry showing how the tag RAMs 364 and 366 are updated is shown. A set modified bit data signal SET<sub>--</sub> MODD is provided by the output of an AND gate 1404, which has as inputs the inverse of P<sub>--</sub> TAGFLUSH, which indicates that the tag RAMs 364 and 366 should be flushed and is provided by circuitry not shown, along with the inverse of PWP. Further providing an input to the AND gate 1404 is an OR gate 1406, which receives as inputs P<sub>--</sub> CPUWR and P<sub>--</sub> CPUWRBK.</p><p>The four signals T<sub>--</sub> MODD 3:0! are provided by a series of flip-flops illustrated by the flip-flop 1408, which is clocked whenever one of the variables used to generate T<sub>--</sub> MODD 3:0! changes state. As its D input, the flip-flop 1408 receives the output of a multiplexer 1410, whose zero input is provided by the appropriate one of T<sub>--</sub> MODD 3:0!. The one input of the multiplexer 1410 is provided by the output of an AND gate 1412, which receives as inputs LINEBIT 3:0! and SET<sub>--</sub> MODD. The multiplexer 1410 has its select input driven by TAGLATCH.</p><p>T<sub>--</sub> TAGCSA is provided by the output of an OR gate 1414, which receives as inputs PADS and the output of a multiplexer 1416. The select input of the multiplexer 1416 is provided as PADS*, and the zero input is provided high. The one input is driven by the output of an OR gate 1418, which as inputs receives D<sub>--</sub> TAGCS along with the output of an AND gate 1420, which receives as inputs TAGWRITEA and STATE<sub>--</sub> S1 which indicates the state machine of FIG. 29 is in the S1 state. T<sub>--</sub> TAGCSB is generated using corresponding logic.</p><p>A latched modified bit write enable signal REG<sub>--</sub> MODWEA X!, where X equals zero through three for the four modified bits, is provided by the output of a flip-flop 1422, which is clocked by CLK. The D input of the flip-flop 1422 is driven by the output of an AND gate 1424, which receives as its inputs STATE<sub>--</sub> S1 and the output of an OR gate 1426. The OR gate 1426 receives as inputs the output of an AND gate 1428 and ALLOCATE<sub>--</sub> WAYA. The AND gate 1428 receives as inputs LINEBIT X! and the output of an OR gate 1430. The OR gate 1430 receives as inputs MODIFY<sub>--</sub> WAYA and UNMODIFY<sub>--</sub> WAYA.</p><p>Corresponding latched modified bit write enable signals REG<sub>--</sub> MODWEB X! are generated using the same circuitry as used to generate REG<sub>--</sub> MODWEA X!, but by substituting the WAYB signals for the WAYA signals. Of note, these register mode write enable bits are enabled when ALLOCATE<sub>--</sub> WAYA is true during state S1. Thus, on allocation cycles, the latch mode bit is write enabled.</p><p>A latched least recently used bit write enable signal REG<sub>--</sub> LRUWEA is provided by the output of a flip-flop 1432, clocked by CLK. The D input of flip-flop 1432 is provided by the output of an AND gate 1434, which as inputs receives STATE<sub>--</sub> S1 as well as the output of an OR gate 1436. The OR gate 1436 receives as inputs ALLOCATE<sub>--</sub> WAYA, VALIDATE<sub>--</sub> WAYA, the inverse of P<sub>--</sub> SNPWRBK, MODIFY<sub>--</sub> WAYA, and NEWLRU<sub>--</sub> WAYA. The corresponding WAYB least recently used bit write enable signal REG<sub>--</sub> LRUWEB is generated using similar circuitry, but with the way B signals substituted for the way A signals.</p><p>A clear tag write enable signal TAGWEA<sub>--</sub> CLR is provided by the output of a flip-flop 1438, which is clocked on the negative edge of CLK. The D input of the flip-flop 1438 is driven by the output of an OR gate 1440, which receives as inputs REG<sub>--</sub> LRUWEA as well as the output of an OR gate 1442. The OR gate 1442 receives as inputs all of the lines of REG<sub>--</sub> MODWEA 3:0!.</p><p>T<sub>--</sub> MODWEA X! is provided by a series of AND gates illustrated by an AND gate 1444, which receives as its inputs the inverse of TAGWEA<sub>--</sub> CLR and REG<sub>--</sub> MODWE X!.</p><p>T<sub>--</sub> LRUWEA is provided by the. output of AND gate 1446, which receives as inputs the inverse of TAGWEA<sub>--</sub> CLR, as well as REG<sub>--</sub> LRUWEA. Corresponding WAYB signals T<sub>--</sub> MODWEB X! and T<sub>--</sub> LRUWEB are generated by substituting the corresponding way B signals for the illustrated way A signals.</p><p>LINEVALIDA is provided by the output of a multiplexer 1448, which as its select inputs receives PALINE 1:0!, the line selects on the processor address bus PA. These line selects select the appropriate one of the four signals R<sub>--</sub> VALIDQA 3:0!, thus providing it as LINEVALIDA. LINEMODA is similarly provided by a multiplexer 1450, again selected by PALINE 1:0! and in this case selecting between the four signals R<sub>--</sub> MODQA 3:0!. Corresponding LINEVALIDB and LINEMODB signals are generated using similar circuitry.</p><h4>Allocate Direct to Modified Operation</h4><p>Referring to the circuitry of FIGS. 28-31J, it will be understood that when a processor 200 write cycle results in a tag miss, the resulting L2 cache 208 allocate cycle takes that line directly to the modified state rather than to the unmodified state. Specifically, SET<sub>--</sub> MODD as provided by the AND gate 1404 will be true because one of the signals provided to the OR gate 1406 is P<sub>--</sub> CPUWR. Referring to the generation of that signal, the OR gate 1318 has as one input the output of the AND gate 1320. That AND gate 1320 will provide a true signal, because P<sub>--</sub> CPUALLOC will be true and the ALLOCT<sub>--</sub> LAT<sub>--</sub> WRALLOC<sub>--</sub> REQ will be true. This latter signal is latched by the flip-flop 944 on a write allocation request, while P<sub>--</sub> CPUALLOC from the flip-flop 1304 is similarly set by the tag allocation state machine of FIG. 17 setting SET<sub>--</sub> P<sub>--</sub> CPUALLOC. Thus, on a write miss the resulting allocated line in the tag RAM 364 or 366 will be set to modified, even though it has only been read, and yet not modified.</p><p>Then, when the back off signal PBOFF to the processor 200 is dropped, allowing the processor 200 to resume the write that caused the allocation, the resulting write hit will be to a modified line. A write hit to a modified line, however, does not require that the tags be updated, because the line simply remains modified. This results in one less wait state, because usually a tag update to modified requires one extra wait state.</p><h4>Timing Diagrams Showing System Operation</h4><p>Direct to Modified</p><p>Turning to FIG. 32, the timing of various signals in the computer system 100 is shown during a write allocate direct to modified cycle in which the processor is running at 50 MHz. Four distinct operations are illustrated. First, operation A is a write miss to the L2 cache 208 followed by an allocate cycle; operation B is the resulting write to the L2 cache 208 line just allocated; operation C is a write hit to a modified line; and operation D is a write hit to a valid but shared or unmodified line. The states of various illustrated signals will be examined at various times within each of these operations.</p><p>At time A.1, PADS* has been asserted, but the line for which the read is being attempted is not valid, as is indicated by T<sub>--</sub> HITVALID going true while R<sub>--</sub> VALIDQA remains false. So, the CMC 210 L2 cache 208 control logic requests a memory read by asserting P<sub>--</sub> MRDREQ true, which is acknowledged by M<sub>--</sub> PREQACK subsequently going true. PBOFF* is then asserted, backing off the write operation that caused the L2 cache 208 miss. While waiting for the memory read to become available, the tag state machine illustrated in FIG. 29 cycles from S0 to S1 to S2 (indicated by TAGSTATE), where the tags are rewritten in anticipation of the burst read from memory. At time A.2, it is seen that the tag state machine is in state S2, with T<sub>--</sub> MODWEA asserted true and T<sub>--</sub> MODD, the data for the modified bit, also being asserted true. Thus, the modified bit in the appropriate way of the tag RAMs 364 or 366 is set for this line before the data is even read into the L2 cache 208. At the following times, A.3, A.4, A.5 and A.6, the data is read into the L2 cache 208, as illustrated by CWE0* being asserted and CADV0* being subsequently strobed to advance the burst SRAMs 300 and 302 addresses. PBOFF* is also then deasserted, allowing the processor 200 to complete the write to the line it was attempting.</p><p>The processor 200 attempts this write to the previously invalid line in operation B. Operation B results in a hit to a line that the cache tag RAMs 364 or 366 indicate is modified, as illustrated by R<sub>--</sub> MODQA being true when T<sub>--</sub> HITVALID goes true at time B.1. Because this is a write to a modified line, the tag RAM 364 or 366 modified bits do not need to be updated, so the cycle then ends. Note that operation B has only taken three cycles. Operation C is similar to operation B, with a write hit to the previously allocated line. This write hit is not the result of the backed off write, but a new write. Again, however, the write to the modified line results in no need to update the modified bits, as is seen when T<sub>--</sub> HITVALID goes true with R<sub>--</sub> MODQA also true at time C.1.</p><p>Compare this with operation D, a write hit to an unmodified line. In this case, when T<sub>--</sub> HITVALID goes true at time D.1, R<sub>--</sub> MODQA is false, indicating the current line is not modified. But because this is a write operation, the tags for this line must be updated to indicate that it has been modified. So, TAGSTATE proceeds to state S2, which was unnecessary in operations B and C, where T<sub>--</sub> MODWEA is asserted with T<sub>--</sub> MODD true, thus writing the correct modified value to the tag RAMs 364 or 366 at time D.2. Then, only on the next clock cycle is PBRDY* asserted at D.3. Thus, this operation has occupied one extra clock cycle.</p><p>It will thus be appreciated that by setting a line s modified bits to true during the allocate read, rather than setting them to unmodified, the resulting backed-off write will take one less clock cycle than if the modified bits had not been so set. That is, in FIG. 32, operation B would have taken one extra clock cycle. It will thus be appreciated that performance is improved and a cycle save when using non-dual ported RAMS by taking the modified bits directly to modified on the allocate cycle.</p><p>It will further be appreciated that such an advantage can be realized whether using a direct mapped cache or two-way set-associative cache. In any case, the write operation to an allocated line saves a wait state.</p><p>Two-Bank Two-Way Code Read Way Prediction</p><p>Turning to FIG. 33, the timing of various signals is shown that illustrates way prediction based on the last code read way in a two-bank two-way cache. Five operations are shown. Operation A is a code hit to way 1, in which the way prediction has missed. Operation B is a data hit to way 0, in which the way prediction has missed. Operation C is a data hit to way 1, in which the way prediction has hit. Operation D is a code hit to way 0, in which the way prediction has missed. Operation E is a data hit to way 0, in which the way prediction has hit. The way prediction being used is last code read, not last code plus data read. Using last code plus data read, data read operations would change LASTRDWAY to whatever way the data read occurred.</p><p>Referring to operation A, it is seen that when PADS* is asserted, LASTRDWAY is currently low, indicating way 0 was the last read way. Thus, at the assertion of PADS*, it is seen that COE0* is driven low, predicting that way 0 will be the way of this read operation. Further, LAST<sub>--</sub> PRED<sub>--</sub> COE0 is true, indicating that the last way prediction is to way 0. At A.2, which is the following edge of CLK, EARLY<sub>--</sub> WAYMISS<sub>--</sub> COE1 goes true, indicating that if the predicted way is not to way 1, a way miss has occurred. Simultaneously, TURN<sub>--</sub> OFF<sub>--</sub> ASYNC<sub>--</sub> COE0 goes true, forcing LASTWAY<sub>--</sub> PRED<sub>--</sub> COE0 low, the combination of which force COE0* high and COE1* low after a brief delay. This, however, costs one cycle, as PBRDY* is delayed, causing the read operation to take an extra cycle. Note that LASTRDWAY is reset to 1, indicating that this, the last code read, was to way 1. Operation B, a data read hit to way zero, but with the way prediction failing, having predicted way 0, includes similar timing as operation A, except that LASTRDWAY is not reset to zero, because S<sub>--</sub> PREDLAST data is false, indicating that only code read hits are used to predict the next way.</p><p>In operation C, at time C.1, COE0* is deasserted high, while COE1* is asserted low. This is a hit to way 1, and COE0* and COE1* remain at the respective states throughout the remainder of the operation. This does not cost an extra cycle, as PBRDY* is asserted low in the cycle immediately following PADS*.</p><p>In this way, way hits do not cause an extra cycle to be incurred, whereas way misses only cause a single extra cycle to be incurred. This method of prediction can even be preferable to a most recently used way prediction well known to the art in high speed systems. Most recently used signals are generated from the LRU bits in the cache tag RAMS, and obviously the LRU way will not be ready until the tag RAMS have output these LRU bits during PADS*. But by then, it can still be too late to assert PBRDY* without incurring a wait state, depending on system timing.</p><p>But as will be discussed below in conjunction with FIGS. 35A-35B, even though an extra wait state is not required in this instance, the single-bank two-way cache according to the invention does have a timing advantage over the two-bank two-way cache implemented using way prediction according to the invention in the case of pipelined operations. With pipelined operations, in the two-bank two-way cache, it is always necessary to deassert PBRDY* on a way miss between pipelined operations.</p><p>The cache output enable circuity when using a two-bank two-way cache according to the invention also provides an advantage on a way miss using a two-bank two-way cache. Specifically, the circuitry used to generate COE0* and COE1* is not entirely synchronous. For an understanding of this, refer to FIG. 33, operation A, at time A.3. It appears as though COE0* and COE1* simultaneously switch, enabling COE1* and disabling COE0*.</p><p>But if these were simultaneous, that could stress the two-bank two-way cache burst SRAMs 312, 314, 322, and 324. If one bank was enabled simultaneously with another bank being disabled, they could conceivably be driving the data bus at the same time.</p><p>But according to the invention, the cache output enable circuitry is not entirely synchronous, so in fact COE0* is deasserted slightly before the time COE1* is asserted. In this way, in the disclosed embodiment, a wait state can be avoided on a way miss. Specifically, the extra state that would be required if COE1* in operation A were not asserted until after the time PBRDY* would have to be asserted is eliminated.</p><p>The circuitry for achieving this asynchronous switching is found in FIGS. 6A-7G. Assume, for example, that way prediction has predicted way 0, and thus COE0 is asserted. But then, a way miss occurs, requiring a switch to way 1. Referring to the circuitry of FIGS. 6A-6K, it will be seen that one input to COE0 is LASTWAY<sub>--</sub> PRED<sub>--</sub> COE0. It is this signal which has previously asserted COE0 using way prediction. The AND gate 572 has as one input to LASTWAY<sub>--</sub> PRED<sub>--</sub> COE0 the inverse of TURN<sub>--</sub> OFF<sub>--</sub> ASYNC<sub>--</sub> COE0. Referring to FIGS. 7A-7G, TURN<sub>--</sub> OFF<sub>--</sub> ASYNC<sub>--</sub> COE0 is seen to go true on a hit to way 1 (T<sub>--</sub> HITB) and on a low level of CLK as provided by the AND gate 590. The end result of this circuitry is that TURN<sub>--</sub> OFF<sub>--</sub> ASYNC<sub>--</sub> COE0 is driven directly by CLK, and when CLK goes false and we have a way miss and must go to way 1, TURN<sub>--</sub> OFF<sub>--</sub> ASYNC<sub>--</sub> COE0 goes immediately true. This forces LASTWAY<sub>--</sub> PRED<sub>--</sub> COE0 false, which immediately forces COE0 false, or deasserted.</p><p>COE1, however, is then asserted through a slightly different method. As one input, COE1 in FIGS. 6A-6K is dependent upon EARLY<sub>--</sub> WAYMISS<sub>--</sub> COE1. Referring to FIGS. 7A-7G, it is seen that this is in turn dependent upon EN<sub>--</sub> WAYMISS<sub>--</sub> COE, which is in turn also asserted on the negative edge of CLK by the flip-flop 594. But the flip-flop 594 provides a delay not present in the deassertion of COE0. The end result is the delay between the falling edge of CLK and the deassertion of COE0 is less than that of the assertion of COE1. That is, COE1 is asserted slightly later than COE0. Through these critical timing paths, COE0* and COE1* are never asserted at the same time, but have a slight delay between their assertions.</p><p>Single-Bank Two-Way Operation</p><p>Turning to FIG. 34, the timing of various signals used for way prediction in a single bank, two way cache data RAM are shown. Five operations are shown. Operation A is a code hit to way 1, but a way prediction miss. Operation B is a data hit to way zero, but a way prediction miss. Operation C is a data hit to way 1, with a way prediction hit. Operation D is a code hit to way zero, with a way prediction miss. Operation E is a data hit to way zero, with a way prediction hit.</p><p>The operation of the cache control signals using a single-bank two-way cache is relatively simpler than in a two-bank two-way cache using way prediction. Referring to operation A, at the indicated time it is determined that the way bit provided to the most significant address bit of the burst RAMs 300 and 302 and indicated by CMWAY is incorrect. Since this is a tag hit to way 1, CMWAY is changed to logic 1, and CADS0* is then strobed. Note that the processor 200 had previously strobed the burst RAMs 300 and 302 through PADS* being driven to the ADSP* input of the burst RAMs 300 and 302 while COE0* was asserted. Thus, on a way miss, an extra cycle is incurred for CADS0* to be strobed in correctly. Also note that LASTRDWAY is changed to way 1 in operation A, reflecting that this last code read was to way 1.</p><p>In operation B, CMWAY is high during the assertion of PADS*. This is because LASTRDWAY is high, thus predicting way 1. The tag RAMs 364 and 366 indicate this is a tag hit to way zero, indicating a way miss, so the correct way must be strobed in at the indicated time by CADS0* with CMWAY being asserted low. Note that immediately after this data is strobed in, however, CMWAY returns high, as LASTRDWAY is high. In operation C, the address strobed into the burst RAMs 300 and 302 during PADS* is correct. That is, CMWAY is correct. Thus, CADS0* does not need to be strobed low to strobe in a correct CMWAY. In this case, an extra cycle is not needed to strobe in the correct way. Operation D illustrates a code hit to way zero with a way miss, again causing LASTRDWAY to be switched and requiring an extra cycle, and operation E indicates a data hit to way zero with a way hit.</p><p>It will be appreciated, as in the two-bank two-way case, a way miss incurs a single extra clock cycle while a way hit incurs no wait state whatsoever. If LRU way prediction were used, or if no way prediction were used with a single-bank two-way cache, no address could be driven to the cache burst RAMs 300 and 302 until after the tag RAMs 364 and 366 had been strobed. This is because the outputs of the tag RAMs 364 and 366 would be required before an address could even be driven to the burst RAMs 300 and 302. This would result in at least one wait state in all cases, because the address to the burst RAMS could not be strobed in on PADS*.</p><p>Thus, way prediction based on a last code read or last code plus data read is crucial to operation of a single-bank two-way system.</p><p>Timing Differences Between Single-Bank Two-Way and Two-Bank Two-Way Caches</p><p>Referring to FIGS. 35A and 35B, the timing differences between a single-bank two-way cache implemented according to the invention and a two-bank two-way cache according to the invention is shown. Referring to FIG. 35A, a two-bank two-way pipelined read is illustrated. After the assertion of PADS* on operation A, the cache controller 210 asserts the appropriate COE0* or COE1* and then asserts PBRDY*. The pipelined read then occurs over the next four cycles (A.1 to A.4). At the end of those four cycles, however, if there is a way miss on the next pipelined read, so PBRDY* must be deasserted for one cycle to allow for the change of COE0* to COE1*, or vice versa. It is not possible to switch ways on the run on pipelined burst reads.</p><p>Referring to FIG. 35B, however, a pipelined burst read in a single-bank two-way cache is shown. Here it is seen that the appropriate CMWAY is set as would be COE0* or COE1*, but at the end of the pipelined read, on a way miss, CMWAY is simply switched to its opposite state. In this case, PBRDY* need not be deasserted for a cycle, so using a single-bank, two-way cache does not require an extra wait state on pipelined reads. The reads occur without interruption, but with A.4 being immediately followed by B.1.</p><p>Same Way Prediction on Pipelined Reads in a Two-Bank Two-Way Cache</p><p>Referring to FIG. 35A again, another feature of the invention will be appreciated. In a two-bank two-way cache, there is no advantage to using way prediction to the opposite way. It is seen in FIG. 35A that even on a way hit to the opposite way, an extra PBRDY* is required as is seen in cycle 5 of FIG. 35A. Therefore, the way prediction logic according to the invention on a pipelined read predicts to the way of the previous cycle (operation A). This is accomplished by the circuitry of FIGS. 6A-7G. As can be seen, one input to COE0 and COE1 are PIP<sub>--</sub> PRED<sub>--</sub> COE0 and PIP<sub>--</sub> PRED<sub>--</sub> COE1, respectively. Referring to FIGS. 7A-7G, it is seen that these have as inputs a clocked value of SYNC<sub>--</sub> COE0 and SYNC<sub>--</sub> COE1, respectively. These will only be true, however, on the second burst of a pipelined read. Through this circuitry, COE0 and COE1 are forced to their previous state on a pipelined read operation in a two-bank two-way cache. This provides the most effective method of way prediction on pipelined reads in a two-bank two-way cache.</p><p>The foregoing disclosure and description of the invention are illustrative and explanatory thereof, and various changes in the size, shape, materials, components, circuit elements, wiring connections and contacts, as well as in the details of the illustrated circuitry and construction and method of operation may be made without departing from the spirit of the invention.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Gary W.", "last_name": "Thome", "name": ""}, {"first_name": "Jens K.", "last_name": "Ramsey", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "COMPAQ COMPUTER CORPORATION"}, {"first_name": "", "last_name": "HEWLETT-PACKARD DEVELOPMENT COMPANY, L.P.", "name": ""}, {"first_name": "", "last_name": "COMPAQ INFORMATION TECHNOLOGIES GROUP, L.P.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/08"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMUS"}], "national_classes": [{"primary": true, "label": "711128"}, {"primary": false, "label": "711E12018"}], "ecla_classes": [{"label": "S06F212:6082"}, {"label": "G06F  12/08B10"}], "cpc_classes": [{"label": "G06F2212/6082"}, {"label": "G06F  12/0864"}, {"label": "G06F  12/0864"}, {"label": "G06F2212/6082"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1994-10-14", "application_date": "1997-04-23", "family_members": [{"ucid": "US-5822756-A", "titles": [{"lang": "EN", "text": "Microprocessor cache memory way prediction based on the way of a previous memory read"}]}, {"ucid": "US-5640532-A", "titles": [{"lang": "EN", "text": "Microprocessor cache memory way prediction based on the way of previous memory read"}]}]}