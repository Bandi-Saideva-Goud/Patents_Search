{"patent_number": "US-6574725-B1", "publication_id": 73426386, "family_id": 23711587, "publication_date": "2003-06-03", "titles": [{"lang": "EN", "text": "Method and mechanism for speculatively executing threads of instructions"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11521305\" source=\"national office\"><p>A processor architecture containing multiple closely coupled processors in a form of symmetric multiprocessing system is provided. The special coupling mechanism allows it to speculatively execute multiple threads in parallel very efficiently. Generally, the operating system is responsible for scheduling various threads of execution among the available processors in a multiprocessor system. One problem with parallel multithreading is that the overhead involved in scheduling the threads for execution by the operating system is such that shorter segments of code cannot efficiently take advantage of parallel multithreading. Consequently, potential performance gains from parallel multithreading are not attainable. Additional circuitry is included in a form of symmetrical multiprocessing system which enables the scheduling and speculative execution of multiple threads on multiple processors without the involvement and inherent overhead of the operating system. Advantageously, parallel multithreaded execution is more efficient and performance may be improved.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50501972\"><p>A processor architecture containing multiple closely coupled processors in a form of symmetric multiprocessing system is provided. The special coupling mechanism allows it to speculatively execute multiple threads in parallel very efficiently. Generally, the operating system is responsible for scheduling various threads of execution among the available processors in a multiprocessor system. One problem with parallel multithreading is that the overhead involved in scheduling the threads for execution by the operating system is such that shorter segments of code cannot efficiently take advantage of parallel multithreading. Consequently, potential performance gains from parallel multithreading are not attainable. Additional circuitry is included in a form of symmetrical multiprocessing system which enables the scheduling and speculative execution of multiple threads on multiple processors without the involvement and inherent overhead of the operating system. Advantageously, parallel multithreaded execution is more efficient and performance may be improved.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00001\" num=\"1\"><claim-text>1. A multiprocessor computer comprising:</claim-text><claim-text>a plurality of processors, wherein each of said processors includes a register file, a reorder buffer and circuitry to support speculative multithreaded execution; </claim-text><claim-text>a reorder buffer tag translation buffer, wherein said translation buffer maps an entry in a reorder buffer of a first processor to an entry in a reorder buffer of a second processor; and </claim-text><claim-text>a thread control device, wherein said thread control device is configured to store and transmit instructions between said processors, wherein said instructions support the speculative execution of threads on said processors, wherein said threads may be executed in parallel. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00002\" num=\"2\"><claim-text>2. The multiprocessor computer of <claim-ref idref=\"US-6574725-B1-CLM-00001\">claim 1</claim-ref>, wherein said circuitry is configured to support synchronization of said execution of said threads.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00003\" num=\"3\"><claim-text>3. The multiprocessor computer of <claim-ref idref=\"US-6574725-B1-CLM-00002\">claim 2</claim-ref>, wherein said circuitry comprises an interprocessor communication unit.</claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00004\" num=\"4\"><claim-text>4. The multiprocessor computer of <claim-ref idref=\"US-6574725-B1-CLM-00003\">claim 3</claim-ref>, wherein said interprocessor communication unit includes a reservation station.</claim-text></claim>"}, {"num": 5, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00005\" num=\"5\"><claim-text>5. The multiprocessor computer of <claim-ref idref=\"US-6574725-B1-CLM-00003\">claim 3</claim-ref>, wherein said interprocessor communication unit includes a reservation station, a Locked Read reservation station, a Locked Write reservation station, and a scratchpad functional unit.</claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00006\" num=\"6\"><claim-text>6. The multiprocessor computer of <claim-ref idref=\"US-6574725-B1-CLM-00005\">claim 5</claim-ref>, wherein said multiprocessor computer includes scratchpad instructions, wherein said scratchpad instructions support the exchange of shared data between a first thread running on a first processor and a second thread running on a second processor.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00007\" num=\"7\"><claim-text>7. The multiprocessor computer of <claim-ref idref=\"US-6574725-B1-CLM-00001\">claim 1</claim-ref>, wherein said multiprocessor computer comprises a plurality of said reorder buffer tag translation buffers.</claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00008\" num=\"8\"><claim-text>8. The multiprocessor computer recited in <claim-ref idref=\"US-6574725-B1-CLM-00001\">claim 1</claim-ref>, wherein said thread control device is configured to synchronize execution of said threads on said processors.</claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00009\" num=\"9\"><claim-text>9. The multiprocessor computer recited in <claim-ref idref=\"US-6574725-B1-CLM-00008\">claim 8</claim-ref>, wherein said thread control device comprises:</claim-text><claim-text>a storage buffer; and </claim-text><claim-text>synchronization logic, wherein said synchronization logic is configured to support the synchronization of said threads on said processors. </claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00010\" num=\"10\"><claim-text>10. The multiprocessor computer recited in <claim-ref idref=\"US-6574725-B1-CLM-00009\">claim 9</claim-ref>, wherein said thread control device further comprises:</claim-text><claim-text>a plurality of scratchpad registers. </claim-text></claim>"}, {"num": 11, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00011\" num=\"11\"><claim-text>11. The multiprocessor computer recited in <claim-ref idref=\"US-6574725-B1-CLM-00009\">claim 9</claim-ref>, wherein said storage buffer comprises a plurality of FIFOs.</claim-text></claim>"}, {"num": 12, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00012\" num=\"12\"><claim-text>12. The multiprocessor computer of <claim-ref idref=\"US-6574725-B1-CLM-00008\">claim 8</claim-ref>, wherein said synchronization of said execution of said threads comprises:</claim-text><claim-text>said first processor executing a first synchronization instruction; and </claim-text><claim-text>said second processor executing a second synchronization instruction; and </claim-text><claim-text>said first processor halting execution of said thread on said first processor, in response to detecting said first synchronization instruction is ready to retire in said first processor and said second synchronization instruction in said second processor is not ready to retire; and </claim-text><claim-text>said second processor halting execution of said thread on said second processor, in response to detecting said second synchronization instruction is ready to retire in said second processor and said first synchronization instruction in said first processor is not ready to retire; and </claim-text><claim-text>said first processor continuing execution of said thread on said first processor, in response to detecting said first synchronization instruction and said second synchronization instruction are both ready to retire; and </claim-text><claim-text>said second processor continuing execution of said thread on said second processor, in response to detecting said first synchronization instruction and said second synchronization instruction are both ready to retire. </claim-text></claim>"}, {"num": 13, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00013\" num=\"13\"><claim-text>13. The multiprocessor computer of <claim-ref idref=\"US-6574725-B1-CLM-00008\">claim 8</claim-ref>, wherein said synchronization of said execution of said threads comprises:</claim-text><claim-text>said first processor executing a first synchronization instruction; and </claim-text><claim-text>said second processor executing a second synchronization instruction; and </claim-text><claim-text>said first processor halting execution of said thread on said first processor, in response to detecting said first synchronization instruction is ready to retire in said first processor and said second synchronization instruction in said second processor is not ready to retire; and </claim-text><claim-text>said second processor halting execution of said thread on said second processor, in response to detecting said second synchronization instruction is ready to retire in said second processor and said first synchronization instruction in said first processor is not ready to retire; and </claim-text><claim-text>said first processor retiring said first synchronization instruction, in response to detecting both said first synchronization instruction and said second synchronization instruction are ready to retire; and </claim-text><claim-text>said second processor retiring said second synchronization instruction, in response to detecting both said first synchronization instruction and said second synchronization instruction are ready to retire; and </claim-text><claim-text>said first processor halting execution of said thread on said first processor, in response to detecting said first synchronization instruction in said first processor has retired and said second synchronization instruction in said second processor has not retired; and </claim-text><claim-text>said second processor halting execution of said thread on said second processor, in response to detecting said second synchronization instruction in said second processor has retired and said first synchronization instruction in said first processor has not retired; and </claim-text><claim-text>said first processor continuing execution of said thread on said first processor, in response to detecting said first synchronization instruction and said second synchronization instruction have retired; and </claim-text><claim-text>said second processor continuing execution of said thread on said second processor, in response to detecting said first synchronization instruction and said second synchronization instruction have retired. </claim-text></claim>"}, {"num": 14, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00014\" num=\"14\"><claim-text>14. The multiprocessor computer recited in <claim-ref idref=\"US-6574725-B1-CLM-00001\">claim 1</claim-ref>, wherein a first processor of said plurality of processors is a master, wherein said master executes all single threaded code on said multiprocessor computer.</claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00015\" num=\"15\"><claim-text>15. The multiprocessor computer of <claim-ref idref=\"US-6574725-B1-CLM-00014\">claim 14</claim-ref>, further comprising a plurality of multithread instructions, wherein</claim-text><claim-text>said master conveys data from a register file of said master to a second processor, in response to a first instruction of said plurality of multithread instructions; and </claim-text><claim-text>said second processor conveys data from a register file of said second processor to said master, in response to a second instruction of said plurality of multithread instructions; and </claim-text><claim-text>said second processor begins execution of a thread of instructions, in response to a third instruction of said plurality of multithread instructions; and </claim-text><claim-text>said second processor ends execution of said thread of instructions, in response to a fourth instruction of said plurality of multithread instructions; and </claim-text><claim-text>said master and said second processor synchronize thread execution, in response to a fifth instruction of said plurality of multithread instructions. </claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00016\" num=\"16\"><claim-text>16. The multiprocessor computer of <claim-ref idref=\"US-6574725-B1-CLM-00015\">claim 15</claim-ref>, wherein said first instruction is a Wr<b>2</b>Proc instruction, wherein said second instruction is a RdFrProc instruction, wherein said third instruction is a Fork instruction, wherein said fourth instruction is a Join instruction, and wherein said fifth instruction is a Sync instruction.</claim-text></claim>"}, {"num": 17, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00017\" num=\"17\"><claim-text>17. The multiprocessor computer of <claim-ref idref=\"US-6574725-B1-CLM-00015\">claim 15</claim-ref>, wherein said first instruction, said second instruction and said third instruction are speculatively executed in said second processor.</claim-text></claim>"}, {"num": 18, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00018\" num=\"18\"><claim-text>18. The multiprocessor computer of <claim-ref idref=\"US-6574725-B1-CLM-00015\">claim 15</claim-ref>, wherein</claim-text><claim-text>said first instruction is retired from a reorder buffer of said second processor, in response to detecting said first instruction is ready to retire in said reorder buffer of said second processor and receiving an indication from said master that said first instruction has retired from a reorder buffer of said master; and </claim-text><claim-text>said third instruction is retired from said reorder buffer of said second processor, in response to detecting said third instruction is ready to retire in said reorder buffer of said second processor and receiving an indication from said master that said third instruction has retired from said reorder buffer of said master. </claim-text></claim>"}, {"num": 19, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00019\" num=\"19\"><claim-text>19. The multiprocessor computer of <claim-ref idref=\"US-6574725-B1-CLM-00015\">claim 15</claim-ref>, wherein</claim-text><claim-text>said first instruction is retired from a reorder buffer of said second processor, in response to detecting said first instruction is ready to retire in said reorder buffer of said second processor and receiving an indication from said master that said third instruction has retired from a reorder buffer of said master; and </claim-text><claim-text>said third instruction is retired from said reorder buffer of said second processor, in response to detecting said third instruction is ready to retire in said reorder buffer of said second processor and receiving an indication from said master that said third instruction has retired from said reorder buffer of said master. </claim-text></claim>"}, {"num": 20, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00020\" num=\"20\"><claim-text>20. A method comprising:</claim-text><claim-text>performing thread setup for execution of said thread on a second processor, wherein said setup comprises a first processor conveying setup instructions to said second processor, wherein said setup instructions are speculatively executed on said second processor; </claim-text><claim-text>storing a reorder buffer tag of a reorder buffer in said first processor, wherein said reorder buffer tag corresponds to a location in said reorder buffer in said first processor containing a first instruction of said setup instructions; </claim-text><claim-text>conveying a startup instruction from said first processor to said second processor, wherein said startup instruction is speculatively executed on said second processor; </claim-text><claim-text>executing said thread on said second processor, in response to receiving said startup instruction, wherein said thread is speculatively executed, wherein said thread is executed in parallel with the execution of a thread on said first processor; </claim-text><claim-text>terminating said execution of said thread on said second processor, wherein said termination comprises retiring a first termination instruction in said second processor; </claim-text><claim-text>conveying results of said execution of said thread on said second processor to said first processor, in response to said second processor receiving a retrieve result instruction, wherein said retrieve result instruction is speculatively executed by said second processor; and </claim-text><claim-text>updating a reorder buffer tag translation buffer, wherein said update comprises storing in a location in said translation buffer a reorder buffer tag of said reorder buffer of said second processor, wherein said reorder buffer tag of said reorder buffer of said second processor corresponds to a location of said first instruction in said reorder buffer of said second processor, wherein said location in said translation buffer is selected by said reorder buffer tag of said reorder buffer of said first processor. </claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00021\" num=\"21\"><claim-text>21. The method recited in <claim-ref idref=\"US-6574725-B1-CLM-00020\">claim 20</claim-ref>, wherein said conveying results comprises:</claim-text><claim-text>storing a retrieve result instruction from said first processor in a first FIFO; and </claim-text><claim-text>reading said retrieve result instruction from said first FIFO by said second processor; and </claim-text><claim-text>reading data from a register file of said second processor by said second processor, wherein said data corresponds to a location in said register file of said second processor, wherein said location is indicated by said retrieve result instruction; and </claim-text><claim-text>storing said data in a second FIFO; and </claim-text><claim-text>reading said data from said second FIFO by said first processor. </claim-text></claim>"}, {"num": 22, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00022\" num=\"22\"><claim-text>22. The method recited in <claim-ref idref=\"US-6574725-B1-CLM-00020\">claim 20</claim-ref>, wherein said conveying results is subsequent to said retiring of said first termination instruction in said second processor, and wherein said conveying is subsequent to retiring a second termination instruction in said first processor.</claim-text></claim>"}, {"num": 23, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00023\" num=\"23\"><claim-text>23. The method recited in <claim-ref idref=\"US-6574725-B1-CLM-00020\">claim 20</claim-ref>, further comprising synchronizing said execution of said thread on said first processor with said execution of said thread on said second processor.</claim-text></claim>"}, {"num": 24, "parent": 23, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00024\" num=\"24\"><claim-text>24. The method recited in <claim-ref idref=\"US-6574725-B1-CLM-00023\">claim 23</claim-ref>, wherein said synchronizing comprises:</claim-text><claim-text>executing a first synchronization instruction on said first processor; and </claim-text><claim-text>executing a second synchronization instruction on said second processor; and </claim-text><claim-text>halting execution of said thread on said first processor, in response to detecting said first synchronization instruction is ready to retire and said second synchronization instruction is not ready to retire; and </claim-text><claim-text>halting execution of said thread on said second processor, in response to detecting said second synchronization instruction is ready to retire and said first synchronization instruction is not ready to retire; and </claim-text><claim-text>continuing execution of said thread on said first processor and said thread on said second processor, in response to detecting both said first synchronization instruction and said second synchronization instruction are ready to retire. </claim-text></claim>"}, {"num": 25, "parent": 23, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00025\" num=\"25\"><claim-text>25. The method recited in <claim-ref idref=\"US-6574725-B1-CLM-00023\">claim 23</claim-ref>, wherein said synchronizing comprises:</claim-text><claim-text>executing a first synchronization instruction on said first processor; and </claim-text><claim-text>executing a second synchronization instruction on said second processor; and </claim-text><claim-text>halting execution of said thread on said first processor, in response to detecting said first synchronization instruction is ready to retire and said second synchronization instruction is not ready to retire; and </claim-text><claim-text>halting execution of said thread on said second processor, in response to detecting said second synchronization instruction is ready to retire and said first synchronization instruction is not ready to retire; and </claim-text><claim-text>retiring said first synchronization instruction and said second synchronization instruction, in response to detecting said first synchronization instruction and said second synchronization instruction are both ready to retire; and </claim-text><claim-text>halting execution of said thread on said first processor, in response to detecting said first synchronization instruction has retired and said second synchronization instruction has not retired; and </claim-text><claim-text>halting execution of said thread on said second processor, in response to detecting said second synchronization instruction has retired and said first synchronization instruction has not retired; and </claim-text><claim-text>continuing execution of said thread on said first processor and said thread on said second processor, in response to detecting both said first synchronization instruction and said second synchronization instruction have retired. </claim-text></claim>"}, {"num": 26, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00026\" num=\"26\"><claim-text>26. The method recited in <claim-ref idref=\"US-6574725-B1-CLM-00020\">claim 20</claim-ref> further comprising:</claim-text><claim-text>retiring a first setup instruction of said setup instructions from a reorder buffer of said second processor, in response to detecting said first setup instruction is ready to retire in said reorder buffer of said second processor and receiving an indication from said first processor that said first setup instruction has retired from a reorder buffer in said first processor; and </claim-text><claim-text>retiring said startup instruction from a reorder buffer of a second processor, in response to detecting said startup instruction is ready to retire in said reorder buffer of said second processor and receiving an indication from said first processor that said startup instruction has retired from said reorder buffer in said first processor. </claim-text></claim>"}, {"num": 27, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00027\" num=\"27\"><claim-text>27. The method recited in <claim-ref idref=\"US-6574725-B1-CLM-00020\">claim 20</claim-ref> further comprising:</claim-text><claim-text>retiring said setup instruction from a reorder buffer of said second processor, in response to detecting said setup instruction is ready to retire in said reorder buffer of said second processor and receiving an indication from said first processor that said startup instruction has retired from a reorder buffer in said first processor; and </claim-text><claim-text>retiring said startup instruction from a reorder buffer of a second processor, in response to detecting said startup instruction is ready to retire in said reorder buffer of said second processor and receiving an indication from said first processor that said startup instruction has retired from said reorder buffer in said first processor. </claim-text></claim>"}, {"num": 28, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00028\" num=\"28\"><claim-text>28. The method of <claim-ref idref=\"US-6574725-B1-CLM-00020\">claim 20</claim-ref>, further comprising:</claim-text><claim-text>decoding a scratchpad instruction by said first processor, wherein said decoding produces a plurality of operations, wherein said plurality of operations are conveyed to a scratchpad functional unit and a first reorder buffer, wherein said plurality of operations include a locked read operation, an ALU operation, and a locked write operation; and </claim-text><claim-text>storing said locked read operation in a Locked Read reservation station and storing said locked write operation in a Locked Write reservation station; and </claim-text><claim-text>issuing said locked read operation from said Locked Read reservation station, in response to detecting all previous locked read operations in said Locked Read reservation station have completed; and </claim-text><claim-text>locking a location in a storage, wherein said location is locked by said locked read operation, in response to detecting said location is not locked; and </claim-text><claim-text>reading a contents of said locked location; and </claim-text><claim-text>issuing said locked write operation from said Locked Write reservation station, in response to detecting said locked write operation has received its input operands and said locked write operation is next to retire in said first reorder buffer; and </claim-text><claim-text>storing data in said location; and </claim-text><claim-text>unlocking said location; and </claim-text><claim-text>removing said locked read operation from said Locked Read reservation station and removing said locked write operation from said Locked Write reservation station, in response to detecting said locked read operation and said locked write operation have completed. </claim-text></claim>"}, {"num": 29, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6574725-B1-CLM-00029\" num=\"29\"><claim-text>29. The method of <claim-ref idref=\"US-6574725-B1-CLM-00028\">claim 28</claim-ref>, further comprising:</claim-text><claim-text>detecting a branch instruction in a reorder buffer is mispredicted; and </claim-text><claim-text>invalidating a plurality of instructions following said branch instruction in said reorder buffer; and </claim-text><claim-text>detecting one of said plurality of instructions is a locked instruction; and </claim-text><claim-text>conveying a plurality of reorder buffer tags to a scratchpad functional unit, wherein said reorder buffer tags correspond to said locked instruction, wherein said locked instruction is the first locked instruction in said first reorder buffer following said branch instruction; and </claim-text><claim-text>invalidating locked instructions in said scratchpad functional unit, wherein said locked instructions correspond to said plurality of reorder buffer tags; and </claim-text><claim-text>unlocking a location in a scratchpad register, in response to detecting one of said locked instructions is a locked read instruction, wherein said locked read instruction is at the front of a Locked Read reservation station, and wherein said locked read instruction has been issued.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53934030\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention is related to the field of microprocessors and, more particularly, to multithreading in multiprocessors.</p><p>2. Description of the Related Art</p><p>Computer systems employing multiple processing units hold a promise of economically accommodating performance capabilities that surpass those of current single-processor based systems. Within a multiprocessing environment, rather than concentrating all the processing for an application in a single processor, tasks are divided into groups or \u201cthreads\u201d that can be handled by separate processors. The overall processing load is thereby distributed among several processors, and the distributed tasks may be executed simultaneously in parallel. The operating system software divides various portions of the program code into the separately executable threads, and typically assigns a priority level to each thread.</p><p>Superscalar microprocessors achieve high performance by executing multiple instructions per clock cycle and by choosing the shortest possible clock cycle consistent with the design. As used herein, the term \u201cclock cycle\u201d refers to an interval of time accorded to various stages of an instruction processing pipeline within the microprocessor. Storage devices (e.g. registers and arrays) capture their values according to the clock cycle. For example, a storage device may capture a value according to a rising or falling edge of a clock signal defining the clock cycle. The storage device then stores the value until the subsequent rising or falling edge of the clock signal, respectively. The term \u201cinstruction processing pipeline\u201d is used herein to refer to the logic circuits employed to process instructions in a pipelined fashion. Although the pipeline may be divided into any number of stages at which portions of instruction processing are performed, instruction processing generally comprises fetching the instruction, decoding the instruction, executing the instruction, and storing the execution results in the destination identified by the instruction.</p><p>An important feature of microprocessors is the degree to which they can take advantage of parallelism. Parallelism is the execution of instructions in parallel, rather than serially. Superscalar processors are able to identify and utilize fine grained instruction level parallelism by executing certain instructions in parallel. However, this type of parallelism is limited by data dependencies between instructions. Further, as mentioned above, computer systems which contain more than one processor may improve performance by dividing the workload presented by the computer processes. By identifying higher levels of parallelism, multi-processor computer systems may execute larger segments of code, or threads, in parallel on separate processors. Because microprocessors and operating systems cannot identify these segments of code which are amenable to parallel multithreaded execution, they are identified by the application code itself. Generally, the operating system is responsible for scheduling the various threads of execution among the available processors in a multi-processor system.</p><p>One problem with parallel multithreading is that the overhead involved in scheduling the threads for execution by the operating system is such that shorter segments of code cannot efficiently take advantage of parallel multithreading. Consequently, potential performance gains from parallel multithreading are not attainable.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by a microprocessor and method as described herein. Additional circuitry is included in a form of symmetrical multiprocessing system which enables the scheduling and speculative execution of multiple threads on multiple processors without the involvement and inherent overhead of the operating system. Advantageously, parallel multithreaded execution is more efficient and performance is improved.</p><p>Broadly speaking, a multiprocessor computer is contemplated comprising a plurality of processors, wherein said processors include a register file, a reorder buffer and circuitry to support speculative multithreaded execution. In addition, the multiprocessor computer includes one or more reorder buffer tag translation buffers and a thread control device. The thread control device is configured to store and transmit instructions between the processors. The thread control device and instructions support parallel speculative multithreaded execution.</p><p>In addition, a method is contemplated which comprises performing thread setup for execution of a second thread on a second processor, wherein the setup comprises a first processor conveying setup instructions to a second processor, where the setup instructions are speculatively executed on the second processor. A startup instruction is conveyed from the first processor to the second processor which begins speculative execution of the second thread on the second processor. The second processor begins speculative execution of the second thread in parallel with the execution of a thread on the first processor, in response to receiving the startup instruction. Execution of the second thread is terminated, in response to retiring a termination instruction in the second processor. Finally, the results of the execution of the second thread are conveyed to the first processor, in response to the second processor receiving a retrieve result instruction, where the retrieve result instruction is speculatively executed by the second processor.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of one embodiment of a microprocessor.</p><p>FIG. 2 is a block diagram of one embodiment of a multiprocessor computer.</p><p>FIG. 3A is a diagram showing two microprocessors and a thread control device.</p><p>FIG. 3B is a flowchart illustrating thread setup, execution and completion.</p><p>FIG. 4 is a diagram showing two microprocessors and a thread control device.</p><p>FIG. 5 is a chart showing two threads of instructions and the use of a Sync instruction.</p><p>FIG. 6 shows a synchronous implementation of synchronization logic.</p><p>FIG. 7 shows an asynchronous implementation of synchronization logic.</p><p>FIG. 8 shows an instruction sequence representing an asynchronous implementation of synchronization logic.</p><p>FIG. 9 shows one embodiment of an interprocessor communication unit and a thread control device.</p><p>FIG. 10 is a block diagram of one embodiment of a computer system including the multiprocessor computer shown in FIG. <b>2</b>.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>Processor Overview</p><p>Turning now to FIG. 1, a block diagram of one embodiment of a processor <b>10</b> is shown. Other embodiments are possible and contemplated. As shown in FIG. 1, processor <b>10</b> includes a prefetch/predecode unit <b>12</b>, a branch prediction unit <b>14</b>, an instruction cache <b>16</b>, an instruction alignment unit <b>18</b>, a plurality of decode units <b>20</b>A-<b>20</b>C, a plurality of reservation stations <b>22</b>A-<b>22</b>C, a plurality of functional units <b>24</b>A-<b>24</b>C, a load/store unit <b>26</b>, a data cache <b>28</b>, a register file <b>30</b>, a reorder buffer <b>32</b>, an MROM unit <b>34</b>, an interprocessor communication unit <b>320</b>, and a bus interface unit <b>37</b>. Elements referred to herein with a particular reference number followed by a letter will be collectively referred to by the reference number alone. For example, decode units <b>20</b>A-<b>20</b>C will be collectively referred to as decode units <b>20</b>.</p><p>Prefetch/predecode unit <b>12</b> is coupled to receive instructions from bus interface unit <b>37</b>, and is further coupled to instruction cache <b>16</b> and branch prediction unit <b>14</b>. Similarly, branch prediction unit <b>14</b> is coupled to instruction cache <b>16</b>. Still further, branch prediction unit <b>14</b> is coupled to decode units <b>20</b> and functional units <b>24</b>. Instruction cache <b>16</b> is further coupled to MROM unit <b>34</b> and instruction alignment unit <b>18</b>. Instruction alignment unit <b>18</b> is in turn coupled to decode units <b>20</b>. Each decode unit <b>20</b>A-<b>20</b>C is coupled to load/store unit <b>26</b> and to respective reservation stations <b>22</b>A-<b>22</b>C. Reservation stations <b>22</b>A-<b>22</b>C are further coupled to respective functional units <b>24</b>A-<b>24</b>C. Additionally, decode units <b>20</b> and reservation stations <b>22</b> are coupled to register file <b>30</b> and reorder buffer <b>32</b>. Functional units <b>24</b> are coupled to load/store unit <b>26</b>, register file <b>30</b>, and reorder buffer <b>32</b> as well. Data cache <b>28</b> is coupled to load/store unit <b>26</b> and to bus interface unit <b>37</b>. Bus interface unit <b>37</b> is further coupled to an L<b>2</b> interface to an L<b>2</b> cache and a bus. Interprocessor communication unit <b>320</b> is coupled to reorder buffer <b>32</b> and result bus <b>38</b>. Finally, MROM unit <b>34</b> is coupled to decode units <b>20</b>.</p><p>Instruction cache <b>16</b> is a high speed cache memory provided to store instructions. Instructions are fetched from instruction cache <b>16</b> and dispatched to decode units <b>20</b>. In one embodiment, instruction cache <b>16</b> is configured to store up to 64 kilobytes of instructions in a 2 way set associative structure having 64 byte lines (a byte comprises 8 binary bits). Alternatively, any other desired configuration and size may be employed. For example, it is noted that instruction cache <b>16</b> may be implemented as a fully associative, set associative, or direct mapped configuration.</p><p>Instructions are stored into instruction cache <b>16</b> by prefetch/predecode unit <b>12</b>. Instructions may be prefetched prior to the request thereof from instruction cache <b>16</b> in accordance with a prefetch scheme. A variety of prefetch schemes may be employed by prefetch/predecode unit <b>12</b>. As prefetch/predecode unit <b>12</b> transfers instructions to instruction cache <b>16</b>, prefetch/predecode unit <b>12</b> generates three predecode bits for each byte of the instructions: a start bit, an end bit, and a functional bit. The predecode bits form tags indicative of the boundaries of each instruction. The predecode tags may also convey additional information such as whether a given instruction can be decoded directly by decode units <b>20</b> or whether the instruction is executed by invoking a microcode procedure controlled by MROM unit <b>34</b>, as will be described in greater detail below. Still further, prefetch/predecode unit <b>12</b> may be configured to detect branch instructions and to store branch prediction information corresponding to the branch instructions into branch prediction unit <b>14</b>. Other embodiments may employ any suitable predecode scheme.</p><p>One encoding of the predecode tags for an embodiment of processor <b>10</b> employing a variable byte length instruction set will next be described. A variable byte length instruction set is an instruction set in which different instructions may occupy differing numbers of bytes. An exemplary variable byte length instruction set employed by one embodiment of processor <b>10</b> is the x86 instruction set.</p><p>In the exemplary encoding, if a given byte is the first byte of an instruction, the start bit for that byte is set. If the byte is the last byte of an instruction, the end bit for that byte is set. Instructions which may be directly decoded by decode units <b>20</b> are referred to as \u201cfast path\u201d instructions. The remaining x86 instructions are referred to as MROM instructions, according to one embodiment. For fast path instructions, the functional bit is set for each prefix byte included in the instruction, and cleared for other bytes. Alternatively, for MROM instructions, the functional bit is cleared for each prefix byte and set for other bytes. The type of instruction may be determined by examining the functional bit corresponding to the end byte. If that functional bit is clear, the instruction is a fast path instruction. Conversely, if that functional bit is set, the instruction is an MROM instruction. The opcode of an instruction may thereby be located within an instruction which may be directly decoded by decode units <b>20</b> as the byte associated with the first clear functional bit in the instruction. For example, a fast path instruction including two prefix bytes, a Mod R/M byte, and an immediate byte would have start, end, and functional bits as follows:</p><p>Start bits <b>10000</b></p><p>End bits <b>00001</b></p><p>Functional bits <b>11000</b></p><p>MROM instructions are instructions which are determined to be too complex for decode by decode units <b>20</b>. MROM instructions are executed by invoking MROM unit <b>34</b>. More specifically, when an MROM instruction is encountered, MROM unit <b>34</b> parses and issues the instruction into a subset of defined fast path instructions to effectuate the desired operation. MROM unit <b>34</b> dispatches the subset of fast path instructions to decode units <b>20</b>.</p><p>Processor <b>10</b> employs branch prediction in order to speculatively fetch instructions subsequent to conditional branch instructions. Branch prediction unit <b>14</b> is included to perform branch prediction operations. In one embodiment, branch prediction unit <b>14</b> employs a branch target buffer which caches up to two branch target addresses and corresponding taken/not taken predictions per 16 byte portion of a cache line in instruction cache <b>16</b>. The branch target buffer may, for example, comprise 2048 entries or any other suitable number of entries. Prefetch/predecode unit <b>12</b> determines initial branch targets when a particular line is predecoded. Subsequent updates to the branch targets corresponding to a cache line may occur due to the execution of instructions within the cache line. Instruction cache <b>16</b> provides an indication of the instruction address being fetched, so that branch prediction unit <b>14</b> may determine which branch target addresses to select for forming a branch prediction. Decode units <b>20</b> and functional units <b>24</b> provide update information to branch prediction unit <b>14</b>. Decode units <b>20</b> detect branch instructions which were not predicted by branch prediction unit <b>14</b>. Functional units <b>24</b> execute the branch instructions and determine if the predicted branch direction is incorrect. The branch direction may be \u201ctaken\u201d, in which subsequent instructions are fetched from the target address of the branch instruction. Conversely, the branch direction may be \u201cnot taken\u201d, in which subsequent instructions are fetched from memory locations consecutive to the branch instruction. When a mispredicted branch instruction is detected, instructions subsequent to the mispredicted branch are discarded from the various units of processor <b>10</b>. In an alternative configuration, branch prediction unit <b>14</b> may be coupled to reorder buffer <b>32</b> instead of decode units <b>20</b> and functional units <b>24</b>, and may receive branch misprediction information from reorder buffer <b>32</b>. A variety of suitable branch prediction algorithms may be employed by branch prediction unit <b>14</b>.</p><p>Instructions fetched from instruction cache <b>16</b> are conveyed to instruction alignment unit <b>18</b>. As instructions are fetched from instruction cache <b>16</b>, the corresponding predecode data is scanned to provide information to instruction alignment unit <b>18</b> (and to MROM unit <b>34</b>) regarding the instructions being fetched. Instruction alignment unit <b>18</b> utilizes the scanning data to align an instruction to each of decode units <b>20</b>. In one embodiment, instruction alignment unit <b>18</b> aligns instructions from three sets of eight instruction bytes to decode units <b>20</b>. Decode unit <b>20</b>A receives an instruction which is prior to instructions concurrently received by decode units <b>20</b>B and <b>20</b>C (in program order). Similarly, decode unit <b>20</b>B receives an instruction which is prior to the instruction concurrently received by decode unit <b>20</b>C in program order.</p><p>Decode units <b>20</b> are configured to decode instructions received from instruction alignment unit <b>18</b>. Register operand information is detected and routed to register file <b>30</b> and reorder buffer <b>32</b>. Additionally, if the instructions require one or more memory operations to be performed, decode units <b>20</b> dispatch the memory operations to load/store unit <b>26</b>. Each instruction is decoded into a set of control values for functional units <b>24</b>, and these control values are dispatched to reservation stations <b>22</b> along with operand address information and displacement or immediate data which may be included with the instruction. In one particular embodiment, each instruction is decoded into up to two operations which may be separately executed by functional units <b>24</b>A-<b>24</b>C.</p><p>Processor <b>10</b> supports out of order execution, and thus employs reorder buffer <b>32</b> to keep track of the original program sequence for register read and write operations, to implement register renaming, to allow for speculative instruction execution and branch misprediction recovery, and to facilitate precise exceptions. A temporary storage location within reorder buffer <b>32</b> is reserved upon decode of an instruction that involves the update of a register to thereby store speculative register states. If a branch prediction is incorrect, the results of speculatively-executed instructions along the mispredicted path can be invalidated in the buffer before they are written to register file <b>30</b>. Similarly, if a particular instruction causes an exception, instructions subsequent to the particular instruction may be discarded. In this manner, exceptions are \u201cprecise\u201d (i.e. instructions subsequent to the particular instruction causing the exception are not completed prior to the exception). It is noted that a particular instruction is speculatively executed if it is executed prior to instructions which precede the particular instruction in program order. Preceding instructions may be a branch instruction or an exception-causing instruction, in which case the speculative results may be discarded by reorder buffer <b>32</b>.</p><p>The instruction control values and immediate or displacement data provided at the outputs of decode units <b>20</b> are routed directly to respective reservation stations <b>22</b>. In one embodiment, each reservation station <b>22</b> is capable of holding instruction information (i.e., instruction control values as well as operand values, operand tags and/or immediate data) for up to five pending instructions awaiting issue to the corresponding functional unit. It is noted that for the embodiment of FIG. 1, each reservation station <b>22</b> is associated with a dedicated functional unit <b>24</b>. Accordingly, three dedicated \u201cissue positions\u201d are formed by reservation stations <b>22</b> and functional units <b>24</b>. In other words, issue position <b>0</b> is formed by reservation station <b>22</b>A and functional unit <b>24</b>A. Instructions aligned and dispatched to reservation station <b>22</b>A are executed by functional unit <b>24</b>A. Similarly, issue position <b>1</b> is formed by reservation station <b>22</b>B and functional unit <b>24</b>B; and issue position <b>2</b> is formed by reservation station <b>22</b>C and functional unit <b>24</b>C.</p><p>Upon decode of a particular instruction, if a required operand is a register location, register address information is routed to reorder buffer <b>32</b> and register file <b>30</b> simultaneously. In one embodiment, reorder buffer <b>32</b> includes a future file which receives operand requests from decode units as well. Those of skill in the art will appreciate that the x86 register file includes eight 32 bit real registers (i.e., typically referred to as EAX, EBX, ECX, EDX, EBP, ESI, EDI and ESP). In embodiments of processor <b>10</b> which employ the x86 processor architecture, register file <b>30</b> comprises storage locations for each of the 32 bit real registers. Additional storage locations may be included within register file <b>30</b> for use by MROM unit <b>34</b>. Reorder buffer <b>32</b> contains temporary storage locations for results which change the contents of these registers to thereby allow out of order execution. A temporary storage location of reorder buffer <b>32</b> is reserved for each instruction which, upon decode, is determined to modify the contents of one of the real registers. Therefore, at various points during execution of a particular program, reorder buffer <b>32</b> may have one or more locations which contain the speculatively executed contents of a given register. If following decode of a given instruction it is determined that reorder buffer <b>32</b> has a previous location or locations assigned to a register used as an operand in the given instruction, the reorder buffer <b>32</b> forwards to the corresponding reservation station either: 1) the value in the most recently assigned location, or 2) a tag for the most recently assigned location if the value has not yet been produced by the functional unit that will eventually execute the previous instruction. If reorder buffer <b>32</b> has a location reserved for a given register, the operand value (or reorder buffer tag) is provided from reorder buffer <b>32</b> rather than from register file <b>30</b>. If there is no location reserved for a required register in reorder buffer <b>32</b>, the value is taken directly from register file <b>30</b>. If the operand corresponds to a memory location, the operand value is provided to the reservation station through load/store unit <b>26</b>.</p><p>In one particular embodiment, reorder buffer <b>32</b> is configured to store and manipulate concurrently decoded instructions as a unit. This configuration will be referred to herein as \u201cline-oriented\u201d. By manipulating several instructions together, the hardware employed within reorder buffer <b>32</b> may be simplified. For example, a line-oriented reorder buffer included in the present embodiment allocates storage sufficient for instruction information pertaining to three instructions (one from each decode unit <b>20</b>) whenever one or more instructions are issued by decode units <b>20</b>. By contrast, a variable amount of storage is allocated in conventional reorder buffers, dependent upon the number of instructions actually dispatched. A comparatively larger number of logic gates may be required to allocate the variable amount of storage. When each of the concurrently decoded instructions has executed, the instruction results are stored into register file <b>30</b> simultaneously. The storage is then free for allocation to another set of concurrently decoded instructions. Additionally, the amount of control logic circuitry employed per instruction is reduced because the control logic is amortized over several concurrently decoded instructions. A reorder buffer tag identifying a particular instruction may be divided into two fields: a line tag and an offset tag. The line tag identifies the set of concurrently decoded instructions including the particular instruction, and the offset tag identifies which instruction within the set corresponds to the particular instruction. It is noted that storing instruction results into register file <b>30</b> and freeing the corresponding storage is referred to as \u201cretiring\u201d the instructions. It is further noted that any reorder buffer configuration may be employed in various embodiments of processor <b>10</b>, including using a future file to store the speculative state of register file <b>30</b>.</p><p>As noted earlier, reservation stations <b>22</b> store instructions until the instructions are executed by the corresponding functional unit <b>24</b>. An instruction is selected for execution if: (i) the operands of the instruction have been provided; and (ii) the operands have not yet been provided for instructions which are within the same reservation station <b>22</b>A-<b>22</b>C and which are prior to the instruction in program order. It is noted that when an instruction is executed by one of the functional units <b>24</b>, the result of that instruction is passed directly to any reservation stations <b>22</b> that are waiting for that result at the same time the result is passed to update reorder buffer <b>32</b> (this technique is commonly referred to as \u201cresult forwarding\u201d). An instruction may be selected for execution and passed to a functional unit <b>24</b>A-<b>24</b>C during the clock cycle that the associated result is forwarded. Reservation stations <b>22</b> route the forwarded result to the functional unit <b>24</b> in this case. In embodiments in which instructions may be decoded into multiple operations to be executed by functional units <b>24</b>, the operations may be scheduled separately from each other.</p><p>In one embodiment, each of the functional units <b>24</b> is configured to perform integer arithmetic operations of addition and subtraction, as well as shifts, rotates, logical operations, and branch operations. The operations are performed in response to the control values decoded for a particular instruction by decode units <b>20</b>. It is noted that a floating point unit (not shown) may also be employed to accommodate floating point operations. The floating point unit may be operated as a coprocessor, receiving instructions from MROM unit <b>34</b> or reorder buffer <b>32</b> and subsequently communicating with reorder buffer <b>32</b> to complete the instructions. Additionally, functional units <b>24</b> may be configured to perform address generation for load and store memory operations performed by load/store unit <b>26</b>. In one particular embodiment, each functional unit <b>24</b> may comprise an address generation unit for generating addresses and an execute unit for performing the remaining functions. The two units may operate independently upon different instructions or operations during a clock cycle.</p><p>Each of the functional units <b>24</b> also provides information regarding the execution of conditional branch instructions to the branch prediction unit <b>14</b>. If a branch prediction was incorrect, branch prediction unit <b>14</b> flushes instructions subsequent to the mispredicted branch that have entered the instruction processing pipeline, and causes fetch of the required instructions from instruction cache <b>16</b> or main memory. It is noted that in such situations, results of instructions in the original program sequence which occur after the mispredicted branch instruction are discarded, including those which were speculatively executed and temporarily stored in load/store unit <b>26</b> and reorder buffer <b>32</b>. It is further noted that branch execution results may be provided by functional units <b>24</b> to reorder buffer <b>32</b>, which may indicate branch mispredictions to functional units <b>24</b>.</p><p>Results produced by functional units <b>24</b> are sent to reorder buffer <b>32</b> if a register value is being updated, and to load/store unit <b>26</b> if the contents of a memory location are changed. If the result is to be stored in a register, reorder buffer <b>32</b> stores the result in the location reserved for the value of the register when the instruction was decoded. A plurality of result buses <b>38</b> are included for forwarding of results from functional units <b>24</b> and load/store unit <b>26</b>. Result buses <b>38</b> convey the result generated, as well as the reorder buffer tag identifying the instruction being executed.</p><p>Load/store unit <b>26</b> provides an interface between functional units <b>24</b> and data cache <b>28</b>. In one embodiment, load/store unit <b>26</b> is configured with a first load/store buffer having storage locations for data and address information for pending loads or stores which have not accessed data cache <b>28</b> and a second load/store buffer having storage locations for data and address information for loads and stores which have accessed data cache <b>28</b>. For example, the first buffer may comprise <b>12</b> locations and the second buffer may comprise <b>32</b> locations. Decode units <b>20</b> arbitrate for access to the load/store unit <b>26</b>. When the first buffer is full, a decode unit must wait until load/store unit <b>26</b> has room for the pending load or store request information. Load/store unit <b>26</b> also performs dependency checking for load memory operations against pending store memory operations to ensure that data coherency is maintained. A memory operation is a transfer of data between processor <b>10</b> and the main memory subsystem. Memory operations may be the result of an instruction which utilizes an operand stored in memory, or may be the result of a load/store instruction which causes the data transfer but no other operation. Additionally, load/store unit <b>26</b> may include a special register storage for special registers such as the segment registers and other registers related to the address translation mechanism defined by the x86 processor architecture.</p><p>Data cache <b>28</b> is a high speed cache memory provided to temporarily store data being transferred between load/store unit <b>26</b> and the main memory subsystem. In one embodiment, data cache <b>28</b> has a capacity of storing up to 64 kilobytes of data in a two way set associative structure. It is understood that data cache <b>28</b> may be implemented in a variety of specific memory configurations, including a set associative configuration, a fully associative configuration, a direct-mapped configuration, and any suitable size of any other configuration.</p><p>Interprocessor communication unit <b>320</b> provides an interface for communicating with another processor in a multithreaded multiprocessor configuration. In one embodiment, interprocessor communication unit <b>320</b> may include a reservation station for temporarily storing instructions to be executed. In addition, in one embodiment, interprocessor communication unit <b>320</b> interfaces to a thread control device which facilitates multithread related communications between processors.</p><p>In one particular embodiment of processor <b>10</b> employing the x86 processor architecture, instruction cache <b>16</b> and data cache <b>28</b> are linearly addressed and physically tagged. The linear address is formed from the offset specified by the instruction and the base address specified by the segment portion of the x86 address translation mechanism. Linear addresses may optionally be translated to physical addresses for accessing a main memory. The linear to physical translation is specified by the paging portion of the x86 address translation mechanism. The physical address is compared to the physical tags to determine a hit/miss status.</p><p>Bus interface unit <b>37</b> is configured to communicate between processor <b>10</b> and other components in a computer system via a bus. For example, the bus may be compatible with the EV-6 bus developed by Digital Equipment Corporation. Alternatively, any suitable interconnect structure may be used including packet-based, unidirectional or bi-directional links, etc. An optional L<b>2</b> cache interface may be employed as well for interfacing to a level two cache.</p><p>Symmetric Multiprocessing</p><p>FIG. 2 is a block diagram of one embodiment of a multiprocessor computer <b>100</b> including a plurality of processing units <b>12</b>A-<b>12</b>B, a thread control device <b>300</b>, a bus bridge <b>30</b> and a memory <b>20</b>. Each processing unit <b>12</b>A-<b>12</b>B includes a processing core <b>14</b>A-<b>14</b>B, an L<b>1</b> cache memory <b>16</b>A-<b>16</b>B, and a bus interface <b>18</b>A-<b>18</b>B, respectively. The processing units <b>12</b>A-<b>12</b>B are coupled to a main memory <b>20</b> via a system bus <b>22</b>.</p><p>The multiprocessor computer <b>100</b> of FIG. 2 is symmetrical in the sense that all processing units <b>12</b>A-<b>12</b>B share the same memory space (i.e., main memory <b>20</b>) and access the memory space using the same address mapping. The multiprocessing system <b>100</b> is further symmetrical in the sense that all processing units <b>12</b>A-<b>12</b>B share equal access to the same I/O subsystem.</p><p>In general, a single copy of the operating system software as well as a single copy of each user application file is stored within main memory <b>20</b>. Each processing unit <b>12</b>A-<b>12</b>B executes from these single copies of the operating system and user application files. Although processing cores <b>14</b>A-<b>14</b>B may be executing code simultaneously, it is noted that only one of the processing units <b>12</b>A-<b>12</b>B may assume mastership of the system bus <b>22</b> at a given time. Thus, a bus arbitration mechanism, bus bridge <b>30</b>, is provided to arbitrate concurrent bus requests of two or more processing units and to grant mastership to one of the processing units based on a predetermined arbitration algorithm. A variety of bus arbitration techniques are well-known.</p><p>The high speed cache memory <b>16</b>A-<b>16</b>B of each processing unit <b>12</b>A-<b>12</b>B, respectively, stores data most recently accessed by the respective processing unit along with address tags that indicate the main memory address to which the associated data corresponds. Since programs tend to execute the same sections of code and access the same data structures repeatedly, many of the locations accessed will already be stored in the cache if the cache is sufficiently large.</p><p>The cache mechanisms provide two significant benefits. First, because the caches are implemented with high-speed memory and can be accessed without bus arbitration and buffer delays, an access to a location stored in a respective cache is much faster than a main memory access. Second, because an access to a location stored in the respective cache does not require access to the system bus, the bus utilization of each processor is greatly reduced. The system bus is therefore available to service other requested transactions. Typically, the higher the \u201chit rate\u201d, the better the overall system performance. The hit rate is the percentage of accesses by a particular processing core that are to locations already stored in the cache. Well designed systems with moderately large caches can achieve hit rates of over ninety percent.</p><p>An important consideration with respect to multiprocessing systems that employ cache memories is data coherency. Since multiple copies of the data (and instructions) stored by main memory <b>20</b> may concurrently reside in one or more of the cache memories <b>16</b>A-<b>16</b>B, a specialized mechanism must be employed to maintain the integrity of data in the event that one of the memory subsystems is updated (i.e., written with new data). For example, consider a situation wherein a particular section of data is updated within cache memory <b>16</b>A by processing core <b>14</b>A but is not updated within the corresponding section of main memory <b>20</b>. If processing core <b>14</b>B subsequently accesses the same section of code, there must be some reliable mechanism to track which section is up-to-date and which section is no longer valid to ensure that processing core <b>14</b>B accesses the proper data. A variety of techniques have therefore been developed with the goal of efficiently maintaining cache coherency, including those based on so-called write-through and write-back techniques. Various cache coherency techniques are described within a host of publications of the known prior art, and are not discussed further herein.</p><p>General Operation</p><p>FIGS. 3A and 3B illustrate the general operation of multithreaded multiprocessing. In FIG. 3A, interconnection between two processors <b>12</b>A-<b>12</b>B and a thread control device <b>300</b> is shown. FIG. 3B is a flowchart illustrating the general operation of the multiprocessor computer shown in FIG. <b>3</b>A. Each processor <b>12</b>A-<b>12</b>B includes a processing core <b>14</b>A-<b>14</b>B, an L<b>1</b> cache <b>16</b>A-<b>16</b>B, a reorder buffer tag translation buffer (RTB) <b>330</b>A-<b>330</b>B, and an interprocessor communication unit (hereinafter ICU) <b>320</b>A-<b>320</b>B. Also shown is thread control device <b>300</b> which includes first-in-first-out (hereinafter FIFO) buffers <b>310</b>A-<b>310</b>B, and synchronization logic <b>314</b>.</p><p>The ICUs <b>320</b> of each processor <b>12</b> are coupled to thread control device <b>300</b> which facilitates communication between processors <b>12</b>A and <b>12</b>B. In general, one processor <b>12</b>A serves as master and the other processor <b>12</b>B serves as slave. The master processor <b>12</b>A runs all single threaded code, sets up and starts thread execution on the slave processor <b>12</b>B and consolidates execution results following thread execution. In general, processing core <b>14</b>A executes single threaded code (block <b>330</b>) until a multithread setup instruction is encountered. When processing core <b>12</b>A encounters a multithread setup instruction (block <b>332</b>), processing core <b>12</b>A conveys thread setup instructions to ICU <b>320</b>A which conveys them to FIFO <b>1</b><b>310</b>A. ICU <b>320</b>B retrieves instructions from FIFO <b>1</b><b>310</b>A and transfers them to processing core <b>14</b>B. Subsequently, master processor <b>12</b>A conveys a thread <b>2</b> startup instruction (block <b>334</b>) to ICU <b>320</b>A which places the instruction into FIFO <b>1</b><b>310</b>A. ICU <b>320</b>B retrieves the thread startup instruction from FIFO <b>1</b><b>310</b>A and transfers it to processing core <b>14</b>B. Processing core <b>14</b>B then begins fetching and executing the thread <b>2</b> code (block <b>338</b>) while processor <b>12</b>A continues execution of thread <b>1</b> code (block <b>336</b>). Upon execution and retirement of a JOIN instruction (blocks <b>340</b> and <b>342</b>) by both processors <b>12</b>, slave processor <b>12</b>B terminates execution of thread <b>2</b> and single threaded execution resumes with master processor <b>12</b>A. Master processor <b>12</b>A may then convey another instruction to processor <b>12</b>B which causes slave processor <b>12</b>B to convey thread <b>2</b> execution results to master processor <b>12</b>A via FIFO <b>310</b>B. Master processor <b>12</b>A may then consolidate execution results from the separate threads (block <b>344</b>) and continue normal execution (block <b>346</b>). To summarize, master processor <b>12</b>A sets up a second thread for execution on slave processor <b>12</b>B. Both the master <b>12</b>A and slave <b>12</b>B processors execute threads in parallel. Master processor <b>12</b>A then obtains the second thread execution results from the slave processor.</p><p>Detailed Description of Operation</p><p>FIG. 4 shows one embodiment of a multithreaded multiprocessor. Included in FIG. 4 are portions of processors <b>12</b>A and <b>12</b>B, thread control device <b>300</b>, and bus <b>22</b>. Processors <b>12</b> include an ICU <b>320</b>, register file <b>30</b>, reorder buffer <b>32</b>, system bus <b>38</b> and bus interface unit <b>37</b>. In addition, ICU <b>320</b>A includes a reservation station <b>402</b> and a reorder buffer tag translation buffer (hereinafter RTB) <b>400</b>. Thread control device <b>300</b> includes two FIFOs <b>310</b> and synchronization logic <b>314</b>. ICUs <b>320</b> are coupled to reorder buffer <b>32</b> and system bus <b>38</b>. Register file <b>30</b> and bus interface unit <b>37</b> are coupled to bus <b>38</b>. Bus interface unit <b>37</b> is also coupled to bus <b>22</b>. Thread control device <b>300</b> is coupled to ICU <b>320</b>.</p><p>In one embodiment of the multithreaded multiprocessor shown in FIG. 4, the five following instructions are used for the control of threads: Wr<b>2</b>Proc, RdFrProc, Fork, Join, Sync. Table 1 below gives a brief description of the purpose of each instruction.</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217pt\"></colspec><thead><row><entry nameend=\"1\" namest=\"1\" rowsep=\"1\">TABLE 1</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" nameend=\"1\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Thread Control Instructions</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"35pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77pt\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"105pt\"></colspec><tbody valign=\"top\"><row><entry>Instruction</entry><entry>Syntax</entry><entry>Purpose</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>Wr2Proc</entry><entry>Wr2Proc PNo, destreg,</entry><entry>To move data from the register file</entry></row><row><entry></entry><entry>srcreg</entry><entry>of the current processor to the</entry></row><row><entry></entry><entry></entry><entry>register file of another processor.</entry></row><row><entry></entry><entry></entry><entry>PNo = number of destination</entry></row><row><entry></entry><entry></entry><entry>processor.</entry></row><row><entry></entry><entry></entry><entry>destreg = register identifier on</entry></row><row><entry></entry><entry></entry><entry>destination processor.</entry></row><row><entry></entry><entry></entry><entry>srcreg = register identifier on</entry></row><row><entry></entry><entry></entry><entry>current processor (source).</entry></row><row><entry>RdFrProc</entry><entry>Rd2Proc PNo, destreg,</entry><entry>To move data from the register file</entry></row><row><entry></entry><entry>srcreg</entry><entry>of another processor to the register</entry></row><row><entry></entry><entry></entry><entry>file of the current processor.</entry></row><row><entry></entry><entry></entry><entry>PNo = number of destination</entry></row><row><entry></entry><entry></entry><entry>processor.</entry></row><row><entry></entry><entry></entry><entry>destreg = register identifier on</entry></row><row><entry></entry><entry></entry><entry>current processor (destination).</entry></row><row><entry></entry><entry></entry><entry>srcreg = register identifier on</entry></row><row><entry></entry><entry></entry><entry>source processor.</entry></row><row><entry>Fork</entry><entry>PNo, ThrdAddr</entry><entry>Starts speculative execution of a</entry></row><row><entry></entry><entry></entry><entry>thread on another processor.</entry></row><row><entry></entry><entry></entry><entry>PNo = number of processor to start</entry></row><row><entry></entry><entry></entry><entry>thread on.</entry></row><row><entry></entry><entry></entry><entry>ThrdAddr = address of thread</entry></row><row><entry></entry><entry></entry><entry>code.</entry></row><row><entry>Join</entry><entry>Join</entry><entry>Ends execution of thread code.</entry></row><row><entry>Sync</entry><entry>Sync</entry><entry>Serializes execution until all</entry></row><row><entry></entry><entry></entry><entry>processors have reached the</entry></row><row><entry></entry><entry></entry><entry>synchronization point.</entry></row><row><entry align=\"center\" nameend=\"3\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>Briefly, master processor <b>12</b>A sets up a second thread for execution by conveying Wr<b>2</b>Proc instructions to slave processor <b>12</b>B. Wr<b>2</b>Proc instructions move data from the register file of the master processor to the slave processor. To start execution of the second thread, the Fork instruction is used. When the master processor <b>12</b>A conveys a Fork instruction to slave processor <b>12</b>B, slave processor <b>12</b>B places the Fork instruction in its reorder buffer <b>32</b>B and begins fetching the instructions for the second thread from the thread address conveyed with the Fork instruction. Execution of the second thread terminates upon execution of a Join instruction. The ability to speculatively execute thread instructions is important as is discussed below. Support for speculative execution is discussed next, followed by a more detailed discussion of the overall mechanism of thread setup and execution.</p><p>Support for Speculative Thread Execution</p><p>State of the art superscalar processors have large instruction windows. Consequently, to wait for a Fork instruction to retire before thread startup may result in significant delays. To allow optimal thread startup, the mechanism should allow for speculative startup of threads. This allows the second thread to startup and execute in the slave processor long before the Fork instruction retires in the master processor. Advantageously, performance of the multithreaded multiprocessor is improved.</p><p>To support speculative thread execution, a reorder buffer tag translation buffer (RTB) <b>400</b> is included in each processor <b>12</b> which maps the location of an instruction in one processor reorder buffer to the location of the same instruction in another processor reorder buffer. In one embodiment, the RTB <b>400</b> has the same number of entries as the reorder buffer <b>32</b>. The RTB is addressed with the reorder buffer <b>32</b> tag of a first processor and the addressed entry of the RTB <b>400</b> contains the corresponding reorder buffer tag <b>32</b> of the second processor.</p><p>To enable speculative startup and execution of threads, the Wr<b>2</b>Proc and Fork instructions are processed speculatively. When Wr<b>2</b>Proc and Fork are dispatched to the master processor ICU <b>320</b>A, they are also sent to the slave processor <b>12</b>B via FIFO <b>1</b><b>310</b>A. Two possibilities may exist when the Wr<b>2</b>Proc instruction is dispatched to the master ICU <b>320</b>A: data is available or data is not available. If data is available, the instruction, reorder buffer <b>32</b>A tag of the instruction, and an \u201cadd instruction\u201d are sent to the slave processor. The instruction and data are inserted into the reorder buffer <b>32</b>B of the slave processor and the entry is marked as having valid data. In addition, the RTB <b>400</b>B of the slave is updated to indicate the correspondence between the reorder buffer <b>32</b>A entry and the reorder buffer <b>32</b>B entry. If data is not available upon dispatch to the master processor ICU <b>320</b>A, the instructions remain in the ICU reservation station <b>402</b>A of the master processor ICU <b>320</b>A until data is available. However, the instruction is still sent to the slave processor <b>12</b>B. The instructions are inserted into the reorder buffer <b>32</b>B of the slave processor, the entries in the slave processor reorder buffer <b>32</b>B are marked as not having valid data, and the RTB <b>400</b>B is updated as described above. Instructions in slave processor reorder buffer <b>32</b>B that are marked as not having valid data may not execute until data is available. When data becomes available for an instruction waiting in the reservation station <b>402</b>A of the master processor <b>12</b>A, the instruction is removed from the reservation station <b>402</b>A of the master processor <b>12</b>A and issues to ICU <b>320</b>A. When the ICU <b>320</b>A receives the instruction, the data and the reorder buffer <b>32</b>A tag of the master processor, along with a \u201cdata update\u201d command are sent to the slave processor <b>12</b>B. The slave processor <b>12</b>B translates the reorder buffer <b>32</b>A tag using the RTB <b>400</b>B to identify the tag of the instruction in the slave processor <b>12</b>B reorder buffer <b>32</b>B. The corresponding reorder buffer <b>32</b>B tag is then used to insert the data into the correct reorder buffer <b>32</b>B entry. The instruction in the slave processor reorder buffer <b>32</b>B is now marked as having valid data and dependent instructions in slave processor <b>12</b>B may issue.</p><p>Thread Setup and Thread Startup</p><p>To setup a second thread for execution on another processor, master processor <b>12</b>A conveys speculative Wr<b>2</b>Proc instructions to slave processor <b>12</b>B via FIFO <b>1</b><b>310</b>A. In addition to the Wr<b>2</b>Proc instruction, master processor <b>12</b>A conveys the reorder buffer <b>32</b>A tag of the instruction to slave processor <b>12</b>B. The instructions are placed into the reorder buffer <b>32</b>B of the slave processor. If the data for the Wr<b>2</b>Proc instruction is available, it is placed in reorder buffer <b>32</b>B as well. Otherwise, the reorder buffer <b>32</b>B entry is marked as not having valid data. In parallel, the RTB <b>400</b>B of the slave processor is updated by placing the tag of the slave processor reorder buffer <b>32</b>B in the location indexed by the tag of the master processor reorder buffer <b>32</b>A. If the reorder buffer <b>32</b>B of the slave processor <b>12</b>B is full, no instructions will be received from the master processor <b>12</b>A. When space is available in slave processor reorder buffer <b>12</b>B, master processor <b>12</b>A receives an indication and pending instructions may be sent.</p><p>After setup of the second thread is complete, the Fork instruction is used to start execution of the second thread. When a Fork instruction is encountered by the master processor, it is sent to the slave processor <b>12</b>B via thread control device <b>300</b> as described above. If the slave processor <b>12</b>B is already running a thread, the Fork instruction is ignored. An indication is made by the slave processor <b>12</b>B as to the success of the Fork operation. Such an indication may be made by various means, such as setting an ordinary processor flag which may be checked by the master processor <b>12</b>A. Other embodiments may use other means to ensure an attempt to start a second thread is not made while another thread is already is running, eliminating the need for setting and checking of flags. If the slave processor <b>12</b>B is not already running a thread, the Fork instruction is placed in reorder buffer <b>32</b>B and the slave processor begins fetching instructions for the second thread. The newly fetched thread instructions are placed in reorder buffer <b>32</b>B behind the Fork instruction and are dispatched to the processor functional units for execution. Those instructions which have no outstanding dependencies on the Wr<b>2</b>Proc instructions may issue. Advantageously, many nondependent instructions may issue in the slave processor <b>12</b>B before the Fork instruction has retired in the master processor <b>12</b>A. The mechanism of executing the thread instructions after the Fork instruction in the slave processor <b>12</b>B is identical to a regular superscalar processor.</p><p>Branch Misprediction and Correction</p><p>When a branch misprediction is detected in the master processor <b>12</b>A, all entries in the reorder buffer <b>32</b>A following the branch are invalidated. If Wr<b>2</b>Proc or Fork instructions were mispredicted, these need to be invalidated in the slave processor <b>12</b>B as well. When master processor <b>12</b>A invalidates entries in reorder buffer <b>32</b>A following a mispredicted branch, it detects the first Wr<b>2</b>Proc or Fork instruction following the mispredicted branch and sends the reorder buffer <b>32</b>A tag of that instruction along with an invalidation request to the ICU <b>320</b>A. This tag and request are then conveyed to the slave processor <b>12</b>B where the master processor reorder buffer <b>32</b>A tag is translated by the RTB <b>400</b>B to obtain the reorder buffer <b>32</b>B tag of the slave processor <b>12</b>B. The resulting reorder buffer <b>32</b>B tag is then used to invalidate that entry and all following entries in the reorder buffer <b>32</b>B. If a Fork instruction is encountered during invalidation of instructions in reorder buffer <b>32</b>B, speculative execution in slave processor <b>12</b>B stops.</p><p>Ending Second Thread Execution and Retirement</p><p>The end of the second thread executing on the slave processor <b>12</b>B is indicated by a Join instruction. A Join instruction is also used in the thread running on the master processor <b>12</b>A. When both the master and slave processors <b>12</b> have retired the Join instruction, the slave processor <b>12</b>B stops executing and execution continues only in the master processor <b>12</b>A. When a slave processor <b>12</b>B retires a Join instruction, it signals this retirement to the master processor <b>12</b>A and its reorder buffer <b>32</b>B is cleared. The slave processor <b>12</b>B then stops execution and waits for the next Fork instruction. When the master processor <b>12</b>A has received an indication that the slave processor <b>12</b>B has retired the Join instruction, the master processor <b>12</b>A marks its Join instruction as completed and ready to retire.</p><p>Once both processors <b>12</b> have retired the Join instruction, the master processor <b>12</b>A may access the register file <b>30</b>B of the slave processor <b>12</b>B to obtain the execution results of the second thread. Access to the slave register file <b>30</b>B is obtained by use of the RdFrProc instruction. The RdFrProc instruction is dispatched by the master processor <b>12</b>A to the ICU <b>320</b>A where it waits in the reservation station <b>402</b>A until it is at the front and then it is issued. The RdFrProc command is then sent to the slave processor <b>12</b>B. Execution of the RdFrProc command in the slave processor <b>12</b>B reads the contents of the specified register and conveys the results back to the master processor <b>12</b>A via FIFO <b>2</b><b>310</b>B. The RdFrProc command in the master processor, which is still in the execute phase, retrieves the result and places it on the result bus <b>38</b>A. Normal instruction execution then continues.</p><p>The RdFrProc instruction may issue before the Join instruction retires, but may not retire until after the Join instruction retires. Because synchronization is not performed prior to a RdFrProc instruction, a Join instruction must precede that instruction in both the master and slave threads. If a mispredicted branch occurs and RdFrProc instructions are mispredicted, the instruction may still receive the data but the result is discarded by the master processor reorder buffer <b>32</b>A. Advantageously, the above mechanism enables speculative execution of the RdFrProc instruction.</p><p>Retiring Wr<b>2</b>Proc and Fork Instructions</p><p>When a Wr<b>2</b>Proc or Fork instruction retires in the master processor reorder buffer <b>32</b>A, the reorder buffer <b>32</b>A tag is sent to the slave processor where it is translated by RTB <b>400</b>B to the reorder buffer <b>32</b>B tag of the slave processor. Those instructions which have retired in the master processor <b>12</b>A may then be retired from the slave processor <b>12</b>B as well.</p><p>The retirement of Wr<b>2</b>Proc and Fork instructions may be handled in a variety of ways. One method involves a retirement command and the second involves a Fork commit command. In order to implement branch misprediction recovery as described above, the Wr<b>2</b>Proc and Fork command cannot retire in the slave processor reorder buffer <b>32</b>B until they have retired in the master processor reorder buffer <b>32</b>A. Consequently, reorder buffer <b>32</b>A must notify reorder buffer <b>32</b>B when such a retirement occurs. One way of making this notification is to send a retire command along with the reorder buffer <b>32</b>A tag to the slave processor <b>12</b>B whenever a Wr<b>2</b>Proc or Fork instruction retires in the master reorder buffer <b>32</b>A. The master reorder buffer <b>32</b>A tag is then translated by RTB <b>400</b>B in the slave processor <b>12</b>B to obtain the slave reorder buffer <b>32</b>B tag. The resulting slave reorder buffer <b>32</b>B tag is then used to retire the corresponding instruction. While this method creates additional retirement traffic to slave reorder buffer <b>32</b>B, the operation of this method is advantageously transparent to software, unlike the following method.</p><p>A second method of handling the retirement of Wr<b>2</b>Proc and Fork instructions involves the use of a Fork commit command. When a Fork instruction is retired in the master reorder buffer <b>32</b>A, the reorder buffer <b>32</b>A indicates to the ICU <b>320</b>A that a Fork instruction has been retired along with the corresponding reorder buffer <b>32</b>A tag. The ICU <b>320</b>A then sends a Fork commit command and the reorder buffer <b>32</b>A tag to the slave processor <b>12</b>B. The reorder buffer <b>32</b>A tag is then translated by RTB <b>400</b>B to obtain the corresponding reorder buffer <b>32</b>B tag. The resulting reorder buffer <b>32</b>B tag is then used to mark the corresponding entry as completed and ready to retire. Also, all previous Wr<b>2</b>Proc instructions in slave reorder buffer <b>32</b>B are marked completed and can now retire. When using this second method, there is a special case to consider. If for some reason Wr<b>2</b>Proc instructions are not followed by a Fork instruction, they may not be marked as complete and may remain in the reorder buffer <b>32</b>B. Subsequent thread setups by the master processor <b>12</b>A may write more Wr<b>2</b>Proc instructions. With each setup, less space is available in the slave reorder buffer <b>32</b>B. This process may continue and ultimately result in an overflow of the slave reorder buffer <b>32</b>B. To avoid this condition, the software is required to keep track of the available size of the slave reorder buffer <b>32</b>B. Even though this second method may produce less traffic than the first method described above, requiring the software to continuously track the available space in the slave reorder buffer <b>32</b>B is undesirable. Consequently, the first method described above which utilizes a retirement command and is transparent to software is preferred.</p><p>In one embodiment, the ICU <b>320</b>A may accept multiple instructions per cycle. Reservation station <b>402</b> may accommodate multiple instructions, with the position of the instructions within reservation station <b>402</b> indicating the order in which they are to be sent to the other processor. In addition, multiple instructions may be conveyed at once to the other processor. Overall, it must be ensured that the instructions are inserted in-order in the reorder buffer <b>32</b>B of the other processor.</p><p>Synchronization of Threads</p><p>Synchronization Using Sync Instruction</p><p>There are times during execution of parallel threads when it may be desirable to get the threads into a determinable state. For example, if data must be exchanged between threads there needs to be a mechanism for synchronizing the execution of the threads. To enable synchronization, in one embodiment a Sync instruction and synchronization logic may be used. The synchronization mechanism used depends on the characteristics of the system. If all processors in the system have the same latencies and phases, then a highly synchronous implementation may be used. Otherwise a more flexible implementation may be used. In either case, the mechanism is transparent to the software. The same synchronization code may be used for either implementation.</p><p>FIG. 5 illustrates how a Sync instruction may be used to synchronize threads. FIG. 5 includes two columns, each representing a thread of instructions. The first column represents a thread of code running on a master processor and the second column represents a thread of code running on a slave processor. Each column in FIG. 5 is divided into rows with each cell representing a single instruction. Instruction <b>500</b> represents a label which may serve as a branch entry point from elsewhere in the code. The operation of the threads is as follows. Thread <b>1</b> code executes in parallel with thread <b>2</b> code. Thread <b>1</b> executes until it reaches the first Sync <b>502</b> instruction. Thread <b>2</b> code executes the mov instruction <b>510</b> which moves the Handle data to reg<b>1</b>. Thread <b>2</b> then continues execution to Sync instruction <b>512</b>. When both threads have reached the first Sync instruction, <b>502</b> and <b>512</b> respectively, the Sync instructions may be retired. When both Sync instructions have exited the synchronization point (retired) execution continues. Thread <b>1</b> executes instruction <b>504</b> which reads the data from reg<b>1</b> of processor <b>2</b> into reg<b>0</b> of its register file. Both threads reach a second synchronization point at Sync instructions <b>506</b> and <b>514</b>. When Sync instructions <b>506</b> and <b>514</b> are both ready to retire, both are retired and execution continues. Thread <b>1</b> then executes a compare instruction <b>507</b> and if they are not identical, the jump instruction <b>508</b> causes execution to continue with instruction <b>500</b>. Otherwise, execution of thread <b>1</b> continues with other code. As the above example shows, a Sync instruction may not be retired until all processors are ready to retire their corresponding Sync instructions. This requires that each processor indicate when it is ready to retire a Sync instruction and each processor must know when all other processors have reached the synchronization point.</p><p>FIG. 6 shows a block diagram of a synchronous mechanism to implement the synchronization logic. Shown are synchronization logic <b>314</b>, SSO signals <b>600</b>, and SSI signal <b>602</b>. SSO signals <b>600</b> are output from CPUs <b>1</b>-x and input to synchronization logic <b>314</b>. Synchronization logic <b>314</b> outputs signal SSI <b>602</b>. In the synchronous implementation shown in FIG. 6, each processor is connected to synchronization logic <b>314</b> with 2 signals: a Sync State Out (SSO) signal <b>600</b> and a Sync Signal In (SSI) <b>602</b>. Each processor outputs an SSO signal <b>600</b> to indicate the state of the Sync instructions to the synchronization logic <b>314</b>. In addition, each processor receives SSI signal <b>602</b> as input to detect the status of the Sync instructions in other processors. In one embodiment, the state of the SSO signal <b>600</b> is described by the following table.</p><p><tables id=\"TABLE-US-00002\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"91pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"126pt\"></colspec><thead><row><entry nameend=\"2\" namest=\"1\" rowsep=\"1\">TABLE 2</entry></row><row><entry align=\"center\" nameend=\"2\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>SSO state</entry><entry>State Description</entry></row><row><entry align=\"center\" nameend=\"2\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry>0</entry><entry>No Sync instruction.</entry></row><row><entry>1</entry><entry>Sync instruction ready to retire.</entry></row><row><entry align=\"center\" nameend=\"2\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>Sync instructions are handled specially by the reorder buffers. In the synchronous implementation, if a Sync instruction is next to retire, then the SSO signal <b>600</b> of that processor is set to state 1 to indicate to all other processors that it has entered the synchronization point. When all SSO signals <b>600</b> input to synchronization logic <b>314</b> are set to state 1, synchronization logic <b>314</b> sets the SSI signal <b>602</b> to state 1. Only when the SSI signal <b>602</b> input to a processor is set to state 1 may that processor retire its Sync instruction. In this manner, all processors retire their Sync instructions at the same time. When a processor retires a Sync instruction, its SSO signal <b>600</b> is set to state 0 on the following clock cycle to indicate it has exited the synchronization point. The second clock cycle following retirement, the SSO signal <b>600</b> may be set to state 1 again if a Sync instruction is ready to retire. In the synchronous implementation, synchronization logic <b>314</b> may consist of an AND gate, with all SSO signals <b>600</b> as inputs and the SSI signal <b>602</b> as output. The synchronous implementation provides the fastest synchronization mechanism. However, it can only be used if the processors operate in a cycle by cycle synchronous manner.</p><p>If synchronous operation between the processors is not guaranteed, an asynchronous implementation of synchronization logic <b>314</b> may be used. FIG. 7 is a block diagram illustrating an asynchronous implementation. FIG. 7 shows synchronization logic <b>314</b>, SSO signals <b>700</b> input to synchronization logic <b>314</b>, and SSI signal <b>702</b> output from synchronization logic <b>314</b>. In the asynchronous implementation, each processor includes a two bit SSO signal <b>700</b> to indicate the state of its Sync instruction. As in the synchronous implementation, synchronization logic <b>314</b> outputs an SSI signal <b>702</b> to each processor. In one embodiment, the state of the SSO signal <b>700</b> may be described by the following table.</p><p><tables id=\"TABLE-US-00003\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"91pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"126pt\"></colspec><thead><row><entry nameend=\"2\" namest=\"1\" rowsep=\"1\">TABLE 3</entry></row><row><entry align=\"center\" nameend=\"2\" namest=\"1\" rowsep=\"1\"></entry></row><row><entry>SSO state</entry><entry>State Description</entry></row><row><entry align=\"center\" nameend=\"2\" namest=\"1\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry>0</entry><entry>No Sync instruction.</entry></row><row><entry>1</entry><entry>Sync instruction ready to retire.</entry></row><row><entry>2</entry><entry>Sync instruction retired</entry></row><row><entry align=\"center\" nameend=\"2\" namest=\"1\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>As in the synchronous implementation, Sync instructions are handled specially by the reorder buffers <b>32</b>. In the asynchronous implementation, if a Sync instruction is next to retire, then the SSO signal of that processor is set to state 1 to indicate to the other processors that it is ready to retire its Sync instruction. When all SSO signals <b>700</b> input to synchronization logic <b>314</b> are set to state 1, synchronization logic <b>314</b> sets the SSI signal <b>702</b> to state 1. Only when the SSI signal <b>702</b> input to a processor is set to state 1 may that processor retire its Sync instruction. In this manner, all processors retire their Sync instructions at the same time. When a Sync instruction is retired, the SSO signal <b>700</b> of that processor is set to state 2 to indicate to the other processors that it is exiting the synchronization point. When a processor has exited the synchronization point and set its SSO signal <b>700</b> to state 2, it waits until all other processors have exited the synchronization point as well. When all processors have set their SSO signals <b>700</b> to state 2, SSI signal <b>702</b> is set to state 0. All processors may then detect that SSI signal <b>702</b> is set to state 0 and continue execution. After SSI signal <b>702</b> has returned to state 0, a processor may then indicate another Sync instruction is ready to retire by setting its SSI signal <b>700</b> to state 1.</p><p>The asynchronous implementation of the synchronization logic <b>314</b> may be central logic or may be included as part of one of the processors. The synchronization logic <b>314</b> implements a small state machine which may work as illustrated by FIG. <b>8</b>. FIG. 8 represents a continuous loop wherein the state of FSMState is continuously checked. FSMState represents the state of the Sync signals SSO in the processors. Initially, synchronization logic <b>314</b> may be in state WAIT_ALL_S<b>1</b>. While in state WAIT_ALL_S<b>1</b>, signal SSI is set to state 0. If all SSO signals are in state S<b>1</b>, indicating all processors are ready to retire a Sync instruction, then the next state for FSMState is ALL_S<b>1</b>. Otherwise, the next state for FSMState remains WAIT_ALL_S<b>1</b>. Once all SSO signals are in state S<b>1</b>, FSMState transitions to state ALL_S<b>1</b> and subsequently to state WAIT_ALL_S<b>2</b>. In state WAIT_ALL_S<b>2</b>, the signal SSI is set to state 1 which allows each processor to retire its Sync instruction. While in state WAIT_ALL_S<b>2</b>, synchronization logic waits for all SSO signals to enter state 2. Once all processors have exited the synchronization point, as indicated by setting their SSO signals to state 2, FSMState transitions to state ALL_S<b>2</b> and subsequently to state WAIT_ALL_S<b>1</b> where it sets signal SSI to state 0. This implementation allows the synchronization of processors even if they do not work in lock step. While this implementation is more flexible, it has a longer latency than the synchronous implementation described above.</p><p>Synchronization Using Scratchpad</p><p>Another way of exchanging data while multiple processors are processing different threads is to use a scratchpad register space. FIG. 9 shows a block diagram of an ICU <b>920</b>A and TCD <b>900</b> using scratchpad registers <b>902</b> for synchronization. In addition to scratchpad registers <b>902</b>, additional scratchpad instructions (hereafter SCINS) are added which access the scratchpad registers. To implement the scratchpad mechanism, scratchpad logic <b>902</b> has been added to the TCD. Shown in FIG. 9 are ICU <b>920</b>A and TCD <b>900</b>. ICU <b>920</b>A includes SCINS Read reservation station <b>930</b>A, SCINS Write reservation station <b>932</b>A, and FIFO reservation station <b>402</b>A. TCD <b>900</b> includes FIFOs <b>310</b>, synchronization logic <b>314</b>, and scratchpad registers <b>902</b>. ICU <b>920</b>A is</p><p>The SCINS are locked read-modify-write (hereafter RmodW) instructions to a scratchpad register location. These instructions enable the modification of shared data during parallel thread execution. The scratchpad register may be locked on an address by address basis. The SCINS are handled by a special functional unit which may be separate from, or included in, ICU <b>920</b>. The SCINS functional unit includes separate reservation stations, <b>930</b> and <b>932</b>, for read and write accesses. All instructions are issued in order from the scratchpad reservation stations. Any instruction which modifies a scratchpad location with a RmodW operation is a locked instruction. SCINS are decoded into multiple operations. At least a locked Read, ALU operation, and a locked Write are generated. The mechanism works as follows:</p><p>1. A locked RmodW SCINS is decoded. From this decoded instruction, a locked Read and locked Write are dispatched to the SCINS functional unit.</p><p>2. The locked Read is inserted into Locked Read reservation station <b>930</b>A. The locked Write is inserted into Locked Write reservation station <b>932</b>A.</p><p>3. When all previous reads in Read reservation station <b>930</b>A have been completed, the locked Read is issued from Read reservation station <b>930</b>A. Because all RmodW instructions are issued in order, the corresponding Write instruction is now also at the front of the Write reservation station <b>932</b>A.</p><p>4. The Read now accesses scratchpad register <b>902</b>. If it is locked, the Read waits until it is unlocked. Then it locks the scratchpad register <b>902</b> location, completes its operation and conveys the result to the result bus. However, the Read instruction is not yet removed from reservation station <b>930</b>A.</p><p>5. All instructions dependent on the Read may now issue. Once the locked Write in Write reservation station <b>932</b>A receives its input operand it is ready to issue. However, the Write does not issue until the Write is next to retire in the reorder buffer <b>32</b>. This is required, because only non speculative writes are allowed.</p><p>6. When the Write is next to retire in the reorder buffer <b>32</b>, the Write is issued from reservation station <b>932</b>A and writes to scratchpad register <b>902</b>. This write updates the data and unlocks the location. The SCINS Read and Write instructions are now removed from reservation stations <b>930</b> and <b>932</b>, respectively.</p><p>In 6 above, the Read is removed from reservation station <b>930</b> if the associated Write retires. The Read must remain in the reservation station <b>930</b> in order to properly handle branch misprediction. In the case of a mispredicted branch, the mechanism operates as follows:</p><p>1. When a mispredicted branch is detected, the entries following the mispredicted branch in reorder buffer <b>32</b> are nullified.</p><p>2. During nullification, a SCINS locked instruction may be detected. This causes reorder buffer <b>32</b> to send the reorder buffer tags for the nullified SCINS to the SCINS functional unit together with an invalidate command. If multiple SCINS instructions are detected, then only the tags of the first instruction after the branch are required.</p><p>3. The SCINS functional unit uses the conveyed reorder buffer tag to invalidate all instructions in reservation stations <b>930</b> and <b>932</b> beginning with and following the received reorder buffer tag.</p><p>4. If the nullification of instructions in Read reservation station <b>930</b>A hits a Read at the front of the reservation station <b>930</b>A which has already been issued, the logic uses the address of the Read instruction to unlock that location in the scratchpad register <b>902</b>.</p><p>The mechanism described above allows a speculatively locked scratchpad location <b>902</b> to be unlocked. Advantageously, the above mechanism allows the speculative execution of locked reads. While the above discussion uses separate Read and Write reservation stations, other implementations may be used and are contemplated. However, it must be possible to unlock a location if a locked Read was mispredicted without executing the mispredicted locked Write.</p><p>Computer System</p><p>Turning now to FIG. 10, a block diagram of one embodiment of a computer system <b>1800</b> including multiprocessor computer <b>100</b> coupled to a variety of system components through a bus bridge <b>1802</b> is shown. Other embodiments are possible and contemplated. In the depicted system, a main memory <b>1804</b> is coupled to bus bridge <b>1802</b> through a memory bus <b>1806</b>, and a graphics controller <b>1808</b> is coupled to bus bridge <b>1802</b> through an AGP bus <b>1810</b>. Finally, a plurality of PCI devices <b>1812</b>A-<b>1812</b>B are coupled to bus bridge <b>1802</b> through a PCI bus <b>1814</b>. A secondary bus bridge <b>1816</b> may further be provided to accommodate an electrical interface to one or more EISA or ISA devices <b>1818</b> through an EISA/ISA bus <b>1820</b>. Multiprocessor computer <b>100</b> is coupled to bus bridge <b>1802</b> through a CPU bus <b>1824</b> and to an optional L<b>2</b> cache <b>1828</b>.</p><p>Bus bridge <b>1802</b> provides an interface between multiprocessor computer <b>100</b>, main memory <b>1804</b>, graphics controller <b>1808</b>, and devices attached to PCI bus <b>1814</b>. When an operation is received from one of the devices connected to bus bridge <b>1802</b>, bus bridge <b>1802</b> identifies the target of the operation (e.g. a particular device or, in the case of PCI bus <b>1814</b>, that the target is on PCI bus <b>1814</b>). Bus bridge <b>1802</b> routes the operation to the targeted device. Bus bridge <b>1802</b> generally translates an operation from the protocol used by the source device or bus to the protocol used by the target device or bus.</p><p>In addition to providing an interface to an ISA/EISA bus for PCI bus <b>1814</b>, secondary bus bridge <b>1816</b> may further incorporate additional functionality, as desired. An input/output controller (not shown), either external from or integrated with secondary bus bridge <b>1816</b>, may also be included within computer system <b>1800</b> to provide operational support for a keyboard and mouse <b>1822</b> and for various serial and parallel ports, as desired. An external cache unit (not shown) may further be coupled to CPU bus <b>1824</b> between multiprocessor computer <b>100</b> and bus bridge <b>1802</b> in other embodiments. Alternatively, the external cache may be coupled to bus bridge <b>1802</b> and cache control logic for the external cache may be integrated into bus bridge <b>1802</b>. L<b>2</b> cache <b>1828</b> is further shown in a backside configuration to processor <b>100</b>. It is noted that L<b>2</b> cache <b>1828</b> may be separate from multiprocessor computer <b>100</b>, integrated into a cartridge (e.g. slot <b>1</b> or slot A) with multiprocessor computer <b>100</b>, or even integrated onto a semiconductor substrate with multiprocessor computer <b>100</b>.</p><p>Main memory <b>1804</b> is a memory in which application programs are stored and from which multiprocessor computer <b>100</b> primarily executes. A suitable main memory <b>1804</b> comprises DRAM (Dynamic Random Access Memory). For example, a plurality of banks of SDRAM (Synchronous DRAM) or Rambus DRAM (RDRAM) may be suitable.</p><p>PCI devices <b>1812</b>A-<b>1812</b>B are illustrative of a variety of peripheral devices such as, for example, network interface cards, video accelerators, audio cards, hard or floppy disk drives or drive controllers, SCSI (Small Computer Systems Interface) adapters and telephony cards. Similarly, ISA device <b>1818</b> is illustrative of various types of peripheral devices, such as a modem, a sound card, and a variety of data acquisition cards such as GPIB or field bus interface cards.</p><p>Graphics controller <b>1808</b> is provided to control the rendering of text and images on a display <b>1826</b>. Graphics controller <b>1808</b> may embody a typical graphics accelerator generally known in the art to render three-dimensional data structures which can be effectively shifted into and from main memory <b>1804</b>. Graphics controller <b>1808</b> may therefore be a master of AGP bus <b>1810</b> in that it can request and receive access to a target interface within bus bridge <b>1802</b> to thereby obtain access to main memory <b>1804</b>. A dedicated graphics bus accommodates rapid retrieval of data from main memory <b>1804</b>. For certain operations, graphics controller <b>1808</b> may further be configured to generate PCI protocol transactions on AGP bus <b>1810</b>. The AGP interface of bus bridge <b>1802</b> may thus include functionality to support both AGP protocol transactions as well as PCI protocol target and initiator transactions. Display <b>1826</b> is any electronic display upon which an image or text can be presented. A suitable display <b>1826</b> includes a cathode ray tube (\u201cCRT\u201d), a liquid crystal display (\u201cLCD\u201d), etc.</p><p>It is noted that, while the AGP, PCI, and ISA or EISA buses have been used as examples in the above description, any bus architectures may be substituted as desired. It is further noted that computer system <b>1800</b> may be a multiprocessing computer system including additional multiprocessor computers (e.g. multiprocessor computer <b>100</b><i>a </i>shown as an optional component of computer system <b>1800</b>). Multiprocessor computer <b>100</b><i>a </i>may be similar to multiprocessor computer <b>100</b>. More particularly, multiprocessor computer <b>100</b><i>a </i>may be an identical copy of multiprocessor computer <b>100</b>. Multiprocessor computer <b>100</b><i>a </i>may be connected to bus bridge <b>1802</b> via an independent bus (as shown in FIG. 5) or may share CPU bus <b>1824</b> with processor <b>100</b>. Furthermore, processor <b>100</b><i>a </i>may be coupled to an optional L<b>2</b> cache <b>1828</b><i>a </i>similar to L<b>2</b> cache <b>1828</b>.</p><p>It is noted that the present discussion may refer to the assertion of various signals. As used herein, a signal is \u201casserted\u201d if it conveys a value indicative of a particular condition. Conversely, a signal is \u201cdeasserted\u201d if it conveys a value indicative of a lack of a particular condition. A signal may be defined to be asserted when it conveys a logical zero value or, conversely, when it conveys a logical one value. Additionally, various values have been described as being discarded in the above discussion. A value may be discarded in a number of manners, but generally involves modifying the value such that it is ignored by logic circuitry which receives the value. For example, if the value comprises a bit, the logic state of the value may be inverted to discard the value. If the value is an n-bit value, one of the n-bit encodings may indicate that the value is invalid. Setting the value to the invalid encoding causes the value to be discarded. Additionally, an n-bit value may include a valid bit indicative, when set, that the n-bit value is valid. Resetting the valid bit may comprise discarding the value. Other methods of discarding a value may be used as well.</p><p>Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Uwe", "last_name": "Kranich", "name": ""}, {"first_name": "David S.", "last_name": "Christie", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}, {"first_name": "", "last_name": "GLOBALFOUNDRIES U.S. INC.", "name": ""}, {"first_name": "", "last_name": "GLOBALFOUNDRIES INC.", "name": ""}, {"first_name": "", "last_name": "WILMINGTON TRUST, NATIONAL ASSOCIATION", "name": ""}, {"first_name": "", "last_name": "GLOBALFOUNDRIES INC.", "name": ""}, {"first_name": "", "last_name": "ADVANCED MICRO DEVICES, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/40"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  15/173       20060101A I20051008RMEP"}, {"label": "G06F   9/46        20060101ALI20051220RMJP"}, {"label": "G06F   9/30        20060101A I20051008RMEP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}, {"label": "G06F   9/48        20060101A I20051008RMEP"}, {"label": "G06F  15/177       20060101ALI20051220RMJP"}], "national_classes": [{"primary": true, "label": "712031"}, {"primary": false, "label": "712E09053"}, {"primary": false, "label": "712E09049"}, {"primary": false, "label": "709208"}, {"primary": false, "label": "718104"}, {"primary": false, "label": "712E09032"}, {"primary": false, "label": "712E0907"}, {"primary": false, "label": "712028"}, {"primary": false, "label": "712E0905"}, {"primary": false, "label": "712023"}, {"primary": false, "label": "712216"}], "ecla_classes": [{"label": "G06F   9/38S"}, {"label": "G06F   9/30A8S"}, {"label": "G06F   9/30A8T"}, {"label": "G06F   9/38S1"}, {"label": "G06F  15/173N4D"}, {"label": "G06F   9/38E4"}, {"label": "G06F   9/38E2"}, {"label": "G06F   9/38E"}, {"label": "G06F   9/48C4"}], "cpc_classes": [{"label": "G06F   9/3885"}, {"label": "G06F   9/3851"}, {"label": "G06F   9/3836"}, {"label": "G06F   9/384"}, {"label": "G06F   9/3842"}, {"label": "G06F   9/30087"}, {"label": "G06F   9/3009"}, {"label": "G06F   9/3855"}, {"label": "G06F   9/3857"}, {"label": "G06F  15/17381"}, {"label": "G06F   9/3838"}, {"label": "G06F   9/4843"}, {"label": "G06F   9/30087"}, {"label": "G06F   9/3838"}, {"label": "G06F   9/4843"}, {"label": "G06F   9/3009"}, {"label": "G06F   9/3851"}, {"label": "G06F   9/3885"}, {"label": "G06F   9/3842"}, {"label": "G06F   9/384"}, {"label": "G06F  15/17381"}, {"label": "G06F   9/3836"}, {"label": "G06F   9/3857"}, {"label": "G06F   9/3855"}, {"label": "G06F   9/48"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1999-11-01", "application_date": "1999-11-01", "family_members": [{"ucid": "JP-2003514274-A", "titles": [{"lang": "JA", "text": "\u63a5\u8fd1\u3057\u3066\u7d50\u5408\u3055\u308c\u308b\u591a\u91cd\u30d7\u30ed\u30bb\u30c3\u30b5\u306e\u305f\u3081\u306e\u9ad8\u901f\u30de\u30eb\u30c1\u30b9\u30ec\u30c3\u30c7\u30a3\u30f3\u30b0"}, {"lang": "EN", "text": "Fast multithreading for closely coupled multiprocessors"}]}, {"ucid": "JP-4578042-B2", "titles": [{"lang": "JA", "text": "\u63a5\u8fd1\u3057\u3066\u7d50\u5408\u3055\u308c\u308b\u591a\u91cd\u30d7\u30ed\u30bb\u30c3\u30b5\u306e\u305f\u3081\u306e\u9ad8\u901f\u30de\u30eb\u30c1\u30b9\u30ec\u30c3\u30c7\u30a3\u30f3\u30b0"}, {"lang": "EN", "text": "Fast multithreading for closely coupled multiprocessors."}]}, {"ucid": "US-6574725-B1", "titles": [{"lang": "EN", "text": "Method and mechanism for speculatively executing threads of instructions"}]}, {"ucid": "CN-1384935-A", "titles": [{"lang": "EN", "text": "Fast multithreading for closely coupled multipocessors"}, {"lang": "ZH", "text": "\u7d27\u5bc6\u8026\u5408\u5f0f\u591a\u5904\u7406\u5668\u7684\u5feb\u901f\u591a\u7ebf\u7a0b\u6267\u884c"}]}, {"ucid": "EP-1226498-A1", "titles": [{"lang": "FR", "text": "TRAITEMENT MULTIFILAIRE RAPIDE POUR MULTIPROCESSEURS  ETROITEMENT LIES"}, {"lang": "EN", "text": "FAST MULTITHREADING FOR CLOSELY COUPLED MULTIPROCESSORS"}, {"lang": "DE", "text": "SCHNELL MULTITHREADING F\u00dcR ENG GEKOPPELTE MULTIPROZESSOREN"}]}, {"ucid": "EP-1226498-B1", "titles": [{"lang": "DE", "text": "SCHNELL MULTITHREADING F\u00dcR ENG GEKOPPELTE MULTIPROZESSOREN"}, {"lang": "EN", "text": "FAST MULTITHREADING FOR CLOSELY COUPLED MULTIPROCESSORS"}, {"lang": "FR", "text": "TRAITEMENT MULTIFILAIRE RAPIDE POUR MULTIPROCESSEURS  ETROITEMENT LIES"}]}, {"ucid": "KR-100734529-B1", "titles": [{"lang": "KO", "text": "\ubc00\uc811\ud558\uac8c \uacb0\ud569\ub41c \ub2e4\uc911 \ud504\ub85c\uc138\uc11c\ub97c \uc704\ud55c \uace0\uc18d\uc758 \ub2e4\uc911 \uc2a4\ub808\ub529"}, {"lang": "EN", "text": "FAST MULTITHREADING FOR CLOSELY COUPLED MULTIPROCESSORS"}]}, {"ucid": "KR-20020087928-A", "titles": [{"lang": "KO", "text": "\uae34\ubc00\ud558\uac8c \uc5f0\uacb0\ub41c \ub2e4\uc911 \ud504\ub85c\uc138\uc11c\ub4e4\uc744 \uc704\ud55c \uace0\uc18d \ub2e4\uc911 \uc2a4\ub808\ub529"}, {"lang": "EN", "text": "FAST MULTITHREADING FOR CLOSELY COUPLED MULTIPROCESSORS"}]}, {"ucid": "WO-2001033352-A1", "titles": [{"lang": "EN", "text": "FAST MULTITHREADING FOR CLOSELY COUPLED MULTIPROCESSORS"}, {"lang": "FR", "text": "TRAITEMENT MULTIFILI\u00c8RE RAPIDE POUR MULTIPROCESSEURS \u00c0 LIAISON INTIME"}]}, {"ucid": "CN-1199099-C", "titles": [{"lang": "ZH", "text": "\u7d27\u5bc6\u8026\u5408\u5f0f\u591a\u5904\u7406\u5668\u7684\u5feb\u901f\u591a\u7ebf\u7a0b\u6267\u884c"}, {"lang": "EN", "text": "Fast multithreading for closely coupled multipocessors"}]}, {"ucid": "DE-60036016-T2", "titles": [{"lang": "DE", "text": "SCHNELL MULTITHREADING F\u00dcR ENG GEKOPPELTE MULTIPROZESSOREN"}, {"lang": "EN", "text": "FAST MULTITHREADING FOR ENG COUPLED MULTIPROCESSORS"}]}, {"ucid": "DE-60036016-D1", "titles": [{"lang": "EN", "text": "FAST MULTITHREADING FOR ENG COUPLED MULTIPROCESSORS"}, {"lang": "DE", "text": "SCHNELL MULTITHREADING F\u00dcR ENG GEKOPPELTE MULTIPROZESSOREN"}]}]}