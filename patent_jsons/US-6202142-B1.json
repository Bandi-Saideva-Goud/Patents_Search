{"patent_number": "US-6202142-B1", "publication_id": 72607516, "family_id": 25215586, "publication_date": "2001-03-13", "titles": [{"lang": "EN", "text": "Microcode scan unit for scanning microcode instructions using predecode data"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11156887\" source=\"national office\"><p>An instruction scanning unit for a superscalar microprocessor is disclosed. The instruction scanning unit processes start, end, and functional byte information (or predecode data) associated with a plurality of contiguous instruction bytes. The processing of start byte information and end byte information is performed independently and in parallel, and the instruction scanning unit produces a plurality of scan values which identify valid instructions within the plurality of contiguous instruction bytes. Additionally, the instruction scanning unit is scaleable. Multiple instruction scanning units may be operated in parallel to process a larger plurality of contiguous instruction bytes. Furthermore, the instruction scanning unit detects error conditions in the predecode data in parallel with scanning to locate instructions. Moreover, in parallel with the error checking and scanning to locate instructions, MROM instructions are located for dispatch to an MROM unit.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72525148\"><p>An instruction scanning unit for a superscalar microprocessor is disclosed. The instruction scanning unit processes start, end, and functional byte information (or predecode data) associated with a plurality of contiguous instruction bytes. The processing of start byte information and end byte information is performed independently and in parallel, and the instruction scanning unit produces a plurality of scan values which identify valid instructions within the plurality of contiguous instruction bytes. Additionally, the instruction scanning unit is scaleable. Multiple instruction scanning units may be operated in parallel to process a larger plurality of contiguous instruction bytes. Furthermore, the instruction scanning unit detects error conditions in the predecode data in parallel with scanning to locate instructions. Moreover, in parallel with the error checking and scanning to locate instructions, MROM instructions are located for dispatch to an MROM unit.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00001\" num=\"1\"><claim-text>1. A method comprising:</claim-text><claim-text>scanning a plurality of start bits and a plurality of end bits to identify instructions within a plurality of instruction bytes for dispatch to an instruction alignment unit, wherein each one of said plurality of start bits and a corresponding one of said plurality of end bits corresponds to one of said plurality of instruction bytes; </claim-text><claim-text>separately scanning, in parallel with said scanning a plurality of start bits and a plurality of end bits, said plurality of end bits and a plurality of functional bits to identify microcode instructions, wherein said plurality of end bits scanned in said separately scanning are a same plurality of end bits scanned in said scanning, and wherein each of said plurality of functional bits corresponds to one of said plurality of instruction bytes, and wherein each of said plurality of end bits is indicative of whether or not a corresponding one of said plurality of instruction bytes is an end byte of a first instruction, and wherein a corresponding one of said plurality of functional bits is indicative of whether or not said first instruction is a microcode instruction if said one of said plurality of end bits indicates that said corresponding one of said plurality of instruction bytes is said end byte of said first instruction; and </claim-text><claim-text>dispatching said first instruction to a microcode unit responsive to said scanning a plurality of end bits and a plurality of functional bits identifying said first instruction as a first microcode instruction within said plurality of instruction bytes. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00002\" num=\"2\"><claim-text>2. The method as recited in claim <b>1</b> further comprising dispatching a second microcode instruction identified by a second one of said plurality of end bits and a second corresponding one of said plurality of functional bits to said microcode unit.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00003\" num=\"3\"><claim-text>3. The method as recited in claim <b>2</b> wherein said dispatching a second microcode instruction is performed during a second clock cycle subsequent to a first clock cycle in which said dispatching said first instruction is performed.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00004\" num=\"4\"><claim-text>4. The method as recited in claim <b>1</b> wherein said scanning a plurality of end bits and a plurality of functional bits comprises logically ANDing said plurality of end bits and said plurality of functional bits, thereby forming a microcode instruction mask.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00005\" num=\"5\"><claim-text>5. The method as recited in claim <b>4</b> wherein said microcode instruction mask has binary ones at each byte position at which a microcode instruction ends.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00006\" num=\"6\"><claim-text>6. The method as recited in claim <b>1</b> further comprising forming a start pointer indicative of a start byte of said first microcode instruction based upon a plurality of start bits corresponding to said plurality of instruction bytes.</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00007\" num=\"7\"><claim-text>7. The method as recited in claim <b>6</b> further comprising forming an opcode pointer identifying an opcode byte of said first microcode instruction.</claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00008\" num=\"8\"><claim-text>8. The method as recited in claim <b>1</b> further comprising dispatching one or more instructions to said instruction alignment unit responsive to said scanning a plurality of start bits and a plurality of end bits.</claim-text></claim>"}, {"num": 9, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00009\" num=\"9\"><claim-text>9. A microprocessor comprising:</claim-text><claim-text>a scanning unit including: </claim-text><claim-text>at least one scan circuit configured to scan a plurality of start bits and a plurality of end bits corresponding to a plurality of instruction bytes to locate one or more instructions for dispatch, wherein each one of said plurality of start bits and a corresponding one of said plurality of end bits corresponds to one of said plurality of instruction bytes; and </claim-text><claim-text>a separate microcode scan circuit configured to scan said plurality of end bits and a corresponding plurality of functional bits in parallel with said at least one scan circuit, said plurality of end bits being a same plurality of end bits scanned by said at least one scan circuit, said microcode scan circuit configured to detect a first microcode instruction for dispatch, wherein each of said corresponding plurality of functional bits corresponds to one of said plurality of instruction bytes, and wherein, if a first one of said plurality of end bits indicates that a corresponding one of said plurality of instruction bytes is an end byte of a first instruction, a first corresponding one of said plurality of functional bits indicates whether or not said first instruction is a microcode instruction; </claim-text><claim-text>an instruction alignment unit coupled to said at least one scan circuit to receive instruction information; and </claim-text><claim-text>a microcode unit coupled to said microcode scan circuit to receive microcode instruction information. </claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00010\" num=\"10\"><claim-text>10. The microprocessor as recited in claim <b>9</b> wherein said microcode instruction information includes a start pointer identifying a start byte of said first microcode instruction within said plurality of instruction bytes.</claim-text></claim>"}, {"num": 11, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00011\" num=\"11\"><claim-text>11. The microprocessor as recited in claim <b>9</b> wherein said microcode instruction information includes an opcode pointer identifying an opcode byte of said first microcode instruction within said plurality of instruction bytes.</claim-text></claim>"}, {"num": 12, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00012\" num=\"12\"><claim-text>12. The microprocessor as recited in claim <b>9</b> wherein said microcode scan circuit is configured to detect a second microcode instruction within said plurality of instruction bytes and is configured to signal for an additional scan cycle in response to said second microcode instruction.</claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00013\" num=\"13\"><claim-text>13. The microprocessor as recited in claim <b>12</b> wherein said microcode scan circuit is configured to dispatch microcode instruction information corresponding to said second microcode instruction to said microcode unit during said additional scan cycle.</claim-text></claim>"}, {"num": 14, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00014\" num=\"14\"><claim-text>14. The microprocessor as recited in claim <b>9</b> wherein said instruction information from said at least one scan circuit comprises a plurality of valid masks corresponding to a plurality of instructions within said plurality of instruction bytes.</claim-text></claim>"}, {"num": 15, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00015\" num=\"15\"><claim-text>15. The microprocessor as recited in claim <b>9</b> further comprising a plurality of decode units coupled to said instruction alignment unit, wherein said instruction alignment unit is configured to dispatch instructions to said plurality of decode units.</claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00016\" num=\"16\"><claim-text>16. The microprocessor as recited in claim <b>15</b> wherein said microcode unit is coupled to said plurality of decode units, and wherein said microcode unit is configured to dispatch a microcode routine corresponding to said first microcode instruction to said plurality of decode units.</claim-text></claim>"}, {"num": 17, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00017\" num=\"17\"><claim-text>17. A computer system comprising:</claim-text><claim-text>a microprocessor comprising: </claim-text><claim-text>a scanning unit including: </claim-text><claim-text>at least one scan circuit configured to scan a plurality of start bits and a plurality of end bits corresponding to a plurality of instruction bytes to locate one or more instructions for dispatch, wherein each one of said plurality of start bits and a corresponding one of said plurality of end bits corresponds to one of said plurality of instruction bytes; and </claim-text><claim-text>a separate microcode scan circuit configured to scan said plurality of end bits and a corresponding plurality of functional bits in parallel with said at least one scan circuit, said plurality of end bits being a same plurality of end bits scanned by said at least one scan circuit, said microcode scan circuit configured to detect a first microcode instruction for dispatch, wherein each of said corresponding plurality of functional bits corresponds to one of said plurality of instruction bytes, and wherein, if a first one of said plurality of end bits indicates that a corresponding one of said plurality of instruction bytes is an end byte of a first instruction, a first corresponding one of said plurality of functional bits indicates whether or not said first instruction is a microcode instruction; </claim-text><claim-text>an instruction alignment unit coupled to said at least one scan circuit to receive instruction information; and </claim-text><claim-text>a microcode unit coupled to said microcode scan circuit to receive microcode instruction information; and </claim-text><claim-text>an input/output (I/O) device configured to communicate between said computer system and another computer system to which said I/O device is couplable. </claim-text></claim>"}, {"num": 18, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00018\" num=\"18\"><claim-text>18. The computer system as recited in claim <b>17</b> wherein said I/O device is a modem.</claim-text></claim>"}, {"num": 19, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-6202142-B1-CLM-00019\" num=\"19\"><claim-text>19. The computer system as recited in claim <b>17</b> further comprising a sound card.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54510768\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This application is a continuation of U.S. patent application Ser. No. 08/814,629, now U.S. Pat. No. 5,968,163, filed Mar. 10, 1997.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention relates to the field of superscalar microprocessors and, more particularly, to instruction dispatch mechanisms within superscalar microprocessors.</p><p>2. Description of the Relevant Art</p><p>Superscalar microprocessors are capable of attaining performance characteristics which surpass those of conventional scalar processors by allowing the concurrent execution of multiple instructions. Due to the widespread acceptance of the x86 family of microprocessors, efforts have been undertaken by microprocessor manufacturers to develop superscalar microprocessors which execute x86 instructions. Such superscalar microprocessors achieve relatively high performance characteristics while advantageously maintaining backwards compatibility with the vast amount of existing software developed for previous microprocessor generations such as the 8086, 80286, 80386, and 80486.</p><p>The x86 instruction set is relatively complex and is characterized by a plurality of variable byte length instructions. An x86 instruction includes from one to five optional prefix bytes followed by an operation code (opcode) field, an optional addressing mode (Mod R/M) byte, an optional scale-index-base (SIB) byte, an optional displacement field, and an optional immediate data field.</p><p>The opcode field defines the basic operation for a particular instruction. The default operation of a particular opcode may be modified by one or more prefix bytes. For example, a prefix byte may be used to change the address or operand size for an instruction, to override the default segment used in memory addressing, or to instruct the processor to repeat a string operation a number of times. The opcode field may be one or two bytes in length. The addressing mode (Mod R/M) byte specifies the registers used as well as memory addressing modes used by the instruction. The SIB byte is used only in 32-bit base-relative addressing using scale and index factors. A base field of the SIB byte specifies which register contains the base value for the address calculation, and an index field specifies which register contains the index value. A scale field specifies the power of two by which the index value will be multiplied before being added, along with any displacement, to the base value. The next instruction field is the optional displacement field, which may be from one to four bytes in length. The displacement field contains a constant used in address calculations. The optional immediate field, which may also be from one to four bytes in length, contains a constant used as an instruction operand. The shortest x86 instructions are only one byte long, and comprise a single opcode byte. The 80286 sets a maximum length for an instruction at 10 bytes, while the 80386 and 80486 both allow instruction lengths of up to 15 bytes.</p><p>The complexity of the x86 instruction set poses difficulties in implementing high performance x86 compatible superscalar microprocessors. One difficulty arises from the fact that instructions must be aligned with respect to the parallel-coupled instruction decoders of such processors before proper decode can be effectuated. In contrast to most RISC instruction formats, the x86 instruction set consists of variable byte length instructions. The variable byte length nature implies that the start bytes of successive instructions within a line are not necessarily equally spaced, and the number of instructions per line is not fixed. As a result, employment of simple, fixed-length shifting logic cannot in itself solve the problem of instruction alignment. Although scanning logic has been proposed to dynamically find the boundaries of instructions during the decode pipeline stage (or stages) of the processor, such a solution typically requires that the decode pipeline stage of the processor be implemented with a relatively large number of cascaded levels of logic gates and/or the allocation of several clock cycles to perform the scanning operation.</p><p>Another problem related to the detection of variable byte length instructions is incurred by microprocessors which define certain complex instructions as microcode instructions. \u201cMicrocode instructions\u201d, as used herein, are instructions which are not directly decoded by the parallel-coupled instruction decoders of the superscalar microprocessor. Instead, microcode instructions are routed to a microcode unit which decomposes the microcode instructions into simpler operations which may be decoded by the parallel-coupled instruction decoders. The microcode instructions, therefore, must be detected prior to decode of the instructions and routed to the microcode unit.</p><p>Certain microprocessors may employ predecoding as a method for locating variable byte length instructions. However, particularly if a cache line may be partially predecoded, the predecode data may be invalid for a given cache line fetched for dispatch within the microprocessor. A method for validating the predecode data is therefore needed.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by a microprocessor employing an instruction scanning unit in accordance with the present invention. The microprocessor employs predecoding, in which predecode information is generated for a set of instruction bytes prior to storing the instruction bytes into an instruction cache. In particular, the start and end of instructions are indicated. Additionally, a set of functional bits are defined which indicate the opcode byte of the instruction as well as the microcode/non-microcode nature of each instruction, among other things. When the instruction are fetched, the corresponding predecode data is fetched as well. The instruction scanning unit receives the predecode data, and scans the predecode data to locate the beginning and end of each instruction. The predecode data is independently scanned within multiple regions of the set of bytes, thereby increasing the number of instructions which may be located in a given clock cycle.</p><p>The instruction scanning unit speculatively generates instruction valid masks based upon the predecode data defining the start of instructions. A mask is generated for each byte within a particular region, assuming that that byte is an end byte of an instruction. In parallel, the predecode data defining the ends of instructions is scanned. The number of instructions ending prior to each byte in the region is counted. Subsequently, certain ones of the instruction valid masks are selected via the instruction end counts and the predecode data defining the end of instructions. If a byte is the end of an instruction and there are no instructions ending prior to that byte within the region, then the instruction valid mask corresponding to that byte is selected as the first instruction from the region. Similarly, if a second byte is the end of an instruction and there is one instruction ending prior to that second byte within the region, then the instruction valid mask corresponding to that second byte is selected as the second instruction from the region, etc. By processing the start and end predecode data separately, a faster scanning of the predecode data may be realized. The instructions identified by the instruction scanning unit are selected for dispatch into the instruction processing pipeline of the microprocessor.</p><p>In parallel with scanning the predecode data to identify instructions for dispatch into the instruction processing pipeline, the instruction scanning unit scans the predecode data to locate microcode instructions within the set of instruction bytes. Microcode instructions so identified are dispatched to a microcode unit as well as into the instruction processing pipeline of the microprocessor. By identifying the microcode instructions during instruction scanning, the microcode unit may begin processing the microcode instructions earlier in the instruction processing pipeline. The execution time of the microcode instructions may thereby be improved over microprocessors which identify microcode instructions at a later point in the instruction processing pipeline.</p><p>The microprocessor relies on the validity of the predecode data in order to properly route instructions being fetched. However, predecode data may be invalid for a variety of causes. Predecoding of a block of instructions may be interrupted, or the dynamic behavior of the program may cause instructions to be executed in a different manner than previously experienced. The instruction scanning unit, in parallel with scanning the predecode data for dispatching instructions and for microcode instructions, scans the predecode data for validity. The set of error conditions scanned for is sufficient to verify that the predecode data is correct. When incorrect predecode data is detected, the instruction scanning unit routers an invalid pointer and an indication of the invalidity to the predecode unit. The predecode unit subsequent predecodes the instruction bytes, thereby providing valid predecode data.</p><p>Broadly speaking, the present invention contemplates an instruction scanning unit comprising at least one scan block and a microcode scan unit. The scan block is configured to scan predecode information corresponding to a set of instruction bytes in order to locate instructions for dispatch to an instruction alignment unit. The microcode scan unit is configured to scan the predecode information in parallel with the scan block. The microcode scan unit is configured to detect microcode instructions for dispatch to a microcode unit.</p><p>The present invention further contemplates a method for locating microcode instructions within a plurality of instruction bytes and dispatching the microcode instructions to a microcode unit. A plurality of end bits and a plurality of functional bits are examined to identify microcode instructions. Each of the plurality of end bits and a corresponding one of the plurality of functional bits corresponds to one of the plurality of instruction bytes. A first microcode instruction identified by a first one of the plurality of end bits and a first corresponding one of the plurality of functional bits is dispatched.</p><p>The present invention still further contemplates an instruction scanning unit comprising at least one scan block and an invalid instruction scan unit. The scan block is configured to scan predecode information corresponding to a set of instruction bytes in order to locate instructions for dispatch to an instruction alignment unit. The invalid instruction scan unit is configured to scan the predecode information in parallel with the scan block, The invalid instruction scan unit is configured to detect invalid predecode information and to identify, via an invalid instruction pointer, a byte within the set of instruction bytes at which predecoding is to be performed to generate valid predecode information.</p><p>The present invention yet further contemplates a method for detecting invalid predecode data. The predecode data is scanned for validity in parallel with locating instructions via the predecode data. An invalid instruction pointer is determined as well. The invalid instruction pointer indicates a byte at which the predecode data becomes invalid.</p><p>Furthermore, the present invention contemplates an instruction scanning unit for scanning a block of predecode information associated with a plurality of contiguous instruction bytes. The block of predecode information includes start byte information indicative of bytes which start instructions and end byte information indicative of bytes which end instructions. The instruction scanning unit comprises a first subunit and a second subunit. The first subunit is coupled to receive the start byte information, and is configured to generate a plurality of instruction valid values. Each of the plurality of instruction valid values is indicative of a potential valid instruction starting at a first byte within the plurality of contiguous instruction bytes and ending at a second byte within the plurality of contiguous instruction bytes. The first byte is indicated to be a start byte by the start byte information, and the second byte is different for each one of the plurality of instruction valid values. Coupled to receive the end byte information, the second subunit is configured to generate a plurality of instruction end counts. Each of the instruction end counts is indicative of a number of instructions which end between a first one of the plurality of contiguous instruction bytes and a particular one of the plurality of contiguous instruction bytes. The first subunit and the second subunit operate in parallel.</p><p>Moreover, the present invention contemplates a method for concurrently locating variable byte length instructions. Start byte information corresponding to a plurality of contiguous bytes is scanned to create a plurality of instruction valid values. Each of the plurality of instruction valid values is indicative of a potential valid instruction beginning at a first of the plurality of contiguous bytes and ending at a second of the plurality of contiguous bytes. The first of the plurality of contiguous bytes is identified by the start byte information to be a start byte. One of the plurality of instruction valid values is selected. The second one of the plurality of contiguous bytes corresponding to the selected one of the plurality of instruction valid values is identified by end byte information corresponding to the plurality of instruction valid values to be an end byte.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of one embodiment of a superscalar microprocessor.</p><p>FIG. 2 is a block diagram of one embodiment of a pair of decode units shown in FIG. <b>1</b>.</p><p>FIG. 3 is a block diagram of one embodiment of an instruction scanning unit included within an instruction cache shown in FIG. <b>1</b>.</p><p>FIG. 4 is a block diagram of one embodiment of a scan block shown in FIG. <b>3</b>.</p><p>FIG. 5 is a logic diagram of one embodiment of portions of an IVAL generation subunit shown in FIG. <b>4</b>.</p><p>FIG. 6 is a logic diagram of one embodiment of portions of a PCEND generation subunit shown in FIG. <b>4</b>.</p><p>FIG. 7 is a logic diagram of one embodiment of portions of an NEND generation subunit shown in FIG. <b>4</b>.</p><p>FIG. 8 is a logic diagram of one embodiment of portions of a Scan Bus generation subunit shown in FIG. <b>4</b>.</p><p>FIG. 9 is a block diagram of one embodiment of an MROM instruction scan unit shown in FIG. <b>3</b>.</p><p>FIG. 10 is a flow chart depicting the activities of one embodiment of an invalid instruction scan unit shown in FIG. <b>3</b>.</p><p>FIG. 11 is a block diagram of a computer system including the microprocessor shown in FIG. <b>1</b>.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>Turning now to FIG. 1, a block diagram of one embodiment of a microprocessor <b>10</b> is shown. Microprocessor <b>10</b> includes a prefetch/predecode unit <b>12</b>, a branch prediction unit <b>14</b>, an instruction cache <b>16</b>, an instruction alignment unit <b>18</b>, a plurality of decode units <b>20</b>A-<b>20</b>C, a plurality of reservation stations <b>22</b>A-<b>22</b>C, a plurality of functional units <b>24</b>A-<b>24</b>C, a load/store unit <b>26</b>, a data cache <b>28</b>, a register file <b>30</b>, a reorder buffer <b>32</b>, and an MROM unit <b>34</b>. Elements referred to herein with a particular reference number followed by a letter will be collectively referred to by the reference number alone. For example, decode units <b>20</b>A-<b>20</b>C will be collectively referred to as decode units <b>20</b>.</p><p>Prefetch/predecode unit <b>12</b> is coupled to receive instructions from a main memory subsystem (not shown), and is further coupled to instruction cache <b>16</b> and branch prediction unit <b>14</b>. Similarly, branch prediction unit <b>14</b> is coupled to instruction cache <b>16</b>. Still further, branch prediction unit <b>14</b> is coupled to decode units <b>20</b> and functional units <b>24</b>. Instruction cache <b>16</b> is further coupled to MROM unit <b>34</b> and instruction alignment unit <b>18</b>. Instruction alignment unit <b>18</b> is in turn coupled to decode units <b>20</b>. Each decode unit <b>20</b>A-<b>20</b>C is coupled to load/store unit <b>26</b> and to respective reservation stations <b>22</b>A-<b>22</b>C. Reservation stations <b>22</b>A-<b>22</b>C are further coupled to respective functional units <b>24</b>A-<b>24</b>C. Additionally, decode units <b>20</b> and reservation stations <b>22</b> are coupled to register file <b>30</b> and reorder buffer <b>32</b>. Functional units <b>24</b> are coupled to load/store unit <b>26</b>, register file <b>30</b>, and reorder buffer <b>32</b> as well. Data cache <b>28</b> is coupled to load/store unit <b>26</b> and to the main memory subsystem. Finally, MROM unit <b>34</b> is coupled to decode units <b>20</b>.</p><p>Generally speaking, instruction cache <b>16</b> includes an instruction scanning unit configured to scan predecode data fetched from the instruction cache. The instruction scanning unit independently and in parallel locates instructions from multiple regions of a set of bytes being scanned, thereby increasing the maximum number of instructions which may be concurrently located and conveyed to instruction alignment unit <b>18</b>. The predecode data includes both start and end bits, and the start and end bits are further scanned in parallel with each other to locate the instructions, further decreasing the number of cascaded levels of logic used to locate the instructions.</p><p>Because the predecode data must be correct for microprocessor <b>10</b> to operate properly, the instruction scanning unit scans the predecode data for validity as well. If invalid predecode data is detected, the instructions are routed to prefetch/predecode unit <b>12</b> for predecoding. The validity checking identifies the byte at which predecoding should begin, advantageously reducing the amount of predecoding performed when partially valid predecode data is detected. Additionally, MROM instructions are dispatched to MROM unit <b>34</b> as well as to instruction alignment unit <b>18</b>. Therefore, the predecode data is scanned independently for MROM instructions in addition to the scanning performed for dispatch to instruction alignment unit <b>18</b>. The MROM instruction scanning is performed in parallel with instruction scanning for dispatch to instruction alignment unit <b>18</b>.</p><p>Instruction cache <b>16</b> is a high speed cache memory provided to store instructions. Instructions are fetched from instruction cache <b>16</b> and dispatched to decode units <b>20</b>. In one embodiment, instruction cache <b>16</b> is configured to store up to 32 kilobytes of instructions in an 8 way set associative structure having 32 byte lines (a byte comprises 8 binary bits). Instruction cache <b>16</b> may additionally employ a way prediction scheme in order to speed access times to the instruction cache. Instead of accessing tags identifying each line of instructions and comparing the tags to the fetch address to select a way, instruction cache <b>16</b> predicts the way that is accessed. In this manner, the way is selected prior to accessing the instruction storage. The access time of instruction cache <b>16</b> may be similar to a direct-mapped cache. A tag comparison is performed and, if the way prediction is incorrect, the correct instructions are fetched and the incorrect instructions are discarded. It is noted that instruction cache <b>16</b> may be implemented as a fully associative, set associative, or direct mapped configuration.</p><p>Instructions are fetched from main memory and stored into instruction cache <b>16</b> by prefetch/predecode unit <b>12</b>. Instructions may be prefetched prior to instruction cache <b>16</b> recording a miss for the instructions in accordance with a prefetch scheme. A variety of prefetch schemes may be employed by prefetch/predecode unit <b>12</b>. As prefetch/predecode unit <b>12</b> transfers instructions from main memory to instruction cache <b>16</b>, prefetch/predecode unit <b>12</b> generates three predecode bits for each byte of the instructions: a start bit, an end bit, and a functional bit. The predecode bits form tags indicative of the boundaries of each instruction. The predecode tags may also convey additional information such as whether a given instruction can be decoded directly by decode units <b>20</b> or whether the instruction is executed by invoking a microcode procedure controlled by MROM unit <b>34</b>, as will be described in greater detail below. Still further, prefetch/predecode unit <b>12</b> may be configured to detect branch instructions and to store branch prediction information corresponding to the branch instructions into branch prediction unit <b>14</b>.</p><p>One encoding of the predecode tags for an embodiment of microprocessor <b>10</b> employing the x86 instruction set will next be described. If a given byte is the first byte of an instruction, the start bit for that byte is set. If the byte is the last byte of an instruction, the end bit for that byte is set. Instructions which may be directly decoded by decode units <b>20</b> are referred to as \u201cfast path\u201d instructions. The remaining x86 instructions are referred to as MROM instructions, according to one embodiment. MROM instructions are an example of microcode instructions. For fast path instructions, the functional bit is set for each prefix byte included in the instruction, and cleared for other bytes. Alternatively, for MROM instructions, the functional bit is cleared for each prefix byte and set for other bytes. The type of instruction may be determined by examining the functional bit corresponding to the end byte. If that functional bit is clear, the instruction is a fast path instruction. Conversely, if that functional bit is set, the instruction is an MROM instruction. The opcode of an instruction may thereby be located within an instruction which may be directly decoded by decode units <b>20</b> as the byte associated with the first clear functional bit in the instruction. For example, a fast path instruction including two prefix bytes, a Mod R/M byte, and an SIB byte would have start, end, and functional bits as follows:</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"119PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Start bits</entry><entry morerows=\"0\" valign=\"top\">10000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">End bits</entry><entry morerows=\"0\" valign=\"top\">00001</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Functional bits</entry><entry morerows=\"0\" valign=\"top\">11000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>MROM instructions are instructions which are determined to be too complex for decode by decode units <b>20</b>. MROM instructions are executed by invoking MROM unit <b>34</b>. More specifically, when an MROM instruction is encountered, MROM unit <b>34</b> parses and issues the instruction into a subset of defined fast path instructions to effectuate the desired operation. MROM unit <b>34</b> dispatches the subset of fast path instructions to decode units <b>20</b>. A listing of exemplary x86 instructions categorized as fast path instructions will be provided further below.</p><p>Microprocessor <b>10</b> employs branch prediction in order to speculatively fetch instructions subsequent to conditional branch instructions. Branch prediction unit <b>14</b> is included to perform branch prediction operations. In one embodiment, up to two branch target addresses are stored with respect to each 16 byte portion of each cache line in instruction cache <b>16</b>. Prefetch/predecode unit <b>12</b> determines initial branch targets when a particular line is predecoded. Subsequent updates to the branch targets corresponding to a cache line may occur due to the execution of instructions within the cache line. Instruction cache <b>16</b> provides an indication of the instruction address being fetched, so that branch prediction unit <b>14</b> may determine which branch target addresses to select for forming a branch prediction. Decode units <b>20</b> and functional units <b>24</b> provide update information to branch prediction unit <b>14</b>. Because branch prediction unit <b>14</b> stores two targets per 16 byte portion of the cache line, some branch instructions within the line may not be stored in branch prediction unit <b>14</b>. Decode units <b>20</b> detect branch instructions which were not predicted by branch prediction unit <b>14</b>. Functional units <b>24</b> execute the branch instructions and determine if the predicted branch direction is incorrect. The branch direction may be \u201ctaken\u201d, in which subsequent instructions are fetched from the target address of the branch instruction. Conversely, the branch direction may be \u201cnot taken\u201d, in which subsequent instructions are fetched from memory locations consecutive to the branch instruction. When a mispredicted branch instruction is detected, instructions subsequent to the mispredicted branch are discarded from the various units of microprocessor <b>10</b>. A variety of suitable branch prediction algorithms may be employed by branch prediction unit <b>14</b>.</p><p>Instructions fetched from instruction cache <b>16</b> are conveyed to instruction alignment unit <b>18</b>. As instructions are fetched from instruction cache <b>16</b>, the corresponding predecode data is scanned to provide information to instruction alignment unit <b>18</b> (and to MROM unit <b>34</b>) regarding the instructions being fetched. Instruction alignment unit <b>18</b> utilizes the scanning data to align an instruction to each of decode units <b>20</b>. In one embodiment, instruction alignment unit <b>18</b> aligns instructions from three sets of eight instruction bytes to decode units <b>20</b>. Instructions are selected independently from each set of eight instruction bytes into preliminary issue positions. The preliminary issue positions are then merged to a set of aligned issue positions corresponding to decode units <b>20</b>, such that the aligned issue positions contain the three instructions which are prior to other instructions within the preliminary issue positions in program order. Decode unit <b>20</b>A receives an instruction which is prior to instructions concurrently received by decode units <b>20</b>B and <b>20</b>C (in program order). Similarly, decode unit <b>20</b>B receives an instruction which is prior to the instruction concurrently received by decode unit <b>20</b>C in program order.</p><p>Decode units <b>20</b> are configured to decode instructions received from instruction alignment unit <b>18</b>. Register operand information is detected and routed to register file <b>30</b> and reorder buffer <b>32</b>. Additionally, if the instructions require one or more memory operations to be performed, decode units <b>20</b> dispatch the memory operations to load/store unit <b>26</b>. Each instruction is decoded into a set of control values for functional units <b>24</b>, and these control values are dispatched to reservation stations <b>22</b> along with operand address information and displacement or immediate data which may be included with the instruction.</p><p>Microprocessor <b>10</b> supports out of order execution, and thus employs reorder buffer <b>32</b> to keep track of the original program sequence for register read and write operations, to implement register renaming, to allow for speculative instruction execution and branch misprediction recovery, and to facilitate precise exceptions. A temporary storage location within reorder buffer <b>32</b> is reserved upon decode of an instruction that involves the update of a register to thereby store speculative register states. If a branch prediction is incorrect, the results of speculatively-executed instructions along the mispredicted path can be invalidated in the buffer before they are written to register file <b>30</b>. Similarly, if a particular instruction causes an exception, instructions subsequent to the particular instruction may be discarded. In this manner, exceptions are \u201cprecise\u201d (i.e. instructions subsequent to the particular instruction causing the exception are not completed prior to the exception). It is noted that a particular instruction is speculatively executed if it is executed prior to instructions which precede the particular instruction in program order. Preceding instructions may be a branch instruction or an exception-causing instruction, in which case the speculative results may be discarded by reorder buffer <b>32</b>.</p><p>The instruction control values and immediate or displacement data provided at the outputs of decode units <b>20</b> are routed directly to respective reservation stations <b>22</b>. In one embodiment, each reservation station <b>22</b> is capable of holding instruction information (i.e., instruction control values as well as operand values, operand tags and/or immediate data) for up to three pending instructions awaiting issue to the corresponding functional unit. It is noted that for the embodiment of FIG. 1, each reservation station <b>22</b> is associated with a dedicated functional unit <b>24</b>. Accordingly, three dedicated \u201cissue positions\u201d are formed by reservation stations <b>22</b> and functional units <b>24</b>. In other words, issue position 0 is formed by reservation station <b>22</b>A and functional unit <b>24</b>A. Instructions aligned and dispatched to reservation station <b>22</b>A are executed by functional unit <b>24</b>A. Similarly, issue position 1 is formed by reservation station <b>22</b>B and functional unit <b>24</b>B; and issue position 2 is formed by reservation station <b>22</b>C and functional unit <b>24</b>C.</p><p>Upon decode of a particular instruction, if a required operand is a register location, register address information is routed to reorder buffer <b>32</b> and register file <b>30</b> simultaneously. Those of skill in the art will appreciate that the x86 register file includes eight 32 bit real registers (i.e., typically referred to as EAX, EBX, ECX, EDX, EBP, ESI, EDI and ESP). In embodiments of microprocessor <b>10</b> which employ the x86 microprocessor architecture, register file <b>30</b> comprises storage locations for each of the 32 bit real registers. Additional storage locations may be included within register file <b>30</b> for use by MROM unit <b>34</b>. Reorder buffer <b>32</b> contains temporary storage locations for results which change the contents of these registers to thereby allow out of order execution. A temporary storage location of reorder buffer <b>32</b> is reserved for each instruction which, upon decode, is determined to modify the contents of one of the real registers. Therefore, at various points during execution of a particular program, reorder buffer <b>32</b> may have one or more locations which contain the speculatively executed contents of a given register. If following decode of a given instruction it is determined that reorder buffer <b>32</b> has a previous location or locations assigned to a register used as an operand in the given instruction, the reorder buffer <b>32</b> forwards to the corresponding reservation station either: 1) the value in the most recently assigned location, or 2) a tag for the most recently assigned location if the value has not yet been produced by the functional unit that will eventually execute the previous instruction. If reorder buffer <b>32</b> has a location reserved for a given register, the operand value (or reorder buffer tag) is provided from reorder buffer <b>32</b> rather than from register file <b>30</b>. If there is no location reserved for a required register in reorder buffer <b>32</b>, the value is taken directly from register file <b>30</b>. If the operand corresponds to a memory location, the operand value is provided to the reservation station through load/store unit <b>26</b>.</p><p>In one particular embodiment, reorder buffer <b>32</b> is configured to store and manipulate concurrently decoded instructions as a unit. This configuration will be referred to herein as \u201cline-oriented\u201d. By manipulating several instructions together, the hardware employed within reorder buffer <b>32</b> may be simplified. For example, a line-oriented reorder buffer included in the present embodiment allocates storage sufficient for instruction information pertaining to three instructions (one from each decode unit <b>20</b>) whenever one or more instructions are dispatched by decode units <b>20</b>. By contrast, a variable amount of storage is allocated in conventional reorder buffers, dependent upon the number of instructions actually dispatched. A comparatively larger number of logic gates may be required to allocate the variable amount of storage. When each of the concurrently decoded instructions has executed, the instruction results are stored into register file <b>30</b> simultaneously. The storage is then free for allocation to another set of concurrently decoded instructions. Additionally, the amount of control logic circuitry employed per instruction is reduced because the control logic is amortized over several concurrently decoded instructions. A reorder buffer tag identifying a particular instruction may be divided into two fields: a line tag and an offset tag. The line tag identifies the set of concurrently decoded instructions including the particular instruction, and the offset tag identifies which instruction within the set corresponds to the particular instruction. It is noted that storing instruction results into register file <b>30</b> and freeing the corresponding storage is referred to as \u201cretiring\u201d the instructions. It is further noted that any reorder buffer configuration may be employed in various embodiments of microprocessor <b>10</b>.</p><p>As noted earlier, reservation stations <b>22</b> store instructions until the instructions are executed by the corresponding functional unit <b>24</b>. An instruction is selected for execution if: (i) the operands of the instruction have been provided; and (ii) the operands have not yet been provided for instructions which are within the same reservation station <b>22</b>A-<b>22</b>C and which are prior to the instruction in program order. It is noted that when an instruction is executed by one of the functional units <b>24</b>, the result of that instruction is passed directly to any reservation stations <b>22</b> that are waiting for that result at the same time the result is passed to update reorder buffer <b>32</b> (this technique is commonly referred to as \u201cresult forwarding\u201d). An instruction may be selected for execution and passed to a functional unit <b>24</b>A-<b>24</b>C during the clock cycle that the associated result is forwarded. Reservation stations <b>22</b> route the forwarded result to the functional unit <b>24</b> in this case.</p><p>In one embodiment, each of the functional units <b>24</b> is configured to perform integer arithmetic operations of addition and subtraction, as well as shifts, rotates, logical operations, and branch operations. The operations are performed in response to the control values decoded for a particular instruction by decode units <b>20</b>. It is noted that a floating point unit (not shown) may also be employed to accommodate floating point operations. The floating point unit may be operated as a coprocessor, receiving instructions from MROM unit <b>34</b> and subsequently communicating with reorder buffer <b>32</b> to complete the instructions. Additionally, functional units <b>24</b> may be configured to perform address generation for load and store memory operations performed by load/store unit <b>26</b>.</p><p>Each of the functional units <b>24</b> also provides information regarding the execution of conditional branch instructions to the branch prediction unit <b>14</b>. If a branch prediction was incorrect, branch prediction unit <b>14</b> flushes instructions subsequent to the mispredicted branch that have entered the instruction processing pipeline, and causes fetch of the required instructions from instruction cache <b>16</b> or main memory. It is noted that in such situations, results of instructions in the original program sequence which occur after the mispredicted branch instruction are discarded, including those which were speculatively executed and temporarily stored in load/store unit <b>26</b> and reorder buffer <b>32</b>.</p><p>Results produced by functional units <b>24</b> are sent to reorder buffer <b>32</b> if a register value is being updated, and to load/store unit <b>26</b> if the contents of a memory location are changed. If the result is to be stored in a register, reorder buffer <b>32</b> stores the result in the location reserved for the value of the register when the instruction was decoded. A plurality of result buses <b>38</b> are included for forwarding of results from functional units <b>24</b> and load/store unit <b>26</b>. Result buses <b>38</b> convey the result generated, as well as the reorder buffer tag identifying the instruction being executed.</p><p>Load/store unit <b>26</b> provides an interface between functional units <b>24</b> and data cache <b>28</b>. In one embodiment, load/store unit <b>26</b> is configured with a load/store buffer having eight storage locations for data and address information for pending loads or stores. Decode units <b>20</b> arbitrate for access to the load/store unit <b>26</b>. When the buffer is full, a decode unit must wait until load/store unit <b>26</b> has room for the pending load or store request information. Load/store unit <b>26</b> also performs dependency checking for load memory operations against pending store memory operations to ensure that data coherency is maintained. A memory operation is a transfer of data between microprocessor <b>10</b> and the main memory subsystem. Memory operations may be the result of an instruction which utilizes an operand stored in memory, or may be the result of a load/store instruction which causes the data transfer but no other operation. Additionally, load/store unit <b>26</b> may include a special register storage for special registers such as the segment registers and other registers related to the address translation mechanism defined by the x86 microprocessor architecture.</p><p>In one embodiment, load/store unit <b>26</b> is configured to perform load memory operations speculatively. Store memory operations are performed in program order, but may be speculatively stored into the predicted way. If the predicted way is incorrect, the data prior to the store memory operation is subsequently restored to the predicted way and the store memory operation is performed to the correct way. In another embodiment, stores may be executed speculatively as well. Speculatively executed stores are placed into a store buffer, along with a copy of the cache line prior to the update. If the speculatively executed store is later discarded due to branch misprediction or exception, the cache line may be restored to the value stored in the buffer. It is noted that load/store unit <b>26</b> may be configured to perform any amount of speculative execution, including no speculative execution.</p><p>Data cache <b>28</b> is a high speed cache memory provided to temporarily store data being transferred between load/store unit <b>26</b> and the main memory subsystem. In one embodiment, data cache <b>28</b> has a capacity of storing up to sixteen kilobytes of data in an eight way set associative structure. Similar to instruction cache <b>16</b>, data cache <b>28</b> may employ a way prediction mechanism. It is understood that data cache <b>28</b> may be implemented in a variety of specific memory configurations, including a set associative configuration.</p><p>In one particular embodiment of microprocessor <b>10</b> employing the x86 microprocessor architecture, instruction cache <b>16</b> and data cache <b>28</b> are linearly addressed. The linear address is formed from the offset specified by the instruction and the base address specified by the segment portion of the x86 address translation mechanism. Linear addresses may optionally be translated to physical addresses for accessing a main memory. The linear to physical translation is specified by the paging portion of the x86 address translation mechanism. It is noted that a linear addressed cache stores linear address tags. A set of physical tags (not shown) may be employed for mapping the linear addresses to physical addresses and for detecting translation aliases. Additionally, the physical tag block may perform linear to physical address translation.</p><p>Turning now to FIG. 2, a block diagram of one embodiment of decode units <b>20</b>B and <b>20</b>C are shown. Each decode unit <b>20</b> receives an instruction from instruction alignment unit <b>18</b>. Additionally,, MROM unit <b>34</b> is coupled to each decode unit <b>20</b> for dispatching fast path instructions corresponding to a particular MROM instruction. Decode unit <b>20</b>B comprises early decode unit <b>40</b>B, multiplexor <b>42</b>B, and opcode decode unit <b>44</b>B. Similarly, decode unit <b>20</b>C includes early decode unit <b>40</b>C, multiplexor <b>42</b>C, and opcode decode unit <b>44</b>C.</p><p>Certain instructions in the x86 instruction set are both fairly complicated and frequently used. In one embodiment of microprocessor <b>10</b>, such instructions include more complex operations than the hardware included within a particular functional unit <b>24</b>A-<b>24</b>C is configured to perform. Such instructions are classified as a special type of MROM instruction referred to as a \u201cdouble dispatch\u201d instruction. These instructions are dispatched to a pair of opcode decode units <b>44</b>. It is noted that opcode decode units <b>44</b> are coupled to respective reservation stations <b>22</b>. Each of opcode decode units <b>44</b>A-<b>44</b>C forms an issue position with the corresponding reservation station <b>22</b>A-<b>22</b>C and functional unit <b>24</b>A-<b>24</b>C. Instructions are passed from an opcode decode unit <b>44</b> to the corresponding reservation station <b>22</b> and further to the corresponding functional unit <b>24</b>.</p><p>Multiplexor <b>42</b>B is included for selecting between the instructions provided by MROM unit <b>34</b> and by early decode unit <b>40</b>B. During times in which MROM unit <b>34</b> is dispatching instructions, multiplexor <b>42</b>B selects instructions provided by MROM unit <b>34</b>. At other times, multiplexor <b>42</b>B selects instructions provided by early decode unit <b>40</b>B. Similarly, multiplexor <b>42</b>C selects between instructions provided by MROM unit <b>34</b>, early decode unit <b>40</b>B, and early decode unit <b>40</b>C. The instruction from MROM unit <b>34</b> is selected during times in which MROM unit <b>34</b> is dispatching instructions. During times in which early decode unit <b>40</b>A detects a double dispatch instruction, the instruction from early decode unit <b>40</b>B is selected by multiplexor <b>42</b>C. Otherwise, the instruction from early decode unit <b>40</b>C is selected. Selecting the instruction from early decode unit <b>40</b>B into opcode decode unit <b>44</b>C allows a fast path instruction decoded by decode unit <b>20</b>B to be dispatched concurrently with a double dispatch instruction decoded by decode unit <b>20</b>A.</p><p>According to one embodiment employing the x86 instruction set, early decode units <b>40</b> perform the following operations:</p><p>(i) merge the prefix bytes of the instruction into an encoded prefix byte;</p><p>(ii) decode unconditional branch instructions (which may include the unconditional jump, the CALL, and the RETURN) which were not detected during branch prediction;</p><p>(iii) decode source and destination flags;</p><p>(iv) decode the source and destination operands which are register operands and generate operand size information; and</p><p>(v) determine the displacement and/or immediate size so that displacement and immediate data may be routed to the opcode decode unit.</p><p>Opcode decode units <b>44</b> are configured to decode the opcode of the instruction, producing control values for functional unit <b>24</b>. Displacement and immediate data are routed with the control values to reservation stations <b>22</b>.</p><p>Since early decode units <b>40</b> detect operands, the outputs of multiplexors <b>42</b> are routed to register file <b>30</b> and reorder buffer <b>32</b>. Operand values or tags may thereby be routed to reservation stations <b>22</b>. Additionally, memory operands are detected by early decode units <b>40</b>. Therefore, the outputs of multiplexors <b>42</b> are routed to load/store unit <b>26</b>. Memory operations corresponding to instructions having memory operands are stored by load/store unit <b>26</b>.</p><p>Turning now to FIG. 3, a block diagram of one embodiment of an instruction scanning unit <b>50</b> is shown. In microprocessor <b>10</b>, instruction scanning unit <b>50</b> is included within instruction cache <b>16</b>. As shown in FIG. 3, instruction scanning unit <b>50</b> includes a control unit <b>52</b>, an invalid instruction scan unit <b>54</b>, an MROM instruction scan unit <b>56</b>, a first scan block <b>58</b>, and a second scan block <b>60</b>. A register <b>62</b> is included for storing data corresponding to a set of instruction bytes being scanned. Register <b>62</b> receives as an input the output of a multiplexor <b>64</b>. Multiplexor <b>64</b> provides, under the control of control unit <b>52</b>, either data corresponding to a new set of instruction bytes fetched from instruction cache <b>16</b> or updated data indicating dispatch of zero or more instructions from the set of instruction bytes represented by the data stored in register <b>62</b>. In one embodiment, a set of instruction bytes is 16 bytes corresponding to either an upper half or a lower half of a 32 byte instruction cache line. The set of 16 instruction bytes is divided into two regions of eight bytes each, which are scanned independent from each other. In other embodiments, a set may include more or fewer bytes and more or fewer regions.</p><p>Instruction scanning unit <b>50</b> identifies valid instructions within the set of instruction bytes being scanned, so that instruction alignment unit <b>18</b> may align the instructions to decode units <b>20</b>. More particularly, instruction scanning unit <b>50</b> provides a set of valid masks for instructions within the set of instruction bytes. Each valid mask includes binary ones corresponding to byte positions occupied by the bytes of a particular instruction. Additionally, start pointers and end pointers encoding offsets within the set of instruction bytes at which each instruction begins and ends are generated by instruction scanning unit <b>50</b>. An indication of the fast path/MROM nature of each instruction is provided as well. Still further, an indication of an instruction which overflows from the set of instruction bytes or between regions within the set of instruction bytes is provided.</p><p>Instruction scanning unit <b>50</b> receives information regarding the set of bytes being fetched from instruction cache <b>16</b> and branch prediction unit <b>14</b>. In particular, instruction scanning unit receives a set of start bits on a start bits bus <b>68</b>, a set of end bits upon an end bits bus <b>70</b>, and a set of functional bits upon a functional bits bus <b>72</b>, all from instruction cache <b>16</b>. Additionally, an end pointer is received from branch prediction unit <b>14</b> upon an end pointer bus <b>74</b> and a start pointer is received upon a start pointer bus <b>66</b> from branch prediction unit <b>14</b> as well. The start pointer and the end pointer are offsets within the set of instruction bytes represented by the start, end, and functional bits provided upon buses <b>68</b>-<b>72</b>. The start pointer indicates the byte identified by the fetch address presented to instruction cache <b>16</b>. Bytes prior to the start pointer are not requested by the instruction fetching mechanism of microprocessor <b>10</b>. For example, a branch instruction may have a target address which indicates a byte other than the first byte in the set of instruction bytes. In other cases, the first byte in the set of instruction bytes may be being fetched (e.g. when the previous set of instruction bytes did not include a predicted taken branch instruction). In these cases, the start pointer is zero (e.g. an offset of zero). Branch, prediction unit <b>14</b> generates the end pointer based upon the existence (or lack thereof) of a branch instruction within the set of instruction bytes. The end pointer indicates the end byte of the last instruction within the set of instruction bytes to be executed in accordance with the branch prediction stored for the set of instruction bytes.</p><p>The start pointer and the end pointer, taken together, define a subset of the set of instruction bytes which are to be dispatched as instructions to instruction alignment unit <b>18</b>. Instructions between the start pointer and the end pointer are dispatched, while instructions prior to the start pointer or subsequent to the end pointer are not selected as part of the instructions being dispatched during the current clock cycle. The start, end, and functional bits correspond to the set of instruction bytes being fetched, as described above.</p><p>If instruction scanning unit <b>50</b> is not in the process of scanning a previous set of instruction bytes when instruction cache <b>16</b> provides a set of instruction bytes, control unit <b>52</b> causes multiplexor <b>64</b> to select the start pointer, end pointer, start bits, end bits, and functional bits provided by instruction cache <b>16</b> and branch prediction unit <b>14</b> into register <b>62</b>. On the other hand, if a previous set of instruction bytes has not been completely scanned and transmitted to instruction alignment unit <b>18</b>, an updated set of start bits, end bits, and functional bits indicating the instructions remaining to be scanned and transmitted are provided to multiplexor <b>64</b>, which selects the updated values into register <b>62</b>.</p><p>Register <b>62</b> stores a current end pointer <b>76</b>, a current start pointer <b>78</b>, a current set of functional bits <b>80</b>, a current set of start bits <b>82</b>, and a current set of end bits <b>84</b>. The current values stored in register <b>62</b> initially comprise the values provided by instruction cache <b>16</b> and branch prediction unit <b>14</b>, and are subsequently updated by control unit <b>52</b> if more than one clock cycle is needed to scan and convey all of the instructions from the set of instruction bytes to instruction alignment unit <b>18</b>.</p><p>First scan block <b>58</b> and second scan block <b>60</b> independently scan regions of the set of instruction bytes. In the present embodiment, up to three instructions are located within each region and conveyed to instruction alignment unit <b>18</b>. First scan block <b>58</b> and second scan block <b>60</b> form the valid masks for each of the located instructions for their respective regions based upon the start bits <b>82</b> and end bits <b>84</b> provided from register <b>62</b>. The valid masks are conveyed upon scan buses <b>86</b> and <b>88</b>.</p><p>Each scan block receives the start bits and end bits corresponding to the region that scan block scans. For example, according to one embodiment, first scan block <b>58</b> scans the first eight bytes of the set of instruction bytes while second scan block <b>60</b> scans the second eight bytes of the set of instruction bytes. Therefore, first scan block <b>58</b> receives the portion of start bits <b>82</b> and end bits <b>84</b> corresponding to the first eight bytes while second scan block <b>60</b> receives the portion of start bits <b>82</b> and end bits <b>84</b> corresponding to the second eight bytes. By scanning the start and end bits, scan blocks <b>58</b> and <b>60</b> can locate the valid instructions within the line. Additionally, scan blocks <b>58</b> and <b>60</b> receive masks generated by control unit <b>52</b> based upon the start and end pointers. The masks indicate which of the bytes are valid for dispatch, and are used by the scan blocks to select the appropriate valid bytes (i.e. those which are first, in program order, among the instructions between the start and the end pointer). The masks are conveyed upon a set of mask buses <b>98</b> and <b>100</b>. Bus <b>98</b> provides the mask for the first region of the set of instruction bytes, and bus <b>100</b> provides the mask for the second region of the set of instruction bytes.</p><p>In addition to being provided to instruction alignment unit <b>18</b>, scan buses <b>86</b> and <b>88</b> are provided to control unit <b>52</b> for determining which instructions have been successfully identified to instruction alignment unit <b>18</b>. Control unit <b>52</b> masks the start and end bits corresponding to instructions which have been successfully conveyed to instruction alignment unit <b>18</b>. Instructions are successfully conveyed by first scan block <b>58</b> as long as instruction alignment unit <b>18</b> is capable of accepting the instructions (i.e. not stalling due to any buffer full conditions, etc.). Instructions are successfully conveyed by second scan block <b>60</b> if first scan block <b>58</b> is concurrently or has previously conveyed all of the instructions from the first region of the set of bytes and instruction alignment unit <b>18</b> is capable of accepting the instructions. If instructions remain to be dispatched after the masking (or MROM instructions remain to be dispatched to MROM unit <b>34</b>, as described further below), then control unit <b>52</b> provides the updated values to register <b>62</b> via multiplexor <b>64</b>.</p><p>Additionally, control unit <b>52</b> generates start pointers and end pointers corresponding to each of the valid masks received upon scan buses <b>86</b> and <b>88</b>. Control unit <b>52</b> provides these start and end pointers upon a start pointers bus <b>90</b> and an end pointers bus <b>92</b> to instruction alignment unit <b>18</b>. Still further, control unit <b>52</b> conveys the MROM/fast path nature of each instruction as determined from the functional bits corresponding to the end bits of the selected instruction upon an MROM bus <b>94</b>. Lastly, control unit <b>52</b> provides overflow indications corresponding to each region of instruction bytes. An overflow is indicated if an instruction being conveyed to instruction alignment unit <b>18</b> overflows from the first region to the second region, or overflows from the second region to a first region of a subsequently fetched set of instruction bytes, or overflows from the first region through the second region to the first region of the subsequently fetched set of instruction bytes. A signal is included for each overflow indication, and the signal are conveyed upon an overflow bus <b>96</b>.</p><p>MROM instruction scan unit <b>56</b> scans the set of instruction bytes for MROM instructions, and provides an opcode pointer, a start pointer, and a set of valid bits to MROM unit <b>34</b> for each MROM instruction. Since MROM instructions can be detected by analyzing the functional bits corresponding to end bytes, MROM instruction scan unit <b>56</b> receives functional bits <b>80</b> and end bits <b>84</b> from register <b>62</b>. Furthermore, start bits <b>82</b> are received by MROM instruction scan unit <b>56</b> to aid in start pointer formation. In one embodiment, the MROM instructions are provided to MROM unit <b>34</b> at a rate of one per clock cycle. Therefore, if multiple MROM instructions reside within a set of instruction bytes, MROM instruction scan unit <b>56</b> indicates to control unit <b>52</b> that MROM instructions remain to be dispatched to MROM unit <b>34</b>. As noted above, control unit <b>52</b> updates register <b>62</b> with values corresponding to the current set of instructions until: (i) all instructions to be dispatched have been conveyed to instruction alignment unit <b>18</b> via first scan block <b>58</b> and second scan block <b>60</b>; and (ii) all MROM instructions have been dispatched to MROM unit <b>34</b> by MROM instruction scan unit <b>56</b>. MROM instruction scan unit <b>56</b> provides the opcode pointer upon an MROM opcode pointer bus <b>102</b>, the start pointer upon an MROM start pointer bus <b>104</b>, and the valid bits upon an MROM valid bus <b>106</b>.</p><p>Invalid instruction scan unit <b>54</b> scans start bits <b>82</b> and end bits <b>84</b> to determine if valid predecode data has been provided with respect to the set of bytes. Invalid instruction scan unit <b>54</b> additionally receives start pointer <b>78</b> for further checking, as described in more detail below. Instruction alignment unit <b>18</b> relies on the predecode data being correct in order to correctly route instructions to decode units <b>20</b>. However, predecode data for a given set of bytes may be invalid for a variety of reasons. For example, prefetch/predecode unit <b>12</b> is configured (according to one embodiment) to discontinue predecoding of a particular set of bytes upon encountering a predicted-taken branch instruction. Therefore, if bytes within the set of bytes which are subsequent to the predicted-taken branch instruction are fetched, then valid predecode data may not have been generated. Similarly, if prefetch/predecode unit <b>12</b> is predecoding a prefetched cache line and a request from invalid instruction scan unit <b>54</b> to predecode a cache line being fetched is received, prefetch/predecode unit <b>12</b> discontinues predecode of the prefetched cache line. Still further, the operation of a program may cause the predecode data to become invalid. For example, a branch instruction may branch to a target address at which the opcode of an instruction is stored, thereby bypassing any prefix bytes for the instruction. In such a case, the start bit for the opcode byte (i.e. the start byte of the instruction for this case) is not set. Many other examples leading to invalid predecode data may occur as well. Invalid instruction scan unit <b>54</b> is provided to detect any invalid predecode data.</p><p>If invalid instruction scan unit <b>54</b> detects invalid predecode data, invalid instruction scan unit <b>54</b> provides a pointer to the byte at which the predecode data becomes invalid (upon an invalid pointer bus <b>108</b>) and an indication of the invalidity detected (upon an invalid bus <b>110</b>) to prefetch/predecode unit <b>12</b>. Prefetch/predecode unit <b>12</b> subsequently predecodes the set of instruction bytes beginning at the pointer provided by invalid instruction scan unit <b>54</b>. The newly generated predecode data is stored into instruction cache <b>16</b> in the cache line storing the set of instruction bytes, and the newly generated predecode data is provided to instruction scanning unit <b>50</b> for scan and dispatch of the appropriate instructions. In one embodiment, invalid instruction scan unit <b>54</b> indicates invalidity of the predecode data if it occurs within the first three instructions within the set of instruction bytes (i.e. the instructions being dispatched during the clock cycle by first scan block <b>58</b> or second scan block <b>60</b>). In this manner, the instructions for which valid predecode data has been generated are dispatched prior to submitting the set of instruction bytes to prefetch/predecode unit <b>12</b> for predecoding. As with MROM instruction scan unit <b>56</b> and scan blocks <b>58</b> and <b>60</b>, invalid instruction scan unit <b>54</b> receives the masks upon mask buses <b>98</b> and <b>100</b> from control unit <b>52</b>. Invalid instruction scan unit <b>54</b> analyzes the predecode data for the instruction bytes between the start and end pointers, as indicated by the masks.</p><p>It is noted that, although invalid instruction scan unit <b>54</b> and MROM instruction scan unit <b>56</b> as shown in FIG. 3 operate upon the set of instruction bytes as a whole, invalid instruction scan unit <b>54</b> and MROM instruction scan unit <b>56</b> may be divided into regions in a fashion similar to scan blocks <b>58</b> and <b>60</b>. Alternatively, MROM instruction scan unit <b>56</b> and invalid instruction scan unit <b>54</b> may operate upon regions independently and then select a result for conveyance depending upon the results of each region.</p><p>Turning now to FIG. 4, an embodiment of first scan block <b>58</b> is shown. Second scan block <b>58</b> may be configured similarly. First scan block <b>58</b> receives a portion of start bits <b>82</b> upon a scan start bit bus <b>150</b>. The portion received corresponds to the region of the set of instruction bytes which first scan block <b>58</b> is configured to scan. Additionally, first scan block <b>58</b> receives a portion of end bits <b>84</b> upon a scan end bit bus <b>152</b>. First scan block <b>58</b> produces a scan bus <b>154</b>.</p><p>First scan block <b>58</b> is configured with several subunits which perform various tasks. An IVAL generation subunit <b>156</b> is coupled to scan start bit bus <b>150</b> and to an IVAL bus <b>158</b>. A PCEND generation subunit <b>160</b> is included, coupled to scan end bit bus <b>152</b> and a PCEND bus <b>162</b>. Also coupled to PCEND bus <b>162</b> and to an NEND bus <b>166</b> is an NEND generation subunit <b>164</b>. NEND bus <b>166</b> is further coupled to a scan bus generation subunit <b>168</b>. Further coupled to scan bus generation subunit <b>168</b> is scan end bit bus <b>152</b>, IVAL bus <b>158</b>, and mask bus <b>98</b> from control unit <b>52</b>.</p><p>Generally speaking, first scan block <b>58</b> is configured to scan start byte information and end byte information associated with a plurality of contiguous instruction bytes. The start byte information is conveyed on scan start bit bus <b>150</b> and the end byte information is conveyed on scan end bit bus <b>152</b>. Scan start bit bus <b>150</b> and scan end bit bus <b>152</b> together form an input bus to first scan block <b>58</b>. First scan block <b>58</b> produces a set of scan values on scan bus <b>154</b> which are indicative of the boundaries of instructions within the plurality of contiguous instruction bytes. In one embodiment, start and end byte information is conveyed for eight contiguous instruction bytes. First scan block <b>58</b> scans the start byte information independently and in parallel with the end byte information in PCEND generation subunit <b>160</b>, NEND generation subunit <b>164</b>, and IVAL generation subunit <b>156</b>. The information so generated is combined in scan bus generation subunit <b>168</b>, producing a set of masks on scan bus <b>154</b>. A mask is a field of bits, each bit being associated with one instruction byte within the plurality of contiguous instruction bytes being scanned. If a particular bit of a mask is set, the associated byte is a portion of the instruction identified by that mask. If a particular bit of a mask is clear, the associated byte is not a portion of the instruction identified by that mask. Each mask identifies instruction bytes which form a valid instruction. In one embodiment, scan bus <b>154</b> conveys three eight-bit masks identifying the first three valid instructions found within the eight bytes associated with the start and end byte information conveyed to first scan block <b>58</b>. The masks produced on scan bus <b>154</b> are conveyed to instruction alignment unit <b>18</b>, for use in locating valid instruction bytes from a plurality of instructions associated with the start and end byte information processed by first scan block <b>58</b>.</p><p>As mentioned above, IVAL generation subunit <b>156</b> receives start byte information associated with a plurality of contiguous instruction bytes. IVAL generation subunit <b>156</b> generates an instruction valid value associated with each byte in the plurality of contiguous instruction bytes. Instruction valid values are values which identify bytes which may form a valid instruction. In one embodiment, the instruction valid values generated by IVAL generation subunit <b>156</b> are masks as described above. Each instruction valid value generated by IVAL generation subunit <b>156</b> identifies a potentially valid instruction ending at the associated byte within the contiguous instruction bytes being scanned. The potentially valid instruction begins at the byte associated with the first start bit encountered in the associated start byte information prior to the byte position of the associated byte. Furthermore, the start bit corresponding to the associated byte is included in determining the beginning of the potentially valid instruction. Since the end byte information is not available to IVAL generation subunit <b>156</b>, an instruction valid value is generated for each byte being scanned as if that byte were an end byte. Therefore, the instruction valid values identify potentially valid instructions. The correct instruction valid values may then be selected from this set of instruction valid values according to the end byte information, as will be described below.</p><p>PCEND generation subunit <b>160</b> and NEND generation subunit <b>164</b> are a pair of subunits which generate an instruction end count for each byte being scanned. The instruction end count for a particular byte indicates the number of instructions which end within the eight bytes being scanned but prior to the particular byte. This information, along with the end byte information, may be used to determine which of the instruction valid values generated from IVAL generation subunit <b>156</b> are the correct instruction valid values. According to one particular embodiment, the instruction end count indicates if there are zero, one, two or three end bytes prior to a particular byte.</p><p>In one embodiment, PCEND generation subunit <b>160</b> generates intermediate instruction end counts according to a set of scan regions within the plurality of contiguous instruction bytes being scanned. In one embodiment, four scan regions are used. The first scan region comprises the first byte of the contiguous instruction bytes being scanned. The second scan region includes the second through fourth bytes, while the third scan region includes the fifth through seventh bytes. Finally, the fourth scan region comprises the eighth byte being scanned. For a particular byte within the contiguous bytes being scanned, the associated intermediate instruction end count indicates the number of instructions which end prior to that particular byte but within the scan region that includes the particular byte. Additionally, an instruction which ends in the last byte of the scan region prior to the scan region that includes the particular byte is included in the associated intermediate instruction end count. By generating these intermediate instruction end counts, the logic gates embodying the function may be advantageously limited to a relatively small number of inputs while still utilizing a parallel scanning technique, as will be explained in more detail below. In one embodiment, the intermediate instruction end counts are decoded counts such that a bit set in one position of the count indicates zero prior end bytes; a bit set in another position of the count indicates one prior end byte; etc. These intermediate instruction end counts are conveyed on PCEND bus <b>162</b> to NEND generation subunit <b>164</b>.</p><p>NEND generation subunit <b>164</b> accepts the intermediate instruction end counts generated by PCEND generation subunit <b>160</b> and generates the instruction end counts mentioned above. A particular instruction end count is generated by shifting the instruction end count of the last byte of the previous scan region by the intermediate instruction end count associated with a particular byte of the current scan region. Since the intermediate instruction end count values and the instruction end count values are decoded, the shifting adds the intermediate instruction end count of each byte to the instruction end count of the last byte of the previous scan region. In this manner, the correct instruction end count for each byte may be generated. In one embodiment, the instruction end counts and intermediate instruction end counts convey a value between zero and two. Furthermore, a value may be conveyed indicative of three or more instruction ends. NEND generation subunit <b>164</b> conveys the instruction end counts to scan bus generation subunit <b>168</b> on NEND bus <b>166</b>.</p><p>Scan bus generation subunit <b>168</b> selects a plurality of scan bus values from the instruction valid values conveyed on IVAL bus <b>158</b>. The plurality of scan bus values are conveyed on scan bus <b>154</b>. In one embodiment, up to three scan bus values are selected corresponding to the first three valid instructions contained within the plurality of contiguous instruction bytes being scanned. A particular instruction valid value is selected by scan bus generation subunit <b>168</b> if the end byte information indicates that the associated byte is an end byte and the instruction end count associated with that byte is between zero and two. The first scan value conveys the instruction valid value associated with an instruction end count of zero. Therefore, the first scan value identifies a valid instruction associated with the first end byte within the plurality of contiguous instruction bytes being scanned (i.e. the first valid instruction within the plurality of contiguous instruction bytes). The second and third scan values similarly identify the second and third valid instructions within the plurality of contiguous instruction bytes being scanned, if that many valid instructions may be located.</p><p>At most three instruction valid values will be selected in this manner, according to the present embodiment. First scan block <b>58</b> is a parallel instruction scanning unit which (as will be shown below) may be implemented in relatively few cascaded levels of logic. Advantageously, such an instruction scanning unit identifies multiple valid instructions per clock cycle and may allow a short clock cycle design. Similar techniques may be used to identify any number of valid instructions per clock cycle.</p><p>The operation of first scan block <b>58</b> may be further illuminated through the use of an example. The example will be presented for the embodiment of first scan block <b>58</b> that scans eight contiguous instruction bytes and provides up to three scan bus values per clock cycle. Therefore, this embodiment generates eight instruction valid values on IVAL bus <b>158</b> (one for each of the eight instruction bytes). These buses will be labeled IVAL0, IVAL1, IVAL2, IVAL3, IVAL4, IVAL5, IVAL6, and IVAL7. Also, the four scan regions described above will be processed by PCEND generation subunit <b>160</b>. The values of the intermediate instruction end counts will be conveyed on PCEND0, PCEND1, PCEND2, PCEND3, PCEND4, PCEND5, PCEND6, and PCENC7. Each value includes three bits which indicate the number of end bytes prior to the current byte. If bit <b>0</b> is set, there are zero end bytes prior to the current byte. If bit <b>1</b> is set, there is one end byte prior to the current byte. If bit <b>2</b> is set, there are two end bytes prior to the current byte. If no bits are set, there are three or more end bytes prior to the current byte. The instruction end counts generated by NEND generation subunit <b>164</b> are conveyed on NEND0, NEND1, NEND2, NEND3, NEND4, NEND5, NEND6, and NEND7. Finally, the scan bus values are conveyed on SCAN0, SCAN1, and SCAN2. In each of the above assigned names, the number indicates the associated byte. Therefore, IVAL0, PCEND0, and NEND0 are associated with the first of the eight contiguous instruction bytes (i.e. byte <b>0</b>). Similarly, IVAL1, PCEND1, and NEND1 are associated with the second of the eight contiguous instruction bytes (i.e. byte <b>1</b>), etc. SCAN0 is the scan value indicating the first valid instruction within the eight contiguous instruction bytes. Similarly, SCAN1 is the scan value indicating the second valid instruction within the eight contiguous instruction bytes, etc.</p><p>For this example, the start byte and end byte information indicates the following values:</p><p><tables id=\"TABLE-US-00002\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"105PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"112PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Byte position</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01234567 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"112PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Start byte information:</entry><entry morerows=\"0\" valign=\"top\"> 10011110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">End byte information:</entry><entry morerows=\"0\" valign=\"top\">00111101 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>In this embodiment, the start byte information and end byte information comprises a bit for each byte. If the bit is set, the corresponding byte is a start (or end) byte. If the bit is clear, the corresponding byte is not a start (or an end) byte. Therefore, for this example the first valid instruction begins at byte <b>0</b> and ends at byte <b>2</b>. The second valid instruction begins and ends at byte <b>3</b> (therefore, the second valid instruction is a single byte). Similarly, the third valid instruction begins and ends at byte <b>4</b> and the fourth valid instruction begins and ends at byte <b>5</b>. Finally, the fifth valid instruction begins at byte <b>6</b> and ends at byte <b>7</b>. The correct scan bus values for this example would be:</p><p><tables id=\"TABLE-US-00003\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"70PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"147PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Byte position</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01234567 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"147PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAN0</entry><entry morerows=\"0\" valign=\"top\">11100000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAN1</entry><entry morerows=\"0\" valign=\"top\">00010000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAN2</entry><entry morerows=\"0\" valign=\"top\">00001000 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>When the aforementioned start and end byte values are conveyed to first scan block <b>58</b>, IVAL generation subunit <b>156</b> generates eight instruction valid values as described above. IVAL0 generates binary ones beginning at the occurrence of the first previous start byte to byte <b>0</b> (i.e. byte <b>0</b> itself) and ending in byte <b>0</b>. Bits to the left of the assumed end byte position are set to zero. IVAL1 generates binary ones beginning at the occurrence of the first previous start byte (again at byte <b>0</b>) and ending at byte <b>1</b>. IVAL4 generates binary ones beginning at the first previous start byte (now at byte <b>4</b>) and ending at byte <b>4</b>. A \u201cprevious start byte\u201d comprises a byte corresponding to a set start bit. The set start bit may be at the byte assumed to be the end byte, or the set start bit may correspond to a byte prior to the assumed end byte. A list of the generated instruction valid values is shown below.</p><p><tables id=\"TABLE-US-00004\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"70PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"147PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Mask bit positions</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01234567 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"147PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL0</entry><entry morerows=\"0\" valign=\"top\">10000000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL1</entry><entry morerows=\"0\" valign=\"top\">11000000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL2</entry><entry morerows=\"0\" valign=\"top\">11100000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL3</entry><entry morerows=\"0\" valign=\"top\">00010000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL4</entry><entry morerows=\"0\" valign=\"top\">00001000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL5</entry><entry morerows=\"0\" valign=\"top\">00000100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL6</entry><entry morerows=\"0\" valign=\"top\">00000010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL7</entry><entry morerows=\"0\" valign=\"top\">00000011 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>PCEND generation subunit <b>160</b> generates intermediate end counts according to the scan regions defined above. Therefore, PCEND0 contains a zero end count since no bytes precede PCEND0. PCEND3, however, contains a count of one since byte <b>2</b> is an end byte within the current scan region and no other end bits occur in the current scan region prior to byte <b>3</b>. The values for the intermediate instruction end counts are shown below for this example:</p><p><tables id=\"TABLE-US-00005\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"49PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Instruction count value</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">012 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"77PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND0</entry><entry morerows=\"0\" valign=\"top\">100</entry><entry morerows=\"0\" valign=\"top\">first scan region</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND1</entry><entry morerows=\"0\" valign=\"top\">100</entry><entry morerows=\"0\" valign=\"top\">second scan region</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND2</entry><entry morerows=\"0\" valign=\"top\">100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND3</entry><entry morerows=\"0\" valign=\"top\">010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND4</entry><entry morerows=\"0\" valign=\"top\">010</entry><entry morerows=\"0\" valign=\"top\">third scan region</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND5</entry><entry morerows=\"0\" valign=\"top\">001</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND6</entry><entry morerows=\"0\" valign=\"top\">000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND7</entry><entry morerows=\"0\" valign=\"top\">000</entry><entry morerows=\"0\" valign=\"top\">fourth scan region </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>NEND generation subunit <b>164</b> receives the intermediate instruction end counts and generates the instruction end counts. Since the counts for the first and second scan regions already contain information about each end byte prior to the associated position (the counts in the second scan region include the last and only byte of the first scan region), these counts are unchanged by NEND generation subunit <b>164</b>. The intermediate instruction counts in the third region (i.e. PCEND4, PCEND5, and PCEND6) provide shift amounts for the count in PCEND3. In this example, PCEND3 contains a count of one, PCEND4 a count of one, PCEND5 a count of two, and PCEND6 a count of three or more. Therefore, NEND4 conveys PCEND3 shifted by one (i.e. two), NEND5 conveys PCEND3 shifted by two (i.e. three or more), and NEND6 conveys PCEND3 shifted by three (i.e. three or more, three binary zeros upon NEND6). NEND7 conveys NEND6 shifted by three (the amount on PCEND7). This causes NEND7 to convey a value of 3 binary zeros, indicative of three or more end bits prior to byte <b>7</b>. The values for each instruction end count are shown below for this example:</p><p><tables id=\"TABLE-US-00006\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"70PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"147PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Instruction count value</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">012 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"147PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND0</entry><entry morerows=\"0\" valign=\"top\">100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND1</entry><entry morerows=\"0\" valign=\"top\">100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND2</entry><entry morerows=\"0\" valign=\"top\">100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND3</entry><entry morerows=\"0\" valign=\"top\">010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND4</entry><entry morerows=\"0\" valign=\"top\">001</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND5</entry><entry morerows=\"0\" valign=\"top\">000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND6</entry><entry morerows=\"0\" valign=\"top\">000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND7</entry><entry morerows=\"0\" valign=\"top\">000 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Scan bus generation subunit <b>168</b> receives the NEND and IVAL values shown above as its instruction end counts and instruction valid values along with the original end byte information, as noted above. Scan bus generation subunit <b>168</b> then generates its three scan values from the received values. Since byte two is an end byte and its associated instruction end count (NEND2) is zero, the instruction valid value associated with byte two (IVAL2) is selected as SCAN0. Byte three is also an end byte, and its associated instruction end count (NEND3) is one. Therefore, the instruction valid value associated with byte three (IVAL3) is selected as SCAN1. Similarly, IVAL4 is selected as SCAN2. Therefore, the final scan values are shown below and equal the expected results for the example:</p><p><tables id=\"TABLE-US-00007\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"77PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"140PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"> Byte position</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01234567 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"49PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"140PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAN0</entry><entry morerows=\"0\" valign=\"top\">11100000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAN1</entry><entry morerows=\"0\" valign=\"top\">00010000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAN2</entry><entry morerows=\"0\" valign=\"top\">00001000 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The preceding example contained a full complement of three valid instructions. The following example contains two valid instructions, and will be presented in tabular format below.</p><p><tables id=\"TABLE-US-00008\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"105PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"112PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"> Byte position</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01234567 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"70PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"112PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Start byte information:</entry><entry morerows=\"0\" valign=\"top\">10010000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">End byte information:</entry><entry morerows=\"0\" valign=\"top\">00100010 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Therefore, the expected scan bus results would be:</p><p><tables id=\"TABLE-US-00009\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"77PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"140PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Byte position</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01234567 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"49PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"140PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAN0</entry><entry morerows=\"0\" valign=\"top\">11100000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAN1</entry><entry morerows=\"0\" valign=\"top\">00011110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAN2</entry><entry morerows=\"0\" valign=\"top\">00000000 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The instruction valid values generated by IVAL generation subunit <b>156</b> with this example of end byte information are:</p><p><tables id=\"TABLE-US-00010\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"70PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"147PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Mask bit positions</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01234567 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"147PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL0</entry><entry morerows=\"0\" valign=\"top\">10000000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL1</entry><entry morerows=\"0\" valign=\"top\">11000000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL2</entry><entry morerows=\"0\" valign=\"top\">11100000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL3</entry><entry morerows=\"0\" valign=\"top\">00010000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL4</entry><entry morerows=\"0\" valign=\"top\">00011000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL5</entry><entry morerows=\"0\" valign=\"top\">00011110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL6</entry><entry morerows=\"0\" valign=\"top\">00011110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IVAL7</entry><entry morerows=\"0\" valign=\"top\">00011111 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The intermediate instruction end counts generated by PCEND generation subunit <b>160</b> according to this example's end byte information are:</p><p><tables id=\"TABLE-US-00011\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"49PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Instruction count value</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">012 </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"77PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"> PCEND0</entry><entry morerows=\"0\" valign=\"top\">100</entry><entry morerows=\"0\" valign=\"top\">first scan region</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND1</entry><entry morerows=\"0\" valign=\"top\">100</entry><entry morerows=\"0\" valign=\"top\">second scan region</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND2</entry><entry morerows=\"0\" valign=\"top\">100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND3</entry><entry morerows=\"0\" valign=\"top\">010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND4</entry><entry morerows=\"0\" valign=\"top\">100</entry><entry morerows=\"0\" valign=\"top\">third scan region</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND5</entry><entry morerows=\"0\" valign=\"top\">100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND6</entry><entry morerows=\"0\" valign=\"top\">100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCEND7</entry><entry morerows=\"0\" valign=\"top\">010</entry><entry morerows=\"0\" valign=\"top\">fourth scan region </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>The instruction end counts generated by NEND generation subunit <b>164</b> according to this examples PCEND values would then be:</p><p><tables id=\"TABLE-US-00012\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"70PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"147PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Instruction count value</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">012</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"42PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"147PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND0</entry><entry morerows=\"0\" valign=\"top\">100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND1</entry><entry morerows=\"0\" valign=\"top\">100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND2</entry><entry morerows=\"0\" valign=\"top\">100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND3</entry><entry morerows=\"0\" valign=\"top\">010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND4</entry><entry morerows=\"0\" valign=\"top\">010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND5</entry><entry morerows=\"0\" valign=\"top\">010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND6</entry><entry morerows=\"0\" valign=\"top\">010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEND7</entry><entry morerows=\"0\" valign=\"top\">001</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Therefore, since byte <b>2</b> is an end byte and NEND2 indicates zero previous end bytes, SCAN0 is selected to be IVAL2. Byte <b>6</b> is an end byte and NEND6 indicates one previous end byte, so SCAN1 is selected to be IVAL6. There are no other start bits, so SCAN2 is selected to be zero.</p><p><tables id=\"TABLE-US-00013\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"2\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"77PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"140PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Byte position</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">01234567</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"49PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"140PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAN0</entry><entry morerows=\"0\" valign=\"top\">11100000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAN1</entry><entry morerows=\"0\" valign=\"top\">00011110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAN2</entry><entry morerows=\"0\" valign=\"top\">00000000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Turning next to FIGS. 5 through 8, exemplary logic diagrams of portions of the subunits shown in FIG. 4 are shown. FIG. 5 shows an exemplary logic diagram of a portion of IVAL generation subunit <b>156</b>. Exemplary logic circuits for the generation of IVAL5 are shown. IVAL5 is a portion of IVAL bus <b>158</b> conveying the instruction valid value associated with the sixth of the eight contiguous instruction bytes. Other logic circuits (not shown) generate the instruction valid values associated with the other instruction bytes. The instruction valid values for these bytes are conveyed on IVAL0 through IVAL4, IVAL6, and IVAL7. The values conveyed on IVAL0 through IVAL7 form IVAL bus <b>158</b>, as shown in FIG. <b>5</b>.</p><p>Scan start bit bus <b>150</b> is shown as eight conductors <b>150</b>A-<b>150</b>H in FIG. 5, indicative of the eight contiguous instruction bytes scanned by this embodiment of first scan block <b>58</b>. Conductor <b>150</b>A conveys the start bit for the first of the eight contiguous instruction bytes (referred to as byte <b>0</b>), conductor <b>150</b>B conveys the start bit for the second of the eight contiguous instruction bytes (referred to as byte <b>1</b>), etc. An examination of the exemplary circuits shows that a particular bit for an instruction valid value is generated as the logical NOR of the start bits between the byte subsequent to the byte associated with the particular bit and the byte assumed to be the end bit, inclusive. Therefore, the bit five of IVAL5 is a constant one (since there are no start bits to examine). Furthermore, the bit <b>4</b> of IVAL5 is the inverted start bit for byte <b>5</b> (i.e. the logical NOR of a single bit is an inversion). Bit <b>3</b> of IVAL5 is the NOR of the start bits for bytes <b>4</b> and <b>5</b>, etc.</p><p>Inverter <b>180</b> provides bit <b>4</b> of IVAL5, and NOR gate <b>182</b> provides the bit <b>3</b> of IVAL5. The NOR function for the bit <b>2</b> of IVAL5 is provided by NOR gate <b>184</b>, while NOR gate <b>184</b>, inverter <b>186</b>, and AND gate <b>188</b> provide the NOR function for the bit <b>1</b> of IVAL5. Similarly, bit <b>0</b> of IVAL5 is generated from NOR gate <b>184</b>, NOR gate <b>190</b>, and AND gate <b>192</b>. Note that bits <b>6</b> and <b>7</b>, constant zeros, may be omitted from IVAL5.</p><p>Turning now to FIG. 6, exemplary logic circuits forming a portion of PCEND generation subunit <b>160</b> are shown. PCEND generation subunit <b>160</b> receives scan end bit bus <b>152</b>. Scan end bit bus <b>152</b> is shown in FIG. 6 as eight separate conductors which convey the eight end bits associated with the region of contiguous instruction bytes being scanned. Conductor <b>152</b>A conveys the end bit associated with the first of the contiguous bytes (referred to as byte <b>0</b>), conductor <b>152</b>B conveys the end bit associated with the second of the contiguous bytes (referred to as byte <b>1</b>), etc.</p><p>FIG. 6 shows exemplary logic circuits for generating PCEND3. PCEND3 is the intermediate instruction end count for byte <b>3</b> (i.e. the fourth byte) of the eight contiguous bytes. Other logic circuits (not shown) generate intermediate instruction end counts for other bytes within the contiguous instruction bytes scanned by first scan block <b>58</b>. For the following discussion with respect to FIG. 6, the term \u201cprevious-end bit\u201d refers to an end bit within the scan region associated with a particular intermediate instruction end count and to the end bit associated with the last byte of the previous scan region.</p><p>In this embodiment, each intermediate instruction end count and each instruction end count are decoded values. The first bit, when set, indicates that zero end bytes exist prior to the current byte. The second bit, when set, indicates that one end byte exists prior to the current byte, etc. Therefore, for intermediate end count generation, the first bit is set if none of the previous end bits are set. This is a NOR function of the associated previous end bits, and is shown as NOR gate <b>200</b>.</p><p>The second bit of an intermediate instruction end count indicates one previous end bit is set. Therefore, an AND/OR network may provide the value where each of the input terminals of the AND gate are inverted except for one. In this manner, if one and only one previous end bit is set, then the resulting intermediate instruction end count bit will be set. This function is provided by AND gate <b>202</b>, AND gate <b>204</b>, AND gate <b>206</b>, and OR gate <b>208</b>.</p><p>Two previous end bits being set is indicated by setting bit two of the intermediate instruction end counts. An AND/OR network similar to the network for bit <b>1</b> may provide the value, except that two of the input terminals of the AND gates are not inverted. In this manner, if any two previous end bits are set but no more than two are set, then the resulting intermediate instruction end count bit will be set. AND gate <b>210</b>, AND gate <b>212</b>, AND gate <b>214</b>, and OR gate <b>216</b> provide this function for the embodiment shown in FIG. 6 for PCEND3.</p><p>Turning now to FIG. 7, exemplary logic circuits for a portion of an embodiment of NEND generation subunit <b>164</b> are shown. The generation of the instruction end count associated with byte four (i.e. the fifth byte) of the plurality of contiguous instruction bytes scanned by first scan block <b>58</b> is depicted (referred to as NEND4). As noted above, the instruction end counts for the first two scan regions are unmodified from the intermediate instruction end counts. These unmodified counts are shown in FIG. 7 as buses <b>220</b>, <b>222</b>, <b>224</b>, and <b>226</b>, respectively. As noted above, NEND4 is PCEND3 shifted by the value generated on PCEND4. Multiplexor <b>228</b> is configured to provide this shifting. If the first bit of PCEND4 is set, indicating zero previous end bits, then port 0 of multiplexor <b>228</b> will be selected and NEND4 will be equal to PCEND3. If, however, the second bit of PCEND4 is set indicating one previous end bit, then port 1 of multiplexor <b>228</b> will be selected and NEND4 will be equal to PCEND3 shifted by one value. Port 2 of multiplexor <b>228</b> are operated similarly with respect to the third bit of PCEND4. Circuits for generating NEND5, NEND6, and NEND7 are configured similarly. It is noted that NEND7 selects a shifting of NEND6, not PCEND6.</p><p>Turning next to FIG. 8, exemplary logic circuits for a portion of one embodiment of scan bus generation subunit <b>168</b> are depicted. In particular, logic circuits suitable for generating the first scan bus value (SCAN0) are shown. Multiplexor <b>240</b> is coupled to each instruction valid value generated by IVAL generation subunit <b>156</b>. The corresponding end bits are received on scan end bit bus <b>152</b>, and the corresponding instruction end counts are received on NEND bus <b>166</b>.</p><p>As noted above, an instruction valid value is selected as SCAN0 if the corresponding end bit on scan end bit bus <b>152</b> is set and the corresponding instruction end count indicates that there are no previous instruction ends found within the region of contiguous instruction bytes scanned by first scan block <b>58</b>. Therefore, an AND function of the corresponding end bit and the first bit of the corresponding instruction end count provides each select signal for multiplexor <b>460</b>. Select generation block <b>242</b> provides this ANDing function. Similar selection generation blocks may be used to select the instruction valid value for the second scan bus value (SCAN1) and the third scan bus value (SCAN2).</p><p>SCAN0, SCAN1, and SCAN2 are conveyed on scan bus <b>154</b>.</p><p>Because only a portion of the region of instruction bytes being scanned by first scan block <b>58</b> may be being dispatched (based upon the start pointer and end pointer provided), select generation block further receives the mask upon mask bus <b>98</b>. A particular instruction valid value is selected by select generation block <b>242</b> if the corresponding end bit and end count are as listed above and the corresponding mask bit from mask bus <b>98</b> is set. It is noted that the end bits received upon scan end bits bus <b>152</b> are masked with the mask from mask bus <b>98</b> prior to performing instruction end count generation as well.</p><p>It is noted that FIGS. 5-8 have used a standard symbol for combining bus conductors into a single bus or for splitting bus conductors from a single bus. For example, horizontal line <b>244</b> of FIG. 8 is an indication that eight IVAL buses (IVAL0-IVAL7) form IVAL bus <b>158</b>. These symbols have been included to keep the drawings uncluttered to facilitate understanding. These symbols should not be construed to indicate any physical device. As will be appreciated by those skilled in the art, a bus is simply a collection of conductors which are logically grouped together to form a value.</p><p>It is further noted that the above discussion described an embodiment of first scan block <b>58</b> which scans eight contiguous instruction bytes for up to three instructions. Other embodiments may vary the number of contiguous instruction bytes as well as the maximum number of instructions scanned for. FIGS. 5-8 are also exemplary embodiments of first scan block <b>58</b>. Many other embodiments are possible and specifically contemplated. Still further, bytes within the set of instruction bytes received by instruction scanning unit <b>50</b> have been described as being ordered via such terms as \u201cprior to\u201d, \u201cbefore\u201d, \u201cfirst\u201d, \u201csecond\u201d, etc. A byte is prior to another byte if it is stored in a memory location of main memory which is numerically smaller than the other byte. The terms before, first, second, etc. should be similarly construed.</p><p>Turning now to FIG. 9, a block diagram of one embodiment of MROM instruction scan unit <b>56</b> is shown. MROM instruction scan unit <b>56</b> receives start bits <b>82</b> upon a start bits bus <b>260</b>, functional bits <b>80</b> upon a functional bits bus <b>262</b>, and end bits <b>84</b> upon an end bits bus <b>264</b>. Start bits bus <b>260</b>, functional bits bus <b>262</b>, and end bits bus <b>264</b> are configured to convey the start, functional, and end bits corresponding to the set of bytes represented in register <b>62</b>. MROM instruction scan unit <b>56</b> additionally receives the masks from control unit <b>52</b> upon mask buses <b>98</b> and <b>100</b>. MROM instruction scan unit <b>56</b> provides a start pointer of an MROM instruction upon MROM start pointer bus <b>104</b>, an opcode pointer of an MROM instruction upon MROM opcode pointer bus <b>102</b>, and a set of valid bits upon MROM valid bus <b>106</b>. In the embodiment shown, the set of valid bits includes an opcode pointer valid bit <b>266</b>, a start pointer valid bit <b>268</b>, and end valid bit <b>270</b>. Still further, MROM instruction scan unit <b>56</b> provides a stall signal upon a stall line <b>272</b> to control unit <b>52</b>. The stall signal is asserted if MROM instructions reside within the set of instruction bytes which have yet to be dispatched to MROM unit <b>34</b>.</p><p>In the embodiment of FIG. 9, MROM instruction scan unit <b>56</b> includes a logical AND block <b>274</b>, a first instruction detection block <b>276</b>, a second instruction detection block <b>278</b>, an MROM mask storage <b>280</b>, and a mask control block <b>282</b>. Logical AND block <b>274</b> creates an MROM mask upon receipt of a set of functional bits and a set of end bits from register <b>62</b>. Logical AND block <b>274</b> ANDs each of the functional bits with the corresponding end bit and the corresponding bit from the masks provided upon mask buses <b>98</b> and <b>100</b>. The MROM mask thus created therefore includes a binary one digit for a byte position if the end bit is set for that byte position, the functional bit is set for that byte position, and the mask bit from control unit <b>52</b> is set for that byte position. Since the functional bit being set at the end byte of the instruction indicates an MROM instruction, a binary one digit indicates that an MROM instruction ends at the corresponding byte position. Including the mask bits from control unit <b>52</b> in the logical ANDing excludes MROM instructions which are not within the bytes being dispatched from the set of bytes, such that MROM instruction scan unit <b>56</b> detects only those MROM instructions actually to be dispatched.</p><p>The MROM mask thus created is provided to first instruction detection block <b>276</b> and second instruction detection block <b>278</b> (which are coupled to logical AND block <b>274</b> to receive the MROM mask). First instruction detection block <b>276</b> scans the MROM mask to determine the position of the first MROM instruction (in program order) within the set of instruction bytes. Upon locating the first MROM instruction, if any, first instruction detection block <b>276</b> forms a start pointer from the start bits received upon start bits bus <b>260</b>. In particular, the start pointer indicates the nearest prior byte position to the end of the MROM instruction for which the start bit is set (i.e. the start of the MROM instruction). Additionally, by examining the pattern of functional bits prior to the end byte of the detected MROM instruction, the opcode byte can be determined (i.e. the byte prior to the end of the MROM instruction at which a transition from a binary zero to a binary one in the functional bits occurs, or the start byte of the MROM instruction if the functional bit at the start byte is set). The opcode pointer is thereby formed and conveyed upon MROM opcode pointer bus <b>102</b>. Finally, first instruction detection block <b>276</b> determines the appropriate valid bits for the MROM instruction.</p><p>The valid bits are determined based upon whether or not the entire MROM instruction is contained within the set of bytes being scanned. If the entire MROM instruction is contained within the set, then the start pointer, the opcode pointer, and the end of the instruction are located concurrently and all three of the valid bits are set (e.g. the opcode pointer valid bit <b>266</b>, the start pointer valid bit <b>268</b>, and the end valid bit <b>270</b> are all set). However, if a portion of the MROM instruction lies within one set of instruction bytes and the remaining portion within another set of instruction bytes (a \u201csplit line\u201d instruction), then the MROM instruction is dispatched during two different clock cycles to MROM unit <b>34</b>. The two clock cycles in which the split line instruction is dispatched to MROM unit <b>34</b> may be separated by one or more clock cycles if scan blocks <b>58</b> and <b>60</b> require more clock cycles to dispatch instructions from the set of instruction bytes containing the first portion of the MROM instruction than MROM instruction scan unit <b>56</b> requires to dispatch the MROM instructions within the set of instruction bytes. During the first clock cycle, at least the start pointer is conveyed. The opcode pointer may or may not be conveyed with the start pointer, depending upon which set of instruction bytes the opcode is stored in. The end of the MROM instruction is dispatched in the second clock cycle. Valid bits <b>266</b>-<b>270</b> serve to indicate to MROM unit <b>34</b> which of the MROM information is conveyed during each clock cycle.</p><p>According to one embodiment, the functional bits include an extra bit not associated with any byte position within the set of instruction bytes. The extra bit indicates, when set, that an instruction beginning within the set of instruction bytes and ending in the subsequent set of instruction bytes is an MROM instruction. First instruction detection unit <b>276</b> uses the extra bit to determine if the split line instruction is MROM or fast path. Detection of the start byte and the opcode byte are performed in a manner similar to non-split line instructions. Since each value associated with a particular MROM instruction has a dedicated valid bit, the split line instruction may be dispatched in two portions as described.</p><p>In parallel with first instruction detection block <b>276</b>, second instruction detection block <b>278</b> detects a second MROM instruction within the set of instruction bytes from the MROM mask. If a second MROM instruction is detected (including a split-line MROM instruction), then MROM instruction scan unit <b>56</b> requires at least one additional clock cycle to dispatch the second MROM instruction. Second instruction detection block <b>276</b> asserts the stall signal upon stall line <b>272</b> to control unit <b>52</b>, thereby informing control unit <b>52</b> that MROM instructions remain to be dispatched to MROM unit <b>34</b>. It is noted that second instruction detection block <b>278</b> may receive the full signal upon full line <b>284</b> (described below), to thereby assert the stall signal during clock cycles in which MROM unit <b>34</b> cannot accept instructions and the modified MROM mask indicates that at least one MROM instruction remains to be dispatched. Alternatively, control unit <b>52</b> may receive the full signal directly.</p><p>Mask control block <b>282</b> is coupled to receive the MROM mask from logical AND block <b>274</b> as well. Mask control block <b>282</b> resets the first binary one within the MROM mask if a full signal upon a full line <b>284</b> is deasserted during the clock cycle. The full signal indicates that MROM unit <b>34</b> is buffering the maximum number of MROM instructions for which it is designed, and cannot accept additional MROM instructions until at least one MROM instruction is dispatched from MROM unit <b>34</b> to decode units <b>20</b>. The modified mask is stored into MROM mask storage <b>280</b>, which is coupled to first instruction detection block <b>276</b> and second instruction detection block <b>278</b>. First instruction block <b>276</b> and second instruction block <b>278</b> process the modified MROM mask until all MROM instructions indicated by the modified MROM mask have been dispatched to MROM unit <b>34</b>. Mask control unit <b>282</b> asserts a new mask signal upon a new mask line <b>286</b> to first instruction detection block <b>276</b> and second instruction detection block <b>278</b>, informing the blocks that they should accept a new MROM mask from logical AND block <b>274</b> during the clock cycle. If the new mask signal is deasserted, then the modified MROM mask from MROM mask storage <b>280</b> is analyzed by first instruction detection block <b>276</b> and second instruction detection block <b>278</b>.</p><p>Turning next to FIG. 10, a flow chart <b>300</b> depicting operation of one embodiment of invalid instruction scan unit <b>54</b> is shown. Flow chart <b>300</b> includes checks selected to detect any invalid predecode data, thereby verifying that the scan values provided by scan blocks <b>58</b> and <b>60</b> and the MROM instructions dispatched by MROM instruction scan unit <b>56</b> are correct. The start bits and end bits scanned by invalid instruction scanning unit <b>54</b> are masked by the masks generated by control unit <b>52</b> and provided upon mask buses <b>98</b> and <b>100</b>.</p><p>As indicated by step <b>302</b>, invalid instruction scan unit <b>54</b> checks the start bit corresponding to the byte indicated by the start pointer. If the start bit is clear, then a first case of invalid predecode data is detected. Invalid instruction scan unit <b>54</b> asserts a signal upon invalid bus <b>110</b> indicating that the start bit at the start pointer is clear, and provides the start pointer upon invalid pointer bus <b>108</b> (step <b>304</b>). Alternatively, if the start bit corresponding to the byte indicated by the start pointer is set, then the predecode data is valid with respect to this check.</p><p>For each end bit within the predecode data which is set, invalid instruction scan unit <b>54</b> checks the start bit corresponding to the byte immediately subsequent to that end byte (as indicated by the end bit) to ensure that the start bit is set (step <b>306</b>). If the start bit is not set, then a second case of invalid predecode data is detected. Invalid instruction scan unit <b>54</b> performs step <b>304</b>, providing a signal upon invalid bus <b>110</b> indicating the error detected and providing a pointer to the byte for which the start bit should be set upon invalid pointer bus <b>108</b>. Invalid instruction scan unit <b>54</b> may store an indication of the end bit for the last byte within the set of bytes in order to detect a case where the last byte of the set of instruction bytes is the end of an instruction (and therefore the first byte of the next set of instruction bytes scanned should be a start byte). For this case, the invalid instruction pointer would indicate the first byte of the next set of instruction bytes if that byte is not indicated to be a start byte.</p><p>Invalid instruction scan unit <b>54</b> additionally detects a second start bit being encountered prior to detection of the end bit corresponding to a first start bit (step <b>308</b>). Such a check may be performed by creating instruction valid values based on the start bits (similar to IVAL bus <b>158</b>), and combining instruction valid values corresponding to each end bit within the line. If the value thus formed does not include a binary one bit for each byte within the set of bytes being dispatched (excluding those bytes masked off by the masks provided upon mask buses <b>98</b> and <b>100</b>), then a third case of invalid predecode data is detected. The invalid instruction pointer is set to indicate the first start bit for which the second start bit is detected prior to the end bit, and a signal is asserted upon invalid bus <b>110</b>. Invalid instruction scan unit <b>54</b> stores an indication of a start bit being located within a set of bytes without a detection of a corresponding end bit (i.e. a split line instruction), in order to detect the second start bit before an end bit in the subsequent set of instruction bytes.</p><p>Finally, invalid instruction scan unit <b>54</b> detects a start bit for which an end byte is not located within the subsequent 15 bytes (step <b>310</b>). Such an instruction is longer than that allowed by the x86 microprocessor architecture. Therefore, either the predecode data is invalid or the instruction is an invalid coding. The invalid instruction pointer is set to the start bit, and a signal is asserted upon invalid bus <b>110</b> indicating detection of the instruction which is too long.</p><p>Turning now to FIG. 11, a computer system <b>400</b> including microprocessor <b>10</b> is shown. Computer system <b>400</b> further includes a bus bridge <b>402</b>, a main memory <b>404</b>, and a plurality of input/output (I/O) devices <b>406</b>A-<b>406</b>N. Plurality of I/O devices <b>406</b>A-<b>406</b>N will be collectively referred to as I/O devices <b>406</b>. Microprocessor <b>10</b>, bus bridge <b>402</b>, and main memory <b>404</b> are coupled to a system bus <b>408</b>. I/O devices <b>406</b> are coupled to an I/O bus <b>410</b> for communication with bus bridge <b>402</b>.</p><p>Bus bridge <b>402</b> is provided to assist in communications between I/O devices <b>406</b> and devices coupled to system bus <b>408</b>. I/O devices <b>406</b> typically require longer bus clock cycles than microprocessor <b>10</b> and other devices coupled to system bus <b>408</b>. Therefore, bus bridge <b>402</b> provides a buffer between system bus <b>408</b> and input/output bus <b>410</b>. Additionally, bus bridge <b>402</b> translates transactions from one bus protocol to another. In one embodiment, input/output bus <b>410</b> is an Enhanced Industry Standard Architecture (EISA) bus and bus bridge <b>402</b> translates from the system bus protocol to the EISA bus protocol. In another embodiment, input/output bus <b>410</b> is a Peripheral Component Interconnect (PCI) bus and bus bridge <b>402</b> translates from the system bus protocol to the PCI bus protocol. It is noted that many variations of system bus protocols exist. Microprocessor <b>10</b> may employ any suitable system bus protocol.</p><p>I/O devices <b>406</b> provide an interface between computer system <b>400</b> and other devices external to the computer system. Exemplary I/O devices include a modem, a serial or parallel port, a sound card, etc. I/O devices <b>406</b> may also be referred to as peripheral devices. Main memory <b>404</b> stores data and instructions for use by microprocessor <b>10</b>. In one embodiment, main memory <b>404</b> includes at least one Dynamic Random Access Memory (DRAM) and a DRAM memory controller.</p><p>It is noted that although computer system <b>400</b> as shown in FIG. 11 includes one bus bridge <b>402</b>, other embodiments of computer system <b>400</b> may include multiple bus bridges <b>402</b> for translating to multiple dissimilar or similar I/O bus protocols. Still further, a cache memory for enhancing the performance of computer system <b>400</b> by storing instructions and data referenced by microprocessor <b>10</b> in a faster memory storage may be included. The cache memory may be inserted between microprocessor <b>10</b> and system bus <b>408</b>, or may reside on system bus <b>408</b> in a \u201clookaside\u201d configuration.</p><p>It is still further noted that the present discussion may refer to the assertion of various signals. As used herein, a signal is \u201casserted\u201d if it conveys a value indicative of a particular condition. Conversely, a signal is \u201cdeasserted\u201d if it conveys a value indicative of a lack of a particular condition. A signal may be defined to be asserted when it conveys a logical zero value or, conversely, when it conveys a logical one value. Additionally, various values have been described as being discarded in the above discussion. A value may be discarded in a number of manners, but generally involves modifying the value such that it is ignored by logic circuitry which receives the value. For example, if the value comprises a bit, the logic state of the value may be inverted to discard the value. If the value is an n-bit value, one of the n-bit encodings may indicate that the value is invalid. Setting the value to the invalid encoding causes the value to be discarded. Additionally, an n-bit value may include a valid bit indicative, when set, that the n-bit value is valid. Resetting the valid bit may comprise discarding the value. Other methods of discarding a value may be used as well.</p><p>Table 1 below indicates fast path, double dispatch, and MROM instructions for one embodiment of microprocessor <b>10</b> employing the x86 instruction set:</p><p><tables id=\"TABLE-US-00014\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE 1</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">x86 Fast Path, Double Dispatch, and MROM Instructions</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"105PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">X86 Instruction</entry><entry morerows=\"0\" valign=\"top\">Instruction Category</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">AAA</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">AAD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">AAM</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">AAS</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ADC</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ADD</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">AND</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ARPL</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BOUND</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BSF</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BSR</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BSWAP</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BT</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTC</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTR</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">BTS</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CALL</entry><entry morerows=\"0\" valign=\"top\">fast path/double dispatch</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CBW</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CWDE</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CLC</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CLD</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CLI</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CLTS</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMC</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMP</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMPS</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMPSB</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMPSW</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMPSD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMPXCHG</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CMPXCHG8B</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CPUID</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CWD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CWQ</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DDA</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DAS</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DEC</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">DIV</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ENTER</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">HLT</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IDIV</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IMUL</entry><entry morerows=\"0\" valign=\"top\">double dispatch</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IN</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INC</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INS</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSB</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSW</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INSD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INT</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INTO</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INVD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">INVLPG</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IRET</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IRETD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Jcc</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">JCXZ</entry><entry morerows=\"0\" valign=\"top\">double dispatch</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">JECXZ</entry><entry morerows=\"0\" valign=\"top\">double dispatch</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">JMP</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LAHF</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LAR</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LDS</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LES</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LFS</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LGS</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSS</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LEA</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LEAVE</entry><entry morerows=\"0\" valign=\"top\">double dispatch</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LGDT</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LIDT</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LLDT</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LMSW</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LODS</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LODSB</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LODSW</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LODSD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LOOP</entry><entry morerows=\"0\" valign=\"top\">double dispatch</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LOOPcond</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LSL</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">LTR</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOV</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVCC</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOV.CR</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOV.DR</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVS</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVSB</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVSW</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVSD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVSX</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MOVZX</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">MUL</entry><entry morerows=\"0\" valign=\"top\">double dispatch</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NEG</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NOP</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">NOT</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OR</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OUT</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OUTS</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OUTSB</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OUTSW</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">OUTSD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POP</entry><entry morerows=\"0\" valign=\"top\">double dispatch</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POPA</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POPAD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POPF</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">POPFD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PUSH</entry><entry morerows=\"0\" valign=\"top\">fast path/double dispatch</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PUSHA</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PUSHAD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PUSHF</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PUSHFD</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCL</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RCR</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ROL</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">ROR</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RDMSR</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">REP</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">REPE</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">REPZ</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">REPNE</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">REPNZ</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RET</entry><entry morerows=\"0\" valign=\"top\">double dispatch</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">RSM</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SAHF</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SAL</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SAR</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHL</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHR</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SBB</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCAS</entry><entry morerows=\"0\" valign=\"top\">double dispatch</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCASB</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCASW</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SCASD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SETcc</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SGDT</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SIDT</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHLD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SHRD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SLDT</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SMSW</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STC</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STD</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STI</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STOS</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STOSB</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STOSW</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STOSD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">STR</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">SUB</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">TEST</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">VERR</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">VERW</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WBINVD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">WRMSR</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">XADD</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">XCHG</entry><entry morerows=\"0\" valign=\"top\">MROM</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">XLAT</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">XLATB</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">XOR</entry><entry morerows=\"0\" valign=\"top\">fast path</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"left\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" valign=\"top\">Note: </entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"left\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" valign=\"top\">Instructions including an SIB byte are also considered double dispatch instructions. </entry></row></tbody></tgroup></table></tables></p><p>In accordance with the above disclosure, a parallel and scaleable instruction scanning unit has been described. The instruction scanning unit scans predecode data from multiple regions of an instruction cache line in parallel, thereby locating multiple instruction concurrently for dispatch. In parallel with scanning for instructions, the predecode data is scanned for validity and for MROM instructions for dispatch to an MROM unit.</p><p>Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Rammohan", "last_name": "Narayan", "name": ""}, {"first_name": "Shane A.", "last_name": "Southard", "name": ""}, {"first_name": "Thang M.", "last_name": "Tran", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}], "ipc_classes": [{"primary": true, "label": "G06F   9/30"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/38        20060101A I20051008RMEP"}, {"label": "G06F   9/28        20060101A I20051008RMEP"}, {"label": "G06F   9/318       20060101A I20051008RMEP"}, {"label": "G06F   9/30        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712204"}, {"primary": false, "label": "712E09029"}, {"primary": false, "label": "712E09037"}, {"primary": false, "label": "712E09008"}, {"primary": false, "label": "712E09062"}], "ecla_classes": [{"label": "G06F   9/38C2"}, {"label": "G06F   9/30U"}, {"label": "G06F   9/38B9"}, {"label": "G06F   9/30T2A"}, {"label": "G06F   9/30U2"}, {"label": "G06F   9/28"}, {"label": "G06F   9/38P"}], "cpc_classes": [{"label": "G06F   9/3867"}, {"label": "G06F   9/30152"}, {"label": "G06F   9/3017"}, {"label": "G06F   9/30152"}, {"label": "G06F   9/3816"}, {"label": "G06F   9/3816"}, {"label": "G06F   9/382"}, {"label": "G06F   9/3867"}, {"label": "G06F   9/382"}, {"label": "G06F   9/28"}, {"label": "G06F   9/28"}, {"label": "G06F   9/3017"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1997-03-10", "application_date": "1999-06-01", "family_members": [{"ucid": "US-5968163-A", "titles": [{"lang": "EN", "text": "Microcode scan unit for scanning microcode instructions using predecode data"}]}, {"ucid": "US-6202142-B1", "titles": [{"lang": "EN", "text": "Microcode scan unit for scanning microcode instructions using predecode data"}]}]}