{"patent_number": "US-5640534-A", "publication_id": 71477966, "family_id": 23241808, "publication_date": "1997-06-17", "titles": [{"lang": "EN", "text": "Method and system for concurrent access in a data cache array utilizing multiple match line selection paths"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA10584599\" source=\"national office\"><p>An interleaved data cache array which is divided into two subarrays is provided for utilization within a data processing system. Each subarray includes a plurality of cache lines wherein each cache line includes a selected block of data, a parity field, a content addressable field containing a portion of an effective address for the selected block of data, a second content addressable field contains a portion of the real address for the selected block of data and a data status field. A separate effective address port and real address port permit parallel access to the cache without conflict in separate subarrays and a subarray arbitration logic circuit is provided for attempted simultaneous access of a single subarray by both the effective address port and the real address port. Each access port provides reference lines into either the first content addressable field or the second content addressable field, and a match line associated with each content addressable field is then precharged and discharged in response to a failure of the content of an associated content addressable field to match the desired data. A normal word line is provided and activated by either the effective address match line or the real address match line through the subarray arbitration circuit so that only one match line is allowed to drive the normal word line concurrently. In the event of a SNOOP access, the real address match line may also be utilized to activate a separate SNOOP word line. The separate SNOOP word line and the normal word line are both coupled to dual ported bits within the data status field, permitting concurrent access of those bits during normal load/cache operations which utilize the effective address match line.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA37649031\"><p>An interleaved data cache array which is divided into two subarrays is provided for utilization within a data processing system. Each subarray includes a plurality of cache lines wherein each cache line includes a selected block of data, a parity field, a content addressable field containing a portion of an effective address for the selected block of data, a second content addressable field contains a portion of the real address for the selected block of data and a data status field. A separate effective address port and real address port permit parallel access to the cache without conflict in separate subarrays and a subarray arbitration logic circuit is provided for attempted simultaneous access of a single subarray by both the effective address port and the real address port. Each access port provides reference lines into either the first content addressable field or the second content addressable field, and a match line associated with each content addressable field is then precharged and discharged in response to a failure of the content of an associated content addressable field to match the desired data. A normal word line is provided and activated by either the effective address match line or the real address match line through the subarray arbitration circuit so that only one match line is allowed to drive the normal word line concurrently. In the event of a SNOOP access, the real address match line may also be utilized to activate a separate SNOOP word line. The separate SNOOP word line and the normal word line are both coupled to dual ported bits within the data status field, permitting concurrent access of those bits during normal load/cache operations which utilize the effective address match line.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. A data cache array comprising:<claim-text>a plurality of cache lines, each of said plurality of cache lines including:<claim-text>a selected block of information;</claim-text><claim-text>a first content addressable field, said first content addressable field containing at least a portion of a multibit effective address for said selected block of information;</claim-text><claim-text>an effective address match line associated with each first content addressable field for indicating a match between a portion of a desired multibit effective address and said portion of said multibit effective address stored therein;</claim-text><claim-text>a second content addressable field, said second content addressable field containing at least a portion of a multibit real address for said selected block of information;</claim-text><claim-text>a real address match line associated with each second content addressable field for indicating a match between a portion of a desired multibit real address and said portion of a multibit real address stored therein;</claim-text></claim-text><claim-text>a normal word line for selecting a first particular cache line for access among said plurality of cache lines in response to activation by either said effective address match line or said real address match line; and</claim-text><claim-text>a SNOOP word line for selecting a second particular cache line for access among said plurality of cache lines in response to activation by said real address match line while said first particular cache line is being accessed.</claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. The data cache array according to claim 1, further including an arbitration logic circuit coupled to said effective address match line and said real address match line for activating said normal word line in response to only one of said effective address match line and said real address match line during a single clock cycle.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. The data cache array according to claim 2, further including means for coupling said real address match line to said SNOOP word line without arbitration.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. The data cache array according to claim 1, wherein each of said plurality of cache lines includes a data status field having a plurality of status bit cells therein.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. The data cache array according to claim 4, wherein each of said plurality of status bit cells is dual ported.</claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. The data cache array according to claim 5, wherein said normal word line is coupled to a first port of each of said dual ported status bit cells.</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. The data cache array according to claim 6, wherein said SNOOP word line is coupled to a second port of each of said dual ported status bit cells.</claim-text></claim>"}, {"num": 8, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. A method for permitting concurrent access in a data cache array having a plurality of cache lines, each cache line including a selected block of information, a first content addressable field, said first content addressable field containing at least a portion of a multibit effective address for said selected block of information and a second content addressable field, said second content addressable field containing at least a portion of a multibit real address for said selected block of information, said method comprising the steps of:<claim-text>providing an effective address match line associated with each first content addressable field for indicating a match between a portion of a desired multibit effective address and said portion of said multibit effective address stored therein;</claim-text><claim-text>providing a real address match line associated with each second content addressable field for indicating a match between a portion of a desired multibit real address and said portion of a multibit real address stored therein;</claim-text><claim-text>activating a normal word line for selecting a first particular cache line for access among said plurality of cache lines in response to either said effective address match line or said real address match line; and</claim-text><claim-text>activating a SNOOP word line for selecting a second particular cache line for access among said plurality of cache lines in response to said real address match line while said first particular cache line is being accessed.</claim-text></claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. The method for permitting concurrent access in a data cache array according to claim 8, further including the step of arbitrating said effective address match line and said real address match line such that said normal word line is activated by only one of said effective address match line and said real address match line during a single clock cycle.</claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. A data processing system, said data processing system comprising:<claim-text>a processor;</claim-text><claim-text>a main memory store;</claim-text><claim-text>a data cache array for temporarily storing blocks of information from within said main memory store, said data cache array comprising a plurality of cache lines, each cache line including:<claim-text>a selected block of information;</claim-text><claim-text>a first content addressable field, said first content addressable field containing at least a portion of a multibit effective address for said selected block of information;</claim-text><claim-text>an effective address match line associated with each first content addressable field for indicating a match between a portion of a desired multibit effective address and said portion of said multibit effective address stored therein;</claim-text><claim-text>a second content addressable field, said second content addressable field containing at least a portion of a multibit real address for said selected block of information;</claim-text><claim-text>a real address match line associated with each second content addressable field for indicating a match between a portion of a desired multibit real address and said portion of a multibit real address stored therein;</claim-text></claim-text><claim-text>a normal word line for selecting a first particular cache line for access among said plurality of cache lines in response to activation by either said effective address match line or said real address match line; and</claim-text><claim-text>a SNOOP word line for selecting a second particular cache line for access among said plurality of cache lines in response to activation by said real address match line while said first particular cache line is being accessed.</claim-text></claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. The data processing system according to claim 10, further including an arbitration logic circuit coupled to said effective address match line and said real address match line for activating said normal word line in response to only one of said effective address match line and said real address match line during a single clock cycle.</claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim num=\"12\"><claim-text>12. The data processing system according to claim 11, further including means for coupling said real address match line to said SNOOP word line without arbitration.</claim-text></claim>"}, {"num": 13, "parent": 10, "type": "dependent", "paragraph_markup": "<claim num=\"13\"><claim-text>13. The data processing system according to claim 10, wherein each of said plurality of cache lines includes a data status field having a plurality of status bit cells therein.</claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim num=\"14\"><claim-text>14. The data processing system according to claim 13, wherein each of said plurality of status bit cells is dual ported.</claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim num=\"15\"><claim-text>15. The data processing system according to claim 14, wherein said normal word line is coupled to a first port of each of said dual ported status bit cells.</claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim num=\"16\"><claim-text>16. The data processing system according to claim 15, wherein said SNOOP word line is coupled to a second port of each of said dual ported status bit cells.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES317715407\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>CROSS-REFERENCE TO RELATED APPLICATION</h4><p>The present invention is related to the subject matter of U.S. patent application Ser. No. 08/173,448, filed Dec.22, 1993, now abandoned in favor of U.S. patent application Ser. No. 08/658,912, and assigned to the assignee herein named. The content of the aforementioned U.S. patent application is hereby incorporated herein by reference thereto.</p><h4>BACKGROUND OF THE INVENTION</h4><p>1. Technical Field</p><p>The present invention is directed to an improved data processing system and in particular to an improved data cache array for utilization in a data processing system. Still more particularly the present invention relates to an improved method and system for concurrent access in a data cache array utilizing multiple match line selection paths.</p><p>2. Description of the Related Art</p><p>Many systems for processing information include both a system memory and a cache memory. A cache memory is a relatively small, high-speed memory that stores a copy of information from one or more portions of the system memory. Frequently, the cache memory is physically distinct from the system memory. Such a cache memory can be integral with the processor device of the system or non-integral with the processor.</p><p>Information may be copied from a portion of the system memory into the cache memory. The information in the cache memory may then be modified. Further, modified information from the cache memory can then be copied back to a portion of the system memory. Accordingly, it is important to map information in the cache memory relative to its location within system memory.</p><p>Assuming selection of an appropriately sized cache memory and the efficient storage of data therein the limiting factor in cache performance is the speed of the cache memory and the ability of the system to rapidly write data into or read data from the cache memory. This access speed will necessarily be limited by the width of the access bus and the speed of the memory.</p><p>Division of the cache into multiple subarrays may provide some increase in access speed by increasing the effective bandwidth of the access path; however, this approach requires increased addressing complexity and the overhead of maintaining multiple separate subarrays.</p><p>In view of the above, it should be apparent that a method and system for increasing the speed of access to a data cache array would be highly desirable.</p><h4>SUMMARY OF THE INVENTION</h4><p>It is therefore one object of the present invention to provide an improved data process system.</p><p>It is another object of the present invention to provide an improved data cache array for utilization with a data processing system.</p><p>It is yet another object of the present invention to provide an improved method and system for concurrent access In a data cache array utilizing multiple match line selection paths.</p><p>The foregoing objects are achieved as is now described. An interleaved data cache array which is divided into two subarrays is provided for utilization within a data processing system. Each subarray includes a plurality of cache lines wherein each cache line includes a selected block of data, a parity field, a content addressable field containing a portion of an effective address for the selected block of data, a second content addressable field contains a portion of the real address for the selected block of data and a data status field. A separate effective address port and real address port permit parallel access to the cache without conflict in separate subarrays and a subarray arbitration logic circuit is provided for attempted simultaneous access of a single subarray by both the effective address port and the real address port. Each access port provides reference lines into either the first content addressable field or the second content addressable field, and a match line associated with each content addressable field is then precharged and discharged in response to a failure of the content of an associated content addressable field to match the desired data. A normal word line is provided and activated by either the effective address match line or the real address match line through the subarray arbitration circuit so that only one match line is allowed to drive the normal word line concurrently. In the event of a SNOOP access, the real address match line may also be utilized to activate a separate SNOOP word line. The separate SNOOP word line and the normal word line are both coupled to dual ported bits within the data status field, permitting concurrent access of those bits during normal load/cache operations which utilize the effective address match line.</p><p>The above as well as additional objects, features, and advantages of the present invention will become apparent in the following detailed written description. dr</p><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself however, as well as a preferred mode of use, further objects and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:</p><p>FIGS. 1a-1c are conceptual illustrations of exemplary mapping techniques for caching information according to the prior art;</p><p>FIG. 2 is a conceptual illustration of a semi-associative mapping technique for caching information, in accordance with the preferred embodiment of the present invention;</p><p>FIG. 3 is a block diagram of an exemplary system including first and second processing systems and a level 2 (\"L2\") cache memory;</p><p>FIG. 4 is a graphic illustration of an addressing scheme utilized within the system of the present invention;</p><p>FIG. 5 is a schematic electrical circuit diagram of an exemplary CMOS CAM cell;</p><p>FIG. 6 is a high level block diagram of a multiple subarray cache provided in accordance with the present invention;</p><p>FIG. 7 is a more detailed block diagram of a single subarray of the cache of FIG. 6, illustrating one camlet in greater detail;</p><p>FIG. 8 is a high level block diagram illustrating a system for allocation control within a cache provided in accordance with the present invention;</p><p>FIG. 9 is an illustrative logic circuit for implementing allocation control within a cache provided in accordance with the present invention; and</p><p>FIG. 10 is a schematic representation of a dual port concurrent access system for utilization within a cache provided in accordance with the present invention.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF PREFERRED EMBODIMENT</h4><p>With reference now to the figures and in particular with reference to FIGS. 1a-1c, there are depicted conceptual illustrations of exemplary mapping techniques for caching information according to the prior art. A cache directory 10 has p=2<sup>k</sup> =8 entries, each associated with a respective block of information within a cache memory. A matrix 12 has q=2<sup>m+k</sup> =64 octal addresses, each representing a respective block of information within a secondary memory. FIGS. 1a-1c show each block of matrix 12 together with the block's respectively associated address. Each of the q octal addresses of matrix 12 has m+k=6 address bits.</p><p>FIG. 1a illustrates a direct mapping technique. In FIG. 1a, matrix 12 and directory 10 are logically arranged into p=2<sup>k</sup> =8 congruence classes. A congruence class is specified by an address's low-order k address bits. Accordingly, each congruence class includes multiple addresses, all of which can share the same low-order k address bits. For FIG. 1a, k=3 and m=3.</p><p>For example, in FIG. 1a, one congruence class includes all addresses whose low-order 3 address bits are octal 7. This congruence class includes the octal address 07, 17, 27, 37, 47, 57, 67 and 77. Likewise, another congruence class includes the octal addresses 02, 12, 22, 32, 42, 52, 62 and 72.</p><p>In FIG. 1a, each congruence class has one respective preassigned associated entry within cache directory 10. Accordingly, at any single moment, the cache memory stores information for only a single address of a congruence class; this single address is specified in the congruence class's associated entry of cache directory 10. For example, in the congruence class's associated entry, cache directory 10 can store a tag including the single address's high-order m address bits. For FIG. 1am, m=3.</p><p>As an example, in FIG. 1a, from among the 8 addresses whose low-order three address bits are octal 5, cache directory 10 indicates that the cache memory stores information for only octal address 45 whose tag value is octal 4. Similarly, from among the eight addresses whose low-order address bits are octal 1, cache directory 10 indicates that the cache memory stores information for only octal address 31.</p><p>Accordingly, the low-order k address bits of an address ADDR specify the congruence class of ADDR. Moreover, the low-order k address bits operate as an Index to access the congruence class's associated entry within cache directory 10 and its associated block of information within the cache memory by binary decoding. The indexed entry of cache directory 10 is read and compared with ADDR. If ADDR matches the index entry, then the index block of the cache memory stores information for ADDR.</p><p>A disadvantage of the directory mapping technique Is that storage in the cache memory of one address's Information excludes the storage of information for all other addresses of the same congruence class. This disadvantage is augmented by the fact that the number (2<sup>k</sup>) of congruence classes is limited to the number (2<sup>k</sup>) of entries In cache directory 10, so that a large number of addresses are forced to share a single entry in a cache directory 10. Likewise, all addresses of a single congruence class are forced to share a single entry In the cache memory.</p><p>FIG. 1b illustrates an n-way set-associative mapping technique, where n=2. In FIG. 1b, matrix 12 and directory 10 are logically arranged into p/n=4 congruence classes. A congruence class is specified by an address's low-order y address bits, where p/n=2<sup>y</sup>. Accordingly, each congruence class includes multiple addresses, all of which share the same low-order y address bits. For FIG. 1b, k=3 and y=2.</p><p>For example, in FIG. 1b, one congruence class includes all addresses whose low-order two address bits have a value=3. This congruence class includes the octal addresses 03, 07, 13, 17, 23, 27, 33, 37, 43, 47, 53, 57, 63, 67, 73 and 77. Likewise, another congruence class includes the octal addresses 01, 05, 11, 15, 21, 25, 31, 35, 41, 45, 51, 55, 61, 65, 71 and 75.</p><p>In FIG. 1b cache directory 10 is logically arranged into two columns having four blocks each. Thus, each congruence class has a respective preassigned associated set of first and second entries within cache directory 10. Accordingly, at any single moment, the cache memory stores information for first and second addresses of a congruence class; the first and second addresses are specified in the congruence class's associated set of first and second entries within cache directory 10. For example, in the first associated entry, cache directory 10 can store a first tag including the first address's high-order m=1 address bits; in the second associated entry, cache directory 10 can store a second tag including the second address's high-order m=1 address bits. For FIG. 1b, m=3.</p><p>As an example, in FIG. 1b, from among the 16 addresses whose low-order two address bits have a value=1, cache directory 10 indicates that the cache memory stores information for only octal address 05 and octal address 11. Similarly, from among the 16 address whose low-order two address bits have a value=3, cache directory 10 indicates that the cache memory stores information for only octal address 43 and octal address 14.</p><p>Accordingly, the low-order y address bits of address ADDR specify the congruence class of ADDR. Moreover, the low-order y address bits operate as an index to the congruence class's associated set of two entries within cache directory 10 and its associated set of two blocks within the cache memory. The two index entries of cache directory 10 are read and compared with ADDR. If ADDR matches one of the indexed entries, then the matching entry's associated block of the cache memory stores information for ADDR. A disadvantage of the set-associative technique is delayed selection of information output from a cache memory, resulting from selection between the two indexed entries of cache directory 10. This disadvantage is overcome by the method and system of the present invention.</p><p>Finally, FIG. 1c illustrates a fully associative mapping technique. In FIG. 1c, matrix 12 and directory 10 are not logically arranged into congruence classes. Accordingly, at any single moment, the cache memory can store information for any group of eight addresses; these eight addresses are specified in the eight entries of cache directory 10. For example, cache directory 10 can store eight tags, each including all bits of an address.</p><p>In FIG. 1c, cache directory 10 is structures as a content addressable memory (CAM) array of p=8 CAM entries by m+k=6 address bits. As a CAM array, cache directory 10 inputs address ADDR and compares it simultaneously with all address in the eight CAM entries. If ADDR matches any CAM entry's address, then a respective one of match lines 14a-h is asserted to directly select the cache memory block storing information for ADDR. Thus, cache directory 10 operates as a decoder and accessing mechanism for the cache memory.</p><p>A disadvantage of the fully associative technique is the expense, complexity and diminished speed of a CAM array having m+k address bit lines by p match lines. This is especially true as the number (m+k) of address bits increases in conjunction with the number of (q=2<sup>m+k</sup>) of secondary memory blocks.</p><p>Referring now to FIG. 2 there Is depicted a conceptual illustration of a semi-associative mapping technique for caching Information in accordance with the present invention. As illustrated, a cache directory 30 has p=2<sup>k</sup> =8 entries (or \"locations\"), each associated with a respective block (or location) of information within a cache memory provided in accordance with the present invention. Matrix 32 is depicted, which includes q=2<sup>m+k</sup> =64 octal addresses, each representing a respective block (or \"location\") of information within a secondary memory, depicted within FIG. 3. Each of the q octal addresses of matrix 32 has m+k=6 address bits.</p><p>As illustrated in FIG. 2, matrix 32 and directory 30 are logically arranged into 2.sup.(k+l) congruence classes, where 2<sup>k</sup> is a number of primary congruence classes and 2 is a number of secondary congruence classes (\"congruence subclasses\"). For FIG. 2, p*2=2.sup.(k+j) =16, so that k=3 and j=1. A primary/secondary congruence class is specified by an addresses's index (k+j) address bits. Accordingly, each congruence class includes multiple addresses, all of which share the same index (k+j) address bits.</p><p>For example, in FIG. 2, one congruence class includes all addresses whose index (k+j) address bits are 0001. This congruence class includes the octal addresses 01, 21, 41 and 61. Likewise, another congruence class (whose index (k+j) address bits are 1001) includes the octal addresses 11, 31, 51 and 71.</p><p>In a significant aspect of the preferred embodiment, congruence classes are not preassigned to entries within cache directory 30. Instead, congruence classes are dynamically associated with (or \"allocated to\") entries within cache directory 30. Accordingly, each cache directory 30 entry is able to relate a cache memory block to any of the multiple secondary memory blocks in more than one congruence class.</p><p>Thus, at any single moment, up to 2<sup>k</sup> of the 2<sup>k+j</sup> congruence classes have respective associated entries within cache directory 30 in any grouping and in any order. Accordingly, at any single moment, the cache memory stores information for up to 2<sup>k</sup> of the 2.sup.(k+j) congruence classes in any grouping and in any order. The value of a congruence class is stored in the k+j CAM cells of the congruence classes's dynamically associated entry within cache directory 30. In a congruence classes's associated entry within cache directory 30, one of multiple addresses of the congruence class is specified. For example, in the congruence classes's associated entry, cache directory 30 can store a tag including the addresses's high-order (m-J) address bits. For FIG. 2, m=3.</p><p>As an example, in FIG. 2, from among the four addresses whose index (k+J) address bits are 1101 (octal addresses 15, 35, 55 and 75), cache directory 30 indicates that the cache memory stores information for octal address 55. In such a situation, the k+j index bits 1101 are stored in the CAM bits portion of the congruence classes's cache directory 30 entry, and a m-j tag bits are stored in the tag portion of the congruence classes's cache directory 30 entry. By comparison, cache directory 30 indicates that the cache memory stores information for none of the four addresses (octal addresses 03, 23, 43 and 63) whose index (k+j) address bits are 0011.</p><p>In an exemplary embodiment, a particular congruence class is allowed only one associated entry within cache directory 30, such that the cache directory is able to store information for only one address of the particular congruence class at a single moment. By comparison, in the preferred embodiment, a particular congruence class is allowed multiple associated entries within cache directory 30, in any grouping and in any order, such that the cache memory is able to store information for multiple addresses of the particular congruence class at any single moment in any grouping and in any order.</p><p>With reference now to FIG. 3, there is depicted a block diagram of an exemplary system, indicated generally as 300, including first and second processing systems 302 and 304, and a level 2 (\"L2\") cache controller 306, connected to one another through a system bus 308. L2 cache controller 306 controls an L2 cache memory 312, according to a real 4-way set-associative mapping technique. L2 cache memory 312 is accessed in response to real addresses.</p><p>Processing system 302 preferably includes a processor 314, an L1 cache controller 316, and an L1 cache memory 318. L1 cache controller 316 is connected to system bus 308, to processor 314 and to L1 cache memory 318. L1 cache controller 316 controls L1 cache memory 318 according to the semi-associative mapping technique disclosed herein.</p><p>Likewise, a processing system 304 includes a processor 320, an L1 cache controller 322, and an L1 cache memory 324. L1 cache controller 322 is connected to system bus 308, to processor 320 and to L1 cache memory 324. L1 cache controller 322 controls L1 cache memory 324 according to the semi-associative mapping techniques set forth herein.</p><p>Processing system 302 is a representative one of processing systems 302 and 304. Notably, the set of blocks in L1 cache memory 318 is a subset of the blocks in L2 cache memory 312. Any block of information stored in L2 cache memory 312 likewise can be stored in L1 cache memory 318.</p><p>Accordingly, L2 cache memory 312 is preferably organized as a real-cache having a block size at least as large as the block size of L1 cache memory 318. If the number of blocks in L1 cache memory 318 is p, then any p blocks (out of the total number of blocks stored in L2 cache memory 312) may be stored in L1 cache memory 318. For multiprocessor and I/O cache consistency, a directory of L2 cache memory 312 stores a real address for each block stored in L1 cache memory 318.</p><p>Aliasing in a system of the type set forth herein is supported on a page granularity, such that a real block of information may have different effective addresses. In an exemplary embodiment, the different effective addresses (corresponding to the same real block of information) may differ by an integral multiple of 4 kilobytes, which is the page size. As an example, if the size of L1 cache memory 318 is 32 kilobytes with a block size of 64 bytes, then L1 cache memory 318 has 512 blocks. In addition to the 64 bytes of information, each block has directory information including a real address and various status bits.</p><p>Thus, each of the 512 blocks of information in L1 cache memory 318 is associated with an effective address. A portion of the effective address is formed by bits 2<sup>12</sup> through 2<sup>c</sup> of each blocks' associated effective address. In the exemplary embodiment, c=19, and the effective address is either 32 bits or 64 bits in length. By searching L1 cache memory 318 in response to an effective address (EA) (see FIG. 4), one-cycle loads are achievable.</p><p>Referring now to FIG. 4, there is depicted a graphic illustration of an addressing system which may be utilized within the system of the present invention. As illustrated, an effective or virtual address 400 is graphically depicted within FIG. 4. Effective address 400 preferably includes 64 bits; however, bits 0 through bit 43 are not utilized within the data cache array of the present invention. As depicted, bits 58 through 63, as illustrated at 410, represent the line offset of the effective address. Bit 57, as depicted at 408, is utilized to select one of two subarrays within the data cache array of the present invention. Next, bits 52 through 56, as depicted at 406, are utilized to select one of 32 camlets within each subarray of the data cache array of the present invention. In the depicted embodiment of the present invention each \"camlet\" comprises eight lines of the data cache array, which are laid out in a manner which will be explained in greater detail herein. Finally, eight bits of the effective address, bits 44 through 51, as depicted at 404, form a content addressable memory field referred to herein as the \"ECAM\" tag present within each line of the data cache array provided in accordance with the present invention.</p><p>Next, as depicted at block 412, an exemplary real address which may be utilized with the system of the present invention is depicted. As above, six bits, bits 34-39, as illustrated at 420, are the line offset for the real address. Bit 33, as depicted at block 418, is utilized to select one of the two subarrays within the data cache array of the present invention and, five bits, bits 28-32, as illustrated at 416, are utilized to select a particular one of the 32 camlets within each subarray. Finally, as depicted at 414, 28 bits of the real address for an associated block of information are stored within a second content addressable field, referred to herein as \"RCAM\". Although not described herein in detail, those skilled in the art will appreciate that during any comparison between a desired address and the potions of the address stored within the ECAM field and the RCAM field, the bits identifying the camlet must also be compared.</p><p>Thus, those skilled in the art will appreciate that in accordance with the addressing system depicted within FIG. 4, each block of information within a system which incorporates the data cache array of the present invention will include two separate and distinct content addressable fields which may be utilized in conjunction with either a portion of the effective address or a portion of the real address to select a block of information within the cache array.</p><p>With reference now to FIG. 5, there is depicted a schematic electrical circuit diagram of an exemplary CMOS CAM cell provided in accordance with the present invention. As illustrated generally at 500, the CAM cell depicted includes a six transistor SRAM memory cell, generally indicated at 502, with additional logic for comparison, and XOR function, generally indicated at 516. The SRAM memory cell is preferably connected to a pair of bit lines 504 and 506 by activation of the word line 512. The two inputs of the XOR logic are preferably connected to a reference line pair 508 and output to a match lines 14. In accordance with the system of the present invention utilizing both a bit line pair 504 and 506 and a reference line pair 508 and 510 within selected CAM cells make it possible to compare and read/write during the same clock cycle.</p><p>In operation, reference line pair 508 and 510 are forced low and match line 514 is precharged high. Next, one of the reference lines (508 and 510) is activated and the comparison begins. If the data on the reference line does not match the data stored within the memory cell, the match line 514 will be discharged. However, if the data on the reference line does match the data stored within the memory cell, match line 514 will remain in the precharged condition. The condition of match line 514 is preferably latched and the reading or writing of data may thereafter continue while the match line is in the precharged condition.</p><p>Referring now to FIG. 6, there is illustrated a high level block diagram of a multiple subarray cache 600 which is provided in accordance with the present invention. As illustrated, multiple subarray cache 600 preferably includes two subarrays 602 and 604; however, as those skilled in the art will appreciate upon reference to the present specification, a larger number of subarrays may be provided. As illustrated, data cache array unit 600 preferably contains 32K bytes of cache data and is physically subdivided into subarrays 602 and 604. Each subarray preferably includes 256 cache lines, wherein each cache line includes a 512 bit data field, which is broken into two segments, as depicted at 618 and 628 within subarray 602. Each cache line also preferably includes a 64 bit parity field (not shown) a 28 bit RCAM field 626, a 9 bit ECAM field 620 and a 3 bit MESI field 624.</p><p>As those skilled in the art will appreciate the so-called \"MESI\" status bits are commonly utilized within data caches. The term \"MESI\" is an acronym which stands for \"Modified,\" \"Exclusive,\"\"Shared,\" and \"Invalid.\" Thus, the status of data within a particular line within a data cache may be rapidly and efficiently determined by determining the status of these three bits. Similarly, the status of data within a cache may be altered by writing different bits into the MESI field.</p><p>Additionally, as depicted within FIG. 6, each subarray includes an associated allocate buffer 606 and 608 and an associated write driver 610 and 612 which are utilized to drive data into a cache line within the array. Similarly, sense amplifiers 650 and 652 are provided for amplifying the output signal from a particular cache line.</p><p>As illustrated within FIG. 6, by providing two separate and distinct content addressable fields within each line within the data cache array the data within that line may be accessed in a number of novel and efficient sequences.</p><p>With reference now to FIG. 7, there is Illustrated a more detailed block diagram of a single subarray of a cache provided in accordance with the present invention, illustrating one camlet in greater detail. As illustrated, a single subarray 700 is depicted. As described above, each line within subarray 700 includes 512 bits of data which is divided into data fields 702 and 704. A twenty-eight bit content addressable field containing a portion of a multibit real address (RCAM) is illustrated at 706 and an eight bit effective address content addressable field (ECAM) is dipicted at block 708. An additional most recently utilized (MRU) bit 710 is depicted and this bit is utilized, in conjunction with eight bit ECAM content addressable field 708 to resolve offset situations in which two or more effective addresses map to a single real address.</p><p>The MESI bits are illustrated in greater detail at reference numeral 712 and, in accordance with an important feature of the present invention, a pseudo least recently utilized \"PLRU\" logic circuit is present within subarray 700 and is depicted at block 714. Each camlet, which comprises eight lines of data cache array 700, includes a separate PLRU logic circuit which may be utilized, in a manner which will be explained in greater detail herein, to allocate a particular line within that camlet for removal and replacement in the event of a cache miss and the requirement to load a new line of data.</p><p>A PLRU multiplexor is also illustrated at block 716 and is utilized, in a manner which will be explained in greater detail herein, to permit a particular line within a camlet to be allocated in response to a lack of validity of the data therein or in response to a utilization data which is determined utilizing PLRU logic circuit 714.</p><p>Output buffers and sense amplifiers 718 and 720 are utilized in a conventional manner to read data from a cache line. In accordance with a novel feature of the present invention two input ports are provided within each subarray. An effective address (EA) input port and a real address (RA) input port are provided such that up to two concurrent accesses may be supported. Thus, one effective address (EA) port and one real address (RA) port may be utilized to simultaneously access the array during the same cycle. A read control and arbitration logic circuit 722 is provided to ensure that in the event simultaneous access of the same subarray is attempted utilizing the effective address (EA) port and real address (RA) port the lower priority cycle will be blocked and the higher priority cycle will be permitted to access the subarray. An exception to this technique is the so-called \"SNOOP\" cycle which, in a manner which will be explained in greater detail herein, is provided by implementing a second word line for access of the MESI bits, such that a SNOOP access may be run concurrently with any of the effective address (EA) cycles.</p><p>Finally, write control 730 is utilized in conjunction with write drivers and the associated multiplexes, as indicated at 732 and 734 to permit data within the data cache array to be written. Still referring to FIG. 7 it should be noted that since only a portion of the effective addresses utilized to try to obtain a match within an ECAM field on an initial cache look-up, it is possible to encounter a situation in which the portion of the effective address which is utilized indicates a \"hit,\" but the data associated with that ECAM field is not the appropriate data. This situation is known as an address \"offset\" condition. This situation occurs wherein an entry within the cache includes the desired partial effective address; however, the real address of the data desired is not associated therewith.</p><p>Additionally, it is possible that although the portion of the effective address contained within the ECAM fields within the cache do not match the desired effective address upon initial look-up, the desired data may still be present within the cache. This is due to the fact that it is possible for two different effective addresses to map to the same real address. This situation is known as virtual address \"aliasing.\"</p><p>These two situations may be efficiently handled within the data cache array of the present invention if the data cache array is constrained such that no two RCAM fields contain the same content within a selected camlet. This will ensure that only one line per camlet can match, for a given address. As illustrated at reference numeral 710 a most recently utilized (MRU) bit may be stored as part of the ECAM field and utilized to permit two different ECAM fields to have the same stored address but only one of the ECAM fields to match. In other words, if there are multiple copies of the same ECAM address field stored within a camlet only the particular ECAM field having a validated MRU bit will be considered a match.</p><p>First, the so-called virtual \"aliasing\" miss will be described. In this scenario a partial effective address is utilized to access the content addressable field referred to as the ECAM, at reference numeral 708 and no stored ECAM field within the desired subarray and camlet matches the desired partial effective address. Thus, a second cycle real address look-up is required to determine if virtual aliasing has occurred.</p><p>During the period of time while the partial effective address is being utilized to determine if an ECAM field within the desired camlet is a match, the desired effective address is preferably being translated within the system into a real address by a memory management unit. Numerous schemes for translating effective addresses into real addresses are known in the prior art and further discussion of this technique is not contained herein. On the second cycle, the appropriate portion of the desired real address is utilized to attempt to locate a match within the content addressable fields (RCAM) which contain the real address portion and a \"hit\" may occur, indicating an aliased address condition.</p><p>This result means that the requested data is contained within the selected camlet; however, the data was allocated into the cache utilizing a different effective address field than the effective address field which was utilized during the first cycle look-up. In this situation during the second cycle hit data and MESI status bits are returned to the load unit. In addition, while the line is selected the ECAM field associated with the desired data is updated with the portion of the effective address utilized during the initial look-up up and the MRU bit for that line is set to \"1\", effectively turning this data cache line into a single cycle hit case for subsequent look-ups.</p><p>An offset hit scenario may also result. In such a situation the portion of the effective address utilized to access the ECAM field indicates a hit within the desired camlet; however, the real address portion stored within that line within the data cache array does not match the real page number which is output from the memory management unit after translation. At this point, it is determined that the data of interest is not stored within the line having the matching ECAM address; however, it is not yet known whether or not that data resides within any of the other camlet locations having different ECAM address fields. As above, the ROAM content addressable fields within the camlet are then accessed utilizing a portion of the translated real address and a failure of the ROAM content addressable fields to hit indicates that the requested data does not reside within the selected camlet.</p><p>In this situation the MRU bit of the first ECAM field line must be reset, so that the ECAM field may be updated without creating a condition where two ECAMs have the same content within a camlet. In a third cycle the latched effective address is utilized to compare into the first line and that line's MRU bit is reset to zero. In the fourth cycle, an allocate cycle is performed which, in a manner which will be explained in greater detail herein, either utilizes the PLRU logic to select a line for replacement or determines an allocation candidate based on validity status, as determined utilizing the MESI bits. The desired data and its associated ECAM and ROAM fields is then written into the cache and the MRU bit for that line is set to \"1\" Thereafter, the desired data may be read from that line within the cache array.</p><p>Finally, an aliased hit may occur in an offset situation. In this scenario the portion of the effective address utilized to access the ECAM context addressable fields within a camlet indicates a hit but the real address portion stored therein does not match the real page number output from the memory management unit after translation. Again, at this point it is known that the data of interest is not stored within this particular line; however, again we do not know if the desired data resides within any other camlet location having a different ECAM address. In the second cycle, as described above with respect to the aliasing situation, the RCAM content addressable fields are examined for a match with the desired real address and a hit may occur, indicating that the requested data is present within the camlet but that the data has been allocated with a different effective address. In this situation the MRU bit of the first line is reset, and the ECAM field within the second line will be updated, this process occurs without creating a condition where two ECAMs have the same content with a camlet. The MRU bit is set to \"1\" and the desired data has then been returned from the cache.</p><p>Upon reference to the foregoing those skilled in the art will appreciate that by writing two separate and distinct content addressable fields within each cache line which may be utilized to access data within a cache line utilizing either the effective or real address, the data cache array of the present invention may be rendered substantially more efficient than fully associative cache designs while maintaining the high hit ratio of set associative cache designs known in the prior art.</p><p>Referring now to FIG. 8, there is depicted a high level block diagram illustrating a system for allocation control within a cache provided in accordance with the present invention. As depicted, a pseudo least recently utilized (PLRM) logic circuit 802 is provided for each camlet within the data cache array. Pseudo least recently utilized (PLRU) logic 802 is utilized to provide a series of signals to allocate control 814, which is utilized to control the conduction of a transistor which is coupled to a match line 812. As illustrated, a pseudo least recently utilized (PLRU) logic 802 is utilized to provide these control signals to each line within a camlet and thus, eight control outputs are provided.</p><p>As described above, match line 812 is preferably precharged and then discharged in response to a failure of the data stored within the cam cells (806, 808) to match a desired set of reference data.</p><p>As will be explained in greater detail herein, pseudo least recently utilized (PLRU) logic 802 may be utilized to select a particular line within a camlet for allocation based upon utilization data of those lines or, alternatively, based upon the validity status of a particular line within that camlet. In this manner, by providing allocation selection logic circuitry within the data cache array the selection of lines within the data cache array for replacement is greatly enhanced and bus loading is reduced, as well as reducing the number of cycles which are required to complete a miss sequence. This is accomplished, as will be described in greater detail herein, by providing an additional modified cell, an allocation control cell, within each ECAM field for each line within the data cache array. During the allocation cycle, pseudo least recently utilized (PLRU) logic 802 controls this additional cell while all ECAM reference line pairs are forced low, disabling their effect on the ECAM match line. This allows pseudo least recently utilized (PLRU) logic 802 to directly select a line for allocation end any other related miss sequence cycles.</p><p>For an instruction cache this approach may be utilized to merge both the allocation, line selection and refill cycles into a single cycle. For a data cache which may require copy backs of the replacement line, this approach can merge the allocation cycle, status/tag read cycle and the first copy back read cycle into a single cycle. The ECAM word line driver circuit previously necessary to update the ECAM field is also eliminated as the ECAM word line may be selected utilizing the same logic which selects the tag, status bit and data word lines. A single word line may thus be utilized to select every memory element (RCAM/ECAM/tag/status/data) within a cache line.</p><p>When a line within the data cache array needs to be replaced pseudo least recently utilized (PLRU) logic 802 first determines whether or not there is a non-valid line within the camlet which can be replaced. As those having ordinary skill in this art will appreciate, this is accomplished by checking the MESI bits for each line within the camlet. If all of the lines within the camlet are valid, pseudo least recently utilized (PLRU) logic 802 then utilizes a common PLRU mechanism to determine which line should be replaced. Seven binary bits within pseudo least recently utilized (PLRU) logic 802 are defined for each of the eight lines In the camlet. These bits are referred to as the PLRU bits and they are update for each hit within the data cache.</p><p>Thus, if the most recent access to the set was to line LO line L1, line L2 or line L3, binary bit B0 is set equal to 1. If the most recent access to the set was to lines L4, L5, L6, or L7, the binary bit B0 is :set equal to \"0.\" Additionally, if the most recent access to lines L0-L3 was to L0, or L1, binary bit B1 is set equal to 1, otherwise binary bit B1 is set equal to 0. If the most recent access to lines L4-L7 was to L4 or L5, binary bit B2 is set equal to 1, otherwise binary bit B2 is set equal to 0. If the most recent access to lines L0-L1 was to L0, binary bit B3 is set equal to 1, otherwise binary bit B3 is set equal to 0. If the most recent access to lines L2-L3 was to L2, binary bit B4 is set equal to 1, otherwise binary bit B4 is set equal to 0. Similarly, if the most recent access to lines L4-L5 was to line L4, binary bit B5 is set equal to 1, otherwise binary B5 is set equal to 0. Finally, if the most recent access to lines L6-L7 was to line L6, binary bit B6 is set equal to 1, otherwise binary bit B6 is set equal to 0.</p><p>In this manner, pseudo least recently utilized (PLRU) logic 802 may be utilized to select a particular line during an allocation in a cycle when all eight lines within a camlet are valid by following the following logic equations:</p><p></p><pre listing-type=\"tabular\" xml:space=\"preserve\"><!--Greenbook tabular data-->______________________________________                                    \n        L0.sub.-- selected: =                                             \n                   B0&amp; B1&amp; B3;                                            \n        L1.sub.-- selected: =                                             \n                   B0&amp; B1&amp;B3;                                             \n        L2.sub.-- selected: =                                             \n                   B0&amp;B1&amp; B4;                                             \n        L3.sub.-- selected: =                                             \n                   B0&amp;B1&amp;B4;                                              \n        L4.sub.-- selected: =                                             \n                  B0&amp; B2&amp; B5;                                             \n        L5.sub.-- selected: =                                             \n                  B0&amp; B2&amp;B5;                                              \n        L6.sub.-- selected: =                                             \n                  B0&amp;B2&amp; B6;                                              \n        L7.sub.-- selected: =                                             \n                  B0&amp;B2&amp;B6;                                               \n______________________________________                                    \n</pre><p>With reference now to FIG. 9, there is depicted an illustrative logic circuit for implementing allocation control within a data cache array provided in accordance with the present invention. As illustrated, a signal indicating that a particular line within a camlet is invalid may be coupled to logic gate 902 and utilized to enable the selection of the invalid line for an allocation cycle. Alternately, a particular line selected by pseudo least recently utilized (PLRU) logic 802 may also be utilized to select a particular line within a camlet for allocation. These signals are combined logically and coupled to allocation control cells 904 and 906, for illustrative purposes, and these circuits are then utilized, in the manner described above, to control allocation control transistors 908 and 910, which may be utilized to effect the selection of a particular line for allocation.</p><p>Finally, referring to FIG. 10, there is depicted a schematic representation of a dual port concurrent access within a data cache array provided in accordance with the present invention. As schematically depicted, ECAM cells 1002 and RCAM cells 1004 each drive an associated match line 1006 and 1008. Each match line is coupled to match line arbitration circuits 1010 and 1012. Thus, an attempted simultaneous access utilizing the EA port and RA port within the same subarray will result in an arbitration such that only a single word line 1014 is asserted. This ensures that concurrent access by both the EA port and RA port within the same subarray do not occur.</p><p>However, if the RA access port is being utilized to permit a \"SNOOP\" access a second word line may be activated. Thus, SNOOP word line 1018 may be activated directly from RA match line 1008 without regard to arbitration, permitting the RA input port to be utilized for a SNOOP access, while the EA input port is being utilized for normal loads or cache control operations. SNOOP word line 1018 may then be utilized to determine the state of data within a particular line by examining the MESI bits, two of which are illustrated at 1020 and 1022. The CAM cells which provide these bits are dual ported in nature, utilizing two word lines to allow each bit to be read simultaneously on two sets of bit lines.</p><p>The \"normal\" word line, as illustrated at 1014 may be activated by allowing the EA match line to be passed to the word line through an arbitrated pass device. This of course requires that RA match line 1008 is not being utilized to select the normal word line, as only one match line is permitted throughout the final word line buffer logic. In this manner, by providing a word line driver consisting of an EA input port/RA input port arbitrated match line selection path and a non-arbitrated RA input port match line selection path, concurrent access for SNOOP purposes may be provided.</p><p>While the invention has been particularly shown and described with reference to a preferred embodiment, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Peichun Peter", "last_name": "Liu", "name": ""}, {"first_name": "Brian David", "last_name": "Branson", "name": ""}, {"first_name": "Victor", "last_name": "Shadan", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "INTERNATIONAL BUSINESS MACHINES CORPORATION"}, {"first_name": "", "last_name": "FREESCALE SEMICONDUCTOR, INC.", "name": ""}, {"first_name": "", "last_name": "FREESCALE SEMICONDUCTOR, INC.", "name": ""}, {"first_name": "", "last_name": "FREESCALE SEMICONDUCTOR, INC.", "name": ""}, {"first_name": "", "last_name": "CITIBANK, N.A., AS COLLATERAL AGENT", "name": ""}, {"first_name": "", "last_name": "CITIBANK, N.A. AS COLLATERAL AGENT", "name": ""}, {"first_name": "", "last_name": "FREESCALE SEMICONDUCTOR, INC.", "name": ""}, {"first_name": "", "last_name": "INTERNATIONAL BUSINESS MACHINES CORPORATION", "name": ""}, {"first_name": "", "last_name": "MOTOROLA, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/08"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/10        20060101A I20051008RMEP"}, {"label": "G06F  12/08        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711146"}, {"primary": false, "label": "711E12062"}, {"primary": false, "label": "711108"}, {"primary": false, "label": "711131"}, {"primary": false, "label": "711E12033"}], "ecla_classes": [{"label": "G06F  12/08B4P4"}, {"label": "G06F  12/10L4"}, {"label": "S06F12:08B6N"}], "cpc_classes": [{"label": "G06F  12/0853"}, {"label": "G06F  12/0831"}, {"label": "G06F  12/1045"}, {"label": "G06F  12/0853"}, {"label": "G06F  12/1045"}, {"label": "G06F  12/0831"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1994-10-05", "application_date": "1994-10-05", "family_members": [{"ucid": "US-5640534-A", "titles": [{"lang": "EN", "text": "Method and system for concurrent access in a data cache array utilizing multiple match line selection paths"}]}, {"ucid": "EP-0706133-A3", "titles": [{"lang": "FR", "text": "Proc\u00e9d\u00e9 et syst\u00e8me d'acc\u00e8s simultane dans une matrice d'ant\u00e9m\u00e9moires de donn\u00e9es utilisant plusieurs chemins de s\u00e9lection de lignes de concordance"}, {"lang": "EN", "text": "Method and system for concurrent access in a data cache array utilizing multiple match line selection paths"}, {"lang": "DE", "text": "Verfahren und Anordnung zum gleichzeitigen Zugriff in einer Datencache-Speichermatrix mit mehreren \u00dcbereinstimmungszeilenauswahlswegen"}]}, {"ucid": "EP-0706133-A2", "titles": [{"lang": "FR", "text": "Proc\u00e9d\u00e9 et syst\u00e8me d'acc\u00e8s simultane dans une matrice d'ant\u00e9m\u00e9moires de donn\u00e9es utilisant plusieurs chemins de s\u00e9lection de lignes de concordance"}, {"lang": "EN", "text": "Method and system for concurrent access in a data cache array utilizing multiple match line selection paths"}, {"lang": "DE", "text": "Verfahren und Anordnung zum gleichzeitigen Zugriff in einer Datencache-Speichermatrix mit mehreren \u00dcbereinstimmungszeilenauswahlswegen"}]}]}