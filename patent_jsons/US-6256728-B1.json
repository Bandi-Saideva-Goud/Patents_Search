{"patent_number": "US-6256728-B1", "publication_id": 72726661, "family_id": 26746119, "publication_date": "2001-07-03", "titles": [{"lang": "EN", "text": "Processor configured to selectively cancel instructions from its pipeline responsive to a predicted-taken short forward branch instruction"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11212545\" source=\"national office\"><p>A processor is configured to detect a branch instruction have a forward branch target address within a predetermined range of the branch fetch address of the branch instruction. If the branch instruction is predicted taken, instead of canceling subsequent instructions and fetching the branch target address, the processor allows sequential fetching to continue and selectively cancels the sequential instructions which are not part of the predicted instruction sequence (i.e. the instructions between the predicted taken branch instruction and the target instruction identified by the forward branch target address). Instructions within the predicted instruction sequence which may already have been fetched prior to predicting the branch instruction taken may be retained within the pipeline of the processor, and yet subsequent instructions may be fetched.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72580582\"><p>A processor is configured to detect a branch instruction have a forward branch target address within a predetermined range of the branch fetch address of the branch instruction. If the branch instruction is predicted taken, instead of canceling subsequent instructions and fetching the branch target address, the processor allows sequential fetching to continue and selectively cancels the sequential instructions which are not part of the predicted instruction sequence (i.e. the instructions between the predicted taken branch instruction and the target instruction identified by the forward branch target address). Instructions within the predicted instruction sequence which may already have been fetched prior to predicting the branch instruction taken may be retained within the pipeline of the processor, and yet subsequent instructions may be fetched.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00001\" num=\"1\"><claim-text>1. A method for fetching instructions in a processor, the method comprising:</claim-text><claim-text>fetching a plurality of instructions; </claim-text><claim-text>detecting a first branch instruction within said plurality of instructions, said first branch instruction having a forward branch target address; </claim-text><claim-text>predicting said first branch instruction; </claim-text><claim-text>canceling instructions from a pipeline of said processor prior to executing said instructions, said instructions being between said first branch instruction and a subsequent instruction within said plurality of instructions, said subsequent instruction being identified by said forward branch target address, wherein said canceling is responsive to said predicting selecting a taken prediction for said first branch instruction and said forward branch target address being within a predetermined range of a first branch fetch address corresponding to said first branch instruction; and </claim-text><claim-text>retaining said subsequent instruction in said pipeline even if said predicting selects said taken prediction responsive to said forward branch target address being within said predetermined range. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00002\" num=\"2\"><claim-text>2. The method as recited in claim <b>1</b> further comprising detecting a second branch instruction within said plurality of instructions and subsequent to said first branch instruction, said detecting said second branch instruction performed in parallel with said detecting said first branch instruction.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00003\" num=\"3\"><claim-text>3. The method as recited in claim <b>2</b> further comprising predicting said second branch instruction.</claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00004\" num=\"4\"><claim-text>4. The method as recited in claim <b>3</b> further comprising determining if said second branch instruction is still within said pipeline subsequent to said canceling.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00005\" num=\"5\"><claim-text>5. The method as recited in claim <b>4</b> further comprising canceling instructions from said pipeline prior to executing said instructions, said instructions being subsequent to said second branch instruction within said plurality of instructions, said canceling responsive to said predicting said second branch instruction taken.</claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00006\" num=\"6\"><claim-text>6. The method as recited in claim <b>5</b> wherein said canceling comprises selectively canceling instructions within said plurality of instructions between said second branch instruction and a second subsequent instruction identified by a second forward branch target address corresponding to said second branch instruction.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00007\" num=\"7\"><claim-text>7. The method as recited in claim <b>1</b> wherein said canceling comprises identifying a range of addresses of instructions to be cancelled.</claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00008\" num=\"8\"><claim-text>8. The method as recited in claim <b>7</b> wherein said range is delimited by an upper limit and a lower limit.</claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00009\" num=\"9\"><claim-text>9. The method as recited in claim <b>8</b> wherein said lower limit comprises said first branch fetch address.</claim-text></claim>"}, {"num": 10, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00010\" num=\"10\"><claim-text>10. The method as recited in claim <b>8</b> wherein said upper limit comprises said forward branch target address.</claim-text></claim>"}, {"num": 11, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00011\" num=\"11\"><claim-text>11. The method as recited in claim <b>7</b> wherein said canceling further comprises comparing said upper limit and said lower limit to fetch addresses of said plurality of instructions.</claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00012\" num=\"12\"><claim-text>12. The method as recited in claim <b>11</b> wherein said canceling further comprises canceling a particular instruction within said plurality of instructions if a corresponding fetch address of said particular instruction is greater than said lower limit and less than said upper limit.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00013\" num=\"13\"><claim-text>13. A processor comprising:</claim-text><claim-text>a branch scanner configured to identify a first branch instruction within a plurality of instructions; </claim-text><claim-text>a branch history table coupled to said branch scanner, wherein said branch history table is configured to select a first branch prediction from a plurality of branch predictions stored therein responsive to said first branch instruction identified by said branch scanner; and </claim-text><claim-text>a forward collapse unit coupled to said branch scanner and said branch history table, wherein said forward collapse unit is configured to indicate: (i) which instructions within said plurality of instructions and subsequent to said first branch instruction to cancel from a pipeline of said processor prior to executing said instructions, and (ii) which instructions within said plurality of instructions and subsequent to said first branch instruction to retain in said pipeline, said forward collapse unit responsive to said first branch prediction indicating taken and said first branch instruction having a forward branch target address within a predetermined range of a first branch fetch address corresponding to said first branch instruction. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00014\" num=\"14\"><claim-text>14. The processor as recited in claim <b>13</b> wherein said branch scanner is configured to identify a second branch instruction in parallel with identifying said first branch instruction.</claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00015\" num=\"15\"><claim-text>15. The processor as recited in claim <b>14</b> wherein said branch history table is configured to select a second branch prediction responsive to said second branch instruction.</claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00016\" num=\"16\"><claim-text>16. The processor as recited in claim <b>15</b> wherein said forward collapse unit is configured to determine if said second branch instruction is still within said pipeline subsequent to canceling instructions responsive to said first branch instruction.</claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00017\" num=\"17\"><claim-text>17. The processor as recited in claim <b>16</b> wherein said forward collapse unit is configured to indicate: (i) which instructions within said plurality of instructions and subsequent to said second branch instruction to cancel from said pipeline prior to executing said instructions, and (ii) which instructions within said plurality of instructions and subsequent to said second branch instruction to retain in said pipeline, said forward collapse unit responsive to said second branch prediction indicating taken and said second branch instruction having a forward branch target address within said predetermined range of a second branch fetch address corresponding to said second branch instruction.</claim-text></claim>"}, {"num": 18, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00018\" num=\"18\"><claim-text>18. The processor as recited in claim <b>13</b> wherein said forward collapse unit is configured to indicate which instructions to cancel and which instructions to retain by providing a range of addresses of instructions to be cancelled.</claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00019\" num=\"19\"><claim-text>19. The processor as recited in claim <b>18</b> further comprising an instruction queue configured to store said plurality of instructions prior to dispatch thereof, wherein said instruction queue is coupled to said forward collapse unit, and wherein said instruction queue is configured to compare fetch addresses of said plurality of instructions to said range of addresses received from said forward collapse unit and to invalidate instructions having fetch addresses within said range of addresses.</claim-text></claim>"}, {"num": 20, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00020\" num=\"20\"><claim-text>20. The processor as recited in claim <b>13</b> wherein said branch scanner is coupled to receive predecode information including control transfer indications corresponding to said plurality of instructions and wherein said branch scanner is configured to identify said branch instructions by scanning said control transfer indications.</claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00021\" num=\"21\"><claim-text>21. The processor as recited in claim <b>20</b> further comprising an instruction cache coupled to said branch scanner, wherein said instruction cache is configured to store said plurality of instruction bytes and said predecode information, and wherein said processor is configured to fetch said plurality of instruction bytes and said predecode information from said instruction cache.</claim-text></claim>"}, {"num": 22, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00022\" num=\"22\"><claim-text>22. A computer system comprising:</claim-text><claim-text>a processor configured to fetch a plurality of instructions, wherein said processor is configured to identify a first branch instruction within said plurality of instructions, and wherein said processor is configured to: (i) cancel instructions from a pipeline of said processor prior to executing said instructions, and (ii) retain instructions within said plurality of instructions and subsequent to said first branch instruction in said pipeline, said processor configured to cancel and retain instructions responsive to predicting said first branch instruction taken and said first branch instruction having a forward branch target address within a predetermined range of a first branch fetch address corresponding to said first branch instruction; and </claim-text><claim-text>an input/output (I/O) device coupled to said processor, wherein said I/O device is configured to communicate between said computer system and another computer system to which said I/O device is coupled. </claim-text></claim>"}, {"num": 23, "parent": 22, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00023\" num=\"23\"><claim-text>23. The computer system as recited in claim <b>22</b> further comprising a second processor configured to fetch a plurality of instructions, wherein said second processor is configured to identify a first branch instruction within said plurality of instructions, and wherein said processor is configured to: (i) cancel instructions from a pipeline of said processor prior to executing said instructions, and (ii) retain instructions within said plurality of instructions and subsequent to said first branch instruction in said pipeline, said second processor configured to cancel and retain instructions responsive to predicting said first branch instruction taken and said first branch instruction having a forward branch target address within a predetermined range of a first branch fetch address corresponding to said first branch instruction.</claim-text></claim>"}, {"num": 24, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00024\" num=\"24\"><claim-text>24. A processor comprising:</claim-text><claim-text>a branch prediction circuit configured to identify a first branch instruction within a plurality of instructions and to predict said first branch instruction; and </claim-text><claim-text>a first circuit coupled to said branch prediction circuit, wherein said first circuit is configured, responsive to said first branch instruction having a forward target address within a predetermined range of a first branch fetch address corresponding to said first branch instruction and said branch prediction circuit predicting said first branch instruction taken: (i) to cancel a first one or more instructions within said plurality of instructions from a pipeline of said processor prior to executing said first one or more instructions, said first one or more instructions having fetch addresses between said first branch fetch address and said forward target address, and (ii) to retain a second one or more instructions in said pipeline, said second one or more instructions within said plurality of instructions and having fetch addresses which are not between said first branch fetch address and said forward target address. </claim-text></claim>"}, {"num": 25, "parent": 24, "type": "dependent", "paragraph_markup": "<claim id=\"US-6256728-B1-CLM-00025\" num=\"25\"><claim-text>25. The processor as recited in claim <b>24</b> wherein said plurality of instructions includes a second branch instruction subsequent to said first branch instruction, and wherein said branch prediction circuit is configured to predict said second branch instruction, and wherein said first circuit is configured to cancel and retain instructions responsive to said second branch instruction being predicted taken if said second branch instruction is retained in said pipeline responsive to said first branch instruction being predicted taken.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54596668\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This Application claims benefit of priority to the Provisional Application serial No. 60/065,878, entitled \u201cHigh Frequency, Wide Issue Microprocessor\u201d filed on Nov. 17, 1997 by Witt. The Provisional Application is incorporated herein by reference in its entirety.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention is related to the field of processors and, more particularly, to branch prediction and fetch mechanisms within processors.</p><p>2. Description of the Related Art</p><p>Superscalar processors attempt to achieve high performance by dispatching and executing multiple instructions per clock cycle, and by operating at the shortest possible clock cycle time consistent with the design. To the extent that a given processor is successful at dispatching and/or executing multiple instructions per clock cycle, high performance may be realized. In order to increase the average number of instructions dispatched per clock cycle, processor designers have been designing superscalar processors which employ wider issue rates. A \u201cwide issue\u201d superscalar processor is capable of dispatching (or issuing) a larger maximum number of instructions per clock cycle than a \u201cnarrow issue\u201d superscalar processor is capable of dispatching. During clock cycles in which a number of dispatchable instructions is greater than the narrow issue processor can handle, the wide issue processor may dispatch more instructions, thereby achieving a greater average number of instructions dispatched per clock cycle.</p><p>In order to support wide issue rates, it is desirable for the superscalar processor to be capable of fetching a large number of instructions per clock cycle (on the average). For brevity, a processor capable of fetching a large number of instructions per clock cycle (on the average) will be referred to herein as having a \u201chigh fetch bandwidth\u201d. If the superscalar processor is unable to achieve a high fetch bandwidth, then the processor may be unable to take advantage of the wide issue hardware due to a lack of instructions being available for issue.</p><p>Several factors may impact the ability of a particular processor to achieve a high fetch bandwidth. For example, many code sequences have a high frequency of branch instructions, which may redirect the fetching of subsequent instructions within that code sequence to a branch target address specified by the branch instruction. Accordingly, the processor may identify the branch target address after fetching the branch instruction. Subsequently, the next instructions within the code sequence may be fetched using the branch target address. Processors attempt to minimize the impact of branch instructions on the fetch bandwidth by employing highly accurate branch prediction mechanisms and by generating the subsequent fetch address (either branch target or sequential) as rapidly as possible.</p><p>As used herein, a branch instruction is an instruction which specifies the address of the next instructions to be fetched. The address may be the sequential address identifying the instruction immediately subsequent to the branch instruction within memory, or a branch target address identifying a different instruction stored elsewhere in memory. Unconditional branch instructions always select the branch target address, while conditional branch instructions select either the sequential address or the branch target address based upon a condition specified by the branch instruction. For example, the processor may include a set of condition codes which indicate the results of executing previous instructions, and the branch instruction may test one or more of the condition codes to determine if the branch selects the sequential address or the target address. A branch instruction is referred to as taken if the branch target address is selected via execution of the branch instruction, and not taken if the sequential address is selected. Similarly, if a conditional branch instruction is predicted via a branch prediction mechanism, the branch instruction is referred to as predicted taken if the branch target address is predicted to be selected upon execution of the branch instruction and is referred to as predicted not taken if the sequential address is predicted to be selected upon execution of the branch instruction.</p><p>Unfortunately, even if highly accurate branch prediction mechanisms are employed, fetch bandwidth may still suffer. Typically, a plurality of instructions are fetched by the processor, and a first branch instruction within the plurality of instructions is detected. Instructions subsequent to the first branch instruction are discarded if the branch instruction is predicted taken, and the branch target address is fetched. Accordingly, the number of instructions fetched during the clock cycle in which a branch instruction is fetched and predicted taken is limited to the number of instructions prior to and including the first branch instruction within the plurality of instructions being fetched. Since branch instructions are frequent in many code sequences, this limitation may be significant. Performance of the processor may be decreased if the limitation to the fetch bandwidth leads to a lack of instructions being available for dispatch. A method for increasing the achievable fetch bandwidth in the presence of predicted taken branch instructions is therefore desired.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by a processor in accordance with the present invention. The processor is configured to detect a branch instruction having a forward branch target address within a predetermined range of the branch fetch address of the branch instruction. If the branch instruction is predicted taken, instead of canceling subsequent instructions and fetching the branch target address, the processor allows sequential fetching to continue and selectively cancels the sequential instructions which are not part of the predicted instruction sequence (i.e. the instructions between the predicted taken branch instruction and the target instruction identified by the forward branch target address). Advantageously, instructions within the predicted instruction sequence which may already have been fetched prior to predicting the branch instruction taken may be retained within the pipeline of the processor, and yet subsequent instructions may be fetched. Higher fetch bandwidth may thereby be achieved, and hence more instructions may be available in wider superscalar processors.</p><p>Broadly speaking, the present invention contemplates a method for fetching instructions in a processor. A plurality of instructions are fetched. A first branch instruction is detected within the plurality of instructions. The first branch instruction has a forward branch target address. The first branch instruction is predicted. Instructions within the plurality of instructions which are between the first branch instruction and a subsequent instruction within the plurality of instructions identified by the forward branch target address are cancelled. The canceling is performed responsive to selecting a taken prediction for the first branch instruction and the forward branch target address being within a predetermined range of a first branch fetch address corresponding to the first branch instruction. Additionally, the subsequent instruction is retained within the plurality of instructions even if the predicting selects the taken prediction responsive to the forward branch target address being within the predetermined range.</p><p>The present invention further contemplates a processor comprising a branch scanner configured to identify a first branch instruction within a plurality of instructions, a branch history table, and a forward collapse unit. Coupled to the branch scanner, the branch history table is configured to select a first branch prediction from a plurality of branch predictions stored therein responsive to the first branch instruction identified by the branch scanner. Coupled to the branch scanner and the branch history table, the forward collapse unit is configured to indicate: (i) which instructions within the plurality of instructions and subsequent to the first branch instruction to cancel, and (ii) which instructions within the plurality of instructions and subsequent to the first branch instruction to retain. The forward collapse unit is responsive to the first branch prediction indicating taken and the first branch instruction having a forward branch target address within a predetermined range of a first branch fetch address corresponding to the first branch instruction.</p><p>Moreover, the present invention contemplates a computer system comprising a processor coupled to an input/output (I/O) device. The processor is configured to fetch a plurality of instructions and to identify a first branch instruction within the plurality of instructions. Additionally, the processor is configured to selectively cancel and retain instructions within the plurality of instructions and subsequent to the first branch instruction responsive to predicting the first branch instruction taken and the first branch instruction having a forward branch target address within a predetermined range of a first branch fetch address corresponding to the first branch instruction. The I/O device is configured to communicate between the computer system and another computer system to which the I/O device is coupled.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of one embodiment of a processor.</p><p>FIG. 2 is a block diagram of one embodiment of a fetch/scan unit shown in FIG. <b>1</b>.</p><p>FIG. 3 is a block diagram of one embodiment of a lookahead/collapse unit shown in FIG. <b>1</b>.</p><p>FIG. 4 is a block diagram of one embodiment of a branch scanner, a branch history table, a forward collapse unit, and an instruction queue.</p><p>FIG. 5 is a flowchart illustrating operation of one embodiment of the forward collapse unit shown in FIGS. 2 and 4.</p><p>FIG. 6 is an example of an instruction run including a branch instruction have a backward branch target address.</p><p>FIG. 7 is an example of an instruction run including a branch instruction have a forward branch target address.</p><p>FIG. 8 is an example of an instruction run including a branch instruction have a forward branch target address and a second branch instruction have a backward branch target address.</p><p>FIG. 9 is an example of an instruction run including a branch instruction have a forward branch target address and a second branch instruction have in forward branch target address.</p><p>FIG. 10 is an example of an instruction run including a branch instruction have a forward branch target address which is outside of the run.</p><p>FIG. 11 is a timing diagram illustrating the fetch of instructions including a branch instruction having a forward target address and the fetch of subsequent instructions.</p><p>FIG. 12 is a block diagram of one embodiment of an instruction queue shown in FIG. <b>1</b>.</p><p>FIG. 13 is a block diagram of a computer system including the processor shown in FIG. <b>1</b>.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>Turning now to FIG. 1, a block diagram of one embodiment of a superscalar processor <b>10</b> is shown. Other embodiments are possible and contemplated. In the embodiment shown in FIG. 1, processor <b>10</b> includes a predecode unit <b>12</b>, an L<b>1</b> I-cache <b>14</b>, an L<b>0</b> I-cache <b>16</b>, a fetch/scan unit <b>18</b>, an instruction queue <b>20</b>, an alignment unit <b>22</b>, a lookahead/collapse unit <b>24</b>, a future file <b>26</b>, a reorder buffer/register file <b>28</b>, a first instruction window <b>30</b>A, a second instruction window <b>30</b>B, a plurality of functional units <b>32</b>A, <b>32</b>B, <b>32</b>C, and <b>32</b>D, a plurality of address generation units <b>34</b>A, <b>34</b>B, <b>34</b>C, and <b>34</b>D, a load/store unit <b>36</b>, an L<b>1</b> D-cache <b>38</b>, an FPU/multimedia unit <b>40</b>, and an external interface unit <b>42</b>. Elements referred to herein by a particular reference number followed by various letters will be collectively referred to using the reference number alone. For example, functional units <b>32</b>A, <b>32</b>B, <b>32</b>C, and <b>32</b>D will be collectively referred to as functional units <b>32</b>.</p><p>In the embodiment of FIG. 1, external interface unit <b>42</b> is coupled to predecode unit <b>12</b>, L<b>1</b> D-cache <b>38</b>, an L<b>2</b> interface <b>44</b>, and a bus interface <b>46</b>. Predecode unit <b>12</b> is further coupled to L<b>1</b> I-cache <b>14</b>. L<b>1</b> I-cache <b>14</b> is coupled to L<b>0</b> I-cache <b>16</b> and to fetch/scan unit <b>18</b>. Fetch/scan unit <b>18</b> is also coupled to L<b>0</b> I-cache <b>16</b> and to instruction queue <b>20</b>. Instruction queue <b>20</b> is coupled to alignment unit <b>22</b>, which is further coupled to lookahead/collapse unit <b>24</b>. Lookahead/collapse unit <b>24</b> is further coupled to future file <b>26</b>, reorder buffer/register file <b>28</b>, load/store unit <b>36</b>, first instruction window <b>30</b>A, second instruction window <b>30</b>B, and FPU/multimedia unit <b>40</b>. FPU/multimedia unit <b>40</b> is coupled to load/store unit <b>36</b> and to reorder buffer/register file <b>28</b>. Load/store unit <b>36</b> is coupled to L<b>1</b> D-cache <b>38</b>. First instruction window <b>30</b>A is coupled to functional units <b>32</b>A-<b>32</b>B and to address generation units <b>34</b>A-<b>34</b>B. Similarly, second instruction window <b>30</b>B is coupled to functional units <b>32</b>C-<b>32</b>D and address generation units <b>34</b>C-<b>34</b>D. Each of L<b>1</b> D-cache <b>38</b>, functional units <b>32</b>, and address generation units <b>34</b> are coupled to a plurality of result buses <b>48</b> which are further coupled to load/store unit <b>36</b>, first instruction window <b>30</b>A, second instruction window <b>30</b>B, reorder buffer/register file <b>28</b>, and future file <b>26</b>.</p><p>Generally speaking, processor <b>10</b> is configured a fetch instructions from L<b>0</b> I-cache <b>16</b>. Fetch/scan unit <b>18</b> is configured to scan the instructions in order to detect the branch instructions included therein, and is further configured to predict the detected branch instructions. If a branch instruction is predicted taken and has a forward branch target address, fetch/scan unit <b>18</b> is configured to selectively cancel one or more of the instructions subsequent to the predicted branch instruction while retaining other ones of the instructions subsequent to the predicted branch instruction. More particularly, if the forward branch target address is within a predetermined range of the branch fetch address of the corresponding branch instruction, the instructions between the predicted branch instruction and a subsequent instruction within the plurality instructions which is stored at the forward branch target address are cancelled while the subsequent instruction and any succeeding instructions within the plurality of instructions are retained. Instead of fetching the forward branch target address from L<b>0</b> I-cache <b>16</b>, the sequential address is fetched as one or more of the instructions at the target address have already been fetched concurrent with the branch instruction and have been retained within the pipeline of processor <b>10</b>.</p><p>Advantageously, the achievable fetch bandwidth may be improved by retaining target instructions which are fetched concurrently with the branch instruction having the forward branch target address. Instead of discarding the target instructions which have already been fetched and fetching those target instructions during a subsequent fetch using the forward branch target address, the target instructions are retained and instructions sequential to the previously fetched target instructions are fetched.</p><p>In one embodiment, fetch/scan unit <b>18</b> is configured to detect and predict up to two branch instructions within a run of instructions fetched from for L<b>0</b> I-cache <b>16</b> during a clock cycle. If the first detected branch instruction is predicted taken and has a forward branch target address, instructions are selectively cancelled as described above. Fetch/scan unit <b>18</b> then determines if the second detected branch instruction is still within the run of instructions (i.e. the second branch instruction was not cancelled). If the second detected branch instruction was not cancelled, is predicted taken, and has a forward branch target address, instructions subsequent to the second detected branch instruction are selectively cancelled and retained in a manner similar to the processing of the first detected branch instruction. Advantageously, up to two branch instructions may be predicted per fetch, and fetch bandwidth may be even further increased.</p><p>As used herein, the term \u201cforward branch target address\u201d refers to a branch target address which is numerically greater than the fetch address of the branch instruction specifying the branch target address. The fetch address of the branch instruction (or \u201cbranch fetch address\u201d) is the address at which the branch instruction is stored. Furthermore, the term canceling instructions refers to invalidating the instructions within the pipeline subsequent to fetching the instructions. For example, the instructions may be invalidated within instruction queue <b>20</b>. The term \u201csquashing instructions\u201d may also be used herein to refer to canceling the instructions. An instruction is referred to as being between a branch instruction and a subsequent target instruction if the instruction is stored at a fetch address which is numerically greater than the branch fetch address and numerically less then the branch target address specified by the branch instruction stored at the branch fetch address. Additionally, a forward target address is \u201cwithin a predetermined range\u201d of the corresponding branch fetch address if the difference between the branch fetch address and the branch target address is less than or equal to a predetermined value (e.g. 64 bytes, in one embodiment).</p><p>Predecode unit <b>12</b> receives instruction bytes fetched by external interface unit <b>42</b> and predecodes the instruction bytes prior to their storage within L<b>1</b> I-cache <b>14</b>. Predecode information generated by predecode unit <b>12</b> is stored in L<b>1</b> I-cache <b>14</b> as well. Generally, predecode information is provided to aid in the identification of instruction features which may be useful during the fetch and issue of instructions but which may be difficult to generate rapidly during the fetch and issue operation. The term \u201cpredecode\u201d, as used herein, refers to decoding instructions to generate predecode information which is later stored along with the instruction bytes being decoded in an instruction cache (e.g. L<b>1</b> I-cache <b>14</b> and/or L<b>0</b> I-cache <b>16</b>).</p><p>In one embodiment, processor <b>10</b> employs two bits of predecode information per instruction byte. One of the bits, referred to as the \u201cstart bit\u201d, indicates whether or not the instruction byte is the initial byte of an instruction. When a group of instruction bytes is fetched, the corresponding set of start bits identifies the boundaries between instructions within the group of instruction bytes. Accordingly, multiple instructions may be concurrently selected from the group of instruction bytes by scanning the corresponding start bits. While start bits are used to locate instruction boundaries by identifying the initial byte of each instruction, end bits could alternatively be used to locate instruction boundaries by identifying the final byte of each instruction.</p><p>The second predecode bit used in this embodiment, referred to as the \u201ccontrol transfer\u201d bit, identifies which instructions are branch instructions. The control transfer bit corresponding to the initial byte of an instruction indicates whether or not the instruction is a branch instruction. The control transfer bit corresponding to subsequent bytes of the instruction is a don't care except for relative branch instructions having a small displacement field. According to one particular embodiment, the small displacement field is an 8 bit field. Generally, a \u201csmall displacement field\u201d refers to a displacement field having fewer bits than the target address generated by branch instructions. For relative branch instructions having small displacement fields, the control transfer bit corresponding to the displacement byte is used as described below.</p><p>In addition to generating predecode information corresponding to the instruction bytes, predecode unit <b>12</b> is configured to recode the displacement field of relative branch instructions to actually store the target address in the present embodiment. In other words, predecode unit <b>12</b> adds the displacement of the relative branch instruction to the address corresponding to the relative branch instruction as defined by the instruction set employed by processor <b>10</b>. The resulting target address is encoded into the displacement field as a replacement for the displacement, and the updated displacement field is stored into L<b>1</b> I-cache <b>14</b> instead of the original displacement field. Target address generation is simplified by precomputing relative target addresses, and hence the branch prediction mechanism may operate more efficiently.</p><p>In one embodiment of processor <b>10</b> which employs the x86 instruction set, predecode unit <b>12</b> is configured to recode eight bit and 32 bit displacement fields. The 32 bit displacement fields may store the entirety of the target address. On the other hand, the eight bit displacement field is encoded. More particularly, the eight bit displacement field and corresponding control transfer predecode bit is divided into a cache line offset portion and a relative cache line portion. The cache line offset portion is the cache line offset portion of the target address. The relative cache line portion defines the cache line identified by the target address (the \u201ctarget cache line\u201d) in terms of a number of cache lines above or below the cache line storing the relative branch instruction. A first cache line is above a second cache line if each byte within the first cache line is stored at an address which is numerically greater than the addresses at which the bytes within the second cache line are stored. Conversely, a first cache line is below the second cache line if each byte within the first cache line is stored at an address which is numerically less than the addresses at which the bytes within a second cache line are stored. A signed eight bit displacement specifies an address which is +/\u2212128 bytes of the address corresponding to the branch instruction. Accordingly, the number of above and below cache lines which can be reached by a relative branch instruction having an eight bit displacement is limited. The relative cache line portion encodes this limited set of above and below cache lines. Generally, branch instructions having a small displacement field have displacements within a predefined range, whereas larger displacement fields may store values outside the predefined range.</p><p>Tables 1 and 2 below illustrates an exemplary encoding of the predecode information corresponding to a byte in accordance with one embodiment of processor <b>10</b>.</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE 1</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Predecode Encoding</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"63PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"126PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">Start Bit</entry><entry morerows=\"0\" valign=\"top\">Control Transfer Bit</entry><entry morerows=\"0\" valign=\"top\">Meaning</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">Start byte of an instruction which is not a</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">branch.</entry></row><row><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">Start byte of a branch instruction.</entry></row><row><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">x</entry><entry morerows=\"0\" valign=\"top\">Not an instruction boundary. Control</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Transfer Bit corresponding to</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">displacement is used on 8-bit relative</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">branches to encode target address as</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">shown in Table 2 below.</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p><tables id=\"TABLE-US-00002\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE 2</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Target Address Encoding</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"91PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"91PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">Control</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Transfer</entry><entry morerows=\"0\" valign=\"top\">Displacement Byte</entry></row><row><entry morerows=\"0\" valign=\"top\">Bit</entry><entry morerows=\"0\" valign=\"top\">Most Significant Bits (binary)</entry><entry morerows=\"0\" valign=\"top\">Meaning</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">00</entry><entry morerows=\"0\" valign=\"top\">Within Current Cache Line</entry></row><row><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">01</entry><entry morerows=\"0\" valign=\"top\">One Cache Line Above</entry></row><row><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">10</entry><entry morerows=\"0\" valign=\"top\">Two Cache Lines Above</entry></row><row><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">01</entry><entry morerows=\"0\" valign=\"top\">One Cache Line Below</entry></row><row><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">10</entry><entry morerows=\"0\" valign=\"top\">Two Cache Lines Below</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry align=\"left\" morerows=\"0\" nameend=\"3\" namest=\"1\" valign=\"top\">Note: Remaining displacement byte bits are the offset within the target cache line. Control Transfer Bit is effectively a direction, and the most significant bits of the displacement byte are the number of cache lines. </entry></row></tbody></tgroup></table></tables></p><p>Predecode unit <b>12</b> conveys the received instruction bytes and corresponding predecode information to L<b>1</b> I-cache <b>14</b> for storage. L<b>1</b> I-cache <b>14</b> is a high speed cache memory for storing instruction bytes and predecode information. L<b>1</b> I-cache <b>14</b> may employ any suitable configuration, including direct mapped and set associative configurations. In one particular embodiment, L<b>1</b> I-cache <b>14</b> is a 128 KB, two way set associative cache employing 64 byte cache lines. L<b>1</b> I-cache <b>14</b> includes additional storage for the predecode information corresponding to the instruction bytes stored therein. The additional storage is organized similar to the instruction bytes storage. As used herein, the term \u201ccache line\u201d refers to the unit of allocation of storage in a particular cache. Generally, the bytes within a cache line are manipulated (i.e. allocated and deallocated) by the cache as a unit.</p><p>In one embodiment, L<b>1</b> I-cache <b>14</b> is linearly addressed and physically tagged. A cache is linearly addressed if at least one of the address bits used to index the cache is a linear address bit which is subsequently translated to a physical address bit. The tags of a linearly address/physically tagged cache include each translated bit in addition to the bits not used to index. As specified by the x86 architecture, instructions are defined to generate logical addresses which are translated through a segmentation translation mechanism to a linear address and further translated through a page translation mechanism to a physical address. It is becoming increasingly common to employ flat addressing mode, in which the logical address and corresponding linear address are equal. Processor <b>10</b> may be configured to assume flat addressing mode. Accordingly, fetch addresses, target addresses, etc. as generated by executing instructions are linear addresses. In order to determine if a hit is detected in L<b>1</b> I-cache <b>14</b>, the linear address presented thereto by fetch/scan unit <b>18</b> is translated using a translation lookaside buffer (TLB) to a corresponding physical address which is compared to the physical tags from the indexed cache lines to determine a hit/miss. When flat addressing mode is not used, processor <b>10</b> may still execute code but additional clock cycles may be used to generate linear addresses from logical addresses.</p><p>L<b>0</b> I-cache <b>16</b> is also a high speed cache memory for storing instruction bytes. Because L<b>1</b> I-cache <b>14</b> is large, the access time of L<b>1</b> I-cache <b>14</b> may be large. In one particular embodiment, L<b>1</b> I-cache <b>14</b> uses a two clock cycle access time. In order to allow for single cycle fetch access, L<b>0</b> I-cache <b>16</b> is employed. L<b>0</b> I-cache <b>16</b> is comparably smaller than L<b>1</b> I-cache <b>14</b>, and hence may support a more rapid access time. In one particular embodiment, L<b>0</b> I-cache <b>16</b> is a 512 byte fully associative cache. Similar to L<b>1</b> I-cache <b>14</b>, L<b>0</b> I-cache <b>16</b> is configured to store cache lines of instruction bytes and corresponding predecode information (e.g. 512 bytes stores eight 64 byte cache lines and corresponding predecode data is stored in additional storage). In one embodiment, L<b>0</b> I-cache <b>16</b> may be linearly addressed and linearly tagged.</p><p>Fetch/scan unit <b>18</b> is configured to generate fetch addresses for L<b>0</b> I-cache <b>16</b> and fetch or prefetch addresses for L<b>1</b> I-cache <b>14</b>. Instructions fetched from L<b>0</b> I-cache <b>16</b> are scanned by fetch/scan unit <b>18</b> to identify instructions for dispatch as well as to locate branch instructions and to form branch predictions corresponding to the located branch instructions. Instruction scan information and corresponding instruction bytes are stored into instruction queue <b>20</b> by fetch/scan unit <b>18</b>. Additionally, the identified branch instructions and branch predictions are used to generate subsequent fetch addresses for L<b>0</b> I-cache <b>16</b>.</p><p>Fetch/scan unit <b>18</b> employs a prefetch algorithm to attempt to prefetch cache lines from L<b>1</b> I-cache <b>14</b> to L<b>0</b> I-cache <b>16</b> prior to the prefetched cache lines being fetched by fetch/scan unit <b>18</b> for dispatch into processor <b>10</b>. Any suitable prefetch algorithm may be used. One embodiment of the prefetch algorithm is set forth in more detail below.</p><p>Fetch/scan unit <b>18</b> employs an aggressive branch prediction mechanism in attempt to fetch larger \u201cruns\u201d of instructions during a clock cycle. As used herein, a \u201crun\u201d of instructions is a set of one or more instructions predicted to be executed in the sequence specified within the set. For example, fetch/scan unit <b>18</b> may fetch runs of 24 instruction bytes from L<b>0</b> I-cache <b>16</b>. Each run is divided into several sections which fetch/scan unit <b>18</b> scans in parallel to identify branch instructions and to generate instruction scan information for instruction queue <b>20</b>. According to one embodiment, fetch/scan unit <b>18</b> attempts to predict up to two branch instructions per clock cycle in order support large instruction runs.</p><p>Instruction queue <b>20</b> is configured to store instruction bytes provided by fetch/scan unit <b>18</b> for subsequent dispatch. Instruction queue <b>20</b> may operate as a first-in, first-out (FIFO) buffer. In one embodiment, instruction queue <b>20</b> is configured to store multiple entries, each entry comprising: a run of instructions, scan data identifying up to five instructions within each section of the run, and addresses corresponding to each section of the run. Additionally, instruction queue <b>20</b> may be configured to select up to six instructions within up to four consecutive run sections for presentation to alignment unit <b>22</b>. Instruction queue <b>20</b> may, for example, employ 2-3 entries.</p><p>Alignment unit <b>22</b> is configured to route instructions identified by instruction queue <b>20</b> to a set of issue positions within lookahead/collapse unit <b>24</b>. In other words, alignment unit <b>22</b> selects the bytes which form each instruction from the run sections provided by instruction queue <b>20</b> responsive to the scan information provided by instruction queue <b>20</b>. The instructions are provided into the issue positions in program order (i.e. the instruction which is first in program order is provided to the first issue position, the second instruction in program order is provided to the second issue position, etc.).</p><p>Lookahead/collapse unit <b>24</b> decodes the instructions provided by alignment unit <b>22</b>. FPU/multimedia instructions detected by lookahead/collapse unit <b>24</b> are routed to FPU/multimedia unit <b>40</b>. Other instructions are routed to first instruction window <b>30</b>A, second instruction window <b>30</b>B, and/or load/store unit <b>36</b>. In one embodiment, a particular instruction is routed to one of first instruction window <b>30</b>A or second instruction window <b>30</b>B based upon the issue position to which the instruction was aligned by alignment unit <b>22</b>. According to one particular embodiment, instructions from alternate issue positions are routed to alternate instruction windows <b>30</b>A and <b>30</b>B. For example, instructions from issue positions zero, two, and four may be routed to the first instruction window <b>30</b>A and instructions from issue positions one, three, and five may be routed to the second instruction window <b>30</b>B. Instructions which include a memory operation are also routed to load/store unit <b>36</b> for access to L<b>1</b> D-cache <b>38</b>.</p><p>Additionally, lookahead/collapse unit <b>24</b> attempts to generate lookahead addresses or execution results for certain types of instructions. Lookahead address/result generation may be particularly beneficial for embodiments employing the x86 instruction set. Because of the nature the x86 instruction set, many of the instructions in a typical code sequence are versions of simple moves. One reason for this feature is that x86 instructions include two operands, both of which are source operands and one of which is a destination operand. Therefore, one of the source operands of each instruction is overwritten with an execution result. Furthermore, the x86 instruction set specifies very few registers for storing register operands. Accordingly, many instructions are moves of operands to and from a stack maintained within memory. Still further, many instruction dependencies are dependencies upon the ESP/EBP registers and yet many of the updates to these registers are increments and decrements of the previously stored values.</p><p>To accelerate the execution of these instructions, lookahead/collapse unit <b>24</b> generates lookahead copies of the ESP and EBP registers for each of instructions decoded during a clock cycle. Additionally, lookahead/collapse unit <b>24</b> accesses future file <b>26</b> for register operands selected by each instruction. For each register operand, future file <b>26</b> may be storing either an execution result or a tag identifying a reorder buffer result queue entry corresponding to the most recent instruction having that register as a destination operand.</p><p>In one embodiment, lookahead/collapse unit <b>24</b> attempts to perform an address calculation for each instruction which: (i) includes a memory operand; and (ii) register operands used to form the address of the memory operand are available from future file <b>26</b> or lookahead copies of ESP/EBP. Additionally, lookahead/collapse unit <b>24</b> attempts to perform a result calculation for each instruction which: (i) does not include a memory operand; (ii) specifies an add/subtract operation (including increment and decrement); and (iii) register operands are available from future file <b>26</b> or lookahead copies of ESP/EBP. In this manner, many simple operations may be completed prior to instructions being sent to instruction windows <b>30</b>A-<b>30</b>B.</p><p>Lookahead/collapse unit <b>24</b> detects dependencies between a group of instructions being dispatched and collapses any execution results generated therein into instructions dependent upon those instruction results. Additionally, lookahead/collapse unit <b>24</b> updates future file <b>26</b> with the lookahead execution results. Instruction operations which are completed by lookahead/collapse unit <b>24</b> (i.e. address generations and/or instruction results are generated and load/store unit <b>36</b> or future file <b>26</b> and the result queue are updated) are not dispatched to instruction windows <b>30</b>A-<b>30</b>B.</p><p>Lookahead/collapse unit <b>24</b> allocates a result queue entry in reorder buffer/register file <b>28</b> for each instruction dispatched. In one particular embodiment, reorder buffer/register file <b>28</b> includes a result queue organized in a line-oriented fashion in which storage locations for execution results are allocated and deallocated in lines having enough storage for execution results corresponding to a maximum number of concurrently dispatchable instructions. If less than the maximum number of instructions are dispatched, then certain storage locations within the line are empty. Subsequently dispatched instructions use the next available line, leaving the certain storage locations empty. In one embodiment, the result queue includes 40 lines, each of which may store up to six execution results corresponding to concurrently dispatched instructions. Execution results are retired from the result queue in order into the register file included within reorder buffer/register file <b>28</b>. Additionally, the reorder buffer handles branch mispredictions, transmitting the corrected fetch address generated by the execution of the branch instruction to fetch/scan unit <b>18</b>. Similarly, instructions which generate other exceptions are handled within the reorder buffer. Results corresponding to instructions subsequent to the exception-generating instruction are discarded by the reorder buffer. The register file comprises a storage location for each architected register. For example, the x86 instruction set defines 8 architected registers. The register file for such an embodiment includes eight storage locations. The register file may further include storage locations used as temporary registers by a microcode unit in embodiments employing microcode units.</p><p>Future file <b>26</b> maintains the speculative state of each architected register as instructions are dispatched by lookahead/collapse unit <b>24</b>. As an instruction having a register destination operand is decoded by lookahead/collapse unit <b>24</b>, the tag identifying the storage location within the result queue portion of reorder buffer/register file <b>28</b> assigned to the instruction is stored into the future file <b>26</b> storage location corresponding to that register. When the corresponding execution result is provided, the execution result is stored into the corresponding storage location (assuming that a subsequent instruction which updates the register has not been dispatched).</p><p>It is noted that, in one embodiment, a group of up to six instructions is selected from instruction queue <b>20</b> and moves through the pipeline within lookahead/collapse unit <b>24</b> as a unit. If one or more instructions within the group generates a stall condition, the entire group stalls. An exception to this rule is if lookahead/collapse unit <b>24</b> generates a split line condition due to the number of ESP updates within the group). Such a group of instructions is referred to as a \u201cline\u201d of instructions herein.</p><p>Instruction windows <b>30</b> receive instructions from lookahead/collapse unit <b>24</b>. Instruction windows <b>30</b> store the instructions until the operands corresponding to the instructions are received, and then select the instructions for execution. Once the address operands of an instruction including a memory operation have been received, the instruction is transmitted to one of the address generation units <b>34</b>. Address generation units <b>34</b> generate an address from the address operands and forward the address to load/store unit <b>36</b>. On the other hand, once the execution operands of an instruction have been received, the instruction is transmitted to one of the functional units <b>32</b> for execution. In one embodiment, each integer window <b>30</b>A-<b>30</b>B includes 25 storage locations for instructions. Each integer window <b>30</b>A-<b>30</b>B is configured to select up to two address generations and two functional unit operations for execution each clock cycle in the address generation units <b>34</b> and functional units <b>32</b> connected thereto. In one embodiment, instructions fetched from L<b>0</b> I-cache <b>16</b> remain in the order fetched until stored into one of instruction windows <b>30</b>, at which point the instructions may be executed out of order.</p><p>In embodiments of processor <b>10</b> employing the x86 instruction set, an instruction may include implicit memory operations for load/store unit <b>36</b> as well as explicit functional operations for functional units <b>32</b>. Instructions having no memory operand do not include any memory operations, and are handled by functional units <b>32</b>. Instructions having a source memory operand and a register destination operand include an implicit load memory operation handled by load/store unit <b>36</b> and an explicit functional operation handled by functional units <b>32</b>. Instructions having a memory source/destination operand include implicit load and store memory operations handled by load/store unit <b>36</b> and an explicit functional operation handled by functional units <b>32</b>. Finally, instructions which do not have an explicit functional operation are handled by load/store unit <b>36</b>. Each memory operation results in an address generation handled either by lookahead/collapse unit <b>24</b> or address generation units <b>34</b>. Memory operations and instructions (i.e. functional operations) may be referred to herein separately, but may be sourced from a single instruction.</p><p>Address generation units <b>34</b> are configured to perform address generation operations, thereby generating addresses for memory operations in load/store unit <b>36</b>. The generated addresses are forwarded to load/store unit <b>36</b> via result buses <b>48</b>. Functional units <b>32</b> are configured to perform integer arithmetic/logical operations and execute branch instructions. Execution results are forwarded to future file <b>26</b>, reorder buffer/register file <b>28</b>, and instruction windows <b>30</b>A-<b>30</b>B via result buses <b>48</b>. Address generation units <b>34</b> and functional units <b>32</b> convey the result queue tag assigned to the instruction being executed upon result buses <b>48</b> to identify the instruction being executed. In this manner, future file <b>26</b>, reorder buffer/register file <b>28</b>, instruction windows <b>30</b>A-<b>30</b>B, and load/store unit <b>36</b> may identify execution results with the corresponding instruction. FPU/multimedia unit <b>40</b> is configured to execute floating point and multimedia instructions.</p><p>Load/store unit <b>36</b> is configured to interface with L<b>1</b> D-cache <b>38</b> to perform memory operations. A memory operation is a transfer of data between processor <b>10</b> and an external memory. The memory operation may be an explicit instruction, or may be implicit portion of an instruction which also includes operations to be executed by functional units <b>32</b>. Load memory operations specify a transfer of data from external memory to processor <b>10</b>, and store memory operations specify a transfer of data from processor <b>10</b> to external memory. If a hit is detected for a memory operation within L<b>1</b> D-cache <b>38</b>, the memory operation is completed therein without access to external memory. Load/store unit <b>36</b> may receive addresses for memory operations from lookahead/collapse unit <b>24</b> (via lookahead address calculation) or from address generation units <b>34</b>. In one embodiment, load/store unit <b>36</b> is configured perform up to three memory operations per clock cycle to L<b>1</b> D-cache <b>38</b>. For this embodiment, load/store unit <b>36</b> may be configured to buffer up to <b>30</b> load/store memory operations which have not yet accessed D-cache <b>38</b>. The embodiment may further be configured to include a 96 entry miss buffer for buffering load memory operations which miss D-cache <b>38</b> and a 32 entry store data buffer. Load/store unit <b>36</b> is configured to perform memory dependency checking between load and store memory operations.</p><p>L<b>1</b> D-cache <b>38</b> is a high speed cache memory for storing data. Any suitable configuration may be used for L<b>1</b> D-cache <b>38</b>, including set associative and direct mapped configurations. In one particular embodiment, L<b>1</b> D-cache <b>38</b> is a 128 KB two way set associative cache employing 64 byte lines. L<b>1</b> D-cache <b>38</b> may be organized as, for example, 32 banks of cache memory per way. Additionally, L<b>1</b> D-cache <b>38</b> may be a linearly addressed/physically tagged cache employing a TLB similar to L<b>1</b> I-cache <b>14</b>.</p><p>External interface unit <b>42</b> is configured to transfer cache lines of instruction bytes and data bytes into processor <b>10</b> in response to cache misses. Instruction cache lines are routed to predecode unit <b>12</b>, and data cache lines are routed to L<b>1</b> D-cache <b>38</b>. Additionally, external interface unit <b>42</b> is configured to transfer cache lines discarded by L<b>1</b> D-cache <b>38</b> to memory if the discarded cache lines have been modified to processor <b>10</b>. As shown in FIG. 1, external interface unit <b>42</b> is configured to interface to an external L<b>2</b> cache via L<b>2</b> interface <b>44</b> as well as to interface to a computer system via bus interface <b>46</b>. In one embodiment, bus interface unit <b>46</b> comprises an EV/6 bus interface.</p><p>Turning now to FIG. 2, a block diagram of one embodiment of fetch/scan unit <b>18</b> is shown. Other embodiments are possible and contemplated. As shown in FIG. 2, fetch/scan unit <b>18</b> includes a fetch control unit <b>50</b>, a plurality of select next blocks <b>52</b>A-<b>52</b>C, an instruction select multiplexor (mux) <b>54</b>, an instruction scanner <b>56</b>, a branch scanner <b>58</b>, a branch history table <b>60</b>, a branch select mux <b>62</b>, a return stack <b>64</b>, an indirect address cache <b>66</b>, and a forward collapse unit <b>68</b>. Fetch control unit <b>50</b> is coupled to L<b>1</b> I-cache <b>14</b>, L<b>0</b> I-cache <b>16</b>, indirect address cache <b>66</b>, return stack <b>64</b>, branch history table <b>60</b>, branch scanner <b>58</b>, and instruction select mux <b>54</b>. Select next block <b>52</b>A is coupled to L<b>1</b> I-cache <b>14</b>, while select next blocks <b>52</b>B-<b>52</b>C are coupled to L<b>0</b> I-cache <b>16</b>. Each select next block <b>52</b> is coupled to instruction select mux <b>54</b>, which is further coupled to branch scanner <b>58</b> and instruction scanner <b>56</b>. Instruction scanner <b>56</b> is coupled to instruction queue <b>20</b>. Branch scanner <b>58</b> is coupled to branch history table <b>60</b>, return stack <b>64</b>, and branch select mux <b>62</b>. Branch select mux <b>62</b> is coupled to indirect address cache <b>66</b>. Branch history table <b>60</b> and branch scanner <b>58</b> are coupled to forward collapse unit <b>68</b>, which is coupled to instruction queue <b>20</b>.</p><p>Fetch control unit <b>50</b> receives branch prediction information (including target addresses and taken/not taken predictions) from branch scanner <b>58</b>, branch history table <b>60</b>, return stack <b>64</b>, and indirect address cache <b>66</b>. Responsive to the branch prediction information, fetch control unit <b>50</b> generates fetch addresses for L<b>0</b> I-cache <b>16</b> and a fetch or a prefetch address for L<b>1</b> I-cache <b>14</b>. In one embodiment, fetch control unit <b>50</b> generates two fetch addresses for L<b>0</b> I-cache <b>16</b>. The first fetch address is selected as the target address corresponding to the first branch instruction identified by branch scanner <b>58</b> (if any). The second fetch address is the sequential address to the fetch address selected in the previous clock cycle (i.e. the fetch address corresponding to the run selected by instruction select mux <b>54</b>).</p><p>L<b>0</b> I-cache <b>14</b> provides the cache lines (and predecode information) corresponding to the two fetch addresses, as well as the cache lines (and predecode information) which are sequential to each of those cache lines, to select next blocks <b>52</b>B-<b>52</b>C. More particularly, select next block <b>52</b>B receives the sequential cache line corresponding to the sequential address and the next incremental cache line to the sequential cache line. Select next block <b>52</b>C receives the target cache line corresponding to the target address as well as the cache line sequential to the target cache line. Additionally, select next blocks <b>52</b>B-<b>52</b>C receive the offset portion of the corresponding fetch address. Select next blocks <b>52</b>B-<b>52</b>C each select a run of instruction bytes (and corresponding predecode information) from the received cache lines, beginning with the run section including the offset portion of the corresponding fetch address. Since the offset portion of each fetch address can begin anywhere within the cache line, the selected run may included portions of the fetched cache line and the sequential cache line to the fetched cache line. Hence, both the fetched cache line and the sequential cache line are received by select next blocks <b>52</b>B-<b>52</b>C.</p><p>Similarly, select next block <b>52</b>A receives a prefetched cache line (and corresponding predecode information) from L<b>1</b> I-cache <b>14</b> and selects an instruction run therefrom. Since one cache line is prefetched from L<b>1</b> I-cache <b>14</b>, the run selected therefrom may comprise less than a full run if the offset portion of the prefetch address is near the end of the cache line. It is noted that the fetch cache lines from L<b>0</b> I-cache <b>16</b> may be provided in the same clock cycle as the corresponding addresses are generated by fetch control unit <b>50</b>, but the prefetch cache line may be a clock cycle delayed due to the larger size and slower access time of L<b>1</b> I-cache <b>14</b>. In addition to providing the prefetched cache line to select next block <b>52</b>A, L<b>1</b> I-cache <b>14</b> provides the prefetched cache line to L<b>0</b> I-cache <b>16</b>. If the prefetched cache line is already stored within L<b>0</b> I-cache <b>16</b>, L<b>0</b> I-cache <b>16</b> may discard the prefetched cache line. However, if the prefetched cache line is not already stored in L<b>0</b> I-cache <b>14</b>, the prefetched cache line is stored into L<b>0</b> I-cache <b>16</b>. In this manner, cache lines which may be accessed presently are brought into L<b>0</b> I-cache <b>16</b> for rapid access therefrom. According to one exemplary embodiment, L<b>0</b> I-cache <b>16</b> comprises a fully associative cache structure of eight entries. A fully associative structure may be employed due to the relatively small number of cache lines included in L<b>0</b> I-cache <b>16</b>. Other embodiments may employ other organizations (e.g. set associative or direct-mapped).</p><p>Fetch control unit <b>50</b> selects the instruction run provided by one of select next blocks <b>52</b> in response to branch prediction information by controlling instruction select mux <b>54</b>. As will be explained in more detail below, fetch control unit <b>50</b> receives (in the present embodiment) target addresses from branch scanner <b>58</b>, return stack <b>64</b>, and indirect address cache <b>66</b> early in the clock cycle as well as at least a portion of the opcode byte of the first branch instruction identified by branch scanner <b>58</b>. Fetch control unit <b>50</b> decodes the portion of the opcode byte to select the target address to be fetched from L<b>0</b> I-cache <b>16</b> from the various target address sources and provides the selected target address to L<b>0</b> I-cache <b>16</b>. In parallel, the sequential address to the fetch address selected in the previous clock cycle (either the target address or the sequential address from the previous clock cycle, depending upon the branch prediction from the previous clock cycle) is calculated and provided to L<b>0</b> I-cache <b>16</b>. Branch prediction information (i.e. taken or not taken) is provided by branch history table <b>60</b> late in the clock cycle. If the branch instruction corresponding to the target address fetched from L<b>0</b> I-cache <b>16</b> is predicted taken and the branch target address is backward or forward and outside of the predetermined range for selective canceling, then fetch control unit <b>50</b> selects the instruction run provided by select next block <b>52</b>C. On the other hand, if no branch instruction is detected, the branch instruction is predicted not taken, or the branch target address is forward and within the predetermined range, then the instruction run selected by select next block <b>52</b>B is selected. The instruction run provided by select next block <b>52</b>A is selected if a predicted fetch address missed L<b>0</b> I-cache <b>16</b> in a previous clock cycle and was fetched from L<b>1</b> I-cache <b>14</b>. Additionally, the instruction run from L<b>1</b> I-cache <b>14</b> is selected if the instruction run was fetched responsive to a branch instruction having a 32 bit displacement or indirect target address generation or an L<b>0</b> I-cache miss was fetched.</p><p>The selected instruction run is provided to instruction scanner <b>56</b> and branch scanner <b>58</b>. Instruction scanner <b>56</b> scans the predecode information corresponding to the selected instruction run to identify instructions within the instruction run. More particularly in one embodiment, instruction scanner <b>56</b> scans the start bits corresponding to each run section in parallel and identifies up to five instructions within each run section. Pointers to the identified instructions (offsets within the run section) are generated. The pointers, instruction bytes, and addresses (one per run section) are conveyed by instruction scanner <b>56</b> to instruction queue <b>20</b>. If a particular run section includes more than five instructions, the information corresponding to run sections subsequent to the particular run section is invalidated and the particular run section and subsequent run sections are rescanned during the next clock cycle.</p><p>Branch scanner <b>58</b> scans the instruction run in parallel with instruction scanner <b>56</b>. Branch scanner <b>58</b> scans the start bits and control transfer bits of the instruction run to identify the first two branch instructions within the instruction run. As described above, a branch instruction is identified by the control transfer bit corresponding to the start byte of an instruction (as identified by the start bit) being set. Upon locating the first two branch instructions, branch scanner <b>58</b> assumes that the instructions are relative branch instructions and selects the corresponding encoded target addresses from the instruction bytes following the start byte of the branch instruction. For embodiments employing the x86 instruction set, a nine bit target address (the displacement byte as well as the corresponding control transfer bit) is selected, and a 32 bit target address is selected as well. Furthermore, at least a portion of the opcode byte identified by the start and control transfer bits is selected. The target addresses and opcode bytes are routed to fetch control unit <b>50</b> for use in selecting a target address for fetching from L<b>0</b> I-cache <b>16</b>. The fetch addresses of each branch instruction (determined from the fetch address of the run section including each branch instruction and the position of the branch instruction within the section) are routed to branch history table <b>60</b> for selecting a taken/not-taken prediction corresponding to each branch instruction. Furthermore, the fetch addresses corresponding to each branch instruction are routed to branch select mux <b>62</b>, which is further routed to indirect address cache <b>66</b>. The target address of each branch instruction is routed to forward collapse unit <b>68</b>. According to one embodiment, branch scanner <b>58</b> is configured to scan each run section in parallel for the first two branch instructions and then to combine the scan results to select the first two branch instructions within the run.</p><p>Branch scanner <b>58</b> may further be configured to determine if a subroutine call instruction is scanned during a clock cycle. Branch scanner <b>58</b> may forward the fetch address of the next instruction following the detected subroutine call instruction to return stack <b>64</b> for storage therein.</p><p>In one embodiment, if there are more than two branch instructions within a run, the run is scanned again during a subsequent clock cycle to identify the subsequent branch instruction.</p><p>The fetch addresses of the identified branch instructions are provided to branch history table <b>60</b> to determine a taken/not taken prediction for each instruction. Branch history table <b>60</b> comprises a plurality of taken/not-taken predictors corresponding to the previously detected behavior of branch instructions. One of the predictors is selected by maintaining a history of the most recent predictions and exclusive ORing those most recent predictions with a portion of the fetch addresses corresponding to the branch instructions. The least recent (oldest) prediction is exclusive ORed with the most significant bit within the portion of the fetch address, and so forth through the most recent prediction being exclusive ORed with the least significant bit within the portion of the fetch address. Since two predictors are selected per clock cycle, the predictor corresponding to the second branch instruction is dependent upon the prediction of the first branch instruction (for exclusive ORing with the least significant bit of the corresponding fetch address). Branch history table <b>60</b> provides the second predictor by selecting both of the predictors which might be selected (i.e. the predictor that would be selected if the first branch instruction is predicted not-taken and the predictor that would be selected if the first branch instruction is predicted taken) and then selecting one of the two predictors based on the actual prediction selected for the first branch instruction.</p><p>Branch history table <b>60</b> receives information regarding the execution of branch instructions from functional units <b>32</b>A-<b>32</b>D. The history of recent predictions corresponding to the executed branch instruction as well as the fetch address of the executed branch instruction are provided for selecting a predictor to update, as well as the taken/not taken result of the executed branch instruction. Branch history table <b>60</b> selects the corresponding predictor and updates the predictor based on the taken/not taken result. In one embodiment, the branch history table stores a bimodal counter. The bimodal counter is a saturating counter which saturates at a minimum and maximum value (i.e. subsequent decrements of the minimum value and increments of the maximum value cause no change in the counter). Each time a branch instruction is taken, the corresponding counter is incremented and each time a branch instruction is not taken, the corresponding counter is decremented. The most significant bit of the counter indicates the taken/not taken prediction (e.g. taken if set, not taken if clear). In one embodiment, branch history table <b>60</b> stores 64K predictors and maintains a history of the 16 most recent predictions. Each clock cycle, the predictions selected during the clock cycle are shifted into the history and the oldest predictions are shifted out of the history.</p><p>Return stack <b>64</b> is used to store the return addresses corresponding to detected subroutine call instructions. Return stack <b>64</b> receives the fetch address of a subroutine call instruction from branch scanner <b>58</b>. The address of the byte following the call instruction (calculated from the fetch address provided to return stack <b>64</b>) is placed at the top of return stack <b>64</b>. Return stack <b>64</b> provides the address stored at the top of the return stack to fetch control unit <b>50</b> for selection as a target address if a return instruction is detected by branch scanner <b>58</b> and fetch control unit <b>50</b>. In this manner, each return instruction receives as a target address the address corresponding to the most recently detected call instruction. Generally in the x86 instruction set, a call instruction is a control transfer instruction which specifies that the sequential address to the call instruction be placed on the stack defined by the x86 architecture. A return instruction is an instruction which selects the target address from the top of the stack. Generally, call and return instructions are used to enter and exit subroutines within a code sequence (respectively). By placing addresses corresponding to call instructions in return stack <b>64</b> and using the address at the top of return stack <b>64</b> as the target address of return instructions, the target address of the return instruction may be correctly predicted. In one embodiment, return stack <b>64</b> may comprise 16 entries.</p><p>Indirect address cache <b>66</b> stores target addresses corresponding to previous executions of indirect branch instructions. The fetch address corresponding to an indirect branch instruction and the target address corresponding to execution of the indirect branch instruction are provided by functional units <b>32</b>A-<b>32</b>D to indirect address cache <b>66</b>. Indirect address cache <b>66</b> stores the target addresses indexed by the corresponding fetch addresses. Indirect address cache <b>66</b> receives the fetch address selected by branch select mux <b>62</b> (responsive to detection of an indirect branch instruction) and, if the fetch address is a hit in indirect address cache <b>66</b>, provides the corresponding target address to fetch control unit <b>50</b>. In one embodiment, indirect address cache <b>66</b> may comprise 32 entries.</p><p>According to one contemplated embodiment, if indirect address cache <b>66</b> detects a miss for a fetch address, indirect address cache <b>66</b> may be configured to select a target address to provide from one of the entries. In this manner, a \u201cguess\u201d at a branch target is provided in case an indirect branch instruction is decoded. Fetching from the guess may be performed rather than awaiting the address via execution of the indirect branch instruction. Alternatively, another contemplated embodiment awaits the address provided via execution of the indirect branch instruction.</p><p>It is noted that, if an encoded target address is selected, the actual target address may be presented to L<b>0</b> I-cache <b>16</b>. Fetch control unit <b>50</b> may be configured to precalculate each of the possible above/below target addresses and select the correct address based on the encoded target address. Alternatively, fetch control unit <b>50</b> may record which L<b>0</b> I-cache storage locations are storing the above and below cache lines, and select the storage locations directly without a tag compare.</p><p>Forward collapse unit <b>68</b> receives the target addresses and positions within the instruction run of each selected branch instruction as well as the taken/not taken predictions. Forward collapse unit <b>68</b> determines which instructions within the run should be cancelled based upon the received predictions. If the first branch instruction is predicted taken and is backward (i.e. the displacement is negative), all instructions subsequent to the first branch instruction are cancelled. If the first branch instruction is predicted taken and is forward but the displacement is small (e.g. within the instruction run), the instructions which are between the first branch instruction and the target address are cancelled. The second branch instruction, if still within the run according to the first branch instruction's prediction, is treated similarly. Cancel indications for the instructions within the run are set to instruction queue <b>20</b>.</p><p>It is noted that, in one embodiment, branch instructions are predicted and target addresses are fetched with a one cycle bubble from the fetching of the branch instructions. The sequential run is fetched during this clock cycle, and the sequential run is discarded upon detecting the predicted taken branch instruction.</p><p>Turning now to FIG. 3, a block diagram of one embodiment of lookahead/collapse unit <b>24</b> is shown. Other embodiments are possible and contemplated. As shown in FIG. <b>3</b>, lookahead/collapse unit <b>24</b> includes a plurality of decode units <b>70</b>A-<b>70</b>F, an ESP/EBP lookahead unit <b>72</b>, a lookahead address/result calculation unit <b>74</b>, a dispatch control unit <b>76</b>, and an operand collapse unit <b>78</b>. Decode units <b>70</b>A-<b>70</b>F are coupled to receive instructions from alignment unit <b>22</b>. Decode units <b>70</b>A-<b>70</b>F are coupled to provide decoded instructions to FPU/multimedia unit <b>40</b>, ESP/EBP lookahead unit <b>72</b>, future file <b>26</b>, and lookahead address/result calculation unit <b>74</b>. ESP/EBP lookahead unit <b>72</b> is coupled to lookahead address/result calculation unit <b>74</b>, as is future file <b>26</b>. Lookahead address/result calculation unit <b>74</b> is further coupled load/store unit <b>36</b> and dispatch control unit <b>76</b>. Dispatch unit <b>76</b> is further coupled to operand collapse unit <b>78</b>, future file <b>26</b>, load/store unit <b>36</b>, and reorder buffer <b>28</b>. Operand collapse unit <b>78</b> is coupled to instruction windows <b>30</b>.</p><p>Each decode unit <b>70</b>A-<b>70</b>F forms an issue position to which alignment unit <b>22</b> aligns an instruction. While not indicated specifically throughout FIG. 3 for simplicity the drawing, a particular instruction remains within its issue position as the instruction moves through lookahead/collapse unit <b>24</b> and is routed to one of instruction windows <b>30</b>A-<b>30</b>B if not completed within lookahead/collapse unit <b>24</b>.</p><p>Decode units <b>70</b>A-<b>70</b>F route FPU/multimedia instructions to FPU/multimedia unit <b>40</b>. However, if the FPU/multimedia instructions include memory operands, memory operations are also dispatched to load/store unit <b>36</b> in response to the instruction through lookahead address/result calculation unit <b>74</b>. Additionally, if the address for the memory operations cannot be generated by lookahead address/result calculation unit <b>74</b>, an address generation operation is dispatched to one of address generation units <b>34</b>A-<b>34</b>D via instruction windows <b>30</b>A-<b>30</b>B. Still further, entries within reorder buffer <b>28</b> are allocated to the FPU/multimedia instructions for maintenance of program order. Generally, entries within reorder buffer <b>28</b> are allocated from decode units <b>70</b>A-<b>70</b>F for each instruction received therein.</p><p>Each of decode units <b>70</b>A-<b>70</b>F may be further configured to determine: (i) whether or not the instruction uses the ESP or EBP registers as a source operand; and (ii) whether not the instruction modifies the ESP/EBP registers (i.e. has the ESP or EBP registers as a destination operand). Indications of these determinations are provided by decode units <b>70</b>A-<b>70</b>F to ESP/EBP lookahead unit <b>72</b>. ESP/EBP lookahead unit <b>72</b> generates lookahead information for each instruction which uses the ESP or EBP registers as a source operand. The lookahead information may include a constant to be added to the current lookahead value of the corresponding register and an indication of a dependency upon an instruction in a prior issue position. In one embodiment, ESP/EBP lookahead unit <b>72</b> is configured to provide lookahead information as long as the set of concurrently decoded instructions provided by decode units <b>70</b>A-<b>70</b>F do not include more than: (i) two push operations (which decrement the ESP register by a constant value); (ii) two pop operations (which increment ESP register by a constant value); (iii) one move to ESP register; (iv) one arithmetic/logical instruction having the ESP as a destination; or (v) three instructions which update ESP. If one of these restrictions is exceeded, ESP/EBP lookahead unit <b>72</b> is configured to stall instructions beyond those which do not exceed restrictions until the succeeding clock cycle (a \u201csplit line\u201d case). For those instructions preceded, in the same clock cycle but in earlier issue positions, by instructions which increment or decrement the ESP register, ESP/EBP lookahead unit <b>72</b> generates a constant indicating the combined total modification to the ESP register of the preceding instructions. For those instructions preceded by a move or arithmetic operation upon the ESP or EBP registers, ESP/EBP lookahead unit <b>72</b> generates a value identifying the issue position containing the move or arithmetic instruction.</p><p>The lookahead values may be used by lookahead address/result calculation unit <b>74</b> to generate either a lookahead address corresponding to the instruction within the issue position (thereby inhibiting an address generation operation which would otherwise be performed by one of address generation units <b>34</b>A-<b>34</b>D) or a lookahead result corresponding to the instruction (thereby providing lookahead state to future file <b>26</b> earlier in the pipeline). Performance may be increased by removing address generation operations and/or providing lookahead state prior to functional units <b>32</b>A-<b>32</b>D and address generation units <b>34</b>A-<b>34</b> D. Many x86 code sequences include a large number of relatively simple operations such as moves of values from a source to destination without arithmetic/logical operation or simple arithmetic operations such as add/subtract by small constant or increment/decrement of a register operand. Accordingly, functional units <b>32</b>A-<b>32</b>D may typically execute the more complex arithmetic/logical operations and branch instructions and address generation units <b>34</b>A-<b>34</b>D may typically perform the more complex address generations. Instruction throughput may thereby be increased.</p><p>Decode units <b>70</b>A-<b>70</b>F may be still further configured to identify immediate data fields from the instructions decoded therein. The immediate data is routed to lookahead address/result calculation unit <b>74</b> by decode units <b>70</b>A-<b>70</b>F. Additionally, decode unit <b>70</b>A-<b>70</b>F are configured to identify register operands used by the instructions and to route register operand requests to future file <b>26</b>. Future file <b>26</b> returns corresponding speculative register values or result queue tags for each register operand. Decode units <b>70</b> further provide dependency checking between the line of instructions to ensure that an instruction which uses a result of an instruction within a different issue position receives a tag corresponding to that issue position.</p><p>Lookahead address/result calculation unit <b>74</b> receives the lookahead values from ESP/EBP lookahead units <b>72</b>, the immediate data from decode units <b>70</b>A-<b>70</b>F, and the speculative register values or result queue tags from future file <b>26</b>. Lookahead address/result calculation unit <b>74</b> attempts to generate either a lookahead address corresponding to a memory operand of the instruction, or a lookahead result if the instruction does not include a memory operand. For example, simple move operations can be completed (with respect to functional units <b>32</b> and address generation units <b>34</b>) if an address generation can be performed by lookahead address/result calculation unit <b>74</b>. In one embodiment, lookahead address/result calculation unit <b>74</b> is configured to compute addresses using displacement only, register plus displacement, ESP/EBP plus displacement, and scale-index-base addressing mode except for index or base registers being ESP/EBP. Load/store unit <b>36</b> performs the memory operation and returns the memory operation results via result buses <b>48</b>. Even if no address is generated for a memory operation by lookahead address/result calculation unit <b>74</b>, lookahead address/result calculation unit <b>74</b> indicates the memory operation and corresponding result queue tag to load/store unit <b>36</b> to allocate storage within load/store unit <b>36</b> for the memory operation.</p><p>Simple arithmetic operations which increment or decrement a source operand, add/subtract a small immediate value to a source operand, or add/subtract two register source operands may also be completed via lookahead address/result calculation unit <b>74</b> if the source operands are available from future file <b>26</b> (i.e. a speculative register value is received instead of a result queue tag). Instructions completed by lookahead address/result calculation units <b>74</b> are indicated as completed and are allocated entries in reorder buffer <b>28</b> but are not dispatched to instruction windows <b>30</b>. Lookahead address/result calculation unit <b>74</b> may comprise, for example, an adder for each issue position along with corresponding control logic for selecting among the lookahead values, immediate data, and speculative register values. It is noted that simple arithmetic operations may still be forwarded to instruction windows <b>30</b> for generation of condition flags, according to the present embodiment. However, generating the functional result in lookahead address/result calculation unit <b>74</b> provides the lookahead state early, allowing subsequent address generations/instructions to be performed early as well.</p><p>Lookahead address/result calculation unit <b>74</b> may be configured to keep separate lookahead copies of the ESP/EBP registers in addition to the future file copies. However, if updates to the ESP/EBP are detected which cannot be calculated by lookahead address/result calculation unit <b>74</b>, subsequent instructions may be stalled until a new lookahead copy of the ESP/EBP can be provided from future file <b>26</b> (after execution of the instruction which updates ESP/EBP in the undeterminable manner).</p><p>Dispatch control unit <b>76</b> determines whether or not a group of instructions are dispatched to provide pipeline flow control. Dispatch control unit <b>76</b> receives instruction counts from instruction windows <b>30</b> and load/store counts from load/store unit <b>36</b> and, assuming the maximum possible number of instructions are in flight in pipeline stages between dispatch control units <b>76</b> and instruction windows <b>30</b> and load/store unit <b>36</b>, determines whether or not space will be available for storing the instructions to be dispatched within instruction windows <b>30</b> and/or load/store unit <b>36</b> when the instructions arrive therein. If dispatch control unit <b>76</b> determines that insufficient space will be available in load/store unit <b>36</b> and either instruction window <b>30</b>, dispatch is stalled until the instruction counts received by dispatch control unit <b>76</b> decrease to a sufficiently low value.</p><p>Upon releasing instructions for dispatch through dispatch control unit <b>76</b>, future file <b>26</b> and reorder buffer <b>28</b> are updated with speculatively generated lookahead results. In one embodiment, the number of non-ESP/EBP updates supported may be limited to, for example, two in order to limit the number of ports on future file <b>26</b>. Furthermore, operand collapse unit <b>78</b> collapses speculatively generated lookahead results into subsequent, concurrently decoded instructions which depend upon those results as indicated by the previously determined intraline dependencies. In this manner, the dependent instructions receive the speculatively generated lookahead results since these results will not subsequently be forwarded from functional units <b>32</b>A-<b>32</b>D. Those instructions not completed by lookahead address/result calculation unit <b>74</b> are then transmitted to one of instruction windows <b>30</b>A-<b>30</b>B based upon the issue position to which those instructions were aligned by alignment unit <b>22</b>.</p><p>It is noted that certain embodiments of processor <b>10</b> may employ a microcode unit (not shown) for executing complex instructions by dispatching a plurality of simpler instructions referred to as a microcode routine. Decode units <b>70</b>A-<b>70</b>F may be configured to detect which instructions are microcode instructions and to route the microcode instructions to the microcode unit. For example, the absence of a directly decoded instruction output from a decode unit <b>70</b> which received a valid instruction may be an indication to the microcode unit to begin execution for the corresponding valid instruction. It is further noted that various storage devices are shown in FIGS. 2 and 3 (e.g. devices <b>79</b>A, <b>79</b>B, and similar devices in FIG. <b>2</b> and devices <b>79</b>C, <b>79</b>D and similar devices in FIG. <b>3</b>). The storage devices represent latches, registers, flip-flops and the like which may be used to separate pipeline stages. However, the particular pipeline stages shown in FIGS. 2 and 3 are but one embodiment of suitable pipeline stages for one embodiment of processor <b>10</b>. Other pipeline stages may be employed in other embodiments.</p><p>It is noted that, while the x86 instruction set and architecture has been used as an example above and may be used as an example below, any instruction set and architecture may be used. Additionally, displacements may be any desirable size (in addition to the 8 bit and 32 bit sizes used as examples herein). Furthermore, while cache line fetching may be described herein, it is noted that cache lines may be sectors, and sectors may be fetched, if desirable based upon cache line size and the number of bytes desired to be fetched.</p><p>Turning now to FIG. 4, a block diagram of branch scanner <b>58</b>, branch history table <b>60</b>, forward collapse unit <b>68</b>, and instruction queue <b>20</b> is shown to highlight interconnection therebetween according to one particular implementation of processor <b>10</b>. Other embodiments are possible and contemplated, including alternative or additional interconnection as desired. In the embodiment of FIG. 4, branch scanner <b>58</b> is coupled to a branch target address bus <b>80</b> and a branch fetch address bus <b>82</b>. Branch target address bus <b>80</b> is further coupled to forward collapse unit <b>68</b>. Similarly, branch fetch address bus <b>82</b> is further coupled to forward collapse unit <b>68</b>, and is also coupled to branch history table <b>60</b>. Branch history table <b>60</b> is coupled to a branch predictions bus <b>84</b> which is further coupled to forward collapse unit <b>68</b>. Forward collapse unit <b>68</b> is still further coupled to a cancel all line <b>86</b>, a cancel range line <b>88</b>, a range lower limit bus <b>90</b>, and a range upper limit bus <b>92</b>, each of which is further coupled to instruction queue <b>20</b>. It is noted that pipeline storage devices similar to devices <b>79</b> shown in FIGS. 2-3 have been omitted for simplicity in the drawing. Any suitable pipeline may be employed.</p><p>Generally speaking, forward collapse unit <b>68</b> is used to select instructions to be cancelled based upon the branch predictions corresponding to branch instructions identified within the run. Forward collapse unit <b>68</b> receives the branch target addresses corresponding to the branch instructions detected by branch scanner <b>58</b> as well as the branch fetch addresses. Additionally, forward collapse unit <b>68</b> receives the corresponding branch predictions from branch history table <b>60</b>. If a branch instruction is predicted taken, forward collapse unit <b>68</b> determines which instructions to cancel. More particularly, for forward branch target addresses, forward collapse unit <b>68</b> determines if the branch target address identifies a subsequent instruction within a predetermined range of the branch instruction or whether the branch target address identifies an instruction outside of the range (the instruction identified by the branch target address is the instruction stored at the branch target address and is referred to as the \u201ctarget instruction\u201d). If the target address is within the range, prefetch control unit <b>50</b> is selecting the sequential fetch even though the branch instruction is predicted taken (as described above). Accordingly, the target instruction and subsequent instructions within the run are to be retained so that the predicted instruction sequence is executed by processor <b>10</b>. Furthermore, the instructions between the branch instruction and the target instruction are to be cancelled, thereby forming the predicted instruction sequence.</p><p>If forward collapse unit <b>68</b> determines that a predicted taken branch instruction has a forward target address within the range, forward collapse unit <b>68</b> signals instruction queue <b>20</b> of a range of addresses for which instructions are to be cancelled. In the present embodiment, forward collapse unit <b>68</b> activates a cancel range signal on cancel range line <b>88</b>, and provides the addresses of the lower and upper limit of the range upon the range lower limit bus <b>90</b> and range upper limit bus <b>92</b>, respectively. Instruction queue <b>20</b>, responsive to the activated cancel range signal, invalidates any instructions stored therein which lie between the lower and upper limits. An instruction lies between the lower and upper limits if the address of the instruction is numerically greater than the lower limit and is numerically less than the upper limit. Since the instructions to be cancelled lie between the branch instruction and the target instruction for a forward branch target address, the range lower limit may be the fetch address of the predicted taken branch instruction and the range upper limit may be the branch target address.</p><p>For branch instructions having backward branch target addresses (i.e. be branch target addresses numerically less than the corresponding branch fetch address), each of the instructions subsequent to the branch instruction is not within the predicted instruction sequence. Accordingly, upon detecting a branch instruction having a backward target address, forward collapse unit <b>68</b> activates a cancel all signal upon cancel all line <b>86</b> and provides the branch fetch address as the range lower limit. Responsive to the activated cancel all signal, instruction queue <b>20</b> invalidates each instruction stored at an address greater than the range lower limit address.</p><p>Forward collapse unit <b>68</b> may handle branch instructions having forward branch target addresses which identify a target instruction outside of the predetermined range in a manner similar to handling branch instructions having backward branch target addresses. In these cases, forward collapse unit <b>68</b> activates the cancel all signal and provides the branch fetch address as the range lower limit address.</p><p>While forward collapse unit <b>68</b> may be employed in embodiments in which one branch instruction is predicted per clock cycle, the present embodiment attempts to predict up to two branch instructions per clock cycle. Forward collapse unit <b>68</b> receives the branch target address and branch fetch address for each detected branch instruction. In the present embodiment, forward collapse unit <b>68</b> processes the first identified branch instruction (i.e. the instruction which is encountered first in program order within the run) prior to processing the second identified branch instruction. If the second identified branch instruction is still within the run subsequent to processing the first identified branch instruction, the second identified branch instruction is processed subsequently.</p><p>Generally, forward collapse unit <b>68</b> may be configured to determine if a particular branch instruction has a forward branch target address by comparing the branch fetch address to the corresponding branch target address. If the branch target address is greater than the branch fetch address, then the branch target address is forward. In the present embodiment, forward collapse unit <b>68</b> may receive a branch target address which is encoded with the cache line offset of the branch target address as well as an indication of the number of cache lines above or below the cache line storing the branch instruction (as described above). Accordingly, forward collapse unit <b>68</b> may determine that the branch target address is a forward branch target address by determining that the branch target address is one or two cache lines above or is within the same cache line and the offset portion of the branch target addresses greater than the branch fetch address. Other embodiments may use the full branch target address and branch fetch address to determine if the branch target address is a forward branch target address, or may use a suitable portion of the addresses.</p><p>It is noted that forward collapse unit <b>68</b> may detect whether or not the forward branch target address is within the predetermined range by comparing the branch fetch address and the branch target address. Generally, the size of the predetermined range may vary from embodiment to embodiment. However, the size of the predetermined range may be selected based upon the amount of instruction bytes fetched prior to the prediction of a forward branch instruction. In other words, since sequential fetching is chosen in the absence of a predicted taken branch, instructions sequential to a predicted taken branch instruction are fetched until the branch instruction is predicted and the fetch mechanism would be able to fetch the branch target address. The size of the predetermined range may be based upon the amount of sequential instructions which may be fetched. If a forward branch target address outside of the predetermined range is detected, than all of the sequential instructions which have been fetched prior to predicting the branch instruction may be prior to the target instruction identified by the forward branch target address. On the other hand, if a forward branch target address within the predetermined range is detected, than the target instruction and one or more subsequent instructions may have already been fetched. In one exemplary embodiment, the predetermined range may be 64 bytes from the branch fetch address. In another embodiment, the predetermined range could be selected such that the target instruction is within the run with the corresponding branch instruction. It is noted that, depending upon the size of the predetermined range, the cancellation indications provided by forward collapse unit <b>68</b> may be provided to other pipeline stages besides instruction queue <b>20</b>. Alternatively, instruction queue <b>20</b> may retain cancellation indications and continue canceling instructions until the target instruction is received.</p><p>Embodiments of forward collapse unit <b>68</b> which handle multiple branch predictions within a run may further determine whether or not the second identified branch instruction is still within the run after processing the first identified branch instruction by comparing the branch target address of the first identified branch instruction to the branch fetch address of the second identified branch instruction. If the branch target address of the first identified branch instruction is greater than the branch fetch address of the second identified branch instruction and the first identified branch instruction is predicted taken, then the second branch instruction is no longer within the run and is not processed. Otherwise, the second branch instruction is processed. It is noted that processing of the second branch instruction may be initiated in parallel with processing of the first branch instruction, and the cancellations corresponding to the second branch instruction (if any) may be broadcast is inhibited based on whether the second branch instruction is still within the run after cancellations (if any) due to the first branch instruction.</p><p>It is noted that forward collapse unit <b>68</b> may be integrated into instruction queue <b>20</b>, if desired. It is also noted that, as an alternative to comparing addresses, embodiments of forward collapse unit <b>68</b> and processor <b>10</b> are contemplated in which processor <b>10</b> assigns sequence numbers to the instructions within a run (e.g. via instruction scanner <b>56</b>). Forward collapse unit <b>68</b> may be provided with the sequence numbers as well as an indication of the sequence number of the branch instruction and the corresponding target instruction. Cancellation of instructions may be performed on the basis of the sequence numbers instead of the addresses.</p><p>It is noted that cancellation indications may additionally be routed to alignment unit <b>22</b> and lookahead/collapse unit <b>24</b> to cause cancellation of instructions which may have been dispatched from instruction queue <b>20</b> prior to cancellation. It is further noted that, although the present discussion refers to transmitting only a lower limit with cancel all indications, forward collapse unit <b>68</b> may be configured to transmit the branch fetch address as the lower limit and the branch target address as the upper limit, with the cancel all and cancel range signals validating the upper and lower limits.</p><p>Turning next to FIG. 5, a flowchart illustrating operation of one embodiment of forward collapse unit <b>68</b> is shown. Other embodiments are possible and contemplated. The steps shown in FIG. 5 are shown in a particular order for ease of understanding. However, any suitable order may be used. Furthermore, steps may be performed in parallel as desired.</p><p>Upon receiving an indication of at least a first branch instruction from branch scanner <b>58</b> and the corresponding branch prediction from branch history table <b>60</b>, forward collapse unit <b>68</b> determines whether or not the first branch instruction is predicted taken (decision block <b>100</b>). If the first branch instruction is predicted taken, forward collapse unit <b>68</b> determines if the first branch instruction includes a forward branch target address within the predetermined range (decision block <b>102</b>). If a forward branch target address within the range is not detected for the first branch instruction, forward collapse unit <b>68</b> signals instruction queue <b>20</b> to cancel all instructions subsequent to the first branch instruction within the run (step <b>104</b>). On the other hand, if a forward branch target address within the range is detected, forward collapse unit <b>68</b> signals instruction queue <b>20</b> to cancel instructions between the first branch instruction and the instruction located at the first branch target address (step <b>106</b>).</p><p>If either the first branch instruction is predicted not taken or the first branch target address indicates an instruction within the run which is not subsequent to the second branch instruction (decision block <b>108</b>), forward collapse unit <b>68</b> determines if the second branch instruction (if any) is predicted taken (decision block <b>110</b>). If the second branch instruction is not predicted taken, additional cancellations are not needed. If a second branch instruction is predicted taken, forward collapse unit <b>68</b> determines if the second branch target address is a forward branch target address within the predetermined range (decision block <b>112</b>). If the second branch target address is a forward target address within the predetermined range, forward collapse unit <b>68</b> signals instruction queue <b>20</b> to cancel all instructions subsequent to the second branch instruction (step <b>114</b>). On the other hand, if the second branch target address is a forward branch target address within the range, forward collapse unit <b>68</b> signals instruction queue <b>20</b> to cancel instructions between the second branch instruction and the instruction indicated by the second branch target address (step <b>116</b>).</p><p>It is noted that, in the embodiment shown in FIG. 4, forward collapse unit <b>68</b> is configured transmit one cancellation indication per clock cycle. Accordingly, the steps shown in FIG. 5 may be performed over a pair of clock cycles. For example, forward collapse unit <b>68</b> may determine cancellation signalling for both the first and second branch instruction upon receiving the branch target addresses, branch fetch addresses, and branch predictions and convey the cancellations during consecutive clock cycles if two cancellations are detected. Alternatively, examination and cancellation based on the first branch instruction may be performed in one clock cycle and examination cancellation based second branch instruction may occur in any subsequent clock cycle. In yet another alternative, cancellation indications for each branch instruction which may be detected within a run may be conveyed concurrently.</p><p>Turning next to FIG. 6, an exemplary instruction run <b>120</b> is shown including a first branch instruction (B<b>0</b>) having a backward branch target address. Instructions other than branch instructions within instruction run <b>120</b> are indicated with an \u201cI\u201d followed by a number, while branch instructions are indicated by a \u201cB\u201d followed by a number. In other words, run <b>120</b> includes branch instructions B<b>0</b> and B<b>1</b> as well as non-branch instructions I<b>0</b>, I<b>1</b>, I<b>2</b>, I<b>3</b>, and I<b>4</b>. Program order of the instructions is from left to right as illustrated in FIG. <b>6</b>. In other words, instruction I<b>0</b> is foremost of the instructions within run <b>120</b> and hence is stored at the numerically lowest address of the instructions within run <b>120</b>. Subsequent instructions follow in the order listed and hence are stored at increasingly (numerically) larger addresses. The arrow connected to branch instruction B<b>0</b> and pointing to the left indicates that branch instruction B<b>0</b> has a backward branch target address.</p><p>A timing diagram <b>122</b> is also shown in FIG. 6, illustrating operation of one embodiment of forward collapse unit <b>68</b> in response to instruction run <b>120</b>. Clock cycles within the timing diagram are delimited by vertical dashed lines. During clock cycle CLK<b>0</b>, forward collapse unit <b>68</b> receives the branch target addresses (and branch fetch addresses) corresponding to branch instructions B<b>0</b> and B<b>1</b> from branch scanner <b>58</b>. During clock cycle CLK <b>1</b>, the corresponding branch prediction for branch instruction B<b>0</b> is received. The branch prediction corresponding to branch instruction B<b>1</b> may be received during clock cycle CLK<b>1</b> as well, but is a don't care in this case because the branch target address corresponding to branch instruction B<b>0</b> is a backward branch target address and branch instruction B<b>0</b> is predicted taken.</p><p>Responsive to the prediction of branch instruction B<b>0</b> as taken and the branch target address corresponding to branch instruction B<b>0</b> being a backward branch target address, forward collapse unit <b>68</b> transmits a cancel all signal to instruction queue <b>20</b> and provides the fetch address corresponding to the branch instruction B<b>0</b> as the range lower limit during clock cycle CLK<b>1</b>. As a result, as shown in clock cycle CLK<b>2</b>, the instructions subsequent to branch instruction B<b>0</b> have been cancelled (i.e. instructions I<b>1</b>, I<b>2</b>, B<b>1</b>, I<b>3</b>, and I<b>4</b>).</p><p>Turning next to FIG. 7, an exemplary instruction run <b>130</b> is shown including a first branch instruction (B<b>0</b>) having a forward branch target address. Instructions other than branch instructions within instruction run <b>130</b> are indicated with an \u201cI\u201d followed by a number, while branch instructions are indicated by a \u201cB\u201d followed by a number. In other words, run <b>130</b> includes branch instructions B<b>0</b> and B<b>1</b> as well as non-branch instructions I<b>0</b>, I<b>1</b>, I<b>2</b>, I<b>3</b>, and I<b>4</b>. Program order of the instructions is from left to right as illustrated in FIG. <b>7</b>. In other words, instruction I<b>0</b> is foremost of the instructions within run <b>130</b> and hence is stored at the numerically lowest address of the instructions within run <b>130</b>. Subsequent instructions follow in the order listed and hence are stored at increasingly (numerically) larger addresses. The arrow connected to branch instruction B<b>0</b> and pointing to the right indicates that branch instruction B<b>0</b> has a forward branch target address. Additionally, the target instruction identified by the forward branch target address is I<b>3</b> within run <b>130</b>.</p><p>A timing diagram <b>132</b> is also shown in FIG. 7, illustrating operation of one embodiment of forward collapse unit <b>68</b> in response to instruction run <b>130</b>. Clock cycles within the timing diagram are delimited by vertical dashed lines. During clock cycle CLK<b>0</b>, forward collapse unit <b>68</b> receives the branch target addresses (and branch fetch addresses) corresponding to branch instructions B<b>0</b> and B<b>1</b> from branch scanner <b>58</b>. During clock cycle CLK <b>1</b>, the corresponding branch prediction for branch instruction B<b>0</b> is received. The branch prediction corresponding to branch instruction B<b>1</b> may be received during clock cycle CLK<b>1</b> as well, but is a don't care in this case because the branch target address corresponding to branch instruction B<b>0</b> is a forward branch target address, is predicted taken, and indicates a target instruction which is beyond branch instruction B<b>1</b> within run <b>130</b>.</p><p>Responsive to the prediction of branch instruction B<b>0</b> as taken and the branch target address corresponding to branch instruction B<b>0</b> being a forward branch target address, forward collapse unit <b>68</b> transmits a cancel range signal to instruction queue <b>20</b>, provides the fetch address corresponding to branch instruction B<b>0</b> as the range lower limit, and provides the forward branch target address specified by branch instruction B<b>0</b> as the range upper limit during clock cycle CLK<b>1</b>. As a result, as shown in clock cycle CLK<b>2</b>, the instructions subsequent to branch instruction B<b>0</b> and prior to the target instruction (I<b>3</b>) have been cancelled (i.e. instructions I<b>1</b>, I<b>2</b>, and B<b>1</b>). Furthermore, the target instruction and subsequent instructions (I<b>3</b> and I<b>4</b>) have been retained.</p><p>Turning next to FIG. 8, an exemplary instruction run <b>140</b> is shown including a first branch instruction (B<b>0</b>) having a forward branch target address and a second branch instruction (B<b>1</b>) having a backward branch target address. Instructions other than branch instructions within instruction run <b>140</b> are indicated with an \u201cI\u201d followed by a number, while branch instructions are indicated by a \u201cB\u201d followed by a number. In other words, run <b>140</b> includes branch instructions B<b>0</b> and B<b>1</b> as well as non-branch instructions I<b>0</b>, I<b>1</b>, I<b>2</b>, I<b>3</b>, and I<b>4</b>. Program order of the instructions is from left to right as illustrated in FIG. <b>8</b>. In other words, instruction I<b>0</b> is foremost of the instructions within run <b>140</b> and hence is stored at the numerically lowest address of the instructions within run <b>140</b>. Subsequent instructions follow in the order listed and hence are stored at increasingly (numerically) larger addresses. The arrow connected to branch instruction B<b>0</b> and pointing to the right indicates that branch instruction B<b>0</b> has a forward branch target address. Additionally, the target instruction identified by the forward branch target address is I<b>2</b> within run <b>140</b>. The arrow connected to branch instruction B<b>1</b> and pointing to the left indicates that branch instruction B<b>1</b> has a backward branch target address.</p><p>A timing diagram <b>142</b> is also shown in FIG. 8, illustrating operation of one embodiment of forward collapse unit <b>68</b> in response to instruction run <b>140</b>. Clock cycles within the timing diagram are delimited by vertical dashed lines. During clock cycle CLK<b>0</b>, forward collapse unit <b>68</b> receives the branch target addresses (and branch fetch addresses) corresponding to branch instructions B<b>0</b> and B<b>1</b> from branch scanner <b>58</b>. During clock cycle CLK<b>1</b>, the corresponding branch predictions for branch instructions B<b>0</b> and B<b>1</b> are received.</p><p>Responsive to the prediction of branch instruction B<b>0</b> as taken and the branch target address corresponding to branch instruction B<b>0</b> being a forward branch target address, forward collapse unit <b>68</b> transmits a cancel range signal to instruction queue <b>20</b>, provides the fetch address corresponding to branch instruction B<b>0</b> as the range lower limit, and provides the forward branch target address specified by branch instruction B<b>0</b> as the range upper limit during clock cycle CLK<b>1</b>. As a result, as shown in clock cycle CLK<b>2</b>, the instructions subsequent to branch instruction B<b>0</b> and prior to the target instruction (I<b>2</b>) have been cancelled (i.e. instruction I<b>1</b>). Furthermore, the target instruction and subsequent instructions (I<b>2</b>, B<b>1</b>, I<b>3</b> and I<b>4</b>) have been retained.</p><p>Responsive to branch instruction B<b>1</b> being retained after instruction cancellation corresponding to branch instruction B<b>0</b> being performed, the prediction of branch instruction B<b>1</b> as taken, and the branch target address corresponding to branch instruction B<b>1</b> being a backward branch target address, forward collapse unit <b>68</b> transmits a cancel all signal to instruction queue <b>20</b>, and provides the fetch address corresponding to branch instruction B<b>1</b> as the range lower limit during clock cycle CLK<b>2</b>. As a result, as shown in clock cycle CLK<b>3</b>, the instructions subsequent to branch instruction B<b>1</b> have been cancelled (i.e. instructions I<b>3</b> and I<b>4</b>).</p><p>Turning next to FIG. 9, an exemplary instruction run <b>150</b> is shown including a first branch instruction (B<b>0</b>) having a forward branch target address and a second branch instruction (B<b>1</b>) having a forward branch target address. Instructions other than branch instructions within instruction run <b>150</b> are indicated with an \u201cI\u201d followed by a number, while branch instructions are indicated by a \u201cB\u201d followed by a number. In other words, run <b>150</b> includes branch instructions B<b>0</b> and B<b>1</b> as well as non-branch instructions I<b>0</b>, I<b>1</b>, I<b>2</b>, I<b>3</b>, and I<b>4</b>. Program order of the instructions is from left to right as illustrated in FIG. <b>9</b>. In other words, instruction I<b>0</b> is foremost of the instructions within run <b>150</b> and hence is stored at the numerically lowest address of the instructions within run <b>150</b>. Subsequent instructions follow in the order listed and hence are stored at increasingly (numerically) larger addresses. The arrow connected to branch instruction B<b>0</b> and pointing to the right indicates that branch instruction B<b>0</b> has a forward branch target address. Additionally, the target instruction identified by the forward branch target address is I<b>2</b> within run <b>150</b>. The arrow connected to branch instruction B<b>1</b> and pointing to the right indicates that branch instruction B<b>1</b> has a forward branch target address. Additionally, the target instruction identified by the forward branch target address is I<b>4</b> within run <b>150</b>.</p><p>A timing diagram <b>152</b> is also shown in FIG. 9, illustrating operation of one embodiment of forward collapse unit <b>68</b> in response to instruction run <b>150</b>. Clock cycles within the timing diagram are delimited by vertical dashed lines. During clock cycle CLK<b>0</b>, forward collapse unit <b>68</b> receives the branch target addresses (and branch fetch addresses) corresponding to branch instructions B<b>0</b> and B<b>1</b> from branch scanner <b>58</b>. During clock cycle CLK<b>1</b>, the corresponding branch predictions for branch instructions B<b>0</b> and B<b>1</b> are received.</p><p>Responsive to the prediction of branch instruction B<b>0</b> as taken and the branch target address corresponding to branch instruction B<b>0</b> being a forward branch target address, forward collapse unit <b>68</b> transmits a cancel range signal to instruction queue <b>20</b>, provides the fetch address corresponding to branch instruction B<b>0</b> as the range lower limit, and provides the forward branch target address specified by branch instruction B<b>0</b> as the range upper limit during clock cycle CLK<b>1</b>. As a result, as shown in clock cycle CLK<b>2</b>, the instructions subsequent to branch instruction B<b>0</b> and prior to the target instruction (I<b>2</b>) have been cancelled (i.e. instruction I<b>1</b>). Furthermore, the target instruction and subsequent instructions (I<b>2</b>, B<b>1</b>, I<b>3</b> and I<b>4</b>) have been retained.</p><p>Responsive to branch instruction B<b>1</b> being retained after instruction cancellation corresponding to branch instruction B<b>0</b> being performed, the prediction of branch instruction B<b>1</b> as taken, and the branch target address corresponding to branch instruction B<b>1</b> being a forward branch target address, forward collapse unit <b>68</b> transmits a cancel range signal to instruction queue <b>20</b>, provides the fetch address corresponding to branch instruction B<b>1</b> as the range lower limit, and provides the forward branch target address corresponding to branch instruction B<b>1</b> as the range upper limit during clock cycle CLK<b>2</b>. As a result, as shown in clock cycle CLK<b>3</b>, the instructions subsequent to branch instruction B<b>1</b> and prior to the target instruction (I<b>4</b>) have been cancelled (i.e. instructions I<b>3</b>). Furthermore, the target instruction (I<b>4</b>) has been retained.</p><p>Turning next to FIG. 10, an exemplary instruction run <b>160</b> is shown including a first branch instruction (B<b>0</b>) having a forward branch target address outside of run <b>160</b> and more particularly outside of the predetermined range. Instructions other than branch instructions within instruction run <b>160</b> are indicated with an \u201cI\u201d followed by a number, while branch instructions are indicated by a \u201cB\u201d followed by a number. In other words, run <b>160</b> includes branch instructions B<b>0</b> and B<b>1</b> as well as non-branch instructions I<b>0</b>, I<b>1</b>, I<b>2</b>, I<b>3</b>, and I<b>4</b>. Program order of the instructions is from left to right as illustrated in FIG. <b>10</b>. In other words, instruction I<b>0</b> is foremost of the instructions within run <b>160</b> and hence is stored at the numerically lowest address of the instructions within run <b>160</b>. Subsequent instructions follow in the order listed and hence are stored at increasingly (numerically) larger addresses. The arrow connected to branch instruction B<b>0</b> and pointing to the right indicates that branch instruction B<b>0</b> has a forward branch target address.</p><p>A timing diagram <b>162</b> is also shown in FIG. 10, illustrating operation of one embodiment of forward collapse unit <b>68</b> in response to instruction run <b>160</b>. Clock cycles within the timing diagram are delimited by vertical dashed lines. During clock cycle CLK<b>0</b>, forward collapse unit <b>68</b> receives the branch target addresses (and branch fetch addresses) corresponding to branch instructions B<b>0</b> and B<b>1</b> from branch scanner <b>58</b>. During clock cycle CLK<b>1</b>, the corresponding branch predictions for branch instructions B<b>0</b> and B<b>1</b> are received.</p><p>Responsive to the prediction of branch instruction B<b>0</b> as taken and the branch target address corresponding to branch instruction B<b>0</b> being a forward branch target address outside of the predetermined range, forward collapse unit <b>68</b> transmits a cancel all signal to instruction queue <b>20</b>, and provides the fetch address corresponding to branch instruction B<b>0</b> as the range lower limit during clock cycle CLK<b>1</b>. As a result, as shown in clock cycle CLK<b>2</b>, the instructions subsequent to branch instruction B<b>0</b> have been cancelled (i.e. instructions I<b>1</b>, I<b>2</b>, B<b>1</b>, I<b>3</b>, and I<b>4</b>). Since branch instruction B<b>1</b> has been cancelled according to the prediction of branch instruction B<b>0</b>, the prediction for branch instruction B<b>1</b> is ignored.</p><p>It is noted that, while the examples shown in FIGS. 6-10 have illustrated a run of instructions and branch target addresses within the run, forward collapse unit <b>68</b> may make similar determinations for forward branch target addresses outside of the run as long as the forward branch target addresses are within the predetermined range. Furthermore, in a case in which the first branch instruction is predicted not taken, the cancellation indications for the second branch instruction (if any) may be broadcast during the clock cycle in which the cancellation indications corresponding to the first branch instruction would otherwise have been broadcast.</p><p>Turning now to FIG. 11, a timing diagram <b>170</b> is shown illustrating additional advantages which may be achieved by one embodiment of forward collapse unit <b>68</b> as employed within one embodiment of processor <b>10</b> as illustrated in FIGS. 1-3. Clock cycles in FIG. 11 are delimited by vertical dashed lines.</p><p>During clock cycle CLK<b>0</b>, a run of instructions including a branch instruction having a forward branch target address is fetched from L<b>0</b> I-cache <b>16</b> (reference number <b>172</b>). The run of instructions is scanned during clock cycle CLK<b>1</b>, and branch scanner <b>58</b> detects the branch instruction (reference number <b>174</b>). Branch scanner <b>58</b> transmits the forward branch target address of the branch instruction to forward collapse unit <b>68</b> during clock cycle CLK<b>2</b> (reference number <b>176</b>) as well as transmitting the branch target address to prefetch control unit <b>50</b> and branch history table <b>60</b>. Branch history table <b>60</b> provides a taken branch prediction corresponding to the branch target address in clock cycle CLK<b>2</b> (reference number <b>178</b>). Additionally, the instructions including the branch instruction are queued in instruction queue <b>20</b> during clock cycle CLK<b>2</b>.</p><p>Forward collapse unit <b>68</b> receives the taken branch prediction corresponding to the branch instruction during clock cycle CLK<b>3</b> (reference number <b>180</b>). Since the branch instruction is predicted taken and has a forward branch target address within the predetermined range, forward collapse unit <b>68</b> transmits a cancel range signal to instruction queue <b>20</b> along with a range lower limit set to the fetch address of the branch instruction and a range upper limit set to the branch target address (reference <b>182</b>).</p><p>In parallel with the aforementioned events, L<b>0</b> I-cache <b>16</b> continues to provide instructions responsive to fetch addresses provided by prefetch control unit <b>50</b>. For example, during clock cycle CLK<b>1</b>, a sequential run of instructions to the run including the branch instruction is fetched (reference number <b>184</b>). Because no branch prediction is received during clock cycle CLK<b>1</b>, prefetch control unit selects the sequential run of instructions via instruction select mux <b>54</b>. Accordingly, during clock cycle CLK<b>2</b>, the sequential run of instructions is scanned by instruction scanner <b>56</b> and branch scanner <b>58</b> (reference number <b>186</b>). The sequential run of instructions is queued within instruction queue <b>20</b> during clock cycle CLK<b>3</b> (reference number <b>188</b>). Instructions which are not predicted to be executed because they are between the branch instruction and the target instruction and a branch instruction is predicted taken are cancelled (reference number <b>190</b>).</p><p>In the absence of the selective cancellation mechanism described above, the sequential run of instructions would not be fetched until clock cycle CLK<b>2</b> (i.e. as part of the fetch of the branch target address of the branch instruction). However, since the selective cancellation mechanism is provided, the sequential instructions are actually fetched during clock cycle CLK<b>1</b> and these instructions are retained while the instructions which are not predicted to be executed because the branch instruction is predicted taken and has a forward target address are cancelled from the instruction queue (as well as any subsequent and/or previous pipeline stages to which the instructions may have been dispatched).</p><p>Additionally, timing diagram <b>170</b> illustrates how the selective cancellation mechanism may be used in response to forward branch target addresses which extend beyond the end of the run including the branch instruction. The sequential run instructions is queued in instruction queue <b>20</b> during clock cycle CLK<b>3</b> (reference number <b>188</b>). Accordingly, instructions within the sequential instruction run may be selectively cancelled based upon the branch fetch address and branch target address of the predicted branch instruction. Furthermore, if desired, the cancellation ranges may be provided to instruction scanner <b>56</b> for selective cancellation of instructions being scanned as well. In this manner, larger forward target addresses may be handled by the selective cancellation mechanism. Such embodiments are contemplated. For example, an embodiment in which selective cancellation of instructions responsive to a forward target address of up to 64 bytes away from the branch fetch address is contemplated.</p><p>Turning next to FIG. 12, a block diagram of one exemplary embodiment of instruction queue <b>20</b> is shown. Other embodiments are possible and contemplated. In the embodiment of FIG. 12, instruction queue <b>20</b> includes run storages <b>300</b>A-<b>300</b>B, scan data storages <b>302</b>A-<b>302</b>B, and address storages <b>304</b>A-<b>304</b>B. Additionally, instruction queue <b>20</b> includes a mux <b>306</b> and a control unit <b>308</b>. A run of instructions is provided to instruction queue <b>20</b> from fetch/scan unit <b>18</b> via a run bus <b>310</b>; corresponding scan data is provided on a scan data bus <b>312</b>; and corresponding addresses (one per run section) are provided on a run addresses bus <b>314</b>. Instruction queue <b>20</b> provides a set of selected instruction bytes to alignment unit <b>22</b> on instruction bytes bus <b>316</b>, pointers to instructions within the instruction bytes on an instruction pointers bus <b>318</b>, and addresses for the run sections comprising the set of selected instruction bytes on an addresses bus <b>320</b>. Run bus <b>310</b> is coupled to run storages <b>300</b>A-<b>300</b>B, while scan data bus <b>312</b> is coupled to scan data storages <b>302</b>A-<b>302</b>B and address storages <b>304</b>A-<b>304</b>B are coupled to run addresses bus <b>314</b>. Storages <b>300</b>A-<b>300</b>B, <b>302</b>A-<b>302</b>B, and <b>304</b>A-<b>304</b>B are coupled to mux <b>306</b>, which is further coupled to buses <b>316</b>-<b>320</b>. Control unit <b>308</b> is coupled to mux <b>306</b> and scan data storages <b>302</b>A-<b>302</b>B.</p><p>Fetch/scan unit <b>18</b>, and more particularly instruction scanner <b>56</b> according to the embodiment of FIG. 2, provides a run of instructions and associated information to instruction queue <b>20</b> via buses <b>310</b>-<b>314</b>. Control unit <b>308</b> allocates one of run storages <b>300</b>A-<b>300</b>B for the instruction bytes comprising the instruction run, and a corresponding, scan data storage <b>302</b>A-<b>302</b>B and address storage <b>304</b>A-<b>304</b>B for the associated information. The scan data includes instruction pointers which identify: (i) the start byte and end byte as offsets within a run section; as well as (ii) the run section within which the instruction resides. According to one particular embodiment, up to five instructions may be identified within an eight byte run section, and there are up to three run sections in a run for a total of up to 15 instructions pointers stored within a scan data storage <b>302</b>. Additionally, address storages <b>304</b> store an address corresponding to each run section.</p><p>Control unit <b>308</b> examines the instruction pointers within scan data storages <b>302</b>A-<b>302</b>B to identify instructions within a set of contiguous run sections for dispatch to alignment unit <b>22</b>. In one particular embodiment, up to six instructions are identified within up to four contiguous run sections. The run sections may be stored in one of run storages <b>300</b>A or <b>300</b>B, or some run sections may be selected from one of run storages <b>300</b>A-<b>300</b>B and the other run sections may be selected from the other one of run storages <b>300</b>A-<b>300</b>B. A first run section is contiguous to a second run section if the first run section is next, in speculative program order, to the second run section. It is noted that mux <b>306</b>, while illustrated as a single mux in FIG. 13 for simplicity in the drawing, may be implemented by any suitable parallel or cascaded set of multiplexors.</p><p>Control unit <b>308</b> provides a set of selection signals to mux <b>306</b> to select the set of run sections including the selected instructions, as well as the instruction pointers corresponding to the selected instructions. Additionally, the address for each selected run section is selected. The run sections are provided upon instruction bytes bus <b>316</b>, while the corresponding instruction pointers and addresses are provided upon instruction pointers bus <b>318</b> and addresses bus <b>320</b>, respectively.</p><p>Control unit <b>308</b> is further configured to invalidate instructions stored within instruction queue <b>20</b> in response to signals from forward collapse unit <b>68</b>. Control unit <b>308</b> receives the range lower limit and range upper limit buses <b>90</b>-<b>92</b>, as well as cancel all line <b>86</b> and cancel range line <b>88</b>. Control unit <b>308</b> is further coupled to address storages <b>304</b>A-<b>304</b>B and scan data storage <b>302</b>A-<b>302</b>B. Between the run section addresses stored in storages <b>304</b>A-<b>304</b>B and the start byte offsets stored in scan data storages <b>302</b>A-<b>302</b>B, control unit <b>308</b> may determine the address of each instruction represented within instruction queue <b>20</b>. These addresses may then be compared to the range lower limit and range upper limit values. If an instruction's start byte is stored at an address greater than the range lower limit address and the cancel all signal is asserted, control unit <b>308</b> invalidates the instruction within instruction queue <b>20</b>. If an instruction's start byte is stored at an address greater than the range lower limit address and less than the range upper limit address and the cancel range signal is asserted, then control unit <b>308</b> invalidates the instruction within instruction queue <b>20</b>. For example, each instruction may be indicated as valid via a valid bit within scan data storages <b>302</b>A-<b>302</b>B and the valid bit may be set to an invalid state to invalidate the instruction.</p><p>It is noted that, since control unit <b>308</b> compares the address of the start byte of each instruction to the range lower limit address and checks for greater than, the branch instruction itself will not be invalidated. Similarly, since control unit <b>308</b> compares the address of the start byte of each instruction to the range upper limit address and checks for less than, the target instruction itself will not be invalidated.</p><p>Turning now to FIG. 13, a block diagram of one embodiment of a computer system <b>200</b> including processor <b>10</b> coupled to a variety of system components through a bus bridge <b>202</b> is shown. Other embodiments are possible and contemplated. In the depicted system, a main memory <b>204</b> is coupled to bus bridge <b>202</b> through a memory bus <b>206</b>, and a graphics controller <b>208</b> is coupled to bus bridge <b>202</b> through an AGP bus <b>210</b>. Finally, a plurality of PCI devices <b>212</b>A-<b>212</b>B are coupled to bus bridge <b>202</b> through a PCI bus <b>214</b>. A secondary bus bridge <b>216</b> may further be provided to accommodate an electrical interface to one or more EISA or ISA devices <b>218</b> through an EISA/ISA bus <b>220</b>. Processor <b>10</b> is coupled to bus bridge <b>202</b> through bus interface <b>46</b>.</p><p>Bus bridge <b>202</b> provides an interface between processor <b>10</b>, main memory <b>204</b>, graphics controller <b>208</b>, and devices attached to PCI bus <b>214</b>. When an operation is received from one of the devices connected to bus bridge <b>202</b>, bus bridge <b>202</b> identifies the target of the operation (e.g. a particular device or, in the case of PCI bus <b>214</b>, that the target is on PCI bus <b>214</b>). Bus bridge <b>202</b> routes the operation to the targeted device. Bus bridge <b>202</b> generally translates an operation from the protocol used by the source device or bus to the protocol used by the target device or bus.</p><p>In addition to providing an interface to an ISA/EISA bus for PCI bus <b>214</b>, secondary bus bridge <b>216</b> may further incorporate additional functionality, as desired. For example, in one embodiment, secondary bus bridge <b>216</b> includes a master PCI arbiter (not shown) for arbitrating ownership of PCI bus <b>214</b>. An input/output controller (not shown), either external from or integrated with secondary bus bridge <b>216</b>, may also be included within computer system <b>200</b> to provide operational support for a keyboard and mouse <b>222</b> and for various serial and parallel ports, as desired. An external cache unit (not shown) may further be coupled to bus interface <b>46</b> between processor <b>10</b> and bus bridge <b>202</b> in other embodiments. Alternatively, the external cache may be coupled to bus bridge <b>202</b> and cache control logic for the external cache may be integrated into bus bridge <b>202</b>.</p><p>Main memory <b>204</b> is a memory in which application programs are stored and from which processor <b>10</b> primarily executes. A suitable main memory <b>204</b> comprises DRAM (Dynamic Random Access Memory), and preferably a plurality of banks of SDRAM (Synchronous DRAM).</p><p>PCI devices <b>212</b>A-<b>212</b>B are illustrative of a variety of peripheral devices such as, for example, network interface cards, video accelerators, audio cards, hard or floppy disk drives or drive controllers, SCSI (Small Computer Systems Interface) adapters and telephony cards. Similarly, ISA device <b>218</b> is illustrative of various types of peripheral devices, such as a modem, a sound card, and a variety of data acquisition cards such as GPIB or field bus interface cards.</p><p>Graphics controller <b>208</b> is provided to control the rendering of text and images on a display <b>226</b>. Graphics controller <b>208</b> may embody a typical graphics accelerator generally known in the art to render three-dimensional data structures which can be effectively shifted into and from main memory <b>204</b>. Graphics controller <b>208</b> may therefore be a master of AGP bus <b>210</b> in that it can request and receive access to a target interface within bus bridge <b>202</b> to thereby obtain access to main memory <b>204</b>. A dedicated graphics bus accommodates rapid retrieval of data from main memory <b>204</b>. For certain operations, graphics controller <b>208</b> may further be configured to generate PCI protocol transactions on AGP bus <b>210</b>. The AGP interface of bus bridge <b>202</b> may thus include functionality to support both AGP protocol transactions as well as PCI protocol target and initiator transactions. Display <b>226</b> is any electronic display upon which an image or text can be presented. A suitable display <b>226</b> includes a cathode ray tube (\u201cCRT\u201d), a liquid crystal display (\u201cLCD\u201d), etc.</p><p>It is noted that, while the AGP, PCI, and ISA or EISA buses have been used as examples in the above description, any bus architectures may be substituted as desired. It is further noted that computer system <b>200</b> may be a multiprocessing computer system including additional processors (e.g. processor <b>10</b><i>a </i>shown as an optional component of computer system <b>200</b>). Processor <b>10</b><i>a </i>may be similar to processor <b>10</b>. More particularly, processor <b>10</b><i>a </i>may be an identical copy of processor <b>10</b>. Processor <b>10</b><i>a </i>may share bus interface <b>46</b> with processor <b>10</b> (as shown in FIG. 13) or may be connected to bus bridge <b>202</b> via an independent bus.</p><p>In accordance with the above disclosure, a method for selectively invalidating and retaining instructions according to a forward branch target address of a branch instruction has been shown. Instead of discarding all instructions and fetching the branch target address, instructions which are not predicted to be executed are invalidated while other instructions are kept. Sequential fetching of the subsequent instructions may be performed. Fetch bandwidth may be increased due to the retaining of instructions already fetched from the branch target concurrent with the branch instruction and allowing sequential fetching of additional instructions to continue.</p><p>Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "David B.", "last_name": "Witt", "name": ""}, {"first_name": "William M.", "last_name": "Johnson", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}, {"first_name": "", "last_name": "GLOBALFOUNDRIES U.S. INC.", "name": ""}, {"first_name": "", "last_name": "GLOBALFOUNDRIES INC.", "name": ""}, {"first_name": "", "last_name": "ADVANCED MICRO DEVICES, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  15/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMEP"}, {"label": "G06F   9/30        20060101A I20051008RMEP"}, {"label": "G06F   9/32        20060101A I20051008RMEP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712236"}], "ecla_classes": [{"label": "G06F   9/30A3C"}, {"label": "G06F   9/38E1"}, {"label": "G06F   9/30A1C"}, {"label": "G06F   9/38B2"}, {"label": "G06F   9/30A3S"}, {"label": "G06F   9/38D2"}, {"label": "G06F  12/08B22L"}, {"label": "G06F  12/08B8"}, {"label": "G06F   9/38E2"}], "cpc_classes": [{"label": "G06F  12/0862"}, {"label": "G06F   9/3842"}, {"label": "G06F   9/383"}, {"label": "G06F   9/3804"}, {"label": "G06F   9/30021"}, {"label": "G06F   9/30058"}, {"label": "G06F   9/30069"}, {"label": "G06F   9/3804"}, {"label": "G06F   9/3838"}, {"label": "G06F   9/383"}, {"label": "G06F   9/30058"}, {"label": "G06F   9/30021"}, {"label": "G06F   9/30069"}, {"label": "G06F  12/0862"}, {"label": "G06F  12/0897"}, {"label": "G06F   9/3838"}, {"label": "G06F  12/0897"}, {"label": "G06F   9/3842"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1997-11-17", "application_date": "1998-07-06", "family_members": [{"ucid": "US-6256728-B1", "titles": [{"lang": "EN", "text": "Processor configured to selectively cancel instructions from its pipeline responsive to a predicted-taken short forward branch instruction"}]}]}