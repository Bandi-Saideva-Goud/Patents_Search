{"patent_number": "US-6223198-B1", "publication_id": 72656247, "family_id": 22462083, "publication_date": "2001-04-24", "titles": [{"lang": "EN", "text": "Method and apparatus for multi-function arithmetic"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11180278\" source=\"national office\"><p>A multiplier capable of performing signed and unsigned scalar and vector multiplication is disclosed. The multiplier is configured to receive signed or unsigned multiplier and multiplicand operands in scalar or packed vector form. An effective sign for the multiplier and multiplicand operands may be calculated and used to create and select a number of partial products according to Booth's algorithm. Once the partial products have been created and selected, they may be summed and the results may be output. The results may be signed or unsigned, and may represent vector or scalar quantities. When a vector multiplication is performed, the multiplier may be configured to generate and select partial products so as to effectively isolate the multiplication process for each pair of vector components. The multiplier may also be configured to sum the products of the vector components to form the vector dot product. The final product may be output in segments so as to require fewer bus lines. The segments may be rounded by adding a rounding constant. Rounding and normalization may be performed in two paths, one assuming an overflow will occur, the other assuming no overflow will occur. The multiplier may also be configured to perform iterative calculations to evaluate constant powers of an operand. Intermediate products that are formed may be rounded and normalized in two paths and then compressed and stored for use in the next iteration. An adjustment constant may also be added to increase the frequency of exactly rounded results.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72547331\"><p>A multiplier capable of performing signed and unsigned scalar and vector multiplication is disclosed. The multiplier is configured to receive signed or unsigned multiplier and multiplicand operands in scalar or packed vector form. An effective sign for the multiplier and multiplicand operands may be calculated and used to create and select a number of partial products according to Booth's algorithm. Once the partial products have been created and selected, they may be summed and the results may be output. The results may be signed or unsigned, and may represent vector or scalar quantities. When a vector multiplication is performed, the multiplier may be configured to generate and select partial products so as to effectively isolate the multiplication process for each pair of vector components. The multiplier may also be configured to sum the products of the vector components to form the vector dot product. The final product may be output in segments so as to require fewer bus lines. The segments may be rounded by adding a rounding constant. Rounding and normalization may be performed in two paths, one assuming an overflow will occur, the other assuming no overflow will occur. The multiplier may also be configured to perform iterative calculations to evaluate constant powers of an operand. Intermediate products that are formed may be rounded and normalized in two paths and then compressed and stored for use in the next iteration. An adjustment constant may also be added to increase the frequency of exactly rounded results.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00001\" num=\"1\"><claim-text>1. A microprocessor comprising</claim-text><claim-text>a first means for multiplying a first multiplier operand and a first multiplicand operand; and </claim-text><claim-text>a second means for multiplying a second multiplier operand and a second multiplicand operand; </claim-text><claim-text>wherein said first and second means for multiplying are coupled together and are configured to perform at least two types of multiplication, wherein said first type of multiplication is vector multiplication and is performed when said first and second multiplicand operands each comprise different components of a vector multiplicand operand and said first and second multiplier operands each comprise different components of a vector multiplier operand, </claim-text><claim-text>wherein said first and second means for multiplying generate a preliminary result in redundant form, and wherein said microprocessor further comprises: </claim-text><claim-text>an overflow logic means for generating a first non-redundant form result based on said preliminary result, wherein said overflow logic means generates said first non-redundant form result assuming an overflow will occur; </claim-text><claim-text>a non-overflow logic means for generating a second non-redundant form result based on said preliminary result, wherein said non-overflow logic means generates said second non-redundant form result assuming that no overflow will occur; and </claim-text><claim-text>a selection means for selecting either said first or second result as a final result. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00002\" num=\"2\"><claim-text>2. The microprocessor as recited in claim <b>1</b>, wherein said second type of multiplication is scalar multiplication and is performed in response to said first and second multiplicand operands both comprising different portions of a single N-bit scalar multiplicand and said first and second multiplier operands both comprising different portions of a single N-bit scalar multiplier, wherein said scalar multiplication is performed in parallel in said first and second multiplier means and results in a 2N-bit wide scalar result.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00003\" num=\"3\"><claim-text>3. The microprocessor as recited in claim <b>2</b>, wherein said first multiplier means is configured to propagate carry values to said second multiplier means only in response to said scalar multiplication being performed.</claim-text></claim>"}, {"num": 4, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00004\" num=\"4\"><claim-text>4. The microprocessor as recited in claim <b>2</b>, wherein said first and second multiplier means are configured to perform a third type of multiplication, wherein said third type of multiplication is independent vector multiplication and is performed in response to said first and second multiplier operands and said first and second multiplicand operands each comprising an independent vector having at least two vector components.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00005\" num=\"5\"><claim-text>5. The microprocessor as recited in claim <b>4</b>, wherein said first and second multiplier means are further configured to perform a fourth type of multiplication, wherein said fourth type of multiplication is independent scalar multiplication and is performed in response to said first and second multiplier operands and said first and second multiplicand operands each comprising an independent scalar value.</claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00006\" num=\"6\"><claim-text>6. The microprocessor as recited in claim <b>5</b>, wherein said first and second multiplier means each comprise:</claim-text><claim-text>a partial product array adder configured to sum a plurality of partial products to generate said preliminary redundant form result. </claim-text></claim>"}, {"num": 7, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00007\" num=\"7\"><claim-text>7. A multiplier capable of multiplying one pair of N-bit operands or two pairs of N/2-bit operands simultaneously comprising:</claim-text><claim-text>a multiplier input configured to receive a multiplier operand, wherein said multiplier operand comprises one N-bit value or two N/2-bit values; </claim-text><claim-text>a multiplicand input configured to receive a multiplicand operand, wherein said multiplicand operand comprises one N-bit value or two N/2-bit values; </claim-text><claim-text>a partial product generator coupled to said multiplicand input, wherein said partial product generator is configured to generate a plurality of partial products based upon said multiplicand operand; </claim-text><claim-text>a selection logic unit coupled to said partial product generator and said multiplier input, wherein said selection logic unit is configured to select a plurality of partial products from said partial product generator based upon said multiplier operand; </claim-text><claim-text>a partial product array adder coupled to said selection logic unit, wherein said adder comprises a less significant portion and a more significant portion, wherein said adder is configured to sum the partial products selected by said selection unit to create a redundant-form final product comprises either a single 2N-bit value or two N-bit values, wherein said less significant portion is configured to propagate carry information to said more significant portion only when said multiplier is multiplying two N-bit numbers; </claim-text><claim-text>an overflow logic unit coupled to said partial product array adder and configured to convert said redundant-form final product into a first non-redundant form result assuming an overflow will occur during the formation of said redundant-form product; </claim-text><claim-text>a non-overflow logic unit coupled to said partial product array adder and configured to convert said redundant form final product into a second non-redundant form result assuming that no overflow will occur during the formation of said redundant form product; and </claim-text><claim-text>a multiplexer configured to select either said first or second non-redundant form result as the final non-redundant form result. </claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00008\" num=\"8\"><claim-text>8. The multiplier as recited in claim <b>7</b>, wherein said multiplier operand and said multiplicand operand each comprise a vector.</claim-text></claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00009\" num=\"9\"><claim-text>9. The multiplier as recited in claim <b>7</b>, further comprising:</claim-text><claim-text>a second adder coupled to said multiplexer, wherein said second adder is configured to receive said final non-redundant form result and sum it with an adjustment constant to form a first adjusted result; </claim-text><claim-text>a third adder coupled to said multiplexer, wherein said third adder is configured to receive said final non-redundant form result and subtract an adjustment constant to form a second adjusted result; and </claim-text><claim-text>a second multiplexer configured to select either said final non-redundant form result, said first adjusted result, or said second adjusted result for output. </claim-text></claim>"}, {"num": 10, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00010\" num=\"10\"><claim-text>10. The multiplier as recited in claim <b>7</b>, further comprising:</claim-text><claim-text>a rounding constant selection unit configured to select a rounding constant based upon the selected rounding mode, wherein said partial product array adder comprises a plurality of carry-save adders, wherein said partial product array adder is configured to sum said rounding constant with the partial products selected by said selection unit to create said redundant-form final product. </claim-text></claim>"}, {"num": 11, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00011\" num=\"11\"><claim-text>11. The multiplier as recited in claim <b>7</b>, wherein said multiplier operand and said multiplicand operand each comprise a single scalar value.</claim-text></claim>"}, {"num": 12, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00012\" num=\"12\"><claim-text>12. The multiplier as recited in claim <b>7</b>, wherein said multiplier operand and said multiplicand operand each comprise a single floating point value.</claim-text></claim>"}, {"num": 13, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00013\" num=\"13\"><claim-text>13. The multiplier as recited in claim <b>7</b>, wherein said multiplier operand and said multiplicand operand each comprise a single integer value.</claim-text></claim>"}, {"num": 14, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00014\" num=\"14\"><claim-text>14. The multiplier as recited in claim <b>7</b>, wherein said multiplier operand and said multiplicand operand each comprise the same number of values, wherein said number of values is greater than two.</claim-text></claim>"}, {"num": 15, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00015\" num=\"15\"><claim-text>15. A microprocessor comprising:</claim-text><claim-text>an instruction cache, </claim-text><claim-text>one or more instruction decoders coupled to the instruction cache, wherein the instruction decoders are configured to receive and decode instructions from the instruction cache, and </claim-text><claim-text>a multiplier, wherein the multiplier is configured to receive decoded instructions from the instruction decoders, wherein the multiplier comprises: </claim-text><claim-text>a multiplier input configured to receive a multiplier operand; </claim-text><claim-text>a multiplicand input configured to receive a multiplicand operand; </claim-text><claim-text>a partial product generator coupled to said multiplicand input, wherein said partial product generator is configured to generate a plurality of partial products based on said multiplicand operand; </claim-text><claim-text>a selection logic unit coupled to said partial product generator and said multiplier input, wherein said selection logic unit is configured to select a plurality of partial products from said partial product generator based upon said multiplier operand; and </claim-text><claim-text>a plurality of adders coupled to said selection logic unit, wherein said adders are configured to sum the partial products selected by said selection unit to create a redundant-form final product and sum the redundant-form final product to form two results, wherein the first result assumes an overflow occurs, wherein the second result assumes that an overflow does not occur. </claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00016\" num=\"16\"><claim-text>16. The microprocessor of claim <b>15</b>, wherein said multiplier also includes a multiplexer configured to select either said first result or second result as a final result.</claim-text></claim>"}, {"num": 17, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00017\" num=\"17\"><claim-text>17. The microprocessor of claim <b>15</b>, wherein said multiplicand operand and said multiplier operand are vectors each comprising two or more floating point values.</claim-text></claim>"}, {"num": 18, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00018\" num=\"18\"><claim-text>18. The microprocessor of claim <b>15</b>, wherein said multiplicand operand and said multiplier operand are vectors each comprising two or more integer values.</claim-text></claim>"}, {"num": 19, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6223198-B1-CLM-00019\" num=\"19\"><claim-text>19. The microprocessor of claim <b>15</b>, wherein said multiplicand operand and said multiplier operand are vectors each comprising one scalar value.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54535098\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention relates generally to the field of microprocessors and, more particularly, to rounding the results of iterative calculations in microprocessors.</p><p>2. Description of the Related Art</p><p>Microprocessors are typically designed with a number of \u201cexecution units\u201d that are each optimized to perform a particular set of functions or instructions. For example, one or more execution units within a microprocessor may be optimized to perform memory accesses, i.e., load and store operations. Other execution units may be optimized to perform general arithmetic and logic functions, e.g., shifts and compares. Many microprocessors also have specialized execution units configured to perform more complex arithmetic operations such as multiplication and reciprocal operations. These specialized execution units typically comprise hardware that is optimized to perform one or more particular arithmetic functions. In the case of multiplication, the optimized hardware is typically referred to as a \u201cmultiplier.\u201d</p><p>In older microprocessors, multipliers were implemented using designs that conserved die space at the expense of arithmetic performance. Until recently, this was not a major problem because most applications, i.e., non-scientific applications such as word processors, did not frequently generate multiplication instructions. However, recent advances in computer technology and software are placing greater emphasis upon multiplier performance. For example, three dimensional computer graphics, rendering, and multimedia applications all rely heavily upon a microprocessor's arithmetic capabilities, particularly multiplication and multiplication-related operations. As a result, in recent years microprocessor designers have favored performance-oriented designs that use more die space. Unfortunately, the increased die space needed for these high performance multipliers reduces the space available for other execution units within the microprocessor. Thus, a mechanism for increasing multiplier performance while conserving die space in needed.</p><p>The die space used by multipliers is of particular importance to microprocessor designers because many microprocessors, e.g., those configured to execute MM (multimedia extension) or 3D graphics instructions, may use more than one multiplier. MMX and 3D graphics instructions are often implemented as \u201cvectored\u201d instructions. Vectored instructions have operands that are partitioned into separate sections, each of which is independently operated upon. For example, a vectored multiply instruction may operate upon a pair of 32-bit operands, each of which is partitioned into two 16-bit sections or four 8-bit sections. Upon execution of a vectored multiply instruction, corresponding sections of each operand are independently multiplied. FIG. 1 illustrates the differences between a scalar (i.e., non-vectored) multiplication and a vector multiplication. To quickly execute vectored multiply instructions, many microprocessors use a number of multipliers in parallel. In order to conserve die space, a mechanism for reducing the number of multipliers in a microprocessor is desirable. Furthermore, a mechanism for reducing the amount of support hardware (e.g., bus lines) that may be required for each multiplier is also desirable.</p><p>Another factor that may affect the number of multipliers used within a microprocessor is the microprocessor's ability to operate upon multiple data types. Most microprocessors must support multiple data types. For example, x86 compatible microprocessors execute instructions that are defined to operate upon an integer data type and instructions that are defined to operate upon floating point data types. Floating point data can represent numbers within a much larger range than integer data. For example, a 32-bit signed integer can represent the integers between \u22122<sup>31 </sup>and 2<sup>31</sup>\u22121 (using two's complement format). In contrast, a 32-bit (\u201csingle precision\u201d) floating point number as defined by the Institute of Electrical and Electronic Engineers (IEEE) Standard 754 has a range (in normalized format) from 2<sup>\u2212126 </sup>to 2<sup>127</sup>\u00d7(2\u22122<sup>\u221223</sup>) in both positive and negative numbers. While both integer and floating point data types are capable of representing positive and negative values, integers are considered to be \u201csigned\u201d for multiplication purposes, while floating point numbers are considered to be \u201cunsigned.\u201d Integers are considered to be signed because they are stored in two's complement representation.</p><p>Turning now to FIG. 2A, an exemplary format for an 8-bit integer <b>100</b> is shown As illustrated in the figure, negative integers are represented using the two's complement format <b>104</b>. To negate an integer, all bits are inverted to obtain the one's complement format <b>102</b>. A constant of one is then added to the least significant bit (LSB).</p><p>Turning now to FIG. 2B, an exemplary format for a 32-bit (single precision) floating point number is shown. A floating point number is represented by a significand, an exponent and a sign bit. The base for the floating point number is raised to the power of the exponent and multiplied by the significand to arrive at the number represented. In microprocessors, base <b>2</b> is typically used. The significand comprises a number of bits used to represent the most significant digits of the number. Typically, the significand comprises one bit to the left of the radix point and the remaining bits to the right of the radix point In order to save space, the bit to the left of the radix point, known as the integer bit, is not explicitly stored. Instead, it is implied in the format of the number. Additional information regarding floating point numbers and operations performed thereon may be obtained in IEEE Standard 754. Unlike the integer representation, two's complement format is not typically used in the floating point representation. Instead, sign and magnitude form are used. Thus, only the sign bit is changed when converting from a positive value 106 to a negative value 108. For this reason, many microprocessors use two multipliers, i.e., one for signed values (two's complement format) and another for unsigned values (sign and magnitude format). Thus, a mechanism for increasing floating point, integer, and vector multiplier performance while conserving die space is needed.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by a multiplier configured in accordance with the present invention. In one embodiment, the multiplier may perform signed and unsigned scalar and vector multiplication using the same hardware. The multiplier may receive either signed or unsigned operands in either scalar or packed vector format and accordingly output a signed or unsigned result that is either a scalar or a vector quantity. Advantageously, this embodiment may reduce the total number of multipliers needed within a microprocessor because it may be shared by execution units and perform both scalar and vector multiplication. This space savings may in turn allow designers to optimize the multiplier for speed without fear of using too much die space.</p><p>In another embodiment, speed may be increased by configuring the multiplier to perform fast rounding and normalization. This may be accomplished configuring the multiplier to calculate two version of an operand, e.g., an overflow version and a non-overflow version, in parallel and then select between the two versions.</p><p>In other embodiments, the multiplier may be further optimized to perform certain calculations such as evaluating constant powers of an operand (e.g., reciprocal or reciprocal square root operations). Iterative formulas may be used to recast these operations into multiplication operations. Iterative formulas generate intermediate products which are used in subsequent iterations to achieve greater accuracy. In some embodiments, the multiplier may be configured to store these intermediate products for future iterations. Advantageously, the multiplier may be configured to compress these intermediate products before storing them, which may further conserve die space.</p><p>In one embodiment, the multiplier may comprise a partial product generator, a selection logic unit, and an adder. The multiplier may also comprise a multiplicand input configured to receive a multiplicand operand (signed or unsigned), a multiplier input configured to receive a multiplier operand (also signed or unsigned), and a sign-in input. The sign-in input is configured to receive a sign-in signal indicative of whether the multiplier is to perform signed or unsigned multiplication. The partial product generator, which is coupled to the multiplicand input, is configured to generate a plurality of partial products based upon the multiplicand operand. The selection logic unit, which is coupled to the partial product generator and the multiplier input, is configured to select a number of partial products from the partial product generator based upon the multiplier operand. The adder, which is coupled to the selection logic unit, is configured to sum the selected partial products to form a final product. The final product, which may be signed or unsigned, may then be output to other parts of the microprocessor.</p><p>In addition, the multiplier may further comprise an \u201ceffective sign\u201d calculation unit. In one embodiment, the calculation unit may comprise a pair of AND gates, each configured to receive the most significant bit of one operand and the sign-in signal. The output of each AND gate is used as the effective sign for that gate's operand. The effective sign may be appended to each operand for use as the operand's sign during the multiplication process. Advantageously, the effective sign may allow both unsigned operands and signed operands to be multiplied on die same hardware.</p><p>A method for operating a multiplier within a microprocessor is also contemplated. In one embodiment, the method comprises receiving a multiplier operand, a multiplicand operand, and a sign-in signal from other functional units within the microprocessor. An effective sign bit for the multiplicand operand is generated from the sign-in signal and the most significant bit of the multiplicand operand. A plurality of partial products may then be calculated from the effective sign bit and the multiplicand operand. Next, a number of the partial products may be selected according to the multiplier operand. The partial products are then summed, and the results are output. In other embodiments, the steps may be performed in parallel or in a different order.</p><p>In another embodiment, the multiplier may be capable of multiplying one pair of N-bit operands or two pairs of N/2-bit operands simultaneously. The multiplier may comprise a multiplier input and a multiplicand input, each configured to receive an operand comprising one N-bit value or two N/2-bit values. The multiplier may also comprise a partial product generator coupled to the multiplicand input, wherein the partial product generator is configured to generate a plurality of partial products based upon the value of the multiplicand operand. The multiplier may further comprise a selection logic unit coupled to the partial product generator and the multiplier input. The selection logic unit may be configured to select a plurality of partial products from the partial product generator based upon the value of the multiplier operand. An adder may be coupled to the selection logic unit to receive and sum the selected partial products to form a final product comprising either one 2N-bit value or two N-bit values. The multiplier may receive a vector_in signal indicating whether vector or scalar multiplication is to be formed.</p><p>A method for operating a multiplier capable of scalar and vector multiplication is also contemplated. The method may comprise receiving a multiplier operand, a multiplicand operand, and a vector-in signal as inputs from functional units within the microprocessor and then calculating a number of partial products from the multiplicand operand using inverters and shifting logic. Certain partial products may be selected according to the multiplier operand. The selected partial products may then be summed to generate a final product. The final product may be in scalar form if the vector_in signal is unasserted, and in vector form if the vector_in signal is asserted.</p><p>In another embodiment, the multiplier may also be configured to calculate vector dot products and may comprise a multiplier input and a multiplicand input, each configured to receive a vector. A partial product generator may be coupled to the multiplicand input and may be configured to generate a plurality of partial products based upon one of the vectors. A first adder may be coupled to receive the partial products and sum them to generate vector component products for each pair of vector components. A second adder may be coupled to the first adder and may be configured to receive and sum the vector component products to form a sum value and a carry value. A third adder may be configured to receive the sum and carry values and one or more vector component products from the first adder. The third adder may be configured to output the sum of the sum and carry values (and any carry bits resulting from the summation of the one or more vector components) as a final result.</p><p>In yet another embodiment, the multiplier may be configured to output the results in segments or portions. This may advantageously reduce the amount of interface logic and the number of bus lines needed to support the multiplier. Furthermore, the segments or portions may be rounded. In this embodiment, the multiplier may comprise a multiplier input, a multiplicand input, and a partial product generator. The generator is coupled to the multiplicand input and i.e., configured to generate one or more partial products. An adder, coupled to the partial product generator and the multiplier input, may be configured to receive a number of the partial products. The adder may sum the partial products together with rounding constants to form a plurality of vector component products which are logically divided into portions. One or more of the portions may be rounded.</p><p>In another embodiment, the multiplier may be configured to round its outputs in a number of different modes. Thus, an apparatus and method for rounding and normalizing results within a multiplier is also contemplated. In one embodiment, the apparatus comprises an adder configured to receive a plurality of redundant-form components. The adder is configured to sum the redundant-form components to generate a first non-redundant-form result. The adder may also be configured to generate a second non-redundant-form result comprising the sum of the redundant-form components plus a constant. Two shifters are configured to receive the results. Both shifters may be controlled by the most significant bits of the results they receive. A multiplexer may be coupled to receive the output from the shifters and select one of them for output based upon the least significant bits in the first non-redundant-form result. By generating more than version of the result (e.g., the result and the result plus a constant) in parallel, rounding may be accomplished in less time than previously required.</p><p>A multiplier configured to round and normalize products is also contemplated. In one embodiment, the multiplier may comprise two paths. Each path may comprise one or more adders, each configured to receive a redundant-form product and reduce it to a non-redundant form. The first path does so assuming no overflow will occur, while the second path does so assuming an overflow will occur. A multiplexer may be coupled to the outputs of the two paths, so as to select between the results from the first and second paths.</p><p>A method for rounding and normalizing results within a multiplier is also contemplated. In one embodiment, the method comprises multiplying a first operand and a second operand to form a plurality of redundant-form components. A rounding constant is generated and added to the redundant-form component in two different bit positions. The first position assumes an overflow will occur, while the second position assumes no overflow will occur. A particular set of bits are selected for output as the final result from either the first addition or the second addition.</p><p>Also contemplated is an apparatus for evaluating a constant power of an operand using a multiplier. In one embodiment, the apparatus comprises an initial estimate generator configured to receive the operand and output an initial estimate of the operand raised to the desired constant power. A multiplier may be coupled to receive the operand and the initial estimate, wherein the multiplier is configured to calculate the product of the initial estimate and the operand. A first plurality of inverters may be coupled to receive, invert, and normalize selected bits from the product to form a first approximation, wherein the first approximation assumes an overflow has occurred in the multiplier. A second plurality of inverters may be coupled to receive, invert, and normalize selected bits from the product to form a second approximation, wherein the second approximation assumes an overflow has not occurred in the multiplier. A multiplexer may be configured to select either the first or second approximations for output.</p><p>Also contemplated is a method for evaluating a constant power of an operand using a multiplier. In one embodiment, the method comprises determining an initial estimate of the operand raised to a first constant power. The operand and the initial estimate are then multiplied in the multiplier to form a first product. A normalized first intermediate approximation is calculated by performing a bit-wise inversion on the first product assuming an overflow occurred during the multiplying. A normalized second intermediate approximation is calculated by performing a bit-wise inversion on the first product assuming no overflow occurred during the multiplying. Finally, a set of bits are selected from either the first intermediate approximation or the second intermediate approximation to form a selected approximation that may be output or used in subsequent iterations to achieve a more accurate result.</p><p>An apparatus for rounding and normalizing a redundant-form value is also contemplated. In one embodiment, the apparatus may comprise two adders and a multiplexer. The first adder is configured to receive the redundant-form value and add a rounding constant to its guard bit position, thereby forming a first rounded result, wherein the guard bit position is selected assuming no overflow will occur. The second adder is similarly configured and performs the same addition assuming, however, that an overflow will occur. A multiplexer is configured to select either the first rounded result or the second rounded result based upon one or more of the most significant bits from the first and second rounded results. Performing the rounding in parallel may advantageously speed the process by allowing normalization to take place in parallel with the multiplexer's selection.</p><p>A method for operating a multiplier that compresses intermediate results is also contemplated. In one embodiment, this method comprises calculating an intermediate product to a predetermined number of bits of accuracy. Next, a signaling bit is selected from the intermediate product. The signaling bit is equal to each of the N most significant bits of the intermediate product. Next the intermediate product is compressed by replacing the N most significant bits of the intermediate product with the signaling bit. The compressed intermediate product is then stored into a storage register. During the next iteration, the storage register is read to determine the value of the compressed intermediate product. The compressed intermediate product may be expanded to form an expanded intermediate product by padding, the compressed intermediate product with copies of the signaling bit.</p><p>A multiplier configured to perform iterative calculations and to compress intermediate products is also contemplated. In one embodiment, the multiplier comprises a multiplier input, a multiplicand input, and a partial product generator as described in previous embodiments. The multiplier also comprises a partial product array adder which is configured to receive and add a selected plurality of partial products to form an intermediate product. Compression logic may be coupled to the partial product array adder. The compression logic may comprise a wire shifter configured to replace a predetermined number of bits of the intermediate product with a single signal bit, which represents the information stored in the predetermined number of bits. The signal bit is selected so that it equals the value of each individual bit within the predetermined number of bits. A storage register may be coupled to receive and store the compressed intermediate product from the compression logic.</p><p>In another embodiment, the multiplier may be configured to add an adjustment constant to increase the frequency of exactly rounded results. In such an embodiment, the multiplier may comprise a multiplier input configured to receive a multiplier operand, a multiplicand input configured to receive a multiplicand operand, a partial product generator, and selection logic. In one embodiment, the partial product generator is coupled to the multiplicand input and configured to generate one or more partial products based upon the multiplicand operand. The selection logic may be coupled to the partial product generator and the multiplier, wherein the selection logic is configured to select a plurality of partial products based upon the multiplier. The partial product array adder may be coupled to the selection logic, wherein the adder is configured to receive and sum a number of the partial products and an adjustment constant to form a product. The adjustment constant is selected to increase the frequency that the result is exactly rounded.</p><p>A method for increasing the frequency of exactly rounded results is also contemplated. In one embodiment, the method comprises receiving an operand and determining an initial estimate of the result of an iterative calculation using the operand. The initial estimate and the operand are multiplied to generate an intermediate result. The multiplication is repeated a predetermined number of times, wherein the intermediate result is used in place of the initial estimate in subsequent iterations. The final repetition generates a final result, and an adjustment constant may be added to the final result, wherein the adjustment constant increases the probability that the final result will equal the exactly rounded result of the iterative calculation.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a diagram illustrating an exemplary scalar multiplication and an exemplary vector multiplication.</p><p>FIG. 2A is a diagram of an exemplary integer data format using two's complement representation.</p><p>FIG. 2B is a diagram of an exemplary floating point data format.</p><p>FIG. 3 is a block diagram of one embodiment of an exemplary microprocessor.</p><p>FIG. 4 is a block diagram of one embodiment of the computational core from the microprocessor of FIG. <b>3</b>.</p><p>FIG. 5A illustrates one embodiment of the shift-and-add algorithm for binary multiplication.</p><p>FIG. 5B illustrates one embodiment of Booth's algorithm for binary multiplication.</p><p>FIG. 6 is a block diagram illustrating details of one embodiment of the multiplier from FIG. <b>4</b>.</p><p>FIG. 7 is a block diagram illustrating the operation of the multiplier from FIG. 6 for unsigned operands.</p><p>FIG. 8 is a block diagram illustrating an example of the operation of the multiplier from FIG. 6 for signed operands.</p><p>FIG. 9 is a block diagram illustrating another example of the operation of the multiplier from FIG. 6 for signed operands.</p><p>FIG. 10 is a diagram illustrating one embodiment of the multiplier from FIG. 4 that is configured to perform vector multiplication.</p><p>FIG. 11A is a diagram that illustrates details of one embodiment of the partial product generator from FIG. <b>6</b>.</p><p>FIG. 11B is a diagram that illustrates in detail part of one embodiment of the selection logic from FIG. <b>6</b>.</p><p>FIGS. 12A-B is a diagram that illustrates details of one embodiment of the selection logic and adder from FIG. <b>6</b>.</p><p>FIG. 13 is a diagram illustrating another embodiment of the multiplier from FIG. 4 that is configured to perform vector multiplication.</p><p>FIG. 14 is a diagram illustrating yet another embodiment of the multiplier from FIG. 4 that is configured to perform vector multiplication.</p><p>FIG. 15 is a diagram illustrating one embodiment of a multiplier that is configured to calculate the vector dot product of a pair of vector operands.</p><p>FIG. 16 is a diagram illustrating another embodiment of a multiplier that is configured to calculate the vector dot product of a pair of vector operands.</p><p>FIG. 17 is a diagram illustrating one embodiment of a multiplier that is configured to return vector component products in portions, some of which may be rounded.</p><p>FIG. 18 is a diagram illustrating another embodiment of a multiplier that is configured to return vector component products in portions, some of which may be rounded.</p><p>FIG. 19 is a diagram illustrating one embodiment of the multiplier from FIG. 6 configured to perform rounding.</p><p>FIG. 20 is a diagram illustrating a numerical example of the operation of the multiplier from FIG. <b>19</b>.</p><p>FIG. 21 is a diagram illustrating details of one embodiment of the sticky bit logic from FIG. <b>19</b>.</p><p>FIG. 22 is a diagram illustrating a numerical example of the operation of the multiplier from FIG. <b>19</b>.</p><p>FIG. 23 is a diagram illustrating another embodiment of the multiplier from FIG. <b>6</b>.</p><p>FIG. 24 is a flowchart illustrating one embodiment of a method for calculating the reciprocal of an operand.</p><p>FIG. 25 is a flowchart illustrating one embodiment of a method for calculating the reciprocal square root of an operand.</p><p>FIG. 26 is a diagram illustrating one embodiment of the multiplier from FIG. 6 that is configured to perform iterative calculations.</p><p>FIG. 27 is a diagram illustrating details of one exemplary embodiment of the non-overflow and overflow logic units from FIG. <b>26</b>.</p><p>FIG. 28 is a diagram illustrating details of another exemplary embodiment of non-overflow and overflow logic units from FIG. <b>26</b>.</p><p>FIG. 29A is a flowchart illustrating one possible method for fast compression.</p><p>FIG. 29B is a flowchart illustrating one possible method for fast decompression.</p><p>FIG. 30 is a diagram illustrating one embodiment of the multiplier from FIG. 4 configured to compress intermediate products.</p><p>FIG. 31A is a figure illustrating one possible method for compression.</p><p>FIG. 31B is a figure illustrating another possible method for compression.</p><p>FIG. 32 is a figure illustrating one embodiment of a multiplier configured to achieve a higher frequency of exactly rounded results.</p><p>FIG. 33A is a diagram illustrating an example of a vector multiplication using two multipliers.</p><p>FIG. 33B is a diagram illustrating another example of a multiplication using two multipliers.</p><p>FIG. 34 is a block diagram of one embodiment of a computer system configured to utilize the microprocessor of FIG. <b>3</b>.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF AN EMBODIMENT</h4><p>Turning now to FIG. 3, a block diagram of one embodiment of a microprocessor <b>10</b> is shown. As depicted, microprocessor <b>10</b> comprises a predecode logic block <b>12</b>, a bus interface unit <b>24</b>, and a level one-cache controller <b>18</b>, all of which are coupled to the following three caches: a level-one instruction cache <b>14</b>, a level-one data cache <b>26</b>, and an on-chip level-two cache <b>40</b>. Both instruction cache <b>14</b> and data cache <b>26</b> are configured with translation lookaside buffers, i.e., TLBs <b>16</b> and <b>28</b>, respectively. Microprocessor <b>10</b> further comprises a decode unit <b>20</b> which receives instructions from instruction cache <b>14</b>, decodes them, and then forwards them to an execution engine <b>30</b> in accordance with inputs received from a branch logic unit <b>22</b>.</p><p>Execution engine <b>30</b> comprises a scheduler buffer <b>32</b>, an instruction control unit <b>34</b>, and a plurality of execution units <b>36</b>A-<b>36</b>F. Note that blocks referred to herein with a reference number followed by a letter may be collectively referred to by the reference number alone. For example, execution units <b>36</b>A-F may be collectively referred to as execution units <b>36</b>. Scheduler buffer <b>32</b> is coupled to receive decoded instructions from decode unit <b>20</b> and convey them to execution units <b>36</b> in accordance with input received from instruction control unit <b>34</b>. In one embodiment, execution units <b>36</b>A-F include a load unit <b>36</b>A, a store unit <b>36</b>B, two integer/MMX/3D units <b>36</b>C and <b>36</b>D, a floating point unit <b>36</b>E, and a branch resolving unit <b>36</b>F. Load unit <b>36</b>A receives input from data cache <b>26</b>, while store unit <b>36</b>B interfaces with data cache <b>26</b> via a store queue <b>38</b>. Integer/MMX 3D units <b>36</b>C and <b>36</b>D, and floating point unit <b>36</b>E collectively form a computational core <b>42</b> for microprocessor <b>10</b>. Computational core <b>42</b> may further comprise other execution units and specialized hardware such as multipliers.</p><p>Before describing computational core <b>42</b> in detail, other features of microprocessor 1.0 will be discussed. In one embodiment, instruction cache <b>14</b> is organized into sectors, with each sector including two 32-byte cache lines. The two cache lines within each sector share a common tag but have separate state bits that indicate the status of the line. Accordingly, two forms of cache misses (and associated cache fills) may take place: (1) sector replacement and (2) cache line replacement. In the case of sector replacement, the cache miss is caused by a tag mismatch in instruction cache <b>14</b>. Thus the required cache line is supplied by external memory via bus interface unit <b>24</b>. The cache line within the sector that is not needed is then marked invalid. In the case of a cache line replacement, a tag matches the requested address but the corresponding cache line is marked as invalid. The required cache line is then supplied by external memory, but unlike a sector replacement, the cache line within the sector that was not requested remains unaltered. In alternate embodiments, other organizations and replacement policies for instruction cache <b>14</b> may be utilized.</p><p>In one embodiment, microprocessor <b>10</b> may be configured to perform prefetching only in the case of sector replacements. During sector replacement, the required cache line is filled. If the required cache line is in the first half of the sector, the other cache line in the sector is prefetched. If the required cache line is in the second half of the sector, no prefetching is performed. Other prefetching methodologies may also be employed in different embodiments of microprocessor <b>10</b>.</p><p>When cache lines of instruction data are retrieved from external memory by bus interface unit <b>24</b>, the data is conveyed to predecode logic block <b>12</b>. In one embodiment, the instructions processed by microprocessor <b>10</b> and stored in cache <b>14</b> are variable-length (e.g., the x86 instruction set). Because decoding variable-length instructions is particularly complex, predecode logic <b>12</b> may be configured to provide additional information to be stored in instruction cache <b>14</b> to aid during decode. In one embodiment, predecode logic <b>12</b> generates \u201cpredecode bits\u201d for each byte in instruction cache <b>14</b>. The predecode bits may provide various information useful during the decode process, e.g., the number of bytes to the start of the next variable-length instruction. The predecode bits are passed to decode unit <b>20</b> when instruction bytes are requested from cache <b>14</b>.</p><p>In one embodiment, instruction cache <b>14</b> is implemented as a 32-Kbyte, two-way set-associative, writeback cache. The cache line size may be 32 bytes in this embodiment. Cache <b>14</b> also includes a 64-entry TLB that may be used to speed linear to physical address translation. Other variations of instruction cache <b>14</b> are possible and contemplated.</p><p>Instruction cache <b>14</b> receives instruction fetch addresses from cache controller <b>18</b>. In one embodiment, up to 16 bytes may be fetched from cache <b>14</b> per clock cycle. The fetched information is placed into an instruction buffer that feeds into decode unit <b>20</b>. In one embodiment of microprocessor <b>10</b>, fetching may occur along a single execution stream with seven outstanding branches taken. In another embodiment, fetching may take place along multiple execution streams.</p><p>In one embodiment, the instruction fetch logic within cache controller <b>18</b> is capable of retrieving any 16 contiguous instruction bytes within a 32-byte boundary of cache <b>14</b> with no additional penalty when the 16 bytes cross a cache line boundary. New instructions are loaded into the instruction buffer as the current instructions are consumed by decode unit <b>20</b>. Other configurations of cache controller <b>18</b> are also possible and contemplated.</p><p>In one embodiment, decode logic <b>20</b> may be configured to decode multiple instructions per processor clock cycle. Decode unit <b>20</b> may further be configured to accept instruction and predecode bytes from the instruction buffer (in x86 format), locate actual instruction boundaries, and generates corresponding \u201cRISC ops\u201d. RISC ops are fixed-format internal instructions, most of which are executable by microprocessor <b>10</b> in a single clock cycle. In one embodiment of microprocessor <b>10</b>, RISC ops are combined to form every function in the x86 instruction sit. Microprocessor <b>10</b> may use a combination of decoders to convert x86 instructions into RISC ops. In one embodiment, the hardware comprises three sets of decoders: two parallel short decoders, one long decoder, and one vector decoder. The parallel short decoders translate the most commonly-used x86 instructions (e.g., moves, shifts, branches, etc.) into zro, one, or two RISC ops each. The short decoders only operate on x86 instructions that are up to seven bytes long. IUn addition, they are configured to decode up to two x86 instructions per clock cycle. Commonly-used x-86 instructions which are greater than seven bytes long, as well as those semi-commonly-used instructions that are up to seven bytes long, are handled by the long decoder.</p><p>The long decoder in decode unit <b>20</b> only performs one decode per clock cycle generating up to four RISC ops. All other translations (complex instructions, interrupts, etc.) arare handled by a combination of the vector decoder and an on-chip ROM. For complex operations, the vector decoder logic provides the first set of RISC ops and an initial address to a sequence of further RISC ops within the on-chip ROM. The RISC ops fetched from the on-chip ROM are of the same type that are generated by the hardware decoders.</p><p>In one embodiment, decode unit <b>20</b> generates a group of four RISC ops each clock cycle. For clock cycles in which four RISC ops cannot be generated, decode unit <b>20</b> places RISC NOP operations in the remaining slots of the grouping. These groupings of RISC ops (and possible NOPs) are then conveyed to scheduler buffer <b>32</b>. It is noted that in other embodiments, microprocessor <b>10</b> may be configured to decode other instructions sets in place of, or in addition to, the x86 instruction set.</p><p>Instruction control logic <b>34</b> contains the logic necessary to manage out-of-order execution of instructions stored in scheduler buffer <b>32</b>. Instruction control logic <b>34</b> also manages data forwarding, register renaming, simultaneous issue and retirement of RISC ops, and speculative execution. In one embodiment, scheduler buffer <b>32</b> holds up to <b>24</b> RISC ops at one time, which is equivalent to a maximum of twelve x86 instructions. When possible, instruction control logic <b>34</b> may simultaneously issue (from buffer <b>32</b>) RISC ops to any available execution units <b>36</b>. In one embodiment, control logic <b>34</b> may be configured to issue up to six and retire up to four RISC ops per clock cycle.</p><p>In one embodiment, store unit <b>36</b>A and load unit <b>36</b>B may each have two-stage pipelines. Store unit <b>36</b>A may be configured to perform memory and register writes such that the data is available for loading after one clock cycle. Similarly, load unit <b>36</b>B may be configured to perform memory reads such that the data is available after two clock cycles. Other configurations for load and store units <b>36</b>A and <b>36</b>B are also possible with varying latencies.</p><p>Execution unit <b>36</b>G (the branch resolving unit) is separate from branch prediction logic <b>22</b> in that it resolves conditional branches such as JCC and LOOP after the branch condition has been evaluated. Branch resolving unit <b>36</b>G allows efficient speculative execution, enabling microprocessor <b>10</b> to execute instructions beyond conditional branches before knowing whether the branch prediction was correct As described above, microprocessor <b>10</b> may be configured to handle up to seven outstanding branches in one embodiment.</p><p>Branch prediction logic <b>22</b>, coupled to decode unit <b>20</b>, is configured to increase the accuracy with which conditional branches are predicted in microprocessor <b>10</b>. Ten to twenty percent of the instructions in typical applications include conditional branches. Branch prediction logic <b>22</b> is configured to handle this type of program behavior and its negative effects on instruction execution, such as stalls due to delayed instruction fetching. In one embodiment, branch prediction logic <b>22</b> includes an 8192-entry branch history table, a 16-entry by 16 byte branch target cache, and a 16-entry return address stack. Branch prediction logic <b>22</b> may implement a two-level adaptive history algorithm using the branch history table. The table stores executed branch information, predicts individual branches, and predicts behavior of groups of branches. In one embodiment, the branch history table does not store predicted target addresses in order to save space. Instead, the addresses are calculated on-the-fly during the decode stage.</p><p>To avoid a clock cycle penalty for a cache fetch when a branch is predicted taken, a branch target cache within branch logic <b>22</b> supplies the first 16 bytes at that address directly to the instruction buffer (assuming a hit occurs in the branch target cache). In one embodiment, branch prediction logic <b>22</b> achieves branch prediction rates of over 95%.</p><p>Branch logic <b>22</b> may also include special circuitry designed to optimize the CALL and RET instructions. This circuitry allows the address of the next instruction following the CALL instruction in memory to be pushed onto a return address stack. When microprocessor <b>10</b> encounters a RET instruction, branch logic <b>22</b> pops this address from the return stack and begins fetching.</p><p>Like instruction cache <b>14</b>, data cache <b>26</b> may also be organized as two-way set associative 32-Kbyte storage. In one embodiment, data TLB <b>28</b> includes 128 entries that may be used to translate linear to physical addresses. Like instruction cache <b>14</b>, data cache <b>26</b> may also be sectored. Data cache <b>26</b> may further implement a MESI (modified-exclusive-shared-invalid) protocol to track cache line status. Other configurations of data cache <b>26</b> are also possible and are contemplated.</p><p>Computational Core</p><p>Turning now to FIG. 4, more detail of one embodiment of computation core <b>42</b> is shown. In one embodiment, computation core <b>42</b> comprises three execution units <b>36</b>C-E and a multiplier <b>50</b>. Integer/M/3D execution unit <b>36</b>C is a fixed point execution unit which is configured to operate on all ALU operations, as well as multiplies, divides (both signed and unsigned), shifts, and rotates. In contrast, integer/M/3D execution unit <b>36</b>E (Integer Y unit) is a fixed point execution unit configured to operate only on the basic word and doubleword ALU operations (ADD, AND, CMP, etc.).</p><p>Execution units <b>36</b>C and <b>36</b>D are also configured to accelerate performance of software written using multimedia and 3D graphics instructions. Applications that can take advantage of multimedia and 3D graphics instructions include 3D modeling and rendering, video and audio compression/decompression, speech recognition, and telephony. Execution units <b>36</b>C and <b>36</b>D may be configured to execute multimedia instructions in a single clock cycle. Many of these instructions are designed to perform the same operation to multiple sets of data at once (i.e., vector processing). In one embodiment, execution units <b>36</b>C and <b>36</b>D use registers which are mapped onto the stack of floating point unit <b>36</b>E.</p><p>Execution unit <b>36</b>E contains an IEEE 754-compatible floating point unit designed to accelerate the performance of software which utilizes the x86 instruction set. Floating point software is typically written to manipulate numbers that are either very large or small, require a great deal of precision, or result from complex mathematical operations such as transcendentals. Floating point execution unit <b>36</b>E may comprise an adder unit, a multiply unit, and a divide/square root unit. In one embodiment, these low-latency units are configured to execute floating point instructions in as few as two clock cycles.</p><p>In one embodiment, execution units <b>36</b>C and <b>36</b>D are coupled to multiplier <b>50</b> and are configured to utilize multiplier <b>50</b> as a shared resource. Advantageously, this configuration allows both execution units <b>36</b>C and <b>36</b>D to perform multiplication without requiring two multipliers. In another configuration, each execution unit <b>36</b>C and <b>36</b>D may each have their own dedicated multiplier. Still other configurations are possible and contemplated. For example, two n-bit multipliers may be shared by execution units <b>36</b>C and <b>36</b>D. Configuring microprocessor <b>10</b> with two multipliers each having a width of 32-bits advantageously allows two single precision multiplications to be executed in parallel (each operand/significand is 24 bits wide), or one MMX packed multiply (i.e., multiplying a pair of vectors wherein each vector comprises four 16-bit components). In another embodiment, multiplier <b>50</b> may be configured to accept operands that are 76-bits wide (i.e., the width of the significand in a double precision floating point data type), thereby providing the same functionality as two separate 32-bit multipliers while further alleviating the need for a separate multiplier in floating point unit <b>36</b>E. In such an embodiment, execution units <b>36</b>C-<b>36</b>E may be directly coupled to multiplier <b>50</b>, with each execution unit sharing multiplier <b>50</b>.</p><p>Multiplier <b>50</b> may also be configured to perform both signed and unsigned multiplication. Advantageously, this allows multiplier <b>50</b> to support both integer multiplication for MMX instructions, and floating point multiplication for 3D graphics instructions.</p><p>While multiplier <b>50</b> may be configured to perform multiplication using a number of different algorithms, the embodiment shown in the figure is configured to use a modified version of Booth's Algorithm to improve multiplication times. Booth's algorithm relies upon calculating a number of partial products and then summing them to obtain a final product. Booth's algorithm is able to improve multiplication times over the standard \u201cadd-and-shift\u201d algorithm by reducing the number of partial products that need to be summed in order to obtain the final product. For example, in performing an 8-bit by 8-bit multiplication, the shift-and-add algorithm generates eight partial products. By contrast, same 8-bit by 8-bit multiplication using the 2-bit version of Booth's algorithm generates only five partial products. This reduction in the number of partial products is illustrated in FIGS. 5A and 5B.</p><p>Turning now to FIG. 6, more detail of one embodiment of multiplier <b>50</b> is shown. In this embodiment, multiplier <b>50</b> comprises a partial product generator <b>60</b>, a partial product selection logic unit <b>62</b>, and an adder <b>64</b>. As shown in the figure, partial product generator <b>60</b> is coupled to selection logic unit <b>62</b>, which is in turn coupled to adder <b>64</b>. When one of execution units <b>36</b>C-<b>36</b>E receives an instruction invoking the multiplication function, the execution unit conveys two operands to multiplier <b>50</b>, i.e., a multiplicand operand <b>72</b> and a multiplier operand <b>74</b>. Partial product generator <b>60</b> is coupled to receive multiplicand operand <b>72</b>, which is used as a starting value for calculating a plurality of partial products <b>70</b>. For example, if partial product generator <b>60</b> is configured to use the 2-bit version of Booth's algorithm, the following partial products would be generated: the multiplicand itself (\u201c+M\u201d), a shifted version of the multiplicand (\u201c+2M\u201d), an inverted version of the multiplicand (\u201c-M\u201d), a shifted and inverted version of the multiplicand (\u201c\u22122M\u201d), and two constants, i.e., a positive zero (\u201c+0\u201d) and a negative zero (\u201c\u22120\u201d) in two's complement form.</p><p>Partial product selection unit <b>62</b> is coupled to receive multiplier operand <b>74</b>. Selection unit <b>62</b> is configured to select a number of partial products from generator <b>60</b> based upon particular fields within multiplier operand <b>74</b>. For example, using the 2-bit version of Booth's algorithm, multiplier operand <b>74</b> is padded with leading and trailing zeros (assuming an unsigned multiplication is being performed), and then one partial product is selected by each 3-bit field within the operand.</p><p>Finally, adder <b>64</b> is configured to receive and sum the partial products selected by selection unit <b>62</b>. As noted in the figure, the selected partial products <b>68</b> are shifted before they are summed. The resulting final product <b>76</b> is output to the execution unit that transmitted the operands. As previously noted, multiplier <b>50</b> may advantageously be configured to perform both signed and unsigned multiplication. This is described in greater detail below.</p><p>Scalar Unsigned Multiplication</p><p>Turning now to FIG. 7, details of one embodiment of multiplier <b>50</b> are shown. The figure also illustrates the operation of multiplier <b>50</b> for an unsigned multiplication. While the FIG. shows an 8-bit by 8-bit multiplier using the 2-bit version of Booth's algorithm, other configurations are possible and contemplated, e.g., a 32-bit by 32-bit multiplier using a 3-bit version of Booth's algorithm. In this embodiment, multiplier <b>50</b> further comprises a \u201csign-in\u201d input <b>78</b>, which indicates whether a signed or unsigned multiplication is to be performed. Sign-in input <b>78</b> is coupled to AND gate <b>86</b>A, which also receives the most significant bit (\u201cMSB\u201d) of multiplier operand <b>74</b>. AND gate <b>86</b>A outputs an \u201ceffective sign\u201d bit <b>90</b> for multiplier operand <b>74</b> which is copied and appended to multiplier operand <b>74</b> for use by selection logic unit <b>62</b>. Sign-in input <b>78</b> is also routed to AND gate <b>88</b>B, which similarly calculates and appends an effective sign bit <b>92</b> for multiplicand operand <b>72</b>. While other effective sign calculation logic may be used, the configuration illustrated advantageously generates an effective sign of zero for all unsigned operands and positive signed operands using a minimum amount of logic. Furthermore, in the embodiment shown only signed negative operands receive an asserted effective sign bit.</p><p>Partial product generation logic <b>60</b> uses multiplicand operand <b>72</b> and effective sign bit <b>92</b> to generate a number of partial products <b>80</b>A-<b>80</b>C. For example, a shifted version <b>80</b>A of multiplicand operand <b>72</b> is generated by shifting logic <b>84</b>B. Shifted version <b>80</b>A is equivalent to two times the multiplicand operand (+2M). Similarly, inverters <b>98</b> generate an inverted (i.e., one's complement) version (-M) of multiplicand operand <b>72</b>. Shifting logic <b>84</b>A is used to generate a shifted and inverted version <b>80</b>C (\u22122M) of multiplicand operand <b>72</b>. Partial product generation logic <b>60</b> also generates constants for use as partial products, e.g., positive zero <b>82</b>B (+0) and negative zero <b>82</b>A (\u22120). As illustrated in the figure, each partial product <b>80</b>A, <b>80</b>B, <b>80</b>C, <b>72</b>, <b>82</b>A, and <b>82</b>B may have an extra constant bit <b>88</b> associated with it. Extra constant bit <b>88</b> is asserted only for negative partial products, i.e., \u2212M, \u22122M, and \u22120, and is added to the partial product within adder <b>64</b> to generate two's complement versions of the inverted partial products. The shaded areas of the figure denote constants that may be designed into multiplier <b>50</b>.</p><p>Once partial product generator <b>60</b> has generated the partial products, selection logic <b>62</b> is configured to select partial products based upon 3-bit fields from multiplier operand <b>74</b>. Multiplier operand <b>74</b> is padded with zeros and copies of effective sign bit <b>90</b> so that there are no fractional 3-bit fields. Selection logic <b>62</b> may comprise a number of multiplexers <b>94</b>A-<b>94</b>F, one for each partial product to be selected. Each multiplexer <b>94</b>A-<b>94</b>E is controlled by a different 3-bit field from multiplier operand <b>74</b>. The 3-bit fields determine which partial product from those generated by partial product generator <b>60</b>, i.e., +M, +2M, \u2212M, \u22122M, +0, \u22120, will be selected. The selected partial products are then conveyed to adder <b>64</b>. Using 2-bit Booth decoding, Table 1 describes how partial products will be selected.</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"center\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"119PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\">TABLE 1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">3-bit Multiplier Field Value</entry><entry morerows=\"0\" valign=\"top\">Partial Product Selected</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">000</entry><entry morerows=\"0\" valign=\"top\">+0</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">001</entry><entry morerows=\"0\" valign=\"top\">+M</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">010</entry><entry morerows=\"0\" valign=\"top\">+M</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">011</entry><entry morerows=\"0\" valign=\"top\">+2M\u2002</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">100</entry><entry morerows=\"0\" valign=\"top\">\u22122M\u2002</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">101</entry><entry morerows=\"0\" valign=\"top\">\u2212M</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">110</entry><entry morerows=\"0\" valign=\"top\">\u2212M</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">111</entry><entry morerows=\"0\" valign=\"top\">\u22120</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>Adder <b>64</b> is configured to receive and sum the selected partial products. As illustrated in the figure, the partial products are shifted before being summed. Some of the partial products may have prefix bits added to eliminate the need for sign extending the partial product's most significant bit (i.e., sign bit) to the maximum width of final product <b>76</b>. The prefixes may be generated using simple inverters coupled to the partial product's most significant bit and constants. Once the partial products are shifted, padded, and summed, final product <b>76</b> is output and conveyed to the execution unit that provided the operands. Adder <b>64</b> may use a number of different algorithms for summing the partial products. For example, adder <b>64</b> may configured as a carry look-ahead adder, a carry skip adder, a carry select adder, a carry-save adder, or a carry propagate adder.</p><p>The exemplary values in the figure illustrate the unsigned multiplication of two values, 240<sub>10 </sub>and 230<sub>10</sub>. Sign-in input <b>78</b> is unasserted because unsigned multiplication to be performed. Sign-in input <b>78</b> may be provided by the same execution unit that provided the operands. The execution unit may generate sign-in input bit <b>78</b> based upon the type of multiply instruction it received. In the example shown in the figure, effective signs <b>90</b> and <b>92</b> are both zero because sign-in input <b>78</b> is unasserted. As shown in the illustration, an 8-bit by 8-bit version of multiplier <b>50</b> is able to multiply 8-bit unsigned operands (i.e., operands that do not have a sign bit) having values from 0 to 255 to obtain a 16-bit unsigned result.</p><p>Scalar Signed Multiplication</p><p>Turning now to FIG. 8, the same 8-bit by 8-bit version of multiplier <b>50</b> is shown. In this figure, however, multiplier <b>50</b> is performing signed multiplication. Sign-in input <b>78</b> is asserted because signed multiplication is to be performed. In the example illustrated, multiplicand operand <b>72</b> equals 100<sub>10</sub>, while multiplier operand <b>74</b> equals \u221250<sub>10</sub>. Multiplier operand <b>74</b> is received in two's complement format because it is a negative signed value. Thus its effective sign bit <b>90</b> (as calculated by AND gate <b>88</b>A) is asserted. In contrast, effective sign bit <b>92</b> for multiplicand operand <b>72</b> is unasserted because multiplicand operand <b>72</b> is positive. The final product <b>76</b> is a negative 16-bit number (\u22125000<sub>10</sub>) represented in two's complement format with the MSB indicating the sign.</p><p>Turning now to FIG. 9, another example of multiplier <b>50</b> performing a signed multiplication is shown. In this example, however, both multiplier operand <b>74</b> (having a value of \u221250<sub>10</sub>) and multiplicand operand <b>72</b> (having a value of \u2212100<sub>10</sub>) are received in two's complement format. The multiplication results in a signed final product <b>76</b> (having a value of 5000<sub>10</sub>) that is; positive. As FIGS. 6-8 illustrate, multiplier <b>50</b> may advantageously perform both signed and unsigned multiplication with the same hardware. Furthermore, multiplier <b>50</b> may advantageously be configured to use Booth's algorithm to further increase multiplication performance.</p><p>Component-wise Vector Multiplication</p><p>As previously noted, recent advances have placed a greater emphasis on microprocessors multimedia and graphics performance. Multimedia and 3D extensions to the basic x86 instruction set include vectored multiply instructions to improve performance. Turning now to FIG. 10, an embodiment of multiplier <b>50</b> capable of performing vector multiplication is shown. As in previous embodiments, multiplier <b>50</b> comprises partial product generator <b>60</b>, selection logic <b>62</b>, and adder <b>64</b>. This embodiment of multiplier <b>50</b> is configured to perform component-wise vector multiplication of two pairs of N-bit values (A<b>1</b>\u00d7B<b>1</b> and A<b>2</b>\u00d7B<b>2</b>) simultaneously or a scalar multiplication of one pair of 2N-bit values (A\u00d7B). Advantageously, multiplier <b>50</b> may take the place of three separate multipliers (i.e., one for scalar multiplication and two for the vector multiplication), thereby saving valuable die space.</p><p>In this embodiment, multiplier <b>50</b> has several features which allow it to perform both scalar and component-wise vector multiplication. When scalar multiplication is performed, multiplier <b>50</b> functions as previously disclosed, i.e., adder <b>64</b> will sum the partial products selected by selection logic <b>62</b> from partial product generator <b>60</b> to form final product <b>76</b>. When performinig component-wise vector multiplication, however, multiplier <b>50</b> is configured to effectively operate as two separate multipliers. This behavior ensures that the results generated by multiplier <b>50</b> will equal the results that would have been generated had two separate multipliers been used. To indicate whether multiplier <b>50</b> should perform component-wise vector multiplication or scalar multiplication, multiplier <b>50</b> receives a vector in input signal <b>120</b>. When an asserted vector_in signal is received, a plurality of multiplexers within selection logic <b>62</b> (e.g., multiplexers <b>122</b> and <b>124</b>) effectively isolate the two \u201clogical halves\u201d of multiplier <b>50</b>. This separation prevents partial products from one pair of vector components (e.g., A<b>1</b> and B<b>1</b>) from interfering with the multiplication of another pair of vector components (e.g., A<b>2</b> and B<b>2</b>). The operation of multiplexers <b>122</b> and <b>124</b> is described in greater detail below.</p><p>As shown in the figure, multiplicand operand <b>72</b> and multiplier operand <b>74</b> may each comprise a vector (two N-bit values) or a scalar value (a single 2N-bit value). For example, multiplicand operand <b>72</b> may comprise a vector (A<b>2</b>, A<b>1</b>) or a single scalar value A. The partial products selected by selection logic <b>62</b> may be logically divided into four quadrants <b>130</b>-<b>136</b> for component-wise vector multiplications (assuming vector operands each having two vector components). Quadrant <b>130</b> represents the higher order bits of partial products selected by the least significant vector component of vector multiplier <b>74</b> (i.e., B<b>1</b>). Quadrant <b>132</b> represents the lower order bits of partial products selected by the least significant vector component of vector multiplier <b>74</b> (i.e., B<b>1</b>). Quadrant <b>134</b> represents the lower order bits of partial products selected by the most significant vector component of vector multiplier <b>74</b> (i.e., B<b>2</b>). Quadrant <b>136</b> represents the higher order bits of partial products selected by the most significant vector component of vector multiplier <b>74</b> (i.e., B<b>2</b>).</p><p>As the selected partial products are shifted before being summed in adder <b>64</b>, the least significant bits of partial products selected by vector component B<b>2</b> located within quadrant <b>134</b> may affect the addition performed to generate A<b>1</b>\u00d7B<b>1</b> within final product <b>76</b>. To prevent this \u201ccorruption\u201d of final product <b>76</b>, multiplexer <b>124</b> is configured to \u201czero-out\u201d the lower order bits of partial products located within quadrant <b>134</b>. Similarly, in some embodiments the higher order bits of partial products selected by vector component B<b>1</b> may extend into quadrant <b>130</b>, thereby possibly affecting the summation used to form B<b>1</b>\u00d7B<b>2</b> within final product <b>76</b>. Thus additional multiplexers similar to multiplexer <b>124</b> may be used to zero-out the higher order bits within quadrant <b>130</b>.</p><p>Multiplexer <b>122</b> also assists in the logical separation that is advantageous for component-wise vector multiplication. Staggered bit fields within multiplier operand <b>74</b> are used to select partial products from partial product generator <b>60</b>. When a bit field encompasses bits from more than one vector component within multiplier operand <b>74</b>, the resulting partial product may also be \u201ccorrupted.\u201d For example, selecting a partial product using one bit from vector component B<b>1</b> and two bits from vector component B<b>2</b> (as illustrated in the figure) will result in a partial product that is partially representative of vector component B<b>1</b> and partially representative of vector component B<b>2</b>. This is undesirable because B<b>1</b> is to be multiplied with A<b>1</b> separately from B<b>2</b>. To remedy this, a multiplexer <b>122</b> may be used. When a bit field encompasses bits from more than one vector component, multiplexer <b>122</b> may zero-out the unwanted bit or bits (e.g., the most significant bit from B<b>1</b> as shown in the figure). Thus, the partial product selected by multiplexer <b>94</b>B will reflect only the bit values within the desired vector component. A second multiplexer similar to multiplexer <b>122</b> may zero out the opposite bits. Thus two partial products may be selected, one representing the end of vector operand B<b>1</b> and one representing the beginning of vector operand B<b>2</b>. The zeroing-out of bits for partial product selection and summation are illustrated in more detail by way of a numerical example in FIGS. 11A through 12.</p><p>Turning now to FIG. 11A, more detail of one embodiment of partial product generator <b>60</b> is shown. To support component-wise vector multiplication when the vector components are signed, an additional effective sign bit <b>172</b>A-<b>172</b>F may be generated for the lower-order portion of each partial product. The same logic may be used as previously disclosed, with AND-gate <b>86</b>B being duplicated (see AND-gate <b>86</b>C) to generate an effective sign for each lower-order vector component. Advantageously, multiplier <b>50</b> may be configured to perform both signed and unsigned vector multiplication. Generator <b>60</b> may also be configured to generate separate constant bits <b>88</b>A-F (referred to as S<b>1</b>) and <b>170</b>A-F (referred to as S<b>2</b>) to further improve separability when the selected partial products are summed in adder <b>64</b>. The extra constant bits <b>170</b>A-F and effective sign bits <b>172</b>A-F may simply remain unused or unselected during scalar multiplication. Note the figure illustrates one possible set of partial products generated for an unsigned component-wise vector multiplication wherein the multiplicand operand <b>72</b> has the values of (6,7), i.e., A<b>2</b>=6 and A<b>1</b>=7. Sign_in input <b>78</b> is unasserted to indicate that an unsigned multiplication is being performed.</p><p>Turning now to FIG. 11B, detail of part of one embodiment of selection logic <b>62</b> is shown. In order to support both scalar and vector multiplication, selection logic <b>62</b> may comprise a plurality of multiplexers <b>310</b>A-B, <b>312</b>A-B, <b>314</b>A-B, and <b>316</b>A-B. These multiplexers operate to select particular bits from partial product generator <b>60</b> according to the status of vector_in signal <b>120</b>. Each partial product has its own set of selection multiplexers (excluding constants +0 and \u22120 which are simply fed through as is; see <b>320</b>A and <b>320</b>B). For example, multiplexer <b>310</b>A selects bits [9-0] from the partial product \u22122M and outputs them to the rest of selection logic <b>62</b> and adder <b>64</b> if vector_in is asserted. This may ensure that both effective sign bits <b>92</b>A and <b>172</b>A are conveyed to adder <b>64</b>. Two effective sign bits are needed because two separate multiplications are being performed. Conversely, if vector_in is unasserted (indicating a scalar multiplication), extra effective sign bit <b>172</b>A is not needed, thus multiplexer <b>310</b>A selects bits [9-6, 4-0] and outputs them as bits [0-8]. The extra effective sign bit <b>172</b>A is removed, and a constant zero is padded to the output to create bit [9]. As indicated in the figure, bit [S<b>1</b>] may be passed through as it is needed in both cases (scalar and component-wise vector multiplication). Multiplexer <b>310</b>B selects bit [S2] if vector_in signal <b>10</b> is asserted, thereby providing two constants <b>88</b>A and <b>170</b>A. If vector_in signal <b>120</b> is not asserted and scalar multiplication is being performed, bit [S2] is not needed (and may cause an incorrect result if it is passed through to adder <b>64</b>). Thus, multiplexer <b>310</b>B is configured to select and convey a constant zero in place of actual S<b>2</b> bit <b>170</b>A if scalar multiplication is performed. Multiplexers <b>312</b>A-B, <b>314</b>A-B, and <b>316</b>A-B operate in a similar fashion. Each multiplexer may be configured to select the required bits from partial product generator <b>60</b> without passing extra bits unless they are needed.</p><p>Turning now to FIG. 12A-B, more details of one embodiment of selection logic <b>62</b> and adder <b>64</b> are shown. In this embodiment, selection logic <b>62</b> comprises a plurality of multiplexers <b>94</b>A-<b>94</b>F as in the previous embodiments. Note that multiplexers <b>312</b>A-B, <b>314</b>A-B, and <b>316</b>A-B are not shown, but are instead included within partial product generator <b>60</b>. Selection logic <b>62</b> further comprises multiplexers <b>152</b>-<b>156</b>, which operate to select two portions of partial products: (1) a portion of the partial product corresponding to the higher order bits of vector operand B<b>1</b>, and (2) a portion of the partial product corresponding to the lower order bits of vector operand B<b>2</b>. Multiplexer <b>156</b> then selects this \u201ccombination\u201d partial product when vector_in signal <b>120</b> is asserted. Advantageously, this configuration may remedy the problem of summation corruption when a bit field encompassing bits from more than one vector operand is used to select a partial product. This problem is described in greater detail below (see FIGS. <b>13</b> and <b>14</b>).</p><p>In this embodiment, adder <b>64</b> comprises three pluralities of multiplexers <b>160</b>A-<b>160</b>D, <b>162</b>A-<b>162</b>E, and <b>164</b>C-<b>164</b>E. Multiplexers <b>160</b>A-<b>160</b>D are controlled by vector_in signal <b>120</b> and operate to \u201czero-out\u201d portions of the partial products to prevent corruption of the vector components within final product <b>76</b> during the summation within adder <b>64</b>. Multiplexers <b>164</b>C-E are also controlled by vector_in signal <b>120</b> and operate to select either extra constant bits <b>140</b>C-<b>140</b>E (in the event of a vector multiplication) or a zero constant (in the event of a scalar multiplication) for addition into the more significant product. Multiplexers <b>162</b>A-<b>162</b>D are controlled by sign_in input <b>78</b> and are configured to select either the effective sign bit of the more significant portion of the selected partial product (in the event of a signed vector multiplication) or the actual sign (in the event of an unsigned vector multiplication). Multiplexers <b>164</b>C-<b>164</b>E are also controlled by vector_in signal <b>102</b> and perform the same function as multiplexers <b>310</b>B, <b>312</b>B, <b>314</b>B, and <b>316</b>B, i.e., they select a constant zero instead of extra constant bit S<b>2</b> if scalar multiplication is performed. Note that other configurations of logic for zeroing out and partial product selection are possible and contemplated. Further note that multiplexers <b>160</b>A-<b>160</b>D, <b>162</b>A-<b>162</b>E, and <b>164</b>C-<b>164</b>E may be configured as part of adder <b>64</b>, selection logic unit <b>62</b>, or as a separate part of multiplier <b>50</b>.</p><p>In addition to the features disclosed above, adder <b>64</b> may further comprise a plurality of multiplexers (not shown) to prevent carries across the boundaries of vector operands within final product <b>76</b> when summing the selected partial products. This boundary is represented by a dashed line <b>178</b> in the figure. Other embodiments of multiplier <b>50</b> may utilize different configurations of multiplexers. For example, multiplexers <b>160</b>A-<b>160</b>C may be configured to select either additional sign-extension bits or the most significant bits of the selected partial products. In addition, multiplexers <b>160</b>A-<b>160</b>C may be configured to pad each selected partial product with prefix bits until the most significant bit of each selected product corresponds to the most significant bit of final product <b>76</b> (as indicated by dashed bit positions <b>170</b>A-<b>170</b>B). The prefix bits may comprise a constant, sign extension bits, or a combination thereof.</p><p>Note that FIGS. 11A-B and <b>12</b> together illustrate the exemplary component-wise multiplication of two vector operands, i.e., multiplier operand <b>74</b> having a value of (3,12), i.e., B<b>2</b>=3 and B<b>1</b>=12, and multiplicand operand <b>72</b> having a value of (6,7), i.e., A<b>2</b>=6, and A<b>1</b>=7, resulting in final product <b>76</b> having a value of (18,84). Further note that while the figures and exemplary embodiments have illustrated a multiplier configured to perform component-wise vector multiplication on vector operands having up to two vector components, other configurations are possible and contemplated, e.g. vectors having four or six vector components may be multiplied component-wise in parallel. Furthermore, a number of multipliers configured similarly to multiplier <b>50</b> may be used in parallel to achieve even higher performance. The widths of multiplier operand <b>74</b> and multiplicand operand <b>72</b> may also be varied, e.g., 32-bits or 64-bits, as may the widths of their vector components.</p><p>In addition, other embodiments of multiplier <b>50</b> may be configured to return only a portion of final product <b>76</b> per clock cycle. For example, the most significant vector component of final product <b>76</b> may be returned during a first clock cycle. Other vector components may be returned during subsequent clock cycles in order of their significance.</p><p>Turning now to FIG. 13, another embodiment of multiplier <b>50</b> is shown. In this embodiment, multiplier <b>50</b> further comprises multiplexer <b>138</b>. When vector_in signal <b>120</b> is asserted, component-wise vector multiplication is performed. If the summing of partial products generates one or more carry bits <b>140</b>, the upper vector component in final product <b>144</b> may be corrupted if carry bits <b>140</b> are allowed to propagate across boundary <b>176</b>. To prevent this, multiplier <b>50</b> may comprise one or more carry multiplexers <b>138</b> to prevent carry bits from propagating to higher order vector components within final product <b>76</b>. When multiplier <b>50</b> is performing scalar multiplication, multiplexers <b>138</b> may be configured to propagate carry bits normally. As shown in the figure, in this embodiment of multiplier <b>50</b> the partial products in quadrant <b>130</b> are zeroed out such that they will not affect the value of final product <b>144</b>.</p><p>Turning now to FIG. 14, another embodiment of multiplier <b>50</b> is shown. In this embodiment, the partial products in quadrant <b>130</b> are not zeroed out. Instead, the selected partial products in quadrant <b>132</b> are allowed to sign extend across quadrant <b>130</b>. In some instances, e.g., when vector components A<b>1</b> and B<b>1</b> have opposite signs, final product <b>76</b> will have a lower order vector component <b>142</b> that will be negative and may result in a sign extensions across quadrant <b>130</b>. This sign extension may affect the value of the more significant vector component <b>144</b> within final product <b>76</b>. Multiplexer <b>146</b> is configured to insert a constant to be summed with the selected partial products to form final product vector component <b>144</b>. The constant (e.g., a binary value of one) is calculated to compensate for a negative sign extension across final product <b>144</b>. For example, a negative sign extension may be equivalent to \u201c11111111,\u201d thus adding a constant of one (i.e., \u201c00000001\u201d) will negate the effect of the sign extension on result vector component <b>144</b>. As this sign extension occurs only when vector components A<b>1</b> and B<b>1</b> have different signs, an XOR-gate <b>148</b> may be used in conjunction with vector_in input <b>120</b> to control multiplexer <b>146</b> so that the constant is only added when final product <b>142</b> will be negative and a component-wise vector multiplication is being performed. As illustrated, XOR-gate <b>148</b> may receive the sign bits (i.e., the most significant bits) of vector components A<b>1</b> and B<b>1</b> as inputs.</p><p>Vector Dot Product</p><p>Multiplier <b>50</b> may also be configured to calculate the \u201cvector dot product\u201d or inner product of two vectors. The following example illustrates the calculation of a vector dot product. Assuming vector A equals (x<b>1</b>, x<b>2</b>, x<b>3</b>), and vector B equals (y<b>1</b>, y<b>2</b>, y<b>3</b>), then the vector dot product A\u00b7B equals x<b>1</b>y<b>1</b>+x<b>2</b>y<b>2</b>+x<b>3</b>y<b>3</b>. As this example illustrates, calculation of the dot product entails performing a component-wise vector multiplication and then summing the vector component products.</p><p>Turning now to FIG. 15, one embodiment of multiplier <b>50</b> configured to calculate the vector dot product is shown. As shown in the figure, partial products <b>190</b> are summed within adder <b>64</b> to form vector component products <b>192</b>A-N. Each vector component product <b>192</b>A-N corresponds to one vector pair within multiplicand operand <b>72</b> and multiplier operand <b>74</b> as previously disclosed. Vector component products <b>192</b>A-N are then summed using a plurality of carry-propagate adders <b>194</b>A-N to form final result <b>196</b>, which may then be output for use by other parts of microprocessor <b>10</b>.</p><p>Turning now to FIG. 16, another embodiment of multiplier <b>50</b> configured to calculate the vector dot product is shown. In this embodiment, however, partial products <b>190</b> summed by adder <b>64</b> are kept in redundant form, i.e., each vector component product <b>192</b>A-F is represented by more than one value. For example, each vector component product <b>192</b>A-F may be represented by two values, a sum value <b>198</b>A-F and a carry value <b>200</b>A-F. A set of carry-save adders (not shown) may be used within adder <b>64</b> to sum partial products <b>192</b> in redundant form. Advantageously, carry-save adders may significantly reduce the amount of time and die space required to sum partial products <b>192</b>. At the single-bit level, a carry-save adder will take three bits of the same significance and produce a sum value (having the same significance) and a carry value (having a significance one bit higher than the sum value). In contrast, the term \u201ccarry-propagate adder\u201d denotes an adder that is not a carry-save adder. In one embodiment, a carry-save adder may be implemented as a number of independent full adders.</p><p>Once vector component products <b>192</b>A-<b>192</b>F have been formed, they may be summed together using a second set of carry-save adders <b>202</b>A-J. When the number of values remaining to be summed is reduced to two, a carry-propagate adder <b>204</b> may be used to perform the final summation. Note, however, that this configuration may require further modification if multiplier <b>50</b> is configured to propagate sign extension and carry bits as illustrated in FIG. <b>14</b>. The embodiment of multiplier <b>50</b> illustrated in FIG. 14 relies upon carries from less significant products propagating into the more significant ones. In this case, summing partial products <b>190</b> and products <b>192</b>A-F using carry-save adders may cause final result <b>196</b> to be less than the correct result by one unit-in-the-last-place (ULP) for each product below the most significant product. This is because carries from lower products are not incorporated into upper products during carry-save adds.</p><p>To ensure that final result <b>196</b> is correct when multiplier <b>50</b> is configured in a manner similar to the embodiment of FIG. 14, carry-propagate adder <b>204</b> may be configured to accept summands having a width equal to the cumulative width of all products <b>192</b>A-F. Assuming the length of each operand (multiplier and multiplicand) is n bits wide and comprises p vector components, each product <b>192</b>A-F will have a width of 2n/p. Thus to accommodate all products <b>192</b>A-<b>192</b>F, adder <b>204</b> may be 2n bits wide or wider. The redundant forms of each product <b>192</b>-<b>192</b>F (e.g., sum values <b>198</b>A-F and carry values <b>200</b>A-F) are conveyed as inputs to adder <b>204</b> (excluding the most significant product <b>192</b>F). In place of the most significant product <b>192</b>F, the final two summands remaining from the carry-save summation of products <b>192</b>A-<b>192</b>F are input to adder <b>204</b> as the most significant inputs. While adder <b>204</b> will output a 2n-bit wide result, only the most significant 2n/p bits comprise the final result <b>196</b>. This configuration advantageously allows adder <b>204</b> to propagate carry bits from lower order products to higher order products, thereby ensuring a proper result while still retaining the advantages associated with carry-save addition. Furthermore, the cost in die space of having a 2n-bit wide carry-propagate adder such as adder <b>204</b> may be reduced if other functions to performed by multiplier <b>50</b> also require a wide carry-propagate adder.</p><p>As with previous embodiments, this embodiment of multiplier <b>50</b> may be configured to accept operands having varying widths (n), and varying numbers of vector components (p). For example, multiplier <b>50</b> may be configured to calculate the dot product of two vector operands, each 64-bits wide and each having four vector components.</p><p>Rounded Products</p><p>As previously noted, some embodiments of multiplier <b>50</b> may be configured to conserves hardware resources (e.g., signal lines and registers) by returning only a portion of the final product (or products, in the case of component-wise vector multiplication) per clock cycle. For example, the higher order bits of the final product may be returned first, and then the lower order bits may be returned in subsequent clock cycles. However, in some embodiments it may be advantageous to return the higher order bits rounded to the nearest unit in the last place (\u201cULP\u201d).</p><p>Turning now to FIG. 17, a diagram of another embodiment of multiplier <b>50</b> is shown. This embodiment is configured to round the higher order bits of each vector component product to the nearest ULP. As in the previous embodiment (illustrated in FIG. <b>16</b>), partial products <b>190</b> are reduced in redundant form (e.g., a sum value and a carry value for each pairs of vector components) by adder <b>64</b>. However, in this embodiment a plurality of adders <b>210</b>A-<b>210</b>F are used to add a rounding constant <b>214</b> to each vector component product. Rounding constant <b>214</b> may comprise a single asserted bit (i.e., a \u201cone-hot\u201d) added to the bit position below the least significant bit position in the portion of the vector component to be rounded. For example, assuming a vector component product has a width of 8 bits, and the four most significant bits (MSBs) are to be rounded, then a constant one would be added to the fourth bit (as illustrated in Table 2). By adding a constant one in the appropriate bit position, the upper portion of the vector component product may be rounded efficiently and without large amounts of additional logic.</p><p><tables id=\"TABLE-US-00002\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"9\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"63PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"14PT\"></colspec><colspec align=\"center\" colname=\"4\" colwidth=\"14PT\"></colspec><colspec align=\"center\" colname=\"5\" colwidth=\"14PT\"></colspec><colspec align=\"center\" colname=\"6\" colwidth=\"14PT\"></colspec><colspec align=\"center\" colname=\"7\" colwidth=\"14PT\"></colspec><colspec align=\"center\" colname=\"8\" colwidth=\"14PT\"></colspec><colspec align=\"center\" colname=\"9\" colwidth=\"35PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"9\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE 2</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"9\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Bit Number \u2212&gt;</entry><entry morerows=\"0\" valign=\"top\">7 (MSB)</entry><entry morerows=\"0\" valign=\"top\">6</entry><entry morerows=\"0\" valign=\"top\">5</entry><entry morerows=\"0\" valign=\"top\">4</entry><entry morerows=\"0\" valign=\"top\">3</entry><entry morerows=\"0\" valign=\"top\">2</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0 (LSB)</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"9\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">Vector Component</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry></row><row><entry morerows=\"0\" valign=\"top\">Product</entry></row><row><entry morerows=\"0\" valign=\"top\">Rounding Constant</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">0</entry></row><row><entry morerows=\"0\" valign=\"top\">Rounded MSBs</entry><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">1</entry></row><row><entry morerows=\"0\" valign=\"top\">Output</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"9\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>As shown in FIG. 17, each adder <b>210</b>A-<b>210</b>F is configured to receive the redundant form of a single vector component product. For example, adder <b>210</b>A is configured to receive sum value <b>198</b>A and carry value <b>200</b>A and combine them with rounding constant <b>214</b>. Adder <b>210</b>A combines these three values and generates a redundant form output comprising a new sum value and a new carry value. Advantageously, adders <b>210</b>A-<b>210</b>F may be configured as independent carry-save adders, thereby preventing carry-bits caused by rounding constant <b>214</b> from propagating to more significant vector component products. The outputs of each adder <b>210</b>A-<b>210</b>F are coupled to the inputs of one of a plurality of carry-propagate adders <b>212</b>A-<b>212</b>F. Each carry-propagate adder <b>212</b>A-<b>212</b>F is configured to sum the outputs of adders <b>210</b>A-<b>210</b>F and thereby generate a non-redundant form of each vector component product. The rounded MSBs of each vector product may be output first, while the remaining least significant bits (\u201cLSBs\u201d) may be output during a subsequent clock cycle. Adders <b>212</b>A-<b>212</b>F may be configured independently to avoid the possibility of an unwanted carry-bit propagating across vector product boundaries.</p><p>In another embodiment, additional adders (not shown) may be configured to generate the LSBs (which are unrounded) separately from the MSBs. Advantageously, this may prevent the rounding process from altering the value of the LSBs. For example, adder <b>212</b>A may be configured to generate the rounded MSBs by summing the sum and carry values generated by adder <b>210</b>A, while an additional adder may be configured to sum the lower bits of sum value <b>198</b>A and carry value <b>200</b>A to generate the LSBs.</p><p>In the previously described embodiments, each adder <b>210</b>A-<b>210</b>F and <b>212</b>A-<b>212</b>F is configured to perform addition without propagating carry bits from one vector component product to another. While this may be desirable in many configurations, the non-propagation of carry bits may disrupt some configurations of adder <b>50</b>. For example, the embodiment illustrated in FIG. 14 relies upon the propagation of sign extension bits across vector component product boundaries. If carry bits are not allowed to propagate during the final addition stages which convert the redundant-from vector component products to non-redundant-form, the higher order products may be incorrect.</p><p>Turning now to FIG. 18, an embodiment of multiplier <b>50</b> which rounds the higher order bits of each vector component product, yet still allows carry bits to propagate across consecutive vector component product boundaries, is shown. In this embodiment, rounding constant <b>214</b> is once again added to the redundant form sum values <b>198</b>A-<b>198</b>F and carry values <b>200</b>A-<b>200</b>F of each vector component product by carry-save adders <b>210</b>A-<b>210</b>F. In order to allow carries from partial products <b>190</b> to propagate without allowing carries from rounding constant <b>214</b> to propagate, separate carry-propagate adders <b>212</b>A-<b>212</b>F are used for each vector component product. The length of each adder <b>212</b>A-<b>212</b>F may equal the number of bits in the vector component product itself plus all of the bits corresponding to less significant vector component products. For example, assuming each vector component product is eight bits wide, adder <b>212</b>B may be 16 bits wide and may add redundant vector component values <b>198</b>A-<b>198</b>C and <b>200</b>A-<b>200</b>C. Advantageously, undesired carry-out bits from each vector component product will not affect higher order vector component products in this configuration. Furthermore, the carry bits that may be required for correct operation of the embodiment of multiplier <b>50</b> illustrated in FIG. 14 still propagate to form the correct result despite possible sign-extensions.</p><p>Note that other configurations of multiplier <b>50</b> are possible. For example, rounding constant <b>214</b> may be incorporated within the logic of adder <b>64</b>, thereby potentially eliminating the need for an extra level of adders. Furthermore, multiplier <b>50</b> may be configured to round and return the upper portions of scalar products and vector dot products in addition to vector component products. The types of adders used may also be changed according to the implementation, e.g., carry-propagate adders may be used through out in conjunction with multiplexers configured to prevent carry bits from propagating across vector component product boundaries. In addition, various control signals, e.g., a round_in signal, may be used to indicate whether rounding is to be performed.</p><p>Fast Rounding and Normalization</p><p>Another possible area for improving the speed of multiplication relates to rounding and normalization. When performing floating point multiplication, the multiplier and multiplicand operands (i.e., the significands of two floating point numbers) are received in normalized form. A binary number is said to be normalized when the most significant asserted bit is directly to the left of the binary radix point For example, 1.010011<sub>2 </sub>is normalized, while 10.10011<sub>2 </sub>and 0.01010011<sub>2 </sub>are not. In order to normalize a binary number, the number is shifted either right or left until the most significant asserted bit is directly to the left of the binary radix point. The number's exponent is then increased or decreased an amount equal to the number of positions that the number was shifted.</p><p>When multiplier <b>50</b> performs floating point multiplication, it receives two normalized significands. In some embodiments, multiplier <b>64</b> may be configured to output the results in normalized form. For example, multiplier <b>50</b> may receive two 32-bit normalized significands as operands and be configured to output one 32-bit result in normalized form. After multiplier <b>50</b> generates and selects the partial products, they are summed by adder <b>64</b> to create the final result. As the final result may be in redundant form, it may be passed through a carry-propagate adder as previously described. Once in non-redundant form, the result is rounded and normalized before being output. Different methods of rounding are possible. For example, IEEE Standard 754 defines four different rounding methods: round to nearest (even), round to positive infinity, round to minus infinity, and round to zero. The round to nearest method is particularly useful because it ensures that the error in the final product is at most one-half ULP (unit in the last place).</p><p>Turning now to FIG. 19, another embodiment of multiplier <b>50</b> is shown. This embodiment comprises two \u201cpaths\u201d which are configured to perform IEEE rounding and normalization by calculating two results in parallel, i.e., one result assuming there is an overflow and one result assume no overflow. This embodiment comprises a pair of carry-save adders <b>276</b>A-B, a pair of carry-propagate adders <b>278</b>A-B, a pair of sticky bit logic units <b>286</b>A-B, and a pair of LSB fix-up logic units <b>288</b>A-B. The \u201cno-overflow path\u201d comprises carry-save adder <b>276</b>A, carry-propagate adder <b>278</b>A, sticky bit logic unit <b>286</b>A, and LSB fix-up logic unit <b>288</b>A, while the \u201coverflow path\u201d comprises carry-save adder <b>276</b>B, carry-propagate adder <b>278</b>B, sticky bit logic unit <b>286</b>B, and LSB fix-up logic unit <b>288</b>B. Both carry-save adders <b>276</b>A and <b>276</b>B are configured to receive sum value <b>274</b>A and carry value <b>274</b>B from partial product array adder <b>64</b>. Each carry-save adder <b>276</b>A and <b>276</b>B is also configured to receive a rounding constant <b>268</b> from multiplexer <b>266</b>.</p><p>Multiplexer <b>266</b> is configured to select rounding constant <b>268</b> from one of four rounding constants. The first rounding constant is a hard-wired constant one and is selected when rounding mode input <b>270</b> indicates that round to nearest (even) is the selected rounding mode. The constant is added to the guard bit position by both carry save adders <b>276</b>A and <b>276</b>B. The second rounding constant is a hard-wired zero and is selected when rounding mode input <b>270</b> indicates that round to zero (truncate) is the selected rounding mode. The third rounding constant is the sign of the final product of the multiplication being performed. This sign may be obtained by exclusively ORing the sign bit <b>260</b>A of multiplicand operand <b>72</b> and the sign bit <b>260</b>B of multiplier operand <b>74</b> within XOR gate <b>262</b>. The resulting sign bit is added to the guard bit position, and each bit position less significant than the guard bit position, by carry-save adders <b>276</b>A and <b>276</b>B. The fourth rounding constant is the inversion of the third rounding constant. It may obtained by inverting the rounding constant obtained from XOR gate <b>262</b> with inverter <b>264</b>. The resulting inverted sign bit is added to the guard bit position and each bit position less significant than the guard bit position by carry-save adders <b>276</b>A and <b>276</b>B.</p><p>Carry-save adders <b>276</b>A and <b>276</b>B are configured to receive and add sum value <b>274</b>A, carry value <b>274</b>B, and the selected rounding constant from multiplexer <b>266</b>. Carry-save adders <b>276</b>A and <b>276</b>B convey their results in redundant form to carry-propagate adders <b>278</b>A and <b>278</b>B, respectively. Carry-propagate adders <b>278</b>A and <b>278</b>B reduce the results to non-redundant form <b>282</b>A and <b>282</b>B and convey them to LSB fix-up logic units <b>288</b>A and <b>288</b>B, respectively.</p><p>In parallel with the addition performed by adders <b>276</b>A-B and <b>278</b>A-B, sticky bit logic units <b>280</b>A-B calculate sticky bits <b>286</b>A-B. Sticky bit logic units <b>280</b>A-B each receive sum value <b>274</b>A and carry value <b>274</b>B as inputs. The calculation of sticky bits and the operation of sticky bit logic units <b>280</b>A-B are described in greater detail below.</p><p>LSB fix-up logic units <b>288</b>A and <b>288</b>B are coupled to carry-propagate adders <b>278</b>A-B and sticky bit logic units <b>280</b>A-B. Fix-up logic units <b>288</b>A-B are configured to conditionally invert the least significant bit of the non-redundant results received from adders <b>278</b>A-B. In one embodiment, fix-up logic units <b>288</b>A-B are configured to perform the inversion or \u201cfix-up\u201d when the \u201cround to nearest\u201d mode is being performed and the following equation is true: (inverse of L) \u00b7(G)\u00b7(inverse of S)=1, wherein L and G are the least significant bits (LSBs) and guard bits, respectively, of the sum of sum value <b>274</b>A and carry value <b>274</b>B, and wherein S is the corresponding sticky bit (either <b>286</b>A or <b>286</b>B). Note that L and G may be calculated within fix-up units <b>288</b>A-B using sum value <b>274</b>A and carry value <b>274</b>. The calculation of L and G may be performed in parallel with the additions performed by adders <b>276</b>A-B and <b>278</b>A-B and need not include a rounding constant. L and G may be calculated within fix-up units <b>288</b>A-B, or by using an extra component within multiplier <b>50</b> (e.g., a third pair of carry-save/carry-propagate adders). The fix-up may advantageously compensate for cases in which adders <b>276</b>A-B have added a constant when a constant was not actually needed (e.g., result+1 is generated when result+0 is needed).</p><p>Next, the desired number of upper bits from the outputs of LSB fix-up logic units <b>288</b>A and <b>288</b>B may be conveyed to multiplexer <b>290</b>, which selects one of the two values (overflow or no overflow) as output <b>292</b>. Multiplexer <b>290</b> may be controlled by MSB <b>284</b> from the output of fix-up logic unit <b>288</b>A. By looking at the most significant bit, a determination of whether an overflow occurred can be made. If an overflow occurred, the upper bits from the output of LSB fix-up logic unit <b>288</b>A are selected. If an overflow did not occur, the upper bits from the output of LSB fix-up logic unit <b>288</b>B are selected. Note that other control configurations are also possible, e.g., MSB <b>284</b> may be the most significant bit of the output from fix-up logic unit <b>288</b>B. Furthermore, in some embodiments of multiplier <b>50</b> only one fix-up logic unit may be needed. For example, the single fix-up logic unit may be coupled to the output of multiplexer <b>290</b> and perform the fix-up before final result <b>292</b> is output.</p><p>In one embodiment, exponent control logic unit <b>254</b> is also controlled by the same signal that controls multiplexer <b>290</b>. If an overflow occurs, exponent control logic unit <b>254</b> is configured to increment the corresponding exponent. This completes the normalization of the output.</p><p>Advantageously, the embodiment of multiplier <b>50</b> depicted in the figure may be able to round and normalize the final result in less time because normalization is performed in parallel. Furthermore, the fix-up is performed while multiplexer <b>290</b> is selecting a result (overflow or no overflow). This may further reduce the cycle time of this embodiment of multiplier <b>50</b>.</p><p>Turning now to FIG. 20, a diagram illustrating the operation of one embodiment of carry-save adders <b>276</b>A and <b>276</b>B is shown. The example assumes eight bit sum and carry values <b>274</b>A-B are being rounded to four bit values and that round to nearest (even) is being performed. Adders <b>276</b>A-B each receive sum value <b>274</b>A, carry value <b>274</b>B, and rounding constant <b>268</b> as inputs. In the example shown, adder <b>276</b>A is configured to add a constant one to the guard bit position of sum value <b>274</b>A and constant value <b>274</b>B assuming there will not be an overflow. The guard bit position is the bit position that is one bit less significant than the least significant bit of the portion to be output An overflow occurs when the summation of sum value <b>274</b>A, carry value <b>274</b>B, and any added rounding constants, creates a carry out from the bit position directly to the left of the binary radix point. An overflow may require the result to be shifted to the right (and the corresponding exponent to be incremented) in order to produce a normalized output.</p><p>As the figure illustrates, adder <b>276</b>A adds a constant one to the guard bit position of sum value <b>274</b>A and carry value <b>274</b>B assuming there will be no overflow. In contrast, adder <b>276</b>B adds rounding constant <b>268</b> to the guard bit position of sum value <b>274</b>A and carry value <b>274</b>B assuming there is an overflow. Thus, adder <b>286</b>B adds the constant one in a different bit position than adder <b>276</b>A. For this reason, adders <b>276</b>A and <b>276</b>B each generate a different result. The results from adder <b>276</b>A are conveyed to carry propagate adder <b>278</b>A, which is configured to reduce them to non-redundant form. Similarly, the results from adder <b>276</b>B are conveyed to carry propagate adder <b>278</b>B, which operates in manner similar to adder <b>278</b>A.</p><p>Turning now to FIG. 21, more detail of one embodiment of sticky bit logic unit <b>280</b>A is shown. As the figure illustrates, sticky bit logic <b>280</b>A receives the lower four bits of the sum and carry values (<b>350</b> and <b>352</b>, respectively ) generated by adder <b>276</b>A. A constant <b>354</b> (e.g., 1111) is added to the sum and carry bits within carry save adder <b>340</b>A, thereby generating two different 4-bit outputs which are routed to exclusive NOR gate <b>342</b>A. The output from exclusive NOR gate <b>342</b>A is routed to 4-input OR gate <b>344</b>A, which outputs sticky bit <b>286</b>A. Sticky bit logic <b>280</b>B is configured similarly to sticky bit logic <b>280</b>A, but it may be configured to receive one extra bit, e.g., five bits as opposed to four bits, due to the assumed overflow.</p><p>Turning now to FIG. 22, a numerical example of the operation of the embodiment of multiplier <b>50</b> from FIG. 20 is shown. This example assumes an eight bit output from adder <b>64</b> is being rounded to a four bit result. The figure shows each of the four IEEE rounding modes being performed by both carry-save adders <b>276</b>A and <b>276</b>B. The selected rounding constant <b>268</b> corresponds to the rounding mode. The selected rounding constant <b>268</b> is added to sum value <b>274</b>A and carry value <b>274</b>B by carry save adders <b>276</b>A and <b>276</b>B. As the figure illustrates, the starting bit position to which the constant is added varies from adder <b>276</b>A to adder <b>276</b>B. As previously noted, this is because adder <b>276</b>A adds the constant to the guard bit position assuming there is no overflow, while adder <b>276</b>B assumes there is an overflow. In parallel, sticky bit logic units <b>280</b>A and <b>280</b>B each calculate their own version of the sticky bit (<b>286</b>A and <b>286</b>B, respectively), also reflecting whether or not an overflow is presumed to occur.</p><p>Next, LSB fix-up logic units <b>288</b>A and <b>288</b>B fix-up (invert) the LSB of output <b>282</b>A, if necessary. As the figure illustrates, the fix-up is only performed when round to nearest (even) is the selected rounding mode and the formula (inverse of LSB)\u00b7(Guard bit)\u00b7(inverse of Sticky Bit)=1 is true. Note that in this embodiment the LSB and Guard bit are taken from the sum of sum value <b>274</b>A and carry value <b>274</b>B without selected rounding constant <b>268</b>. After the fix-up, the upper four bits are output to multiplexer <b>290</b>. In one embodiment, LSB fix-up logic <b>288</b>A and <b>288</b>B may each comprise a single inverter configured to invert the least significant bit of results <b>282</b>A and <b>282</b>B, respectively.</p><p>Other configurations of multiplier <b>50</b> are possible and contemplated. Turning now to FIG. 23, another embodiment of multiplier <b>50</b> configured to perform rounding and normalization is shown. In this embodiment, the \u201cfix-up\u201d or inversion of the LSB is performed by a single LSB fix-up logic unit <b>288</b> after multiplexer <b>290</b> performs the overflow/no overflow selection. A second multiplexer <b>290</b>B is included to select which sticky bit <b>286</b>A or <b>286</b>B will be used by LSB fix-up logic unit <b>288</b> in determining whether to perform the inversion. Note the rounding and normalization hardware disclosed herein may be configured to round and normalize redundant results from other functional units also, e.g., adders.</p><p>Fast Newton-Raphson Iteration to Calculate the Reciprocal (1/B)</p><p>As microprocessor <b>10</b> already contains a highly optimized multiplier <b>50</b>, it would be advantageous to perform other calculations on multiplier <b>50</b> as well, e.g., division. This may be accomplished by recasting division operations into reciprocal operations followed by multiplication operations. For example, the operation \u201cA divided by B\u201d (A/B) may be recast into \u201cA multiplied by the reciprocal of B\u201d (A\u00d7B<sup>\u22121</sup>). Forming the reciprocal of B may also be recast into a series of multiplication operations by using a version of the Newton-Raphson iteration. The Newton-Raphson iteration uses the equation X<sub>1</sub>=X<sub>0</sub>\u00d7(2\u2212X<sub>0</sub>\u00d7B) to calculate the reciprocal of B. The initial estimate, X<sub>0</sub>, may be determined in a number of different ways. For example, X<sub>0 </sub>may be read from a ROM table using B as the index, wherein X<sub>0 </sub>approximates 1/B. In another embodiment, X<sub>0 </sub>may be calculated directly from B or from one or more ROM tables configured to output seed values. The seed values may be manipulated, e.g., using arithmetic and combinational logic, to determine X<sub>0</sub>. Once X<sub>0 </sub>is known, the first iteration may be performed. Thereafter, the results from each iteration are used in place of X<sub>0 </sub>in subsequent iterations. This forces X<sub>n+1 </sub>to converge on 1/B in a quadratic fashion.</p><p>Turning now to FIG. 24, a flowchart depicting one embodiment of a method to calculate the reciprocal using multiplier <b>50</b> is shown. As previously noted, X<sub>0 </sub>is calculated first (step <b>700</b>). Once X<sub>0 </sub>is determined, it is multiplied by B (step <b>702</b>). The results are then routed down two parallel paths <b>706</b> and <b>708</b>, one that assumes an overflow took place in the multiplication (path <b>706</b>), and another that assumes no overflow occurred (path <b>708</b>). Because X<sub>0 </sub>is close to 1/B, the product of X<sub>0 </sub>and B will be close to one, i.e., either slightly over one or slightly under one. As a result, an overflow will only occur during the multiplication if X<sub>0 </sub>is slightly greater than one (i.e., of the form 10.000 . . . with an exponent equal to 2<sup>\u22121</sup>). If there is no overflow, the result will be slightly less than one (i.e., in the form 01.111 . . . with an effective exponent equal to 2<sup>\u22121</sup>).</p><p>After the multiplication, the term (2\u2212X<sub>0</sub>\u00d7B) is formed within each path by inverting the (X<sub>0</sub>\u00d7B) results. Since (X<sub>0</sub>\u00d7B) is close to one, (2\u2212X<sub>0</sub>\u00d7B) may be approximated by the absolute value of the two's complement of (X<sub>0</sub>\u00d7B). To further speed the calculation, the one's complement may be used because it only differs by a one in the least significant digit. The approximations for (2\u2212X<sub>0</sub>\u00d7B) are performed in parallel within each path (steps <b>710</b> and <b>712</b>). Specifically, in overflow path <b>706</b>, the bits are inverted to get 01.111 . . . (with an effective exponent equaling 2<sup>\u22121</sup>). In non-overflow path <b>708</b>, the bits are inverted to get 10.000 . . . (with an effective exponent equaling 2<sup>\u22121</sup>). Note that the sign bit of each intermediate value may also be forced to zero (positive).</p><p>Next, either the overflow path result or the non-overflow path result is selected (step <b>714</b>). This selection can be performed by examining the result from the path that assumes no overflow occurred. If the most significant bit of this result is a one, then an overflow occurred within the non-overflow path, and the result from the overflow path should be selected as the proper result. The corresponding sign and exponent bits are also selected along with the result.</p><p>Note that different bits may be selected from each path. This is illustrated by the following example. Assuming the product from the multiplier is 64 bits wide, then the bits may be numbered from 0 (the least significant bit) to 63 (the overflow bit), with the binary radix point located between the most significant bit <b>62</b> and the most significant fractional bit <b>61</b>. If an overflow has occurred, bits <b>62</b> through <b>0</b> are selected with the radix point positioned between bits <b>62</b> and <b>61</b>. If an overflow has not occurred, bits <b>63</b> though <b>0</b> are selected with the radix point positioned between bits <b>63</b> and <b>62</b>. Thus bits 10.000 . . . may be selected as 1.0000 . . . (along with a hardwired exponent equaling 2). Advantageously, this configuration may save time by normalizing the inverted bits without requiring a dedicated normalization step. Note that other configurations and other widths are contemplated. Furthermore, all the bits from the selected path need not be used. In some embodiments fewer bits may be selected, and in other embodiments extra bits may be padded with constants to meet a desired length.</p><p>After the appropriate bits are selected, the result is routed back to the multiplier, which multiplies it with X<sub>0 </sub>to complete the first iteration and form X<sub>1 </sub>(step <b>716</b>). If the desired accuracy has been achieved (step <b>718</b>), the results are output (step <b>722</b>). If the desired accuracy has not been achieved (step <b>720</b>), the iteration is repeated to form X<sub>2</sub>, wherein X<sub>2</sub>=X<sub>1</sub>\u00d7(2\u2212X<sub>1</sub>\u00d7B). As with the first iteration, the term (X<sub>1</sub>\u00d7B) is close to one. The results of the multiplication are once again passed down paths <b>706</b> and <b>708</b> in parallel.</p><p>Depending upon the accuracy of the initial guess X<sub>0 </sub>and the accuracy desired in the final result, the iteration may be performed any number of times (e.g., one, two, or five times). Using two paths may advantageously eliminate the need for normalization because the exponent and sign bits can be hard-wired based upon the known limits of the incoming operands and whether or not an overflow occurs.</p><p>Fast Newton-Raphson Iteration to Calculate the Reciprocal Square Root (1/B)</p><p>In another embodiment, multiplier <b>50</b> may be configured to calculate the reciprocal square root of an operand B using a modified version of the Newton-Raphson iteration. The equation Y<sub>n+1</sub>=Y<sub>n</sub>\u00d7(3\u2212B\u00d7Y<sub>n</sub><sup>2</sup>)/2 may be used to calculate the reciprocal square root of B. Once again, the initial estimate, Y<sub>0</sub>, may be determined in a number of ways, e.g., by using initial estimate generators that perform calculations on seed values read from ROM tables using B. In this iteration Y<sub>0 </sub>approximately equals 1/B. Each subsequent iteration of the equation forces Y to converges on 1/B in a quadratic fashion. In one embodiment, both Y<sub>0 </sub>and Y<sub>0</sub><sup>2 </sup>may be produced using the same initial estimate generator that was used for the reciprocal calculation described above. This may be desirable because determining Y<sub>0</sub><sup>2 </sup>may eliminate the need for a multiplication operation to form Y<sub>0</sub><sup>2 </sup>from Y<sub>0</sub>. As used herein, an initial estimate generator refers to any hardware capable of generating an initial value such as X<sub>0 </sub>or Y<sub>1</sub>, e.g., one or more ROM tables configured to output seed values that may be used to calculate the initial value using arithmetic and combinational logic.</p><p>Turning now to FIG. 25, a flowchart depicting one embodiment of a method to calculate the reciprocal square root using multiplier <b>50</b> is shown. As previously noted, Y<sub>0</sub><sup>2 </sup>and Y<sub>0 </sub>are determined first (step <b>730</b>). Once Y<sub>0</sub><sup>2 </sup>is determined, it is multiplied by B to form the term (B\u00d7Y<sub>0</sub><sup>2</sup>) (step <b>732</b>). The results are then routed down two parallel paths <b>734</b> and <b>736</b>, one that assumes an overflow took place in the multiplication (path <b>736</b>), and another that assumes no overflow occurred (path <b>734</b>). Because Y<sub>0</sub><sup>2 </sup>is close to 1/B, the product of Y<sub>0</sub><sup>2 </sup>and B will be close to one, i.e., either slightly over or slightly under one. As a result, an overflow will only occur during the multiplication if the result (B\u00d7Y<sub>0</sub><sup>2</sup>) is slightly greater than one (i.e., of the form 10.000 . . . with an effective exponent equal to 2<sup>\u22121</sup>). If there is no overflow, the result will be slightly less than one (i.e., in the form 01.111 . . . with an effective exponent equal to 2<sup>\u22121</sup>).</p><p>After the multiplication, the overflow path <b>736</b> forms the one's complement by inverting the result (B\u00d7Y<sub>0</sub><sup>2</sup>) (step <b>740</b>). The resulting value has the form 01.111 . . . with an effective exponent of 2<sup>\u22121 </sup>and approximates (2\u2212B\u00d7Y<sub>0</sub><sup>2</sup>). To form the term (3\u2212B\u00d7Y<sub>0</sub><sup>2</sup>), a one is effectively added to the result to form 1.111 . . . with an exponent of 2<sup>0 </sup>(step <b>744</b>). This value is then be right shifted one bit to reflect the division by two in the term (3\u2212B\u00d7Y<sub>0</sub><sup>2</sup>)/2 (step <b>748</b>). This results in a value having the form 1.111. .. with an exponent of 2<sup>\u22121 </sup>(step <b>748</b>).</p><p>The non-overflow path <b>734</b> also forms the one's complement by inverting the result (B\u00d7Y<sub>0</sub><sup>2</sup>) (step <b>738</b>). The resulting value, however, has the form 10.000 . . . with an effective exponent of 2<sup>\u22121</sup>. This form is normalized to 1.000 . . . with an exponent of 2<sup>0</sup>, which approximates (2\u2212B\u00d7Y<sub>0</sub><sup>2</sup>). To approximate the term (3\u2212B\u00d7Y<sub>0</sub><sup>2</sup>), a one is effectively added to the result to form 10.000 . . . (step <b>742</b>). This value is then be shifted right one bit to reflect the division by two in the term (3\u2212B\u00d7Y<sub>0</sub><sup>2</sup>)/2 (step <b>746</b>). The result has the form 1.000 . . . In this path, the result's exponent is forced to 2<sup>0 </sup>(step <b>746</b>).</p><p>Next, either the overflow path result or the non-overflow path result is selected (step <b>750</b>). This selection can be performed as previously disclosed, i.e., based upon the value of the most significant bit of the result from each path. Different bits may be selected from each path to eliminate the need for normalization.</p><p>The selected result is then routed back to the multiplier, which multiplies it with Y<sub>0 </sub>(determined during step <b>730</b>) to complete the first iteration and form Y<sub>1 </sub>(step <b>752</b>). If the desired accuracy has been achieved (step <b>754</b>), the results are output (step <b>756</b>). If the desired accuracy has not been achieved, the iteration is repeated to form Y<sub>2</sub>, wherein Y<sub>2</sub>=Y<sub>1</sub>\u00d7(3\u2212B\u00d7Y<sub>1</sub><sup>2</sup>)/2 (step <b>758</b>). However, unlike the first iteration, subsequent iterations may require an additional multiplication to form the term Y<sub>n</sub><sup>2 </sup>(step <b>760</b>). As with the first iteration, the term (B\u00d7Y<sub>1</sub><sup>2</sup>) is close to one. Once this term has been calculated, the results are once again passed down the two paths (overflow <b>736</b> and non-overflow <b>734</b>) in parallel.</p><p>Depending upon the accuracy of the initial guess Y<sub>0 </sub>and the accuracy desired in the final result, the iterative calculation may be performed any number of times (e.g., one, two, or five times). Advantageously, using two paths (overflow and non-overflow) may eliminate the need for normalization because the exponent and sign bits may be hard coded based upon the known limits of the incoming operands and whether or not an overflow occurs.</p><p>Note that the steps in the figures are show in a serial fashion for explanatory purposes only. Some steps may be performed in parallel or in a different order. Further note that the method above may also be used to determine the square root of an operand. To implement the square root function, an additional multiplication may be performed during each iteration.</p><p>Turning now to FIG. 26, an embodiment of multiplier <b>50</b> configured to evaluate constant powers of an operand is shown. This embodiment may be configured to evaluate one or more constant powers of an operand such as \u22121 (reciprocal), \u2212\u00bd, (reciprocal square root), and \u00bd (square root). In addition to the features of the previous embodiments, this embodiment of multiplier <b>50</b> comprises a non-overflow logic unit <b>770</b>A, an overflow logic unit <b>770</b>B, an initial estimate generator (IEG) <b>774</b>, two multiplexers <b>776</b> and <b>780</b>, and a control logic <b>778</b>. Note that non-overflow logic unit <b>770</b>A and overflow logic unit <b>770</b>B may also be referred to herein as a \u201cnon-overflow path,\u201d and \u201coverflow path,\u201d respectively.</p><p>Initial estimate generator <b>774</b> is coupled to receive multiplier operand <b>74</b> and communicate initial estimates, e.g., X<sub>0 </sub>and Y<sub>0</sub>, to multiplexer <b>776</b>. Note as used herein, X<sub>0</sub>=Y<sub>0</sub><sup>2</sup>\u22481/B, and Y<sub>0</sub>\u22481/B. Multiplexer <b>776</b> is configured to select the first multiplication operand from either multiplicand operand <b>72</b> or the initial estimate output by initial estimate generator <b>774</b>. Similarly, multiplexer <b>780</b> is configured to select the second operand to be multiplied from either multiplier operand <b>74</b> or result <b>292</b> from multiplexer <b>290</b>. Control logic <b>778</b> receives control signal <b>772</b> and controls multiplexers <b>776</b> and <b>780</b>, exponent control logic <b>254</b>, and logic units <b>770</b>A-B. Non-overflow logic <b>770</b>A is coupled to receive values from LSB fix-up logic <b>288</b>A and output values to multiplexer <b>290</b>. Similarly, overflow logic <b>770</b>B is coupled to receive values from LSB fix-up logic <b>288</b>B and also output values to multiplexer <b>290</b>. Logic units <b>770</b>A-B are controlled by control logic unit <b>778</b>, which indicates which, if any, constant power operation is being performed. If a constant power operation is not being performed, logic units <b>770</b>A-B may be configured to simply allow values from fix-up logic units <b>288</b>A-B to propagate through to multiplexer <b>290</b> unchanged.</p><p>When a constant power operation is being performed, logic units <b>770</b>A-B are configured to form approximations by inverting selected bits from the values received from fix-up logic units <b>770</b>A-B. Logic units <b>770</b>A-B are also configured to force (e.g., hard-wire) the exponents associated with the values received from fix-up logic units <b>288</b>A-B to fixed values. These fixed exponents are communicated to exponent control logic <b>254</b>. Alternatively, exponent control logic <b>254</b> may force the exponents to fixed constants when instructed to do so by logic units <b>770</b>A-B. Logic units <b>770</b>A-B may each comprise a plurality of inverters, a wire shifter, and one or more hard-wired constants. A wire shifter is a plurality of signal, data, or control lines that are selectively connected and or offset to provide fixed shifting and routing. The following examples illustrate the operation of logic units <b>770</b>A-B and multiplier <b>50</b> in more detail.</p><p>Example of a Reciprocal Operation</p><p>When a reciprocal operation is performed, multiplier <b>50</b> receives the operand to be inverted (referred to herein as \u201coperand B\u201d) as multiplier operand <b>74</b>. Initially, multiplexer <b>780</b> is configured to select operand B. Initial estimate generator <b>774</b> also receives operand B and in response outputs an initial estimate or approximation of the reciprocal (referred to as X<sub>0</sub>) to multiplexer <b>776</b>. Multiplexer <b>776</b> is configured to select, based upon control signals from control logic <b>778</b>, the initial estimate, which is then multiplied by operand B to form the quantity (X<sub>0</sub>\u00d7B). The quantity (X<sub>0</sub>\u00d7B) propagates through multiplier <b>50</b> until it reaches logic units <b>770</b>A-<b>770</b>B. Non-overflow logic unit <b>770</b>A receives a version from fix-up logic <b>288</b>A that assumes no overflow has occurred. Based upon control signal <b>772</b>, non-overflow logic unit <b>770</b>A inverts the version of (X<sub>0</sub>\u00d7B) it receives to approximate the quantity (2\u00d7X<sub>0</sub>\u00d7B). Non-overflow logic unit <b>770</b>A may be configured to normalize its output by forcing the corresponding exponent to a constant, e.g., 2<sup>0</sup>. Note all references herein are to unbiased exponents. For example, an unbiased exponent 2<sup>0 </sup>may translate to a biased exponent of 2<sup>7F </sup>(assuming a +7F<sub>16 </sub>or +127<sub>10 </sub>bias). Similarly, overflow logic unit <b>770</b>B receives a version from fix-up logic <b>288</b>B that assumes an overflow has occurred and inverts it. Overflow logic unit <b>770</b>B may also be configured to normalize its output by forcing the corresponding exponent to a constant, e.g., 2<sup>\u22121</sup>. Note that in some embodiments, not all bits from fix-up logic units <b>288</b>A-B may be used or inverted by logic units <b>770</b>A-B.</p><p>Once the overflow and non-overflow approximations for the quantity (2\u2212X<sub>0</sub>\u00d7B) have been output by logic units <b>770</b>A-B, multiplexer <b>290</b> is configured to select one of the approximations based upon the value of MSB <b>284</b> from the output of fix-up logic unit <b>288</b>A. As previously noted, by looking at the most significant bit a determination of whether an overflow occurred can be made. If an overflow occurred, the approximation for the quantity (2\u2212X<sub>0</sub>\u00d7B) from logic unit <b>770</b>B (the overflow path) is selected. If an overflow did not occur, the approximation for the quantity (2\u2212X<sub>0</sub>\u00d7B) from logic unit <b>770</b>A (the non-overflow path) is selected. Note that other control configurations are possible, e.g., MSB <b>284</b> may be the most significant bit of the output from fix-up logic unit <b>288</b>B.</p><p>Once the appropriate approximation for the quantity (2\u2212X<sub>0</sub>\u00d7B) has been selected by multiplexer <b>290</b>, it is routed to multiplexers <b>776</b> and <b>780</b>. Multiplexer <b>780</b> is directed by control logic <b>778</b> to select the approximation so that it may be multiplied by initial estimate X<sub>0 </sub>to form the quantity X<sub>0</sub>\u00d7(2\u2212X<sub>0</sub>\u00d7B). During this multiplication, however, logic units <b>770</b>A-B are configured to allow the values from fix-up logic units <b>288</b>A-B to pass through unchanged. The result selected by multiplexer <b>290</b> is the approximation of the reciprocal of operand B after one Newton-Raphson iteration. As previously noted, the process may be repeated a number of times to achieve greater accuracy.</p><p>Example of a Reciprocal Square Root Operation</p><p>When a reciprocal square root operation is performed, multiplier <b>50</b> operates in much the same fashion as previously described for a reciprocal operation. The operand to be raised to the \u2212\u00bd power (referred to herein as \u201coperand B\u201d) is received as multiplier operand <b>74</b>. Initially, multiplexer <b>780</b> is configured to select operand B. Initial estimate generator <b>774</b> also receives operand B and in response outputs an initial estimate or approximation of the reciprocal (referred to as Y<sub>0</sub><sup>2</sup>, which equals X<sub>0</sub>) and the reciprocal square root (referred to as Y<sub>0</sub>) to multiplexer <b>776</b>. Multiplexer <b>776</b> is configured to select, based upon control signals from control logic <b>778</b>, the initial estimate Y<sub>0</sub><sup>2</sup>, which is then multiplied by operand B to form the quantity (Y<sub>0</sub><sup>2</sup>\u00d7B). The quantity (Y<sub>0</sub><sup>2</sup>\u00d7B) propagates through multiplier <b>50</b> until it reaches logic units <b>770</b>A-<b>770</b>B. Non-overflow logic Unit <b>770</b>A receives a version from fix-up logic <b>288</b>A that assumes no overflow has occurred. Based upon control signal <b>772</b>, non-overflow logic unit <b>770</b>A inverts the version of quantity (Y<sub>0</sub><sup>2</sup>\u00d7B) it receives to approximate the quantity (2\u2212Y<sub>0</sub><sup>2</sup>\u00d7B). Logic unit <b>770</b>A also pads the most significant bit of the quantity (2\u2212Y<sub>0</sub><sup>2</sup>\u00d7B) with a constant one to approximate the quantity (3\u2212Y<sub>0</sub><sup>2</sup>\u00d7B). Logic unit <b>770</b>A may then normalize the quantity (3\u2212Y<sub>0</sub><sup>2</sup>\u00d7B) by selectively routing (e.g., wire-shifting) bits to multiplexer <b>290</b> in a particular position or offset and by forcing the corresponding exponent to 2<sup>0</sup>.</p><p>Overflow logic unit <b>770</b>B may be similarly configured to invert the version of quantity (Y<sub>0</sub><sup>2</sup>\u00d7B) it receives to approximate the quantity (2\u2212Y<sub>0</sub><sup>2</sup>\u00d7B). Logic unit <b>770</b>B also pads the most significant bit of the quantity (2\u2212Y<sub>0</sub><sup>2</sup>\u00d7B) with a constant one to approximate the quantity (3\u2212Y<sub>0</sub><sup>2</sup>\u00d7B). Logic unit <b>770</b>B may then normalize the quantity (3\u2212Y<sub>0</sub><sup>2</sup>\u00d7B) by selectively routing bits to multiplexer <b>290</b> in a particular position or offset and by forcing the corresponding exponent to 2<sup>\u22121</sup>. Note that in some embodiments, not all bits from fix-up logic units <b>288</b>A-B may be used or inverted by logic units <b>770</b>A-B.</p><p>Once the overflow and non-overflow approximations for the quantity (3\u2212Y<sub>0</sub><sup>2</sup>\u00d7B) have been output by logic units <b>770</b>A-B, multiplexer <b>290</b> is configured to select one of the approximations based upon the value of MSB <b>284</b> from the output of fix-up logic unit <b>288</b>A. As previously noted, by looking at the most significant bit a determination of whether an overflow occurred can be made. If an overflow occurred, the approximation for the quantity (3\u2212Y<sub>0</sub><sup>2</sup>\u00d7B) from logic unit <b>770</b>B (the overflow path) is selected. If an overflow did not occur, the approximation for the quantity (3\u2212Y<sub>0</sub><sup>2</sup>\u00d7B) from logic unit <b>770</b>A (the non-overflow path) is selected. Other control configurations are also possible.</p><p>Once the approximation for the quantity (3\u2212Y<sub>0</sub><sup>2</sup>\u00d7B) has been selected by multiplexer <b>290</b>, it is routed to multiplexer <b>780</b>. Multiplexer <b>780</b> is directed by control logic <b>778</b> to select the approximation so that it may be multiplied by initial estimate Y<sub>0 </sub>that was read from initial estimate generator <b>744</b> to form the quantity Y<sub>0</sub>\u00d7(3\u2212Y<sub>0</sub><sup>2</sup>\u00d7B). During this multiplication, however, logic units <b>770</b>A-B are configured to allow the values from fix-up logic units <b>288</b>A-B to pass through unchanged. The result selected by multiplexer <b>290</b> is the approximation of the reciprocal square root of operand B after one Newton-Raphson iteration. As previously noted, the process may be repeated a number of times to achieve greater accuracy. However, in subsequent iterations the result may be squared to form Y<sub>n</sub><sup>2</sup>, which is then used in place of the initial estimate Y<sub>0</sub><sup>2 </sup>from initial estimate generator <b>774</b>.</p><p>Note other configurations of multiplier <b>50</b> are possible and contemplated. For example, non-overflow logic <b>770</b>A and overflow logic <b>770</b>B may instead be configured to receive rounded and normalized value <b>292</b> from multiplexer <b>290</b>, in which case a separate multiplexer (not shown) may be needed to select between the values output by non-overflow logic <b>770</b>A and overflow logic <b>770</b>B. In some embodiments of multiplier <b>50</b>, registers may be used to store various intermediate results, e.g., the inputs to multiplexers <b>776</b> and <b>780</b>, and the results from multiplexer <b>290</b>. The registers may the store the intermediate results for use during subsequent clock cycles.</p><p>Turning to FIG. 27, details of one exemplary embodiment of non-overflow logic unit <b>770</b>A configured to calculate the quantity (3\u2212Y<sub>0</sub><sup>2</sup>\u00d7B) for the reciprocal square root calculation are shown. When the quantity (Y<sub>0</sub><sup>2</sup>\u00d7B) <b>790</b>A is received from LSB fix-up logic <b>228</b>A, inverters <b>792</b>A invert selected bits to approximate the quantity (2\u2212Y<sub>0</sub><sup>2</sup>\u00d7B). Note that an inverter may not be required for all bits, e.g., the most and least significant bits. Constants <b>794</b>A are then used to replace the most significant bit of the quantity (2\u2212Y<sub>0</sub><sup>2</sup>\u00d7B) <b>790</b>A to approximate the quantity (3\u2212Y<sub>0</sub><sup>2</sup>\u00d7B), which is output to multiplexer <b>290</b>. A constant or control signal may be routed to exponent control logic <b>254</b> to force the corresponding exponent to 2<sup>0</sup>.</p><p>A numerical example further illustrates the operation of non-overflow logic unit <b>770</b>A. First, the value 1.111 . . . \u00d72<sup>\u22121 </sup>is received from LSB fix-up logic <b>228</b>A as an approximation of the quantity (Y<sub>0</sub><sup>2</sup>\u00d7B) <b>790</b>A. Next, inverters <b>792</b>A invert the quantity to generate 10.000 . . .\u00d72<sup>\u22121 </sup>as an approximation of the quantity (2\u2212Y<sub>0</sub><sup>2</sup>\u00d7B). Finally, constants <b>794</b>A are used to replace the most significant bits. The results are shifted, resulting in the quantity 1.00000 . . . , and the corresponding exponent is forced to 2<sup>0</sup>. Note that the most and least significant bits of the quantity (Y<sub>0</sub><sup>2</sup>\u00d7B) <b>790</b>A may not be incorporated into the quantity (2\u2212Y<sub>0</sub><sup>2</sup>\u00d7B).</p><p>Overflow logic <b>770</b>B operates in a similar fashion. However, the most significant bit of quantity <b>790</b>B is replaced with only a single constant <b>794</b>B, and bits <b>30</b> through <b>0</b> are incorporated into the quantity (2\u2212Y<sub>0</sub><sup>2</sup>\u00d7B). A numerical example further illustrates the operation of overflow logic unit <b>770</b>B. First, the value 10.000.. .\u00d72<sup>\u22121 </sup>is received from LSB fix-up logic <b>228</b>B as an approximation of the quantity (Y<sub>0</sub><sup>2</sup>\u00d7B) <b>790</b>B. Next, inverters <b>792</b>B invert the quantity to generate 01.111 . . . \u00d72<sup>\u22121 </sup>as an approximation of the quantity (2\u2212Y<sub>0</sub><sup>2</sup>\u00d7B). Finally, constant <b>794</b>B is used to replace the most significant bit. The results are shifted, resulting in the quantity 1.1111 . . . , and the corresponding exponent is forced to 2<sup>\u22121</sup>.</p><p>Turning now to FIG. 28, another exemplary embodiment of non-overflow logic <b>770</b>A and overflow logic <b>770</b>B is shown. The embodiments shown in the figure are configured to return the quantity (2\u2212Y<sub>0</sub><sup>2</sup>\u00d7B) for the reciprocal calculation. A numerical example illustrates the operation of non-overflow logic <b>770</b>A and overflow logic <b>770</b>B. Assuming non-overflow logic <b>770</b>A receives a value 1.111 . . . \u00d72<sup>\u22121 </sup>as the quantity (Y<sub>0</sub><sup>2</sup>\u00d7B) <b>790</b>A, then inverters <b>792</b>A are used to invert the bits (excluding the least significant bit) to obtain a value 0.000 . . . Constant <b>796</b>A is then used to pad the most significant bit position. The remaining bits are all shifted one position, with the result 1.0000 . . . being output to multiplexer <b>290</b>. The corresponding exponent is forced to 2<sup>0 </sup>by signal <b>796</b>A.</p><p>Overflow path <b>770</b>B operates in a similar fashion. For example, assuming value <b>790</b>B is, 1.000 . . . \u00d72<sup>\u22121</sup>, then inverters <b>792</b>B generate the value 0.111 . . . which is shifted and output to multiplexer <b>290</b> as the value 1.11 . . . Note the least significant bit may be padded with a constant <b>794</b>B, e.g., zero, while the corresponding exponent is forced to 2<sup>\u22121 </sup>by signal <b>796</b>B.</p><p>Note the examples and figures referred to herein are exemplary. Other configurations for non-overflow logic <b>770</b>A and overflow logic <b>770</b>B and multiplier <b>50</b> are also contemplated. For example, the least significant bit from quantity <b>790</b>B may be duplicated instead of using constant <b>794</b>B. Other constant values may also be used, and the widths of quantities <b>770</b>A-B may be reduced before they are routed to multiplexer <b>290</b> (e.g., from 32 bits to 24 bits). Other logic components may be used in place of inverters <b>792</b>A-B, and the bit routing structure disclosed above may be replaced by other logic components, e.g., a shifter. The functionality provided by non-overflow logic <b>770</b>A and overflow logic <b>770</b>B may be provided in other components internal or external to multiplier <b>50</b>. In addition, multiplier <b>50</b> may be configured to perform both reciprocal and reciprocal square root functions, e.g., by incorporating two versions of non-overflow logic <b>770</b>A and overflow logic <b>770</b>B, or by incorporating multiplexers within non-overflow logic <b>770</b>A and overflow logic <b>770</b>B to select which routing of bits and constants should be applied.</p><p>Compression of Intermediate Products</p><p>When performing iterative calculations, multiplier <b>50</b> calculates intermediate products which may be stored in registers. During the next iteration, the intermediate product may be read from the register and used as an operand. Unfortunately, each iteration may introduce rounding errors that accumulate in the final result. For example, assuming an N-bit significand, the results from each multiplication have significands that are 2N bits wide. This result may be rounded to N-bits or some other width. The greater the number of iterations, the larger the potential rounding error may be in the final result. For obvious reasons, it is desirable to reduce the magnitude of this rounding error.</p><p>One possible method to reduce the rounding error is to calculate extra bits for each intermediate product and then round at lower bit positions. Each iteration may generate accurate bits in lower (less significant) bit positions than the previous iteration. However, due to the fixed size of the storage registers within multiplier <b>50</b>, the extra bits will not fit unless the registers within multiplier <b>50</b> are widened accordingly. There are several potential drawbacks to using wider registers, including the additional die space requirements and the additional architectural state requirements for context switches. Thus, a mechanism for maintaining the accuracy provided by the extra bits without using wider registers may be desirable.</p><p>One possible method for providing such extra accuracy without increasing the size of the storage registers is to compress the intermediate results before they are stored. However, not all compression algorithms are well suited for use within multiplier <b>50</b>. One concern, in particular, is speed. Another concern is the die space required to implement the compression.</p><p>Turning now to FIG. 29A, a flowchart illustrating one possible method for fast compression is shown. In the embodiment illustrated, the intermediate product is first calculated to N extra significant bits (step <b>600</b>), wherein N is a predetermined constant. For example, assuming multiplier <b>50</b> receives 24-bit operands, multiplier <b>50</b> may calculate intermediate products to a precision of 28 bits. In this case, N equals 4 bits. Once the intermediate product is calculated, the next-to-most significant bit is examined (step <b>602</b>). The value of the next-to-most significant bit determines the value of a signaling bit. If the next-to-most significant bit equals one (step <b>604</b>), then the signaling bit equals one also. If, on the other hand, the next-to-most significant bit equals zero (step <b>606</b>), then the signaling bit equals zero. The signaling bit is used to replace a portion of the intermediate product, thereby compressing the intermediate product (step <b>608</b>). In one embodiment, the portion replaced by the signaling bit is N+1 bits wide. While this method assumes that the portion being replaced comprises entirely one's or zero's, this may be a safe assumption when certain types of iterations are being performed. For example, when performing the Newton-Raphson iterations previously disclosed for calculating the square root and inverse square root, the products (2\u2212B\u00d7X<sub>n</sub>) and (3\u2212B\u00d7Y<sub>n</sub><sup>2</sup>) are formed during each iteration. As previously noted, these product are very close to one (e.g., either slightly over one, 1.00000000 . . . \u00d72<sup>0</sup>, or slightly under one, 1.11111111 . . . \u00d72<sup>\u22121</sup>). Accordingly, many of the leading bits (excluding the most significant bit in some cases) of the products are identical, i.e., either all zeros or ones, from one iteration to the next with differences occurring in the less significant bits. This property allows the method illustrated in FIG. 29A to be used effectively.</p><p>The maximum number of bits that may be compressed in a particular implementation may be determined by examining the number of bits that have the same values over the entire range of possible operand values. For example, if an embodiment using a 32-bit significand is determined to have nine bits that have the same value for all possible operand values, then the 32-bit results may compressed so that they may be stored in 24-bit registers.</p><p>While the present embodiment illustrated in the figure performs the compression whenever a particular iterative calculation is performed, in other embodiments the compression may be performed conditionally. For example, in one embodiment the compression may be performed only if a comparison of the bits to be compressed shows that they all have the same value. While many different types of hardware may be used to perform this comparison, one possible configuration may utilize multiple input AND gates and multiple input NAND gates. If the testing logic determines that the bits to be compressed do not all have the same value, then the operand may stored by truncating the extra least significant bits. While this implementation may lose the benefit of increased accuracy in some cases, this may be adequate if the bits to be compressed rarely have different values.</p><p>When the compressed intermediate product is needed for the next iteration, it may be decompressed. Turning now to FIG. 29B, one possible method for decompressing the compressed intermediate product is illustrated. First, the compressed intermediate product is read from the storage register (step <b>612</b>). Next, the compressed intermediate product is expanded by padding the next-to-most significant bits with copies of the signaling bit (step <b>614</b>). The number of copies of the signaling bit that are padded or inserted below the most significant bit in this embodiment equals N\u22121. Advantageously, the expanded intermediate product now has the same width as the original intermediate product. For example, if the compressed intermediate product comprises 24 bits, and the original intermediate product comprises 28 bits, then the signaling bit will be copied 4 times to render an expanded intermediate product having 28 bits. Advantageously, using the methods illustrated in FIGS. 29A and 29B, no information is lost in the compression and decompression process.</p><p>Note that the bits replaced by the signaling bit need not be the most significant bit. They may begin with the next-to-most significant bit. For example, if the most significant bit of the intermediate product is bit <b>27</b>, the bits replaced by the signal bit may comprise bits <b>22</b> through <b>26</b>. Further note that the signaling bit may simply be a particular bit within the intermediate product, i.e., an extra calculation to determine the signal bit is not required. Furthermore, the signal bit need not be the most significant or least significant bit in the range of bits to be compressed, i.e., the signal bit may be a bit in the middle of the range of bits to be compressed.</p><p>Turning now to FIG. 30, one embodiment of multiplier <b>50</b> configured to compress intermediate products is shown. As in previous embodiments, this embodiment of multiplier <b>50</b> comprises partial product generator <b>60</b>, selection logic <b>62</b>, and partial product array adder <b>64</b>. This embodiment also comprises demultiplexer <b>622</b>, 24-bit storage register <b>638</b>, and multiplexers <b>776</b> and <b>780</b>. Demultiplexer <b>622</b> receives an intermediate product <b>620</b> from partial product array adder <b>64</b>. Other embodiments are also contemplated. For example, demultiplexer <b>622</b> may receive intermediate product <b>620</b> from multiplexer <b>290</b> (see FIG. <b>26</b>). Demultiplexer <b>622</b> routes intermediate product <b>620</b> according to an iterative control signal <b>644</b>. For example, if iterative control signal <b>644</b> indicates that an iterative operation is being performed, then intermediate product <b>620</b> is routed to storage register <b>638</b>. If, on the other hand, iterative control signal <b>644</b> indicates that an iterative operation is not being performed, then intermediate product <b>620</b> may be routed to standard rounding logic (not shown) and then output. In another embodiment, intermediate product <b>620</b> may be rounded before reaching demultiplexer <b>622</b>. In this case, demultiplexer <b>622</b> may simply route product <b>620</b> to an output of multiplier <b>50</b> if an iterative calculation is not being performed.</p><p>In the event an iterative operation is being performed, storage register <b>638</b> is configured to store intermediate product <b>620</b> until it is needed for the next iteration. The signal and data lines coupled to the inputs and outputs of storage register <b>638</b> may be referred to herein as a wire shifter because they provide a fixed shifting function. As previously noted, storage register <b>638</b> may be implemented so that it is smaller than intermediate product <b>620</b>. Assuming, for example, that intermediate product is 28 bits wide, storage register <b>638</b> may be configured to store only the 24 least significant bits of intermediate product <b>620</b>. Assuming the five next-to-most significant bits of intermediate product <b>620</b> all have the same value for the particular iteration being performed, then bit <b>22</b> may be selected as a signal bit <b>632</b> to replace the four next-to-most significant bits <b>636</b>. Thus, as the figured illustrates, storage register <b>638</b> may be configured to store bits <b>0</b>-<b>21</b>, signal bit <b>632</b>, and bit <b>27</b>.</p><p>When the next iteration is performed, bits <b>0</b>-<b>21</b>, signal bit <b>632</b>, and bit <b>27</b> are read from storage register <b>638</b>. To recreate the full 28 bits of intermediate product <b>620</b>, signal bit <b>632</b> is copied four times to recreate bits <b>23</b>-<b>26</b>. Advantageously, no information from intermediate product <b>620</b> is lost in the compression and decompression cycle.</p><p>Multiplier <b>50</b> may also be configured with optional testing logic <b>624</b>, which is configured to determine whether the five most significant bits from intermediate product <b>620</b> have the same value. In one embodiment, testing logic <b>624</b> may comprise five-input AND gate <b>626</b>, five-input NOR gate <b>628</b>, and two-input OR gate <b>630</b>. The output from two-input OR gate <b>630</b> may be used in a number of ways, e.g., to signal an error condition or to cause register <b>638</b> to store the 24 most significant bits without compression.</p><p>In some embodiments, testing logic <b>624</b> may be omitted. Furthermore, demultiplexer <b>622</b> may also be omitted. In such embodiments, product <b>620</b> may be rounded and then routed to both storage register <b>638</b> and the outputs of multiplexer <b>50</b>. In the event of an iterative calculation, external logic may be used to ensure that functional units or other parts of the microprocessor will not use the data output by multiplier <b>50</b> until the iterative calculation is completed.</p><p>Turning now to FIG. 31A, a figure illustrating one possible method for compression is shown. As the figure illustrates, uncompressed intermediate product <b>656</b> may comprise 28 bits numbered <b>0</b> through <b>27</b>. If the five most significant bits <b>652</b> from intermediate product <b>656</b> all have the same value, they may be compressed into one signal bit <b>654</b>. This allows uncompressed intermediate product <b>656</b> to be represented and stored as compressed intermediate product <b>658</b>, thereby using only 24 bits. When compressed intermediate product <b>658</b> is uncompressed, signal bit <b>654</b> is copied four times to create the four most significant bits of uncompressed intermediate product <b>660</b>.</p><p>Turning now to FIG. 31B, a figure illustrating another possible method for compressing intermediate product is shown. In this embodiment, intermediate product <b>676</b> is characterized by having five equal bits <b>672</b> directly below most significant bit <b>680</b>. As the figure illustrates, the five equal bits <b>672</b> may be compressed into one signal bit <b>674</b> even though they are not the most significant bits in intermediate product <b>676</b>. Compressed product <b>678</b> is still able to fit within a 24 bit storage register. To decompress compressed product <b>678</b>, four copies of signal bit <b>674</b> are inserted below most significant bit <b>680</b> within uncompressed product <b>682</b>. Once again, no information from intermediate product <b>676</b> is lost in the process. As this example illustrates, the contemplated compression method may be used regardless of where the bits having equal values are located. Advantageously, no information is lost if the bits having equal values are located in the same position in each iteration.</p><p>Achieving Higher Frequencies of Exactly Rounded Results</p><p>When an infinitely precise result is rounded to the nearest machine number, the maximum possible error is one-half of a unit in the last place (ulp). When performing an iterative calculation such as the Newton-Raphson iterations discussed above for the reciprocal and reciprocal square root, the results converge toward the infinitely precise result. However, due to limitations in the number of bits of precision that are available, the number of iterations performed, and the approximations discussed above to improve the speed of each iteration, some input operands may generate results from multiplier <b>50</b> that do not equal the infinitely precise result rounded to the nearest machine number (also referred to as the \u201cexactly rounded result\u201d). This holds true even when each iteration is configured to use the \u201cround to nearest\u201d rounding mode.</p><p>Thus, it would be desirable to increase the frequency or probability that the calculated result equals the exactly rounded result. One method to determine whether the calculated result equals the exactly rounded result is to multiply the calculated result (calculated to at least one extra bit of accuracy, i.e., N+1 bits) and the original operand B (assuming the reciprocal of B has been calculated). The exactly rounded result may then be selected from the following three values: the N-bit result (without the extra bit) plus one in the least significant bit; the N-bit result minus one in the least significant bit; or the N-bit result plus zero. The exactly rounded result is selected based upon the value of the extra computed bit (i.e., bit N+1) and whether the result of multiplication was greater than one, less than one, or equal to one.</p><p>Rather than computing the exactly rounded result with a probability of one as described above (i.e., performing an extra multiplication step), multiplier <b>50</b> may be configured to achieve nearly the same accuracy (i.e., computing the exactly rounded result with a probability close to one) by adding an \u201cadjustment constant\u201d to the result produced from the last step of the iterative calculation before rounding. Depending upon the actual implementation of the multiplier (e.g., the number of bits of precision, the number of iterations performed, and the accuracy of the initial approximation) the probability that the calculated result is higher than the exactly rounded result (\u201cP<sub>high</sub>\u201d) may be greater than the probability that the calculated result is lower than the exactly rounded result (\u201cP<sub>low</sub>\u201d). If this is the case, then adding a negative adjustment constant in the final step of the iteration may increase the probability that the calculated result will equal the exactly rounded result (\u201cP<sub>equal</sub>\u201d). Similarly, if P<sub>high </sub>is less than P<sub>low</sub>, then adding a positive adjustment constant may increase P<sub>equal</sub>. The probabilities P<sub>high</sub>, P<sub>low</sub>, and P<sub>equal </sub>may be determined by passing a large number of differing input operand values through the iterative calculation (as performed by the multiplier) and then comparing each result with the corresponding exactly rounded result. A computer program may be particularly useful in performing the comparisons. The comparisons may also be performed before rounding, i.e., comparing the infinitely precise results with the results from the multiplier's final iteration before they are rounded.</p><p>Turning now to FIG. 32, an embodiment of multiplier <b>50</b> configured to add a correction constant is shown. Generally, multiplier <b>50</b> may be configured similarly to other embodiments disclosed herein that are capable of performing iterative calculations. However, in this embodiment control logic <b>778</b> is configured to convey adjustment constant <b>800</b> to partial product array adder <b>64</b> during the last step of an iterative calculation. Partial product array adder <b>64</b> then sums adjustment constant <b>800</b> with the selected partial products from selection logic <b>62</b>. Advantageously, this configuration may not require an additional set of adders to sum adjustment constant <b>800</b> into the result. Another potential advantage of this configuration is that any overflows or denormalizations that occur as a result of adjustment constant <b>800</b> are addressed by the rounding and normalization process already built into multiplier <b>50</b> (i.e., carry-save adders <b>276</b>A-B, carry-propagate adders <b>278</b>A-B, sticky bit logic units <b>280</b>A-B, LSB fix-up logic units <b>288</b>A-B, and logic units <b>770</b>A-B).</p><p>In another embodiment, adjustment constant <b>800</b> may instead be summed into the result by carry-save adders <b>276</b>A-B and or carry-propagate adders <b>278</b>A-B. Another embodiment may incorporate an extra adder (not shown) to sum adjustment constant <b>800</b> with result <b>292</b> from multiplexer <b>290</b>. However, this configuration may require additional logic in the event the result becomes denormalized or experiences an overflow as a result of the addition.</p><p>Control logic <b>778</b> may be configured to convey adjustment constant <b>800</b> to partial product array adder <b>64</b> during the final multiplication in each iteration, or just for the final multiplication during the final iteration. For example, if the iterative calculation involves two multiplication operations for each iteration, and three iterations are required to achieve the desired accuracy, then control logic <b>778</b> may be configured to convey adjustment constant <b>800</b> during the final multiplication of each iteration, i.e., three times, or only once during the second multiplication of the third and final iteration. In yet another embodiment, control logic <b>778</b> may convey adjustment constant <b>800</b> to partial product adder <b>64</b> during every multiplication in the iteration.</p><p>In yet another embodiment, control logic unit <b>778</b> may store a number of different adjustment constants <b>800</b>, e.g., one for each type of iteration. In such a configuration, control logic unit <b>778</b> may convey the appropriate adjustment constant that corresponds to the type of iterative calculation being performed. Control logic unit <b>778</b> receives an indication of which iterative calculation is being perform via control signal <b>722</b>. For example, when control signal <b>722</b> indicates that the reciprocal iterative calculation is to be performed, control logic <b>778</b> may convey a first adjustment constant <b>800</b> to partial product array adder <b>64</b>. However, when control signal <b>722</b> indicates that the reciprocal square root iterative calculation is being performed, control logic <b>778</b> may convey a second, different adjustment constant to partial product array adder <b>64</b>.</p><p>In another embodiment, multiplier <b>50</b> may be configured to calculate three versions of each result, i.e., a first result generated without adding an adjustment constant, a second result generated by adding an adjustment constant, and a third result generated by subtracting the adjustment constant. Alternatively, the second and third results could be calculated by adding different adjustment constants. These results may be calculated in parallel by multiplier <b>50</b>. Once the result without the adjustment constant is generated, a multiplication may be performed as described above to determine whether the result is correct, too high, or too low. The corresponding result may then be selected.</p><p>Exemplary Configuration Using Two Multipliers</p><p>Turning now to FIG. 33A, an example of a vector multiplication using two multipliers <b>50</b>A and <b>50</b>B is shown. Multipliers <b>50</b>A and <b>50</b>B may be configured similarly to multiplier <b>50</b> as described in previous embodiments. As shown in the figure, multipliers <b>50</b>A and SOB are configured to operate in parallel to execute a vector multiplication of a pair of vectors each comprising four 16-bit operands <b>380</b>A-<b>380</b>D and <b>382</b>A-<b>382</b>D. Note operands <b>380</b>A-<b>380</b>D may come from a first 64-bit MMX register, while operands <b>382</b>A-<b>382</b>D may come from a second 64-bit MMX register.</p><p>Turning now to FIG. 33B, another example of a vector multiplication using multipliers <b>50</b>A and <b>50</b>B is shown. In this configuration, multipliers <b>50</b>A and <b>50</b>B operate in parallel to multiply a pair of vectors each comprising two 32-bit operands <b>384</b>A-<b>384</b>B and <b>386</b>A-<b>386</b>B. Once again, operands <b>384</b>A-<b>384</b>B may come from a first 64-bit MMX register, while operands <b>386</b>A-<b>386</b>B may come from a second 64-bit MMX register. Further note that while a vector operation is being performed, each individual multiplier <b>50</b>A and <b>50</b>B is performing a scalar multiplication. Other modes of operation are also contemplated, for example, multiplier <b>50</b>A may perform a 32-bit scalar multiplication independent from multiplier <b>50</b>B. While multiplier <b>50</b>A performs the multiplication, multiplier <b>50</b>B may sit idle or perform an independent multiplication operation.</p><p>Exemplary Computer System Using Multiplier</p><p>Turning now to FIG. 34, a block diagram of one embodiment of a computer system <b>400</b> including microprocessor <b>10</b> is shown. Microprocessor <b>10</b> is coupled to a variety of system components through a bus bridge <b>402</b>. Other embodiments are possible and contemplated. In the depicted system, a main memory <b>404</b> is coupled to bus bridge <b>402</b> through a memory bus <b>406</b>, and a graphics controller <b>408</b> is coupled to bus bridge <b>402</b> through an AGP bus <b>410</b>. Finally, a plurality of PCI devices <b>412</b>A-<b>412</b>B are coupled to bus bridge <b>402</b> through a PCI bus <b>414</b>. A secondary bus bridge <b>416</b> may further be provided to accommodate an electrical interface to one or more EISA or ISA devices <b>418</b> through an EISA/ISA bus <b>420</b>. Microprocessor <b>10</b> is coupled to bus bridge <b>402</b> through a CPU bus <b>424</b>.</p><p>Bus bridge <b>402</b> provides an interface between microprocessor <b>10</b>, main memory <b>404</b>, graphics controller <b>408</b>, and devices attached to PCI bus <b>414</b>. When an operation is received from one of the devices connected to bus bridge <b>402</b>, bus bridge <b>402</b> identifies the target of the operation (e.g. a particular device or, in the case of PCI bus <b>414</b>, that the target is on PCI bus <b>414</b>). Bus bridge <b>402</b> routes the operation to the targeted device. Bus bridge <b>402</b> generally translates an operation from the protocol used by the source device or bus to the protocol used by the target device or bus.</p><p>In addition to providing an interface to an ISA/EISA bus for PCI bus <b>414</b>, secondary bus bridge <b>416</b> may further incorporate additional functionality, as desired. For example, in one embodiment, secondary bus bridge <b>416</b> includes a master PCI arbiter (not shown) for arbitrating ownership of PCI bus <b>414</b>. An input/output controller (not shown), either external from or integrated with secondary bus bridge <b>416</b>, may also be included within computer system <b>400</b> to provide operational support for a keyboard and mouse <b>422</b> and for various serial and parallel ports, as desired. An external cache unit (not shown) may further be coupled to CPU bus <b>424</b> between microprocessor <b>10</b> and bus bridge <b>402</b> in other embodiments. Alternatively, the external cache may be coupled to bus bridge <b>402</b> and cache control logic for the external cache may be integrated into bus bridge <b>402</b>.</p><p>Main memory <b>404</b> is a memory in which application programs are stored and from which microprocessor <b>10</b> primarily executes. A suitable main memory <b>404</b> comprises DRAM (Dynamic Random Access Memory), and preferably a plurality of banks of SDRAM (Synchronous DRAM).</p><p>PCI devices <b>412</b>A-<b>412</b>B are illustrative of a variety of peripheral devices such as, for example, network interface cards, video accelerators, audio cards, hard or floppy disk drives or drive controllers, SCSI (Small Computer Systems Interface) adapters and telephony cards. Similarly, ISA device <b>418</b> is illustrative of various types of peripheral devices, such as a modem, a sound card, and a variety of data acquisition cards such as GPIB or field bus interface cards.</p><p>Graphics controller <b>408</b> is provided to control the rendering of text and images on a display <b>426</b>. Graphics controller <b>408</b> may embody a typical graphics accelerator generally known in the art to render three-dimensional data structures which can be effectively shifted into and from main memory <b>404</b>. Graphics controller <b>408</b> may therefore be a master of AGP bus <b>410</b> in that it can request and receive access to a target interface within bus bridge <b>402</b> to thereby obtain access to main memory <b>404</b>. A dedicated graphics bus accommodates rapid retrieval of data from main memory <b>404</b>. For certain operations, graphics controller <b>408</b> may further be configured to generate PCI protocol transactions on AGP bus <b>410</b>. The AGP interface of bus bridge <b>402</b> may thus include functionality to support both AGP protocol transactions as well as PCI protocol target and initiator transactions. Display <b>426</b> is any electronic display upon which an image or text can be presented. A suitable display <b>426</b> includes a cathode ray tube (\u201cCRT\u201d), a liquid crystal display (\u201cLCD\u201d), etc.</p><p>It is noted that, while the AGP, PCI, and ISA or EISA buses have been used as examples in the above description, any bus architectures may be substituted as desired. It is further noted that computer system <b>400</b> may be a multiprocessing computer system including additional microprocessors (e.g. microprocessor <b>10</b><i>a </i>shown as an optional component of computer system <b>400</b>). Microprocessor <b>10</b><i>a </i>may be similar to microprocessor <b>10</b>. More particularly, microprocessor <b>10</b><i>a </i>may be an identical copy of microprocessor <b>10</b>. Microprocessor <b>10</b><i>a </i>may share CPU bus <b>424</b> with microprocessor <b>10</b> (as shown in FIG. 5) or may be connected to bus bridge <b>402</b> via an independent bus.</p><p>It is still further noted that the present discussion may refer to the assertion of various signals. As used herein, a signal is \u201casserted\u201d if it conveys a value indicative of a particular condition. Conversely, a signal is \u201cdeasserted\u201d if it conveys a value indicative of a lack of a particular condition. A signal may be defined to be asserted when it conveys a logical zero value or, conversely, when it conveys a logical one value. Additionally, various values have been described as being discarded in the above discussion. A value may be discarded in a number of manners, but generally involves modifying the value such that it is ignored by logic circuitry which receives the value. For example, if the value comprises a bit, the logic state of the value may be inverted to discard the value. If the value is an n-bit value, one of the n-bit encodings may indicate that the value is invalid. Setting the value to the invalid encoding causes the value to be discarded. Additionally, an n-bit value may include a valid bit indicative, when set, that the n-bit value is valid. Resetting the valid bit may comprise discarding the value. Other methods of discarding a value may be used as well.</p><p>Although the embodiments above have been described in considerable detail, other versions are possible. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Stuart", "last_name": "Oberman", "name": ""}, {"first_name": "Norbert", "last_name": "Juffa", "name": ""}, {"first_name": "Ming", "last_name": "Siu", "name": ""}, {"first_name": "Frederick D", "last_name": "Weber", "name": ""}, {"first_name": "Ravikrishna", "last_name": "Cherukuri", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}, {"first_name": "", "last_name": "ADVANCED SILICON TECHNOLOGIES, LLC", "name": ""}, {"first_name": "", "last_name": "ADVANCED MICRO DEVICES, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   7/52"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/318       20060101A I20051008RMEP"}, {"label": "G06F   7/544       20060101A I20051008RMEP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}, {"label": "G06F   7/52        20060101A I20051008RMEP"}, {"label": "G06F  17/16        20060101A I20051008RMEP"}, {"label": "G06F   7/533       20060101A N20070721RMEP"}], "national_classes": [{"primary": true, "label": "708620"}, {"primary": false, "label": "712E09071"}, {"primary": false, "label": "712E09037"}, {"primary": false, "label": "712E09056"}], "ecla_classes": [{"label": "G06F   9/30U"}, {"label": "G06F   9/38B2"}, {"label": "G06F   9/30A1P"}, {"label": "G06F   7/544A"}, {"label": "G06F  17/16"}, {"label": "S06F7:499E1"}, {"label": "S06F207:38A4M"}, {"label": "G06F   7/53"}, {"label": "S06F7:499R2C"}, {"label": "S06F7:499S"}, {"label": "S06F7:499N"}, {"label": "G06F   9/38T"}, {"label": "S06F7:533C2A"}], "cpc_classes": [{"label": "G06F   7/4991"}, {"label": "G06F   9/3017"}, {"label": "G06F  17/16"}, {"label": "G06F   7/4991"}, {"label": "G06F  17/16"}, {"label": "G06F   7/53"}, {"label": "G06F   7/49936"}, {"label": "G06F   9/3017"}, {"label": "G06F   7/5443"}, {"label": "G06F   7/5338"}, {"label": "G06F   7/49994"}, {"label": "G06F   7/49994"}, {"label": "G06F   7/53"}, {"label": "G06F   9/3804"}, {"label": "G06F   7/49963"}, {"label": "G06F   9/3885"}, {"label": "G06F   9/3804"}, {"label": "G06F   7/5338"}, {"label": "G06F2207/3828"}, {"label": "G06F   9/3885"}, {"label": "G06F   9/30036"}, {"label": "G06F   7/5443"}, {"label": "G06F2207/3828"}, {"label": "G06F   9/30036"}, {"label": "G06F   7/49963"}, {"label": "G06F   7/49936"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1998-08-14", "application_date": "1998-08-14", "family_members": [{"ucid": "US-6381625-B2", "titles": [{"lang": "EN", "text": "Method and apparatus for calculating a power of an operand"}]}, {"ucid": "US-6223198-B1", "titles": [{"lang": "EN", "text": "Method and apparatus for multi-function arithmetic"}]}, {"ucid": "US-20010010051-A1", "titles": [{"lang": "EN", "text": "Method and apparatus for multi-function arithmetic"}]}, {"ucid": "US-20010023425-A1", "titles": [{"lang": "EN", "text": "Method and apparatus for rounding in a multiplier arithmetic"}]}, {"ucid": "US-6397238-B2", "titles": [{"lang": "EN", "text": "Method and apparatus for rounding in a multiplier"}]}]}