{"patent_number": "US-20010049782-A1", "publication_id": 75680356, "family_id": 22956566, "publication_date": "2001-12-06", "titles": [{"lang": "EN", "text": "HARDWARE/SOFTWARE SYSTEM FOR INSTRUCTION PROFILING AND TRACE SELECTION USING BRANCH HISTORY INFORMATION FOR BRANCH PREDICTIONS"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA48269480\"><p id=\"A-0001\">The inventive mechanism provides fast profiling and effective trace selection. The inventive mechanism partitions the work between hardware and software. The hardware automatically detects which code is executed very frequently, e.g. which code is hot code. The hardware also maintains the branch history information. When the hardware determines that a section or block of code is hot code, the hardware sends a signal to the software. The software then forms the trace from the hot code, and uses the branch history information in making branch predictions. </p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00001\" num=\"1\"><claim-text><b>1</b>. A system for profiling instructions of a program and for selecting a trace of a portion of the instructions of the program, the system comprising: \n<claim-text>a hardware portion for detecting which instructions of the program are more frequently executed and for maintaining a history of targets chosen by branch instructions of the program; and </claim-text><claim-text>a software portion for forming the trace of the most frequently executed instructions and using the history in making branch predictions for branch instructions encountered in forming the trace. </claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00002\" num=\"2\"><claim-text><b>2</b>. The system of <claim-ref idref=\"US-20010049782-A1-CLM-00001\"><claim-text>claim 1</claim-text></claim-ref>, wherein the hardware portion comprises: \n<claim-text>a plurality of counters, with one counter associated with at least one instruction of the program, wherein a particular counter is changed each time its associated one instruction is executed; </claim-text><claim-text>a plurality of memory portions for storing the history, with one memory portion associated with each branch instruction of the program, wherein each memory portion maintains information on performance of the associated branch instruction, and the information is maintained for a predetermined number of times of execution of the associated branch instruction. </claim-text></claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00003\" num=\"3\"><claim-text><b>3</b>. The system of <claim-ref idref=\"US-20010049782-A1-CLM-00002\"><claim-text>claim 2</claim-text></claim-ref>, wherein: \n<claim-text>the plurality of counters is a portion of an instruction cache; and </claim-text><claim-text>the plurality of memory portions is another portion of the instruction cache. </claim-text></claim-text></claim>"}, {"num": 4, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00004\" num=\"4\"><claim-text><b>4</b>. The system of <claim-ref idref=\"US-20010049782-A1-CLM-00002\"><claim-text>claim 2</claim-text></claim-ref>, wherein the software portion comprises: \n<claim-text>a trace selector that forms the trace and is invoked when the one counter reaches a predetermined value; </claim-text><claim-text>wherein the trace selector begins the trace with the instruction associated with the one counter and ends the trace with an instruction selected by a predetermined criteria. </claim-text></claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00005\" num=\"5\"><claim-text><b>5</b>. The system of <claim-ref idref=\"US-20010049782-A1-CLM-00004\"><claim-text>claim 4</claim-text></claim-ref>, wherein: \n<claim-text>the predetermined value is zero; and </claim-text><claim-text>each counter is initialized to a predetermined initialization value and is decremented each time its associated one instruction is executed. </claim-text></claim-text></claim>"}, {"num": 6, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00006\" num=\"6\"><claim-text><b>6</b>. The system of <claim-ref idref=\"US-20010049782-A1-CLM-00004\"><claim-text>claim 4</claim-text></claim-ref>, wherein: \n<claim-text>the trace selector determines a branch prediction upon encountering a branch instruction, based upon the information in the memory portion of the history associated with the branch instruction. </claim-text></claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00007\" num=\"7\"><claim-text><b>7</b>. The system of <claim-ref idref=\"US-20010049782-A1-CLM-00006\"><claim-text>claim 6</claim-text></claim-ref>, wherein: \n<claim-text>the information describes whether the branch instruction has performed one of fallen through to the next sequential instruction and taken the branch to the target instruction, during a predetermined number of prior executions of the branch instruction. </claim-text></claim-text></claim>"}, {"num": 8, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00008\" num=\"8\"><claim-text><b>8</b>. The system of <claim-ref idref=\"US-20010049782-A1-CLM-00004\"><claim-text>claim 4</claim-text></claim-ref>, wherein: \n<claim-text>the predetermined criteria is an instruction that is a backward branch which forms a loop. </claim-text></claim-text></claim>"}, {"num": 9, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00009\" num=\"9\"><claim-text><b>9</b>. The system of <claim-ref idref=\"US-20010049782-A1-CLM-00004\"><claim-text>claim 4</claim-text></claim-ref>, wherein the predetermined criteria is selected from the group consisting of: \n<claim-text>a predetermined length of the trace, a predetermined number of conditional branch instruction s within the trace, a predetermined probability of accumulate d branch predictions of the trace, and an instruction that is an indirect branch. </claim-text></claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00010\" num=\"10\"><claim-text><b>10</b>. A method for profiling instructions of a program and for selecting a trace of a portion of the instructions of the program, the method comprising the steps of: \n<claim-text>detecting, via hardware which instructions of the program are more frequently executed; </claim-text><claim-text>maintaining, via hardware, a history of targets chosen by branch instructions of the program; and </claim-text><claim-text>forming the trace, via software, from the most frequently executed instructions, including the step of making branch predictions from the history for branch instructions encountered during the operation of the step of forming the trace. </claim-text></claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00011\" num=\"11\"><claim-text><b>11</b>. The method of <claim-ref idref=\"US-20010049782-A1-CLM-00010\"><claim-text>claim 10</claim-text></claim-ref>, wherein the step of detecting includes the step of providing a plurality of counters, with one counter associated with at least one instruction of the program, wherein a particular counter is changed each time its associated one instruction is executed; and \n<claim-text>the step maintaining includes the step of providing of a plurality of memory portions for storing the history, with one memory portion associated with each branch instruction of the program, wherein each memory portion maintains information on performance of the associated branch instruction, and the information is maintained for a predetermined number of times of execution of the associated branch instruction. </claim-text></claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00012\" num=\"12\"><claim-text><b>12</b>. The method of <claim-ref idref=\"US-20010049782-A1-CLM-00011\"><claim-text>claim 11</claim-text></claim-ref>, wherein: \n<claim-text>the plurality of counters is a portion of an instruction cache; and </claim-text><claim-text>the plurality of memory portions is another portion of the instruction cache. </claim-text></claim-text></claim>"}, {"num": 13, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00013\" num=\"13\"><claim-text><b>13</b>. The method of <claim-ref idref=\"US-20010049782-A1-CLM-00011\"><claim-text>claim 11</claim-text></claim-ref>, wherein the step of forming comprises the steps of: \n<claim-text>invoking a trace selector to form the trace when the one counter reaches a predetermined value; </claim-text><claim-text>beginning the trace with the instruction associated with the one counter; and </claim-text><claim-text>ending the trace with an instruction selected by a predetermined criteria. </claim-text></claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00014\" num=\"14\"><claim-text><b>14</b>. The method of <claim-ref idref=\"US-20010049782-A1-CLM-00013\"><claim-text>claim 13</claim-text></claim-ref>, wherein the predetermined value is zero, the step of detecting comprising the steps of: \n<claim-text>initializing each counter to a predetermined initialization value; and </claim-text><claim-text>decrementing the one counter each time its associated one instruction is executed. </claim-text></claim-text></claim>"}, {"num": 15, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00015\" num=\"15\"><claim-text><b>15</b>. The method of <claim-ref idref=\"US-20010049782-A1-CLM-00013\"><claim-text>claim 13</claim-text></claim-ref>, wherein the step of forming further comprising the step of: \n<claim-text>determining, via the trace selector, a branch prediction upon encountering a branch instruction, based upon the information in the memory portion of the history associated with the branch instruction. </claim-text></claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00016\" num=\"16\"><claim-text><b>16</b>. The method of <claim-ref idref=\"US-20010049782-A1-CLM-00015\"><claim-text>claim 15</claim-text></claim-ref>, wherein: \n<claim-text>the information describes whether the branch instruction has performed one of fallen through to the next sequential instruction and taken the branch to the target instruction, during a predetermined number of prior executions of the branch instruction. </claim-text></claim-text></claim>"}, {"num": 17, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00017\" num=\"17\"><claim-text><b>17</b>. The method of <claim-ref idref=\"US-20010049782-A1-CLM-00013\"><claim-text>claim 13</claim-text></claim-ref>, wherein: \n<claim-text>the predetermined criteria is an instruction that is a backward branch which forms a loop. </claim-text></claim-text></claim>"}, {"num": 18, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00018\" num=\"18\"><claim-text><b>18</b>. The method of <claim-ref idref=\"US-20010049782-A1-CLM-00013\"><claim-text>claim 13</claim-text></claim-ref>, wherein the predetermined criteria is selected from the group consisting of: \n<claim-text>a predetermined length of the trace, a predetermined number of conditional branch instructions within the trace, a predetermined probability of accumulated branch predictions of the trace, and an instruction that is an indirect branch. </claim-text></claim-text></claim>"}, {"num": 19, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00019\" num=\"19\"><claim-text><b>19</b>. A system for profiling instructions of a program and for selecting a trace of a portion of the instructions of the program, the system comprising: \n<claim-text>a plurality of hardware counters, located on an instruction cache, for detecting which instructions of the program are more frequently executed, with one counter associated with at least one instruction of the program, wherein a particular counter is changed each time its associated one instruction is executed; </claim-text><claim-text>a plurality of hardware memory portions, located on the instruction cache, for maintaining a history of targets chosen by branch instructions of the program, with one memory portion associated with each branch instruction of the program, wherein each memory portion maintains information on performance of the associated branch instruction, and the information is maintained for a predetermined number of times of execution of the associated branch instruction; and </claim-text><claim-text>a software trace selector that forms the trace the most frequently executed instructions and is invoked when the one counter reaches a predetermined value, wherein the trace selector uses the history in making branch predictions for branch instructions encountered in forming the trace. </claim-text></claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049782-A1-CLM-00020\" num=\"20\"><claim-text><b>20</b>. The system of <claim-ref idref=\"US-20010049782-A1-CLM-00019\"><claim-text>claim 19</claim-text></claim-ref>, wherein: \n<claim-text>the trace selector begins the trace with the instruction associated with the one counter and ends the trace with an instruction selected by a predetermined criteria; </claim-text><claim-text>the trace selector determines a branch prediction upon encountering a branch instruction, based upon the information in the memory portion of the history associated with the branch instruction; and </claim-text><claim-text>the information describes whether the branch instruction has performed one of fallen through to the next sequential instruction and taken the branch to the target instruction, during a predetermined number of prior executions of the branch instruction.</claim-text></claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54978396\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><summary-of-invention><h4>BACKGROUND OF THE INVENTION </h4><p id=\"P-0001\" num=\"0001\">[0001] A run-time optimizer is an adaptive software system that transparently optimizes applications at run-time. The optimizer rewrites the binary code of an application on-the-fly to achieve a higher execution efficiency. </p><p id=\"P-0002\" num=\"0002\">[0002]FIG. 3 depicts prior art run time optimizer <b>300</b>. The control loop <b>310</b> begins execution of a block of program code, via emulation performed by the profiling emulator <b>320</b>. The profiling aspect of emulator <b>320</b> allows the control loop <b>310</b> to track the number of time the particular block of code has been executed via emulation. Note that a run time optimization system is different from a run time binary translation system, in that the latter is for architecture migration, while the former is to decrease execution time. The run time optimization system is using the emulator <b>320</b> for profiling in order to guide optimizations, i.e. the code is running on its native system. After a predetermined number of executions via emulation, the control loop <b>310</b> designates the block of code as hot code, and desirable for optimization. The control loop <b>310</b> then activates trace selector <b>330</b> to translate the block of code. The trace selector <b>330</b> forms a trace of the instructions that comprise the block of code by following the instructions in the block. When a branch instruction is encountered, the trace selector makes a prediction as to whether the branch is taken or falls through. If the selector decides the branch is mostly taken, then the trace is formed by extending the code from the branch target block. If the selector decides not to take the branch, then the branch falls through, and the trace continues within the fall through block. The trace terminates at a backward branch predicted to take or when the trace becomes sufficiently large. After the trace is formed, the newly formed trace is optimized for the current processor. The optimized code is then placed into the code cache <b>340</b>. The next time the control loop <b>310</b> encounters a condition to execute this block of code, then the control loop <b>310</b> will execute the code in the code cache <b>340</b> and not emulate the code via emulator <b>320</b>. </p><p id=\"P-0003\" num=\"0003\">[0003] A problem with FIG. 3 is that an emulator is required to perform profiling, i.e. the emulated code is used to determine which code is hot. Emulation is very slow; usually 50-200 times slower than native execution speed. Consequently, there is a large time penalty for determining which code is hot. Moreover, the quality of optimization is often determined by the quality of the selected trace. Branch mis-prediction in trace construction is costly, for example predicting a branch not to be taken means the remainder of the block code is traced and optimized, and if mis-predicted then that tracing and optimizing of the code subsequent to the branch is wasted. Branch mis-prediction can be minimized by maintaining a long history of branching outcomes, which is formed by continually emulating the code block. Thus, the prior art run time optimization system (RTOS) either incurs a time penalty from emulation to build a good history, or incurs a time penalty from branch mis-prediction. </p><p id=\"P-0004\" num=\"0004\">[0004] Another problem with the prior art RTOS is that it attempts to translate any code that is deemed hot based on a small threshold. This problem is referred to as complex and less reliable. There are some traces that are difficult to translate, for example, it is difficult to translate a trace with a branch in the delay slot of another branch, but without a translation, the execution of the trace would be performed by software simulation or emulation. Since emulation is slow, all hot code is translated. The requirement of translating all hot code, including all the difficult traces, increases the translation time and complexity. With this software based approach, it is rather difficult to come up with an ideal threshold value. A higher threshold would incur too much overhead while a lower threshold would end up with traces in poor quality, i.e. too many traces, and traces with early exits. Note that emulation time overhead is such that a higher threshold would require the code to be emulated much longer before they get a chance to be translated. </p><p id=\"P-0005\" num=\"0005\">[0005] Consequently, it is difficult for the prior art RTOS to have long cache lines to hold traces. Long cache lines are desirable because the longer the cache line, the higher the cache hit rate. However, this is difficult for the prior art RTS because traces are either inaccurately formed or require a large amount of overhead for profiling. Moreover, the traces that are formed are not reliable because of branch mis-predictions. For example, if the overhead for software based profiling takes 5% of execution time, then the run-time optimization must gain at least 5% of performance in order to break even. </p><p id=\"P-0006\" num=\"0006\">[0006] The prior art RTOS has been described in terms of a pure software approach. However, another prior art approach of generating traces is in pure hardware form. However, this approach requires a great deal of complexity in the hardware to form the traces. Particularly, the hardware approach requires an additional cache for holding the trace, i.e. a trace cache. Refer to E. Rotenberg, S. Bennett, and J. E. Smith, \u201cTrace Cache: A Low Latency Approach to High-Bandwidth Instruction Fetch,\u201d Proc. Int'l Symp. MicroArchitcture, IEEE CS Press, Los Alamitos, Calif., 1996, which is incorporated by reference. </p><p id=\"P-0007\" num=\"0007\">[0007] Therefore, there is a need in the art for RTOS that does not require emulation for profiling, produces reliable traces, and uses hot code to form traces. </p><h4>SUMMARY OF THE INVENTION </h4><p id=\"P-0008\" num=\"0008\">[0008] These and other objects, features and technical advantages are achieved by a system and method which provides fast profiling and effective trace selection with some micro-architecture support. The instruction execution frequency and branch prediction information are collected at essentially no execution time cost. Therefore, the profiling and trace selection can have a much higher threshold and will select traces with a higher quality. </p><p id=\"P-0009\" num=\"0009\">[0009] The inventive mechanism partitions the work between hardware and software. The hardware automatically detects which code is executed very frequently, e.g. which code is hot code. Hardware is better suited to this task than software, because software would require more overhead in making the determination, while hardware incurs essentially zero overhead. Moreover, since hardware executes the branch instructions, the hardware also keeps the branch history information to do branch prediction. When the hardware determines that a section or block of code is hot, e.g. hot code, the hardware sends a signal to the software, which is maintained in firmware. This signal informs the software and lets the software decide which trace to select. Because the trace latching is done by the software, it has more freedom and can handle more complex cases. Furthermore, the software may add some optimizations to hot code, and has the capability to form longer traces and better traces. Software is better suited for these tasks than hardware, because the software has more flexibility, less implementation complexity and is less expensive than hardware. </p><p id=\"P-0010\" num=\"0010\">[0010] Therefore, it is a technical advantage of the present invention to have a hardware processor identify frequently used code and use software embedded in firmware predict and select traces from the frequently used code. </p><p id=\"P-0011\" num=\"0011\">[0011] It is another technical advantage of the present invention to use the hardware for frequently used code identification and profiling, as hardware requires less overhead in making the determinations than software. </p><p id=\"P-0012\" num=\"0012\">[0012] It is a further technical advantage of the present invention to use the software for trace prediction and selection, as software has more flexibility, less complexity and is less expensive than hardware. </p><p id=\"P-0013\" num=\"0013\">[0013] It is a still further technical advantage of the present invention to use the instruction cache to maintain counters and branch information for the instructions stored in the instruction cache. </p><p id=\"P-0014\" num=\"0014\">[0014] It is a still further technical advantage of the present invention to have the trace prediction and selection software be triggered by the counters in the instruction cache. </p><p id=\"P-0015\" num=\"0015\">[0015] It is a still further technical advantage of the present invention to have the trace prediction and selection software make branch predictions based upon the branch history information. </p><p id=\"P-0016\" num=\"0016\">[0016] It is a still further technical advantage of the present invention to have the trace prediction and selection software store the trace in trace memory. </p><p id=\"P-0017\" num=\"0017\">[0017] The foregoing has outlined rather broadly the features and technical advantages of the present invention in order that the detailed description of the invention that follows may be better understood. Additional features and advantages of the invention will be described hereinafter which form the subject of the claims of the invention. It should be appreciated by those skilled in the art that the conception and the specific embodiment disclosed may be readily utilized as a basis for modifing or designing other structures for carrying out the same purposes of the present invention. It should also be realized by those skilled in the art that such equivalent constructions do not depart from the spirit and scope of the invention as set forth in the appended claims. </p></summary-of-invention><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS </h4><p id=\"P-0018\" num=\"0018\">[0018] For a more complete understanding of the present invention, and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which: </p><p id=\"P-0019\" num=\"0019\">[0019] FIGS. <b>1</b>A-<b>1</b>C depict the inventive instruction cache which includes instruction bundles and their associated counter and branch history information; </p><p id=\"P-0020\" num=\"0020\">[0020]FIGS. 2A and 2B depict the inventive trace selection mechanism, which selects the trace from the instruction cache of FIG. 1A, according to the branch history information of FIG. 1C; and </p><p id=\"P-0021\" num=\"0021\">[0021]FIG. 3 depicts a prior art software emulation run time system. </p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE INVENTION </h4><p id=\"P-0022\" num=\"0022\">[0022]FIG. 1A depicts the inventive instruction cache (Icache) <b>100</b> of a processor, and includes long cache lines <b>101</b>, <b>102</b>, <b>103</b>, and <b>104</b>. Only four lines are depicted for simplicity, Icache <b>100</b> size is implementation dependent. Each cache line includes a tag <b>105</b>, which is used to tell a cache hit or miss, a plurality of instruction bundles <b>106</b>, and counter/branch information <b>107</b>. FIG. 1B depicts the contents of instruction bundles <b>106</b>. Each bundle is comprised of a group of instructions <b>108</b> that can be issued in the same cycle, for example, bundle <b>0</b> includes a load instruction, an add instruction, and a compare-branch instruction. Note that each bundle has a fixed number of instructions, however, some of the instructions may be NOPs. </p><p id=\"P-0023\" num=\"0023\">[0023]FIG. 1C depicts the counter/branch information associated with each instruction bundle. Each instruction bundle has counter information <b>109</b>, which is used to determine whether the code within the bundle is hot code. When the bundle is brought into the Icache, the counter is initialized to a threshold value. Depending on the threshold value desired, the counter can be as small as 8 to 10 bits. The counter is updated when the instruction bundle is retired from the execution pipeline. Each update decrements the counter by 1. Note that the counter could initially be set to zero and increment with each retirement. However, this would require a comparison with a non-zero threshold number, e.g. 100, which requires more work than comparing with a zero threshold number. </p><p id=\"P-0024\" num=\"0024\">[0024] Each instruction bundle <b>106</b> in the Icache <b>100</b> also maintains a branch history <b>110</b>, <b>111</b> for each instruction within the bundle. This history describes whether the comparisons in the branch instructions have resulted in a fall through to the next instruction or a branch taken to another instruction. Branch history <b>110</b> is associated with bundle <b>0</b>, including slots a, b, c, which correspond to the instructions within the bundle <b>0</b>. Thus, it appears one slot in the history is allocated for each instruction in the bundle, whether the instruction is a branch instruction or not. When the instructions from the original binary are brought into the Icache, the branch history is cleared. The branch history information is updated when the instruction bundle is retired from the pipeline. Note that the number of instructions (and thus the number of slots) is by way of example only, as each bundle could have more or fewer instructions. Since the third instruction in bundle <b>0</b> is a branch instruction, then slot <b>110</b><i>c </i>has branch information. Binary zeros indicate a fall through, and binary ones indicate a branch taken. Thus, the information in <b>110</b><i>c</i>, i.e. 00100, indicates that of the last five times that this instruction has been executed, that the instruction BR<b>1</b> has fallen through, fallen through, been taken, fallen through, and fallen through. Note that the number of bits in the history is by way of example only, and more bits could be used to provide a more detailed history (while requiring more space), while fewer bits could be used to save space (while providing less history). Note that either the most significant bit or the last significant bit may represent the most urgent execution instruction. Similarly, the information in <b>111</b><i>b </i>and <b>111</b><i>c </i>describe the histories of instruction BR<b>2</b> and BR<b>3</b> respectively. Note that BR<b>2</b> has not recently branched, whereas the previous four executions of BR<b>3</b> have resulted in the branch taken. </p><p id=\"P-0025\" num=\"0025\">[0025] In operation, once the counter of a bundle reaches zero, a software component known as the trace selector <b>201</b> is invoked, via a special trap, to select a trace. Diagnose instructions (special instructions to diagnose hardware) are used by the trace selector to examine the Icache and the branch history information to form a trace. Regular instructions cannot read I-cache contents since I-cache is not part of the architecture states. Each processor has a set of diagnose instructions defined (not visible to application programmer) which can be used to examine I-cache contents. </p><p id=\"P-0026\" num=\"0026\">[0026]FIGS. 2A and 2B depict trace formation. FIG. 2A depicts instruction bundles <b>106</b> and their associated branch information <b>11110</b>. Assume that the counter of bundle <b>1</b> (not shown) has reached zero, and that bundles <b>5</b>-<b>9</b> and <b>14</b>-<b>99</b> are not shown for reason of simplicity. Note that bundles <b>1</b>-<b>101</b> may be in one or more cache lines of Icache <b>100</b>. The trace selector <b>201</b> begins building the trace <b>202</b> from the hot code, in this case bundle <b>1</b>. The trace selector <b>201</b> examines the branch information (if any) in bundle <b>1</b> to predict whether the branch will be taken or fall through. If there are no branch instructions in the bundle, then bundle will fall through to the next sequential bundle. If the trace selector determines that the branch is most likely to fall through, then the next sequential bundle is added to the trace <b>202</b>, in this case it would be bundle <b>2</b>. Note that if a branch instruction that is in the middle of bundle is assumed to be taken, the remaining instructions of the bundle are not included in the trace. The trace <b>202</b> is stored in the trace memory <b>203</b>. If the trace selector determines that the branch is most likely to be taken, then the target bundle of the branch is added to the trace <b>202</b>, in this case it would be bundle <b>30</b>. After examining the branch history <b>112</b>, the trace selector <b>201</b> will note that in the previous five executions of the branch instruction, the branch has not been taken and has fallen through. Therefore, the trace selector will predict that the branch to bundle <b>30</b> will not be taken, and will add the next sequential bundle, bundle <b>2</b>, to the trace <b>202</b>, and then will examine bundle <b>2</b>. </p><p id=\"P-0027\" num=\"0027\">[0027] After examining the branch history <b>113</b> of bundle <b>2</b>, the trace selector <b>201</b> will note that in the previous five executions of the branch instruction, the branch has been taken four times and fallen through once. Therefore, the trace selector will predict that the branch to bundle <b>10</b> will be taken, and will add the target bundle, bundle <b>10</b>, to the trace <b>202</b>, and then will examine bundle <b>10</b>. After examining the branch history <b>114</b> of bundle <b>10</b>, the trace selector <b>201</b> will note that in the previous five executions of the branch instruction, the branch has not been taken and has fallen through. Therefore, the trace selector will predict that the branch to bundle <b>20</b> will not be taken, and will add the next sequential bundle, bundle <b>11</b>, to the trace <b>202</b>, and then will examine bundle <b>11</b>. Bundle <b>11</b> does not contain any branch instructions, and therefore will not have a branch history, thus the trace selector <b>201</b> will add the next sequential bundle, bundle <b>12</b>, to the trace <b>202</b>, and then will examine bundle <b>12</b>. After examining the branch history <b>115</b> of bundle <b>12</b>, the trace selector <b>201</b> will note that in the previous five executions of the branch instruction, the branch has not been taken and has fallen through. Therefore, the trace selector will predict that the branch to bundle <b>24</b> will not be taken, and will add the next sequential bundle, bundle <b>13</b>, to the trace <b>202</b>, and then will examine bundle <b>13</b>. After examining the branch history <b>116</b> of bundle <b>13</b>, the trace selector <b>201</b> will note that in the previous five executions of the branch instruction, the branch has been taken four times and fallen through once. Therefore, the trace selector will predict that the branch to bundle <b>101</b> will be taken, and will add the target bundle, bundle <b>101</b>, to the trace <b>202</b>, and then will examine bundle <b>101</b>. After examining the branch history <b>117</b> of bundle <b>101</b>, the trace selector <b>201</b> will note that in the previous five executions of the branch instruction, the branch has been taken five times. Therefore, the trace selector will predict that the branch to bundle <b>1</b> will be taken. The trace selector notes that bundle <b>1</b> is already part of the trace <b>202</b> in trace memory <b>203</b>, via the trace of a sequence of bundles, by examining the address of a backward branch, it can be detected whether the target bundle is already part of a trace. The trace selector then ends the trace or passes the formed trace to the optimizer. </p><p id=\"P-0028\" num=\"0028\">[0028] The branch to bundle <b>1</b> from bundle <b>101</b> is known as a backward branch, which forms a loop. At this point, the trace may be stopped, as the trace would merely repeat bundles that are already present in the trace. The trace selector may also end the trace based on other criteria from a set of heuristics including the length of the trace, the number of conditional branches encountered, the probability of accumulated branch predictions and other considerations. Thus, a trace may end when its length is a multiple of a cache line size. This would make cache operations easier, as the entire line could be loaded or overwritten without having to be concerned about starting and stopping points in the middle of a cache line. The trace could also end after a certain, predetermined number of conditional branches has been encountered. Note that branch histories <b>113</b> and <b>116</b> do indicate that branch falls through occasionally, and thus the trace would be inaccurate as the trace predicts that the branch will be taken. The predetermined number could be based on the probability of error of the trace. For example, the predetermined number would be low if many of the branches have histories of 00011 or 00111. On the other hand, the predetermined number would be high if many of the branches have histories of 00000 or 11111. Note that a trace may terminate at an indirect branch since the target address is not known. An indirect branch is different from an IP-relative (or PC-relative) branch in that the branch target address cannot be computed directly from the branch instruction. Its target is stored either in a register or in a memory location. So the target address is unknown unless the instruction is actually executed. For example, </p><p id=\"P-0029\" num=\"0029\">[0029] Branch on reg<b>1</b>; branch on mem_loc<b>1</b>. </p><p id=\"P-0030\" num=\"0030\">[0030] However, the trace selector may decide to grow the trace by predicting its most recent target from the Target Address Cache (TAC), which is a structure commonly used to predict branch target address. For a return branch which is an indirect branch, with its target being dependent on the call site, the trace selector would know the return address if the call instruction is in the trace, if the call instruction is not in the trace, the trace selector can predict the call site using the top address of the Return Stack Buffer (RSB), which is a commonly used data structure to predict return branches. The TAC and the RSB are discussed in the co-pending and commonly assigned U.S. Patent Application entitled EFFICIENT MAPPING TO OPTIMIZED CODE FOR PROCESSOR EMBEDDED RUN-TIME OPTIMIZER [HP No. 10981004-1][19471-P042US-984710] which is hereby incorporated by reference. </p><p id=\"P-0031\" num=\"0031\">[0031] The trace <b>202</b> will be stored in the trace memory <b>203</b>. There is a mapping from the trace starting instruction bundle in the original binary to the trace in the trace memory. When the trace starting bundle is executed, the mapping will automatically lead the execution to the trace stored in the trace memory <b>203</b>. Typically, an executed branch instruction has its target in the trace memory. This is discussed in the co-pending and commonly assigned U.S. Patent Application entitled SYSTEM AND METHOD USING A HARDWARE EMBEDDED RUN-TIME OPTIMIZER (HP No.10980951-1][19471-P044US-984712], which is hereby incorporated by reference. Note that the trace may require more than one cache line. As stated previously, long cache lines are inefficient for original binary. This is because the original binary is loaded sequentially, i.e. bundle <b>1</b>, <b>2</b>, <b>3</b>, <b>4</b>, <b>5</b>, <b>6</b>, etc., and branches taken within the bundles may result in many of the loaded bundles not being used. For example, suppose bundle <b>6</b> has a branch taken to bundle <b>50</b>, then the loading of bundles <b>7</b>-<b>49</b> represent wasted time and cache space as they are not going to be used. However, when the trace is loaded into the cache, the entire trace is almost certain to be used. Thus, the long cache lines are much more efficient, because of the sequential locality, as the bundles of the trace will (almost always) fall through to the next bundle of the trace. Note that a trace usually spans several cache lines. It may not end at the end of a cache line. In this case, the remaining part of the cache line can be the start of another trace. </p><p id=\"P-0032\" num=\"0032\">[0032] Note that since traces are also brought into the Icache, the profiling and trace selection may end up generating a trace on top of an existing trace. Traces can be identified since their addresses are preserved addresses in physical memory. If their participation in subsequent trace selection is not desired, then when the trace is moved into the Icache, the counters associated with the trace will not be initialized to the threshold value, and instead are set to a null value. Thus, the trace will not participate in profiling. However, subsequent profiling and trace selection could be used to determine whether the trace is considered \u201cgood.\u201d For example, if a trace has frequent early exits, then the trace may need to be regenerated. </p><p id=\"P-0033\" num=\"0033\">[0033] Note that more bits of branch history will allow for more accurate predictions to be made by the trace selector. However, this will require more cache space. Alternatively, a multi-tiered system may be used such that the trace selector would not to select a trace when a bundle traps for the first time. Instead, the trace selector may record the branch history information of the bundle in another location of memory, and then set the threshold back to a second value, which could be smaller, larger or the same as the original threshold value, and return to execution. When this bundle traps again, the trace selector can accumulate the current branch history with the branch history from the first trap to make more accurate branch predictions. </p><p id=\"P-0034\" num=\"0034\">[0034] Although the present invention and its advantages have been described in detail, it should be understood that various changes, substitutions and alterations can be made herein without departing from the spirit and scope of the invention as defined by the appended claims. </p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "WEI C", "last_name": "HSU", "name": ""}, {"first_name": "Manuel", "last_name": "Benitez", "name": ""}], "assignees": [{"first_name": "", "last_name": "HEWLETT-PACKARD COMPANY", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   7/38"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   7/38        20060101A I20051110RMEP"}, {"label": "G06F   9/00        20060101A I20051110RMEP"}, {"label": "G06F  15/00        20060101A I20051110RMEP"}, {"label": "G06F   9/38        20060101A I20070721RMEP"}], "national_classes": [{"primary": true, "label": "712237"}, {"primary": false, "label": "712E09051"}], "ecla_classes": [{"label": "G06F   9/38B4"}, {"label": "G06F   9/38E2D"}], "cpc_classes": [{"label": "G06F   9/3808"}, {"label": "G06F   9/3808"}, {"label": "G06F   9/3844"}, {"label": "G06F   9/3844"}], "f_term_classes": [], "legal_status": "Granted", "priority_date": "1999-02-18", "application_date": "1999-02-18", "family_members": [{"ucid": "US-20010049782-A1", "titles": [{"lang": "EN", "text": "HARDWARE/SOFTWARE SYSTEM FOR INSTRUCTION PROFILING AND TRACE SELECTION USING BRANCH HISTORY INFORMATION FOR BRANCH PREDICTIONS"}]}, {"ucid": "US-6418530-B2", "titles": [{"lang": "EN", "text": "Hardware/software system for instruction profiling and trace selection using branch history information for branch predictions"}]}, {"ucid": "US-6647491-B2", "titles": [{"lang": "EN", "text": "Hardware/software system for profiling instructions and selecting a trace using branch history information for branch predictions"}]}, {"ucid": "US-20020019930-A1", "titles": [{"lang": "EN", "text": "Fast instruction profiling and effective trace selection"}]}]}