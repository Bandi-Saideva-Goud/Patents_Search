{"patent_number": "US-6205555-B1", "publication_id": 72604274, "family_id": 12380807, "publication_date": "2001-03-20", "titles": [{"lang": "EN", "text": "Processor power consumption estimating system, processor power consumption estimating method, and storage medium storing program for executing the processor power consumption estimating method"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72527339\"><p>The present invention provides a processor power consumption estimating method comprising the steps of receiving a source program prior to compile of an execution program for a processor, tracing the source program, receiving trace information and detecting whether or not the processor is stalled when the instructions are executed, receiving trace information to which stall information is added and estimating power consumption when the instructions are executed, and outputting an estimated result of the power consumption, wherein the stall information are detected by looking up operation information of the processor in the stall detecting step, and the power consumption in the processor is estimated by looking up a library in which power consumption for each instruction is collected with regard to the stall information in the estimating step. The present invention provides also a power consumption estimating system for executing this processor power consumption estimating method, and a storage medium storing a program to perform this this processor power consumption estimating method.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00001\" num=\"1\"><claim-text>1. A power consumption estimating system for estimating power consumption in a processor when instructions contained in an execution program are executed, comprising:</claim-text><claim-text>(a) means for tracing a source program of the execution program; </claim-text><claim-text>(b) means for receiving trace information and detecting whether or not the processor is put into a stall when the instructions are executed; and </claim-text><claim-text>(c) means for receiving trace information to which stall information is added and estimating power consumption when the instructions are executed; </claim-text><claim-text>wherein the detecting means detects the stall information by looking up operation information of the processor, and </claim-text><claim-text>the estimating means estimates the power consumption in the processor by looking up a library in which power consumption for each instruction is collected with regard to the stall information. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00002\" num=\"2\"><claim-text>2. A power consumption estimating system for estimating power consumption in a processor, according to claim <b>1</b>, further comprising:</claim-text><claim-text>means for receiving the source program; and </claim-text><claim-text>means for outputting an estimated result of the power consumption. </claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00003\" num=\"3\"><claim-text>3. A power consumption estimating system for estimating power consumption in a processor, according to claim <b>2</b>, wherein the processor includes</claim-text><claim-text>a core for executing the instructions, </claim-text><claim-text>a memory for storing the instructions, </claim-text><claim-text>an instruction cache for storing a part of the instructions, and </claim-text><claim-text>a data cache for storing a part of data employed in the instructions. </claim-text></claim>"}, {"num": 4, "parent": 3, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00004\" num=\"4\"><claim-text>4. A power consumption estimating system for estimating power consumption in a processor, according to claim <b>3</b>, wherein the stall information includes</claim-text><claim-text>information for indicating which one of the memory and the instruction cache the instructions are stored in, and </claim-text><claim-text>information for indicating which one of the memory and the data cache the data employed in instruction execution are stored in. </claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00005\" num=\"5\"><claim-text>5. A power consumption estimating system for estimating power consumption in a processor, according to claim <b>1</b>, further comprising:</claim-text><claim-text>means for searching data cache information of the data employed when the instructions are executed; </claim-text><claim-text>wherein the data cache information contain information indicating the data which cause data cache miss and a number of the data. </claim-text></claim>"}, {"num": 6, "parent": 5, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00006\" num=\"6\"><claim-text>6. A power consumption estimating system for estimating power consumption in a processor, according to claim <b>5</b>, wherein the data cache information searching means includes</claim-text><claim-text>means for receiving the source program, </claim-text><claim-text>means for tracing the source program, </claim-text><claim-text>means for receiving the trace information and detecting the data cache information when the instructions are executed, and </claim-text><claim-text>means for outputting the data cache information, </claim-text><claim-text>wherein the data cache information detecting means has a data cache information library, and </claim-text><claim-text>the data cache information library contains information of a total number of the data which are looked up by the instructions, types of the data to be looked up, timings for looking up the data, and sequences and types of the data stored in the data cache after the instructions have been executed. </claim-text></claim>"}, {"num": 7, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00007\" num=\"7\"><claim-text>7. A power consumption estimating system for estimating power consumption in a processor when instructions contained in an execution program are executed, comprising:</claim-text><claim-text>(a) means for statically expanding a source program of the execution program; and </claim-text><claim-text>(b) means for receiving the source program which has been expanded statically and estimating power consumption when the instructions are executed; </claim-text><claim-text>wherein the statically expanding means has information necessary for expansion of the source program and expands the source program based on expansion information, and </claim-text><claim-text>the estimating means estimates the power consumption in the processor with reference to a library in which the power consumption for each instruction is collected with regard to information indicating whether or not the processor is put into a stall when the instructions are executed. </claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00008\" num=\"8\"><claim-text>8. A power consumption estimating system for estimating power consumption in a processor, according to claim <b>7</b>, wherein the expansion information includes information indicating branch probabilities, jump probabilities, and loop number of times of the instructions.</claim-text></claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00009\" num=\"9\"><claim-text>9. A power consumption estimating system for estimating power consumption in a processor, according to claim <b>7</b>, further comprising:</claim-text><claim-text>means for receiving the source program; and </claim-text><claim-text>means for outputting an estimated result of the power consumption. </claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00010\" num=\"10\"><claim-text>10. A power consumption estimating system for estimating power consumption in a processor, according to claim <b>9</b>, wherein the processor includes</claim-text><claim-text>a core for executing the instructions, </claim-text><claim-text>a memory for storing the instructions, </claim-text><claim-text>an instruction cache for storing a part of the instructions, and </claim-text><claim-text>a data cache for storing a part of data employed in the instructions. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00011\" num=\"11\"><claim-text>11. A power consumption estimating system for estimating power consumption in a processor, according to claim <b>10</b>, wherein the stall information includes</claim-text><claim-text>information for indicating which one of the memory and the instruction cache the instructions are stored in, and </claim-text><claim-text>information for indicating which one of the memory and the data cache the data employed in instruction execution are stored in. </claim-text></claim>"}, {"num": 12, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00012\" num=\"12\"><claim-text>12. A power consumption estimating system for estimating power consumption in a processor, according to claim <b>7</b>, further comprising:</claim-text><claim-text>means for searching data cache information of the data employed when the instructions are executed; </claim-text><claim-text>wherein the data cache information contain information indicating the data which cause data cache miss and a number of the data. </claim-text></claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00013\" num=\"13\"><claim-text>13. A power consumption estimating system for estimating power consumption in a processor, according to claim <b>12</b>, wherein the data cache information searching means includes</claim-text><claim-text>means for receiving the source program, </claim-text><claim-text>means for tracing the source program, </claim-text><claim-text>means for receiving the trace information and detecting the data cache information when the instructions are executed, and </claim-text><claim-text>means for outputting the data cache information, </claim-text><claim-text>wherein the data cache information detecting means has a data cache information library, and </claim-text><claim-text>the data cache information library contains information of a total number of the data which are looked up by the instructions, types of the data to be looked up, timings for looking up the data, and sequences and types of the data stored in the data cache after the instructions have been executed. </claim-text></claim>"}, {"num": 14, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00014\" num=\"14\"><claim-text>14. A power consumption estimating method of estimating power consumption in a processor when instructions contained in an execution program are executed, comprising the steps of:</claim-text><claim-text>(a) receiving a source program of the execution program; </claim-text><claim-text>(b) tracing the source program; </claim-text><claim-text>(c) receiving trace information and detecting whether or not the processor is put into a stall when the instructions are executed; </claim-text><claim-text>(d) receiving trace information to which stall information is added and estimating power consumption when the instructions are executed; and </claim-text><claim-text>(e) outputting an estimated result of the power consumption; </claim-text><claim-text>wherein the stall information are detected by looking up operation information of the processor in the detecting step, and </claim-text><claim-text>the power consumption in the processor is estimated by looking up a library, in which power consumption for each instruction is collected with regard to the stall information, in the estimating step. </claim-text></claim>"}, {"num": 15, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6205555-B1-CLM-00015\" num=\"15\"><claim-text>15. A storage medium storing a power consumption estimating program which estimates power consumption in a processor when instructions contained in an execution program are executed, the program comprising the steps of:</claim-text><claim-text>(a) receiving a source program of the execution program; </claim-text><claim-text>(b) tracing the source program; </claim-text><claim-text>(c) receiving trace information and detecting whether or not the processor is put into a stall when the instructions are executed; </claim-text><claim-text>(d) receiving trace information to which stall information is added and estimating power consumption when the instructions are executed; and </claim-text><claim-text>(e) outputting an estimated result of the power consumption; </claim-text><claim-text>wherein the stall information are detected by looking up operation information of the processor in the detecting step, and </claim-text><claim-text>the power consumption in the processor is estimated by looking up a library, in which power consumption for each instruction is collected with regard to the stall information, in the estimating step.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54513325\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates to a processor power consumption estimating system, a processor power consumption estimating method, and a storage medium from which a processor power consumption estimating program can be read out. More particularly, the present invention relates to a power consumption estimating technology for estimating power consumption in a microprocessor with good precision based on a source program which is described by a programmer.</p><p>2. Description of the Related Art</p><p>In order to select type of a package into which a processor is incorporated and a battery capacity employed in the processor, power consumption is taken account when instructions are executed. As a means for evaluating power consumption in the processor, there is a system in which, after a processor is assumed virtually, the power consumption is calculated by simulating operations of the processor when an execution program is carried out by the processor. FIG. 1 is a block diagram showing a configuration of a simulation system. First, this simulation system receives a source program sequence <b>1</b> described by a programmer. This source program is a program which is at a function level and described by a source code. The source code is a program prior to compile. More particularly, the source code is described by a higher level language such as C language, Pascal, etc. and can be read by the human being. The source program sequence <b>1</b> is converted into an assembly code <b>3</b> by a compiler <b>2</b>. The assembly code <b>3</b> is converted into an input signal <b>5</b>, which is operated on the processor at a gate/transistor level, by a gate/transistor level converter <b>4</b>. A gate/transistor level simulator <b>6</b> can estimate the power consumption <b>7</b>A with high precision by executing a simulation at the gate/transistor level by using the gate/transistor level input signal <b>5</b>.</p><p>In this manner, in the above simulation system, the source program <b>1</b>, which is described by the programmer at the function level, is converted into the input signal <b>5</b> which is operated on the actual processor at the gate/transistor level. The power consumption is then calculated by simulating the actual operation in the processor at the gate/transistor level by using the gate/transistor level input signal <b>5</b>. Therefore, estimation precision of the power consumption by using the above simulation system can be improved extremely high. For this reason, it is feasible to estimate the power consumption in the processor by applying the already-described program to this simulation system. However, since an execution speed of the simulation system is slow, it is not practical to employ the simulation system in the course of programming.</p><p>As a method of avoiding the problem that the execution speed of the above simulation system is slow, an estimation system which can estimate the power consumption directly from the assembly code has been proposed. This estimation system can compile the source program described by the programmer to the assembly code, and then estimate the power consumption with the use of the assembly code. Since the power consumption can be estimated from the assembly code without simulation of the operation in the processor, the higher execution speed can be achieved. Accordingly, it is possible to estimate quickly the power consumption of the processor with high precision by using the estimation system at the early stage of program design. As a result, in case a plurality of programs each having the same function are described and then the power consumption of the processor is compared with each other when the programs are executed, this estimation system is very effective. However, since the function level being programmed by the programmer and the assembly level do not always correspond to each other one by one, it is difficult for the programmer to correct the source program directly in the middle of programming, based on the estimated result of the power consumption being derived from the assembly code.</p><h4>SUMMARY OF THE INVENTION</h4><p>The present invention has been made in view of the above circumstances and it is an object of the present invention to provide a processor power consumption estimating system which is capable of estimating power consumption in a microprocessor directly based on a source program which is described by a programmer, a processor power consumption estimating method, and a storage medium capable of mechanical read-out that stores a processor power consumption estimating program.</p><p>In order to achieve the above object, according to a first aspect of the present invention, there is provided a power consumption estimating system for estimating power consumption in a processor when instructions contained in an execution program are executed, comprising means for tracing a source program of the execution program; means for receiving trace information and detecting whether or not the processor is put into a stall when the instructions are executed; and means for receiving trace information to which stall information is added and estimating power consumption when the instructions are executed; wherein the detecting means detects the stall information by looking up operation information of the processor, and the estimating means estimates the power consumption in the processor by looking up a library in which power consumption for each instruction is collected with regard to the stall information.</p><p>In the first aspect of the present invention, the power consumption for each instruction is calculated previously with regard to the stall information and stored as a library, and then the power consumption for each instruction can be detected by referring to the library based on the trace information to which the stall information are added. The power consumption of the processor can be estimated precisely and quickly by summing up the power consumption for each instruction when the instructions contained in the execution program are executed. Then, this estimated result can be fed back quickly to the programmer who programs the source program. Since the power consumption can be estimated from the source program prior to compile, it is possible for the programmer to execute the programming with regard to the estimated result. As a result, the lower power consumption of the processor can be achieved.</p><p>According to a second aspect of the present invention, there is provided a power consumption estimating system for estimating power consumption in a processor when instructions contained in an execution program are executed, comprising means for statically expanding a source program of the execution program; and means for receiving the source program which has been expanded statically and estimating power consumption when the instructions are executed; wherein the statically expanding means has information necessary for expansion of the source program and expands the source program based on expansion information, and the estimating means estimates the power consumption in the processor with reference to a library in which the power consumption for each instruction is collected with regard to information indicating whether or not the processor is put into a stall when the instructions are executed.</p><p>In the second aspect of the present invention, information necessary for the expansion of the source program can be provided previously to the statically expanding means. Accordingly, it is feasible to expand the source program without the actual simulation. In addition, the power consumption for the unfinished source program can be estimated.</p><p>According to a third aspect of the present invention, there is provided a power consumption estimating method of estimating power consumption in a processor when instructions contained in an execution program are executed, comprising the steps of receiving a source program of the execution program; tracing the source program; receiving trace information and detecting whether or not the processor is put into a stall when the instructions are executed; receiving trace information to which stall information is added and estimating power consumption when the instructions are executed; and outputting an estimated result of the power consumption; wherein the stall information are detected by looking up operation information of the processor in the detecting step, and the power consumption in the processor is estimated by looking up a library in which power consumption for each instruction is collected with regard to the stall information in the estimating step.</p><p>According to a fourth aspect of the present invention, there is provided a storage medium for storing a power consumption estimating program which estimates power consumption in a processor when instructions contained in an execution program are executed, the program comprising the steps of receiving a source program of the execution program; tracing the source program; receiving trace information and detecting whether or not the processor is put into a stall when the instructions are executed; receiving trace information to which stall information is added and estimating power consumption when the instructions are executed; and outputting an estimated result of the power consumption; wherein the stall information are detected by looking up operation information of the processor in the detecting step, and the power consumption in the processor is estimated by looking up a library in which power consumption for each instruction is collected with regard to the stall information in the estimating step.</p><p>Other and further objects and features of the present invention will become obvious upon an understanding of the illustrative embodiments about to be described in connection with the accompanying drawings or will be indicated in the appended claims, and various advantages not referred to herein will occur to one skilled in the art upon employing of the invention in practice.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 is a block diagram showing a configuration of a simulation system which estimates power consumption in a processor;</p><p>FIG. 2 is a block diagram showing a configuration of a processor power consumption estimating system according to a first embodiment of the present invention;</p><p>FIG. 3 is a block diagram showing a configuration of a processor whose power consumption is estimated in the first embodiment of the present invention;</p><p>FIG. 4 is a view illustrating options of a compiler employed in the first embodiment of the present invention;</p><p>FIG. 5 is a view illustrating a correspondence between a source code and assembly codes if different compilers are employed;</p><p>FIG. 6 is a view showing an example in which the execution order of instructions of the source code is changed if different compilers are employed;</p><p>FIG. 7 is a view showing an instruction sequence of a source program employed in the first embodiment of the present invention;</p><p>FIG. 8 is a view showing trace information for the source program in FIG. 7;</p><p>FIG. 9 is a view showing the trace information in FIG. 8 to which stall information are added;</p><p>FIG. 10 is a block diagram showing a configuration of a processor power consumption estimating system which is employed when a power consumption library for one equation/one function employed in the first embodiment of the present invention is constructed;</p><p>FIG. 11 is a view showing an example of the power consumption library for one equation/one function employed in the first embodiment of the present invention;</p><p>FIG. 12 is a view showing the power consumption library for one equation/one function with respect to equations and functions contained in the source program sequence in FIG. 7, which is calculated by the processor power consumption estimating system in FIG. 10;</p><p>FIG. 13 is a view showing estimated results of the processor power consumption derived from the source program sequence in FIG. 7 by using the power consumption library for one equation/one function in FIG. 12;</p><p>FIGS. 14A, <b>14</b>B and <b>14</b>C are flowcharts showing process procedures in a stall information detecting algorithm employed in the first embodiment of the present invention;</p><p>FIG. 15 is a view showing a maximum/minimum power consumption library for one equation/one function with respect to the equations and the functions contained in the source program sequence in FIG. 7, which is calculated by the processor power consumption estimating system in FIG. 10;</p><p>FIG. 16 is a view showing estimated results of the processor power consumption derived from the source program sequence in FIG. 7 by using the maximum/minimum power consumption library for one equation/one function in FIG. 15;</p><p>FIG. 17 is a block diagram showing a configuration of a processor power consumption estimating system according to a second embodiment of the present invention;</p><p>FIG. 18 is a block diagram showing a configuration of a data cache information detecting system provided in a processor power consumption estimating system according to a third embodiment of the present invention;</p><p>FIG. 19 is a view showing instruction sequence of the source program employed in a data cache information detecting system according to the third embodiment of the present invention;</p><p>FIG. 20 is a view showing instruction execution order in FIG. 19;</p><p>FIG. 21 is a flowchart showing process procedures in a data cache information detecting algorithm employed in the third embodiment of the present invention;</p><p>FIG. 22 is a view showing change in internal states of the data cache when the instruction sequence in FIG. 19 is executed in the execution order in FIG. 20;</p><p>FIG. 23 is a view showing another instruction execution order in FIG. 19;</p><p>FIG. 24 is a view showing change in internal states of the data cache when the instruction sequence in FIG. 19 is executed in the execution order in FIG. 23;</p><p>FIG. 25 is a view showing a first example of an estimated result of the power consumption displayed by using GUI;</p><p>FIG. 26 is a view showing a second example of the estimated result of the power consumption displayed by using GUI;</p><p>FIG. 27 is a view showing a third example of the estimated result of the power consumption displayed by using GUI;</p><p>FIG. 28 is a view showing a fourth example of the estimated result of the power consumption displayed by using GUI;</p><p>FIG. 29 is a view showing a first example of data cache miss information displayed by using GUI; and</p><p>FIG. 30 is a view showing a second example of the data cache miss information displayed by using GUI.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DESCRIPTION OF THE PREFERRED EMBODIMENTS</h4><p>Various embodiments of the present invention will be described with reference to the accompanying drawings. It is to be noted that the same or similar reference numerals are applied to the same or similar parts and elements throughout the drawings, and the description of the same or similar parts and elements will be omitted or simplified.</p><h4>(First Embodiment)</h4><p>FIG. 2 is a block diagram showing a configuration of a processor power consumption estimating system according to a first embodiment of the present invention. The processor power consumption estimating system according to the first embodiment of the present invention comprises a tracer <b>8</b>B for receiving a source program sequence <b>1</b> at a function level and generating trace information <b>9</b>B of the source program sequence <b>1</b>, a stall information detector <b>10</b>B for receiving the trace information <b>9</b>B and detecting stall information <b>12</b>B of the execution program by using operation information <b>11</b> of the microprocessor, and an estimation portion <b>13</b>B for estimating the power consumption <b>7</b>B in instruction execution by using the trace information <b>12</b>B including the stall information based on a power consumption library <b>15</b>B for one equation/one function. As explained in the related art, the source program constituting the source program sequence <b>1</b> is a program which is at a function level and described by a source code. The source code is a program prior to compile. More particularly, the source code is a program which is described by a higher level language such as C language, Pascal, etc. and is read by the human being. The higher level language does not depend upon a particular computer and thus it can be described the most understandably for the human being. The programmer can program the source program by the higher level language. The execution program is a program which can be executed actually on the processor.</p><p>Next, a concrete example of an operation of the first embodiment will be explained with reference to the drawings hereunder. For simplicity of explanation, items are assumed as the premises in the following.</p><p>(A) A processor as the object of power consumption estimation is a microprocessor shown in FIG. <b>3</b>. The microprocessor shown in FIG. 3 comprises a memory <b>16</b> which stores instructions and data and is a low speed, large capacity, and low price memory; an instruction cache <b>17</b>A and a data cache <b>17</b>B both have higher speed, smaller capacity, and higher price than the memory <b>16</b>; and a core <b>18</b> for executing control of them and various arithmetic operations. Assume that the number of instruction stored in the instruction cache <b>17</b>A at a time is 50 and the number of data stored in the data cache <b>17</b>B at a time is 10. Also, assume that both the instruction cache <b>17</b>A and the data cache <b>17</b>B can cancel the oldest instruction and data executed in the past respectively when overflow occurs.</p><p>(B) Assume that there is no instruction to clear the instruction cache <b>17</b>A and the data cache <b>17</b>B.</p><p>(C) Assume that the instruction which has a possibility to cause cache miss in the instruction cache <b>17</b>A and the data cache <b>17</b>B is only an assignment statement of the source code. The assignment statement of the source code is a load instruction in the assembly code.</p><p>(D) Assume that one type of compiler may be employed to convert the source code into the assembly code. As shown in FIG. 4, assume that three type of options, i.e., normal option, code amount precedence option, execution speed precedence option are prepared as options of a compiler. In the first embodiment, the reason for specifying type of the compiler and option of the compiler is given as follows. The source code described by the programmer is optimized by the compiler and then converted into the assembly code. Hence, if the different compiler is employed, the source code is converted into the different assembly code although the original source code is the same. That is, as shown in FIG. 5, the source code and the assembly code do not correspond one by one. For this reason, if the type of the compiler and the option of the compiler are specified previously, it is possible to correlate equations and functions, which are incorporated into the source code, with the assembly code which has been converted. However, as shown in FIG. 6, execution order of the source code may be changed in compile.</p><p>Next, while taking the source program sequence shown in FIG. 7 as an example, actually an operation of the first embodiment will be explained with reference to FIG. 2 hereunder. First, the source program sequence <b>1</b> shown in FIG. 7 is input. Then, the tracer <b>8</b>B executes the instructions in the input source program sequence <b>1</b> one by one, then checks the execution order of these instructions, then outputs the trace information <b>9</b>B. The trace information <b>9</b>B of the source program sequence <b>1</b> shown in FIG. 7 is shown in FIG. <b>8</b>. The execution order signifies the sequence by which these instructions are executed. Then, the stall information detector <b>10</b>B receives the trace information <b>9</b>B output from the tracer <b>8</b>B, and then detects stall information by looking up the operation information <b>11</b> of the microprocessor. The operation information <b>11</b> of the microprocessor has already been obtained previously based on a configuration of the microprocessor in FIG. <b>3</b>. For example, the operation information <b>11</b> are information as for a cache size in the processor, information indicating by what combination of instructions the stall is caused, and the like. The stall information detector <b>10</b>B adds the detected stall information to the trace information <b>9</b>B and then outputs the trace information <b>12</b>B including the stall information. The stall information detector <b>10</b>B detects the stall information by using a stall information detecting algorithm. The stall information signifies information concerning stall generation, e.g., what stall is caused if the instructions are executed one by one, data to be employed are stored in either the memory or the data cache, etc. FIG. 9 shows the trace information <b>12</b>B which includes the stall information prepared based on the trace information <b>9</b>B in FIG. <b>8</b>. Here, assume that the stall is caused in the case where cache miss is caused. The stall information detecting algorithm will be described later.</p><p>Next, the estimation portion <b>13</b>B receives the trace information <b>12</b>B including stall information which are output from the stall information detector <b>10</b>B, and then calculates the power consumption for each instruction by referring to data stored in the power consumption library <b>15</b>B for one equation/one function. The estimation portion <b>13</b>B then adds the power consumption for each instruction to output the power consumption <b>7</b>B.</p><p>The power consumption library <b>15</b>B for one equation/one function is prepared by using a processor power consumption estimating system shown in FIG. 10, for example. This power consumption estimating system estimates the power consumption in the processor from the assembly code (References: Pat. Application Publication (KOKAI) Hei 9-218731, Pat. Application Publication (KOKAI) Hei 10-40144, and Pat. Application Publication (KOKAI) Hei 10-254944). The power consumption estimating system in FIG. 10 comprises the compiler <b>2</b> for converting the source program sequence <b>1</b> into the assembly code <b>3</b>; a tracer <b>8</b>C for receiving the assembly code <b>3</b> and then generating trace information <b>9</b>C; a stall information detector <b>10</b>C for receiving the trace information <b>9</b>C, then detecting stall information of the execution program by using operation information <b>11</b>C of the microprocessor, and then outputting trace information including stall information <b>12</b>C; and an estimation portion <b>13</b>C for receiving the trace information including stall information <b>12</b>C and then calculating power consumption <b>7</b>C in execution of the execution program by looking up data stored in a power consumption library <b>14</b> with regard to the stall information. As described above, if the type of the compiler and the option of the compiler are specified, it is possible to correlate the equations and the functions incorporated in the source code with the assembly code. Therefore, if the power consumption which corresponds to the equations and the functions contained in the source code is calculated previously by using power consumption estimating system shown in FIG. 10, the power consumption for one equation/one function can be prepared as a power consumption library.</p><p>FIG. 11 shows an example of the power consumption library <b>15</b>B for one equation/one function incorporated in the source program. In FIG. 11, the power consumption as for three options of the compiler is shown. FIG. 12 shows the power consumption library <b>15</b>B for one equation/one function with respect to the equations and the functions contained in the source program sequence in FIG. 7, which is calculated by the processor power consumption estimating system in FIG. <b>10</b>. In FIG. 12, information concerning data reading destination and instruction reading destination, which are the operation information <b>11</b> of the microprocessor in FIG. 3, are also shown. In addition, FIG. 13 shows estimated results of the power consumption derived from the source program sequence in FIG. 7 by using the power consumption library for one equation/one function in FIG. <b>12</b>. It can be understood from FIG. 13 that the estimated results of the power consumption is 22300 mW.</p><p>Then, the stall information detecting algorithm will be explained hereunder. A general explanation of the stall will be first made and then an algorithm will be explained with reference to the drawings. The stall means a state in which the processor cannot execute the instruction due to any delay. For example, as the stall, there are the case where the instruction to be used is stored in a memory device which needs several clocks to load such instruction, the case where a particular instruction cannot be executed because of dependence between several instructions, etc. In this case, execution of the instruction is delayed in the processor over several clocks. As another example of delay, for example, there is a delay which is generated because it takes a lot of time to read the subsequently executed instruction from the memory. Normally this delay per se is called \u201cstall\u201d. In addition, there is a delay which is generated because execution content of the succeeding instruction is changed depending upon execution result of the preceding instruction and therefore the next instruction cannot be executed until the execution result of the preceding instruction is defined. This delay is called \u201chazard\u201d. There is a delay which is generated when execution of the succeeding instruction cannot be started until the preceding instruction is completed since the resource necessary for instruction execution is limited. This delay is called \u201cresource conflict\u201d. If the processor is stalled according to the above causes, such processor must spend the system clock excessively by several clocks. A predetermined amount of power is consumed in the excessive cycle of the system clock. Under such circumstances, the stall information must be calculated to estimate the power consumption more precisely.</p><p>FIGS. 14A, <b>14</b>B and <b>14</b>C are flowcharts showing process procedures in the stall information detecting algorithm. First, initialization is effected (step S<b>1</b>). Type of the compiler is then confirmed (step S<b>2</b>). Option of the compiler is then confirmed (step S<b>3</b>). Then, the subsequently executed instruction x[n] is read from the source program sequence, and then (A) information indicating whether the instruction is the equation or the function, (B) instruction address Y[m] of the instruction, and (C) data address Z[l] of the data employed to execute the instruction are stored (step S<b>4</b>). Where the instruction address Y[m] and the data address Z[l] employed herein do not correspond to addresses in the main memory installed in the power consumption estimating system. The instruction address Y[m] and the data address Z[l] are addresses which are provided virtually in the power consumption estimating system. Such addresses are then employed to decide whether or not the instruction and the data were read in the past and stored in the instruction cache <b>17</b>A or the data cache <b>17</b>B. For convenience, assume that they are stored in the cache memory device provided in the power consumption estimating system.</p><p>Next, it is checked whether or not the instruction address Y[m] of the read instruction is equal to the instruction addresses \u03a3Y[m-<b>1</b>] which are saved in the cache memory device (step S<b>5</b>). If they are equal (if YES in step S<b>5</b>), the instruction can be read from the instruction cache <b>17</b>A in FIG. <b>3</b> and then executed. Then, Iflag=1 is set (step S<b>6</b>). In contrast, unless they are equal (if NO in step S<b>5</b>), the instruction can be read from the memory <b>16</b> in FIG. <b>3</b> and then executed. Then, Iflag=0 is set (step S<b>7</b>). Similarly, it is checked whether or not the data address Z[l] of the data employed by the read instruction is equal to the data addresses \u03a3Z[l-<b>1</b>] which are saved in the cache memory device (step S<b>8</b>). If they are equal (if YES in step S<b>8</b>), the data can be read from the data cache <b>17</b>B in FIG.<b>3</b> and then executed. Then, Dflag=1 is set (step S<b>9</b>). In contrast, unless they are equal (if NO in step S<b>8</b>), the data can be read from the memory <b>16</b> in FIG. <b>3</b> and then executed. Then, Dflag=0 is set (step S<b>10</b>).</p><p>Next, it is decided that the read instruction corresponds to the equation or the function (step S<b>11</b>).</p><p>(A) the case where it has been decided in step S<b>11</b> that the instruction corresponds to the equation</p><p>It is decided based on Iflag whether or not the instruction corresponding to this equation has been read from either the instruction cache <b>17</b>A or the memory <b>16</b>. Then, it is decided based on Dflag whether or not the data employed to execute the instruction has been read from either the data cache <b>17</b>B or the memory <b>16</b> (step S<b>12</b>). In the case of Iflag=1 and Dflag=1, it is decided that the instruction is read from the instruction cache <b>17</b>A and the used data are read from the data cache <b>17</b>B (step S<b>13</b>). In the case of Iflag=1 and Dflag=0, it is decided that the instruction is read from the instruction cache <b>17</b>A and the used data are read from the memory <b>16</b> (step S<b>14</b>). In the case of Iflag=0 and Dflag=1, it is decided that the instruction is read from the memory <b>16</b> and the used data are read from the data cache <b>17</b>B (step S<b>15</b>). In the case of Iflag=0 and Dflag=0, it is decided that both the instruction and the used data are read from the memory <b>16</b> (step S<b>16</b>).</p><p>After read states of the instruction and the data have been classified, overflow of the instruction stored in the instruction cache <b>17</b>A and the data stored in the data cache <b>17</b>B is checked. If the instruction has been read from the instruction cache <b>17</b>A, the same instruction address which was saved in the instruction cache <b>17</b>A in the past is deleted (step S<b>17</b>). If the instruction has been read from the memory <b>16</b>, the instruction being executed at this time is saved newly in the instruction cache <b>17</b>A. In this case, it is checked whether or not the number \u03a3Y[n] of the instruction address which is saved in the cache memory device is larger than 50 (step S<b>18</b>). If the number \u03a3Y[n] is larger than 50 (if YES in step S<b>18</b>), the oldest instruction address is deleted from the cache memory device (step S<b>19</b>).</p><p>Then, it is checked based on Dflag whether the used data has been read from either the memory <b>16</b> or the data cache <b>17</b>B (step S<b>20</b>). If the data has been read from the data cache <b>17</b>B, the same data address which was saved in the data cache <b>17</b>B in the past is deleted (step S<b>21</b>). If the data has been read from the memory <b>16</b>, the data being executed at this time is saved newly in the data cache <b>17</b>B. In this case, it is checked whether or not the number \u03a3Z[l] of the data address which is saved in the cache memory device is larger than 10 (step S<b>22</b>). If the number \u03a3Z[1] is larger than 10 (if YES in step S<b>22</b>), the oldest data address is deleted from the cache memory device (step S<b>23</b>).</p><p>(B) the case where it has been decided in step S<b>11</b> that the instruction corresponds to the function</p><p>The number M of instruction and the number L of data necessary for this function are calculated, and then they are increased (step S<b>24</b>).</p><p>Then, it is decided based on Iflag whether or not the instruction corresponding to this equation has been read from either the instruction cache <b>17</b>A or the memory <b>16</b>. In addition, it is decided based on Dflag whether or not the data employed to execute the instruction has been read from either the data cache <b>17</b>B or the memory <b>16</b> (step S<b>25</b>). In the case of Iflag=1 and Dflag=1, it is decided that the instruction is read from the instruction cache <b>17</b>A and the used data are read from the data cache <b>17</b>B (step S<b>26</b>). In the case of Iflag=1 and Dflag=0, it is decided that the instruction is read from the instruction cache <b>17</b>A and the used data are read from the memory <b>16</b> (step S<b>27</b>). In the case of Iflag=0 and Dflag=1, it is decided that the instruction is read from the memory <b>16</b> and the used data are read from the data cache <b>17</b>B (step S<b>28</b>). In the case of Iflag=0 and Dflag=0, it is decided that both the instruction and the used data are read from the memory <b>16</b> (step S<b>29</b>).</p><p>After read states of the instruction and the data have been classified, overflow of the instruction group stored in the instruction cache <b>17</b>A and the data group stored in the data cache <b>17</b>B is checked. If the instruction has been read from the instruction cache <b>17</b>A, the same instruction address which was saved in the instruction cache <b>17</b>A in the past is deleted (step S<b>30</b>). If the instruction has been read from the memory <b>16</b>, the instruction being executed at this time is saved newly in the instruction cache <b>17</b>A. In this case, it is checked whether or not the number \u03a3Y[n] of the instruction address which is saved in the cache memory device is larger than 50 (step S<b>31</b>). If the number \u03a3Y[n] is larger than 50 (if YES in step S<b>31</b>), the instruction address is deleted from the cache memory device by the number of overflow from the oldest instruction address in sequence (step S<b>32</b>).</p><p>Then, it is checked based on Dflag whether the used data has been read from either the memory <b>16</b> or the data cache <b>17</b>B (step S<b>33</b>). If the data has been read from the data cache <b>17</b>B, the same data address which was saved in the cache memory device in the past is deleted (step S<b>34</b>). If the data has been read from the memory <b>16</b>, the data being executed at this time is saved newly in the data cache <b>17</b>B. In this case, it is checked whether or not the number \u03a3Z[l] of the data address which is saved in the cache memory device is larger than 10 (step S<b>35</b>). If the number \u03a3Z[l] is larger than 10 (if YES in step S<b>35</b>), the data address is deleted from the cache memory device by the number of overflow from the oldest data address in sequence (step S<b>36</b>).</p><p>Then, it is checked whether or not all instructions in the source program have been executed (step S<b>37</b>). Unless all instructions have been executed (if NO in step S<b>37</b>), a program counter (N) is incremented by one (step S<b>38</b>) and then the process returns to step S<b>4</b>. If all instructions have been executed (if YES step S<b>37</b>), the processes in this algorithm are completed.</p><p>In addition, the stall information detecting algorithm will be explained in more detail by using the trace information shown in FIG. <b>8</b>. In this disclosure, assume that the programmer has decided to use the cc compiler and to compile according to normal option. Accordingly, after the initialization in step S<b>1</b>, \u201cuse of the cc compiler\u201d is checked in step S<b>2</b>, then \u201cnormal option\u201d is checked in step S<b>3</b>.</p><p>In step S<b>4</b>, first the instruction in the execution order <b>1</b> is read. Since this instruction is executed for the first time, the process advances to step S<b>11</b> via the pass of step S<b>5</b>, step S<b>7</b>, step S<b>8</b>, and step S<b>10</b>. Since the instruction in the execution order <b>1</b> is the equation, the process goes to step S<b>12</b>. Then, since both the instruction and the data are read from the memory <b>16</b>, the process goes to step S<b>16</b> and step S<b>18</b>. Then, since the number \u03a3Y[n] of the instruction address which is saved in the instruction cache <b>17</b>A is smaller than 50, the process goes to step S<b>20</b>. Then, since the data are read from the memory <b>16</b>, the process goes to step S<b>22</b>. It is checked whether or not the number \u03a3Z[l] of the data address which is saved in the data cache <b>17</b>B is larger than 10. Here, since the number \u03a3Z[l] of the data address is less than 10, the process goes to step S<b>37</b>. Then, since all instructions have not executed yet, the process returns to step S<b>4</b> again via step S<b>38</b> and then process of the next instruction is started. The instruction in the execution order <b>2</b> is processed through the same path as the instruction in the execution order <b>1</b>. Because the instruction in the execution order <b>3</b> is also executed for the first time, the process advances up to step S<b>11</b>, as in the instruction in the execution order <b>1</b>. Since the instruction in the execution order <b>3</b> is the function, the process goes to step S<b>24</b>. In step S<b>24</b>, the number M of instruction and the number L of data necessary for the function are calculated and then they are incremented. Since the instruction in the execution order <b>3</b> employs 12 instructions and 2 data, the number of instruction is increased by (12\u22121)=11 and the number of data is increased by (2\u22121)=1. In turn, the process goes to step S<b>25</b>. Since both the instruction and the data are read from the memory <b>16</b>, the process advances to step S<b>29</b> and step S<b>31</b>. Because the number \u03a3Y[n] of the instruction address which is saved in the instruction cache <b>17</b>A is smaller than 50, the process goes to step S<b>33</b>. Then, since the data has been read from the memory <b>16</b>, the process goes to step S<b>35</b>. Then, because the number \u03a3Z[1] of the data address which is saved in the data cache <b>17</b>B is less than 10, the process goes to step S<b>37</b>, step S<b>38</b>, and step S<b>5</b>.</p><p>The instructions in the execution order <b>4</b> and the execution order <b>7</b> are processed via the same path as the instruction in the execution order <b>1</b>. The instructions in the execution order <b>5</b> and the execution order <b>6</b> are processed via the same path as the instruction in the execution order <b>3</b>.</p><p>The instruction in the execution order <b>3</b>\u2032 is decided in step S<b>5</b> such that its instruction address is equal to the instruction address which is saved in the cache memory device and thus such instruction in the execution order <b>3</b>\u2032 is identical to the instruction being executed in the past. Then, a flag is set (Iflag=1) in step S<b>6</b>, the process goes to step S<b>8</b>. In step S<b>8</b>, since the data have already been stored in the data cache <b>17</b>B, the process goes to step S<b>9</b>. Then, a flag is set (Dflag=1) and then the process goes to step S<b>11</b>. Since the instruction is the function, the process goes to step S<b>25</b> via step S<b>24</b>. In this case, both the instruction and the data are read from the cache memory, the process advances to step S<b>26</b> and step S<b>30</b>. In step S<b>30</b>, the same instruction address group employed in the past is deleted and then the process goes to step S<b>33</b> and step S<b>34</b>. In step S<b>34</b>, the same data address group employed in the past is deleted. Then, the process returns to step S<b>4</b> via step S<b>37</b> and step S<b>38</b>.</p><p>The instruction in the execution order <b>4</b>\u2032 is processed via the same path as the instruction in the execution order <b>3</b>\u2032 and the process goes from step S<b>4</b> to step S<b>11</b>. Since the instruction is the equation, the process goes to step S<b>12</b>. Then, since both the instruction and the data are read from the cache memory <b>17</b>A, <b>17</b>B, the process goes to step S<b>13</b> and step S<b>17</b>. In step S<b>17</b>, the same instruction address employed in the past is deleted and then the process goes to step S<b>20</b> and step S<b>21</b>. In step S<b>21</b>, the same data address employed in the past is deleted. Then, the process returns to step S<b>4</b> via step S<b>37</b> and step S<b>38</b>.</p><p>The instruction in the execution order <b>5</b>\u2032 is processed via the same path as the instruction in the execution order <b>3</b>. The instruction in the execution order <b>6</b>\u2032 is processed via the same path as the instruction in the execution order <b>3</b>. The instruction in the execution order <b>7</b>\u2032 is processed via the same path as the instruction in the execution order <b>4</b>\u2032.</p><p>The instruction in the execution order <b>3</b>\u2033 is processed via the same path as the instruction in the execution order <b>3</b>\u2032 and the process goes to step S<b>37</b>. Since this instruction is the final instruction, this algorithm has been completed. In this manner, the stall information detecting algorithm adds the stall information to the trace information.</p><p>As described above, according to the first embodiment of the present invention, it is possible for the programmer to estimate the power consumption in the processor directly based on the source program being described by the programmer. Therefore, estimated result of the power consumption can be get quickly with high precision. Also, the programmer can get an estimation result of the power consumption in the course of programming, so that the programmer can describe easily the program in consideration of the low power consumption.</p><p>If the instruction is the function and the branch instruction and the loop are contained in the function, in many cases the necessary number of cycle and the power consumption are not decided uniquely in execution of the instruction unless the simulation is performed actually. Hence, the power consumption library <b>15</b>B for one equation/ one function shown in FIG. 12 may be replaced with a maximum/minimum power consumption library in which the maximum value and the minimum value are shown in FIG. <b>15</b>. If the maximum/minimum power consumption library for one equation/one function in FIG. 15 is employed, it is possible to detect the maximum power consumption, which can derived by adding the maximum value of the power consumption for each instruction, and the minimum power consumption, which can derived by adding the minimum value of the power consumption for each instruction, respectively. For example, in the case of the source program sequence shown in FIG. 7, the maximum and minimum power consumption shown in FIG. 16 can be detected by using the data in the maximum/minimum power consumption library in FIG. <b>15</b>. Hence, even if the power consumption for each instruction cannot estimated uniquely, at least the maximum value and the maximum value of the power consumption can be calculated. Accordingly, it is feasible to set an upper limit and a lower limit of the power consumption in the processor. Also, if this information is fed back to the programmer, the programmer can improve the program effectively in the middle of programming.</p><h4>(Second Embodiment)</h4><p>FIG. 17 is a block diagram showing a configuration of a processor power consumption estimating system according to a second embodiment of the present invention. The power consumption estimating system according to the second embodiment of the present invention comprises a static expander <b>19</b> for receiving the source program sequence <b>1</b> of the function level and then statically expanding the source program sequence <b>1</b>, and an estimation portion <b>13</b>D for receiving a statically expanded program sequence <b>20</b> and then calculating the power consumption based on a power consumption library <b>15</b>D for one equation/ one function when the execution program is executed.</p><p>In the second embodiment of the present invention, information such as branch probability, jump probability, loop number of times, etc., which are requested to expand the source program sequence <b>1</b> from the outside, are given. Then, it is decided by using them that the instruction and the data employed to execute the instruction are read from either the instruction cache <b>17</b>A/the data cache <b>17</b>B or the memory <b>16</b>. Based on the decision result, the static expander <b>19</b> statically expands the source program sequence <b>1</b>. That is, it is possible to expand the source program sequence <b>1</b> without the actual simulation. For instance, in the source program sequence employed in the above first embodiment shown in FIG. 7, the loop number in the source program sequence is designated as \u201cloop number=<b>2</b>\u201d from the outside. Thus, the program sequence <b>20</b> which is statically expanded without the actual simulation, i.e., the trace information shown in FIG.8 can be obtained. Then, like the first embodiment, the estimation portion <b>13</b>D receives the program sequence <b>20</b> which is statically expanded and then calculates the power consumption for each instruction by referring to the data being stored in the power consumption library <b>15</b>D for one equation/one function. Then, the estimation portion <b>13</b>D adds the power consumption for each instruction, which is calculated, and then outputs the power consumption <b>7</b>D of the microprocessor. Therefore, even in the stage where variable values employed in the source program are not defined, it is possible to estimate the power consumption in the processor. In addition, since the trace information can be obtained without execution of the simulation, higher speed estimation of the power consumption can be achieved. Moreover, it is possible to estimate the power consumption for the unfinished source program to which the simulation cannot be applied.</p><h4>(Third Embodiment)</h4><p>Next, a third embodiment of the present invention will be explained hereunder. In a processor power consumption estimating system according to the third embodiment of the present invention, a data cache information detecting system which detects cache information of the data cache from the source program is provided to the processor power consumption estimating system according to the first or second embodiment. FIG. 18 is a block diagram showing a configuration of the data cache information detecting system provided in the processor power consumption estimating system according to the third embodiment of the present invention. This data cache information detecting system comprises a tracer <b>8</b>E for receiving the source program sequence <b>1</b> of the function level and then generating trace information <b>9</b>E of the source program sequence <b>1</b>, and a data cache checker <b>21</b> for receiving the trace information <b>9</b>E and then detecting data cache information <b>23</b> by referring to a data cache information library <b>22</b> for one equation/one function. In respective equations/functions employed in the source program, the data stored as the data cache information library <b>22</b> are a total number of data which are referred to by the equation/function, type of referred data, referring timings of data, and order and type of the data which are stored in the data cache after the equation/function have been executed. As the type of referred data, for example, there are internal data which are employed in the inside of only one equation/function and global data which are employed in the inside of a plurality of equations/functions.</p><p>Next, a particular example of an operation of the data cache information detecting system according to the third embodiment of the present invention will be explained with reference to the drawings hereinbelow. Here, the case where three instructions A, B, C shown in FIG. 19 are executed in the execution order shown in FIG. 20 will be explained as an example. To begin with, the tracer <b>8</b>E receives the source program sequence <b>1</b>. Then, the tracer <b>8</b>E executes the instructions one by one to expand the received source program sequence <b>1</b> and then detects the trace information <b>9</b>E which indicates the execution order by which these instructions should be executed. Then, the data cache checker <b>21</b> receives the trace information <b>9</b>E which are output from the tracer <b>8</b>E and then detects the data cache information <b>23</b> by referring to the data stored in the data cache information library <b>22</b> for one equation/ one function. The data cache checker <b>21</b> detects the data cache information <b>23</b> by using the data cache information detecting algorithm.</p><p>FIG. 21 is a flowchart showing process procedures in the data cache information detecting algorithm employed in the third embodiment of the present invention. At first, initialization is carried out (step S<b>101</b>), then type of the compiler is confirmed (step S<b>102</b>), and then option of the compile is confirmed (step S<b>103</b>). In this disclosure, assume that the programmer has decided to use the cc compiler and to compile according to normal option. Accordingly, after the initialization in step S<b>101</b>, \u201cuse of the cc compiler\u201d is checked in step S<b>102</b>, then \u201cnormal option\u201d is checked in step S<b>103</b>. Then, the next executed instruction is read and then it is checked which one of the equation and the function such instruction corresponds to (step S<b>104</b>). In the program shown in FIG. 19, since the instruction A is executed at first, the instruction A is read for the first time and recognized. It is checked whether or not the data are contained in data cache (step S<b>105</b>). Since the instruction A is the first instruction which is executed for the first time, no data is contained in the data cache (if NO in step <b>105</b>). Accordingly, the process goes to step S<b>109</b>. The state of the data cache derived when execution of the instruction A has been terminated is detected from FIG. 19, and the data cache is updated into such state (step S<b>109</b>). Then, information indicating that data cache miss is caused in the global data Y, Z are fed back to the programmer (step S<b>109</b>). It is decided whether or not all instructions have been executed (step S<b>111</b>). Here, since the succeeding instruction is present (if NO in step <b>111</b>), the process returns to step S<b>104</b>.</p><p>Then, the instruction B is read and then checked (step S<b>104</b>). Then, since the data has already been contained in the data cache (if YES in step S<b>105</b>), then it is checked which data is the global data employed in the instruction B, and a total number of the global data is checked (step S<b>106</b>). More specifically, it is confirmed from FIG. 19 that the global data employed in the instruction B are three data X, Y, Z (step S<b>107</b>). Then, it is checked whether or not the global data X, Y, Z are contained in the data cache (step S<b>107</b>). Since the data Y is contained (if YES in step S<b>107</b>), it is checked whether or not the data Y can be read actually from the data cache when the instruction B is executed (step S<b>108</b>). More particularly, FIFO (first-in first-out) is carried out based on the data shown in FIG. <b>19</b>. In this case, the data Y is canceled from the data cache before the data Y is employed by the instruction B, and thus not used. That is, the cache miss is caused. Then, the state of the data cache is detected from FIG. 19 when the execution of the instruction B is terminated, and then the data cache is updated into its state (step S<b>109</b>). Then, information concerning that the cache miss is caused by the global data X, Y, Z are fed back to the programmer (step S<b>110</b>).</p><p>Then, it is decided whether or not all instructions have been executed (step S<b>111</b>). Here, since the succeeding instruction is contained, the process goes to step S<b>104</b> once again. The instruction C is read and confirmed (step S<b>104</b>). Since the data have been contained in the data cache (if YES in step S<b>110</b>), then it is checked which data is the global data employed in the instruction C, and a total number of the global data is checked (step S<b>106</b>). Since the global data of the instruction C is merely data Z and also the data Z is contained in the data cache (if YES in step S<b>107</b>), the process advances to step S<b>108</b>. Then, it is checked whether or not the data Z can be read actually from the data cache when the instruction C is executed (step S<b>108</b>). Here, the data Z are available. After the data cache is updated (step S<b>109</b>), information indicating that the global data Z causes data cache hit is fed back to the programmer (step S<b>110</b>). Then, it is decided whether or not all instructions have been executed and then the process is terminated since the succeeding instruction is not contained (if YES in step S<b>111</b>).</p><p>Based on the data cache information thus derived, the programmer can know the data which causes the data cache miss and the number of such data. Accordingly, for example, if there is no influence upon the execution result, the execution order shown in FIG. 20 can be modified, the cache miss can be improved, influence upon other data caused by this improvement can be checked once again. Therefore, it is possible to reduce the power consumption due to improvement in the cache miss. For instance, if the instruction which employs the data shown in FIG. 19 is executed in the execution order shown in FIG. 20, internal state of the data cache is changed, as shown in FIG. <b>22</b>. As evident from FIG. 20, the cache miss of the global data is caused six times. In the event that there is no influence upon the execution result even when the execution order of the instruction is changed, internal state of the data cache is changed as shown in FIG. 24 if the instruction is executed in the execution order shown in FIG. 23, for example. In this case, the number of times of the data cache miss can be reduced to five. For this reason, the power consumption of the processor can be reduced by reducing the data cache miss in this way.</p><h4>(Other Embodiment)</h4><p>For the processor power consumption estimating system according to the first to third embodiments of the present invention, the normal computer system can be employed. In this computer system, so-called general-purpose machine, workstation, PC, NC (Network Computer), etc. are included. The computer system employed in the power consumption estimating system according to the above first to third embodiments comprises a CPU for executing various processes, an input device such as a keyboard, a mouse, a light pen, a flexible disk device, etc., an external memory device such as a memory device, a disk device, etc., and an output device such as a display device, a printer device, etc.</p><p>Further, in the processor power consumption estimating system according to the above first to third embodiments, GUI (graphical user interface) for displaying the estimated result of the power consumption and the data cache miss information to the programmer can be provided.</p><p>FIG. 25 is a view showing a first example of the estimated result of the power consumption displayed by using GUI. In this first example, the power consumption being consumed by the instructions are displayed one by one relative to respective instructions after the trace has been expanded. FIG. 26 is a view showing a second example of the estimated result of the power consumption displayed by using GUI. In this second example, an occurring frequency of respective instructions prior to trace expansion, maximum/minimum power consumption which is consumed every time when the instruction is executed once, and a product of the occurring frequency and the maximum/minimum power consumption (total power consumption) are displayed. FIG. 27 is a view showing a third example of the estimated result of the power consumption displayed by using GUI. In this third example, the occurring frequency of the instruction before the trace expansion, a frequency of the data cache miss being caused by the instruction, and the power consumption which is estimated with regard to the occurring frequency of the instruction and the frequency of the data cache miss are displayed. FIG. 28 is a view showing a fourth example of the estimated result of the power consumption displayed by using GUI. In this fourth example, if the instruction using a hierarchical structure is employed, more detail information can be get by designating the instruction. FIG. 29 is a view showing a first example of data cache miss information displayed by using GUI. In FIG. 29, data addresses employed by the function A and the function B (thin lines in FIG. <b>29</b>), referred number of times of the function A and the function B, and data addresses at which the data cache miss are caused (thick lines in FIG. 29) are displayed. FIG. 30 is a view showing a second example of the data cache miss information displayed by using GUI. In FIG. 30, data addresses employed by the function A and the function B and using timings thereof are displayed. In this manner, the programmer can execute easily the operation to monitor the estimated result of the power consumption and the data cache information, or to work them by pointing the icon or the menu item on the display screen by using the GUI. In addition, the programmer can analyze information more effectively and feed back the analyzed result to the programming operation.</p><p>Also, the program for implementing the above processor power consumption estimating method can be stored in the storage medium. The contents of this storage medium is installed into the computer system, and then the processor power consumption estimating method can be accomplished while controlling the computer system by executing the program. As the storage medium, there may be employed, for example, a memory device, a magnetic disk drive, an optical disk drive, etc. if they can store the program. Such program can be written in any conventional software language known to those skilled in the art including C, C++ or FORTRAN. Such conventional software languages generally include a compiler which generates machine-executable code from the higher level programming instructions.</p><p>Various modifications will become possible for those skilled in the art after receiving the teaching of the present disclosure without departing from the scope thereof.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Atsushi", "last_name": "Kageshima", "name": ""}, {"first_name": "Masayoshi", "last_name": "Tachibana", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "KABUSHIKI KAISHA TOSHIBA"}, {"first_name": "", "last_name": "KABUSHIKI KAISHI TOSHIBA", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   1/26"}, {"primary": false, "label": "G06F   1/32"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   1/32        20060101A I20051008RMUS"}, {"label": "H01L  21/82        20060101ALI20051220RMJP"}, {"label": "G06F   1/26        20060101A I20051008RMEP"}, {"label": "G06F  11/34        20060101A I20051008RMEP"}, {"label": "G06F  17/50        20060101ALI20051220RMJP"}], "national_classes": [{"primary": true, "label": "713300"}, {"primary": false, "label": "714E11197"}, {"primary": false, "label": "713320"}], "ecla_classes": [{"label": "S06F217:78"}, {"label": "T05K999:99"}, {"label": "G06F   1/26"}, {"label": "G06F  11/34M"}, {"label": "G06F   1/32"}], "cpc_classes": [{"label": "G06F   1/26"}, {"label": "G06F   1/32"}, {"label": "G06F  11/3447"}, {"label": "G06F2119/06"}, {"label": "G06F2119/06"}, {"label": "G06F  11/3471"}, {"label": "G06F  11/3471"}, {"label": "G06F2201/885"}, {"label": "G06F2201/885"}, {"label": "G06F2201/865"}, {"label": "G06F   1/26"}, {"label": "G06F2201/86"}, {"label": "G06F2201/865"}, {"label": "G06F   1/32"}, {"label": "G06F  11/3447"}, {"label": "G06F2201/86"}, {"label": "Y02D  10/00"}, {"label": "Y02D  10/00"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1998-02-16", "application_date": "1999-02-16", "family_members": [{"ucid": "US-6205555-B1", "titles": [{"lang": "EN", "text": "Processor power consumption estimating system, processor power consumption estimating method, and storage medium storing program for executing the processor power consumption estimating method"}]}, {"ucid": "JP-H11232147-A", "titles": [{"lang": "JA", "text": "\u30d1\u30ef\u30fc\u30a8\u30b9\u30c6\u30a3\u30e1\u30fc\u30b7\u30e7\u30f3\u88c5\u7f6e\u3001\u30d1\u30ef\u30fc\u30a8\u30b9\u30c6\u30a3\u30e1\u30fc\u30b7\u30e7\u30f3\u65b9\u6cd5\u3001\u53ca\u3073\u30d1\u30ef\u30fc\u30a8\u30b9\u30c6\u30a3\u30e1\u30fc\u30b7\u30e7\u30f3\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u8a18\u9332\u3057\u305f\u6a5f\u68b0\u8aad\u307f\u53d6\u308a\u53ef\u80fd\u306a\u8a18\u9332\u5a92\u4f53"}, {"lang": "EN", "text": "METHOD AND DEVICE FOR POWER ESTIMATION, AND MACHINE-REDABLE RECORDING MEDIUM HAVING RECORDED POWER ESTMATION PROGRAM"}]}]}