{"patent_number": "US-6510508-B1", "publication_id": 73278373, "family_id": 24383899, "publication_date": "2003-01-21", "titles": [{"lang": "EN", "text": "Translation lookaside buffer flush filter"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11457420\" source=\"national office\"><p>A translation lookaside buffer (TLB) flush filter. In one embodiment, a central processing unit includes a TLB for storing recent address translations. A TLB flush filter monitors blocks of memory from which address translations have been loaded and cached in the TLB. The TLB flush filter is configured to detect if any of the underlying address translations in memory have changed. If no changes have occurred, the TLB flush filter may then prevent a flush of the TLB following the next context switch. If changes have occurred to the underlying address translations, the TLB flush filter may then allow a flush of the TLB following a context switch.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50437930\"><p>A translation lookaside buffer (TLB) flush filter. In one embodiment, a central processing unit includes a TLB for storing recent address translations. A TLB flush filter monitors blocks of memory from which address translations have been loaded and cached in the TLB. The TLB flush filter is configured to detect if any of the underlying address translations in memory have changed. If no changes have occurred, the TLB flush filter may then prevent a flush of the TLB following the next context switch. If changes have occurred to the underlying address translations, the TLB flush filter may then allow a flush of the TLB following a context switch.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00001\" num=\"1\"><claim-text>1. A processor comprising:</claim-text><claim-text>a translation lookaside buffer (TLB) for storing address translations; and </claim-text><claim-text>a TLB flush filter coupled to said TLB, wherein said TLB flush filter is configured to monitor blocks of memory from which said address translations have been read and cached into said TLB and to determine if any of said address translations in said blocks of memory have changed, wherein said TLB flush filter is further configured to, responsive to a context switch, allow said TLB to be flushed if said address translations have changed, and wherein said TLB flush filter is configured to prevent a flush of said TLB if said address translations have not changed. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00002\" num=\"2\"><claim-text>2. The processor as recited in <claim-ref idref=\"US-6510508-B1-CLM-00001\">claim 1</claim-ref>, wherein said TLB flush filter is activated by a first context switch.</claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00003\" num=\"3\"><claim-text>3. The processor as recited in <claim-ref idref=\"US-6510508-B1-CLM-00002\">claim 2</claim-ref>, wherein said first context switch causes a flush of said TLB.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00004\" num=\"4\"><claim-text>4. The processor as recited in <claim-ref idref=\"US-6510508-B1-CLM-00001\">claim 1</claim-ref>, wherein said TLB flush filter includes a region table for tracking said blocks of memory.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00005\" num=\"5\"><claim-text>5. The processor as recited in <claim-ref idref=\"US-6510508-B1-CLM-00004\">claim 4</claim-ref>, wherein said TLB flush filter is configured to detect a modification of a memory location within said blocks of memory, and wherein said TLB flush filter is configured to allow a flush of said TLB responsive to a next context switch and responsive to detecting said modification of said memory location.</claim-text></claim>"}, {"num": 6, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00006\" num=\"6\"><claim-text>6. The processor as recited in <claim-ref idref=\"US-6510508-B1-CLM-00004\">claim 4</claim-ref>, wherein said region table includes a content addressable memory (CAM) and a random access memory (RAM).</claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00007\" num=\"7\"><claim-text>7. The processor as recited in <claim-ref idref=\"US-6510508-B1-CLM-00006\">claim 6</claim-ref>, wherein said CAM is configured to store a plurality of entries, wherein each of said plurality of entries includes address information associated with said blocks of memory.</claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00008\" num=\"8\"><claim-text>8. The processor as recited in <claim-ref idref=\"US-6510508-B1-CLM-00007\">claim 7</claim-ref>, wherein said TLB flush filter includes a counter configured to count the number of entries in said CAM.</claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00009\" num=\"9\"><claim-text>9. The processor as recited in <claim-ref idref=\"US-6510508-B1-CLM-00008\">claim 8</claim-ref>, wherein said TLB flush filter is deactivated when said counter overflows.</claim-text></claim>"}, {"num": 10, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00010\" num=\"10\"><claim-text>10. The processor as recited in <claim-ref idref=\"US-6510508-B1-CLM-00006\">claim 6</claim-ref>, wherein said RAM is configured to store a plurality of entries, wherein each of said plurality of entries is configured to store a tag associated with a base address.</claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00011\" num=\"11\"><claim-text>11. The processor as recited in <claim-ref idref=\"US-6510508-B1-CLM-00010\">claim 10</claim-ref>, wherein said TLB flush filter includes a counter configured to provide a new tag responsive to a base address which misses said CAM.</claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00012\" num=\"12\"><claim-text>12. The processor as recited in <claim-ref idref=\"US-6510508-B1-CLM-00011\">claim 11</claim-ref>, wherein said TLB flush filter is deactivated when said counter overflows.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00013\" num=\"13\"><claim-text>13. A method of operating a processor, the method comprising:</claim-text><claim-text>storing address translations in a translation lookaside buffer (TLB), said address translations loaded into said TLB from one or more blocks of memory; </claim-text><claim-text>determining if any address translations stored in said one or more blocks of memory have changed; </claim-text><claim-text>flushing said TLB if any of said address translations stored in said one or more blocks of memory have changed, said flushing responsive to a context switch; and </claim-text><claim-text>preventing a flush of said TLB responsive to a context switch if none of said address translations stored in said one or more blocks of memory have changed, wherein a flush of said TLB is prevented by a TLB flush filter. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00014\" num=\"14\"><claim-text>14. The method as recited in <claim-ref idref=\"US-6510508-B1-CLM-00013\">claim 13</claim-ref>, wherein said TLB flush filter is activated by a first context switch.</claim-text></claim>"}, {"num": 15, "parent": 14, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00015\" num=\"15\"><claim-text>15. The method as recited in <claim-ref idref=\"US-6510508-B1-CLM-00014\">claim 14</claim-ref>, wherein said first context switch causes a flush of said TLB.</claim-text></claim>"}, {"num": 16, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00016\" num=\"16\"><claim-text>16. The method as recited in <claim-ref idref=\"US-6510508-B1-CLM-00013\">claim 13</claim-ref>, wherein said TLB flush filter includes a region table, said region table configured to monitor said address translations stored in said one or more blocks of memory.</claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00017\" num=\"17\"><claim-text>17. The method as recited in <claim-ref idref=\"US-6510508-B1-CLM-00016\">claim 16</claim-ref>, wherein a flush of said TLB occurs responsive to the next context switch after detection of a change to one or more of said address translations stored in said one or more blocks of memory, said detection occurring in said region table.</claim-text></claim>"}, {"num": 18, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00018\" num=\"18\"><claim-text>18. The method as recited in <claim-ref idref=\"US-6510508-B1-CLM-00016\">claim 16</claim-ref>, wherein said region table includes a content addressable memory (CAM) and a random access memory (RAM.</claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00019\" num=\"19\"><claim-text>19. The method as recited in <claim-ref idref=\"US-6510508-B1-CLM-00018\">claim 18</claim-ref>, wherein said CAM is configured to store a plurality of entries, wherein each of said entries includes information associated with said one or more blocks of memory.</claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00020\" num=\"20\"><claim-text>20. The method as recited in <claim-ref idref=\"US-6510508-B1-CLM-00019\">claim 19</claim-ref>, wherein a counter is configured to count the number of entries stored in said CAM.</claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00021\" num=\"21\"><claim-text>21. The method as recited in <claim-ref idref=\"US-6510508-B1-CLM-00020\">claim 20</claim-ref>, wherein an overflow of said counter causes said TLB flush filter to be deactivated.</claim-text></claim>"}, {"num": 22, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00022\" num=\"22\"><claim-text>22. The method as recited in <claim-ref idref=\"US-6510508-B1-CLM-00018\">claim 18</claim-ref>, wherein said RAM is configured to store a plurality of entries, each of said entries including a base address and a tag associated with said base address.</claim-text></claim>"}, {"num": 23, "parent": 22, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00023\" num=\"23\"><claim-text>23. The method as recited in <claim-ref idref=\"US-6510508-B1-CLM-00022\">claim 22</claim-ref>, wherein a counter is configured to count the number of entries in said RAM.</claim-text></claim>"}, {"num": 24, "parent": 23, "type": "dependent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00024\" num=\"24\"><claim-text>24. The method as recited in <claim-ref idref=\"US-6510508-B1-CLM-00023\">claim 23</claim-ref>, wherein said TLB flush filter is deactivated when said counter overflows.</claim-text></claim>"}, {"num": 25, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6510508-B1-CLM-00025\" num=\"25\"><claim-text>25. An apparatus comprising:</claim-text><claim-text>a memory circuit having a plurality of entries, wherein each of said plurality of entries is configured to store an address of a memory block for storing address translations; and </claim-text><claim-text>a circuit coupled to said memory circuit, wherein said circuit is configured to allow a flush of a translation lookaside buffer (TLB) responsive to a context switch if said address translations corresponding to said plurality of entries stored in said memory circuit have changed, and wherein said filter circuit is configured to prevent a flush of said TLB if said address translations have not changed.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53863700\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention relates to processors, and more particularly, to a translation lookaside buffer used for storing address translations.</p><p>2. Description of the Relevant Art</p><p>Computer systems using memory management may have the need to translate virtual addresses into physical addresses in order to perform a memory access. Typical computer programs are written to address a memory model, and thus issue virtual memory addresses when performing a memory access. A virtual memory address must then be translated into a physical memory address in order to access the information required by the program. Various mechanisms exist in different computer architectures for performing virtual-to-physical address translations.</p><p>One problem with performing address translations is latency. In addition to the time required to access the information from memory, a number of clock cycles may be used to perform the address translation. This latency penalty may become severe or unacceptable in programs that perform frequent memory accesses. One common method of reducing the latency penalty from translating addresses is to use a translation lookaside buffer (TLB). A TLB is a small memory located within a processor, and is used to store virtual-to-physical address translations. A typical TLB may store both the virtual and physical addresses for the most recent address translations. When a program attempts a memory access, it may issue a virtual address. The TLB may then be searched for the issued virtual address. If found, a physical address corresponding to the issued virtual address may then be used to access main memory. Typically, translations are provided on a page basis (e.g. 4 kilobytes, 2 megabytes, 4 megabytes, etc.) and the TLB may store the page portion of the virtual address and page portion of the corresponding physical address.</p><p>Despite the advantages provided by a TLB, problems still exist. One such problem occurs on a context switch. In many processors employing a TLB, a context switch results in the removal of all translations stored in the TLB. This is known as a TLB flush. The TLB is flushed because one or more of the address translations corresponding to the context switched out of may be modified, and thus the translations cached in the TLB may no longer be the correct translations. Unfortunately, as the new process runs following the context switch, each memory access requires an address translation, and the TLB must be reloaded. The address translations and reloading of the TLB may result in large latency penalties. These latency penalties may be exacerbated by programs or operating systems that require frequent context switches.</p><p>The address translations stored in a TLB are supported by underlying data structures stored in memory. For example, computers that employ paging may store data structures in a page table. Such data structures may include the translations which are loaded into the TLB. While these data structures may be altered for a context which was switched out via a context switch, frequently these data structures are not altered. Despite the fact that the data structures are not altered in all instances, a typical processor may still perform a flush of the TLB. A TLB flush under such circumstances may not be necessary, and may result in large latency penalties as described above.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above may in large part be solved by a translation lookaside buffer (TLB) flush filter as described herein. In one embodiment, a processor includes a TLB for storing recent address translations. A TLB flush filter monitors blocks of memory from which address translations have been loaded and cached in the TLB. The TLB flush filter is configured to determine if any of the underlying address translations in memory have changed. If no changes have occurred, the TLB flush filter may then prevent a flush of the TLB on a context switch. If changes have occurred to the underlying address translations, the TLB flush filter may then allow a flush of the TLB following a context switch.</p><p>In one embodiment, the TLB flush filter uses a region table to track blocks of memory from which address translations have been cached in the TLB. The TLB flush filter may monitor for modifications to the underlying address translations in various blocks of memory (typically page tables or directories). A first context switch may result in a TLB flush, and may then activate the TLB flush filter. TLB flushes may be blocked by the TLB flush filter on subsequent context switches if no changes to the underlying address translations in memory are detected in the region table.</p><p>The method of operating the TLB flush filter also includes tracking context switches. In one embodiment, this may be performed by tagging the values of a base address register. The base address register may be configured to store the base address of a page table associated with a particular context. The tag and the actual value of the register may be stored as entries in the region table, and may correspond to specific memory regions. The tag may be stored along with the other data in a TLB entry to associate the translation in that entry with a context. In this way, translations for many contexts may reside in the TLB at the same time. Only translations with context tags that match the current context tag would be available to the current context.</p><p>The region table used in one embodiment is implemented with a content addressable memory (CAM) and a random access memory (RAM). The CAM may be used to store information regarding the memory structures from which address translations are loaded into the TLB. Such information may include page directory information and page table information. The RAM may be used to store values of the base address register and its associated tag. A counter may also be used to track the number of base address entries. When the counter overflows, the TLB flush filter may then be deactivated, and the region table cleared. A region counter may also be used to record the number of entries stored in the CAM. An overflow of this counter may also cause the TLB flush filter to be deactivated and the region table cleared. Following the deactivation of the TLB flush filter, a context switch may result in a TLB flush. The TLB flush filter may then be activated once again.</p><p>Thus, in various embodiments, the TLB flush filter may prevent unnecessary flushes to a TLB. Since unnecessary flushes to a TLB may be prevented, a new context may be able to use previously cached address translations when none of the underlying address translations have changed. In many cases, this may eliminate the need to repeat the process of translating a virtual address to a physical address and caching it into the TLB. Thus, the latency for a large number of memory accesses may be significantly reduced, and may thereby allow for a significant increase in processor performance.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of one embodiment of a processor in which a TLB flush filter could be implemented;</p><p>FIG. 2 is a block diagram of one embodiment of a portion of a processor employing a TLB flush filter;</p><p>FIG. 3 is a block diagram of one embodiment of a TLB flush filter;</p><p>FIG. 4 is a diagram illustrating region table entries for one embodiment of the TLB flush filter;</p><p>FIG. 5 is a logic diagram illustrating the logic for operating one embodiment of the TLB flush filter;</p><p>FIG. 6 is a timing diagram illustrating the operation of one embodiment of the TLB flush filter;</p><p>FIG. 7A is a block diagram illustrating a paging structure covered by entries in a region table;</p><p>FIG. 7B is a block diagram illustrating a region table with entries corresponding to the paging structure illustrated in FIG. 7A; and</p><p>FIG. 8 is a block diagram of one embodiment of a computer system in which a TLB flush filter would be implemented.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and description thereto are not intended to limit the invention to the particular form disclosed, but, on the contrary, the invention is to cover all modifications, equivalents, and alternatives falling with the spirit and scope of the present invention as defined be the appended claims.</p><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>Turning now to FIG. 1, a block diagram of one embodiment of a processor <b>10</b> is shown. Other embodiments are possible and contemplated. As shown in FIG. 1, processor <b>10</b> includes a prefetch/predecode unit <b>12</b>, a branch prediction unit <b>14</b>, an instruction cache <b>16</b>, an instruction alignment unit <b>18</b>, a plurality of decode units <b>20</b>A-<b>20</b>C, a plurality of reservation stations <b>22</b>A-<b>22</b>C, a plurality of functional units <b>24</b>A-<b>24</b>C, a load/store unit <b>26</b>, a data cache <b>28</b>, a register file <b>30</b>, a reorder buffer <b>32</b>, an MROM unit <b>34</b>, and a bus interface unit <b>37</b>. Elements referred to herein with a particular reference number followed by a letter will be collectively referred to by the reference number alone. For example, decode units <b>20</b>A-<b>20</b>C will be collectively referred to as decode units <b>20</b>.</p><p>Prefetch/predecode unit <b>12</b> is coupled to receive instructions from bus interface unit <b>37</b>, and is further coupled to instruction cache <b>16</b> and branch prediction unit <b>14</b>. Similarly, branch prediction unit <b>14</b> is coupled to instruction cache <b>16</b>. Still further, branch prediction unit <b>14</b> is coupled to decode units <b>20</b> and functional units <b>24</b>. Instruction cache <b>16</b> is further coupled to MROM unit <b>34</b> and instruction alignment unit <b>18</b>. Instruction alignment unit <b>18</b> is in turn coupled to decode units <b>20</b>. Each decode unit <b>20</b>A-<b>20</b>C is coupled to load/store unit <b>26</b> and to respective reservation stations <b>22</b>A-<b>22</b>C. Reservation stations <b>22</b>A-<b>22</b>C are further coupled to respective functional units <b>24</b>A-<b>24</b>C. Additionally, decode units <b>20</b> and reservation stations <b>22</b> are coupled to register file <b>30</b> and reorder buffer <b>32</b>. Functional units <b>24</b> are coupled to load/store unit <b>26</b>, register file <b>30</b>, and reorder buffer <b>32</b> as well. Data cache <b>28</b> is coupled to load/store unit <b>26</b> and to bus interface unit <b>37</b>. Bus interface unit <b>37</b> is further coupled to an L<b>2</b> interface to an L<b>2</b> cache and a bus. Finally, MROM unit <b>34</b> is coupled to decode units <b>20</b>.</p><p>Instruction cache <b>16</b> is a high speed cache memory provided to store instructions. Instructions are fetched from instruction cache <b>16</b> and dispatched to decode units <b>20</b>. In one embodiment, instruction cache <b>16</b> is configured to store up to 64 kilobytes of instructions in a 2 way set associative structure having 64 byte lines (a byte comprises 8 binary bits). Alternatively, any other desired configuration and size may be employed. For example, it is noted that instruction cache <b>16</b> may be implemented as a fully associative, set associative, or direct mapped configuration.</p><p>Instructions are stored into instruction cache <b>16</b> by prefetch/predecode unit <b>12</b>. Instructions may be prefetched prior to the request thereof from instruction cache <b>16</b> in accordance with a prefetch scheme. A variety of prefetch schemes may be employed by prefetch/predecode unit <b>12</b>. As prefetch/predecode unit <b>12</b> transfers instructions to instruction cache <b>16</b>, prefetch/predecode unit <b>12</b> generates three predecode bits for each byte of the instructions: a start bit, an end bit, and a functional bit. The predecode bits form tags indicative of the boundaries of each instruction. The predecode tags may also convey additional information such as whether a given instruction can be decoded directly by decode units <b>20</b> or whether the instruction is executed by invoking a microcode procedure controlled by MROM unit <b>34</b>, as will be described in greater detail below. Still further, prefetch/predecode unit <b>12</b> may be configured to detect branch instructions and to store branch prediction information corresponding to the branch instructions into branch prediction unit <b>14</b>. Other embodiments may employ any suitable predecode scheme.</p><p>One encoding of the predecode tags for an embodiment of processor <b>10</b> employing a variable byte length instruction set will next be described. A variable byte length instruction set is an instruction set in which different instructions may occupy differing numbers of bytes. An exemplary variable byte length instruction set employed by one embodiment of processor <b>10</b> is the x86 instruction set.</p><p>In the exemplary encoding, if a given byte is the first byte of an instruction, the start bit for that byte is set. If the byte is the last byte of an instruction, the end bit for that byte is set. Instructions which may be directly decoded by decode units <b>20</b> are referred to as \u201cfast path\u201d instructions. The remaining x86 instructions are referred to as MROM instructions, according to one embodiment. For fast path instructions, the functional bit is set for each prefix byte included in the instruction, and cleared for other bytes. Alternatively, for MROM instructions, the functional bit is cleared for each prefix byte and set for other bytes. The type of instruction may be determined by examining the functional bit corresponding to the end byte. If that functional bit is clear, the instruction is a fast path instruction. Conversely, if that functional bit is set, the instruction is an MROM instruction. The opcode of an instruction may thereby be located within an instruction which may be directly decoded by decode units <b>20</b> as the byte associated with the first clear functional bit in the instruction. For example, a fast path instruction including two prefix bytes, a Mod R/M byte, and an immediate byte would have start, end, and functional bits as follows:</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"offset\" colwidth=\"49pt\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"91pt\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"77pt\"></colspec><thead><row><entry></entry><entry align=\"center\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></thead><tbody valign=\"top\"><row><entry></entry><entry>Start bits</entry><entry>10000</entry></row><row><entry></entry><entry>End bits</entry><entry>00001</entry></row><row><entry></entry><entry>Functional bits</entry><entry>11000</entry></row><row><entry></entry><entry align=\"center\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\"></entry></row></tbody></tgroup></table></tables></p><p>MROM instructions are instructions which are determined to be too complex for decode by decode units <b>20</b>. MROM instructions are executed by invoking MROM unit <b>34</b>. More specifically, when an MROM instruction is encountered, MROM unit <b>34</b> parses and issues the instruction into a subset of defined fast path instructions to effectuate the desired operation. MROM unit <b>34</b> dispatches the subset of fast path instructions to decode units <b>20</b>.</p><p>Processor <b>10</b> employs branch prediction in order to speculatively fetch instructions subsequent to conditional branch instructions. Branch prediction unit <b>14</b> is included to perform branch prediction operations. In one embodiment, branch prediction unit <b>14</b> employs a branch target buffer which caches up to two branch target addresses and corresponding taken/not taken predictions per 16 byte portion of a cache line in instruction cache <b>16</b>. The branch target buffer may, for example, comprise 2048 entries or any other suitable number of entries. Prefetch/predecode unit <b>12</b> determines initial branch targets when a particular line is predecoded. Subsequent updates to the branch targets corresponding to a cache line may occur due to the execution of instructions within the cache line. Instruction cache <b>16</b> provides an indication of the instruction address being fetched, so that branch prediction unit <b>14</b> may determine which branch target addresses to select for forming a branch prediction. Decode units <b>20</b> and functional units <b>24</b> provide update information to branch prediction unit <b>14</b>. Decode units <b>20</b> detect branch instructions which were not predicted by branch prediction unit <b>14</b>. Functional units <b>24</b> execute the branch instructions and determine if the predicted branch direction is incorrect. The branch direction may be \u201ctaken\u201d, in which subsequent instructions are fetched from the target address of the branch instruction. Conversely, the branch direction may be \u201cnot taken\u201d, in which subsequent instructions are fetched from memory locations consecutive to the branch instruction. When a mispredicted branch instruction is detected, instructions subsequent to the mispredicted branch are discarded from the various units of processor <b>10</b>. In an alternative configuration, branch prediction unit <b>14</b> may be coupled to reorder buffer <b>32</b> instead of decode units <b>20</b> and functional units <b>24</b>, and may receive branch misprediction information from reorder buffer <b>32</b>. A variety of suitable branch prediction algorithms may be employed by branch prediction unit <b>14</b>.</p><p>Instructions fetched from instruction cache <b>16</b> are conveyed to instruction alignment unit <b>18</b>. As instructions are fetched from instruction cache <b>16</b>, the corresponding predecode data is scanned to provide information to instruction alignment unit <b>18</b> (and to MROM unit <b>34</b>) regarding the instructions being fetched. Instruction alignment unit <b>18</b> utilizes the scanning data to align an instruction to each of decode units <b>20</b>. In one embodiment, instruction alignment unit <b>18</b> aligns instructions from three sets of eight instruction bytes to decode units <b>20</b>. Decode unit <b>20</b>A receives an instruction which is prior to instructions concurrently received by decode units <b>20</b>B and <b>20</b>C (in program order). Similarly, decode unit <b>20</b>B receives an instruction which is prior to the instruction concurrently received by decode unit <b>20</b>C in program order.</p><p>Decode units <b>20</b> are configured to decode instructions received from instruction alignment unit <b>18</b>. Register operand information is detected and routed to register file <b>30</b> and reorder buffer <b>32</b>. Additionally, if the instructions require one or more memory operations to be performed, decode units <b>20</b> dispatch the memory operations to load/store unit <b>26</b>. Each instruction is decoded into a set of control values for functional units <b>24</b>, and these control values are dispatched to reservation stations <b>22</b> along with operand address information and displacement or immediate data which may be included with the instruction. In one particular embodiment, each instruction is decoded into up to two operations which may be separately executed by functional units <b>24</b>A-<b>24</b>C.</p><p>Processor <b>10</b> supports out of order execution, and thus employs reorder buffer <b>32</b> to keep track of the original program sequence for register read and write operations, to implement register renaming, to allow for speculative instruction execution and branch misprediction recovery, and to facilitate precise exceptions. A temporary storage location within reorder buffer <b>32</b> is reserved upon decode of an instruction that involves the update of a register to thereby store speculative register states. If a branch prediction is incorrect, the results of speculatively-executed instructions along the mispredicted path can be invalidated in the buffer before they are written to register file <b>30</b>. Similarly, if a particular instruction causes an exception, instructions subsequent to the particular instruction may be discarded. In this manner, exceptions are \u201cprecise\u201d (i.e. instructions subsequent to the particular instruction causing the exception are not completed prior to the exception). It is noted that a particular instruction is speculatively executed if it is executed prior to instructions which precede the particular instruction in program order. Preceding instructions may be a branch instruction or an exception-causing instruction, in which case the speculative results may be discarded by reorder buffer <b>32</b>.</p><p>The instruction control values and immediate or displacement data provided at the outputs of decode units <b>20</b> are routed directly to respective reservation stations <b>22</b>. In one embodiment, each reservation station <b>22</b> is capable of holding instruction information (i.e., instruction control values as well as operand values, operand tags and/or immediate data) for up to six pending instructions awaiting issue to the corresponding functional unit. It is noted that for the embodiment of FIG. 1, each reservation station <b>22</b> is associated with a dedicated functional unit <b>24</b>. Accordingly, three dedicated \u201cissue positions\u201d are formed by reservation stations <b>22</b> and functional units <b>24</b>. In other words, issue position <b>0</b> is formed by reservation station <b>22</b>A and functional unit <b>24</b>A. Instructions aligned and dispatched to reservation station <b>22</b>A are executed by functional unit <b>24</b>A. Similarly, issue position <b>1</b> is formed by reservation station <b>22</b>B and functional unit <b>24</b>B; and issue position <b>2</b> is formed by reservation station <b>22</b>C and functional unit <b>24</b>C.</p><p>Upon decode of a particular instruction, if a required operand is a register location, register address information is routed to reorder buffer <b>32</b> and register file <b>30</b> simultaneously. Those of skill in the art will appreciate that the x86 register file includes eight 32 bit real registers (i.e., typically referred to as EAX, EBX, ECX, EDX, EBP, ESI, EDI and ESP). In embodiments of processor <b>10</b> which employ the x86 processor architecture, register file <b>30</b> comprises storage locations for each of the 32 bit real registers. Additional storage locations may be included within register file <b>30</b> for use by MROM unit <b>34</b>. Reorder buffer <b>32</b> contains temporary storage locations for results which change the contents of these registers to thereby allow out of order execution. A temporary storage location of reorder buffer <b>32</b> is reserved for each instruction which, upon decode, is determined to modify the contents of one of the real registers. Therefore, at various points during execution of a particular program, reorder buffer <b>32</b> may have one or more locations which contain the speculatively executed contents of a given register. If following decode of a given instruction it is determined that reorder buffer <b>32</b> has a previous location or locations assigned to a register used as an operand in the given instruction, the reorder buffer <b>32</b> forwards to the corresponding reservation station either: 1) the value in the most recently assigned location, or 2) a tag for the most recently assigned location if the value has not yet been produced by the functional unit that will eventually execute the previous instruction. If reorder buffer <b>32</b> has a location reserved for a given register, the operand value (or reorder buffer tag) is provided from reorder buffer <b>32</b> rather than from register file <b>30</b>. If there is no location reserved for a required register in reorder buffer <b>32</b>, the value is taken directly from register file <b>30</b>. If the operand corresponds to a memory location, the operand value is provided to the reservation station through load/store unit <b>26</b>.</p><p>In one particular embodiment, reorder buffer <b>32</b> is configured to store and manipulate concurrently decoded instructions as a unit. This configuration will be referred to herein as \u201cline-oriented\u201d. By manipulating several instructions together, the hardware employed within reorder buffer <b>32</b> may be simplified. For example, a line-oriented reorder buffer included in the present embodiment allocates storage sufficient for instruction information pertaining to three instructions (one from each decode unit <b>20</b>) whenever one or more instructions are dispatched by decode units <b>20</b>. By contrast, a variable amount of storage is allocated in conventional reorder buffers, dependent upon the number of instructions actually dispatched. A comparatively larger number of logic gates may be required to allocate the variable amount of storage. When each of the concurrently decoded instructions has executed, the instruction results are stored into register file <b>30</b> simultaneously. The storage is then free for allocation to another set of concurrently decoded instructions. Additionally, the amount of control logic circuitry employed per instruction is reduced because the control logic is amortized over several concurrently decoded instructions. A reorder buffer tag identifying a particular instruction may be divided into two fields: a line tag and an offset tag. The line tag identifies the set of concurrently decoded instructions including the particular instruction, and the offset tag identifies which instruction within the set corresponds to the particular instruction. It is noted that storing instruction results into register file <b>30</b> and freeing the corresponding storage is referred to as \u201cretiring\u201d the instructions. It is further noted that any reorder buffer configuration may be employed in various embodiments of processor <b>10</b>.</p><p>As noted earlier, reservation stations <b>22</b> store instructions until the instructions are executed by the corresponding functional unit <b>24</b>. An instruction is selected for execution if: (i) the operands of the instruction have been provided; and (ii) the operands have not yet been provided for instructions which are within the same reservation station <b>22</b>A-<b>22</b>C and which are prior to the instruction in program order. It is noted that when an instruction is executed by one of the functional units <b>24</b>, the result of that instruction is passed directly to any reservation stations <b>22</b> that are waiting for that result at the same time the result is passed to update reorder buffer <b>32</b> (this technique is commonly referred to as \u201cresult forwarding\u201d) . An instruction may be selected for execution and passed to a functional unit <b>24</b>A-<b>24</b>C during the clock cycle that the associated result is forwarded. Reservation stations <b>22</b> route the forwarded result to the functional unit <b>24</b> in this case. In embodiments in which instructions may be decoded into multiple operations to be executed by functional units <b>24</b>, the operations may be scheduled separately from each other.</p><p>In one embodiment, each of the functional units <b>24</b> is configured to perform integer arithmetic operations of addition and subtraction, as well as shifts, rotates, logical operations, and branch operations. The operations are performed in response to the control values decoded for a particular instruction by decode units <b>20</b>. It is noted that a floating point unit (not shown) may also be employed to accommodate floating point operations. The floating point unit may be operated as a coprocessor, receiving instructions from MROM unit <b>34</b> or reorder buffer <b>32</b> and subsequently communicating with reorder buffer <b>32</b> to complete the instructions. Additionally, functional units <b>24</b> may be configured to perform address generation for load and store memory operations performed by load/store unit <b>26</b>. In one particular embodiment, each functional unit <b>24</b> may comprise an address generation unit for generating addresses and an execute unit for performing the remaining functions. The two units may operate independently upon different instructions or operations during a clock cycle.</p><p>Each of the functional units <b>24</b> also provides information regarding the execution of conditional branch instructions to the branch prediction unit <b>14</b>. If a branch prediction was incorrect, branch prediction unit <b>14</b> flushes instructions subsequent to the mispredicted branch that have entered the instruction processing pipeline, and causes fetch of the required instructions from instruction cache <b>16</b> or main memory. It is noted that in such situations, results of instructions in the original program sequence which occur after the mispredicted branch instruction are discarded, including those which were speculatively executed and temporarily stored in load/store unit <b>26</b> and reorder buffer <b>32</b>. It is further noted that branch execution results may be provided by functional units <b>24</b> to reorder buffer <b>32</b>, which may indicate branch mispredictions to functional units <b>24</b>.</p><p>Results produced by functional units <b>24</b> are sent to reorder buffer <b>32</b> if a register value is being updated, and to load/store unit <b>26</b> if the contents of a memory location are changed. If the result is to be stored in a register, reorder buffer <b>32</b> stores the result in the location reserved for the value of the register when the instruction was decoded. A plurality of result buses <b>38</b> are included for forwarding of results from functional units <b>24</b> and load/store unit <b>26</b>. Result buses <b>38</b> convey the result generated, as well as the reorder buffer tag identifying the instruction being executed.</p><p>Load/store unit <b>26</b> provides an interface between functional units <b>24</b> and data cache <b>28</b>. In one embodiment, load/store unit <b>26</b> is configured with a first load/store buffer having storage locations for data and address information for pending loads or stores which have not accessed data cache <b>28</b> and a second load/store buffer having storage locations for data and address information for loads and stores which have access data cache <b>28</b>. For example, the first buffer may comprise <b>12</b> locations and the second buffer may comprise <b>32</b> locations. Decode units <b>20</b> arbitrate for access to the load/store unit <b>26</b>. When the first buffer is fill, a decode unit must wait until load/store unit <b>26</b> has room for the pending load or store request information. Load/store unit <b>26</b> also performs dependency checking for load memory operations against pending store memory operations to ensure that data coherency is maintained. A memory operation is a transfer of data between processor <b>10</b> and the main memory subsystem. Memory operations may be the result of an instruction which utilizes an operand stored in memory, or may be the result of a load/store instruction which causes the data transfer but no other operation. Additionally, load/store unit <b>26</b> may include a special register storage for special registers such as the segment registers and other registers related to the address translation mechanism defined by the x86 processor architecture.</p><p>Data cache <b>28</b> is a high speed cache memory provided to temporarily store data being transferred between load/store unit <b>26</b> and the main memory subsystem. In one embodiment, data cache <b>28</b> has a capacity of storing up to 64 kilobytes of data in an two way set associative structure. It is understood that data cache <b>28</b> may be implemented in a variety of specific memory configurations, including a set associative configuration, a fully associative configuration, a direct-mapped configuration, and any suitable size of any other configuration.</p><p>In one particular embodiment of processor <b>10</b> employing the x86 processor architecture, instruction cache <b>16</b> and data cache <b>28</b> are linearly addressed and physically tagged. The linear address is formed from the offset specified by the instruction and the base address specified by the segment portion of the x86 address translation mechanism. Linear addresses may optionally be translated to physical addresses for accessing a main memory. The linear to physical translation is specified by the paging portion of the x86 address translation mechanism. The physical address is compared to the physical tags to determine a hit/miss status.</p><p>Bus interface unit <b>37</b> is configured to communicate between processor <b>10</b> and other components in a computer system via a bus. For example, the bus may be compatible with the EV-6 bus developed by Digital Equipment Corporation. Alternatively, any suitable interconnect structure may be used including packet-based, unidirectional or bi-directional links, etc. An optional L<b>2</b> cache interface may be employed as well for interfacing to a level two cache.</p><p>Moving now to FIG. 2, a block diagram of one embodiment of a portion of processor <b>10</b> which employs a TLB flush filter is shown. TLB flush filter <b>40</b> is coupled to load/store unit <b>26</b>, bus interface unit <b>37</b>, L<b>1</b> cache <b>25</b>, and TLB <b>39</b>. L<b>1</b> cache <b>25</b> may include, for example, an instruction cache <b>16</b> and a data cache <b>28</b>. In some embodiments, instruction cache <b>16</b> and data cache <b>28</b> of L<b>1</b> cache <b>25</b> may each be associated with their own separate TLB. These TLBs may be integrated into each cache. Load/store unit <b>26</b> is coupled to register file <b>30</b>. Among the registers of register file <b>30</b> is a base address register <b>301</b>. Base address register <b>301</b> may store a base address of a page table for the currently running context. Alternatively, base address register <b>301</b> may store a base address of a page directory pointer table, or other address information associated with the currently running context. Base address register <b>301</b> may be updated during a context switch.</p><p>TLB flush filter <b>40</b> is configured to monitor blocks of memory which include address translations that may be loaded into TLB <b>39</b>. If TLB flush filter <b>40</b> detects changes to one or more address translations in the monitored blocks of memory, it may then allow TLB <b>39</b> to be flushed following the next context switch. In the embodiment shown, TLB flush filter may assert an Invalidate signal in order to allow a flush of TLB <b>39</b>. Load/store unit <b>26</b> may also cause TLB <b>39</b> to be flushed by asserting a signal (shown here as LS_TLBInvalidate). This signal, when asserted by load/store unit <b>26</b> may cause an unconditional flush of TLB <b>39</b>, or allow the TLB to be flushed on the next context switch. Some of the possible causes of an unconditional flush will be discussed below with reference to FIG. <b>5</b>.</p><p>TLB flush filter <b>40</b> may be activated by a first context switch. This first context switch may occur after initial boot of a computer system, or following a deactivation of the flush filter. The first context switch may result in a flush of TLB <b>39</b>. Subsequent to the first context switch, flushes of TLB <b>39</b> may be filtered by TLB flush filter <b>40</b>.</p><p>TLB flush filter <b>40</b> is coupled to bus interface unit <b>37</b>, and may receive information concerning those blocks of memory that it monitors. In the embodiment shown, TLB flush filter <b>40</b> may receive a page directory entry from bus interface unit <b>37</b>. In various embodiments, TLB flush filter <b>40</b> may also receive information concerning page directory entries, page directory pointers, page tables, or other data structures which may be used for address translations. Generally, any address of a block of memory storing address translation info may be provided to TLB flush filter <b>40</b> by bus interface unit <b>37</b>. TLB flush filter <b>40</b> may also receive a snoop (or probe) request signal from bus interface unit <b>37</b>, as well as a snoop address, for searches of a region table (as will be detailed below). TLB flush filter <b>40</b> may also receive notification from load/store unit <b>26</b> when a context switch occurs, as the load/store unit may propagate the new address stored in base address register <b>301</b> around the special register bus (SRB) ring.</p><p>In general, the SRB ring is a bus that may be used for communication with special registers. A variety of special registers may be located in various units throughout the processor. In the embodiment shown, load/store unit <b>26</b> serves as a bus master for the SRB ring, and may thereby control read and write operations involving special registers. The implementation of the SRB ring may allow special registers to be placed closer to the logic which uses them, and yet still under control of load/store unit <b>26</b>.</p><p>Turning now to FIG. 3, a block diagram of one embodiment of a TLB flush filter is shown. TLB flush filter <b>40</b> includes a ring node <b>401</b>, region table <b>402</b>, and filter circuit <b>403</b>. Filter circuit <b>403</b> is coupled to TLB <b>39</b>, and may assert a signal to invalidate, or flush, the TLB. Region table <b>402</b> includes a content addressable memory (CAM) and a random access memory (RAM. The CAM portion of region table <b>402</b> may be used to store addresses, such as page directory pointers, as well as associated tags, and may store base addresses from base address register <b>301</b> (of FIG. 2) as well. The RAM portion of the region table typically stores a tag associated with the base address from base address register <b>301</b>. CAM and RAM entries will be discussed in further detail below.</p><p>Entries into region table <b>401</b> may be received by TLB flush filter <b>40</b> through ring node <b>401</b>, and multiplexers <b>407</b>. Multiplexers <b>407</b> may also used to receive other information, such as page directory entry (PDE) attributes, as shown here. Information received through multiplexers <b>407</b> may then be stored in either the CAM or the RAM. Information from region table <b>402</b> may also be propagated into the SRB ring through ring node <b>401</b>.</p><p>Two counters are also associated with region table <b>402</b>. Region counter <b>404</b> is configured to count the number of entries in the CAM, while base address register counter <b>405</b> is configured to count the number of base address register tags. Each of these counters tracks the available resources in the region table. If the region table runs out of available resources, one of the counters may assert an overflow signal. For example, if each CAM entry is fill, the region counter may assert an overflow signal. This overflow signal may be used to deactivate the TLB flush filter. Similarly, if all available tags have been used for the base address register counter, it may overflow as well, thereby asserting an overflow signal which may deactivate the TLB flush filter. The first context switch following the deactivation of TLB flush filter <b>40</b> may then result in a TLB flush. When TLB flush filter <b>40</b> is deactivated, both counters may be reset by control logic <b>406</b>.</p><p>As previously stated, region table <b>402</b> is configured to store a plurality of entries during operation of TLB flush filter <b>40</b>. Entries in region table <b>402</b> may be used to detect modifications to page tables or other data structures that may be used to load address translations into TLB <b>39</b>. To detect when the page tables or other data structures have changed, bus interface unit <b>37</b> (of FIG. 1) may probe (i.e. snoop) the region table. The probing of the region table may be a function of a coherency protocol within the processor. Generally, the snoop address is compared to the addresses recorded in the region table (e.g. the CAM). If the probe of the region table results in a hit, and the probe is for a memory access that would modify the data in a memory block being monitored by TLB flush filter <b>40</b> (indicating a potential modification of the data used to load address translations into the TLB), then the next context switch may result in a flush of TLB <b>39</b>. In the embodiment shown, a flush of TLB may occur when filter circuit <b>403</b> asserts an Invalidate signal, thereby invalidating all entries currently stored in TLB <b>39</b>. Typically, a hit results when a search of the region table results in a match for one of the entries stored in the CAM. If no hit results from the probe, TLB flush filter <b>40</b> may prevent a TLB flush following the next context switch.</p><p>Moving now to FIG. 4, a diagram illustrating region table entries for one embodiment of the TLB flush filter is shown. Each region table entry includes a CAM entry <b>402</b>-C and a RAM entry <b>402</b>-R. CAM entry <b>402</b>-C includes a valid bit (V), a page directory pointer (PDP) bit, and a tag. In various other embodiments, CAM entries may also include other types of information associated with a memory address, such as attribute and protection information. The tag of CAM entry <b>402</b>-C is typically an address corresponding to an address translation that is present in the TLB. This address may be, for example, a page directory pointer, or a page table pointer from a page directory entry, or a base address from the base address register. In one embodiment, the address may be a linear address that corresponds to a physical address in memory. If the address indicated by the tag is for a page directory pointer, the PDP bit may be set. If the address indicated by the tag is for a page directory entry, the PDP bit may be clear. The valid bit may be set to indicate that the address indicated by the tag is valid for an address translation stored in either the TLB or a page table. The addresses stored in the CAM entry may be probed by a bus interface unit as described above, thereby allowing TLB flush filter <b>40</b> to determine if any modifications have occurred to a page table or other data structure from which address translations have been loaded into the TLB.</p><p>RAM entry <b>402</b>-R includes a valid bit and a base address register tag. In the embodiment shown, the base address register tag may be associated with a base address register entry that may be stored in the CAM. The base address value stored in the CAM may be the base address for a page table (or other data structure) of a previously encountered context or the currently running context. The base address register tag in this embodiment is simply a number that corresponds to the base address. Following each change of the base address register (which typically occurs with each context switch), the new value of the register is compared with older values that have occurred since the last TLB flush which are stored in the region table. If no match is found (i.e. a miss), the value of the register may be assigned a tag and stored in the CAM, with the associated tag stored in the RAM. A match indicates that the current value of the register is already stored in the region table. Thus, if a previously encountered context is resumed by the processor, the previously used address translations may be used again. No new tag need be assigned if there is a match.</p><p>FIG. 5 is a logic diagram illustrating the logic for operating one embodiment of the filter circuit <b>403</b>. Filter circuit <b>403</b> includes logic that allows a flush of the TLB to occur only when certain conditions are met. Filter circuit <b>403</b> is configured to receive LS_TLBInvalidate and LS_TLBInvalidateM signals from load/store unit <b>26</b> of FIG. <b>1</b>. The LS_TLBInvalidate signal may cause an unconditional flush of the TLB, regardless of whether the TLB flush filter is activated. Various changes in the operation of the processor may necessitate a flush of the TLB. These conditions include, but are not limited to, turning off paging, turning on global paging, changing of memory types or changing memory attributes. When asserted, the LS_TLBInvalidate signal may propagate through the OR gate and the D flip-flop shown in the diagram. This may then cause the FF_TLBInvalidate signal to be asserted (this signal is equivalent to the Invalidate signal shown in FIGS. 2 and 3) , thereby allowing a flush of the TLB following the next context switch.</p><p>The LS_TLBInvalidateM signal may be used to indicate that the TLB is to be flushed if a modification has occurred. This signal may be held in a logic high state when the TLB flush filter is activated. A modification may include changes to underlying address translations or a change in status of the flush filter (such as when the counters overflow). The FF_TLBInvalidate signal may be asserted when LS_TLBInvalidateM signals is asserted as a logic high and the /CLR signal is asserted low (and inverted prior to its input into the AND gate).</p><p>The /CLR signal may be driven to a logic low state by one of several different conditions. These conditions may vary with alternative embodiments. In the embodiment shown, such conditions may include a reset of the flush filter (Reset signal), a modification of page data (Modify Page Data signal, shown as the Hit signal in FIG. <b>3</b>), an overflow of either of the counters (Overflow Region Counter signal, Overflow Base Address Register Counter signal), or a signal to disable the flush filter (Disable Flush Filter signal). Signals for each of these conditions are present in the logic circuit of FIG. <b>5</b>. The /CLR signal is typically held in a logic high state in the embodiment shown, and may propagate through a feedback circuit (including an OR gate) to become an input to the 7-input AND gate shown in the drawing. The FF_TLBInvalidate signal may also propagate through a feedback circuit and through the OR gate when it is asserted. Driving any of the conditional to a logic high state may result in a logic low input to the AND gate (due to the inverters), thereby causing the /CLR signal to be asserted in its logic low state.</p><p>Moving now to FIG. 6, a timing diagram illustrating the operation of one embodiment of the TLB flush filter is shown. The diagram is intended to show the basic operation of the flush filter by way of example, and is not intended to cover all possible conditions or results that may occur. Furthermore, the diagram is not intended to characterize specific implementational details of the flush filter, which may vary with different embodiments.</p><p>The TLB flush filter may be initially activated by a first context switch. Since the flush filter was not activated prior to the first context switch, an unfiltered flush of the TLB may result. Following the first context switch, page table A is loaded into memory. Page table A is associated with the new context, and thus entries corresponding to this page table may be loaded into the region table of FIG. 3 as corresponding address translations are loaded into the TLB. Following the loading of page table A, another context switch occurs. In this case, a flush of the TLB may be prevented by the activated TLB flush filter. This may indicate that no condition which would necessitate a flush occurred between context switches. In the example shown, no modifications were made to page table A between context switches.</p><p>Following the second context switch, page table B is loaded into memory. Page table B may contain address translations, some of which may be loaded into the TLB. Following the loading of page table B into memory, page table B is modified. As such, it is possible that some address translations loaded into the TLB from page table B are no longer valid. Consequently, the TLB flush filter may allow a TLB flush (shown here as a filtered flush) to occur following the next context switch.</p><p>The next event to occur following the filtered flush is a loading of page table C. As discussed in reference to FIG. 3, a region counter keeps track of the CAM portion of the region table, and may overflow if the region table runs out of space for more entries. In the diagram shown, this occurs following the loading of page table C, causing the region counter to overflow. An overflow of the region counter may cause the deactivation of the TLB flush filter. Upon the first context switch following deactivation, the TLB may be flushed. This first context switch may also cause a re-activation of the TLB flush filter.</p><p>FIGS. 7A and 7B are block diagrams illustrating a paging structure covered by entries in a region table, and a region table with entries corresponding to the paging structure for one embodiment of TLB flush filter <b>40</b>. In FIG. 7A, base address register <b>301</b> may store an address which points to a region (R<sub>0</sub>) of page directory pointers. Each entry in the region points to a page directory.</p><p>Turning now to FIG. 8, a block diagram of one embodiment of a computer system <b>200</b> including processor <b>10</b> coupled to a variety of system components through a bus bridge <b>202</b> is shown. Other embodiments are possible and contemplated. In the depicted system, a main memory <b>204</b> is coupled to bus bridge <b>202</b> through a memory bus <b>206</b>, and a graphics controller <b>208</b> is coupled to bus bridge <b>202</b> through an AGP bus <b>210</b>. Finally, a plurality of PCI devices <b>212</b>A-<b>212</b>B are coupled to bus bridge <b>202</b> through a PCI bus <b>214</b>. A secondary bus bridge <b>216</b> may further be provided to accommodate an electrical interface to one or more EISA or ISA devices <b>218</b> through an EISA/ISA bus <b>220</b>. Processor <b>10</b> is coupled to bus bridge <b>202</b> through a CPU bus <b>224</b> and to an optional L<b>2</b> cache <b>228</b>.</p><p>Bus bridge <b>202</b> provides an interface between processor <b>10</b>, main memory <b>204</b>, graphics controller <b>208</b>, and devices attached to PCI bus <b>214</b>. When an operation is received from one of the devices connected to bus bridge <b>202</b>, bus bridge <b>202</b> identifies the target of the operation (e.g. a particular device or, in the case of PCI bus <b>214</b>, that the target is on PCI bus <b>214</b>) . Bus bridge <b>202</b> routes the operation to the targeted device. Bus bridge <b>202</b> generally translates an operation from the protocol used by the source device or bus to the protocol used by the target device or bus.</p><p>In addition to providing an interface to an ISA/EISA bus for PCI bus <b>214</b>, secondary bus bridge <b>216</b> may further incorporate additional functionality, as desired. An input/output controller (not shown), either external from or integrated with secondary bus bridge <b>216</b>, may also be included within computer system <b>200</b> to provide operational support for a keyboard and mouse <b>222</b> and for various serial and parallel ports, as desired. An external cache unit (not shown) may further be coupled to CPU bus <b>224</b> between processor <b>10</b> and bus bridge <b>202</b> in other embodiments. Alternatively, the external cache may be coupled to bus bridge <b>202</b> and cache control logic for the external cache may be integrated into bus bridge <b>202</b>. L<b>2</b> cache <b>228</b> is further shown in a backside configuration to processor <b>10</b>. It is noted that L<b>2</b> cache <b>228</b> may be separate from processor <b>10</b>, integrated into a cartridge (e.g. slot <b>1</b> or slot A) with processor <b>10</b>, or even integrated onto a semiconductor substrate with processor <b>10</b>.</p><p>Main memory <b>204</b> is a memory in which application programs are stored and from which processor <b>10</b> primarily executes. A suitable main memory <b>204</b> comprises DRAM (Dynamic Random Access Memory). For example, a plurality of banks of SDRAM (Synchronous DRAM) or Rambus DRAM (RDRAM) may be suitable.</p><p>PCI devices <b>212</b>A-<b>212</b>B are illustrative of a variety of peripheral devices such as, for example, network interface cards, video accelerators, audio cards, hard or floppy disk drives or drive controllers, SCSI (Small Computer Systems Interface) adapters and telephony cards. Similarly, ISA device <b>218</b> is illustrative of various types of peripheral devices, such as a modem, a sound card, and a variety of data acquisition cards such as GPIB or field bus interface cards.</p><p>Graphics controller <b>208</b> is provided to control the rendering of text and images on a display <b>226</b>. Graphics controller <b>208</b> may embody a typical graphics accelerator generally known in the art to render three-dimensional data structures which can be effectively shifted into and from main memory <b>204</b>. Graphics controller <b>208</b> may therefore be a master of AGP bus <b>210</b> in that it can request and receive access to a target interface within bus bridge <b>202</b> to thereby obtain access to main memory <b>204</b>. A dedicated graphics bus accommodates rapid retrieval of data from main memory <b>204</b>. For certain operations, graphics controller <b>208</b> may flirter be configured to generate PCI protocol transactions on AGP bus <b>210</b>. The AGP interface of bus bridge <b>202</b> may thus include functionality to support both AGP protocol transactions as well as PCI protocol target and initiator transactions. Display <b>226</b> is any electronic display upon which an image or text can be presented. A suitable display <b>226</b> includes a cathode ray tube (\u201cCRT\u201d), a liquid crystal display (\u201cLCD\u201d), etc.</p><p>It is noted that, while the AGP, PCI, and ISA or EISA buses have been used as examples in the above description, any bus architectures may be substituted as desired. It is further noted that computer system <b>200</b> may be a multiprocessing computer system including additional processors (e.g. processor <b>10</b><i>a </i>shown as an optional component of computer system <b>200</b>) . Processor <b>10</b><i>a </i>may be similar to processor <b>10</b>. More particularly, processor <b>10</b><i>a </i>may be an identical copy of processor <b>10</b>. Processor <b>10</b><i>a </i>may be connected to bus bridge <b>202</b> via an independent bus (as shown in FIG. 5) or may share CPU bus <b>224</b> with processor <b>10</b>. Furthermore, processor <b>10</b><i>a </i>may be coupled to an optional L<b>2</b> cache <b>228</b><i>a </i>similar to L<b>2</b> cache <b>228</b>.</p><p>While the present invention has been described with reference to particular embodiments, it will be understood that the embodiments are illustrative and that the invention scope is not so limited. Any variations, modifications, additions, and improvements to the embodiments described are possible. These variations, modifications, additions, and improvements may fall within the scope of the inventions as detailed within the following claims.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Gerald D.", "last_name": "Zuraski, Jr.", "name": ""}, {"first_name": "Michael T.", "last_name": "Clark", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}, {"first_name": "", "last_name": "GLOBALFOUNDRIES U.S. INC.", "name": ""}, {"first_name": "", "last_name": "GLOBALFOUNDRIES INC.", "name": ""}, {"first_name": "", "last_name": "GLOBALFOUNDRIES U.S. INC.", "name": ""}, {"first_name": "", "last_name": "WILMINGTON TRUST, NATIONAL ASSOCIATION", "name": ""}, {"first_name": "", "last_name": "GLOBALFOUNDRIES INC.", "name": ""}, {"first_name": "", "last_name": "ADVANCED MICRO DEVICES, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/12"}, {"primary": false, "label": "G06F  12/10"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/10        20060101A I20051008RMUS"}, {"label": "G06F  12/08        20060101ALI20051220RMJP"}], "national_classes": [{"primary": true, "label": "711207"}, {"primary": false, "label": "711E12061"}, {"primary": false, "label": "711135"}], "ecla_classes": [{"label": "G06F  12/10L"}], "cpc_classes": [{"label": "G06F2212/683"}, {"label": "G06F  12/1027"}, {"label": "G06F2212/682"}, {"label": "G06F2212/683"}, {"label": "G06F2212/682"}, {"label": "G06F  12/10"}, {"label": "G06F  12/1027"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "2000-06-15", "application_date": "2000-06-15", "family_members": [{"ucid": "WO-2001097043-A1", "titles": [{"lang": "FR", "text": "FILTRE DE PURGE POUR REPERTOIRE D'ADRESSES ACTIVES"}, {"lang": "EN", "text": "A TRANSLATION LOOKASIDE BUFFER FLUSH FILTER"}]}, {"ucid": "CN-1436332-A", "titles": [{"lang": "EN", "text": "Translation lookaside buffer flush filter"}, {"lang": "ZH", "text": "\u8f6c\u8bd1\u540e\u5907\u7f13\u51b2\u5668\u6e05\u9664\u6ee4\u6ce2\u5668"}]}, {"ucid": "JP-4437001-B2", "titles": [{"lang": "JA", "text": "\u5909\u63db\u7d22\u5f15\u30d0\u30c3\u30d5\u30a1\u306e\u30d5\u30e9\u30c3\u30b7\u30e5\u30d5\u30a3\u30eb\u30bf"}, {"lang": "EN", "text": "Translation index buffer flush filter"}]}, {"ucid": "JP-2004503870-A", "titles": [{"lang": "JA", "text": "\u5909\u63db\u7d22\u5f15\u30d0\u30c3\u30d5\u30a1\u306e\u30d5\u30e9\u30c3\u30b7\u30e5\u30d5\u30a3\u30eb\u30bf"}, {"lang": "EN", "text": "Flush filter for translation index buffer"}]}, {"ucid": "EP-1290562-A1", "titles": [{"lang": "FR", "text": "FILTRE DE PURGE POUR REPERTOIRE D'ADRESSES ACTIVES"}, {"lang": "EN", "text": "A TRANSLATION LOOKASIDE BUFFER FLUSH FILTER"}, {"lang": "DE", "text": "R\u00c4UMUNGSFILTER F\u00dcR ADRESSEN\u00dcBERSETZUNGSPUFFER"}]}, {"ucid": "TW-561341-B", "titles": [{"lang": "EN", "text": "A translation lookaside buffer flush filter"}]}, {"ucid": "KR-20030010727-A", "titles": [{"lang": "KO", "text": "\ubcc0\ud658 \uc0c9\uc778 \ubc84\ud37c \ud50c\ub7ec\uc2dc \ud544\ud130"}, {"lang": "EN", "text": "A TRANSLATION LOOKASIDE BUFFER FLUSH FILTER"}]}, {"ucid": "EP-1290562-B1", "titles": [{"lang": "FR", "text": "FILTRE DE PURGE POUR REPERTOIRE D'ADRESSES ACTIVES"}, {"lang": "EN", "text": "A TRANSLATION LOOKASIDE BUFFER FLUSH FILTER"}, {"lang": "DE", "text": "R\u00c4UMUNGSFILTER F\u00dcR ADRESSEN\u00dcBERSETZUNGSPUFFER"}]}, {"ucid": "KR-100804285-B1", "titles": [{"lang": "KO", "text": "\ubcc0\ud658 \uc0c9\uc778 \ubc84\ud37c \ud50c\ub7ec\uc2dc \ud544\ud130"}, {"lang": "EN", "text": "A TRANSLATION LOOKASIDE BUFFER FLUSH FILTER"}]}, {"ucid": "US-6510508-B1", "titles": [{"lang": "EN", "text": "Translation lookaside buffer flush filter"}]}, {"ucid": "DE-60102017-T2", "titles": [{"lang": "EN", "text": "CLEARING FILTER FOR ADDRESS TRANSLATOR"}, {"lang": "DE", "text": "R\u00c4UMUNGSFILTER F\u00dcR ADRESSEN\u00dcBERSETZUNGSPUFFER"}]}, {"ucid": "DE-60102017-D1", "titles": [{"lang": "EN", "text": "CLEARING FILTER FOR ADDRESS TRANSLATOR"}, {"lang": "DE", "text": "R\u00c4UMUNGSFILTER F\u00dcR ADRESSEN\u00dcBERSETZUNGSPUFFER"}]}, {"ucid": "CN-1304962-C", "titles": [{"lang": "EN", "text": "Translation lookaside buffer flush filter"}, {"lang": "ZH", "text": "\u8f6c\u8bd1\u540e\u5907\u7f13\u51b2\u5668\u6e05\u9664\u6ee4\u6ce2\u5668"}]}]}