{"patent_number": "US-7178013-B1", "publication_id": 75104678, "family_id": 37719791, "publication_date": "2007-02-13", "titles": [{"lang": "EN", "text": "Repeat function for processing of repetitive instruction streams"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA51108747\"><p num=\"p-0001\">A REPEAT instruction for repeated execution of an associated instruction (INST<sub>R</sub>). Once a program counter stores the address for the instruction to be repeated, it remains unchanged until the associated instruction (INST<sub>R</sub>) has been executed the number of times indicated by a COUNT value in a preloaded register, or alternatively, by the REPEAT instruction itself. In this manner, the present invention reduces the number of instruction fetches required to repeatedly execute the associated instruction (INST<sub>R</sub>). Consequently, there is a significant improvement in the efficiency of the program code execution.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00001\" num=\"00001\">\n<claim-text>1. A method of operating a processor to repeatedly execute an instruction in a pre-emptive multi-tasking environment, comprising:\n<claim-text>determining at run time how many times a single instruction is to be repeated;</claim-text>\n<claim-text>loading at run time an existing general purpose register with a count value indicative of the number of times a single instruction is to be executed;</claim-text>\n<claim-text>fetching and executing a REPEAT instruction, the REPEAT instruction indicating the single instruction to be repeatedly re-executed;</claim-text>\n<claim-text>fetching the single instruction;</claim-text>\n<claim-text>repeatedly executing the single instruction for a consecutive number of times as indicated by the count value without refetching the single instruction and without adding a NOP (no operation) instruction;</claim-text>\n<claim-text>adjusting the count value in the register each time the single instruction is executed;</claim-text>\n<claim-text>suspending the repeatedly executing the single instruction step while a second context executes; and</claim-text>\n<claim-text>resuming the repeatedly executing the single instruction after the second context executes;</claim-text>\n<claim-text>wherein contents of an instruction buffer containing the single instruction are locked and preserved while the second context executes.</claim-text>\n</claim-text>\n</claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00002\" num=\"00002\">\n<claim-text>2. A method according to <claim-ref idref=\"CLM-00001\">claim 1</claim-ref>, wherein said count value is stored before execution of said REPEAT instruction.</claim-text>\n</claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00003\" num=\"00003\">\n<claim-text>3. A method according to <claim-ref idref=\"CLM-00001\">claim 1</claim-ref>, wherein said REPEAT instruction includes the count value that is stored in said count register, wherein execution of the REPEAT instruction stores the count value in said count register.</claim-text>\n</claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00004\" num=\"00004\">\n<claim-text>4. A method according to <claim-ref idref=\"CLM-00001\">claim 1</claim-ref>, further comprising:\n<claim-text>incrementing the program counter after the one or more associated instructions have been executed for as many times as indicated by the count value.</claim-text>\n</claim-text>\n</claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00005\" num=\"00005\">\n<claim-text>5. A method according to <claim-ref idref=\"CLM-00001\">claim 1</claim-ref>, wherein the adjusting the count value further comprises:\n<claim-text>decrementing said count value stored in said register each time said one or more associated instructions are executed; and</claim-text>\n<claim-text>determining whether said count value is less than or equal to zero.</claim-text>\n</claim-text>\n</claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00006\" num=\"00006\">\n<claim-text>6. A processor configured to repeatedly execute an instruction in a pre-emptive multi-tasking environment, comprising:\n<claim-text>means for determining at run time how many times a single instruction is to be repeated;</claim-text>\n<claim-text>means for loading at run time an existing general purpose register with a count value indicative of the number of times a single instruction is to be executed;</claim-text>\n<claim-text>means for fetching and executing a REPEAT instruction, the REPEAT instruction indicating the single instruction to be repeatedly re-executed;</claim-text>\n<claim-text>means for fetching the single instruction;</claim-text>\n<claim-text>means for repeatedly executing the single instruction for a consecutive number of times as indicated by the count value without refetching the single instruction and without adding a NOP (no operation) instruction;</claim-text>\n<claim-text>means for adjusting the count value in the register each time the single instruction is executed;</claim-text>\n<claim-text>means for suspending the repeatedly executing the single instruction step while a second context executes; and</claim-text>\n<claim-text>means for resuming the repeatedly executing the single instruction after the second context executes;</claim-text>\n<claim-text>wherein contents of an instruction buffer containing the single instruction are locked and preserved while the second context executes.</claim-text>\n</claim-text>\n</claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00007\" num=\"00007\">\n<claim-text>7. A processor according to <claim-ref idref=\"CLM-00006\">claim 6</claim-ref>, wherein said count value is stored before execution of said REPEAT instruction.</claim-text>\n</claim>"}, {"num": 8, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00008\" num=\"00008\">\n<claim-text>8. A processor according to <claim-ref idref=\"CLM-00006\">claim 6</claim-ref>, wherein said REPEAT instruction includes the count value that is stored in said register, wherein the means for fetching and executing the REPEAT instruction stores the count value in said register.</claim-text>\n</claim>"}, {"num": 9, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00009\" num=\"00009\">\n<claim-text>9. A processor according to <claim-ref idref=\"CLM-00006\">claim 6</claim-ref>, further comprising:\n<claim-text>means for incrementing the program counter after the one or more associated instructions have been executed for as many times as indicated by the count value.</claim-text>\n</claim-text>\n</claim>"}, {"num": 10, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00010\" num=\"00010\">\n<claim-text>10. A processor according to <claim-ref idref=\"CLM-00006\">claim 6</claim-ref>, wherein the means for adjusting the count value further comprises:\n<claim-text>means for decrementing said count value stored in said register each time said one or more associated instructions are executed; and</claim-text>\n<claim-text>means for determining whether said count value is less than or equal to zero.</claim-text>\n</claim-text>\n</claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"CLM-00011\" num=\"00011\">\n<claim-text>11. A processor for repeatedly executing one or more processor instructions, said processor comprising:\n<claim-text>a memory address register associated with a main memory;</claim-text>\n<claim-text>a memory data register associated with the main memory;</claim-text>\n<claim-text>a memory control for generating memory control signals;</claim-text>\n<claim-text>a program counter for storing a memory address location of the main memory where an instruction is to be fetched;</claim-text>\n<claim-text>an instruction register for storing an instruction that is to be executed;</claim-text>\n<claim-text>at least one general purpose register;</claim-text>\n<claim-text>decode and execute control logic for decoding and executing an instruction stored in the instruction register; and</claim-text>\n<claim-text>a state machine for controlling the fetching and repeated execution of one or more associated instructions</claim-text>\n<claim-text>wherein the processor is operating in a pre-emptive multi-tasking environment, further comprising the processor configured to suspend executing the instruction in the instruction register while a second context execute, and the processor is configured to resume executing the instruction in the instruction register after the second context executes;</claim-text>\n<claim-text>wherein contents of an instruction buffer are locked and preserved while the second context executes.</claim-text>\n</claim-text>\n</claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00012\" num=\"00012\">\n<claim-text>12. A processor according to <claim-ref idref=\"CLM-00011\">claim 11</claim-ref>, wherein said general purpose register includes a first register for storing a count value indicative of the number of times the one or more associated instructions are to be repeatedly executed.</claim-text>\n</claim>"}, {"num": 13, "parent": 12, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00013\" num=\"00013\">\n<claim-text>13. A processor according to <claim-ref idref=\"CLM-00012\">claim 12</claim-ref>, wherein said state machine generates signals for decrementing the count value stored in the first register.</claim-text>\n</claim>"}, {"num": 14, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00014\" num=\"00014\">\n<claim-text>14. A processor according to <claim-ref idref=\"CLM-00011\">claim 11</claim-ref>, wherein said state machine generates a signal for executing an instruction stored in said instruction register.</claim-text>\n</claim>"}, {"num": 15, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"CLM-00015\" num=\"00015\">\n<claim-text>15. A processor according to <claim-ref idref=\"CLM-00011\">claim 11</claim-ref>, wherein said state machine generate a signal for incrementing said program counter.</claim-text>\n</claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES16183832\">\n<?BRFSUM description=\"Brief Summary\" end=\"lead\"?>\n<h4>FIELD OF INVENTION</h4>\n<p num=\"p-0002\">The present invention generally relates to a system for executing a series of processor instructions, and more specifically a repeat function for efficient processing of repetitive instruction streams.</p>\n<h4>BACKGROUND OF THE INVENTION</h4>\n<p num=\"p-0003\">It has been recognized that the performance of embedded central processing units (CPUs) has been impaired due to the need for off-chip memory storage devices. In this regard, embedded CPUs typically take the form of a single-chip processor having some peripheral components on the processor chip. Memory associated with the processor for storing instructions and data is typically located off the processor chip. Accordingly, both processor instructions and data must often be read across a common bus (e.g., \u201cVon Neumann bus\u201d) from an off-chip memory storage device. This consumes the bulk of the critical path for items such as \u201cinstruction decode\u201d and \u201cmemory-to-register\u201d data transfers.</p>\n<p num=\"p-0004\">Moreover, off-chip memory storage devices add to the dollar cost of such system incorporating CPUs. Furthermore, off-chip memory storage devices consume valuable real-estate of printed circuit boards (PCBs) which is often at a premium in such arrangements as mini-PCI (Peripheral Component Interconnect) and PCMCIA (Personal Computer Memory Card International Association).</p>\n<p num=\"p-0005\">In addition, power consumption is also greatly increased due to performing off-chip memory accesses, which in turn adversely affects the battery life in a wireless application.</p>\n<p num=\"p-0006\">In view of the foregoing observations, it has been recognized that an ideal design for processing memory transfer instructions, should seek to: (a) minimize the number of off-chip memory instruction fetch accesses to improve data transfer speed and minimize power consumption, and (b) reduce the size of the off-chip memory storage device to minimize use of real-estate area and production costs. These objective are particularly important in the case of wireless applications which use embedded CPUs.</p>\n<p num=\"p-0007\">One way in which the prior art has attempted to address the foregoing problems is by providing an on-chip cache memory. One drawback to this approach is that it adds significant production costs to produce the embedded CPU (e.g., to produce an ASIC). Other drawbacks may include absence of locality-of-reference, coherence problems, and thrashing problems depending on the application.</p>\n<p num=\"p-0008\">Another prior art solution has included the use of dual busses, namely a separate instruction bus and data bus (i.e., \u201cHarvard bus\u201d). One drawback of this approach is that a dual bus system is too power hungry and expensive for many embedded CPU applications. Furthermore, the pins needed to provide dual busses are often not available.</p>\n<p num=\"p-0009\">Other prior art approaches include the use of a \u201clooping\u201d execution method and an \u201cunrolling\u201d execution method to increase data transfer speed. These and other approaches also have significant drawbacks, as will be discussed below.</p>\n<h4>SUMMARY OF THE INVENTION</h4>\n<p num=\"p-0010\">According to the present invention there is provided a method of operating a processor to repeatedly execute at least one associated instruction, the method including the steps of: (a) loading a register with a count value indicative of the number of times the associated instruction is to be executed; (b) fetching and executing a REPEAT instruction indicating the at least one associated instruction to be repeatedly executed; (c) fetching the at least one associated instruction; and (d) executing the at least one associated instruction for as many times as indicated by the count value.</p>\n<p num=\"p-0011\">In accordance with another aspect of the present invention there is provided a method of operating a processor to repeatedly execute one or more instructions, the method including the steps of: (a) fetching a REPEAT instruction; (b) executing a REPEAT instruction, wherein execution of the REPEAT instruction stores in a register a count value indicative of the number of times one or more associated instructions are be executed; (c) fetching the one or more associated instructions; and (d) executing the associated instruction for as many times as indicated by the count value.</p>\n<p num=\"p-0012\">In accordance with still another aspect of the present invention there is provided a method of operating a processor to repeatedly execute one or more instructions, the method including the steps of: (a) loading a register with a count value indicative of the number of times one or more associated instructions are to be executed; (b) fetching and executing a REPEAT instruction indicating the one or more associated instructions that are to be repeatedly executed; (c) incrementing a program counter; (d) fetching the one or more associated instructions; and (e) executing the one or more associated instruction for as many times as indicated by a count value stored in a count register.</p>\n<p num=\"p-0013\">In accordance with yet another aspect of the present invention there is provided a processor for repeatedly execute at least one associated instruction, said processor comprising: load means for loading a register with a count value indicative of the number of times the associated instruction is to be executed; first fetch means for a REPEAT instruction indicating the at least one associated instruction to be repeatedly executed; first execute means for executing the REPEAT instruction indicating the at least one associated instruction to be repeatedly executed; second fetch means for fetching the at least one associated instruction; and first execute means for executing the at least one associated instruction for as many times as indicated by the count value.</p>\n<p num=\"p-0014\">In accordance with yet another aspect of the present invention there is provided a processor for repeatedly executing one or more instructions, comprising: first fetch means for fetching a REPEAT instruction; first execute means for executing a REPEAT instruction, wherein execution of the REPEAT instruction stores in a register a count value indicative of the number of times one or more associated instructions are be executed; second fetch means for fetching the one or more associated instructions; and second execute means for executing the associated instruction for as many times as indicated by the count value.</p>\n<p num=\"p-0015\">In accordance with yet another aspect of the present invention there is provided a processor for repeatedly executing one or more instructions, comprising: load means for loading a register with a count value indicative of the number of times one or more associated instructions are to be executed; first fetch means for fetching a REPEAT instruction indicating the one or more associated instructions that are to be repeatedly executed; first execute means for executing the REPEAT instruction indicating the one or more associated instructions that are to be repeatedly executed; means for incrementing a program counter; second fetch means for fetching the one or more associated instructions; and second execute means for executing the one or more associated instruction for as many times as indicated by a count value stored in a count register.</p>\n<p num=\"p-0016\">In accordance with still another aspect of the present invention there is provided a processor for repeatedly executing one or more processor instructions, said processor comprising: a memory address register associated with a main memory; a memory data register associated with the main memory; a memory control for generating memory control signals; a program counter for storing a memory address location of the main memory where an instruction is to be fetched; an instruction register for storing an instruction that is to be executed; at least one general purpose register; decode and execute control logic for decoding and executing an instruction stored in the instruction register; and a state machine for controlling the fetching and repeated execution one or more associated instructions.</p>\n<p num=\"p-0017\">An advantage of the present invention is the provision of a repeat function which minimizes the number of off-chip memory instruction fetch accesses.</p>\n<p num=\"p-0018\">Another advantage of the present invention is the provision of a repeat function which conserves power in an embedded processor system, thus maximizing battery life.</p>\n<p num=\"p-0019\">Another advantage of the present invention is the provision of a repeat function which minimizes the size of the off-chip memory storage device, thus conserving real estate.</p>\n<p num=\"p-0020\">Still another advantage of the present invention is the provision of a repeat function which minimizes production costs of embedded processor systems.</p>\n<p num=\"p-0021\">Yet another advantage of the present invention is the provision of a repeat function which allows the use of a Von Neumann bus configuration, but provides the effect of a Harvard bus configuration.</p>\n<p num=\"p-0022\">Yet another advantage of the present invention is the provision of a repeat . . . until function that allows for repetition of a group of instructions without an instruction fetch.</p>\n<p num=\"p-0023\">Still other advantages of the invention will become apparent to those skilled in the art upon a reading and understanding of the following detailed description, accompanying drawings and appended claims.</p>\n<?BRFSUM description=\"Brief Summary\" end=\"tail\"?>\n<?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?>\n<description-of-drawings>\n<h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4>\n<p num=\"p-0024\">The invention may take physical form in certain parts and arrangements of parts, a preferred embodiment and method of which will be described in detail in this specification and illustrated in the accompanying drawings which form a part hereof, and wherein:</p>\n<p num=\"p-0025\"><figref idrefs=\"DRAWINGS\">FIG. 1A</figref> illustrates exemplary code for the prior art looping execution method;</p>\n<p num=\"p-0026\"><figref idrefs=\"DRAWINGS\">FIG. 1B</figref> illustrates exemplary code for the prior art unrolling execution method; and</p>\n<p num=\"p-0027\"><figref idrefs=\"DRAWINGS\">FIG. 2</figref> illustrates exemplary code for a repeat function according to a preferred embodiment of the present invention;</p>\n<p num=\"p-0028\"><figref idrefs=\"DRAWINGS\">FIG. 3</figref> illustrates a state machine for providing the repeat function according to a preferred embodiment of the present invention;</p>\n<p num=\"p-0029\"><figref idrefs=\"DRAWINGS\">FIG. 4</figref> illustrates the operation of executing a REPEAT instruction requiring five repeats of an associated instruction, in accordance with the state machine shown in <figref idrefs=\"DRAWINGS\">FIG. 1</figref>;</p>\n<p num=\"p-0030\"><figref idrefs=\"DRAWINGS\">FIG. 5</figref> shows a timing diagram corresponding to the operation shown in <figref idrefs=\"DRAWINGS\">FIG. 4</figref>; and</p>\n<p num=\"p-0031\"><figref idrefs=\"DRAWINGS\">FIG. 6</figref> is a block diagram showing the basic elements of a processor for executing the REPEAT instruction, according to a preferred embodiment of the present invention.</p>\n</description-of-drawings>\n<?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?>\n<?DETDESC description=\"Detailed Description\" end=\"lead\"?>\n<h4>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</h4>\n<p num=\"p-0032\">In computer program execution, a fetch operation transfers the contents of a specific main memory location to the processor or central processing unit (CPU). To start a fetch operation, the CPU must send the address of the desired memory location to the main memory. The CPU contains a register known as the program counter (PC) that contains the address in the main memory of the instruction to be executed. Execution of a given instruction is generally comprised of a two-phase procedure. In the first phase, called \u201cinstruction fetch,\u201d the instruction is fetched from the main memory location whose address is in the PC. This instruction is placed in the instruction register (IR) in the CPU. At the start of the second phase, called \u201cinstruction execute,\u201d the operation field of the instruction in the IR is examined to determine which operation is to be performed. The specified operation is then performed by the CPU. In the case where a shared bus is used for transfer of both instructions and data stored in the main memory (i.e., \u201cVon Neumann bus\u201d), the \u201cfetching\u201d and \u201cexecution\u201d of a memory transfer instruction (e.g., memory read (MRD) and memory write instructions), will require use of the same bus.</p>\n<p num=\"p-0033\"><figref idrefs=\"DRAWINGS\">FIGS. 1A and 1B</figref> show prior art methods for executing a series of repetitive instructions, such as memory transfer instructions (MRD\u2014\u201cmemory read\u201d). <figref idrefs=\"DRAWINGS\">FIG. 1A</figref> illustrates a \u201clooping\u201d method, while <figref idrefs=\"DRAWINGS\">FIG. 1B</figref> illustrates an \u201cunrolling\u201d method. As will be readily understood by those skilled in the art, the looping method requires one instruction fetch operation each time the MRD instruction is encountered, and one instruction fetch operation each time the DBcc (\u201cdecrement and branch\u201d) instruction is encountered. Thus, each 3 consecutive clock cycles of a single loop consist of: (1) fetch MRD, (2) perform memory data transfer (i.e. execute memory read instruction), and (3) fetch DBcc (decrement and branch). Accordingly, the \u201clooping\u201d method provides an effective data transfer rate of 1 data transfer for every 3 clock cycles on a shared instruction/data bus.</p>\n<p num=\"p-0034\">The prior art \u201cunrolling\u201d method shown in <figref idrefs=\"DRAWINGS\">FIG. 1B</figref>, is somewhat better than the \u201clooping\u201d method. As noted above, one instruction fetch operation is executed each time the MRD (\u201cmemory read\u201d) instruction is encountered. Thus, each two consecutive clock cycle consists of: (1) fetch MRD, and (2) perform memory data transfer (i.e., execute memory read instruction). Accordingly, the \u201cunrolling\u201d method provides an effective data transfer rate of 1 data transfer for every 2 clock cycles on a shared instruction/data bus. However, it should be understood that the \u201cunrolling\u201d method requires additional memory space for storing the plurality of MRD instructions. Consequently, a larger memory storage device is needed which adds to production cost.</p>\n<p num=\"p-0035\"><figref idrefs=\"DRAWINGS\">FIG. 2</figref> illustrates a special instruction referred to herein as a REPEAT instruction for repetitively executing an associated instruction. The number of repetitions is specified by a COUNT value preloaded into a register (R<b>0</b>) which said REPEAT instruction is associated with, or alternatively, specified as part of the REPEAT instruction (REPEAT N), where N specifies the number of repetitions. As will be described below, the REPEAT instruction eliminates the need to repetitively fetch on the same bus as a memory transfer. This allows for the same effect as a Harvard bus cycle, but without the added cost of provided separate instruction and data buses.</p>\n<p num=\"p-0036\">Referring now to <figref idrefs=\"DRAWINGS\">FIG. 3</figref>, there is shown a state machine <b>100</b> for decoding a REPEAT instruction, according to a preferred embodiment of the present invention. In STATE <b>1</b> (IDLE) a COUNT value has been preloaded into a register R<b>0</b> indicative of the number of times an instruction (referred to herein as INST<sub>R</sub>) is to be repeated upon encountering a REPEAT instruction. Upon transition from STATE <b>1</b> to STATE <b>2</b> (FIRST FETCH), a REPEAT instruction is fetched.</p>\n<p num=\"p-0037\">In STATE <b>2</b>, \u201cdecrement COUNT\u201d and \u201cre-execute\u201d signals are asserted. Assertion of the \u201cre-execute\u201d signal results in the fetching and execution of the instruction INST<sub>R</sub>, upon transition from STATE <b>2</b> to STATE <b>3</b> (RE-EXECUTE). INST<sub>R </sub>is the next consecutive instruction following the REPEAT instruction (i.e., the instruction associated with the REPEAT instruction).</p>\n<p num=\"p-0038\">In STATE <b>3</b>, a \u201cre-execute\u201d signal is asserted and if COUNT is greater than zero, and INST<sub>R </sub>is again executed. A \u201cdecrement count\u201d signal is also asserted to decrement the COUNT by one, each time INST<sub>R </sub>is executed. Once the COUNT is less than or equal to zero, an \u201cincrement PC\u201d signal is asserted, and there is a transition back to STATE <b>1</b>. Upon transition to STATE <b>1</b>, the address stored in the program counter (PC) is incremented.</p>\n<p num=\"p-0039\">Referring to <figref idrefs=\"DRAWINGS\">FIG. 4</figref>, there is shown a table illustrating the a REPEAT instruction for repeating an instruction INST<sub>R </sub>five (5) times. \u201cProgram counter\u201d refers to the address (hex) stored in the program counter, the \u201ctransitions\u201d refer to locations in the state diagram shown in <figref idrefs=\"DRAWINGS\">FIG. 3</figref>, while the \u201coperation\u201d indicates what type of operation is occurring. A corresponding timing diagram is shown in <figref idrefs=\"DRAWINGS\">FIG. 5</figref>. As can be seen in <figref idrefs=\"DRAWINGS\">FIGS. 4 and 5</figref>, the program counter remains unchanged as the same instruction INST<sub>R </sub>is repeatedly executed. Once the instruction INST<sub>R </sub>has been executed the number of times specified by COUNT, the program counter is incremented.</p>\n<p num=\"p-0040\">It should be appreciated that the instruction that is repeated (i.e., INST<sub>R</sub>) may be any type of instruction, including, but not limited to, memory data transfer instructions, such as memory read (MRD) or memory write instructions, and shift instructions.</p>\n<p num=\"p-0041\">In effect, the REPEAT instruction acts as an instruction cache which holds one repeatedly executed instruction (i.e., INST<sub>R</sub>). Accordingly, the present invention provides the benefits of an on-chip instruction cache, without the expense and problems associated with implementing an instruction cache.</p>\n<p num=\"p-0042\">Referring now to <figref idrefs=\"DRAWINGS\">FIG. 6</figref>, an exemplary processor for implementing the REPEAT instruction is illustrated. It should be appreciated that the processor illustrated in <figref idrefs=\"DRAWINGS\">FIG. 6</figref> is provided solely for the purposes of illustrating a preferred embodiment of the present invention, and that other processor designs (including non-RISC processors) may also be used for implementation of the REPEAT instruction of the present invention.</p>\n<p num=\"p-0043\">The processor is generally comprised of a memory address register (MAR) <b>20</b>, a memory data register (MDR) <b>30</b>, a memory control <b>40</b>, a program counter (PC) <b>50</b>, a plurality of registers <b>60</b>, an instruction register (IR) <b>70</b>, an instruction buffer <b>80</b>, an instruction decode and execute control logic <b>90</b>, an arithmetic logic unit (ALU) <b>95</b>, and a repeat state machine <b>100</b>. The processor is connected with a main memory <b>10</b> for exchange of data. It should be understood that not all interconnections among the processor elements are shown.</p>\n<p num=\"p-0044\">MAR <b>20</b> is used to hold the address of the location to or from which data is to be transferred. MDR <b>30</b> contains the data to be written into or read out of the addressed location. IR <b>70</b> contains the instruction that is being executed. Its output is available to the IR decode and execute control logic <b>90</b> that are needed to execute the instruction. PC <b>50</b> is a register that keeps track of the execution of a program. It contains the memory address of the instruction currently being executed. A plurality of general purpose registers <b>60</b> store various values needed during processing, such as the COUNT value associated with the REPEAT instruction. Programs typically reside in main memory <b>10</b> which interfaces with the processor via a bus.</p>\n<p num=\"p-0045\">In accordance with a preferred embodiment of the present invention, the processor is a RISC machine. Processor control is hard coded in a preferred embodiment, rather than software microcode. The following register transfer logic (RTL) is implemented for the REPEAT instruction:</p>\n<p num=\"h-0006\">IDLE:</p>\n<p num=\"p-0046\">\n</p><ul>\n<li id=\"ul0001-0001\" num=\"0000\">\n<ul>\n<li id=\"ul0002-0001\" num=\"0045\">IR  Fetch [REPEAT instruction]</li>\n<li id=\"ul0002-0002\" num=\"0046\">PC  PC+<b>1</b></li>\n<li id=\"ul0002-0003\" num=\"0047\">R<b>0</b>  R<b>0</b></li>\n<li id=\"ul0002-0004\" num=\"0048\">FIRST FETCH IDLE (transition A)\n<br/>\nFIRST FETCH:\n</li>\n<li id=\"ul0002-0005\" num=\"0049\">IR  [INST<sub>R</sub>]</li>\n<li id=\"ul0002-0006\" num=\"0050\">PC  PC</li>\n<li id=\"ul0002-0007\" num=\"0051\">R<b>0</b>  R<b>0</b>\u2212<b>1</b></li>\n<li id=\"ul0002-0008\" num=\"0052\">RE-EXECUTE  FIRST FETCH (transition B)\n<br/>\nRE-EXECUTE:\n</li>\n<li id=\"ul0002-0009\" num=\"0053\">IR  IR</li>\n<li id=\"ul0002-0010\" num=\"0054\">R<b>0</b>  R<b>0</b>\u2212<b>1</b></li>\n<li id=\"ul0002-0011\" num=\"0055\">IF (R<b>0</b>&gt;<b>0</b>) THEN\n        <ul><li id=\"ul0003-0001\" num=\"0056\">PC  PC; RE-EXECUTE  RE-EXECUTE (transition C)</li></ul>\n</li>\n<li id=\"ul0002-0012\" num=\"0057\">ELSE\n        <ul><li id=\"ul0004-0001\" num=\"0058\">PC  PC+<b>1</b></li><li id=\"ul0004-0002\" num=\"0059\">IDLE  RE-EXECUTE (transition D)</li></ul>\n</li>\n</ul>\n</li>\n</ul>\n<p num=\"p-0047\">As can be readily appreciated, the REPEAT instruction of the present invention is a significant improvement over the prior art. In this regard, after loading the COUNT and executing REPEAT instruction, one data transfer may be performed every clock cycle on a shared instruction/data bus, where INST<sub>R </sub>is a memory read/write instruction. Thus, it can be clearly observed that the present invention is 3 times as efficient as the prior art \u201clooping\u201d method, and is twice as efficient as the prior art \u201cunrolling\u201d method. Moreover, the REPEAT instruction of the present invention provides the added benefit of small code store. In addition, power consumption is also less due to reduced memory traffic. Accordingly, the present invention provides the same effect as a cache memory, but without the drawbacks inherent with use of a cache memory.</p>\n<p num=\"p-0048\">It should be further appreciated that the REPEAT instruction of the present invention does not need an instruction fetch, as required in the case of a \u201cloop caching\u201d method. In this regard, the program counter is effectively stalled on the same instruction which gets executed over and over again. With \u201cloop caching\u201d an instruction cache fetch must still be performed. \u201cLoop caching\u201d refers to an instruction caching variation which seeks to prioritize the caching of instruction streams which loop. Since a fetch instruction phase is required for \u201cloop caching,\u201d performance will suffer. Moreover, there is the drawback with caching in regards to hardware overhead, and penalty for cache miss which is further elaborated below with regards to context switching.</p>\n<p num=\"p-0049\">In a further embodiment of the present invention, the REPEAT instruction takes the form of a REPEAT . . . UNTIL instruction using a multiple instruction buffer. In this regard, multiple instructions are repeatedly executed. The REPEAT . . . UNTIL instruction achieves the same advantage provided by \u201cloop caching\u201d so that the number of off-chip fetch operations are reduced. The key difference is that the REPEAT . . . UNTIL instruction utilizes an instruction buffer <b>80</b> (<figref idrefs=\"DRAWINGS\">FIG. 6</figref>), rather than an instruction cache. Thus, as with the REPEAT instruction, multiple instruction fetches are not required. The contents of instruction buffer <b>80</b> are loaded from the operations nested between the REPEAT and the UNTIL program statements.</p>\n<p num=\"p-0050\">It should be understood that with context switching, the \u201cloop caching\u201d method described above will suffer. In this regard, the loop can become un-cached when the next context executes, since the locality of reference is lost. Therefore, when the suspended code thread is resumed, the loop performance may suffer. In the presence of very rapid context switching (\u201cthrashing\u201d) loop instruction caches can thus become useless. However, the REPEAT instruction and the REPEAT . . . UNTIL instruction do not have this drawback, since the contents of the instruction buffer are locked in and are preserved while the context is pre-empted. Thus, resumption of a switched context that was using a REPEAT or REPEAT . . . UNTIL instruction does not suffer in performance. In should be appreciated that, in effect, the REPEAT instruction has an instruction buffer containing one instruction.</p>\n<p num=\"p-0051\">The utility of using the REPEAT instruction to execute a single instruction over and over again, should be fully appreciated. In the case of code threads that rapidly context switch in a pre-emptive multi-tasking environment, repetition of instructions is of particular importance. For example, a MRD (memory read) instruction can be used to target a FIFO memory, which needs servicing by a code thread. The instruction contains a side effect which suspends the active context until it is interrupted (e.g., the FIFO needs servicing again). Hence, the instruction loop includes one instruction which needs to be continuously executed until the desired amount of data has been sent to the FIFO. For example, the following program code sample will read with post increment (address contents of register R<b>0</b>) from memory to FIFO 100 times, and suspend that context until next time of service after each read is performed.\n</p><ul><li id=\"ul0005-0001\" num=\"0000\"><ul><li id=\"ul0006-0001\" num=\"0065\">REPEAT 100</li><li id=\"ul0006-0002\" num=\"0066\">MRD [R<b>0</b>]+, FIFO, WAIT\n<br/>\nAn example of REPEAT . . . UNTIL is as follows:\n</li><li id=\"ul0006-0003\" num=\"0067\">REPEAT 100\n        <ul><li id=\"ul0007-0001\" num=\"0068\">MRD [R<b>1</b>]+, R<b>2</b></li><li id=\"ul0007-0002\" num=\"0069\">MRD [R<b>3</b>]+, R<b>4</b></li><li id=\"ul0007-0003\" num=\"0070\">ADD R<b>7</b>, R<b>2</b>, R<b>4</b></li><li id=\"ul0007-0004\" num=\"0071\">MWR [R<b>5</b>]+, R<b>7</b></li></ul>\n</li><li id=\"ul0006-0004\" num=\"0072\">UNTIL\n<br/>\nThis loop reads data into registers R<b>2</b> and R<b>4</b> using post increment address contents of register R<b>1</b> and R<b>3</b>. The result is added and placed into register R<b>7</b>, where it is stored to memory at the R<b>5</b> address, post increment. This is done 100 times in a row per the REPEAT N instruction (where N=100).\n</li></ul></li></ul>\n<p num=\"p-0052\">The present invention has been described with reference to a preferred embodiment. Obviously, modifications and alterations will occur to others upon a reading and understanding of this specification. It is intended that all such modifications and alterations be included insofar as they come within the scope of the appended claims or the equivalents thereof.</p>\n<?DETDESC description=\"Detailed Description\" end=\"tail\"?>\n</description>"}], "inventors": [{"first_name": "Kenneth W.", "last_name": "Batcher", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "CISCO TECHNOLOGY, INC."}, {"first_name": "", "last_name": "CISCO TECHNOLOGY, INC.", "name": ""}], "ipc_classes": [], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/32        20060101AFI20070213BHUS"}], "national_classes": [{"primary": true, "label": "712241"}, {"primary": false, "label": "718108"}, {"primary": false, "label": "712205"}, {"primary": false, "label": "712228"}], "ecla_classes": [{"label": "G06F   9/38B4L"}, {"label": "G06F   9/32B6"}], "cpc_classes": [{"label": "G06F   9/325"}, {"label": "G06F   9/325"}, {"label": "G06F   9/381"}, {"label": "G06F   9/381"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "2000-06-30", "application_date": "2000-06-30", "family_members": [{"ucid": "US-7178013-B1", "titles": [{"lang": "EN", "text": "Repeat function for processing of repetitive instruction streams"}]}]}