{"patent_number": "US-20010049770-A1", "publication_id": 75680368, "family_id": 22769873, "publication_date": "2001-12-06", "titles": [{"lang": "EN", "text": "BUFFER MEMORY MANAGEMENT IN A SYSTEM HAVING MULTIPLE EXECUTION ENTITIES"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA48269492\"><p id=\"A-0001\">A system includes multiple program execution entities (e.g., tasks, processes, threads, and the like) and a cache memory having multiple sections. An identifier is assigned to each execution entity. An instruction of one of the execution entities is retrieved and an associated identifier is decoded. Information associated with the instruction is stored in one of the cache sections based on the identifier. </p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00001\" num=\"1\"><claim-text><b>1</b>. A system comprising: \n<claim-text>a processor; </claim-text><claim-text>a plurality of execution entities executable on the processor; and </claim-text><claim-text>a buffer memory having multiple buffer sections, each buffer section adapted to store information associated with requests from a corresponding one of the multiple execution entities. </claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00002\" num=\"2\"><claim-text><b>2</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00001\"><claim-text>claim 1</claim-text></claim-ref>, further comprising a software layer adapted to assign identifiers to the execution identifiers and to assign each buffer section an identifier. </claim-text></claim>"}, {"num": 3, "parent": 2, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00003\" num=\"3\"><claim-text><b>3</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00002\"><claim-text>claim 2</claim-text></claim-ref>, further comprising a controller operatively coupled to the buffer memory to select one of the buffer sections based on an identifier associated with a request from an execution entity. </claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00004\" num=\"4\"><claim-text><b>4</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00001\"><claim-text>claim 1</claim-text></claim-ref>, wherein the execution entities include processes. </claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00005\" num=\"5\"><claim-text><b>5</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00001\"><claim-text>claim 1</claim-text></claim-ref>, wherein the execution entities include threads. </claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00006\" num=\"6\"><claim-text><b>6</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00001\"><claim-text>claim 1</claim-text></claim-ref>, wherein the buffer memory includes a cache memory having multiple cache sections. </claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00007\" num=\"7\"><claim-text><b>7</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00006\"><claim-text>claim 6</claim-text></claim-ref>, wherein the cache sections are configurable to have different attributes. </claim-text></claim>"}, {"num": 8, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00008\" num=\"8\"><claim-text><b>8</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00007\"><claim-text>claim 7</claim-text></claim-ref>, wherein the attributes include cache line replacement policies. </claim-text></claim>"}, {"num": 9, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00009\" num=\"9\"><claim-text><b>9</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00007\"><claim-text>claim 7</claim-text></claim-ref>, wherein the attributes include cache update policies. </claim-text></claim>"}, {"num": 10, "parent": 7, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00010\" num=\"10\"><claim-text><b>10</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00007\"><claim-text>claim 7</claim-text></claim-ref>, wherein the attributes include cache organization. </claim-text></claim>"}, {"num": 11, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00011\" num=\"11\"><claim-text><b>11</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00006\"><claim-text>claim 6</claim-text></claim-ref>, wherein the cache memory includes a multi-level cache memory in which at least one level includes a multi-unit cache memory having multiple cache sections. </claim-text></claim>"}, {"num": 12, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00012\" num=\"12\"><claim-text><b>12</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00001\"><claim-text>claim 1</claim-text></claim-ref>, wherein the execution entities process data according to different temporal and spatial locality characteristics, and each buffer section is configured based on the temporal and spatial locality characteristics. </claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00013\" num=\"13\"><claim-text><b>13</b>. A cache memory for use in a system having multiple execution entities, the cache memory comprising: \n<claim-text>a cache controller; and </claim-text><claim-text>a plurality of cache sections, the cache controller adapted to store information in one of the cache sections based on which execution entity the information is associated with. </claim-text></claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00014\" num=\"14\"><claim-text><b>14</b>. The cache memory of <claim-ref idref=\"US-20010049770-A1-CLM-00013\"><claim-text>claim 13</claim-text></claim-ref>, wherein the cache controller includes storage elements programmable with identifiers to identify the one or more execution entities that each cache section is associated with. </claim-text></claim>"}, {"num": 15, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00015\" num=\"15\"><claim-text><b>15</b>. A method of storing data in a memory having multiple sections, the memory located in a system having multiple execution entities, the method comprising: \n<claim-text>assigning an identifier to each execution entity; </claim-text><claim-text>retrieving an instruction of one of the execution entities; </claim-text><claim-text>decoding an identifier associated with the instruction; and </claim-text><claim-text>storing information associated with the instruction in one of the memory sections based on the identifier. </claim-text></claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00016\" num=\"16\"><claim-text><b>16</b>. The method of <claim-ref idref=\"US-20010049770-A1-CLM-00015\"><claim-text>claim 15</claim-text></claim-ref> wherein decoding includes retrieving the identifier from a storage location. </claim-text></claim>"}, {"num": 17, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00017\" num=\"17\"><claim-text><b>17</b>. A method of setting up a cache memory having multiple cache sections, the cache memory located in a system having multiple execution entities, the method comprising: \n<claim-text>assigning an identifier to each execution entity based on which of the multiple cache sections is to be used for the execution entity; and </claim-text><claim-text>configuring each of the cache sections based on the cache usage characteristics of the one or more execution entities assigned to the cache section. </claim-text></claim-text></claim>"}, {"num": 18, "parent": 17, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00018\" num=\"18\"><claim-text><b>18</b>. The method of <claim-ref idref=\"US-20010049770-A1-CLM-00017\"><claim-text>claim 17</claim-text></claim-ref>, wherein the configuring includes setting attributes of each cache section. </claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00019\" num=\"19\"><claim-text><b>19</b>. The method of <claim-ref idref=\"US-20010049770-A1-CLM-00018\"><claim-text>claim 18</claim-text></claim-ref>, wherein the attribute setting includes setting a replacement policy for each cache section. </claim-text></claim>"}, {"num": 20, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00020\" num=\"20\"><claim-text><b>20</b>. The method of <claim-ref idref=\"US-20010049770-A1-CLM-00018\"><claim-text>claim 18</claim-text></claim-ref>, wherein the attribute setting includes setting an update policy for each cache section. </claim-text></claim>"}, {"num": 21, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00021\" num=\"21\"><claim-text><b>21</b>. A memory subsystem in a system having multiple execution entities that generate instructions, comprising: \n<claim-text>a controller; and </claim-text><claim-text>a multi-unit buffer memory having multiple buffers, </claim-text><claim-text>the controller adapted to select one of the buffers to store information associated with an instruction based on which execution entity generated the instruction. </claim-text></claim-text></claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00022\" num=\"22\"><claim-text><b>22</b>. The memory subsystem of <claim-ref idref=\"US-20010049770-A1-CLM-00021\"><claim-text>claim 21</claim-text></claim-ref>, wherein the controller includes storage elements corresponding to each of the buffers that are programmable to values identifying the execution entities. </claim-text></claim>"}, {"num": 23, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00023\" num=\"23\"><claim-text><b>23</b>. An article including a storage medium containing instructions for managing memory in a system, the system having a processor, a memory with multiple memory sections, and multiple execution entities executable on the processor, the instructions when executed causing the system to: \n<claim-text>assign each memory section to correspond to one or more of the execution entities; and </claim-text><claim-text>configure attributes of each of the memory sections based on the memory usage characteristics of the one or more execution entities assigned to the memory section. </claim-text></claim-text></claim>"}, {"num": 24, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00024\" num=\"24\"><claim-text><b>24</b>. A processor located in a system having multiple execution entities, comprising: \n<claim-text>a cache memory having multiple cache sections each assigned to an execution entity; and </claim-text><claim-text>a sequencer having multiple segments each assigned to an execution entity, </claim-text><claim-text>the sequencer adapted to receive instructions from multiple execution entities, each segment of the sequencer capable of executing the received instructions concurrently and accessing the cache sections concurrently during execution. </claim-text></claim-text></claim>"}, {"num": 25, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00025\" num=\"25\"><claim-text><b>25</b>. A system comprising: \n<claim-text>program execution entities associated with identifiers; and </claim-text><claim-text>a multi-unit cache memory having multiple cache sections adapted to store information associated with requests from the execution entities, each cache section storing the information based on an identifier. </claim-text></claim-text></claim>"}, {"num": 26, "parent": 25, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00026\" num=\"26\"><claim-text><b>26</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00025\"><claim-text>claim 25</claim-text></claim-ref> further comprising a memory in which requests and associated identifiers are stored. </claim-text></claim>"}, {"num": 27, "parent": 25, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00027\" num=\"27\"><claim-text><b>27</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00025\"><claim-text>claim 25</claim-text></claim-ref>, further comprising a processor and a memory to store instructions associated with requests from the execution entities, the processor adapted to retrieve an instruction from the memory and to determine an identifier associated with the instruction based on an address location of the instruction in the memory. </claim-text></claim>"}, {"num": 28, "parent": 25, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00028\" num=\"28\"><claim-text><b>28</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00025\"><claim-text>claim 25</claim-text></claim-ref>, wherein the requests include instructions, the system further comprising a processor having a plurality of program counters and corresponding microsequencers, each microsequencer adapted to fetch instructions associated with a corresponding execution entity based on an address contained in the program counter. </claim-text></claim>"}, {"num": 29, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-20010049770-A1-CLM-00029\" num=\"29\"><claim-text><b>29</b>. The system of <claim-ref idref=\"US-20010049770-A1-CLM-00028\"><claim-text>claim 28</claim-text></claim-ref>, wherein the identifier of an instruction is determined based on which microsequencer fetched the instruction.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54978408\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><summary-of-invention><h4>BACKGROUND </h4><p id=\"P-0001\" num=\"0001\">[0001] The invention relates to buffer memory management in a system having multiple execution entities. </p><p id=\"P-0002\" num=\"0002\">[0002] A buffer memory can be a relatively small, fast memory placed between a memory and another device that is capable of accessing the memory. An example of a buffer memory is a cache memory located between a processor and system memory (which typically is relatively large and slow) to reduce the effective access time required by the processor to retrieve information from the system memory. In some systems, a multi-level cache system may be used for further performance improvement. A first-level cache (L1 cache) may be implemented in the processor itself, and a second-level, typically larger cache (L2 cache) is externally coupled to the processor. </p><p id=\"P-0003\" num=\"0003\">[0003] Further, in some conventional memory systems, a cache memory may include separate instruction and data cache units, one to store instructions and the other to store data. During operation, a processor may fetch instructions from system memory to store in the instruction cache unit. Data processed by those instructions may be stored in the data cache unit. If information, such as instruction or data, requested by the processor is already stored in cache memory, then a cache memory hit is said to have occurred. A cache memory hit reduces the time needed for the processor to access information stored in memory, which improves processor performance. </p><p id=\"P-0004\" num=\"0004\">[0004] However, if information needed by the processor is not stored in cache memory, then a cache miss is said to have occurred. When a cache miss occurs, the processor has to access the system memory to retrieve the desired information, which results in a memory access time performance reduction while the processor waits for the slower system memory to respond to the request. To reduce cache misses, different cache management policies have been implemented. One of several mapping schemes may be selected, for example, including a direct mapping scheme or a set associative cache mapping scheme. A set associative cache memory that implements k-way associative mapping, e.g., 2-way associative mapping, 4-way associative mapping, and so forth, generally provides a higher hit ratio than direct mapped cache memory. One of several replacement policies may also be specified to improve cache memory hit ratios, including a first-in-first-out (FIFO) or least recently used (LRU) policy. Another feature of a cache memory that may be configured is the cache memory update policy that specifies how the system memory is updated when a write operation changes the contents of the cache. Update policies include a write-through policy or a write-back policy. </p><p id=\"P-0005\" num=\"0005\">[0005] Conventionally, a system, such as a computer, may include multiple application programs and other software layers that have different data flow needs. For example, a program execution entity, such as a process, task, or thread, associated with a multimedia application may transfer large blocks of data (e.g., video data) that are typically not reused. Thus, access of these types of data may cause a cache to fill up with large blocks of data that are not likely to be reused. </p><p id=\"P-0006\" num=\"0006\">[0006] In filling a cache memory, data used by one execution entity may replace data used by another execution entity, a phenomenon referred to as data cache pollution. Data cache pollution caused by the activities of one execution entity may increase the likelihood of cache misses for another execution entity, which may reduce overall system performance. </p><p id=\"P-0007\" num=\"0007\">[0007] A need thus exists for a memory architecture that provides improved memory performance. </p><h4>SUMMARY </h4><p id=\"P-0008\" num=\"0008\">[0008] In general, according to an embodiment, a system includes a processor and a plurality of execution entities executable on the processor. A buffer memory in the system has multiple buffer sections. Each buffer section is adapted to store information associated with requests from a corresponding one of the multiple execution entities. </p><p id=\"P-0009\" num=\"0009\">[0009] Other features will become apparent from the following description and from the claims.</p></summary-of-invention><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS </h4><p id=\"P-0010\" num=\"0010\">[0010]FIG. 1 is a block diagram of portions of a buffer or cache memory having multiple sections according to an embodiment of the invention. </p><p id=\"P-0011\" num=\"0011\">[0011]FIG. 2 is a block diagram of an embodiment of a system including the cache memory of FIG. 1. </p><p id=\"P-0012\" num=\"0012\">[0012]FIG. 3 illustrates the components of each cache module in the cache memory of FIG. 1. </p><p id=\"P-0013\" num=\"0013\">[0013]FIG. 4 is a block diagram of a processor including the cache memory of FIG. 1 along with associated control logic. </p><p id=\"P-0014\" num=\"0014\">[0014]FIG. 5 is a flow diagram of an instruction execution sequence performed in the processor of FIG. 4. </p><p id=\"P-0015\" num=\"0015\">[0015]FIG. 6 is a flow diagram of an operating system in the system of FIG. 2 that sets up a cache memory according to an embodiment.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION </h4><p id=\"P-0016\" num=\"0016\">[0016] In the following description, numerous details are set forth to provide an understanding of the present invention. However, it is to be understood by those skilled in the art that the present invention may be practiced without these details and that numerous variations or modifications from the described embodiments may be possible. </p><p id=\"P-0017\" num=\"0017\">[0017] Some embodiments of the invention include a system having a buffer memory that includes several individual buffer sections at one level of the memory hierarchy. Each buffer section may be a separate buffer module or may be a portion of a buffer memory that is separately addressable (that is, memory is separated into different address spaces). The individual buffer sections may be separately configurable and may be assigned to store information of different program execution entities in the system. Such a buffer memory may be referred to as a multi-unit buffer memory. </p><p id=\"P-0018\" num=\"0018\">[0018] In some embodiments, the buffer memory may include a cache memory used in any of a variety of applications, e.g., processor subsystems, peripheral device controllers (such as video controllers, hard disk drive controllers, and so forth), and other types of control devices. Systems including such cache memories may include a general-purpose or special-purpose computer, a hand-held electronic device (e.g., telephones, calendar systems, electronic game devices, and the like), appliances, set-top boxes, and other electronics systems. A cache memory having multiple cache sections may be referred to as a multi-unit cache memory. A cache memory section may include a separate cache module or a portion of the cache memory that is separately addressable. The following described embodiments include a computer having a multi-unit cache memory with multiple independent cache modules \u2014it is to be understood, however, that further embodiments may include computers having multi-unit cache memories with other independently configurable cache sections or other types of systems with buffer memories. </p><p id=\"P-0019\" num=\"0019\">[0019] According to some embodiments, the attributes of each individual cache module in a multi-unit cache memory may be independently configurable. Such attributes may include each cache module's size, organization (e.g., direct mapped versus set associative mapping), replacement policy, update policy, and so forth. Thus, for example, one cache module may be configured to be a direct mapped cache while another cache module may be configured as a k-way set associative cache. The cache modules may also be configured to have different update policies, including a write-through policy or a write-back policy. Other attributes may also be set differently for the different cache modules, as further described below. </p><p id=\"P-0020\" num=\"0020\">[0020] Some processors may be capable of receiving requests from multiple execution entities for processing. A processor may include, by way of example, a general-purpose or a special-purpose microprocessor, a microcontroller, or other types of control devices such as application-specific integrated circuits (ASICs), programmable gate arrays (PGAs), and the like. A program execution entity according to one embodiment may be the basic unit of work of software and firmware layers that are loaded in the system. Such basic units of work may include processes, tasks, threads, or other units, as definable according to different systems. For example, in some operating systems, such as certain Windows\u00ae operating systems by Microsoft Corporation, multiple threads associated with processes in the system may be executable by the processor to perform different operations. Another operating system that offers multithreading or multitasking capabilities is the Be Operating System (BeOS) from BE, Inc., as described in the BE Operating System Product Data Sheet, published at http://www.be.com in 1998. </p><p id=\"P-0021\" num=\"0021\">[0021] In such operating systems, multiple execution entities associated with different software and firmware layers may be active at a time. Requests from these execution entities are scheduled by the operating system according to a predetermined priority protocol, e.g., round-robin, etc. Such operating systems are said to be multitasking or multithreading operating systems. To take advantage of the multitasking or multithreading capabilities of a system, the independent cache modules of a multi-unit cache memory may be assigned to store information of corresponding execution entities. Thus, for example, execution entities of a multimedia application may be assigned to one cache module, while execution entities of other applications may be assigned to different cache modules of the multi-unit cache memory. To that end, according to one embodiment, requests from each execution entity may be assigned to different execution entity identifiers (EIDs). Thus, requests from execution entities of a first application may be assigned to one EID, and requests from another execution entity may be assigned another EID. Thus, according to this embodiment, a cache module may be configured for the general data usage behavior of an assigned application. </p><p id=\"P-0022\" num=\"0022\">[0022] In another embodiment, the execution entities created by one software or firmware layer may further be subdivided to have multiple EIDs. For example, an application may create execution entities that process data according to different temporal and spatial locality characteristics. For example, some execution entities may be more likely to reuse data than other execution entities created by the same application. Thus, it may be beneficial to further separately assign these different execution entities to different cache modules in the multi-unit cache memory. Thus, in one alternative embodiment, requests from different execution entities of one application may be assigned more than one EID so that different cache modules may be utilized. In addition, execution entities of different applications may be assigned the same EID. Thus, for example, a first execution entity of a multimedia application may be assigned EID 1, while a second execution entity of the multimedia application may be assigned EID 2. In the same system, execution entities of a spreadsheet application having similar data usage characteristics as the second execution entity of the multimedia application may also be assigned EID 2. </p><p id=\"P-0023\" num=\"0023\">[0023] In further embodiments, other different schemes may be implemented in assigning EIDs to requests of execution entities. Based on the EID associated with an instruction, a cache controller for the cache memory can keep track of which cache module of the multi-unit cache memory is to be used to store data accessed by the instruction. As a result, cache utilization may be improved since the individual cache modules may be configured to take advantage of the data usage characteristics of the different execution entities in the system. For example, a multimedia application may typically generate requests that transfer large blocks of data that are not re-used. A cache module assigned to these types of requests may be configured to implement the FIFO replacement policy and write-through update policy. Cache modules assigned to other types of requests may have different configurations. </p><p id=\"P-0024\" num=\"0024\">[0024] As execution entities are created in a system, EID identifiers may be assigned to these execution entities by an operating system. Referring to FIG. 6, according to one embodiment, if a new execution entity is detected (at <b>502</b>), the operating system may access (at <b>504</b>) configuration information loaded during system initialization to determine how EID identifiers are to be assigned. The operating system next assigns (at <b>506</b>) the appropriate EID identifier to the execution entity. For example, the operating system may be able to assign three EIDs to correspond to three cache modules in a multi-unit cache memory. Execution entities having one general data usage characteristic may be assigned a first EID identifier, and execution entities having a second general data usage characteristic may be assigned a second EID identifier. A default EID identifier may be assigned to those execution entities that are not specifically assigned one of the other two EID identifiers. </p><p id=\"P-0025\" num=\"0025\">[0025] In addition, based on the configuration information, the operating system also assigns (at <b>508</b>) certain attributes of each cache module in the multi-unit cache memory. Such attributes may include the update, replacement, and placement policies. The operating system may also assign the attributes for the default cache module of the multi-unit cache memory. In alternative embodiments, the EID identifiers and cache attributes may be assigned as described above by a software layer that is separate from the operating system. </p><p id=\"P-0026\" num=\"0026\">[0026] In one example, execution entities of a multimedia application that transfer large amounts of data and that do not typically reuse the data may be allocated one EID identifier so that such data are stored in a first cache module configured for the cache data usage characteristics of these execution entities. Execution entities of intensive arithmetic applications, such as compression applications, may be assigned another EID identifier so that data is stored in another cache module that is configured for cache data operations characterized by increased spatial locality. </p><p id=\"P-0027\" num=\"0027\">[0027] In some embodiments, a multi-unit cache memory having multiple cache modules may be implemented in a multilevel cache memory having multiple levels of cache memory (e.g., an L1 cache and an L2 cache). Such a cache memory may be referred to as a multilevel, multi-unit cache memory, in which at least one level includes a multi-unit cache memory. Thus, for example, a multilevel, multi-unit cache memory having two levels may be constructed in the following manner: the first level is a multi-unit cache and the second level is a conventional cache; the first level is a multi-unit cache and the second level is a multi-unit cache; or the first level is a conventional cache and the second level is a multi-unit cache. </p><p id=\"P-0028\" num=\"0028\">[0028] The individual cache modules of a multi-unit cache may be referred to as P-caches. Thus, for example, a multi-unit cache memory may include several P-caches, including a P0-cache, a P1-cache, a P2-cache, and so forth. The different P-caches may be implemented as separate memory elements or modules, e.g., multiple static random access memory (SRAM) or multiple dynamic random access memory (DRAM) devices. Alternatively, multiple P-caches may be implemented in one memory device that is subdivided into separate sections to correspond to the different P-caches. In addition, the multi-unit cache memory may be integrated in another device, e.g., a processor or other control device in a system. Alternatively, the multi-unit cache memory may be a standalone unit accessible by control devices to retrieve cached data. In further embodiments, one portion of the multi-unit cache memory may be located in one integrated device while another portion of the multi-unit cache memory is located in another device. </p><p id=\"P-0029\" num=\"0029\">[0029] In some embodiments of the invention, each individual P-cache module in a multi-unit cache system may have different attributes, including cache size and organization and cache update, placement, and replacement policies. A placement policy may be specified for each P-cache to determine how information is placed into unfilled portions of the cache. A cache replacement policy is specified to manage replacement of information stored in each P-cache. Example replacement polices may include a first-in-first-out (FIFO) policy, a least-recently-used (LRU) policy, or some other type of replacement policy. A cache update policy manages how information is to be updated when a write occurs to the cache, which may include a write-through policy or a write-back policy. </p><p id=\"P-0030\" num=\"0030\">[0030] Referring to FIG. 1, a multi-unit cache memory <b>100</b> according to an embodiment includes several P-caches, shown as a P0-cache <b>102</b>, a P1-cache <b>104</b>, and a P2-cache <b>106</b>. A cache controller <b>108</b> is associated with the P0-, P1-, and P2-caches <b>102</b>, <b>104</b>, and <b>106</b>. In one embodiment, separate address and data buses may be coupled to each of the cache modules <b>102</b>, <b>104</b> and <b>106</b> so that the cache modules may be accessed concurrently. Alternatively, a common address and data bus may be coupled to the cache modules. The cache controller <b>108</b> provides control signals to each of the P-cache modules <b>102</b>-<b>106</b>. </p><p id=\"P-0031\" num=\"0031\">[0031] The cache controller <b>108</b> includes storage elements <b>118</b>, in the form of registers or the like, that are programmable by the operating system to specify the EID identifiers associated with each of the P-caches. When the multi-unit cache memory <b>100</b> is accessed, the cache controller <b>108</b> selects one of the P-caches based on a comparison of the EID provided by a request and the EID values stored in the storage elements <b>118</b>. </p><p id=\"P-0032\" num=\"0032\">[0032] The cache controller <b>108</b> also includes a replacement and update control block <b>120</b> to control the replacement and update policies of the three separate cache modules, as determined by control information programmed in the storage elements <b>118</b>. Thus, for example, the storage elements <b>118</b> may be programmed to indicate a FIFO replacement policy for one P-cache and an LRU replacement policy for another P-cache. </p><p id=\"P-0033\" num=\"0033\">[0033] The cache controller <b>108</b> may also include a tag compare block <b>122</b> to compare the tag of an incoming request to the tag stored in the selected one or ones of the P-caches to determine if a cache hit has occurred. Further, if update of main memory <b>206</b> (FIG. 2) is needed, a write-back buffer <b>124</b> stores the cache line of one of the P-caches to transfer to main memory <b>206</b> or an L2 cache <b>204</b> (FIG. 2). </p><p id=\"P-0034\" num=\"0034\">[0034] To ensure cache data integrity, the cache controller <b>108</b> also includes a cache coherency block <b>126</b> that determines if an accessed location of a cache module is valid. In one embodiment, each cache module may store a valid/invalid bit. Alternatively, a more sophisticated coherency protocol may be implemented, such as the Modified, Exclusive, Shared, and Invalid (MESI) protocol. </p><p id=\"P-0035\" num=\"0035\">[0035] Other control signals that may be provided to the cache controller <b>108</b> may include a cache disable (CD) signal and a cache flush (CF) signal. In addition, other cache related signals such as snoop signals may be provided to the cache controller <b>108</b>. </p><p id=\"P-0036\" num=\"0036\">[0036] Referring to FIG. 2, the multi-unit cache system <b>100</b> may be implemented in a number of different locations (e.g., processor subsystem, bridge controllers, peripheral device controllers, storage device controllers, and the like) in a system <b>10</b>. In one embodiment, the system <b>10</b> includes a computer, although in alternative embodiments, the system <b>10</b> may be any other electronic device in which a cache or buffer memory may be implemented. </p><p id=\"P-0037\" num=\"0037\">[0037] The system <b>10</b> includes a central processing unit (CPU) <b>200</b>, which may include a processor or other suitable control device, having one or more levels of cache memory. For example, as illustrated, the CPU <b>200</b> may include an internal cache that is the level-one (L1) cache <b>202</b>. In addition, the CPU <b>200</b> may be coupled over a host bus <b>203</b> to access an external cache that is the level-two (L2) cache <b>204</b>. The L1 cache <b>202</b> may include a code component (for storing instructions) and a data component (for storing data). Similarly, the L2 cache <b>204</b> may include code and data components. Thus, instructions and data fetched from main memory <b>206</b> are stored in the code and data components, respectively, of the L1 or L2 cache <b>202</b> or <b>204</b>. In other embodiments, separate code and data cache components are not implemented. </p><p id=\"P-0038\" num=\"0038\">[0038] In some embodiments, the multi-unit cache memory <b>100</b> (FIG. 1) may be implemented in the L1 cache <b>202</b>, the L2 cache <b>204</b>, or both. For purposes of this discussion, it is assumed that the multi-unit cache memory <b>100</b> of FIG. 1 is implemented in the L1 cache <b>202</b> that is the internal cache of the CPU <b>200</b>. It is to be understood, however, that the multi-unit cache memory described, or modifications of such a cache memory, may be implemented in the L2 cache <b>204</b> or in other controllers in the system, such as a video controller or a hard disk drive controller, as examples. In addition, in this embodiment, the multi-unit cache memory <b>100</b> forms the data cache component of the L1 cache <b>202</b>. </p><p id=\"P-0039\" num=\"0039\">[0039] The main memory <b>206</b> is controlled by a memory controller <b>207</b> in a memory hub <b>208</b> coupled to the CPU <b>200</b> over the host bus <b>203</b>. In addition, the memory hub <b>208</b> may include a cache controller <b>205</b> operatively coupled to the L2 cache <b>204</b>. The memory hub <b>208</b> may also include a graphics interface <b>211</b> that is coupled over a link <b>209</b> to a graphics controller <b>210</b>, which is in turn coupled to a display <b>212</b>. As an example, the graphics interface may be according to the Accelerated Graphics Port (A.G.P.) Interface Specification, Revision 2.0, published in May 1998. </p><p id=\"P-0040\" num=\"0040\">[0040] The memory hub <b>208</b> may also be coupled to an input/output (I/O) hub <b>214</b> that includes bridge controllers <b>215</b> and <b>223</b> coupled to a system bus <b>216</b> and a secondary bus <b>224</b>, respectively. As an example, the system bus may be a Peripheral Component Interconnect (PCI) bus, as defined by the PCI Local Bus Specification, Production Version, Revision 2.1, published in June 1995. The system bus <b>216</b> may be coupled to a storage controller <b>218</b> that controls access to one or more mass storage devices <b>220</b>, including a hard disk drive, a compact disc (CD) drive, or a digital video disc (DVD) drive. In an alternative embodiment, the storage controller <b>218</b> may be integrated into the I/O hub <b>214</b>, as may other control functions. The system bus <b>216</b> may also be coupled to other components, including, for example, a network controller <b>222</b> that is coupled to a network port (not shown). </p><p id=\"P-0041\" num=\"0041\">[0041] On the secondary bus <b>224</b>, additional devices <b>226</b> may be coupled, as may be a non-volatile memory <b>228</b> that may store power up routines, such as basic input/output system (BIOS) routines. The secondary bus <b>224</b> may also include ports for coupling to peripheral devices. Although the description makes reference to specific configurations and architectures of the various layers of the system <b>10</b>, it is contemplated that numerous modifications and variations of the described and illustrated embodiments may be possible. For example, instead of memory and I/O hubs, a host bridge controller and a system bridge controller may provide equivalent functions, with the host bridge controller coupled between the CPU <b>200</b> and the system bus <b>216</b> and the system bridge controller <b>224</b> coupled between the system bus <b>216</b> and the secondary bus <b>224</b>. In addition, any of a number of bus protocols may be implemented. </p><p id=\"P-0042\" num=\"0042\">[0042] Various different program execution entities are executable by the CPU <b>200</b> in the system <b>10</b>. As illustrated, according to one embodiment, multiple processes <b>252</b>, <b>254</b>, and <b>256</b> are loaded under an operating system <b>250</b>, which may be a Windows\u00ae operating system, for example. Each process may generate one or more execution entities that form the basic units of work in the system. In one example, the execution entities may be threads; as illustrated in FIG. 2, the process <b>252</b> may include threads <b>258</b> and <b>260</b>, the process <b>254</b> may include a thread <b>262</b>, and the process <b>256</b> may include threads <b>264</b> and <b>266</b>. </p><p id=\"P-0043\" num=\"0043\">[0043] Various software or firmware (formed of modules, routines, or other layers, for example), including applications, operating system modules or routines, device drivers, BIOS modules or routines, and interrupt handlers, may be stored or otherwise tangibly embodied in one or more storage media in the system. Storage media suitable for tangibly embodying software and firmware instructions may include different forms of memory including semiconductor memory devices such as dynamic or static random access memories, erasable and programmable read-only memories (EPROMs), electrically erasable and programmable read-only memories (EEPROMs), and flash memories; magnetic disks such as fixed, floppy and removable disks; other magnetic media including tape; and optical media such as CD or DVD disks. The instructions stored in the storage media when executed cause the system <b>10</b> to perform programmed acts. </p><p id=\"P-0044\" num=\"0044\">[0044] The software or firmware can be loaded into the system <b>10</b> in one of many different ways. For example, instructions or other code segments stored on storage media or transported through a network interface card, modem, or other interface mechanism may be loaded into the system <b>10</b> and executed to perform programmed acts. In the loading or transport process, data signals that are embodied as carrier waves (transmitted over telephone lines, network lines, wireless links, cables and the like) may communicate the instructions or code segments to the system <b>10</b>. </p><p id=\"P-0045\" num=\"0045\">[0045] The execution entities (in this case threads) are adapted to perform different operations. For example, a spreadsheet process may create a first thread to perform calculations on entries entered by a user and a second thread to transfer the calculated data into main memory <b>206</b>. Each thread or execution entity is able to generate requests, which are stored as instructions in main memory <b>206</b>. These instructions are fetched by the CPU <b>200</b> from main memory <b>206</b> for execution. </p><p id=\"P-0046\" num=\"0046\">[0046] According to some embodiments, an execution entity identifier (EID) may be assigned to each execution entity running in the system <b>10</b>. The EID of each execution entity may be assigned by the operating system. In one embodiment, when a scheduler <b>270</b> schedules requests from the execution entities for processing by the CPU <b>200</b>, the associated EID of each execution entity is stored along with one or more corresponding instructions. In this embodiment, the CPU <b>200</b> fetches the associated EIDs along with the instructions. </p><p id=\"P-0047\" num=\"0047\">[0047] In an alternative embodiment, the EIDs are not stored into memory <b>206</b> along with instructions. Instead, multiple instruction memory regions may be defined in the memory <b>206</b> to correspond to the different EIDs. Instructions associated with a request from an execution entity having a first EID may be stored in a first instruction memory region; instructions associated with a request from an execution entity having a second EID may be stored in a second instruction memory region; and so forth. In this alternative embodiment, the CPU <b>200</b> fetches instructions from memory <b>206</b> without associated EIDs. However, based on which of the instruction memory regions the instruction is fetched, the CPU <b>200</b> can determine the EID of the instruction. </p><p id=\"P-0048\" num=\"0048\">[0048] In yet a further embodiment, in which EIDs are similarly not stored along with instructions, the CPU <b>200</b> may include multiple microsequencers assigned to different threads. Thus, one microsequencer may retrieve instructions associated with one thread, another microsequencer may retrieve instructions associated with another thread, and so forth. Each microsequencer may be configured to know locations of instructions of corresponding execution entities. In this embodiment, an instruction's EID may be determined depending on which of the microsequencers fetched that instruction. The determined instruction may then be stored inside the CPU. </p><p id=\"P-0049\" num=\"0049\">[0049] The retrieved or determined EID is decoded by the cache controller <b>108</b> or by some other suitable decoder to identify which P-cache is to be used when the instruction requests an access to data. The cache controller <b>108</b> accesses one of the P-caches to retrieve or store data processed by the corresponding instruction. With the example configuration of FIG. 1, data associated with instructions having EID 0 may be stored in the P0-cache <b>102</b>, data associated with instructions having EID 1 may be stored in the P1-cache <b>104</b>, and data associated with instructions having EID 2 may be stored in the P2-cache <b>106</b>. In some embodiments, a P-cache may be associated with more than one EID. Further, execution entities from different application and software layers may be assigned the same EID. </p><p id=\"P-0050\" num=\"0050\">[0050] Referring to FIG. 3, the general architecture of one of the P-caches is illustrated. In the example shown in FIG. 3, a 4-way set-associative cache is illustrated. Other configurations are also possible, including a direct mapped cache or other k-way set-associative caches. Each P-cache may include a status array <b>160</b>, a tag array <b>162</b>, and a data array <b>164</b>. As illustrated, each of the status array <b>160</b>, tag array <b>162</b>, and data array <b>164</b> is divided into 4 different sections for the 4-way set-associative organization. </p><p id=\"P-0051\" num=\"0051\">[0051] The status array <b>160</b> may contain one or more of the following fields: an EID identifier; replacement selection bits (RPS) that are used by the replacement and update control block <b>120</b> to replace a cache line; and cache coherency protocol bits. For example, each block of the P-cache module may be associated with a valid/invalid bit to indicate if the corresponding cache location is valid or invalid. Alternatively, the status array <b>160</b> may store MESI bits. The replacement selection bits RPS may be used to indicate which cache line is to be replaced. The RPS bits may be used to keep track of the least recently used cache line (for LRU replacement) or the first entered line (for FIFO replacement), as examples. </p><p id=\"P-0052\" num=\"0052\">[0052] The cache controller <b>108</b> may be implemented as an integrated unit or as several separate control units. As discussed, when an instruction is fetched for execution, the EID associated with the instruction is retrieved. Based on the EID value, the appropriate one of the P-cache modules is selected to retrieve data from or write data to. A hit or miss may be returned depending on whether a valid copy of the associated data is stored in the selected P-cache module. </p><p id=\"P-0053\" num=\"0053\">[0053] A multi-unit cache system having independently configurable cache modules according to some embodiments may have one or more of the following advantages. Greater cache management flexibility may be available, since the placement, replacement, and update policies and cache size and organization of each of the P-cache modules may be set to improve cache utilization for corresponding execution entities. Cache performance may be improved by configuring cache modules to take advantage of different cache usage characteristics (to store data or instructions) of different execution entities. Data cache pollution by the different active execution entities in the system <b>10</b> may be reduced, which may improve the cache hit ratio. In addition, the multi-unit data cache system may offer high access bandwidth by increasing parallelism for a multithreading or multitasking processor since the P-cache modules may be concurrently accessible. Such concurrent data cache accesses may help reduce data cache latency to help meet the data access bandwidth demands of high-performance processors. </p><p id=\"P-0054\" num=\"0054\">[0054] In another embodiment, compilers for different application programs may dynamically reconfigure attributes of the multi-unit cache memory to further enhance cache performance. For example, during operation, statistical information associated with different execution entities may be collected and stored. Depending on the collected statistical information, the attributes of each P-cache module may be changed. Thus, for example, if a FIFO replacement policy is determined not to be efficient for a particular P-cache module, the cache controller <b>108</b> may be notified to change the replacement policy to the LRU policy or some other replacement policy. This alternative embodiment may provide the flexibility of dynamically changing the configuration of individual P-cache modules in response to how execution entities in the system <b>10</b> are performing. </p><p id=\"P-0055\" num=\"0055\">[0055] Referring to FIG. 4, in one embodiment, the CPU <b>200</b> includes the multi-unit L1 cache memory <b>202</b> and associated logic. The multi-unit L1 cache memory includes the three data cache modules: the P0-, P1-, and P2-caches <b>102</b>, <b>104</b>, and <b>106</b>. The P0-cache <b>102</b> may be designated as the default data cache that is used to store data associated with execution entities that have not specifically been assigned to one of the other P-caches in the L1 cache. For example, such execution entities may be assigned a default EID 0 by the operating system. The P1- and P2-caches <b>104</b> and <b>106</b> may be assigned to store data for requests from execution entities having EIDs 1 and 2, respectively. In one embodiment, the P0-cache may be a larger memory than either the P1- or P2-cache since it is the default data cache. </p><p id=\"P-0056\" num=\"0056\">[0056] Other components of the CPU <b>200</b> according to one example configuration are illustrated in FIG. 4. A bus front unit (BFU) <b>404</b> forms the interface to the front side or host bus <b>203</b>. The BFU <b>404</b> may include address drivers and receivers, write buffers, data bus transceivers, bus control logic, bus master control, and parity generation and control. </p><p id=\"P-0057\" num=\"0057\">[0057] The instruction path is first described below. Instructions retrieved by the BFU <b>404</b> from either the main memory <b>206</b> or from the L2 cache <b>204</b> may be stored in an instruction cache <b>406</b> that is part of the L1 cache <b>202</b>. The internal instruction cache <b>406</b> may keep copies of the most frequently used instructions. According to some embodiments, instructions are fetched along with EIDs from either the main memory <b>206</b> or the L2 cache <b>204</b> and stored in the instruction cache <b>406</b>. An instruction buffer and decode logic <b>408</b> decodes a selected instruction and associated EID from the instruction cache <b>406</b> and produces one or more micro-operations along with corresponding EIDs. </p><p id=\"P-0058\" num=\"0058\">[0058] In an alternative embodiment, the instructions are stored in different instruction memory regions of the memory <b>206</b> according to different EIDs. However, in this embodiment, the EIDs are not stored along with the instructions. When the CPU <b>200</b> fetches an instruction, an associated EID is not retrieved. Instead, the CPU <b>200</b> determines the EID of the fetched instruction based on the address location where the instruction is stored. This may be performed, for example, by the decode logic <b>408</b>. Thus, the EID of an instruction is determined based on which instruction memory region the instruction is fetched from. Once the EID is determined by the CPU <b>200</b>, it can be attached to the decoded micro-operations and stored in the instruction queue <b>412</b>. </p><p id=\"P-0059\" num=\"0059\">[0059] In yet a further embodiment in which EIDs are not stored along with instructions in memory, multiple program counters and microsequencers may be included in the CPU <b>200</b> that are assigned to corresponding threads. This embodiment is described further below. </p><p id=\"P-0060\" num=\"0060\">[0060] The output port of the instruction buffer and decode logic <b>408</b> may be coupled to an instruction queue <b>412</b>, which stores the micro-operations along with associated EIDs. The output port of the instruction queue <b>412</b> is routed to a sequencer <b>414</b>. The sequencer <b>414</b> may include multiple microsequencer units <b>430</b>, <b>432</b>, and <b>434</b> corresponding to the different EIDs. For example, the microsequencer unit <b>430</b> may be configured to process micro-operations associated with EID 0, the microsequencer <b>432</b> may be configured to process micro-operations associated with EID 1, and the microsequencer <b>434</b> may be configured to process micro-operations associated with EID 2. The micro-operations processed by the microsequencers <b>430</b>, <b>432</b>, and <b>434</b> are received from the instruction queue <b>412</b>. According to one embodiment, the microsequencers <b>430</b>, <b>432</b>, and <b>434</b> may operate simultaneously to process micro-operations associated with different EIDs. Operation of the microsequencers <b>430</b>, <b>432</b>, and <b>434</b> are controlled by a control logic <b>436</b> in the sequencer <b>414</b>. </p><p id=\"P-0061\" num=\"0061\">[0061] In one embodiment, the EIDs associated with micro-operations are originally retrieved from memory along with instructions of the different execution entities. In a further embodiment in which instructions are are not stored along with instructions, each microsequencer may be independently configured to fetch instructions of corresponding execution entities. Thus, a first microsequencer fetches instructions associated with a first execution entity, a second microsequencer fetches instructions associated with a second execution entity, and so forth. The EIDs of a fetched instruction may thus be determined based on which of the microsequencers fetched the instruction. </p><p id=\"P-0062\" num=\"0062\">[0062] An execution entity typically includes a number of instructions that are executed in some program order. By default, instruction addresses are simply incremented to fetch the next instruction. If a jump or other conditional branch occurs, then a target address is specified for the address of the next instruction. Thus, the address of the memory location where the next instruction is stored is known. A program counter may be used to keep track of the program order of instructions. A microsequencer works in conjunction with the program counter to execute instructions. To fetch an instruction, the microsequencer may ask a fetch unit, located in the BFU <b>404</b> for example, to fetch an instruction with an address stored in the program counter. Thus, fetched instructions may be identified as belonging to an execution entity since the microsequencer already knows (from the program counter) the address of the next instruction. </p><p id=\"P-0063\" num=\"0063\">[0063] Thus, for example, given a system with several threads, two or more independent program counters may be used. For example, three program counters PC0, PC1, and PC2 may be associated with microsequencers <b>430</b>, <b>432</b>, and <b>434</b>, respectively. The operating system may load the initial states of the program counters PC0, PC1, and PC2 so that the program counters may fetch instructions associated with the different threads. The combination of PC0 and microsequencer <b>430</b> keeps track of the program sequence for a first thread, the combination of PC1 and microsequencer <b>432</b> keeps track of the program sequence for a second thread, and so forth. When an instruction pointed to by PC0 is fetched, the CPU <b>200</b> knows that the instruction belongs to a first thread having, for example, EID 0. The EID is then attached to the instruction in the CPU <b>200</b> and to subsequently decoded micro-operations that are stored in the instruction queue <b>412</b> for execution by the microsequencer <b>430</b>, <b>432</b>, or <b>434</b> in the sequencer <b>414</b>. </p><p id=\"P-0064\" num=\"0064\">[0064] As shown in FIG. 4, the output port of the sequencer <b>414</b> is provided to a pipeline back-end block <b>415</b> that includes various functional units, such as for example, an early branch execution unit <b>416</b>, a fast decoder unit <b>418</b>, an arithmetic/logic unit (ALU) <b>420</b>, and an address generator unit (AGU) <b>422</b>. During execution of one or more micro-operations by the sequencer <b>414</b>, these functional units may be accessed to perform requested functions. </p><p id=\"P-0065\" num=\"0065\">[0065] The pipeline back-end block <b>415</b> also includes register files <b>424</b>, <b>426</b>, and <b>428</b>. The register files <b>424</b>, <b>426</b> and <b>428</b> in the CPU <b>200</b> correspond to the three EID groups EID 0, EID 1, and EID 2. The register files <b>424</b>, <b>426</b> and <b>428</b> may each include control registers, status registers, flag registers, and general purpose registers. The register files <b>424</b>, <b>426</b>, and <b>428</b> are updated by the functional units in the pipeline back-end block <b>415</b> during operation. According to one embodiment, the register files <b>424</b>, <b>426</b>, and <b>428</b> may also be accessible independently and concurrently. </p><p id=\"P-0066\" num=\"0066\">[0066] In the illustrated embodiment, requests associated with different EIDs may be processed concurrently provided that there are no dependencies among the requests, and further, the multiple requests do not need to utilize the same functional units <b>416</b>, <b>418</b>, <b>420</b>, and <b>422</b>. During concurrent operation of the microsequencers <b>430</b>, <b>432</b>, and <b>434</b>, the register files <b>424</b>, <b>426</b>, and <b>428</b> as well as the cache modules in the multi-unit cache memory may be accessed and updated concurrently. </p><p id=\"P-0067\" num=\"0067\">[0067] In the data path of the CPU <b>200</b>, a store buffer <b>450</b> (for write operations) and a load buffer <b>452</b> (for read operations) store data that are retrieved from or targeted for the BFU <b>404</b>. The store and load buffers <b>450</b> and <b>452</b> are coupled to an internal data bus <b>454</b> that is coupled to several units, including the P0-cache <b>102</b>, the P1-cache <b>104</b>, the P2-cache <b>106</b>, the pipeline back-end block <b>415</b>, and a translation look aside buffer (TLB) <b>456</b>. </p><p id=\"P-0068\" num=\"0068\">[0068] Addresses of instructions in the instruction cache <b>406</b> are fed to the TLB <b>456</b>, which is basically a high speed memory in the CPU <b>200</b> that translates the virtual address from the instruction cache <b>406</b> into a physical address to access the data cache modules <b>102</b>, <b>104</b> and <b>106</b>. </p><p id=\"P-0069\" num=\"0069\">[0069] Based on the multi-unit data cache availability, the control logic <b>436</b> in the microcode sequencer <b>414</b> may select an appropriate instruction for processing by one of the microsequencers <b>430</b>, <b>432</b>, and <b>434</b>. If data access is needed, the microsequencers <b>430</b>, <b>432</b>, and <b>434</b> may concurrently access the several modules in the multi-unit data cache. Thus, to improve system performance, multiple instructions may be executed in the CPU <b>200</b> with concurrent access to data in the L1 multi-unit cache <b>202</b>. </p><p id=\"P-0070\" num=\"0070\">[0070] In some embodiments, the control logic <b>436</b> of the sequencer <b>414</b> may also consider possible load/store ordering, outstanding data cache refilling, and other issues. For example, in one embodiment, instructions associated with a request that has been determined to have a high hit ratio may be scheduled first, as may instructions of a real-time constrained execution entity having high priority. </p><p id=\"P-0071\" num=\"0071\">[0071] Referring to FIG. 5, the general flow of an instruction execution sequence according to an embodiment is illustrated. Instructions are fetched from main memory <b>206</b> or L2 cache <b>204</b> (at <b>302</b>) by the CPU <b>200</b> over the host bus <b>203</b>. In one embodiment, associated EIDs are retrieved with the instructions. In another embodiment, the associated EIDs are not stored and thus are not retrieved. The fetched instructions are then translated into internal micro-operations (at <b>304</b>) by the decoder stage <b>408</b>, with a corresponding EID attached to each micro-operation. The EID may be the one fetched with the instruction or it may be determined by the CPU <b>200</b> based on the address location of the instruction or which microsequencer fetched the instruction. Next, the translated micro-operation is stored in the instruction queue <b>412</b> (at <b>306</b>). The micro-operation is then delivered to one of the microsequencers <b>430</b>, <b>432</b>, and <b>434</b> for execution (at <b>308</b>). Execution of the micro-operation may cause a data cache access request to be made (at <b>310</b>), in which case a corresponding one of the P-cache modules is accessed based on the attached EID. The EID is decoded by the cache controller <b>108</b> and an appropriate request is sent to a corresponding P-cache (<b>102</b>, <b>104</b>, or <b>106</b>). The data access request is then completed in the assigned P-cache (at <b>312</b>). </p><p id=\"P-0072\" num=\"0072\">[0072] While the embodiments described include a multi-unit cache memory to store data, it is contemplated that the multi-unit cache memory may be adapted to store instructions of different execution entities in further embodiments. In such embodiments, the information stored in the multi-unit cache memory includes the instructions themselves. </p><p id=\"P-0073\" num=\"0073\">[0073] While the invention has been disclosed with respect to a limited number of embodiments, those skilled in the art will appreciate numerous modifications and variations therefrom. It is intended that the appended claims cover all such modifications and variations as fall within the true spirit and scope of the invention.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Zhong-ning", "last_name": "Cai", "name": ""}, {"first_name": "Tosaku", "last_name": "Nakanishi", "name": ""}], "assignees": [{"first_name": "", "last_name": "INTEL CORPORATION", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  12/08"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F  12/08        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "711129"}, {"primary": false, "label": "711133"}, {"primary": false, "label": "711122"}, {"primary": false, "label": "711E12039"}, {"primary": false, "label": "711128"}, {"primary": false, "label": "711E12046"}], "ecla_classes": [{"label": "G06F  12/08B6M2"}, {"label": "G06F  12/08B4T"}], "cpc_classes": [{"label": "G06F  12/0848"}, {"label": "G06F  12/0842"}], "f_term_classes": [], "legal_status": "Granted", "priority_date": "1998-12-08", "application_date": "1998-12-08", "family_members": [{"ucid": "AU-6497199-A", "titles": [{"lang": "EN", "text": "Buffer memory management in a system having multiple execution entities"}]}, {"ucid": "US-20010049770-A1", "titles": [{"lang": "EN", "text": "BUFFER MEMORY MANAGEMENT IN A SYSTEM HAVING MULTIPLE EXECUTION ENTITIES"}]}, {"ucid": "DE-19983793-T0", "titles": []}, {"ucid": "HK-1036662-A1", "titles": [{"lang": "EN", "text": "BUFFER MEMORY MANAGEMENT IN A SYSTEM HAVING MULTIPLE EXECUTION ENTITIES"}]}, {"ucid": "CN-1179276-C", "titles": [{"lang": "ZH", "text": "\u914d\u7f6e\u4e0d\u540c\u7684\u9ad8\u901f\u7f13\u5b58\u5206\u533a\u4ee5\u5177\u6709\u4e0d\u540c\u5c5e\u6027\u7684\u7cfb\u7edf\u548c\u65b9\u6cd5"}, {"lang": "EN", "text": "Buffer memory management in system haivng multiple execution entities"}]}, {"ucid": "DE-19983793-B4", "titles": [{"lang": "EN", "text": "A system comprising a processor on which a plurality of concurrent execution entities are executed, and a cache memory having multiple cache sections associated with execution entities"}, {"lang": "DE", "text": "System mit einem Prozessor, auf dem mehrere, gleichzeitig aktive Ausf\u00fchrungsentit\u00e4ten ausgef\u00fchrt werden, und mit einem mehrere, den Ausf\u00fchrungsentit\u00e4ten zugewiese Cache-Abschnitte aufweisenden Cache-Speicher"}]}, {"ucid": "US-20020046325-A1", "titles": [{"lang": "EN", "text": "Buffer memory management in a system having multiple execution entities"}]}, {"ucid": "US-6470422-B2", "titles": [{"lang": "EN", "text": "Buffer memory management in a system having multiple execution entities"}]}, {"ucid": "GB-2359163-A", "titles": [{"lang": "EN", "text": "Buffer memory management in a system having multiple execution entities"}]}, {"ucid": "US-6349363-B2", "titles": [{"lang": "EN", "text": "Multi-section cache with different attributes for each section"}]}, {"ucid": "CN-1334938-A", "titles": [{"lang": "EN", "text": "Buffer memory management in system haivng multiple execution entities"}, {"lang": "ZH", "text": "\u6709\u591a\u6267\u884c\u5b9e\u4f53\u7684\u7cfb\u7edf\u4e2d\u7684\u7f13\u51b2\u5b58\u50a8\u7ba1\u7406"}]}, {"ucid": "GB-0111896-D0", "titles": [{"lang": "EN", "text": "Buffer memory management in a system having multiple execution entities"}]}, {"ucid": "DE-19983793-T1", "titles": [{"lang": "EN", "text": "Cache management in a system with multiple execution units"}, {"lang": "DE", "text": "Pufferspeicherverwaltung in einem System mit mehreren Ausf\u00fchrungseinheiten"}]}, {"ucid": "GB-2359163-B", "titles": [{"lang": "EN", "text": "Buffer memory management in a system having multiple execution entities"}]}, {"ucid": "WO-2000034870-A1", "titles": [{"lang": "FR", "text": "GESTION DE MEMOIRE TAMPON DANS UN SYSTEME AYANT DE MULTIPES ENTITES D'EXECUTION"}, {"lang": "EN", "text": "BUFFER MEMORY MANAGEMENT IN A SYSTEM HAVING MULTIPLE EXECUTION ENTITIES"}]}]}