{"patent_number": "US-6633971-B2", "publication_id": 73580099, "family_id": 23628898, "publication_date": "2003-10-14", "titles": [{"lang": "EN", "text": "Mechanism for forward data in a processor pipeline using a single pipefile connected to the pipeline"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA50562580\"><p>A method for forwarding data within a pipeline of a pipelined data processor having a plurality of execution pipeline stages where each stage accepts a plurality of operand inputs and generates a result. The result generated by each execution pipeline stage is selectively coupled to an operand input of one of the execution pipeline stages.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00001\" num=\"1\"><claim-text>1. A method for forwarding data within a pipeline of a pipelined data processor comprising the steps of:</claim-text><claim-text>providing a plurality of execution pipeline stages where each stage accepts a plurality of operand inputs and generates a result; </claim-text><claim-text>copying the results generated by each execution pipeline stage to an entry of a single pipefile, the entry corresponding to the execution pipeline stage; and </claim-text><claim-text>selectively coupling the result generated by each execution pipeline stage to an operand input of one of the execution pipeline stages. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00002\" num=\"2\"><claim-text>2. The method of <claim-ref idref=\"US-6633971-B2-CLM-00001\">claim 1</claim-ref> wherein the selectively coupling comprises coupling the result generated by a specific one of the execution pipeline stages to an operand input of the same execution pipeline stage.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00003\" num=\"3\"><claim-text>3. The method of <claim-ref idref=\"US-6633971-B2-CLM-00001\">claim 1</claim-ref> wherein the selectively coupling comprises coupling the result generated by a first of the execution pipeline stages to an operand input of a second of the execution pipeline stage.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00004\" num=\"4\"><claim-text>4. The method of <claim-ref idref=\"US-6633971-B2-CLM-00001\">claim 1</claim-ref>, wherein the step of selectively coupling is performed substantially simultaneously with the step of copying.</claim-text></claim>"}, {"num": 5, "parent": 4, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00005\" num=\"5\"><claim-text>5. The method of <claim-ref idref=\"US-6633971-B2-CLM-00004\">claim 4</claim-ref> wherein the step of selectively coupling is performed so as-to make the selectively coupled result available as an operand input before pipefile entry to which the result is being copied is valid.</claim-text></claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00006\" num=\"6\"><claim-text>6. A data processor comprising:</claim-text><claim-text>a plurality of execution pipeline stages where each stage accepts a plurality of operand inputs and generates a result; </claim-text><claim-text>a results bus directly distributing the generated results from each of the execution pipeline stages throughout the plurality of pipeline stages; </claim-text><claim-text>a pipefile coupled to the results bus to selectively receive the generated results; and </claim-text><claim-text>a multiplexor associated with each execution pipeline stage operative to selectively couple the results bus to an operand input of the associated execution pipeline stages. </claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00007\" num=\"7\"><claim-text>7. The data processor of <claim-ref idref=\"US-6633971-B2-CLM-00006\">claim 6</claim-ref> wherein the multiplexor is operative to selectively couple the result of each of the execution pipeline stages to an operand input of the execution pipeline stage generating the result.</claim-text></claim>"}, {"num": 8, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00008\" num=\"8\"><claim-text>8. The data processor of <claim-ref idref=\"US-6633971-B2-CLM-00006\">claim 6</claim-ref> wherein the multiplexor is operative to selectively couple the result of a first of the execution pipeline stages to an operand input of a second of the execution pipeline stages.</claim-text></claim>"}, {"num": 9, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00009\" num=\"9\"><claim-text>9. The data processor of <claim-ref idref=\"US-6633971-B2-CLM-00006\">claim 6</claim-ref> further comprising:</claim-text><claim-text>a pipefile coupled to the results bus and operative to store the data on the result bus at substantially the same time that the multiplexor selectively couples the result bus to an operand input. </claim-text></claim>"}, {"num": 10, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00010\" num=\"10\"><claim-text>10. A method of forwarding data between multiple execution stages forming an execution pipeline of a data processor, comprising the steps of:</claim-text><claim-text>applying multiple operands of an instruction to the execution pipeline to produce a result from each of the multiple execution stages; </claim-text><claim-text>each of the multiple execution stages producing a result; </claim-text><claim-text>selectively coupling the result from each of the multiple execution stages to an entry of a pipefile corresponding to such execution stage; </claim-text><claim-text>selectively coupling the result from each of the multiple execution stages to a register in a general register file; and </claim-text><claim-text>selectively coupling an entry of the pipefile and a register in the general register file to a first one of the multiple execution stages of the execution pipeline. </claim-text></claim>"}, {"num": 11, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00011\" num=\"11\"><claim-text>11. The method of <claim-ref idref=\"US-6633971-B2-CLM-00010\">claim 10</claim-ref>, wherein the entry coupled to the first execution stage of the execution pipeline is an operand.</claim-text></claim>"}, {"num": 12, "parent": 10, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00012\" num=\"12\"><claim-text>12. The method of <claim-ref idref=\"US-6633971-B2-CLM-00010\">claim 10</claim-ref>, the coupling step including the step of writing the result to a snapshot register.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00013\" num=\"13\"><claim-text>13. A method of forwarding data between multiple execution stages forming an execution pipeline of a data processor, comprising the steps of:</claim-text><claim-text>providing multiple operands to the execution pipeline for performing an operation whereby each of the multiple execution stages produces a result; </claim-text><claim-text>copying the result produced by each of the multiple execution stages to a corresponding entry of a single pipefile; and </claim-text><claim-text>selectively coupling the content of the single pipefile to each of the multiple execution stages. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00014\" num=\"14\"><claim-text>14. The method of <claim-ref idref=\"US-6633971-B2-CLM-00013\">claim 13</claim-ref>, wherein the multiple execution stages includes an input execution stage for receiving the multiple operands, and including coupling the result produced by each of the other of the multiple execution stages to the input execution stage.</claim-text></claim>"}, {"num": 15, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00015\" num=\"15\"><claim-text>15. A data processor, including:</claim-text><claim-text>an execution pipeline, comprising a plurality of execution stages, including a first execution stage, coupled to receive operands of an instruction for performing operations dictated by said instruction; </claim-text><claim-text>a single pipefile coupled to receive output from the execution stages; and </claim-text><claim-text>a memory coupled via the pipefile to each of the plurality of execution stages for receiving and storing a result at a memory entry corresponding to such execution stage. </claim-text></claim>"}, {"num": 16, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00016\" num=\"16\"><claim-text>16. The data processor of <claim-ref idref=\"US-6633971-B2-CLM-00015\">claim 15</claim-ref>, including a selector operating to forward a selected one of the memory entries to the first execution stage of the execution pipeline.</claim-text></claim>"}, {"num": 17, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00017\" num=\"17\"><claim-text>17. The data processor of <claim-ref idref=\"US-6633971-B2-CLM-00015\">claim 15</claim-ref>, including a selector operating to forward a selected one of the memory entries to a one of the plurality of execution stages of the execution pipeline.</claim-text></claim>"}, {"num": 18, "parent": 15, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00018\" num=\"18\"><claim-text>18. The data processor of <claim-ref idref=\"US-6633971-B2-CLM-00015\">claim 15</claim-ref>, including a snapshot register for receiving and storing instruction decode and execution information.</claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00019\" num=\"19\"><claim-text>19. The data processor of <claim-ref idref=\"US-6633971-B2-CLM-00018\">claim 18</claim-ref>, wherein the instruction execution information includes criteria for selecting a source operands received by the execution pipeline.</claim-text></claim>"}, {"num": 20, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00020\" num=\"20\"><claim-text>20. An execution pipeline of a data processor, including</claim-text><claim-text>a plurality of serial connected pipeline execution stages, including an input pipeline execution stage that receives one or more operands for performing an operation, each of the plurality of pipeline execution stages having a result output directly coupled to an input of each of the other of the plurality of pipeline execution stages, each result output further selectively coupled to a pipefile. </claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00021\" num=\"21\"><claim-text>21. The execution pipeline of <claim-ref idref=\"US-6633971-B2-CLM-00020\">claim 20</claim-ref>, wherein the result output of each of the plurality of pipeline execution stages is coupled to an input of the input pipeline execution stage.</claim-text></claim>"}, {"num": 22, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00022\" num=\"22\"><claim-text>22. The execution pipeline of <claim-ref idref=\"US-6633971-B2-CLM-00020\">claim 20</claim-ref>, including a pipefile having at least one pipefile entry for each of the plurality of pipeline execution stages, the result output of each pipeline execution stage being coupled to a corresponding pipefile entry, each corresponding pipefile entry being coupled to an input of each of the pipeline execution stages.</claim-text></claim>"}, {"num": 23, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00023\" num=\"23\"><claim-text>23. A method of forwarding result data between a plurality of serial connected execution stages of an execution pipeline of a data processor, including the steps of:</claim-text><claim-text>providing one or more operands to a first one of the plurality of execution stages, the each execution stages operating to perform an operation and to produce a result; </claim-text><claim-text>selectively coupling the result produced by each execution stage to a corresponding entry of a pipefile and to a register of a register file for storage; and </claim-text><claim-text>selectively coupling an entry of the pipefile and a register of the register file to an input of each of the execution stages. </claim-text></claim>"}, {"num": 24, "parent": 23, "type": "dependent", "paragraph_markup": "<claim id=\"US-6633971-B2-CLM-00024\" num=\"24\"><claim-text>24. The method of <claim-ref idref=\"US-6633971-B2-CLM-00023\">claim 23</claim-ref>, including the step of coupling the result produced by each execution stage to the first one of the plurality of execution stages.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES53999991\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates in general to microprocessors and, more particularly, to a system, method, and mechanism providing data forwarding in a pipeline processor.</p><p>2. Relevant Background</p><p>Computer programs comprise a series of instructions that direct a data processing mechanism to perform specific operations on data. These operations including loading data from memory, storing data to memory, adding, multiplying, and the like. Data processors, including microprocessors, microcontrollers, and the like include a central processing unit (CPU) comprising one or more functional units that perform various tasks. Typical functional units include a decoder, an instruction cache, a data cache, an integer execution unit, a floating point execution unit, a load/store unit, and the like. A given program may run on a variety of data processing hardware.</p><p>Early data processors executed only one instruction at a time. Each instruction was executed to completion before execution of a subsequent instruction was begun. Each instruction typically requires a number of data processing operations and involves multiple functional units within the processor. Hence, an instruction may consume several clock cycles to complete. In serially executed processors each functional unit may be busy during only one step, and idle during the other steps. The serial execution of instructions results in the completion of less than one instruction per clock cycle.</p><p>As used herein the term \u201cdata processor\u201d includes complex instruction set computers (CISC), reduced instruction set computers (RISC) and hybrids. A data processor may be a stand alone central processing unit (CPU) or an embedded system comprising a processor core integrated with other components to form a special purpose data processing machine. The term \u201cdata\u201d refers to a digital or binary information that may represent memory addresses, data, instructions, or the like.</p><p>In response to the need for improved performance several techniques have been used to extend the capabilities of these early processors including pipelining, superpipelining, and superscaling. Pipelined architectures attempt to keep all the functional units of a processor busy at all times by overlapping execution of several instructions. Pipelined designs increase the rate at which instructions can be executed by allowing a new instruction to begin execution before a previous instruction is finished executing. A simple pipeline may have only five stages whereas an extended pipeline may have ten or more stages. In this manner, the pipeline hides the latency associated with the execution of any particular instruction.</p><p>The goal of pipeline processors is to execute multiple instructions per cycle (IPC). Due to pipeline hazards, actual throughput is reduced. Pipeline hazards include structural hazards, data hazards, and control hazards. Structural hazards arise when more than one instruction in the pipeline requires a particular hardware resource at the same time (e.g., two execution units requiring access to a single ALU resource in the same clock cycle). Data hazards arise when an instruction needs as input the output of an instruction that has not yet produced that output. Control hazards arise when an instruction changes the program counter (PC) because execution cannot continue until the target instruction from the new PC is fetched.</p><p>When hazards occur, the processor must stall or place \u201cbubbles\u201d (e.g., NOPs) in the pipeline until the hazard condition is resolved. This increases latency and decreases instruction throughput. As pipelines become longer, the likelihood of hazards increases. Hence, an effective mechanism for handling hazard conditions is important to achieving the benefits of deeper pipelines.</p><p>Another goal of many processors is to control the power used by the processor. Many applications, particularly those directed at mobile or battery operated environments, require low power usage. The execution pipelines of a computer consume a significant amount of power. Power consumption is largely caused by moving data between registers, files, and execution units. As data paths become wider, the power consumed to move the data increases.</p><p>Hence, in order to execute instructions efficiently at a high throughput within a pipeline it is important to coordinate and control the flow of instructions, operations, and data within the execution pipeline. The order and manner in which the operands and results of these instructions are made available to each other within the execution pipeline is of critical importance to the throughput of the pipeline.</p><h4>SUMMARY OF THE INVENTION</h4><p>Briefly stated, the present invention involves A method for forwarding data within a pipeline of a pipelined data processor having a plurality of execution pipeline stages where each stage accepts a plurality of operand inputs and generates a result. The result generated by each execution pipeline stage is selectively coupled to an operand input of one of the execution pipeline stages.</p><p>The present invention also involves a data processor having a plurality of execution pipeline stages where each stage accepts a plurality of operand inputs and generates a result. A results bus distributes the generated results from each of the execution pipeline stages throughout the plurality of pipeline stages. A multiplexor associated with each execution pipeline stage operative to selectively couple the results bus to an operand input of the associated execution pipeline stages.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><p>The foregoing and other features, utilities and advantages of the invention will be apparent from the following more particular description of a preferred embodiment of the invention as illustrated in the accompanying drawings.</p><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 shows in block diagram form a computer system incorporating an apparatus and system in accordance with the present invention;</p><p>FIG. 2 shows a processor in block diagram form incorporating the apparatus and method in accordance with the present invention;</p><p>FIG. 3 illustrates a CPU core useful in the implementation of the processor and system shown in FIG. <b>1</b> and FIG. 2 in accordance with the present invention;</p><p>FIG. 4 shows an instruction fetch unit in which features of the present invention are embodied in a particular implementation;</p><p>FIG. 5 illustrates an exemplary execution pipeline in accordance with a specific embodiment of the present invention;</p><p>FIG. 6 illustrates comparative pipeline timing for the execution pipeline shown in FIG. 5;</p><p>FIG. <b>7</b>A and FIG. 7B show exemplary a snapshot register entries in accordance with embodiments of the present invention; and</p><p>FIG. 8 shows an operand multiplexing mechanism in accordance with an embodiment of the present invention; and</p><p>FIG. 9 schematically illustrates internal operand forwarding mechanism in accordance with the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</h4><p>The present invention involves data forwarding in a pipeline data processor such as an embedded processor, a microprocessor, or microcontroller. Data forwarding involves making internal data objects and results generated by instructions that have not yet completed execution available for use by other instructions. This process involves both detecting when data forwarding will be possible and then configuring the execution pipeline stage hardware to use data forwarded from other pipeline stage result(s) rather than from instruction-specified registers and resources. In particular, data forwarding is used to detect and avert hazard conditions that might stall or slow the pipeline, and configure data paths to forwards operands efficiently amongst execution units, handle exception conditions efficiently and precisely, and similar control operations.</p><p>Any system is usefully described as a collection of processes or modules communicating via data objects or messages as shown in FIG. <b>1</b>. The modules may be large collections of circuitry whose properties are somewhat loosely defined, and may vary in size or composition significantly. The data object or message is a communication between modules that make up the system. To actually connect a module within the system it is necessary to define an interface between the system and the component module.</p><p>The present invention is illustrated in terms of a media system <b>100</b> shown in FIG. <b>1</b>. Media processor <b>100</b> comprises, for example, a \u201cset-top box\u201d for video processing, a video game controller, a digital video disk (DVD) player, and the like. Essentially, system <b>100</b> is a special purpose data processing system targeted at high throughput multimedia applications. Features of the present invention are embodied in processor <b>101</b> that operates to communicate and process data received through a high speed bus <b>102</b>, peripheral bus <b>104</b>, and memory bus <b>106</b>.</p><p>Video controller <b>105</b> receives digital data from system bus <b>102</b> and generates video signals to display information on an external video monitor, television set, and the like. The generated video signals may be analog or digital. Optionally, video controller may receive analog and/or digital video signals from external devices as well. Audio controller <b>107</b> operates in a manner akin to video controller <b>105</b>, but differs in that it controls audio information rather than video. Network I/O controller <b>109</b> may be a conventional network card, ISDN connection, modem, and the like for communicating digital information. Mass storage device <b>111</b> coupled to high speed bus <b>102</b> may comprise magnetic disks, tape drives, CDROM, DVD, banks of random access memory, and the like. A wide variety of random access and read only memory technologies are available and are equivalent for purposes of the present invention. Mass storage <b>111</b> may include computer programs and data stored therein. In a particular example, high speed bus <b>102</b> is implemented as a peripheral component interconnect (PCI) industry standard bus. An advantage of using an industry standard bus is that a wide variety of expansion units such as controller's <b>105</b>, <b>107</b>, <b>109</b> and <b>111</b> are readily available.</p><p>Peripherals <b>113</b> include a variety of general purpose I/O devices that may require lower bandwidth communication than provided by high speed bus <b>102</b>. Typical I/O devices include read only memory (ROM) devices such as game program cartridges, serial input devices such as a mouse or joystick, keyboards, and the like. Processor <b>101</b> includes corresponding serial port(s), parallel port(s), printer ports, and external timer ports to communicate with peripherals <b>113</b>. Additionally, ports may be included to support communication with on-board ROM, such as a BIOS ROM, integrated with processor <b>101</b>. External memory <b>103</b> is typically required to provide working storage for processor <b>101</b> and may be implemented using dynamic or static RAM, ROM, synchronous DRAM, or any of a wide variety of equivalent devices capable of storing digital data in a manner accessible to processor <b>101</b>.</p><p>Processor <b>101</b> is illustrated in a greater detail in the functional diagram of FIG. <b>2</b>. One module in a data processing system is a central processor unit (CPU) core <b>201</b>. The CPU core <b>201</b> includes, among other components execution resources (e.g., arithmetic logic units, registers, control logic) and cache memory. These functional units, discussed in greater detail below, perform the functions of fetching instructions and data from memory, preprocessing fetched instructions, scheduling instructions to be executed, executing the instructions, managing memory transactions, and interfacing with external circuitry and devices.</p><p>CPU core <b>201</b> communicates with other components shown in FIG. 2 through a system bus <b>202</b>. In the preferred implementation system bus <b>202</b> is a high-speed network bus using packet technology and is referred to herein as a \u201csuper highway\u201d. Bus <b>202</b> couples to a variety of system components. Of particular importance are components that implement interfaces with external hardware such as external memory interface unit <b>203</b>, PCI bridge <b>207</b>, and peripheral bus <b>204</b>.</p><p>The organization of interconnects in the system illustrated in FIG. 2 is guided by the principle of optimizing each interconnect for its specific purpose. The bus system <b>202</b> interconnect facilitates the integration of several different types of sub-systems. It is used for closely coupled subsystems which have stringent memory latency/bandwidth requirements. The peripheral subsystem bus <b>204</b> supports bus standards which allow easy integration of hardware of types indicated in reference to FIG. <b>1</b> through interface ports <b>213</b>. PCI bridge <b>207</b> provides a standard interface that supports expansion using a variety of PCI standard devices that demand higher performance that available through peripheral port <b>204</b>. The system bus <b>202</b> may be outfitted with an expansion port which supports the rapid integration of application modules without changing the other components of system <b>101</b>. External memory interface <b>203</b> provides an interface between the system bus <b>202</b> and the external main memory subsystem <b>103</b> (shown in FIG. <b>1</b>). The external memory interface comprises a port to system bus <b>202</b> and a DRAM controller.</p><p>The CPU core <b>201</b> can be represented as a collection of interacting functional units as shown in FIG. <b>3</b>. These functional units, discussed in greater detail below, perform the functions of fetching instructions and data from memory, preprocessing fetched instructions, scheduling instructions to be executed, executing the instructions, managing memory transactions, and interfacing with external circuitry and devices.</p><p>A bus interface unit (BIU) <b>301</b> handles all requests to and from the system bus <b>202</b> and external memory. An instruction flow unit (IFU) <b>303</b> is the front end of the CPU pipe and controls fetch, predecode, decode, issue and branch operations in the preferred embodiment. In accordance with the preferred embodiment, IFU <b>303</b> includes a pipe control unit <b>401</b> (shown in FIG. 4) that implements features of the present invention. However, it is contemplated that the inventive features of the present invention may be usefully embodied in a number of alternative processor architectures that will benefit from the performance features of the present invention. Accordingly, these alternative embodiments are equivalent to the particular embodiments shown and described herein.</p><p>An execution unit (IEU) <b>305</b> handles all integer and multimedia instructions. The main CPU datapath includes an instruction cache unit (ICU) <b>307</b> implements an instruction cache (Icache not shown) and an instruction translation lookaside buffer (ITLB, not shown). Load store unit (LSU) <b>309</b> handles all memory instructions. A data cache control unit (DCU) <b>311</b> includes a data cache (Dcache, not shown) and a data translation lookaside buffer (DTLB, not shown). Although the present invention preferably uses separate data and instruction caches, it is contemplated that a unified cache can be used with some decrease in performance. In a typical embodiment, the functional units shown in FIG. 2, and some or all of cache memory <b>105</b> may be integrated in a single integrated circuit, although the specific components and integration density are a matter of design choice selected to meet the needs of a particular application.</p><p>FIG. 4 shows hardware resources within IFU <b>303</b> including a pipe control unit <b>401</b> in accordance with the present invention. FIG. 4 shows a simplified IFU block diagram with the internal blocks as well as the external interfacing units. As shown in FIG. 4, IFU <b>303</b> can be divided into the following functional blocks according to their functions: the instruction cache control unit (ICC) <b>413</b>, the fetch unit (FE) <b>403</b>, the branch unit (BR) <b>411</b>, the decode unit <b>405</b>, the pipe control unit <b>401</b>, and the operand file unit comprising register file <b>407</b> and pipe file <b>409</b>.</p><p>IFU <b>303</b> functions as the sequencer of the CPU core <b>201</b> in accordance with the present invention. It coordinates the flow of instructions and data within the core <b>201</b> as well as merges the external events with the core internal activities. Its main functions are to fetch instructions from ICU <b>307</b> using fetch unit <b>403</b> and decode the instructions in decoder <b>405</b>. IFU <b>303</b> checks for instruction inter-dependency, reads the operands from the register file <b>407</b> and sends the decoded instructions and the operands to the execution units (e.g., IEU <b>305</b>, and LSU <b>309</b>). In addition, IFU <b>303</b> couples to BIU <b>301</b> on instruction cache misses to fill the instruction cache within ICU <b>307</b> with the missing instructions from external memory.</p><p>Because of the sequencing role within the CPU core <b>201</b>, IFU <b>303</b> interfaces with almost every other functional unit. The interface between IFU <b>303</b> and BIU <b>301</b> initiates the loading of instructions into the instruction cache. The interface between IFU <b>303</b> and ICU <b>307</b> provides the flow of instructions for execution. The interface between IFU <b>303</b> and IEU <b>305</b> and LSU <b>309</b> provides the paths for sending/receiving instructions, operands, results, as well as the control signals to enable the execution of instructions. In addition to these interfaces, IFU <b>303</b> may also receive external interrupt signals from an external interrupt controller (shown in FIG. <b>2</b>), which samples and arbitrates external interrupts. IFU <b>303</b> will then arbitrate the external interrupts with internal exceptions and activates the appropriate handler to take care of the asynchronous events.</p><p>Pipe file <b>409</b> operates to collect results from the execution units, and writes them back to the register file <b>407</b>. Once instructions are decoded, pipe control unit <b>401</b> monitors their execution through the remaining pipe stages. The main function of pipe control unit <b>401</b> is to ensure that instructions are executed smoothly and correctly that (i) instructions will be held in the decode stage until the source operands are ready or can be ready when needed, (ii) that synchronization and serialization requirements imposed by the instruction as well as internal/external events are observed, and (iii) that data operands/interim results are forwarded correctly.</p><p>To simplify the pipe control logic, the pipe control unit <b>401</b> makes several observations and assumptions with respect to instruction execution. One of the assumptions is that none of IEU <b>305</b> instructions can cause an exception and all of them flow through the pipe stages deterministically. This assumption allows the pipe control unit <b>401</b> to view IEU <b>305</b> as a complex data operation engine that doesn't need to know where the input operands are coming from and where the output results are going to. All the data forwarding and hazard detection logic can then be lumped into the pipe control unit <b>401</b> using the same simple mechanism. To accommodate for the non-deterministic operations in the LSU <b>309</b>, some modifications are then made to this simple mechanism. The modifications, however, are specifically targeted at the idiosyncrasies of the LSU pipeline, and should cause minimal overhead.</p><p>Another major function of the pipe control unit <b>401</b> is to handle non-sequential events such as instruction exceptions, external interrupts, resets, etc. Under normal execution condition, this part of the pipe control unit <b>401</b> is always in the idle state. It wakes up when an event occurs. The pipe control unit <b>401</b> receives the external interrupt/reset signals from the external interrupt controller (shown in FIG. <b>2</b>). It receives internal exceptions from many parts of the CPU core <b>201</b>. In either case, the pipe control unit <b>401</b> will clean up the pipeline, and then informs the branch unit <b>411</b> to save the core state and branches to the appropriate handler. When multiple exceptions and interrupt occur simultaneously, the pipe control unit <b>401</b> arbitrates between them according to the architecturally defined priority. The pipe control unit <b>401</b> also looks at internal configuration and control registers to determine whether and when an interrupt or exception should be blocked.</p><p>The operand file unit implements the architecturally defined general purpose register file <b>407</b>. In addition, it also implements a limited version of a reorder buffer called \u201cpipe file\u201d <b>409</b> for storing and forwarding interim results that are yet to be committed to architectural registers. Because CPU core <b>201</b> is principally directed at in-order execution, there is only a small window of time that execution results may be produced out-of-order. The present invention takes advantage of this property and implements a simplified version of the reorder buffer that allows interim results to be forwarded as soon as they are produced, while avoiding the expensive tag passing/matching mechanism usually associated with a reorder buffer. The operand file implements the data path portion of this pipe file. The control is implemented in the pipe control unit <b>401</b>.</p><p>FIG. <b>5</b> and FIG. 6 illustrate an example execution pipeline in accordance with the present invention. The particular example is a scalar (i.e., single pipeline), single issue machine. The implementation in FIG. <b>5</b> and FIG. 6 includes three execution stages. Many instructions however execute in a single cycle. The present invention implements features to enable comprehensive forwarding within the pipeline to achieve a high instruction throughput.</p><p>In the pre-decode stage <b>503</b> the instruction cache access which was initiated in the previous cycle is completed and the instruction is returned to IFU <b>303</b> where it can be latched by mid-cycle. An instruction may spend from 1 to n cycles in stage <b>503</b> depending on downstream pipeline instructions. In the second half of stage <b>503</b>, some pre-decoding of the instruction will be carried out. Decode stage <b>505</b> handles the full instruction decode, operand dependency checks and register file read and instruction issue to the execution units.</p><p>The first execution stage <b>507</b> implements the execution of all single cycle integer instructions as well as the address calculation for memory and branch instructions. The second execution stage <b>509</b> implements the second cycle of execution for all multicycle integer/multimedia instructions. Additionally it corresponds to a second cycle for load instructions. The third execution stage <b>511</b> implements the third cycle of execution for multicycle integer/multimedia instructions and a completion cycle for load instructions. Writeback stage <b>513</b> is where architectural state modified by an instruction (e.g general purpose register, program counter etc.) is updated. The exception status of the instruction arriving in this stage or any external exception can prevent the update in this stage.</p><p>The pipe control unit <b>401</b> performs a number of operations in handling the instruction flow. An important feature of the pipe control unit <b>401</b> is the pipeline snapshot file <b>415</b> (shown in FIG. 4) implemented within pipe control unit <b>401</b>. Snapshot file <b>415</b> may be implemented as a lookup table having a table entry <b>701</b> (shown in FIG. 7) corresponding to each execution stage in the pipeline. The snapshot file <b>415</b> provides a central resource for all pipeline control operations such as dependency checks, operand forwarding, exception handling, and the like. In a particular implementation, snapshot file <b>415</b> includes four entries corresponding to the three execution pipeline stages and the write back pipeline stage.</p><p>FIG. <b>7</b>A and FIG. 7B show exemplary snapshot files <b>701</b> and <b>702</b> indicating entries holding metadata describing the instruction execution state at the corresponding pipe stage. As instructions move from one stage to another, their associated snapshot entry moves to the corresponding snapshot entry <b>701</b> or <b>702</b>. The contents of each snapshot entry <b>701</b> may be varied to meet the needs of a particular application. The specific examples shown in FIG. 7 correspond to pipeline control operations described hereinbelow. The essential functionality of examples <b>701</b> and <b>702</b> are similar although the implementation of that essential functionality differs between the examples. In comparing the examples, snapshot file <b>701</b> does not include a \u201cSTAGE\u201d entry as that is implied by the index of the entry whereas example <b>702</b> includes an explicit STAGE entry. The single STAGE_RDY entry of FIG. 7B is implemented using three separate entries (E<b>1</b>_RESULT, E<b>2</b>_RESULT and E<b>3</b>_RESULT) in the example of FIG. <b>7</b>A. The fields have the function generally described in the figures and additional or fewer fields may be added to meet the needs of a particular application.</p><p>In operation, the snapshot register may be used by the pipeline control <b>401</b> to perform a number of parallel checks to classify the instruction currently being processed by the decoder <b>405</b>. For example, the three potential operand register fields of the instruction word are checked against the existing pipe snapshot to detect data dependency, forwarding dependence, write-after-write hazard, and write-after-write for an accumulating-type instruction.</p><p>Data dependency checking is performed by comparing the operand register specifiers of the instruction in decode against the register destinations marked to be written by each subsequent pipeline stage. If there is a match and the data will not be ready in this stage then there is a true data dependency that is resolved by, for example, stalling the instruction currently within the decode stage. Similarly, forwarding dependency checking is performed by comparing Rdest to determine if the result upon which the decoder instruction depends will be ready in the matched stage (forward from the result bus) or a previous stage (implying forward from the pipefile).</p><p>A write-after-write hazard is indicated when an operand register specifier matches on more than one entry. In this case, the dependency can be resolved if the data can be forwarded from the correct (i.e., earlier) conflicting pipeline stage. Accordingly, pipe control can determine to control the forwarding from the earlier stage which matches. Using the same mechanism, the pipe control unit <b>401</b> can easily generate control for the internal forwarding of the IEU <b>305</b> by simply extending the metadata contained in snapshot files <b>701</b> and <b>702</b>.</p><p>When there is an instruction of the IEU-internal forwarding class (e.g., an accumulating-type instruction) in the first or second execution stages <b>507</b> or <b>509</b>, the register destination of this instruction is checked against the register destination of an earlier instruction in the third execution stage <b>511</b>. If a match is found and the instruction in the third execution stage <b>511</b> is of the same class, the pipe control unit <b>401</b> will generate the proper internal forwarding select signals to forward the third stage result to the first or second stage <b>507</b> or <b>509</b>.</p><p>For a hazard to actually be detected one of the source registers of the instruction must be valid and must match against a valid register destination in the snapshot file. Hazard detection of the preferred implementation only detects general purpose register dependencies. Though the snapshot file also stores control register destinations, these are not marked as valid and therefore do not show up in the dependency checks. However, alternative implementations could implement control checks using snapshot files <b>701</b> and <b>702</b> by adding one additional field.</p><p>Under normal conditions once an instruction has been issued to an execution unit its entry will progress through each stage of the snapshot file on each clock edge. At the beginning of each execution stage the control for writing the result to the pipefile is generated. This is determined by checking the E<b>1</b>_RESULT, E<b>2</b>_RESULT, and E<b>3</b>_RESULT fields of the current execution stage. For example, if E<b>1</b>_RESULT field is set for the instruction executing in the EXE_<b>1</b> stage <b>507</b>, the result from EXE_<b>1</b> stage <b>507</b> will then be written into the pipefile entry indexed by the PIPE_FILE_ENTRY field. Similarly, the result from the EXE_<b>2</b> and EXE_<b>3</b> stages will be written into the pipefile <b>409</b> when the E<b>2</b>_RESULT and E<b>3</b>_RESULT fields of the corresponding snapshot file entries are set. The write into pipefile <b>409</b> will occur even if the EXCEPTION field in snapshot file <b>702</b> is set. This is to allow transportation data for exceptions back to the branch unit. Once an instruction reaches write-back, the rdest_valid field also determines if the contents of the pipefile is written back to the architectural register file. Once in write-back, if no exception has occurred, the instruction has completed.</p><p>An important feature of the present invention involves handling internal operand forwarding within the pipeline. Because the snapshot entry <b>701</b> indicates which pipe stage will produce a result to the pipefile <b>409</b>, subsequent instructions can reliably use the interim result from the pipefile <b>409</b> before it is committed to architectural state. By enabling operand bypass between stages a significant percentage of data hazards can be avoided. This process is called internal operand forwarding.</p><p>When decode indicates that it has a valid instruction the pipe control block determines from the instruction code the source of the operands for the instruction. The present invention enables an operand can be sourced from, for example:</p><p>Register operands;</p><p>Indirectly forwarded operands through the three pipefile entries;</p><p>Directly forwarded operands from the result busses of the associated with the instruction execution pipe stages;</p><p>The extended immediate field from the instruction;</p><p>The program counter;</p><p>The contents of an instruction address register (IAR);</p><p>The contents of a control register; and</p><p>A tied low constant field;</p><p>The above gives up to 12 possible sources of input to some operand. FIG. 8 illustrates an exemplary operand multiplexing (\u201cmuxing\u201d) mechanism that enables rich sharing of operands within the pipeline. The mechanism shown in FIG. 8 is distributed throughout pipe control unit <b>401</b> as described below. The operand multiplexor mechanism of FIG. 8 produces three choices (e.g., IFU_SRC<b>1</b>, IFU_SRC<b>2</b>, IFU_SRC<b>3</b>) for the source operands provided to the first execution stage <b>507</b>. Each execution stage produces a result (labeled EXE_<b>1</b>, EXE_<b>2</b>, and EXE_<b>3</b> in FIG. 8) that may be used as a source operand input to the first execution stage <b>507</b>. Execution stage <b>507</b> is associated with a multiplexors <b>809</b><i>a</i>-<b>809</b><i>c </i>for selecting up to three source operands from those available. The specific examples given herein are for purposes of explanation and understanding, and are not a limitation on the actual implementation.</p><p>It should also be understood that execution stage <b>507</b>, <b>509</b> and <b>511</b> shown in FIG. 8 are representative of all of the hardware resources used in that execution stage as defined by the processor microarchitecture. An execution stage is physically implemented using the hardware resources such as those shown in FIG. <b>3</b>. The outputs of multiplexors <b>809</b> are physically coupled to each of the hardware resources that will use the source operands during its operation.</p><p>The multiplexing of these operand sources in the particular example is distributed in the following way:</p><p>The program counter (PC), instruction address registers, and control register contents are pre-muxed in the branch unit using multiplexors <b>801</b> and <b>803</b>. All these inputs are available at the start of the cycle.</p><p>The decode constant extracted from the instruction and possibly tied high zeroes are pre-muxed in the decode stage using multiplexor <b>811</b>.</p><p>The outputs of the pipefile <b>409</b> are muxed with the program counter data and decode constant data respectively in multiplexors <b>805</b> and <b>813</b>.</p><p>The register file contents are muxed with the pipefile outputs using multiplexors <b>807</b>, <b>815</b>, and <b>821</b> to produce source operands which are distributed down the execution datapath (IFU_SRC<b>1</b>, IFU_SRC<b>2</b>, IFU_SRC<b>3</b> in FIG. <b>8</b>).</p><p>Forwarding of completing results is done locally within the execution datapath. As the result is being driven back up the datapath from the various stages of execution (imu_result_exl,_ex<b>2</b> and _ex<b>3</b>), the result taps back into the multiplexors <b>809</b> at the input to the execution sub-units. The result is also driven back up to the pipefile <b>409</b> for ultimate storage in the register file <b>407</b>. Pipe control unit <b>401</b> controls the selection of the multiplexor <b>809</b> latches.</p><p>The LSU ex<b>3</b> result is muxed with the output of the IEU ex<b>3</b> result (from the multiplier). Internally IEU <b>305</b> multiplexes several results into the IEU_EXE<b>3</b> result. In general, all results produced in pipe stage <b>511</b> are multiplexed onto EXE_<b>3</b> result bus line. This is also controlled by the pipe control unit <b>401</b>.</p><p>In this manner, pipe control unit <b>401</b> generates the control signals for multiplexors and execution stage resources. This enables the source operand inputs used by each execution stage to be selected from among a plurality of possible inputs. Of particular significance is that each source operand can be forwarded from the interim results stored in the pipefile if valid results are available in the pipefile. This is useful in handling data hazards in a manner that limits the need to stall the pipeline or fill the pipeline with bubbles while data dependencies resolve. The particular choice and distribution of operand sources can include more or fewer sources to meet the needs of a particular application and unless specified otherwise herein the examples are provided for example purposes only.</p><p>FIG. 9 schematically illustrates the execution stages of a pipeline and the operand sources for each stage. Each execution stage (EXE_<b>1</b>, EXE_<b>2</b> and EXE_<b>3</b>) may generate a result. The specific stage that generates a result for any given instruction will vary from instruction-to-instruction, but is preferably indicated in the \u201cstage_rdy\u201d field of the snapshot file entry <b>702</b> or the E<b>1</b>_RESULT, E<b>2</b>_RESULT and E<b>3</b>_RESULT fields described hereinbefore. Each source operand can be taken from the execution unit's own result output. FIG. 9 shows an operand bus comprising IFU_SRCI, IFU_SRC<b>2</b> and IFU_SRC<b>3</b> (determined as shown in FIG. 8) and a results bus <b>906</b> comprising EXE_<b>1</b>_RESULT, EXE_<b>2</b>_RESULT and EXE_<b>3</b>_RESULT. The results bus <b>906</b> carries results to appropriate entries in pipefile <b>409</b>.</p><p>In the embodiment shown in FIG. 9 each execution stage corresponds to a specific entry in the pipe file <b>409</b> (e.g., EXE_<b>2</b> corresponds to pipefile entry <b>409</b>A, EXE_<b>3</b> stage <b>509</b> corresponds to entry <b>409</b>B). Results are written from the result bus into pipefile <b>409</b> according to the \u201cstage_rdy\u201dvalue in the snapshot register (FIG. 7A) or the El RESULT through E<b>3</b>_RESULT entries (FIG. 7B) as described hereinbefore. Pipefile <b>409</b>A takes the EXE_<b>1</b> result and can forward its contents when the instruction that produces the result is in the EXE_<b>2</b> stage. Similarly, pipefile entry <b>409</b>B takes the EXE_<b>2</b> result and <b>409</b>C takes the EXE_<b>3</b> result respectively. Otherwise, results are moved sequentially from entry <b>409</b>A to <b>409</b>B to <b>409</b>C. Entry <b>409</b>C corresponds to the write back pipe stage. Assuming the snapshot register entry <b>701</b> corresponding to the instruction in the write back stage is valid and does not indicate an exception, the value stored in pipefile stage <b>409</b> is copied to the appropriate register in register file <b>407</b>.</p><p>Significantly, the operands for each execution stage can be selected from either the operand bus or the results bus. Hence, a result that is ready in EXE_<b>1</b> will be driven onto the EXE_<b>1</b>_RESULT line and can be used as an operand on the following cycle in the second and third execution stages before being written to either register file <b>407</b> or the pipefile <b>409</b>. Similarly, a result determined in EXE_<b>3</b> can be used on the next clock cycle as an operand for an instruction executing in the first execution stage (EXE_<b>1</b>). This enables the instruction to be issued to EXE_<b>1</b> without delays or pipeline bubbles normally associated with waiting for the EXE_<b>3</b>_RESULT to be written out to a register or rename register.</p><p>Furthermore, execution stage <b>507</b> can use its own output as well as the outputs of stages <b>509</b> and <b>511</b> as an operand for the next cycle. This is done, for example, by selecting EXE_<b>1</b>_RESULT, EXE_<b>2</b>_RESULT or EXE_<b>3</b>_RESULT as one of its operand inputs. This is particularly useful for accumulate-type operations where the destination register is used in a series of instructions to hold an accumulating result. Without this feature, pipeline bubbles would likely be inserted between accumulate instructions thereby reducing throughput significantly. Using this feature, the decoder can issue accumulating type instructions one-after-another.</p><p>The results are coupled to a corresponding selector unit <b>901</b>. Each selector selectively couples the result to one of the result bus lines. Each selector is controlled by, for example, the pointer value (labeled POINTER_<b>1</b>, POINTER_<b>2</b> and POINTER_<b>3</b> in FIG. 9) corresponding to that pipe stage. The pointer values are determined from the PIPE_FILE_ENTRY and E<b>1</b>_RESULT, E<b>2</b>_RESULT and E<b>3</b>_RESULT fields of snapshot entry <b>701</b>. Alternatively, the pointer value <b>903</b> may be stored in the snapshot file entry <b>701</b> as described hereinbefore, or may be stored in a separate register that operates in a manner such that the pointer value remains associated with a particular instruction as the instruction moves through the pipeline. The result is written to the specified pipefile entry <b>409</b><i>a</i>-<b>409</b><i>c. </i></p><p>Pipefile <b>409</b> preferably comprises dual ported memory structure so that the contents of any entry <b>409</b><i>a</i>-<b>409</b><i>c </i>can be written to and/or read out at any time. The memory within pipefile <b>409</b> is typically implemented using CMOS or BiCMOS static random access memory (SRAM) technology using four or more transistors per stored bit. A multiplexor set <b>903</b> selectively couples the data stored in pipefile entries <b>409</b><i>a</i>-<b>409</b><i>c </i>to appropriate lines on a pipefile bus <b>904</b>. The pipefile bus <b>904</b> provides values to the multiplexing mechanism shown in FIG. 8, for example. Multiplexor set <b>903</b> is controlled by pipe control unit <b>401</b> to couple appropriate bus lines to corresponding entries <b>409</b><i>a</i>-<b>409</b><i>c </i>in pipefile <b>409</b>.</p><p>As a particular example, assume an instruction that generates its result in EXE_<b>1</b> and the pointer values are set such that the EXE_<b>1</b> result is written to pipefile entry <b>409</b><i>b</i>. From pipefile entry <b>409</b><i>b </i>the result can be multiplexed, onto any of the IFU_SRC lines by appropriate settings in multiplexor set <b>903</b>. On the next pipe cycle, the example instruction will move to pipe stage EXE_<b>2</b>, while pipefile entry <b>409</b><i>b </i>remains unchanged. In this manner, a result needs only be written to the results bus one time while remaining continuously available for forwarding while the instruction remains in the pipeline the hundreds of transistors used to store the value in entry <b>409</b><i>b </i>do not have to be switched until after the value is written back and the pipe file entry is reassigned to an instruction in the decoder.</p><p>It is contemplated that the functionality of multiplexor <b>903</b> may be implemented in a variety of ways depending on the level of operand forwarding needed in a particular implementation. For example, if operand forwarding from the pipefile is not needed, there would be no corresponding need to generate the PIPEFILE_SCR<b>1</b>, PIPEFILE_SCR<b>2</b> and PIPEFILE_SCR<b>3</b> lines. The writeback line is controlled by the writeback stage pointer and selects one of the pipefile entries for writeback to an architectural register in register file <b>407</b>.</p><p>A particular example involves execution of accumulate type instructions. Consider a series of instructions such as:</p><p>MAC a, b, x</p><p>MAC c, d, x</p><p>MAC e, f, x</p><p>where MAC is a \u201cmultiply accumulate\u201d instruction that computes the multiple of the first and second operands and accumulates the product with a value stored in a third specified register. Prior implementations would force the MAC c, d, x instruction to wait until the first MAC instruction completed so that the accumulate register (x in the example) is stored in a register or rename register. However, in the present invention, the decode unit is aware that the MAC c, d, x instruction will not need the x register value until the third pipestage. By enabling the third pipestage to accept its own result as an input for the next instruction in that pipestage, the x register value will be immediately available to the subsequent instructions. Hence, the MAC instructions can be streamed one after the other into the pipeline without bubbles.</p><p>While the invention has been particularly shown and described with reference to a preferred embodiment thereof, it will be understood by those skills in the art that various other changes in the form and details may be made without departing from the spirit and scope of the invention. The various embodiments have been described using hardware examples, but the present invention can be readily implemented in software. For example, it is contemplated that a programmable logic device, hardware emulator, software simulator, or the like of sufficient complexity could implement the present invention as a computer program product including a computer usable medium having computer readable code embodied therein to perform precise architectural update in an emulated or simulated out-of-order machine. Accordingly, these and other variations are equivalent to the specific implementations and embodiments described herein.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Chih-Jui", "last_name": "Peng", "name": ""}, {"first_name": "Lew", "last_name": "Chua-Eoan", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "HITACHI, LTD."}, {"first_name": "", "last_name": "RENESAS TECHNOLOGY CORPORATION", "name": ""}, {"first_name": "", "last_name": "HITACHI, LTD.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F   9/34"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/34        20060101A I20051110RMEP"}, {"label": "G06F   9/38        20060101AFI20051220RMJP"}, {"label": "G06F   9/30        20060101A I20051110RMEP"}], "national_classes": [{"primary": true, "label": "712218"}, {"primary": false, "label": "712E09046"}, {"primary": false, "label": "712E09065"}], "ecla_classes": [{"label": "G06F   9/38D1"}, {"label": "G06F   9/38D"}, {"label": "G06F   9/38P6"}], "cpc_classes": [{"label": "G06F   9/3875"}, {"label": "G06F   9/3824"}, {"label": "G06F   9/3824"}, {"label": "G06F   9/3875"}, {"label": "G06F   9/3826"}, {"label": "G06F   9/3826"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1999-10-01", "application_date": "1999-10-01", "family_members": [{"ucid": "US-6633971-B2", "titles": [{"lang": "EN", "text": "Mechanism for forward data in a processor pipeline using a single pipefile connected to the pipeline"}]}, {"ucid": "US-20030154364-A1", "titles": [{"lang": "EN", "text": "MECHANISM FOR INSTRUCTION DATA FORWARDING IN A PIPELINE PROCESSOR"}]}, {"ucid": "JP-2001142699-A", "titles": [{"lang": "JA", "text": "\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u30d7\u30ed\u30bb\u30c3\u30b5\u306b\u304a\u3051\u308b\u547d\u4ee4\u30c7\u30fc\u30bf\u306e\u8ee2\u9001\u30e1\u30ab\u30cb\u30ba\u30e0"}, {"lang": "EN", "text": "TRANSFER MECHANISM OF INSTRUCTION DATA IN PIPELINE PROCESSOR"}]}]}