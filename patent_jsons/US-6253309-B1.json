{"patent_number": "US-6253309-B1", "publication_id": 72696162, "family_id": 22564980, "publication_date": "2001-06-26", "titles": [{"lang": "EN", "text": "Forcing regularity into a CISC instruction set by padding instructions"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72575575\"><p>A microprocessor configured to rapidly decode variable-length instructions is disclosed. The microprocessor is configured with a predecoder and an instruction cache. The predecoder is configured to expand variable-length instructions to create fixed-length instructions by padding instruction fields within each variable-length instruction with constants until each field reaches a predetermined maximum width. The fixed-width instructions are then stored within the instruction cache and output for execution when a corresponding requested address is received. The instruction cache may store both variable- and fixed-width instructions, or just fixed-width instructions. An array of pointers may be used to access particular fixed-length instructions. The fixed-length instructions may be configured to all have the same fields and the same lengths, or they may be divided into groups, wherein instructions within each group have the same fields and the same lengths. A software program configured to generate fixed-length instructions from variable-length instructions is also disclosed. A method for predecoding variable-length instructions is also disclosed.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00001\" num=\"1\"><claim-text>1. A microprocessor comprising:</claim-text><claim-text>a predecode unit configured to read variable-length instructions from an external memory, wherein the predecode unit is configured to expand each of the variable-length instructions to a predetermined constant length by inserting instruction fields filled with one or more padding constants; and </claim-text><claim-text>an instruction cache coupled to receive the expanded instructions from the predecode unit, wherein the instruction cache includes a lookup table storing pointers, wherein the lookup table translates fetch addresses to identify where corresponding expanded constant-length instructions are stored in the instruction cache. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00002\" num=\"2\"><claim-text>2. The microprocessor of claim <b>1</b>, wherein the variable-length instructions are x86 instructions.</claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00003\" num=\"3\"><claim-text>3. The microprocessor of claim <b>1</b>, wherein the predetermined constant length equals a maximum length of the variable-length instructions.</claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00004\" num=\"4\"><claim-text>4. The microprocessor of claim <b>1</b>, wherein the expanded constant-length instructions include a field of five prefix bytes, wherein one of the five prefix bytes is devoted to each of the following: segment override information, repeat information, hardware lock information, operand size information, and address size information.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00005\" num=\"5\"><claim-text>5. The microprocessor of claim <b>1</b>, wherein the expanded constant-length instructions include one byte for each possible prefix byte in the variable-length instructions.</claim-text></claim>"}, {"num": 6, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00006\" num=\"6\"><claim-text>6. A microprocessor comprising:</claim-text><claim-text>a predecode unit configured to receive variable-length instructions from an external memory or external cache, wherein the predecode unit is configured to expand each of the variable-length instructions to one of a predetermined set of lengths by inserting instruction fields filled with one or more padding constants; and </claim-text><claim-text>an instruction cache coupled to receive the expanded instructions from the predecode unit, wherein the instruction cache includes: </claim-text><claim-text>a storage array for expanded instructions of the predetermined set of lengths, and </claim-text><claim-text>a pointer array configured to store pointers, wherein the pointers translate fetch addresses corresponding to variable-length instructions to identify storage locations within the storage arrays that store the corresponding expanded instructions. </claim-text></claim>"}, {"num": 7, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00007\" num=\"7\"><claim-text>7. The microprocessor of claim <b>6</b>, wherein the variable-length instructions are x86 instructions.</claim-text></claim>"}, {"num": 8, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00008\" num=\"8\"><claim-text>8. The microprocessor of claim <b>6</b>, wherein the predetermined constant length equals a maximum length of the variable-length instructions.</claim-text></claim>"}, {"num": 9, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00009\" num=\"9\"><claim-text>9. The microprocessor of claim <b>6</b>, wherein the expanded constant-length instructions include a field of five prefix bytes, wherein one of the five prefix bytes is devoted to each of the following: segment override information, repeat information, hardware lock information, operand size information, and address size information.</claim-text></claim>"}, {"num": 10, "parent": 6, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00010\" num=\"10\"><claim-text>10. The microprocessor of claim <b>6</b>, wherein the expanded constant-length instructions include one byte for each possible prefix byte in the variable-length instructions.</claim-text></claim>"}, {"num": 11, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00011\" num=\"11\"><claim-text>11. A microprocessor comprising:</claim-text><claim-text>a predecode unit configured to read variable-length instructions from an external memory, wherein said predecode unit is configured to expand each of said variable-length instructions to a predetermined constant length by inserting instruction fields filled with one or more padding constants; and </claim-text><claim-text>an instruction cache coupled to receive the expanded constant length instructions from the predecode unit, wherein the instruction cache includes: </claim-text><claim-text>a first storage array for the variable-length instructions, </claim-text><claim-text>a second storage array for the expanded constant length instructions, and </claim-text><claim-text>a pointer array configured to store pointers, wherein the pointers translate fetch addresses to identify where corresponding expanded instructions are stored. </claim-text></claim>"}, {"num": 12, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00012\" num=\"12\"><claim-text>12. The microprocessor of claim <b>11</b>, wherein the variable-length instructions are x86 instructions.</claim-text></claim>"}, {"num": 13, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00013\" num=\"13\"><claim-text>13. The microprocessor of claim <b>11</b>, wherein the predetermined constant length equals a maximum length of the variable-length instructions.</claim-text></claim>"}, {"num": 14, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00014\" num=\"14\"><claim-text>14. The microprocessor of claim <b>11</b>, wherein the expanded constant-length instructions include a field of five prefix bytes, wherein one of the five prefix bytes is devoted to each of the following: segment override information, repeat information, hardware lock information, operand size information, and address size information.</claim-text></claim>"}, {"num": 15, "parent": 11, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00015\" num=\"15\"><claim-text>15. The microprocessor of claim <b>11</b>, wherein the expanded constant-length instructions include one byte for each possible prefix byte in the variable-length instructions.</claim-text></claim>"}, {"num": 16, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00016\" num=\"16\"><claim-text>16. A method for predecoding variable-length instructions comprising:</claim-text><claim-text>receiving variable-length instructions; </claim-text><claim-text>predecoding the variable-length instruction by: </claim-text><claim-text>selecting a length for each variable-length instruction from a set of predetermined lengths, wherein one of said set of predetermined lengths equals a maximum length for the variable length instructions; </claim-text><claim-text>expanding the variable length instruction by inserting one or more instruction fields filled with one or more padding constants; </claim-text><claim-text>storing the expanded instructions in an instruction cache; </claim-text><claim-text>updating a translation table to reflect the location of the stored expanded instructions; </claim-text><claim-text>reading the stored expanded instructions; and </claim-text><claim-text>executing the expanded instructions in lieu of the variable length instructions. </claim-text></claim>"}, {"num": 17, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00017\" num=\"17\"><claim-text>17. The method of claim <b>16</b>, further comprising:</claim-text><claim-text>storing the variable-length instructions in the instruction cache; </claim-text><claim-text>accessing the stored variable-length instructions in response to a taken branch instruction; and </claim-text><claim-text>accessing the stored expanded instructions in response to a not-taken branch instruction. </claim-text></claim>"}, {"num": 18, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00018\" num=\"18\"><claim-text>18. The method of claim <b>16</b>, wherein the variable-length instructions are x86 instructions.</claim-text></claim>"}, {"num": 19, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00019\" num=\"19\"><claim-text>19. The method of claim <b>16</b>, wherein the variable length instructions are expanded to a predetermined constant length that equals a maximum length of the variable-length instructions.</claim-text></claim>"}, {"num": 20, "parent": 16, "type": "dependent", "paragraph_markup": "<claim id=\"US-6253309-B1-CLM-00020\" num=\"20\"><claim-text>20. The method of claim <b>16</b>, wherein the expanded instructions each include a field of five prefix bytes, wherein one of the five prefix bytes is devoted to each of the following: segment override information, repeat information, hardware lock information, operand size information, and address size information.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54566456\"><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>This invention relates to microprocessors and, more particularly, to decoding variable length instructions within a microprocessor.</p><p>2. Description of the Relevant Art</p><p>The number of software applications written for the x86 instruction set is quite large. As a result, despite the introduction of newer and more advanced instruction sets, microprocessor designers have continued to design microprocessors capable of executing the x86 instruction set.</p><p>The x86 instruction set is relatively complex and is characterized by a plurality of variable-length instructions. A generic format illustrative of the x86 instruction set is shown in FIG. <b>1</b>. As illustrated in the figure, an x86 instruction consists of from one to five optional prefix bytes <b>102</b>, followed by an operation code (opcode) field <b>104</b>, an optional addressing mode (Mod R/M) byte <b>106</b>, an optional scale-index-base (SIB) byte <b>108</b>, an optional displacement field <b>110</b>, and an optional immediate data field <b>112</b>.</p><p>The opcode field <b>104</b> defines the basic operation for a particular instruction. The default operation of a particular opcode may be modified by one or more prefix bytes <b>102</b>. For example, one of prefix bytes <b>102</b> may be used to change the address or operand size for an instruction, to override the default segment used in memory addressing, or to instruct the processor to repeat a string operation a number of times. The opcode field <b>104</b> follows prefix bytes <b>102</b>, if present, and may be one or two bytes in length. The addressing mode (Mod R/M) byte <b>106</b> specifies the registers used as well as memory addressing modes. The scale-index-base (SIB) byte <b>108</b> is used only in 32-bit base-relative addressing using scale and index factors. A base field within SIB byte <b>108</b> specifies which register contains the base value for the address calculation, and an index field within SIB byte <b>108</b> specifies which register contains the index value. A scale field within SIB byte <b>108</b> specifies the power of two by which the index value will be multiplied before being added, along with any displacement, to the base value. The next instruction field is a displacement field <b>110</b>, which is optional and may be from one to four bytes in length. Displacement field <b>110</b> contains a constant used in address calculations. The optional immediate field <b>112</b>, which may also be from one to four bytes in length, contains a constant used as an instruction operand. The shortest x86 instructions are only one byte long, and comprise a single opcode byte. The 80286 sets a maximum length for an instruction at 10 bytes, while the 80386 and 80486 both allow instruction lengths of up to 15 bytes.</p><p>The complexity of the x86 instruction set poses many difficulties in implementing high performance x86-compatible microprocessors. In particular, the variable length of x86 instructions makes decoding instructions difficult. Decoding instructions typically involves determining the boundaries of an instruction and then identifying each field within the instruction, e.g., the opcode and operand fields. Decoding typically takes place once the instruction is fetched from the instruction cache before execution.</p><p>One method for determining the boundaries of instructions involves generating a number of predecode bits for each instruction byte read from main memory. The predecode bits provide information about the instruction byte they are associated with. For example, an asserted predecode start bit indicates that the associated instruction byte is the first byte of an instruction. Similarly, an asserted predecode end bit indicates that the associated instruction byte is the last byte of an instruction. Once the predecode bits for a particular instruction byte are calculated, they are stored together with the instruction byte in an instruction cache. When a \u201cfetch\u201d is performed, i.e., a number of instruction bytes are read from the instruction cache, the associated start and end bits are also read. The start and end bits may then be used to generate valid masks for the individual instructions with the fetch. A valid mask is a series of bits in which each bit corresponds to a particular instruction byte. Valid mask bits associated with the first byte of an instruction, the last byte of the instruction, and all bytes in between the first and last bytes of the instruction are asserted. All other valid mask bits are not asserted. Turning now to FIG. 2, an exemplary valid mask is shown. The figure illustrates a portion of a fetch <b>120</b> and its associated start and end bits <b>122</b> and <b>124</b>. Assuming a valid mask <b>126</b> for instruction B <b>128</b> is to be generated, start and end bits <b>122</b> and <b>124</b> would be used to generate the mask. Valid mask <b>126</b> could then be used to mask off all bytes within fetch <b>120</b> that are not part of instruction B <b>128</b>.</p><p>Once the boundaries of an instruction have been determined, the fields within the instruction, e.g., the opcode and operand fields, may be identified. Once again, the variable length of x86 instructions complicates the identification process. In addition, the optional prefix bytes within an x86 instruction create further complications. For example, in some instructions the opcode will begin with the first byte of the instruction, while others may begin with the second, third, or fourth byte.</p><p>To perform the difficult task of decoding x86 instructions, a number of cascaded levels of logic are typically used. Thus, decoding may require a number of clock cycles and may create a significant delay before any instructions are available to the functional stages of the microprocessor's pipeline. As microprocessors increase the number of instructions they are able to execute per clock cycle, instruction decoding may become a performance limiting factor. Therefore, a mechanism for simplifying the complexity and time required for instruction decoding is needed.</p><h4>SUMMARY</h4><p>The problems outlined above are in large part solved by a microprocessor capable of predecoding variable-length instructions into fixed-length instructions. In one embodiment, the microprocessor comprises a predecoder and an instruction cache. The predecoder is configured to receive variable-length instructions and predecode them into fixed-length instructions. The variable-length instructions are predecoded by padding constants into different instruction fields within the variable-length instruction. Constants may be inserted in each instruction field that does not have a predetermined maximum number of bytes. The instruction cache is coupled to receive the fixed-length instructions from the predecoder and store them. When the instruction cache receives a requested address the cache is configured to output a corresponding fixed-length instruction. By predecoding variable-length instructions to fixed lengths, decode time may advantageously be reduced.</p><p>In another embodiment, the instruction cache may further comprise a pointer array configured to store a plurality of pointers. Each stored pointer may be configured to point to one particular fixed-length instruction stored within the instruction cache. These pointer may advantageously allow particular fixed-length instructions to be accessed even though the instructions' location within the instruction cache may not correspond to particular requested addresses (i.e., because of the offset created by padding).</p><p>A software program embodied on computer-readable media is also contemplated. In one embodiment the program comprises a first section of code configured to decode variable-length instructions into a plurality of fields. A second section of code may be configured to generate fixed-length instructions from the variable length instructions by expanding the fields to a predetermined maximum length. The fields may be expanded by inserting constants that act as place holders into the fields. The software program may be part of a high-level language compiler or the program may be a separate routine for optimizing existing object code.</p><p>In another embodiment the software program may comprise pluralities of instructions. The first plurality may be configured to determine the length of variable-length instructions, and the second plurality may be configured to append constants to the end of the variable length instruction until the variable-length instruction has reached a predetermined length. The constant may be added to any variable-length instruction that does not have a length that is evenly divisible by a second constant.</p><p>A method for predecoding variable-length instructions is also contemplated. In one embodiment, the method comprises receiving a variable-length instruction and determining which fields are present within the instruction. Of the fields that are present, each is examined to determine which have space to store additional bytes. Next fixed-length instructions are formed by filling each field with constants until all fields are full. Finally, the resulting fixed-length instruction is output.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of a generic x86 instruction format.</p><p>FIG. 2 is a block diagram illustrating one embodiment of a valid mask.</p><p>FIG. 3 is a block diagram of one embodiment of a microprocessor.</p><p>FIG. 4 is table illustrating one embodiment of a method for decoding variable-length instructions into fixed-length instructions.</p><p>FIG. 5 is a table illustrating another embodiment of a method for decoding variable-length instructions into fixed-length instructions.</p><p>FIG. 6 is a diagram illustrating details of the method illustrated in FIG. <b>5</b>.</p><p>FIG. 7 is a diagram illustrating one possible embodiment of the instruction cache from FIG. <b>3</b>.</p><p>FIG. 8 is a diagram illustrating another embodiment of the instruction cache from the microprocessor depicted in FIG. <b>3</b>.</p><p>FIG. 9 is a diagram illustrating another method for decoding variable-length instructions into fixed-length instructions.</p><p>FIG. 10 is a diagram illustrating another embodiment of the instruction cache from the microprocessor depicted in FIG. <b>3</b>.</p><p>FIG. 11 is a diagram showing one embodiment of a computer system utilizing the microprocessor of FIG. <b>3</b>.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will be described in detail herein. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF AN EMBODIMENT</h4><p>Turning now to FIG. 3, a block diagram of one embodiment of a microprocessor <b>10</b> is shown. Microprocessor <b>10</b> includes a prefetch/predecode unit <b>12</b>, a branch prediction unit <b>14</b>, an instruction cache <b>16</b>, an instruction alignment unit <b>18</b>, a plurality of decode units <b>20</b>A-<b>20</b>C, a plurality of reservation stations <b>22</b>A-<b>22</b>C, a plurality of functional units <b>24</b>A-<b>24</b>C, a load/store unit <b>26</b>, a data cache <b>28</b>, a register file <b>30</b>, a reorder buffer <b>32</b>, and MROM unit <b>34</b>. Elements referred to herein with a particular reference number followed by a letter may be collectively referred to by the reference number alone. For example, reservation stations <b>22</b>A-<b>22</b>C may be collectively referred to as reservation stations <b>22</b>.</p><p>Prefetch/predecode unit <b>12</b> is coupled to receive instructions from a main memory subsystem (not shown), and is further coupled to instruction cache <b>16</b> and branch prediction unit <b>14</b>. Similarly, branch prediction unit <b>14</b> is coupled to instruction cache <b>16</b>. Still further, branch prediction unit <b>14</b> is coupled to instruction alignment unit <b>18</b> and functional units <b>24</b>. Instruction cache <b>16</b> is further coupled to MROM unit <b>34</b> and instruction alignment unit <b>18</b>. Instruction alignment unit <b>18</b> is in turn coupled to load/store unit <b>26</b> and to respective decode units <b>20</b>A-<b>20</b>C. Respective decode units <b>20</b>A-<b>20</b>C are coupled to reservation stations <b>22</b>A-<b>22</b>C, which are further coupled to respective functional units <b>24</b>A-<b>24</b>C. Additionally, instruction alignment unit <b>18</b> and reservation stations <b>22</b> are coupled to register file <b>30</b> and reorder buffer <b>32</b>. Functional units <b>24</b> are coupled to load/store unit <b>26</b>, register file <b>30</b>, and reorder buffer <b>32</b> as well. Data cache <b>28</b> is coupled to load/store unit <b>26</b> and to the main memory subsystem. Finally, MROM unit <b>34</b> is coupled to instruction alignment unit <b>18</b>.</p><p>Instructions are prefetched from main memory by prefetch/predecode unit <b>12</b>. Prefetch/predecode unit <b>12</b> predecodes the variable-length instructions to fixed length instructions which are then stored in instruction cache <b>16</b>. Instructions may be prefetched and predecoded before they are actually requested by using a prefetch scheme. A variety of prefetch schemes may be employed by prefetch/predecode unit <b>12</b>. Before proceeding with a more detailed description of predecode unit <b>12</b>, general aspects regarding the embodiment of exemplary microprocessor <b>10</b> shown in the figure will be described.</p><p>Microprocessor <b>10</b> may employ branch prediction in order to speculatively fetch instructions subsequent to conditional branch instructions. Branch prediction unit <b>14</b> is included to perform branch prediction operations. In one embodiment, up to two branch target addresses are stored for each 16-byte portion of each cache line in instruction cache <b>16</b>. Prefetch/predecode unit <b>12</b> determines initial branch targets when a particular line is predecoded. Subsequent updates to the branch targets corresponding to a cache line may occur due to the execution of instructions within the cache line. Instruction cache <b>16</b> provides an indication of the instruction address being fetched to branch prediction unit <b>14</b>. This allows branch prediction unit <b>14</b> to determine which branch target addresses to select when forming a branch prediction. Instruction alignment unit <b>18</b> and functional units <b>24</b> provide update information to branch prediction unit <b>14</b>. Because branch prediction unit <b>14</b> stores two targets per 16-byte portion of the cache line, predictions for some branch instructions within the line may not be stored in branch prediction unit <b>14</b>. Instruction alignment unit <b>18</b> may be configured to detect branch instructions which were not predicted by branch prediction unit <b>14</b>. Functional units <b>24</b> execute the branch instructions and determine if the predicted branch direction was mispredicted. The branch direction may be \u201ctaken\u201d, in which subsequent instructions are fetched from the target address of the branch instruction. Conversely, the branch direction may be \u201cnot taken\u201d, in which subsequent instructions are fetched from memory locations consecutive to the branch instruction. When a mispredicted branch instruction is detected, instructions subsequent to the mispredicted branch are discarded from the various units of microprocessor <b>10</b>. A variety of suitable branch prediction algorithms may be employed by branch prediction unit <b>14</b>.</p><p>Instruction cache <b>16</b> is a high speed cache memory provided to store instructions received from prefetch/predecode unit <b>12</b>. Stored instructions are then fetched from instruction cache <b>16</b> and forwarded to instruction alignment unit <b>18</b>. In one embodiment, instruction cache <b>16</b> may be configured as a set-associative structure. Instruction cache <b>16</b> may additionally employ a way prediction scheme in order to speed access times. For example, instead of accessing tags identifying each line of instructions and comparing the tags to the fetch address to select a way, instruction cache <b>16</b> may predict the way that is accessed. In this manner, the way is speculatively selected prior to accessing the array. Using way prediction, the access time of instruction cache <b>16</b> may be similar to a direct-mapped cache. After the instruction bytes have been read, a tag comparison is performed for verification. If the way prediction is incorrect, the correct instruction bytes are fetched and the incorrect instruction bytes (which are further down the processing pipeline) are discarded. It is noted that instruction cache <b>16</b> may be implemented in fully associative, set associative, or direct mapped configurations.</p><p>MROM unit <b>34</b> is a read-only memory that is configured to store sequences of \u201cfast-path instructions.\u201d Fast path instructions are instructions that may be decoded and executed by decoders <b>20</b>A-C and functional units <b>24</b>A-C. In contrast, \u201cMROM instructions\u201d are instructions which are too complex for direct decoding or execution by decoders <b>20</b>A-C and functional units <b>24</b>A-C. When instruction cache <b>16</b> outputs an MROM instruction, MROM unit <b>34</b> responds by outputting a sequence of fast path instructions. More specifically, MROM unit <b>34</b> parses and translates the MROM instruction into a subset of defined fast path instructions to effectuate the desired operation. MROM unit <b>34</b> dispatches the subset of fast path instructions to decode units <b>20</b>A-C.</p><p>Once instruction bytes are fetched from instruction cache <b>16</b>, they are conveyed to instruction alignment unit <b>18</b>. Instruction alignment unit <b>18</b> routes the instructions to one of decode unit <b>20</b>A-C. Register operand information is also detected and routed to register file <b>30</b> and reorder buffer <b>32</b>. Additionally, if the instructions require one or more memory operations to be performed, instruction alignment unit <b>18</b> dispatches the memory operations to load/store unit <b>26</b>. Each decoded instruction is dispatched to reservation stations <b>22</b> along with operand address information and displacement or immediate data which may be included with the instruction.</p><p>Microprocessor <b>10</b> supports out-of-order execution, and thus employs reorder buffer <b>32</b> to keep track of the original program sequence for register read and write operations, to implement register renaming, to allow for speculative instruction execution and branch misprediction recovery, and to facilitate precise exceptions. A temporary storage location within reorder buffer <b>32</b> is reserved upon decode of an instruction that involves the update of a register. The temporary storage location stores the speculative register state that results from the speculative execution of an instruction. If a branch prediction is incorrect, the results from the speculatively-executed instructions along the mispredicted path can be invalidated in the reorder buffer <b>32</b> before they are written to register file <b>30</b>. Similarly, if a particular instruction causes an exception, instructions subsequent to the exception-causing instruction may be discarded. In this manner, exceptions are \u201cprecise\u201d (i.e., instructions subsequent to the exception-causing instruction are not completed prior to the exception). It is noted that a particular instruction is speculatively executed if it is executed prior to instructions which precede the particular instruction in program order. Preceding instructions may be a branch instruction or an exception-causing instruction, in which case the speculative results may be discarded by reorder buffer <b>32</b>.</p><p>The decoded instructions and immediate or displacement data provided at the outputs of instruction alignment unit <b>18</b> are routed directly to respective reservation stations <b>22</b>. In one embodiment, each reservation station <b>22</b> is capable of holding instruction information (i.e., decoded instructions as well as operand values, operand tags and/or immediate data) for up to three pending instructions awaiting issue to the corresponding functional unit. It is noted that for the embodiment shown in the figure, each reservation station <b>22</b> is associated with a dedicated functional unit <b>24</b>. Accordingly, three dedicated \u201cissue positions\u201d are formed by reservation stations <b>22</b> and functional units <b>24</b>. In other words, issue position <b>0</b> is formed by reservation station <b>22</b>A and functional unit <b>24</b>A. Instructions aligned and dispatched to reservation station <b>22</b>A are executed by functional unit <b>24</b>A. Similarly, issue position <b>1</b> is formed by reservation station <b>22</b>B and functional unit <b>24</b>B; and issue position <b>2</b> is formed by reservation station <b>22</b>C and functional unit <b>24</b>C.</p><p>Upon decode of a particular instruction, if a required operand is a register location, register address information is routed to reorder buffer <b>32</b> and register file <b>30</b> simultaneously. Those of skill in the art will appreciate that the x86 register file includes eight 32-bit real registers (i.e., typically referred to as EAX, EBX, ECX EDX, EBP, ESI, EDI and ESP). In embodiments of microprocessor <b>10</b> which employ the x86 microprocessor architecture, register file <b>30</b> comprises storage locations for each of the 32-bit real registers. Additional storage locations may be included within register file <b>30</b> for use by MROM unit <b>34</b>. Reorder buffer <b>32</b> contains temporary storage locations for results which change the contents of these registers to thereby allow out of order execution. A temporary storage location of reorder buffer <b>32</b> is reserved for each instruction which, upon decode, is determined to modify the contents of one of the real registers. Therefore, at various points during execution of a particular program, reorder buffer <b>32</b> may have one or more locations which contain the speculatively executed contents of a given register.</p><p>If following decode of a given instruction it is determined that reorder buffer <b>32</b> has a previous location or locations assigned to a register used as an operand in the given instruction, reorder buffer <b>32</b> forwards to the corresponding reservation station either: 1) the value in the most recently assigned location, or 2) a tag for the most recently assigned location if the value has not yet been produced by the functional unit that will eventually execute the previous instruction. If reorder buffer <b>32</b> has a location reserved for a given register, the operand value (or reorder buffer tag) is provided from reorder buffer <b>32</b> rather than from register file <b>30</b>. If there is no location reserved for a required register in reorder buffer <b>32</b>, the value is taken directly from register file <b>30</b>. If the operand corresponds to a memory location, the operand value is provided to the reservation station through load/store unit <b>26</b>.</p><p>In one particular embodiment, reorder buffer <b>32</b> is configured to store and manipulate concurrently decoded instructions as a unit. This configuration will be referred to herein as \u201cline-oriented\u201d. By manipulating several instructions together, the hardware employed within reorder buffer <b>32</b> may be simplified. For example, a line-oriented reorder buffer included in the present embodiment allocates storage sufficient for instruction information pertaining to three instructions whenever one or more instructions are dispatched by instruction alignment unit <b>18</b>. By contrast, a variable amount of storage is allocated in conventional reorder buffers, dependent upon the number of instructions actually dispatched. A comparatively larger number of logic gates may be required to allocate the variable amount of storage. When each of the concurrently decoded instructions has executed, the instruction results are stored into register file <b>30</b> simultaneously. The storage is then free for allocation to another set of concurrently decoded instructions. Additionally, the amount of control logic circuitry employed per instruction is reduced because the control logic is amortized over several concurrently decoded instructions. A reorder buffer tag identifying a particular instruction may be divided into two fields: a line tag and an offset tag. The line tag identifies the set of concurrently decoded instructions including the particular instruction, and the offset tag identifies which instruction within the set corresponds to the particular instruction. It is noted that storing instruction results into register file <b>30</b> and freeing the corresponding storage is referred to as \u201cretiring\u201d the instructions. It is further noted that any reorder buffer configuration may be employed in various embodiments of microprocessor <b>10</b>.</p><p>As noted earlier, reservation stations <b>22</b> store instructions until the instructions are executed by the corresponding functional unit <b>24</b>. An instruction is selected for execution if: (i) the operands of the instruction have been provided; and (ii) the operands have not yet been provided for instructions which are within the same reservation station <b>22</b>A-<b>22</b>C and which are prior to the instruction in program order. It is noted that when an instruction is executed by one of the functional units <b>24</b>, the result of that instruction is passed directly to any reservation stations <b>22</b> that are waiting for that result at the same time the result is passed to update reorder buffer <b>32</b> (this technique is commonly referred to as \u201cresult forwarding\u201d). An instruction may be selected for execution and passed to a functional unit <b>24</b>A-<b>24</b>C during the clock cycle that the associated result is forwarded. Reservation stations <b>22</b> route the forwarded result to the functional unit <b>24</b> in this case.</p><p>In one embodiment, each functional units <b>24</b>A-C is configured to perform integer arithmetic operations of addition and subtraction, as well as shifts, rotates, logical operations, and branch operations. It is noted that a floating point unit (not shown) may also be employed to accommodate floating point operations. The floating point unit may be operated as a coprocessor, receiving instructions from MROM unit <b>34</b> and subsequently communicating with reorder buffer <b>32</b> to complete the instructions. Additionally, functional units <b>24</b> may be configured to perform address generation for load and store memory operations performed by load/store unit <b>26</b>.</p><p>Each of the functional units <b>24</b> also provides information regarding the execution of conditional branch instructions to the branch prediction unit <b>14</b>. If a branch prediction was incorrect, branch prediction unit <b>14</b> flushes instructions subsequent to the mispredicted branch that have entered the instruction processing pipeline, and causes a fetch of the required instructions from instruction cache <b>16</b> or main memory. It is noted that in such situations, results of instructions in the original program sequence which occur after the mispredicted branch instruction are discarded, including those which were speculatively executed and temporarily stored in load/store unit <b>26</b> and reorder buffer <b>32</b>.</p><p>Results produced by functional units <b>24</b> are sent to reorder buffer <b>32</b> if a register value is being updated, and to load/store unit <b>26</b> if the contents of a memory location are changed. If the result is to be stored in a register, reorder buffer <b>32</b> stores the result in the location reserved for the value of the register when the instruction was decoded. A plurality of result buses <b>38</b> are included for forwarding of results from functional units <b>24</b> and load/store unit <b>26</b>. Result buses <b>38</b> convey the result generated, as well as the reorder buffer tag identifying the instruction being executed.</p><p>Load/store unit <b>26</b> provides an interface between functional units <b>24</b> and data cache <b>28</b>. In one embodiment, load/store unit <b>26</b> is configured with a load/store buffer having eight storage locations for data and address information for pending loads or stores. When the buffer is full, instruction alignment unit <b>18</b> waits until load/store unit <b>26</b> has room for the pending load or store request information. Load/store unit <b>26</b> also performs dependency checking for load memory operations against pending store memory operations to ensure that data coherency is maintained. A memory operation is a transfer of data between microprocessor <b>10</b> and the main memory subsystem. Memory operations may be the result of an instruction which utilizes an operand stored in memory, or may be the result of a load/store instruction which causes the data transfer but no other operation. Additionally, load/store unit <b>26</b> may include a special register storage for special registers such as the segment registers and other registers related to the address translation mechanism defined by the x86 microprocessor architecture.</p><p>In one embodiment, load/store unit <b>26</b> is configured to perform load memory operations speculatively. Store memory operations may be performed in program order, but may be speculatively stored into the predicted way. If the predicted way is incorrect, the data prior to the store memory operation is subsequently restored to the predicted way and the store memory operation is performed to the correct way. In another embodiment, stores may be executed speculatively as well. Speculatively executed stores are placed into a store buffer, along with a copy of the cache line prior to the update. If the speculatively executed store is later discarded due to branch misprediction or exception, the cache line may be restored to the value stored in the buffer. It is noted that load/store unit <b>26</b> may be configured to perform any amount of speculative execution, including no speculative execution.</p><p>Data cache <b>28</b> is a high speed cache memory provided to temporarily store data being transferred between load/store unit <b>26</b> and the main memory subsystem. In one embodiment, data cache <b>28</b> has a capacity of storing up to sixteen kilobytes of data in an eight-way set-associative structure. Similar to instruction cache <b>16</b>, data cache <b>28</b> may employ a way prediction mechanism. It is understood that data cache <b>28</b> may be implemented in a variety of specific memory configurations, including set-associative and direct-mapped configurations.</p><p>In one particular embodiment of microprocessor <b>10</b> employing the x86 microprocessor architecture, instruction cache <b>16</b> and data cache <b>28</b> are linearly addressed. The linear address is formed from the offset specified by the instruction and the base address specified by the segment portion of the x86 address translation mechanism. Linear addresses may optionally be translated to physical addresses for accessing a main memory. The linear to physical translation is specified by the paging portion of the x86 address translation mechanism. It is noted that a linear addressed cache stores linear address tags. A set of physical tags (not shown) may be employed for mapping the linear addresses to physical addresses and for detecting translation aliases. Additionally, the physical tag block may perform linear to physical address translation.</p><p>Prefetch/Predecode Unit and Instruction Cache Configuration</p><p>Turning now to FIG. 4, one method for predecoding variable-length instructions into fixed length instructions is shown. Sample code <b>60</b> represents a plurality of variable-length instructions, in this case x86 instructions. While this method may be used with a number of different types of variable-length instructions (e.g., 68000 instructions), x86 instructions are chosen for illustration purposes. In this embodiment, predecode unit <b>12</b> is configured to receive each variable-length instruction and then pad each field within the variable-length instruction to a predetermined maximum field width. While any predetermined constant may be used, e.g., 90<sub>16</sub>, the examples herein use 00<sub>16 </sub>as the padding constant.</p><p>The prefix bytes are expanded to five bytes. The first byte may be reserved for segment override information and may comprise one of the following: 00<sub>16 </sub>representing no segment override, 26<sub>16 </sub>representing the ES segment, 2E<sub>16 </sub>representing the CS segment, 36<sub>16 </sub>representing the SS segment, 3E<sub>16 </sub>representing the DS segment, 64<sub>16 </sub>representing the FS segment, or 65<sub>16 </sub>representing the GS segment. The second byte may be reserved for repeat information and may comprise one of the following: 00<sub>16 </sub>representing no repeat information, F2<sub>16 </sub>representing the REPNE/REPNZ operation, or F3 <sub>6 </sub>representing the REP/REPE/REPZ operation. The third byte may be reserved for hardware lock information for memory operations in multiprocessor environments and may comprise one of the following: 00<sub>16 </sub>representing no lock information, or F0<sub>16 </sub>representing an asserted hardware lock. The fourth byte may be reserved for operand size information and may comprise one of the following: 00<sub>16 </sub>representing no change in operand size, or 66<sub>16 </sub>for toggling the word size. Similarly, the fifth byte may be reserved for address size information and may comprise one of the following: 00<sub>16 </sub>representing no change in address size, or 67<sub>16 </sub>for toggling between 16 and 32-bit addressing. Note the above nomenclature matches the existing x86 nomenclature, but other constants for each function may be selected in other embodiments.</p><p>As previously noted, one major difficulty in decoding variable-length instructions is determining where each instruction begins and ends. By predecoding instructions to a fixed-length, each instruction is automatically aligned when it is read from instruction cache <b>16</b>. Advantageously, instruction alignment unit <b>18</b> and decoders <b>20</b>A-C may be simplified. In some embodiments, one or more decode units <b>20</b>A-<b>20</b>C may be optimized to receive fixed-length instructions, thereby further improving decode speed. In other embodiments, one or more decoder units <b>20</b>A-<b>20</b>C may be bypassed completely for fixed-length instructions.</p><p>A second difficulty in decoding variable-length instructions is determining which instruction and operand fields are present and where those instruction fields begin and end. By predecoding instructions to the format illustrated, determining which fields are present in each instruction and which, if any, operands are required, may be simplified.</p><p>Turning now to FIG. 5, another embodiment of this method is illustrated. In this embodiment, the five prefix bytes <b>102</b> from the previous embodiment's fixed-length instruction format <b>60</b> are compressed into a single prefix byte <b>130</b>. This results in a fixed length of thirteen bytes for each fixed-length instruction. Advantageously, using this format the benefits of a fixed-length format may be preserved while reducing the amount of storage required for each fixed-length instruction.</p><p>Turning now to FIG. 6, details of one embodiment of prefix compression are shown. In this embodiment, prefix byte <b>122</b> comprises a 3-bit segment override field <b>140</b>, a 2-bit repeat field <b>142</b>, a single lock bit <b>144</b>, a single operand size bit <b>146</b>, and a single address size bit <b>148</b>. Segment override information may be encoded into three bits of prefix byte <b>122</b> as follows. A prefix byte of 26<sub>16</sub>, which indicates that the contents of the ES register are to be used to define the segment, may be replaced by the bit sequence 001<sub>2</sub>. Similarly, a prefix byte of 2E<sub>16 </sub>(ES register) may be replaced by the bit sequence 010<sub>2</sub>. A prefix byte of 36<sub>16 </sub>(ES register) may be replaced by 011<sub>2</sub>. A prefix byte of 3E<sub>16 </sub>(DS register) may be replaced by 100<sub>2</sub>. A prefix byte of 64<sub>16 </sub>(FS register) may be replaced by 101<sub>2</sub>. A prefix byte of 65<sub>16 </sub>(GS register) may be replaced by 110<sub>2</sub>. If there is no segment override, 000<sub>2 </sub>may be used in segment override field <b>140</b>.</p><p>The prefix repeat information may be encoded into a 2-bit repeat field <b>142</b> of prefix byte <b>122</b> as follows. A prefix byte of F2 (REPNE/REPNZ) may be replaced with the bit sequence 01<sub>2</sub>. Similarly, a prefix byte of F3 (REP/REPE/REPZ) may be replaced by the bit sequence 10<sub>2</sub>. If there is no repeat information, 00<sub>2 </sub>may be used in repeat field <b>142</b>. If a lock instruction F0<sub>16 </sub>is present, this information may be encoded into a single lock bit <b>144</b>. Similarly, if a toggle operand size byte 66<sub>16 </sub>is present, this information may be encoded into a single bit <b>146</b>. The presence of a toggle address size byte 67<sub>16 </sub>may be encoded into bit <b>148</b>. Thus, all five bytes of prefix information may be compressed into a single prefix byte <b>122</b>. Advantageously, using this method saves space within instruction cache <b>16</b> while still providing clearly defined fields that do not vary from one instruction to the next.</p><p>Turning now to FIG. 7, details of one embodiment of instruction cache <b>16</b> are shown. In this embodiment, instruction cache <b>16</b> comprises a lookup table <b>90</b> and an instruction storage array <b>92</b>. Lookup table <b>90</b> comprises a plurality of storage locations configured to store pointers to storage locations within instruction storage array <b>92</b>. Instruction storage array <b>92</b> comprises a plurality of instruction storage locations each configured to store a fixed-length instruction received from prefetch/predecode unit <b>12</b>.</p><p>Upon receiving a predecoded fixed-length instruction for predecode unit <b>12</b>, instruction cache <b>16</b> stores the instruction in a particular storage location within instruction storage array <b>92</b>. Instruction cache <b>16</b> stores a pointer to that particular storage location in pointer array <b>90</b>. Pointer array <b>90</b> may be configured similarly to standard instruction caches, except smaller. For example, pointer array <b>90</b> may be configured as a set-associative cache with way prediction as previously disclosed. Instruction storage array <b>92</b> may be configured as direct mapped, or may also be configured in a set-associative structure.</p><p>An example of the operation of this embodiment of instruction cache <b>16</b> is now illustrated. When an instruction is received from predecode unit <b>12</b> (e.g., 00 8B 00 D8 00 00 00 00 00 00 00 00 00), instruction cache <b>16</b> is configured to store this instruction into the next available storage location within instruction storage array <b>92</b>. Using the example configured from the figure, the instruction is stored into an instruction storage location having an index 07<sub>16</sub>. Thus, instruction cache <b>16</b> stores the index value 07<sub>16 </sub>into pointer array <b>90</b>. The particular storage location within pointer array <b>90</b> is selected just as a cache line storage location would be selected in a standard instruction cache. For example, assuming the first byte of instruction 8BD8 was located at logical address 0A8D:0100, the pointer 07<sub>16 </sub>may be stored in the location within pointer array <b>90</b> that corresponds to logical address 0A8D:0100. As previously noted, in other embodiments pointer array <b>90</b> may be linearly addressed.</p><p>Upon receiving a request for the instruction residing as logical address 0A8D:0100, instruction cache <b>16</b> may access pointer array <b>90</b> and read the pointer that corresponds to the requested address, i.e., 07<sub>16</sub>. This pointer is then used access a storage location within instruction storage array <b>92</b>. The instruction stored therein (i.e., 00 8B 00 D8 00 00 00 00 00 00 00 00) is then read and output to instruction alignment unit <b>18</b>.</p><p>Turning now to FIG. 8, another embodiment of instruction cache <b>16</b> is shown. In this embodiment, instruction cache <b>16</b> is configured to store both variable and fixed-length versions of instructions. Instruction cache <b>16</b> comprises pointer array <b>90</b>, fixed-length instruction storage array <b>92</b>, and a variable-length instruction storage array <b>150</b>. Storage array <b>150</b> is configured to store variable-length instructions for use when receiving a requested address generated by a branch instruction that is taken. In contrast, fixed-length instruction storage array <b>92</b> stores fixed-length instructions which are accessed by requested addresses from non-branch instructions and branch instructions that are not taken. Because predecoding involves padding fields within each variable length instruction, branch targets may become skewed as a result of the padding. By storing both variable and fixed-length formats, this configuration may advantageously allow fast decoding of fixed-length instruction, while effectively compensating for the expansion of and shifting of instructions due to padding. This configuration may be particularly useful if the program contains branch or jump instructions that have a destination in the middle of an instruction. This is because such instructions may be detected and properly executed from variable-length instruction storage array <b>90</b>. Instruction cache may further comprise a multiplexer (not shown) to select between the output from fixed-length instruction storage array <b>92</b> and variable-length instruction storage array <b>150</b>.</p><p>In this embodiment, microprocessor <b>10</b> may be configured with two sets of decoders <b>20</b>A-C, one set for decoding variable-length instructions and one set for decoding fixed-length instructions. Alternatively, a single set of decoders <b>20</b>A-C may be used, wherein the decoders are allowed more clock cycles to perform variable-length decoding. In another embodiment, one or more decoders may be optimized to handle fixed-length instructions, while the remaining decoders may be optimized to handle variable-length instructions.</p><p>As the figure illustrates, each instruction may be stored in two different forms. Non-branch instructions are requested serially and therefore the shifting caused by predecoding and padding the instructions is not a problem. However, after a branch instruction, instruction cache <b>16</b> will receive a requested address that may have no correlation to the address at which the branch instruction was stored. Thus, variable-length instruction storage array <b>150</b> provides a mechanism for fetching the proper instruction after such instructions.</p><p>Turning now to FIG. 9, another method for predecoding variable length instructions into fixed-length instruction is shown. In this embodiment, predecode unit <b>12</b> expands variable length instructions to one of three lengths: 5 bytes, 6 bytes, or 13 bytes. Predecode unit <b>12</b> may assign an instruction to a particular group based upon whether a particular field is present within the instruction. For example, if an instruction being predecoded does not have displacement or immediate data information, then the instruction is padded to a fixed length of five bytes and is stored as part of group <b>160</b>. If the instruction has data bytes but does not have displacement information, then the instruction is padded to a fixed length of nine bytes and is stored in group <b>142</b>. If the instruction has both displacement bytes and data bytes, then the instruction is padded to the full thirteen bytes and is stored in group <b>144</b>. As in previous embodiments, the prefix bytes may be compressed into a single byte. Advantageously, this method speeds decode while reducing the resources necessary to store fixed-length instructions within instruction cache <b>16</b>.</p><p>Note that other group configurations and sizes based upon other fields are possible and contemplated. For example, an instruction that does not have any prefix, displacement, or data bytes may be padded to a length of four bytes. In another configuration, predecode unit <b>12</b> may be configured to pad and group instructions in two or four byte increments, resulting in four or eight groups of instructions. Further note that other methods may be used to pad instructions to a predetermined length. For example, in one embodiment predecoder <b>12</b> may be configured to pad constants after the final byte of the variable-length instruction. While this method may not identify each field within the instruction, it may allow for faster predecoding while still reducing decoding (particularly alignment) times.</p><p>Turning now to FIG. 10, an embodiment of instruction cache <b>16</b> that is configured to pad and store instructions into groups is shown. In this embodiment, pointer array <b>90</b> is configured to store pointers which point to storage locations within fixed-length instruction storage arrays <b>92</b>A-C. Each fixed-length instruction storage array <b>92</b>A-C (also referred to as sub-arrays) is configured to store one particular length of fixed-length instructions. Sub-array <b>92</b>C may be configured to store fixed-length instructions that are 13 bytes in length (e.g., instructions having displacement data). Sub-array <b>92</b>B may be configured to store fixed-length instructions that are 9 bytes in length (e.g., instruction without displacement data). Similarly, sub-array <b>92</b>A may be configured to store fixed-length instructions that are only five bytes in length (e.g., instructions having no displacement bytes or data bytes). Pointer array <b>90</b> may be configured as in previous embodiments, with each storage location storing a pointer that points to one storage location within either sub-array <b>92</b>A, sub-array <b>92</b>B, or sub-array <b>92</b>C.</p><p>Other embodiments are also contemplated. For example, in one embodiment variable-length instruction storage array <b>50</b>, pointer array <b>90</b>, and fixed-length instruction storage arrays <b>92</b>A-C may all be incorporated into instruction cache <b>16</b>. In another embodiment, there may be more than one storage array having the same length of instructions. For example, the embodiment illustrated above may comprise two fixed-length instruction storage arrays storing 9-byte long instructions. The first array may be configured to store instructions not having displacement data, whereas the second array may be configured to store instructions not having immediate data.</p><p>A software compiler configured to compile variable length instructions into fixed-length instructions is also contemplated. The variable-length to fixed length conversion may take place as part of the compiling of high-level language instructions to object code (e.g., x86 instructions), or the conversion may be performed as an optimization step during or after object code has been generated. The same methods illustrated above may be used. However, the compiler may optionally be configured to expand only certain speed-critical portions of code. Advantageously, this may improve the speed of decode for speed-critical sections of code while reducing the amount of code expansion that takes place. The compiler may be configured to indicate the start and end of fixed-length instruction sections by inserting special opcodes or special status bits. The compiler may also be configured to pad the variable-length instructions using selected constants, e.g., no operation instruction codes (NOPs).</p><p>Exemplary Computer System</p><p>Turning now to FIG. 11, a block diagram of one embodiment of a computer system <b>200</b> utilizing microprocessor <b>10</b> is shown. Other embodiments are possible and contemplated. In the depicted system, a main memory <b>204</b> is coupled to bus bridge <b>202</b> through a memory bus <b>206</b>, and a graphics controller <b>208</b> is coupled to bus bridge <b>202</b> through an AGP bus <b>210</b>. Finally, a plurality of PCI devices <b>212</b>A-<b>212</b>B are coupled to bus bridge <b>202</b> through a PCI bus <b>214</b>. A secondary bus bridge <b>216</b> may further be provided to accommodate an electrical interface to one or more EISA or ISA devices <b>218</b> through an EISA/ISA bus <b>220</b>. Microprocessor <b>10</b> is coupled to bus bridge <b>202</b> through a CPU bus <b>224</b>.</p><p>Bus bridge <b>202</b> provides an interface between microprocessor <b>10</b>, main memory <b>204</b>, graphics controller <b>208</b>, and devices attached to PCI bus <b>214</b>. When an operation is received from one of the devices connected to bus bridge <b>202</b>, bus bridge <b>202</b> identifies the target of the operation (e.g. a particular device or, in the case of PCI bus <b>214</b>, that the target is on PCI bus <b>214</b>). Bus bridge <b>202</b> routes the operation to the targeted device. Bus bridge <b>202</b> generally translates an operation from the protocol used by the source device or bus to the protocol used by the target device or bus.</p><p>In addition to providing an interface to an ISA/EISA bus for PCI bus <b>214</b>, secondary bus bridge <b>216</b> may further incorporate additional functionality, as desired. For example, in one embodiment, secondary bus bridge <b>216</b> includes a master PCI arbiter (not shown) for arbitrating ownership of PCI bus <b>214</b>. An input/output controller (not shown), either external from or integrated with secondary bus bridge <b>216</b>, may also be included within computer system <b>200</b> to provide operational support for a keyboard and mouse <b>222</b> and for various serial and parallel ports, as desired. An external cache unit (not shown) may further be coupled to CPU bus <b>224</b> between microprocessor <b>10</b> and bus bridge <b>202</b> in other embodiments. Alternatively, the external cache may be coupled to bus bridge <b>202</b> and cache control logic for the external cache may be integrated into bus bridge <b>202</b>.</p><p>Main memory <b>204</b> is a memory in which application programs are stored and from which microprocessor <b>10</b> primarily executes. A suitable main memory <b>204</b> comprises DRAM (Dynamic Random Access Memory), and preferably a plurality of banks of SDRAM (Synchronous DRAM).</p><p>PCI devices <b>212</b>A-<b>212</b>B are illustrative of a variety of peripheral devices such as, for example, network interface cards, video accelerators, audio cards, hard or floppy disk drives or drive controllers, SCSI (Small Computer Systems Interface) adapters and telephony cards. Similarly, ISA device <b>218</b> is illustrative of various types of peripheral devices, such as a modem, a sound card, and a variety of data acquisition cards such as GPIB or field bus interface cards.</p><p>Graphics controller <b>208</b> is provided to control the rendering of text and images on a display <b>226</b>. Graphics controller <b>208</b> may embody a typical graphics accelerator generally known in the art to render three-dimensional data structures which can be effectively shifted into and from main memory <b>204</b>. Graphics controller <b>208</b> may therefore be a master of AGP bus <b>210</b> in that it can request and receive access to a target interface within bus bridge <b>202</b> to thereby obtain access to main memory <b>204</b>. A dedicated graphics bus accommodates rapid retrieval of data from main memory <b>204</b>. For certain operations, graphics controller <b>208</b> may further be configured to generate PCI protocol transactions on AGP bus <b>210</b>. The AGP interface of bus bridge <b>202</b> may thus include functionality to support both AGP protocol transactions as well as PCI protocol target and initiator transactions. Display <b>226</b> is any electronic display upon which an image or text can be presented. A suitable display <b>226</b> includes a cathode ray tube (\u201cCRT\u201d), a liquid crystal display (\u201cLCD\u201d), etc.</p><p>It is noted that, while the AGP, PCI, and ISA or EISA buses have been used as examples in the above description, any bus architectures may be substituted as desired. It is further noted that computer system <b>200</b> may be a multiprocessing computer system including additional microprocessors.</p><p>It is still further noted that the present discussion may refer to the assertion of various signals. As used herein, a signal is \u201casserted\u201d if it conveys a value indicative of a particular condition. Conversely, a signal is \u201cdeasserted\u201d or \u201cnot asserted\u201d if it conveys a value indicative of a lack of a particular condition. A signal may be defined to be asserted when it conveys a logical zero value or, conversely, when it conveys a logical one value. Additionally, various values have been described as being discarded in the above discussion. A value may be discarded in a number of manners, but generally involves modifying the value such that it is ignored by logic circuitry which receives the value. For example, if the value comprises a bit, the logic state of the value may be inverted to discard the value. If the value is an n-bit value, one of the n-bit encodings may indicate that the value is invalid. Setting the value to the invalid encoding causes the value to be discarded. Additionally, an n-bit value may include a valid bit indicative, when set, that the n-bit value is valid. Resetting the valid bit may comprise discarding the value. Other methods of discarding a value may be used as well.</p><p>Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Rupaka", "last_name": "Mahalingaiah", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "ADVANCED MICRO DEVICES, INC."}, {"first_name": "", "last_name": "GLOBALFOUNDRIES U.S. INC.", "name": ""}, {"first_name": "", "last_name": "GLOBALFOUNDRIES INC.", "name": ""}, {"first_name": "", "last_name": "GLOBALFOUNDRIES INC.", "name": ""}, {"first_name": "", "last_name": "ADVANCED MICRO DEVICES, INC.", "name": ""}], "ipc_classes": [{"primary": true, "label": "G06F  15/00"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/38        20060101A I20051008RMEP"}, {"label": "G06F   9/30        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712213"}, {"primary": false, "label": "712E09055"}, {"primary": false, "label": "712023"}, {"primary": false, "label": "712210"}, {"primary": false, "label": "717151"}, {"primary": false, "label": "712E09029"}], "ecla_classes": [{"label": "G06F   9/38C2"}, {"label": "G06F   9/30T2A"}, {"label": "G06F   9/38B9"}, {"label": "G06F   9/30T2"}], "cpc_classes": [{"label": "G06F   9/3816"}, {"label": "G06F   9/30152"}, {"label": "G06F   9/382"}, {"label": "G06F   9/3816"}, {"label": "G06F   9/382"}, {"label": "G06F   9/30149"}, {"label": "G06F   9/30152"}, {"label": "G06F   9/30149"}], "f_term_classes": [], "legal_status": "Expired - Lifetime", "priority_date": "1998-09-21", "application_date": "1998-09-21", "family_members": [{"ucid": "US-6253309-B1", "titles": [{"lang": "EN", "text": "Forcing regularity into a CISC instruction set by padding instructions"}]}]}