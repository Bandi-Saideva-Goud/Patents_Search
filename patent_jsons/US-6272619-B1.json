{"patent_number": "US-6272619-B1", "publication_id": 72745433, "family_id": 24920949, "publication_date": "2001-08-07", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA11218466\" source=\"national office\"><p>A high-performance, superscalar-based computer system with out-of-order instruction execution for enhanced resource utilization and performance throughput. The computer system fetches a plurality of fixed length instructions with a specified, sequential program order (in-order). The computer system includes an instruction execution unit including a register file, a plurality of functional units, and an instruction control unit for examining the instructions and scheduling the instructions for out-of-order execution by the functional units. The register file includes a set of temporary data registers that are utilized by the instruction execution control unit to receive data results generated by the functional units. The data results of each executed instruction are stored in the temporary data registers until all prior instructions have been executed, thereby retiring the executed instructions in-order.</p></abstract>"}, {"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA72594814\"><p>A high-performance, superscalar-based computer system with out-of-order instruction execution for enhanced resource utilization and performance throughput. The computer system fetches a plurality of fixed length instructions with a specified, sequential program order (in-order). The computer system includes an instruction execution unit including a register file, a plurality of functional units, and an instruction control unit for examining the instructions and scheduling the instructions for out-of-order execution by the functional units. The register file includes a set of temporary data registers that are utilized by the instruction execution control unit to receive data results generated by the functional units. The data results of each executed instruction are stored in the temporary data registers until all prior instructions have been executed, thereby retiring the executed instructions in-order.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00001\" num=\"1\"><claim-text>1. A computer system, comprising:</claim-text><claim-text>a memory; </claim-text><claim-text>a superscalar microprocessor for executing instructions obtained from an instruction store; and </claim-text><claim-text>a bus coupled between said microprocessor and said memory, wherein said microprocessor comprises: </claim-text><claim-text>a fetch circuit to fetch a plurality of instructions from said instruction store during a first processor cycle, the plurality of instructions being in program order; </claim-text><claim-text>a first in first out (FIFO) buffer to buffer at most four of said plurality of instructions from said fetch circuit during a second processor cycle; </claim-text><claim-text>a dispatch circuit to concurrently decode, during said second processor cycle and then concurrently dispatch during a third processor cycle, four of said plurality of instructions buffered by said FIFO buffer; and </claim-text><claim-text>an execution unit comprising: </claim-text><claim-text>a plurality of functional units, each of said plurality of functional units executing one of said plurality of instructions dispatched by said dispatch circuit out of the program order, and </claim-text><claim-text>a register file comprising temporary registers for temporarily storing out-of-order execution results from said plurality of functional units and a register array for storing results from said temporary registers, </claim-text><claim-text>a plurality of data routing paths, and wherein </claim-text><claim-text>said register file communicates with said plurality of functional units via said plurality of data routing paths for concurrently providing data to more than one of said plurality of functional units and thereby enabling concurrent execution of more than one of said plurality instructions by said plurality of functional units. </claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00002\" num=\"2\"><claim-text>2. The computer system of claim <b>1</b>, further comprising:</claim-text><claim-text>retirement circuitry for causing a plurality of said out-of-order executed instructions to complete in program order; and wherein </claim-text><claim-text>said retirement circuitry causes data values to be transferred from said temporary registers to said register array. </claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00003\" num=\"3\"><claim-text>3. The computer system of claim <b>1</b>, wherein said FIFO buffer includes first and second registers; and wherein</claim-text><claim-text>each of said first and said second registers concurrently provides one or more instructions to said dispatch circuit. </claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00004\" num=\"4\"><claim-text>4. The computer system of claim <b>1</b>, wherein said FIFO buffer includes first and second registers; and wherein</claim-text><claim-text>each of said first and said second registers concurrently provides instruction sets of four instructions to said dispatch circuit. </claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00005\" num=\"5\"><claim-text>5. The computer system of claim <b>1</b>, wherein said dispatch circuit additionally includes circuitry for issuing said instructions out of program order to said execution unit subject to the availability of said plurality of functional units.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00006\" num=\"6\"><claim-text>6. The computer system of claim <b>1</b>, wherein said instruction store is coupled to an external cache.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00007\" num=\"7\"><claim-text>7. The computer system of claim <b>1</b>, wherein said dispatch circuit concurrently dispatches said instructions by providing a plurality of said buffered instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 8, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00008\" num=\"8\"><claim-text>8. A computer system, comprising:</claim-text><claim-text>a memory; </claim-text><claim-text>a superscalar microprocessor for executing instructions obtained from an instruction store; and </claim-text><claim-text>a bus coupled between said microprocessor and said memory, wherein said microprocessor comprises: </claim-text><claim-text>a fetch circuit to fetch a plurality of instructions from said instruction store during a first processor cycle, the plurality of instructions being in program order; </claim-text><claim-text>an instruction buffer for buffering said plurality of said instructions during a second processor cycle; </claim-text><claim-text>a branch decoder responsive to said first instruction buffer during said second processor cycle; </claim-text><claim-text>a first in first out (FIFO) buffer for buffering four of said plurality of said instructions from said branch decoder during said second processor cycle; </claim-text><claim-text>a dispatch circuit to concurrently decode, during said second processor cycle and then concurrently dispatch during a third processor cycle, at most four of said plurality of instructions buffered by said FIFO buffer; and </claim-text><claim-text>an execution unit comprising: </claim-text><claim-text>a plurality of functional units, each of said plurality of functional units executing one of said plurality of instructions dispatched by said dispatch circuit out of the program order, and </claim-text><claim-text>a register file comprising temporary registers to temporarily store out-of-order execution results from said plurality of functional units and a register array to store results from said temporary registers, </claim-text><claim-text>a plurality of data routing paths, and wherein </claim-text><claim-text>said register file communicates with said plurality of functional units via said plurality of data routing paths to supply data to more than one of said functional units and thereby enabling concurrent execution of more than one of said plurality instructions by said plurality of functional units. </claim-text></claim>"}, {"num": 9, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00009\" num=\"9\"><claim-text>9. The computer system of claim <b>8</b>, further comprising:</claim-text><claim-text>retirement circuitry for causing a plurality of said out-of-order executed instructions to complete in program order; and wherein </claim-text><claim-text>said retirement circuitry causes data values to be transferred from said temporary registers to said register array. </claim-text></claim>"}, {"num": 10, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00010\" num=\"10\"><claim-text>10. The computer system of claim <b>8</b>, wherein said dispatch circuit additionally includes circuitry for issuing said instructions out of program order to said execution unit subject to the availability of said plurality of functional units.</claim-text></claim>"}, {"num": 11, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00011\" num=\"11\"><claim-text>11. The computer system of claim <b>8</b>, wherein said instruction store is coupled to an external cache that stores instructions to be executed by the microprocessor.</claim-text></claim>"}, {"num": 12, "parent": 8, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00012\" num=\"12\"><claim-text>12. The computer system of claim <b>8</b>, wherein said dispatch circuit concurrently dispatches said instructions by providing a plurality of said buffered instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00013\" num=\"13\"><claim-text>13. A computer system, comprising:</claim-text><claim-text>a memory; </claim-text><claim-text>a superscalar microprocessor for executing instructions obtained from an instruction store; and </claim-text><claim-text>a bus coupled between said microprocessor and said memory, wherein said microprocessor comprises: </claim-text><claim-text>a fetch circuit to fetch a plurality of instructions from said instruction store during a first processor cycle, the plurality of instructions being in program order; </claim-text><claim-text>an instruction buffer for buffering said plurality of said instructions during a second processor cycle; </claim-text><claim-text>a branch decoder responsive to said first instruction buffer during said second processor cycle; </claim-text><claim-text>a first in first out (FIFO) buffer for buffering four of said plurality of said instructions during said second processor cycle; </claim-text><claim-text>a dispatch circuit to concurrently decode, during said second processor cycle and then concurrently dispatch during a third processor cycle, at most four of said plurality of instructions buffered by said FIFO buffer; and </claim-text><claim-text>an execution unit comprising: </claim-text><claim-text>a plurality of functional units, each of said plurality of functional units executing one of said plurality of instructions dispatched by said dispatch circuit out of the program order, and </claim-text><claim-text>a register file comprising temporary registers to temporarily store out-of order execution results from said plurality of functional units and a register array to store results from said temporary registers, </claim-text><claim-text>a plurality of data routing paths, and wherein </claim-text><claim-text>said register file communicates with said plurality of functional units via said plurality of data routing paths to supply data to more than one of said functional units and thereby enabling concurrent execution of more than one of said plurality instructions by said plurality of functional units. </claim-text></claim>"}, {"num": 14, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00014\" num=\"14\"><claim-text>14. The computer system of claim <b>13</b>, further comprising:</claim-text><claim-text>retirement circuitry for causing a plurality of said out-of-order executed instructions to complete in program order; and wherein said retirement circuitry causes data values to be transferred from said temporary registers to said register array. </claim-text></claim>"}, {"num": 15, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00015\" num=\"15\"><claim-text>15. The computer system of claim <b>13</b>, wherein said dispatch circuit additionally includes circuitry for issuing said instructions out of program order to said execution unit subject to the availability of said plurality of functional units.</claim-text></claim>"}, {"num": 16, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00016\" num=\"16\"><claim-text>16. The computer system of claim <b>13</b>, wherein said instruction store is coupled to an external cache that stores instructions to be executed by the microprocessor.</claim-text></claim>"}, {"num": 17, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00017\" num=\"17\"><claim-text>17. The computer system of claim <b>13</b>, wherein said dispatch circuit concurrently dispatches said instructions by providing a plurality of said buffered instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 18, "parent": 13, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00018\" num=\"18\"><claim-text>18. The computer system of claim <b>13</b>, wherein said FIFO buffer buffers said plurality of said instructions from said first instruction buffer.</claim-text></claim>"}, {"num": 19, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00019\" num=\"19\"><claim-text>19. A computer system, comprising:</claim-text><claim-text>a memory; </claim-text><claim-text>a superscalar microprocessor for executing instructions obtained from an instruction store; and </claim-text><claim-text>a bus coupled between said microprocessor and said memory, wherein said microprocessor comprises: </claim-text><claim-text>a fetch circuit to fetch a plurality of instructions from said instruction store, the plurality of instructions being in program order; </claim-text><claim-text>a branch decoder responsive to said fetch circuit; </claim-text><claim-text>a first in first out (FIFO) buffer for buffering said plurality of said instructions from said branch decoder; </claim-text><claim-text>a dispatch circuit to concurrently decode and then concurrently dispatch more than one of said plurality of instructions buffered by said FIFO buffer; and </claim-text><claim-text>an execution unit comprising: </claim-text><claim-text>a plurality of functional units, each of said plurality of functional units executing one of said plurality of instructions dispatched by said dispatch circuit out of the program order, and </claim-text><claim-text>a register file comprising temporary registers to temporarily store out-of-order execution results from said plurality of functional units and a register array to store results from said temporary registers, </claim-text><claim-text>a plurality of data routing paths, and wherein </claim-text><claim-text>said register file communicates with said plurality of functional units via said plurality of data routing paths to supply data to more than one of said functional units and thereby enabling concurrent execution of more than one of said plurality instructions by said plurality of functional units. </claim-text></claim>"}, {"num": 20, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00020\" num=\"20\"><claim-text>20. The computer system of claim <b>19</b>, further comprising:</claim-text><claim-text>retirement circuitry for causing a plurality of said out-of-order executed instructions to complete in program order; and wherein </claim-text><claim-text>said retirement circuitry causes data values to be transferred from said temporary registers to said register array. </claim-text></claim>"}, {"num": 21, "parent": 20, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00021\" num=\"21\"><claim-text>21. The computer system of claim <b>20</b>, wherein said retirement circuitry is capable of retiring up to four instructions in a processor cycle.</claim-text></claim>"}, {"num": 22, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00022\" num=\"22\"><claim-text>22. The computer system of claim <b>19</b>, wherein said FIFO buffer is capable of providing four or more instructions to said dispatch circuit in a processor cycle.</claim-text></claim>"}, {"num": 23, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00023\" num=\"23\"><claim-text>23. The computer system of claim <b>19</b>, wherein said dispatch circuit is capable of dispatching up to four instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 24, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00024\" num=\"24\"><claim-text>24. The computer system of claim <b>19</b>, wherein said dispatch circuit additionally includes circuitry for issuing said instructions out of program order to said execution unit subject to the availability of said plurality of functional units.</claim-text></claim>"}, {"num": 25, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00025\" num=\"25\"><claim-text>25. The computer system of claim <b>19</b>, wherein said instruction store is coupled to an external cache that stores instructions to be executed by the microprocessor.</claim-text></claim>"}, {"num": 26, "parent": 19, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00026\" num=\"26\"><claim-text>26. The computer system of claim <b>19</b>, wherein said dispatch circuit concurrently dispatches said instructions by providing a plurality of said buffered instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 27, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00027\" num=\"27\"><claim-text>27. A computer system, comprising:</claim-text><claim-text>a memory; </claim-text><claim-text>a superscalar microprocessor for executing instructions obtained from an instruction store; and </claim-text><claim-text>a bus coupled between said microprocessor and said memory, wherein said microprocessor comprises: </claim-text><claim-text>a fetch circuit to fetch a plurality of instructions from said instruction store, the plurality of instructions being in program order; </claim-text><claim-text>a first decoder responsive to said fetch circuit; </claim-text><claim-text>a first in first out (FIFO) buffer for buffering said plurality of said instructions from said decoder; </claim-text><claim-text>a dispatch circuit comprising a second decoder to concurrently decode and a dispatch portion to then concurrently dispatch more than one of said plurality of instructions buffered by said FIFO buffer; and </claim-text><claim-text>an execution unit comprising: </claim-text><claim-text>a plurality of functional units, each of said plurality of functional units executing one of said plurality of instructions dispatched by said dispatch circuit out of the program order, and </claim-text><claim-text>a register file comprising temporary registers to temporarily store out-of-order execution results from said plurality of functional units and a register array to store results from said temporary registers, </claim-text><claim-text>a plurality of data routing paths, and wherein </claim-text><claim-text>said register file communicates with said plurality of functional units via said plurality of data routing paths to supply data to more than one of said functional units and thereby enabling concurrent execution of more than one of said plurality instructions by said plurality of functional units. </claim-text></claim>"}, {"num": 28, "parent": 27, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00028\" num=\"28\"><claim-text>28. The computer system of claim <b>27</b>, further comprising:</claim-text><claim-text>retirement circuitry for causing a plurality of said out-of-order executed instructions to complete in program order; and wherein </claim-text><claim-text>said retirement circuitry causes data values to be transferred from said temporary registers to said register array. </claim-text></claim>"}, {"num": 29, "parent": 28, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00029\" num=\"29\"><claim-text>29. The computer system of claim <b>28</b>, wherein said retirement circuitry is capable of retiring up to four instructions in a processor cycle.</claim-text></claim>"}, {"num": 30, "parent": 27, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00030\" num=\"30\"><claim-text>30. The computer system of claim <b>27</b>, wherein said FIFO buffer is capable of providing four or more instructions to said dispatch circuit in a processor cycle.</claim-text></claim>"}, {"num": 31, "parent": 27, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00031\" num=\"31\"><claim-text>31. The computer system of claim <b>27</b>, wherein said dispatch circuit is capable of dispatching up to four instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 32, "parent": 27, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00032\" num=\"32\"><claim-text>32. The computer system of claim <b>27</b>, wherein said dispatch circuit additionally includes circuitry for issuing said instructions out of program order to said execution unit subject to the availability of said plurality of functional units.</claim-text></claim>"}, {"num": 33, "parent": 27, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00033\" num=\"33\"><claim-text>33. The computer system of claim <b>27</b>, wherein said instruction store is coupled to an external cache that stores instructions to be executed by the microprocessor.</claim-text></claim>"}, {"num": 34, "parent": 27, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00034\" num=\"34\"><claim-text>34. The computer system of claim <b>27</b>, wherein said dispatch circuit concurrently dispatches said instructions by providing a plurality of said buffered instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 35, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00035\" num=\"35\"><claim-text>35. A computer system, comprising:</claim-text><claim-text>a memory; </claim-text><claim-text>a superscalar microprocessor for executing instructions obtained from an instruction store; and </claim-text><claim-text>a bus coupled between said microprocessor and said memory, wherein said microprocessor comprises: </claim-text><claim-text>a fetch circuit to fetch a plurality of instructions from said instruction store, the plurality of instructions being in program order; </claim-text><claim-text>a branch decoder responsive to said fetch circuit; </claim-text><claim-text>a buffer for buffering said plurality of said instructions from said branch decoder; </claim-text><claim-text>a dispatch circuit comprising a second decoder to concurrently decode and a dispatch portion to then concurrently dispatch more than one of said plurality of instructions buffered by said buffer; and </claim-text><claim-text>an execution unit comprising: </claim-text><claim-text>a plurality of functional units, each of said plurality of functional units executing one of said plurality of instructions dispatched by said dispatch circuit out of the program order, and </claim-text><claim-text>a register file comprising temporary registers to temporarily store out-of-order execution results from said plurality of functional units and a register array to store results from said temporary registers, </claim-text><claim-text>a plurality of data routing paths, and wherein said register file communicates with said plurality of functional units via </claim-text><claim-text>said plurality of data routing paths to supply data to more than one of said functional units and thereby enabling concurrent execution of more than one of said plurality instructions by said plurality of functional units. </claim-text></claim>"}, {"num": 36, "parent": 35, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00036\" num=\"36\"><claim-text>36. The computer system of claim <b>35</b>, further comprising:</claim-text><claim-text>retirement circuitry for causing a plurality of said out-of-order executed instructions to complete in program order; and wherein </claim-text><claim-text>said retirement circuitry causes data values to be transferred from said temporary registers to said register array. </claim-text></claim>"}, {"num": 37, "parent": 36, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00037\" num=\"37\"><claim-text>37. The computer system of claim <b>36</b>, wherein said retirement circuitry is capable of retiring up to four instructions in a processor cycle.</claim-text></claim>"}, {"num": 38, "parent": 35, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00038\" num=\"38\"><claim-text>38. The computer system of claim <b>35</b>, wherein said buffer is capable of providing four or more instructions to said dispatch circuit in a processor cycle.</claim-text></claim>"}, {"num": 39, "parent": 35, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00039\" num=\"39\"><claim-text>39. The computer system of claim <b>35</b>, wherein said dispatch circuit is capable of dispatching up to four instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 40, "parent": 35, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00040\" num=\"40\"><claim-text>40. The computer system of claim <b>35</b>, wherein said dispatch circuit additionally includes circuitry for issuing said instructions out of program order to said execution unit subject to the availability of said plurality of functional units.</claim-text></claim>"}, {"num": 41, "parent": 35, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00041\" num=\"41\"><claim-text>41. The computer system of claim <b>35</b>, wherein said instruction store is coupled to an external cache that stores instructions to be executed by the microprocessor.</claim-text></claim>"}, {"num": 42, "parent": 35, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00042\" num=\"42\"><claim-text>42. The computer system of claim <b>35</b>, wherein said dispatch circuit concurrently dispatches said instructions by providing a plurality of said buffered instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 43, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00043\" num=\"43\"><claim-text>43. A computer system, comprising:</claim-text><claim-text>a memory; </claim-text><claim-text>a superscalar microprocessor for executing instructions obtained from an instruction store; and </claim-text><claim-text>a bus coupled between said microprocessor and said memory, wherein said microprocessor comprises: </claim-text><claim-text>a fetch circuit to fetch a plurality of instructions from said instruction store, the plurality of instructions being in program order; </claim-text><claim-text>a first decoder responsive to said fetch circuit; </claim-text><claim-text>a buffer for buffering said plurality of said instructions from said decoder; </claim-text><claim-text>a dispatch circuit comprising a second decoder to concurrently decode and a dispatch portion to then concurrently dispatch more than one of said plurality of instructions buffered by said buffer; and </claim-text><claim-text>an execution unit comprising: </claim-text><claim-text>a plurality of functional units, each of said plurality of functional units executing one of said plurality of instructions dispatched by said dispatch circuit out of the program order, and </claim-text><claim-text>a register file comprising temporary registers to temporarily store out-of-order execution results from said plurality of functional units and a register array to store results from said temporary registers, </claim-text><claim-text>a plurality of data routing paths, and wherein </claim-text><claim-text>said register file communicates with said plurality of functional units via said plurality of data routing paths to supply data to more than one of said functional units and thereby enabling concurrent execution of more than one of said plurality instructions by said plurality of functional units. </claim-text></claim>"}, {"num": 44, "parent": 43, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00044\" num=\"44\"><claim-text>44. The computer system of claim <b>43</b>, further comprising:</claim-text><claim-text>retirement circuitry for causing a plurality of said out-of-order executed instructions to complete in program order; and wherein </claim-text><claim-text>said retirement circuitry causes data values to be transferred from said temporary registers to said register array. </claim-text></claim>"}, {"num": 45, "parent": 44, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00045\" num=\"45\"><claim-text>45. The computer system of claim <b>44</b>, wherein said retirement circuitry is capable of retiring up to four instructions in a processor cycle.</claim-text></claim>"}, {"num": 46, "parent": 43, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00046\" num=\"46\"><claim-text>46. The computer system of claim <b>43</b>, wherein said buffer is capable of providing four or more instructions to said dispatch circuit in a processor cycle.</claim-text></claim>"}, {"num": 47, "parent": 43, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00047\" num=\"47\"><claim-text>47. The computer system of claim <b>43</b>, wherein said dispatch circuit is capable of dispatching up to four instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 48, "parent": 43, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00048\" num=\"48\"><claim-text>48. The computer system of claim <b>43</b>, wherein said dispatch circuit additionally includes circuitry for issuing said instructions out of program order to said execution unit subject to the availability of said plurality of functional units.</claim-text></claim>"}, {"num": 49, "parent": 43, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00049\" num=\"49\"><claim-text>49. The computer system of claim <b>43</b>, wherein said instruction store is coupled to an external cache that stores instructions to be executed by the microprocessor.</claim-text></claim>"}, {"num": 50, "parent": 43, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00050\" num=\"50\"><claim-text>50. The computer system of claim <b>43</b>, wherein said dispatch circuit concurrently dispatches said instructions by providing a plurality of said buffered instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 51, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00051\" num=\"51\"><claim-text>51. A computer system, comprising:</claim-text><claim-text>a memory; </claim-text><claim-text>a superscalar microprocessor for executing instructions obtained from an instruction store; and </claim-text><claim-text>a bus coupled between said microprocessor and said memory, wherein said microprocessor comprises: </claim-text><claim-text>a fetch circuit to fetch a plurality of instructions from said instruction store, the plurality of instructions being in program order; </claim-text><claim-text>a branch decoder responsive to said fetch circuit; </claim-text><claim-text>a dispatch circuit comprising a second decoder to concurrently decode and a dispatch portion to then concurrently dispatch more than one of said plurality of instructions from by said branch decoder; and </claim-text><claim-text>an execution unit comprising: </claim-text><claim-text>a plurality of functional units, each of said plurality of functional units executing one of said plurality of instructions dispatched by said dispatch circuit out of the program order, and </claim-text><claim-text>a register file comprising temporary resisters to temporarily store out-of-order execution results from said plurality of functional units and a register array to store results from said temporary registers, </claim-text><claim-text>a plurality of data routing paths, and wherein </claim-text><claim-text>said register file communicates with said plurality of functional units via said plurality of data routing paths to supply data to more than one of said functional units and thereby enabling concurrent execution of more than one of said plurality instructions by said plurality of functional units. </claim-text></claim>"}, {"num": 52, "parent": 51, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00052\" num=\"52\"><claim-text>52. The computer system of claim <b>51</b>, further comprising:</claim-text><claim-text>retirement circuitry for causing a plurality of said out-of-order executed instructions to complete in program order; and wherein </claim-text><claim-text>said retirement circuitry causes data values to be transferred from said temporary registers to said register array. </claim-text></claim>"}, {"num": 53, "parent": 52, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00053\" num=\"53\"><claim-text>53. The computer system of claim <b>52</b>, wherein said retirement circuitry is capable of retiring up to four instructions in a processor cycle.</claim-text></claim>"}, {"num": 54, "parent": 51, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00054\" num=\"54\"><claim-text>54. The computer system of claim <b>51</b>, wherein said dispatch circuit is capable of dispatching up to four instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 55, "parent": 51, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00055\" num=\"55\"><claim-text>55. The computer system of claim <b>51</b>, wherein said dispatch circuit additionally includes circuitry for issuing said instructions out of program order to said execution unit subject to the availability of said plurality of functional units.</claim-text></claim>"}, {"num": 56, "parent": 51, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00056\" num=\"56\"><claim-text>56. The computer system of claim <b>51</b>, wherein said instruction store is coupled to an external cache that stores instructions to be executed by the microprocessor.</claim-text></claim>"}, {"num": 57, "parent": 51, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00057\" num=\"57\"><claim-text>57. The computer system of claim <b>51</b>, wherein said dispatch circuit concurrently dispatches said instructions by providing a plurality of said buffered instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 58, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00058\" num=\"58\"><claim-text>58. A computer system, comprising:</claim-text><claim-text>a memory; </claim-text><claim-text>a superscalar microprocessor for executing instructions obtained from an instruction store; and </claim-text><claim-text>a bus coupled between said microprocessor and said memory, wherein said microprocessor comprises: </claim-text><claim-text>a fetch circuit to fetch a plurality of instructions from said instruction store, the plurality of instructions being in program order; </claim-text><claim-text>a first decoder responsive to said fetch circuit; </claim-text><claim-text>a dispatch circuit comprising a second decoder to concurrently decode and a dispatch portion to then concurrently dispatch more than one of said plurality of instructions from said first decoder; and </claim-text><claim-text>an execution unit comprising: </claim-text><claim-text>a plurality of functional units, each of said plurality of functional units executing one of said plurality of instructions dispatched by said dispatch circuit out of the program order, and </claim-text><claim-text>a register file comprising temporary registers to temporarily store out-of-order execution results from said plurality of functional units and a register array to store results from said temporary registers, </claim-text><claim-text>a plurality of data routing paths, and wherein </claim-text><claim-text>said register file communicates with said plurality of functional units via said plurality of data routing paths to supply data to more than one of said functional units and thereby enabling concurrent execution of more than one of said plurality instructions by said plurality of functional units. </claim-text></claim>"}, {"num": 59, "parent": 58, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00059\" num=\"59\"><claim-text>59. The computer system of claim <b>58</b>, further comprising:</claim-text><claim-text>retirement circuitry for causing a plurality of said out-of-order executed instructions to complete in program order; and wherein </claim-text><claim-text>said retirement circuitry causes data values to be transferred from said temporary registers to said register array. </claim-text></claim>"}, {"num": 60, "parent": 59, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00060\" num=\"60\"><claim-text>60. The computer system of claim <b>59</b>, wherein said retirement circuitry is capable of retiring up to four instructions in a processor cycle.</claim-text></claim>"}, {"num": 61, "parent": 58, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00061\" num=\"61\"><claim-text>61. The computer system of claim <b>58</b>, wherein said dispatch circuit is capable of dispatching up to four instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 62, "parent": 58, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00062\" num=\"62\"><claim-text>62. The computer system of claim <b>58</b>, wherein said dispatch circuit additionally includes circuitry for issuing said instructions out of program order to said execution unit subject to the availability of said plurality of functional units.</claim-text></claim>"}, {"num": 63, "parent": 58, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00063\" num=\"63\"><claim-text>63. The computer system of claim <b>58</b>, wherein said instruction store is coupled to an external cache that stores instructions to be executed by the microprocessor.</claim-text></claim>"}, {"num": 64, "parent": 58, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00064\" num=\"64\"><claim-text>64. The computer system of claim <b>58</b>, wherein said dispatch circuit concurrently dispatches said instructions by providing a plurality of said buffered instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 65, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00065\" num=\"65\"><claim-text>65. A computer system, comprising:</claim-text><claim-text>a memory; </claim-text><claim-text>a superscalar microprocessor for executing instructions obtained from an instruction store; and </claim-text><claim-text>a bus coupled between said microprocessor and said memory, wherein said microprocessor comprises: </claim-text><claim-text>a fetch circuit to fetch a plurality of instructions from said instruction store, the plurality of instructions being in program order; </claim-text><claim-text>a first decoder responsive to said fetch circuit; </claim-text><claim-text>a first in first out (FIFO) buffer for buffering said plurality of said instructions from said decoder; </claim-text><claim-text>a second decoder to concurrently decode more than one of said plurality of instructions buffered by said FIFO buffer; </claim-text><claim-text>a dispatch circuit to dispatch more than one of said plurality of instructions decoded by said second decoder; and </claim-text><claim-text>an execution unit comprising: </claim-text><claim-text>a plurality of functional units, each of said plurality of functional units executing one of said plurality of instructions dispatched by said dispatch circuit out of the program order, and </claim-text><claim-text>a register file comprising temporary registers to temporarily store out-of-order execution results from said plurality of functional units and a register array to store results from said temporary registers, </claim-text><claim-text>a plurality of data routing paths, and wherein </claim-text><claim-text>said register file communicates with said plurality of functional units via said plurality of data routing paths to supply data to more than one of said functional units and thereby enabling concurrent execution of more than one of said plurality instructions by said plurality of functional units. </claim-text></claim>"}, {"num": 66, "parent": 65, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00066\" num=\"66\"><claim-text>66. The computer system of claim <b>65</b>, further comprising:</claim-text><claim-text>retirement circuitry for causing a plurality of said out-of-order executed instructions to complete in program order; and wherein said retirement circuitry causes data values to be transferred from said temporary registers to said register array. </claim-text></claim>"}, {"num": 67, "parent": 66, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00067\" num=\"67\"><claim-text>67. The computer system of claim <b>66</b>, wherein said retirement circuitry is capable of retiring up to four instructions in a processor cycle.</claim-text></claim>"}, {"num": 68, "parent": 65, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00068\" num=\"68\"><claim-text>68. The computer system of claim <b>65</b>, wherein said FIFO buffer is capable of providing four or more instructions to said dispatch circuit in a processor cycle.</claim-text></claim>"}, {"num": 69, "parent": 65, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00069\" num=\"69\"><claim-text>69. The computer system of claim <b>65</b>, wherein said dispatch circuit is capable of dispatching up to four instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 70, "parent": 65, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00070\" num=\"70\"><claim-text>70. The computer system of claim <b>65</b>, wherein said dispatch circuit additionally includes circuitry for issuing said instructions out of program order to said execution unit subject to the availability of said plurality of functional units.</claim-text></claim>"}, {"num": 71, "parent": 65, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00071\" num=\"71\"><claim-text>71. The computer system of claim <b>65</b>, wherein said instruction store is coupled to an external cache that stores instructions to be executed by the microprocessor.</claim-text></claim>"}, {"num": 72, "parent": 65, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00072\" num=\"72\"><claim-text>72. The computer system of claim <b>65</b>, wherein said dispatch circuit concurrently dispatches said instructions by providing a plurality of said buffered instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 73, "parent": -1, "type": "independent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00073\" num=\"73\"><claim-text>73. A computer system, comprising:</claim-text><claim-text>a memory; </claim-text><claim-text>a superscalar microprocessor for executing instructions obtained from an instruction store; and </claim-text><claim-text>a bus coupled between said microprocessor and said memory, wherein said microprocessor comprises: </claim-text><claim-text>a fetch circuit to fetch a plurality of instructions from said instruction store, the plurality of instructions being in program order; </claim-text><claim-text>a first decoder responsive to said fetch circuit; </claim-text><claim-text>a buffer for buffering said plurality of said instructions from said first decoder; </claim-text><claim-text>a second decoder to concurrently decode more than one of said plurality of instructions buffered by said buffer; </claim-text><claim-text>a dispatch circuit to dispatch more than one of said plurality of instructions decoded by said second decoder; and </claim-text><claim-text>an execution unit comprising: </claim-text><claim-text>a plurality of functional units, each of said plurality of functional units executing one of said plurality of instructions dispatched by said dispatch circuit out of the program order, and </claim-text><claim-text>a register file comprising temporary registers to temporarily store out-of-order execution results from said plurality of functional units and a register array to store results from said temporary registers, </claim-text><claim-text>a plurality of data routing paths, and wherein </claim-text><claim-text>said register file communicates with said plurality of functional units via said plurality of data routing paths to supply data to more than one of said functional units and thereby enabling concurrent execution of more than one of said plurality instructions by said plurality of functional units. </claim-text></claim>"}, {"num": 74, "parent": 73, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00074\" num=\"74\"><claim-text>74. The computer system of claim <b>73</b>, further comprising:</claim-text><claim-text>retirement circuitry for causing a plurality of said out-of-order executed instructions to complete in program order; and wherein </claim-text><claim-text>said retirement circuitry causes data values to be transferred from said temporary registers to said register array. </claim-text></claim>"}, {"num": 75, "parent": 74, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00075\" num=\"75\"><claim-text>75. The computer system of claim <b>74</b>, wherein said retirement circuitry is capable of retiring up to four instructions in a processor cycle.</claim-text></claim>"}, {"num": 76, "parent": 73, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00076\" num=\"76\"><claim-text>76. The computer system of claim <b>73</b>, wherein said buffer is capable of providing four or more instructions to said dispatch circuit in a processor cycle.</claim-text></claim>"}, {"num": 77, "parent": 73, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00077\" num=\"77\"><claim-text>77. The computer system of claim <b>73</b>, wherein said dispatch circuit is capable of dispatching up to four instructions to said execution unit in a processor cycle.</claim-text></claim>"}, {"num": 78, "parent": 73, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00078\" num=\"78\"><claim-text>78. The computer system of claim <b>73</b>, wherein said dispatch circuit additionally includes circuitry for issuing said instructions out of program order to said execution unit subject to the availability of said plurality of functional units.</claim-text></claim>"}, {"num": 79, "parent": 73, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00079\" num=\"79\"><claim-text>79. The computer system of claim <b>73</b>, wherein said instruction store is coupled to an external cache that stores instructions to be executed by the microprocessor.</claim-text></claim>"}, {"num": 80, "parent": 73, "type": "dependent", "paragraph_markup": "<claim id=\"US-6272619-B1-CLM-00080\" num=\"80\"><claim-text>80. The computer system of claim <b>73</b>, wherein said dispatch circuit concurrently dispatches said instructions by providing a plurality of said buffered instructions to said execution unit in a processor cycle.</claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES54704716\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><h4>CROSS-REFERENCE TO RELATED APPLICATIONS</h4><p>This is a continuation of application Ser. No. 09/338,563, filed Jun. 23, 1999, now U.S. Pat. No. 6,038,654, which is a continuation of application Ser. No. 08/946,078, filed Oct. 7, 1997, now U.S. Pat. No. 6,092,181, which is a continuation of application Ser. No. 08/602,021, filed Feb. 15, 1996, now U.S. Pat. No. 5,689,720, which is a continuation of application Ser. No. 07/817,810, filed Jan. 8, 1992, now U.S. Pat. No. 5,539,911, which is a continuation of application Ser. No. 07/727,006, filed Jul. 8, 1991, now abandoned.</p><p>The present application is related to the following Applications, all assigned to the Assignee of the present Application:</p><p>1. High-Performance, Superscalar-Based Computer System with Out-Of-Order Instruction Execution and Concurrent Results Distribution, invented by Nguyen et al., application Ser. No. 08/397,016, filed Mar. 1, 1995, now U.S. Pat. No. 5,560,032, which is a continuation of Ser. No. 07/817,809, filed Jan. 8, 1992, now abandoned, which is a continuation of Ser. No. 07/727,058, filed Jul. 8, 1991, now abandoned;</p><p>2. RISC Microprocessor Architecture with Isolated Architectural Dependencies, invented by Nguyen et al., application Ser. No. 08/292,177, filed Aug. 18, 1994, now abandoned, which is a continuation of Ser. No. 07/817,807, filed Jan. 8, 1992, now abandoned, which is a continuation of Ser. No. 07/726,744, filed Jul. 8, 1991, now abandoned;</p><p>3. RISC Microprocessor Architecture Implementing Multiple Typed Register Sets, invented by Garg et al., application Ser. No. 07/726,773, filed Jul. 8, 1991, now U.S. Pat. No. 5,493,687;</p><p>4. RISC Microprocessor Architecture Implementing Fast Trap and Exception State, invented by Nguyen et al., application Ser. No. 08/345,333, filed Nov. 21, 1994, now U.S. Pat. No. 5,481,685, which is a continuation of Ser. No. 08/171,968, filed Dec. 23, 1993, now abandoned which is a continuation of Ser. No. 07/817,811, filed Jan. 8, 1992, now abandoned, which is a continuation of Ser. No. 07/726,942, filed Jul. 8, 1991 now abandoned;</p><p>5. Page Printer Controller Including a Single Chip Superscalar Microprocessor with Graphics Functional Units, invented by Lentz et al., application Ser. No. 08/267,646, filed Jun. 28, 1994, now U.S. Pat. No. 5,394,515, which is a continuation of Ser. No. 07/817,813, filed Jan. 8, 1992, now abandoned, which is a continuation of Ser. No. 07/726,929, filed Jul. 8, 1991, now abandoned; and</p><p>6. Microprocessor Architecture with a Switch Network for Data Transfer between Cache, Memory Port, and IOU, invented by Lentz et al., application Ser. No. 07/726,893, filed Jul. 8, 1991, now U.S. Pat. No. 5,440,752.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention is generally related to the design of RISC type microprocessor architectures and, in particular, to RISC microprocessor architectures that are capable of executing multiple instructions concurrently.</p><p>2. Description of the Related Art</p><p>Recently, the design of microprocessor architectures have matured from the use of Complex Instruction Set Computer (CISC) to simpler Reduced Instruction Set Computer (RISC) Architectures. The CISC architectures are notable for the provision of substantial hardware to implement and support an instruction execution pipeline. The typical conventional pipeline structure includes, in fixed order, instruction fetch, instruction decode, data load, instruction execute and data store stages. A performance advantage is obtained by the concurrent execution of different portions of a set of instructions through the respective stages of the pipeline. The longer the pipeline, the greater the number of execution stages available and the greater number of instructions that can be concurrently executed.</p><p>Two general problems limit the effectiveness of CISC pipeline architectures. The first problem is that conditional branch instructions may not be adequately evaluated until a prior condition code setting instruction has substantially completed execution through the pipeline. Thus, the subsequent execution of the conditional branch instruction is delayed, or stalled, resulting in several pipeline stages remaining inactive for multiple processor cycles. Typically, the condition codes are written to a condition code register, also referred to as a processor status register (PSR), only at completion of processing an instruction through the execution stage. Thus, the pipeline must be stalled with the conditional branch instruction in the decode stage for multiple processor cycles pending determination of the branch condition code. The stalling of the pipeline results in a substantial loss of through-put. Further, the average through-put of the computer will be substantially dependent on the mere frequency of conditional branch instructions occurring closely after the condition code setting instructions in the program instruction stream.</p><p>A second problem arises from the fact that instructions closely occurring in the program instruction stream will tend to reference the same registers of the processor register file. Data registers are often used as the destination or source of data in the store and load stages of successive instructions. In general, an instruction that stores data to the register file must complete processing through at least the execution stage before the load stage processing of a subsequent instruction can be allowed to access the register file. Since the execution of many instructions require multiple processor cycles in the single execution stage to produce store data, the entire pipeline is typically stalled for the duration of an execution stage operation. Consequently, the execution through-put of the computer is substantially dependent on the internal order of the instruction stream being executed.</p><p>A third problem arises not so much from the execution of the instructions themselves, but the maintenance of the hardware supported instruction execution environment, or state-of-the-machine, of the microprocessor itself. Contemporary CISC microprocessor hardware sub-systems can detect the occurrence of trap conditions during the execution of instructions. Traps include hardware interrupts, software traps and exceptions. Each trap requires execution of a corresponding trap handling routines by the processor. On detection of the trap, the execution pipeline must be cleared to allow the immediate execution of the trap handling routine. Simultaneously, the state-of-the-machine must be established as of the precise point of occurrence of the trap; the precise point occurring at the conclusion of the first currently executing instruction for interrupts and traps and immediately prior to an instruction that fails due to a exception. Subsequently, the state-of-the-machine and, again depending on the nature of the trap the executing instruction itself must be restored at the completion of the handling routine. Consequently, with each trap or related event, a latency is introduced by the clearing of the pipeline at both the inception and conclusion of the handling routine and storage and return of the precise state-of-the-machine with corresponding reduction in the through-put of the processor.</p><p>These problems have been variously addressed in an effort to improve the potential through-put of CISC architectures. Assumptions can be made about the proper execution of conditional branch instructions, thereby allowing pipeline execution to tentatively proceed in advance of the final determination of the branch condition code. Assumptions can also be made as to whether a register will be modified, thereby allowing subsequent instructions to also be tentatively executed. Finally, substantial additional hardware can be provided to minimize the occurrence of exceptions that require execution of handling routines and thereby reduce the frequency of exceptions that interrupt the processing of the program instruction stream.</p><p>These solutions, while obviously introducing substantial additional hardware complexities, also introduce distinctive problems of their own. The continued execution of instructions in advance of a final resolution of either a branch condition or register file store access require that the state-of-the-machine be restorable to any of multiple points in the program instruction stream including the location of the conditional branch, each modification of a register file, and for any occurrence of an exception; potentially to a point prior to the fully completed execution of the last several instructions. Consequently, even more supporting hardware is required and, further, must be particularly designed not to significantly increase the cycle time of any pipeline stage.</p><p>RISC architectures have sought to avoid many of the foregoing problems by drastically simplifying the hardware implementation of the microprocessor architecture. In the extreme, each RISC instruction executes in only three pipelined program cycles including a load cycle, an execution cycle, and a store cycle. Through the use of load and store data bypassing, conventional RISC architectures can essentially execute a single instruction per cycle in the three stage pipeline.</p><p>Whenever possible, hardware support in RISC architectures is minimized in favor of software routines for performing the required functions. Consequently, the RISC architecture holds out the hope of substantial flexibility and high speed through the use of a simple load/store instruction set executed by an optimally matched pipeline. And in practice, RISC architectures have been found to benefit from the balance between a short, high-performance pipeline and the need to execute substantially greater numbers of instructions to implement all required functions.</p><p>The design of the RISC architecture generally avoids or minimizes the problems encountered by CISC architectures with regard to branches, register references and exceptions. The pipeline involved in a RISC architecture is short and optimized for speed. The shortness of the pipeline minimizes the consequences of a pipeline stall or clear as well as minimizing the problems in restoring the state-of-the-machine to an earlier execution point.</p><p>However, significant through-put performance gains over the generally realized present levels cannot be readily achieved by the conventional RISC architecture.</p><p>Consequently, alternate, so-called super-scaler architectures, have been variously proposed. These architectures generally attempt to execute multiple instructions concurrently and thereby proportionately increase the through-put of the processor. Unfortunately, such architectures are, again, subject to similar, if not the same conditional branch, register referencing, and exception handling problems as encountered by CISC architectures.</p><h4>SUMMARY OF THE INVENTION</h4><p>Thus, a general purpose of the present invention is to provide a high-performance, RISC based, super-scaler processor architecture capable of substantial performance gains over conventional CISC and RISC architectures and that is further suited for microprocessor implementation.</p><p>This purpose is obtained in the present invention through the provision of a microprocessor architecture capable of the concurrent execution of instructions obtained from an instruction store. The microprocessor architecture includes an instruction prefetch unit for fetching instruction sets from the instruction store. Each instruction set includes a plurality of fixed length instructions. An instruction FIFO is provided for buffering instruction sets in a plurality of instruction set buffers including a first buffer and a second buffer. An instruction execution unit, including a register file and a plurality of functional units, is provided with an instruction control unit capable of examining the instruction sets within the first and second buffers and issuing any of these instructions for execution by available functional units. Multiple data paths between the functional units and the register file allow multiple independent accesses to the register file as necessary for the concurrent execution of the respective instructions.</p><p>The register file includes an additional set of data registers used for the temporary storage of register data. These temporary data registers are utilized by the instruction execution control unit to receive data processed by the functional units in the out-of-order execution of instructions. The data stored in the temporary data registers is selectively held, then cleared or retired to the register file when, and if, the precise state-of-the-machine advances to the instruction's location in the instruction stream; where all prior in-order instructions have been completely executed and retired.</p><p>Finally, the prefetching of instruction sets from the instruction store is facilitated by multiple prefetch paths allowing for prefetching of the main program instruction stream, a target conditional branch instruction stream and a procedural instruction stream. The target conditional branch prefetch path enables both possible instruction streams for a conditional branch instruction, main and target, to be simultaneously prefetched. The procedural instruction prefetch path allows a supplementary instruction stream, effective for allowing execution of an extended procedures implementing a singular instruction found in the main or target instruction streams; the procedural prefetch path enables these extended procedures to be fetched and executed without clearing at least the main prefetch buffers.</p><p>Consequently, an advantage of the present invention is that it provides an architecture that realizes extremely high performance through-put utilizing a fundamentally RISC type core architecture.</p><p>Another advantage of the present invention is that it provides for the execution of multiple instructions per cycle.</p><p>A further advantage of the present invention is that it provides for the dynamic selection and utilization of functional units necessary to optimally execute multiple instructions concurrently.</p><p>Still another advantage-of the present invention is that it provides for a register file unit that integrally incorporates a mechanism for supporting a precise state-of-the-machine return capability.</p><p>Yet another advantage of the present invention is that it incorporates multiple register files within the register file unit that are generalized, typed and capable of multiple register file functions including operation as multiple independent and parallel integer register files, operation of a register file as both a floating point and integer file and operation of a dedicated boolean register file.</p><p>A still further advantage of the present invention is that load and store operations and the handling of exceptions and interrupts can be performed in a precise manner through the use of a precise state-of-the-machine return capability including efficient instruction cancellation mechanisms and a load/store order synchronizer.</p><p>A yet still further advantage of the present invention is the provision for dedicated register file unit support of trap states so as to minimize latency and enhance processing through-put.</p><p>Yet still another advantage of the present invention is the provision for main and target branch instruction prefetch queues whereby even incorrect target branch stream execution ahead minimally impacts the overall processing through-put obtainable by the present invention. Further, the procedural instruction prefetch queue allows an efficient manner of intervening in the execution of the main or target branch instruction streams to allow the effective implementation of new instructions through the execution of procedural routines and, significantly, the externally provided revision of procedural routines implementing built-in procedural instructions.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>These and other advantages and features of the present invention will become better understood upon consideration of the following detailed description of the invention when considered in connection of the accompanying drawings, in which like reference numerals designate like parts throughout the figures thereof, and wherein:</p><p>FIG. 1 is a simplified block diagram of the preferred microprocessor architecture implementing the present invention;</p><p>FIG. 2 is a detailed block diagram of the instruction fetch unit constructed in accordance with the present invention;</p><p>FIG. 3 is a block diagram of the program counter logic unit constructed in accordance with the present invention;</p><p>FIG. 4 is a further detailed block diagram of the program counter data and control path logic;</p><p>FIG. 5 is a simplified block diagram of the instruction execution unit of the present invention;</p><p>FIG. 6A is a simplified block diagram of the register file architecture utilized in a preferred embodiment of the present invention.</p><p>FIG. 6B is a graphic illustration of the storage register format of the temporary buffer register file and utilized in a preferred embodiment of the present invention;</p><p>FIG. 6C is a graphic illustration of the primary and secondary instruction sets as present in the last two stages of the instruction FIFO unit of the present invention;</p><p>FIGS. 7A, <b>7</b>B, and <b>7</b>C provide a graphic illustration of the reconfigurable states of the primary integer register set as provided in accordance with a preferred embodiment of the present invention;</p><p>FIG. 8 is a graphic illustration of a reconfigurable floating point and secondary integer register set as provided in accordance with the preferred embodiment of the present invention;</p><p>FIG. 9 is a graphic illustration of a tertiary boolean register set as provided in a preferred embodiment of the present invention;</p><p>FIG. 10 is a detailed block diagram of the primary integer processing data path portion of the instruction execution unit constructed in accordance with the preferred embodiment of the present invention;</p><p>FIG. 11 is a detailed block diagram of the primary floating point data path portion of the instruction execution unit constructed in accordance with a preferred embodiment of the present invention;</p><p>FIG. 12 is a detailed block diagram of the boolean operation data path portion of the instruction execution unit as constructed in accordance with the preferred embodiment of the present invention;</p><p>FIG. 13 is a detailed block diagram of a load/store unit constructed in accordance with the preferred embodiment of the present invention;</p><p>FIG. 14 is a timing diagram illustrating the preferred sequence of operation of a preferred embodiment of the present invention in executing multiple instructions in accordance with the present invention;</p><p>FIG. 15 is a simplified block diagram of the virtual memory control unit as constructed in accordance with the preferred embodiment of the present invention;</p><p>FIG. 16 is a graphic representation of the virtual memory control algorithm as utilized in a preferred embodiment of the present invention; and</p><p>FIG. 17 is a simplified block diagram of the cache control unit as utilized in a preferred embodiment of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>I. Microprocessor Architectural Overview</p><p>II. Instruction Fetch Unit</p><p>A) IFU Data Path</p><p>B) IFU Control Path</p><p>C) IFU/IEU Control Interface</p><p>D) PC Logic Unit Detail</p><p>1) PF and EXPC Control/Data Unit Detail</p><p>2) PC Control Algorithm Detail</p><p>E) Interrupt and Exception Handling</p><p>1) Overview</p><p>2) Asynchronous Interrupts:</p><p>3) Synchronous Exceptions</p><p>4) Handler Dispatch and Return</p><p>5) Nesting</p><p>6) List of Traps:</p><p>III. Instruction Execution Unit</p><p>A) IEU Data Path Detail</p><p>1) Register File Detail</p><p>2) Integer Data Path Detail</p><p>3) Floating Point Data Path Detail</p><p>4) Boolean Register Data Path Detail</p><p>B) Load/Store Control Unit</p><p>C) IEU Control Path Detail</p><p>1) EDecode Unit Detail</p><p>2) Carry Checker Unit Detail</p><p>3) Data Dependency Checker Unit Detail</p><p>4) Register Rename Unit Detail</p><p>5) Instruction Issuer Unit Detail</p><p>6) Done Control Unit Detail</p><p>7) Retirement Control Unit Detail</p><p>8) Control Flow Control Unit Detail</p><p>9) Bypass Control Unit Detail</p><p>IV. Virtual Memory Control Unit</p><p>V. Cache Control Unit</p><p>VI. Summary/Conclusion</p><p>I. Microprocessor Architectural Overview:</p><p>The architecture <b>100</b> of the present invention is generally shown in FIG. <b>1</b>. An Instruction Fetch Unit (IFU) <b>102</b> and an Instruction Execution Unit (IEU) <b>104</b> are the principal operative elements of the architecture <b>100</b>. A Virtual Memory Unit (VMU) <b>108</b>, Cache Control Unit (CCU) <b>106</b>, and Memory Control Unit (MCU) <b>110</b> are provided to directly support the function of the IFU <b>102</b> and IEU <b>104</b>. A Memory Array Unit (MAU) <b>112</b> is also provided as a generally essential element for the operation of the architecture <b>100</b>, though the MAU <b>112</b> does not directly exist as an integral component of the architecture <b>100</b>. That is, in the preferred embodiments of the present invention, the IFU <b>102</b>, IEU <b>104</b>, VMU <b>108</b>, CCU <b>106</b>, and MCU <b>110</b> are fabricated on a single silicon die utilizing a conventional 0.8 micron design rule low-power CMOS process and comprising some 1,200,000 transistors. The standard processor or system clock speed of the architecture <b>100</b> is 40 MHz. However, in accordance with a preferred embodiment of the present invention, the internal processor clock speed is 160 MHz.</p><p>The IFU <b>102</b> is primarily responsible for the fetching of instructions, the buffering of instructions pending execution by the IEU <b>104</b>, and, generally, the calculation of the next virtual address to be used for the fetching of next instructions.</p><p>In the preferred embodiments of the present invention, instructions are each fixed at a length of 32 bits. Instruction sets, or \u201cbuckets\u201d of four instructions, are fetched by the IFU <b>102</b> simultaneously from an instruction cache <b>132</b> within the CCU <b>106</b> via a 128 bit wide instruction bus <b>114</b>. The transfer of instruction sets is coordinated between the IFU <b>102</b> and CCU <b>106</b> by control signals provided via a control bus <b>116</b>. The virtual address of a instruction set to be fetched is provided by the IFU <b>102</b> via an IFU combined arbitration, control and address bus <b>118</b> onto a shared arbitration, control and address bus-<b>120</b> further coupled between the IEU <b>104</b> and VMU <b>108</b>. Arbitration for access to the VMU <b>108</b> arises from the fact that both the IFU <b>102</b> and IEU <b>104</b> utilize the VMU <b>108</b> as a common, shared resource. In the preferred embodiment of the architecture <b>100</b>, the low order bits defining an address within a physical page of the virtual address are transferred directly by the IFU <b>102</b> to the Cache Control Unit <b>106</b> via the control lines <b>116</b>. The virtualizing, high order bits of the virtual address supplied by the IFU <b>102</b> are provided by the address portion of the buses <b>118</b>, <b>120</b> to the VMU <b>108</b> for translation into a corresponding physical page address. For the IFU <b>102</b>, this physical page address is transferred directly from the VMU <b>108</b> to the Cache Control Unit <b>106</b> via the address control lines <b>122</b> one-half internal processor cycle after the translation request is placed with the VMU <b>108</b>.</p><p>The instruction stream fetched by the IFU <b>102</b> is, in turn, provided via an instruction stream bus <b>124</b> to the IEU <b>104</b>. Control signals are exchanged between the IFU <b>102</b> and the IEU <b>104</b> via controls lines <b>126</b>. In addition, certain instruction fetch addresses, typically those requiring access to the register file present within the IEU <b>104</b>, are provided back to the IFU via a target address return bus within the control lines <b>126</b>.</p><p>The IEU <b>104</b> stores and retrieves data with respect to a data cache <b>134</b> provided within the CCU <b>106</b> via an 80-bit wide bi-directional data bus <b>130</b>. The entire physical address for IEU data accesses is provided via an address portion cf the control bus <b>128</b> to the CCU <b>106</b>. The control bus <b>128</b> also provides for the exchange of control signals between the IEU <b>104</b> and CCU <b>106</b> for managing data transfers. The IEU <b>104</b> utilizes the VMU <b>108</b> as a resource for converting virtual data address into physical data addresses suitable for submission to the CCU <b>106</b>. The virtualizing portion of the data address is provided via the arbitration, control and address bus <b>120</b> to the VMU <b>108</b>. Unlike operation with respect to the IFU <b>102</b>, the VMU <b>108</b> returns the corresponding physical address via the bus <b>120</b> to the IEU <b>104</b>. In the preferred embodiments of the architecture <b>100</b>, the IEU <b>104</b> requires the physical address for use in ensuring that load/store operations occur in proper program stream order.</p><p>The CCU <b>106</b> performs the generally conventional high-level function of determining whether physical address defined requests for data can be satisfied from the instruction and data caches <b>132</b>, <b>134</b>, as appropriate. Where the access request can be properly fulfilled by access to the instruction or data caches <b>132</b>, <b>134</b>, the CCU <b>106</b> coordinates and performs the data transfer via the data buses <b>114</b>, <b>128</b>.</p><p>Where a data access request cannot be satisfied from the instruction or data caches <b>132</b>, <b>134</b>, the CCU <b>106</b> provides the corresponding physical address to the MCU <b>110</b> along with sufficient control information to identify whether a read or write access of the MAU <b>112</b> is desired, the source or destination cache <b>132</b>, <b>134</b> of the CCU <b>106</b> for each request, and additional identifying information to allow the request operation to be correlated with the ultimate data request as issued by the IFU <b>102</b> or IEU <b>104</b>.</p><p>The MCU <b>110</b> preferably includes a port switch unit <b>142</b> that is coupled by a uni-directional data bus <b>136</b> with the instruction cache <b>132</b> of the CCU <b>106</b> and a bi-directional data bus <b>138</b> to the data cache <b>134</b>. The port switch <b>142</b> is, in essence, a large multiplexer allowing a physical address obtained from the control bus <b>140</b> to be routed to any one of a number of ports P<sub>0</sub>-P<sub>N </sub><b>146</b><sub>0-n </sub>and the bi-directional transfer of data from the ports to the data buses <b>136</b>, <b>138</b>. Each memory access request processed by the MCU <b>110</b> is associated with one of the ports <b>146</b><sub>0-n </sub>for purposes of arbitrating for access to the main system memory bus <b>162</b> as required for an access of the MAU <b>112</b>. Once a data transfer connection has been established, the MCU provides control information via the control bus <b>140</b> to the CCU <b>106</b> to initiate the transfer of data between either the instruction or data cache <b>132</b>, <b>134</b> and MAU <b>112</b> via the port switch <b>142</b> and the corresponding one of the ports <b>146</b><sub>0-n</sub>. In accordance with the preferred embodiments of the architecture <b>100</b> the MCU <b>110</b> does not actually store or latch data in transit between the CCU <b>106</b> and MAU <b>112</b>. This is done to minimize latency in the transfer and to obviate the need for tracking or managing data that may be uniquely present in the MCU <b>110</b>.</p><p>II. Instruction Fetch Unit:</p><p>The primary elements of the Instruction Fetch Unit <b>102</b> are shown in FIG. <b>2</b>. The operation and interrelationship of these elements can best be understood by considering their participation in the IFU data and control paths.</p><p>A) IFU Data Path:</p><p>The IFU data path begins with the instruction bus <b>114</b> that receives instruction sets for temporary storage in a prefetch buffer <b>260</b>. An instruction set from the prefetch buffer <b>260</b> is passed through an IDecode unit <b>262</b> and then to an IFIFO unit <b>264</b>. Instruction sets stored in the last two stages of the instruction FIFO <b>264</b> are continuously available, via the data buses <b>278</b>, <b>280</b>, to the IEU <b>104</b>.</p><p>The prefetch buffer unit <b>260</b> receives a single instruction set at a time from the instruction bus <b>114</b>. The full 128 bit wide instruction set is generally written in parallel to one of four 128 bit wide prefetch buffer locations in a Main Buffer (MBUF) <b>188</b> portion of the prefetch buffer <b>260</b>. Up to four additional instruction sets may be similarly written into two 128 bit wide Target Buffer (TBUF) <b>190</b> prefetch buffer locations or to two 128 bit wide Procedural Buffer (EBUF) <b>192</b> prefetch buffer locations. In the preferred architecture <b>100</b>, an instruction set in any one of the prefetch buffer locations within the MBUF <b>188</b>, TBUF <b>190</b> or EBUF <b>192</b> may be transferred to the prefetch buffer output bus <b>196</b>. In addition, a direct fall through instruction set bus <b>194</b> is provided to connect the instruction bus <b>114</b> directly with the prefetch buffer output bus <b>196</b>, thereby bypassing the MBUF, TBUF and EBUF <b>188</b>, <b>190</b>, <b>192</b>.</p><p>In the preferred architecture <b>100</b>, the MBUF <b>188</b> is utilized to buffer instruction sets in the nominal or main instruction stream. The TBUF <b>190</b> is utilized to buffer instruction sets fetched from a tentative target branch instruction stream. Consequently, the prefetch buffer unit <b>260</b> allows both possible instruction streams following a conditional branch instruction to be prefetched. This facility obviates the latency for further accesses to at least the CCU <b>106</b>, if not the substantially greater latency of a MAU <b>112</b>, for obtaining the correct next instruction set for execution following a conditional branch instruction regardless of the particular instruction stream eventually selected upon resolution of the conditional branch instruction. In the preferred architecture <b>100</b> invention, the provision of the MBUF <b>188</b> and TBUF <b>190</b> allow the instruction fetch unit <b>102</b> to prefetch both potential instruction streamns and, as will be discussed below in relationship to the instruction execution unit <b>104</b>, to further allow execution of the presumed correct instruction stream. Where, upon resolution of the conditional branch instruction, the correct instruction stream has been prefetched into the MBUF <b>188</b>, any instruction sets in the TBUF <b>190</b> may be simply invalidated. Alternately, where instruction sets of the correct instruction stream are present in the TBUF <b>190</b>, the instruction prefetch buffer unit <b>260</b> provides for the direct, lateral transfer of those instruction sets from the TBUF <b>190</b> to respective buffer locations in the MBUF <b>188</b>. The prior MBUF <b>188</b> stored instruction sets are effectively invalidated by being overwritten by the TBUF <b>190</b> transferred instruction sets. Where there is no TBUF instruction set transferred to an MBUF location, that location is simply marked invalid.</p><p>Similarly, the EBUF <b>192</b> is provided as another, alternate prefetch path through the prefetch buffer <b>260</b>. The EBUF <b>192</b> is preferably utilized in the prefetching of an alternate instruction stream that is used to implement an operation specified by a single instruction, a \u201cprocedural\u201d instruction, encountered in the MBUF <b>188</b> instruction stream. In this manner, complex or extended instructions can be implemented through software routines, or procedures, and processed through the prefetch buffer unit <b>260</b> without disturbing the instruction streams already prefetched into the MBUF <b>188</b>. Although the present invention generally permits handling of procedural instructions that are first encountered in the TBUF <b>190</b>, prefetching of the procedural instruction stream is held until all prior pending conditional branch instructions are resolved. This allows conditional branch instructions occurring in the procedural instruction stream to be consistently handled through the use of the TBUF <b>190</b>. Thus, where a branch is taken in the procedural stream, the target instruction sets will have been prefetched into the TBUF <b>190</b> and can be simply laterally transferred to the EBUF <b>192</b>.</p><p>Finally, each of the MBUF <b>188</b>, TBUF <b>190</b> and EBUF <b>192</b> are coupled to the prefetch buffer output bus <b>196</b> so as to provide any instruction set stored by the prefetch unit onto the output bus <b>196</b>. In addition, a flow through bus <b>194</b> is provided to directly transfer an instruction set from the instruction bus <b>114</b> directly to the output bus <b>196</b>.</p><p>In the preferred architecture <b>100</b>, the prefetch buffers within the MBUF <b>188</b>, TBUF <b>190</b>, EBUF <b>192</b> do not directly form a FIFO structure. Instead, the provision of an any buffer location to output bus <b>196</b> connectivity allows substantial freedom in the prefetch ordering of instruction sets retrieved from the instruction cache <b>132</b>. That is, the instruction fetch unit <b>102</b> generally determines and requests instruction sets in the appropriate instruction stream order of instructions. However, the order in which instruction sets are returned to the IFU <b>102</b> is allowed to occur out-of-order as appropriate to match the circumstances where some requested instruction sets are available and accessible from the CCU <b>106</b> alone and others require an access of the MAU <b>112</b>.</p><p>Although instruction sets may not be returned in order to the prefetch buffer unit <b>260</b>, the sequence of instruction sets output on the output bus <b>196</b> must generally conform to the order of instruction set requests issued by the IFU <b>102</b>; the in-order instruction stream sequence subject to, for example, tentative execution of a target branch stream.</p><p>The IDecode unit <b>262</b> receives the instruction sets, generally one per cycle, IFIFO unit <b>264</b> space permitting, from the prefetch buffer output bus <b>196</b>. Each set of four instructions that make up a single instruction set is decoded in parallel by the IDecode unit <b>262</b>. While relevant control flow information is extracted via lines <b>318</b> for the benefit of the control path portion of the IFU <b>102</b>, the contents of the instruction set is not altered by the IDecode unit <b>262</b>.</p><p>Instruction sets from the IDecode Unit <b>162</b> are provided onto a 128 bit wide input bus <b>198</b> of the IFIFO unit <b>264</b>. Internally, the IFIFO unit <b>264</b> consists of a sequence of master/slave registers <b>200</b>, <b>204</b>, <b>208</b>, <b>212</b>, <b>216</b>, <b>220</b>, <b>224</b>. Each register is coupled to its successor to allow the contents of the master registers <b>200</b>, <b>208</b>, <b>216</b> to be transferred during a first half internal processor cycle of FIFO operation to the slave registers <b>204</b>, <b>212</b>, <b>220</b> and then to the next successive master register <b>208</b>, <b>216</b>, <b>224</b> during the succeeding half-cycle of operation. The input bus <b>198</b> is connected to the input of each of the master registers <b>200</b>, <b>208</b>, <b>216</b>, <b>224</b> to allow loading of an instruction set from the IDecode unit <b>262</b> directly in to a master register during the second half-cycle of FIFO operation. However, loading of a master register from the input bus <b>198</b> need not occur simultaneously with a FIFO shift of data within the IFIFO unit <b>264</b>. Consequently, the IFIFO unit <b>264</b> can be continuously filled from the input bus <b>198</b> regardless of the current depth of instruction sets stored within the instruction FIFO unit <b>264</b> and, further, independent of the FIFO shifting of data through the IFIFO unit <b>264</b>.</p><p>Each of the master/slave registers <b>200</b>, <b>204</b>, <b>208</b>, <b>212</b>, <b>216</b>, <b>220</b>, <b>224</b>, in addition to providing for the full parallel storage of a 128 bit wide instruction set, also provides for the storage of several bits of control information in the respective control registers <b>202</b>, <b>206</b>, <b>210</b>, <b>214</b>, <b>218</b>, <b>222</b>, <b>226</b>. The preferred set of control bits include exception miss and exception modify, (VMU), no memory (MCU), branch bias, stream, and offset (IFU). This control information originates from the control path portion of the IFU <b>102</b> simultaneous with the loading of an IFIFO master register with a new instruction set from the input bus <b>198</b>. Thereafter, the control register information is shifted in parallel concurrently with the instruction sets through the IFIFO unit <b>264</b>.</p><p>Finally, in the preferred architecture <b>100</b>, the output of instruction sets from the IFIFO unit <b>264</b> is obtained simultaneously from the last two master registers <b>216</b>, <b>224</b> on the I_Bucket<sub>\u2014</sub>0 and I_Bucket<sub>\u2014</sub>1 instruction set output buses <b>278</b>, <b>280</b>. In addition, the corresponding control register information is provided on the IBASV0 and IBASV1 control field buses <b>282</b>, <b>284</b>. These output buses <b>278</b>, <b>282</b>, <b>280</b>, <b>284</b> are all provided as the instruction stream bus <b>124</b> to the IEU <b>104</b>.</p><p>B) IFU Control Path:</p><p>The control path for the IFU <b>102</b> directly supports the operation of the prefetch buffer unit <b>260</b>, IDecode unit <b>262</b> and IFIFO unit <b>264</b>. A prefetch control logic unit <b>266</b> primarily manages the operation of the prefetch buffer unit <b>260</b>. The prefetch control logic unit <b>266</b> and IFU <b>102</b> in general, receives the system clock signal via the clock line <b>290</b> for synchronizing IFU operations with those of the IEU <b>104</b>, CCU <b>106</b> and VMU <b>108</b>. Control signals appropriate for the selection and writing of instruction sets into the MBUF <b>188</b>, TBUF <b>190</b> and EBUF <b>192</b> are provided on the control lines <b>304</b>.</p><p>A number of control signals are provided on the control lines <b>316</b> to the prefetch control logic unit <b>266</b>. Specifically, a fetch request control signal is provided to initiate a prefetch operation. Other control signals provided on the control line <b>316</b> identify the intended destination of the requested prefetch operation as being the MBUF <b>188</b>, TBUF <b>190</b> or EBUF <b>192</b>. In response to a prefetch request, the prefetch control logic unit <b>266</b> generates an ID value and determines whether the prefetch request can be posted to the CCU <b>106</b>. Generation of the ID value is accomplished through the use of a circular four-bit counter.</p><p>The use of a four-bit counter is significant in three regards. The first is that, typically a maximum of nine instruction sets may be active at one time in the prefetch buffer unit <b>260</b>; four instruction sets in the MBUF <b>188</b>, two in the TBUF <b>190</b>, two in the EBUF <b>192</b> and one provided directly to the IDecode unit <b>262</b> via the flow through bus <b>194</b>. Secondly, instruction sets include four instructions of four bytes each. Consequently, the least significant four bits of any address selecting an instruction set for fetching are superfluous. Finally, the prefetch request ID value can be easily associated with a prefetch request by insertion as the least significant four hits of the prefetch request address; thereby reducing the total number of address lines required to interface with the CCU <b>106</b>.</p><p>To allow instruction sets to be returned by the CCU <b>106</b> out-of-order with respect to the sequence of prefetch requests issued by the IFU <b>102</b>, the architecture <b>100</b> provides for the return of the ID request value with the return of instruction sets from the CCU <b>106</b>. However, the out-of-order instruction set return capability may result in exhaustion of the sixteen unique IDs. A combination of conditional instructions executed out-of-order, resulting in additional prefetches and instruction sets requested but not yet returned can lead to potential re-use of an ID value. Therefore, the four-bit counter is preferably held, and no further instruction set prefetch requests issued, where the next ID value would be the same as that associated with an as yet outstanding fetch request or another instruction set then pending in the prefetch buffer <b>260</b>.</p><p>The prefetch control logic unit <b>266</b> directly manages a prefetch status array <b>268</b> which contains status storage locations logically corresponding to each instruction set prefetch buffer location within the MBUF <b>188</b>, TBUF <b>190</b> and EBUF <b>192</b>. The prefetch control logic unit <b>266</b>, via selection and data lines <b>306</b>, can scan, read and write data to the status register array <b>268</b>. Within the array <b>268</b>, a main buffer register <b>308</b> provides for storage of four, four-bit ID values (MB ID), four single-bit reserved flags (MB RES) and four single-bit valid flags (MB VAL), each corresponding by logical bit-position to the respective instruction set storage locations within the MBUF <b>180</b>. Similarly, a target buffer register <b>310</b> and extended buffer register <b>312</b> each provide for the storage of two four-bit ID values (TB ID, EB ID), two single-bit reserved flags (TB RES, EB RES), and two single-bit valid flags (TB VAL, EB VAL). Finally, a flow through status register <b>314</b> provides for the storage of a single four-bit ID value (FT ID), a single reserved flag bit (FT RES), and a single valid flacjbit (FT VAL).</p><p>The status register array <b>268</b> is first scanned and, as appropriate, updated by the prefetch control logic unit <b>266</b> each time a prefetch request is placed with the CCU <b>106</b> and subsequently scanned and updated each time an instruction set is returned. Specifically, upon receipt of the prefetch request signal via the control lines <b>316</b>, the prefetch control logic unit <b>266</b> increments the current circular counter generated ID value, scans the status register array <b>268</b> to determine whether the ID value is available for use and whether a prefetch buffer location of the type specified by the prefetch request signal is available, examines the state of the CCU IBUSY control line <b>300</b> to determine whether the CCU <b>106</b> can accept a prefetch request and, if so, asserts a CCU IREAD control signal on the control line <b>298</b>, and places the incremented ID value on the CCU ID out bus <b>294</b> to the CCU <b>106</b>. A prefetch storage location is available for use where both of the corresponding reserved and valid status flags are false. The prefetch request ID is written into the ID storage location within the status register array <b>268</b> corresponding to the intended storage location within the MBUF <b>188</b>, TBUF <b>190</b>, or EBUF <b>192</b> concurrent with the placement of the request with the CCU <b>106</b>. In addition, the corresponding reserved status flag is set true.</p><p>When the CCU <b>106</b> is able to return a previously requested instruction set to the IFU <b>102</b>, the CCU IREADY signal is asserted on control line <b>302</b> and the corresponding instruction set ID is provided on the CCU ID control lines <b>296</b>. The prefetch control logic unit <b>266</b> scans the ID values and reserved flags within the status register array <b>268</b> to identify the intended destination of the instruction set within the prefetch buffer unit <b>260</b>. Only a single match is possible. Once identified, the instruction set is written via the bus <b>114</b> into the appropriate location within the prefetch buffer unit <b>260</b> or, if identified as a flow -through request, provided directly to the IDecode unit <b>262</b>. In either case, the valid status flag in the corresponding status register array is set true.</p><p>The PC logic unit <b>270</b>, as will be described below in greater detail, tracks the virtual address of the MBUF <b>188</b>, TBUF <b>190</b> and EBUF <b>192</b> instruction streams through the entirety of the IFU <b>102</b>. In performing this function, the PC logic block <b>270</b> both controls and operates from the IDecode unit <b>262</b>. Specifically, portions of the instructions decoded by the IDecode unit <b>262</b> potentially relevant to a change in the program instruction stream flow are provided on the bus <b>318</b> to a control flow detection unit <b>274</b> and directly to the PC logic block <b>270</b>. The control flow detection unit <b>274</b> identifies each instruction in the decoded instruction set that constitutes a control flow instruction including conditional and unconditional branch instructions, call type instructions, software traps procedural instructions and various return instructions. The control flow detection unit <b>274</b> provides a control signal, via lines <b>322</b>, to the PC logic unit <b>270</b> to identify the location and specific nature of the control flow instructions within the instruction set present in the IDecoae unit <b>262</b>. The PC logic unit <b>270</b>, in turn, determines the target address of the control flow instruction, typically from data provided within the instruction and transferred to the PC logic unit via lines <b>318</b>. Where, for example, a branch logic bias has been selected to execute ahead for conditional branch instructions, the PC logic unit <b>270</b> will begin to direct and separately track the prefetching of instruction sets from the conditional branch instruction target address. Thus, with the next assertion of a prefetch request on the control lines <b>316</b>, the PC logic unit <b>270</b> will further assert a control signal, via lines <b>316</b>, selecting the destination of the prefetch to be the TBUF <b>190</b>, assuming that prior prefetch instruction sets were directed to the MBUF <b>188</b> or EBUF <b>192</b>. Once the prefetch control logic unit <b>266</b> determines that a prefetch request can be supplied to the CCU <b>106</b>, the prefetch control logic unit <b>266</b> provides an enabling signal, again via lines <b>316</b>, to the PC logic unit <b>270</b> to enable the provision of a page offset portion of the target address (CCU PADDR [13:4]) via the address lines <b>324</b> directly to the CCU <b>106</b>. At the same time, the PC logic unit <b>270</b>, where a new virtual to physical page translation is required further provides a VMU request signal via control line <b>328</b> and the virtualizing portion of the target address (VMU VADDR [31:14]) via the address lines <b>326</b> to the VMU <b>108</b> for translation into a physical address. Where a page translation is not required, no operation by the VMU <b>108</b> is required. Rather, the previous translation result is maintained in an output latch coupled to the bus <b>122</b> for immediate use by the CCU <b>106</b>.</p><p>Operational errors in the VMU <b>108</b> in performing the virtual to physical translation requested by the PC logic unit <b>270</b> are reported via the VMU exception and VMU miss control lines <b>332</b>, <b>334</b>. The VMU miss control line <b>334</b> reports a translation lookaside buffer (TLB) miss. The VMU exception control signal, on VMU exception line <b>332</b>, is raised for all other exceptions. In both cases, the PC logic unit handles the error condition by storing the current execution point in the instruction stream and then prefetching, as if in response to an unconditional branch, a dedicated exception handling routine instruction stream for diagnosing and handling the error condition. The VMU exception and miss control signals identify the general nature of the exception encountered, thereby allowing the PC logic unit <b>270</b> to identify the prefetch address of a corresponding exception handling routine.</p><p>The IFIFO control logic unit <b>272</b> is provided to directly support the IFIFO unit <b>264</b>. Specifically, the PC logic unit <b>270</b> provides a control signal via the control lines <b>336</b> to signal the IFIFO control logic unit <b>272</b> that an instruction set is available on the input bus <b>198</b> from the IDecode unit <b>262</b>. The IFIFO control unit <b>272</b> is responsible for selecting the deepest available master register <b>200</b>, <b>208</b>, <b>216</b>, <b>224</b> for receipt of the instruction set. The output of each of the master control registers <b>202</b>, <b>210</b>, <b>218</b>, <b>226</b> is provided to the IFIFO control unit <b>272</b> via the control bus <b>338</b>. The control bits stored by each master control register includes a two-bit buffer address (IF_Bx_ADR), a single stream indicator bit (IF_Bx_STRM), and a single valid bit (IF_Bx_VLD). The two bit buffer address identifies the first valid instruction within the corresponding instruction set. That is, instruction sets returned by the CCU <b>106</b> may not be aligned such that the target instruction of a branch operation, for example, is located in the initial instruction location within the instruction set. Thus, the buffer address value is provided to uniquely identify the initial instruction within an instruction set that is to be considered for execution.</p><p>The stream bit is used essentially as a marker to identify the location of instruction sets containing conditional control flow instructions, and giving rise to potential control flow changes, in the stream of instructions through the IFIFO unit <b>264</b>. The main instruction stream is processed through the MBUF <b>188</b> generally with a stream bit value of 0. On the occurrence of a relative conditional branch instruction, for example, the corresponding instruction set is marked with a stream bit value of 1. The conditional branch instruction is detected by the IDecode unit <b>262</b>. Up to four conditional control flow instructions may be present in the instruction set. The instruction set is then stored in the deepest available master register of the IFIFO unit <b>264</b>.</p><p>In order to determine the target address of the conditional branch instruction, the current IEU <b>104</b> execution point address (DPC), the relative location of the conditional instruction containing instruction set as identified by the stream bit, and the conditional instruction location offset in the instruction set, as provided by the control flow detector <b>274</b>, are combined with the relative branch offset value as obtained from a corresponding branch instruction field via control lines <b>318</b>. The result is a branch target virtual address that is stored by the PC logic unit <b>270</b>. The initial instruction sets of the target instruction stream may then be prefetched into the TBUF <b>190</b> utilizing this address.</p><p>Depending on the preselected branch bias selected for the PC logic unit <b>270</b>, the IFIFO unit <b>264</b> will continue to be loaded from either the MBUF <b>188</b> or TBUF <b>190</b>. If a second instruction set containing one or more conditional flow instructions is encountered, the instruction set is marked with a stream bit value of 0. Since a second target stream cannot be fetched, the target address is calculated and stored by the PC logic unit <b>270</b>, but no prefetch is performed. In addition, no further instruction sets can be processed through the IDecode unit <b>262</b>, or at least none that are found to contain a conditional flow control instruction.</p><p>The PC logic unit <b>270</b>, in the preferred embodiments of the present invention, can manage up to eight conditional flow instructions occurring in up to two instruction sets. The target addresses for each of the two instruction sets marked by stream bit changes are stored in an array of four address registers with each target address positioned logically with respect to the location of the corresponding conditional flow instruction in the instruction set.</p><p>Once the branch result of the first in-order conditional flow instruction is resolved, the PC logic unit <b>270</b> will direct the prefetch control unit <b>260</b>, via control signals on lines <b>316</b>, to transfer the contents of the TBUF <b>190</b> to the MBUF <b>188</b>, if the branch is taken, and to mark invalid the contents of the TBUF <b>190</b>. Any instruction sets in the IFIFO unit <b>264</b> from the incorrect instruction stream, target stream if the branch is not taken and main stream if the branch is taken, are cleared from the IFIFO unit <b>264</b>. If a second or subsequent conditional flow control instruction exists in the first stream bit marked instruction set, that instruction is handled in a consistent manner: the instruction sets from the target stream are prefetched, instruction sets from the MBUF <b>188</b> or TBUF <b>190</b> are processed through the IDecode unit <b>262</b> depending on the branch bias, and the IFIFO unit <b>264</b> is cleared of incorrect stream instruction sets when the conditional flow instruction finally resolves.</p><p>If a secondary conditional flow instruction set remains in the IFIFO unit <b>264</b> once the IFIFO unit <b>264</b> is cleared of incorrect stream instruction sets, and the first conditional flow instruction set contains no further conditional flow instructions, the target addresses of the second stream bit marked instruction set are promoted to the first array of address registers. In any case, a next instruction set containing conditional flow instructions can then be evaluated through the IDecode unit <b>262</b>. Thus, the toggle usage of the stream bit allows potential control flow changes to be marked and tracked through the IFIFO unit <b>264</b> for purposes of calculating branch target addresses and for marking the instruction set location above which to clear where the branch bias is subsequently determined to have been incorrect for a particular conditional flow control instruction.</p><p>Rather than actually clearing instruction sets from the master registers, the IFIFO control logic unit <b>272</b> simply resets the valid bit flag in the control registers of the corresponding master registers of the IFIFO unit <b>264</b>. The clear operation is instigated by the PC logic unit <b>270</b> in a control signal provided on lines <b>336</b>. The inputs of each of the master control registers <b>202</b>, <b>210</b>, <b>218</b>, <b>226</b> are directly accessible by the IFIFO control logic unit <b>272</b> via the status bus <b>230</b>. In the preferred architecture <b>100</b>, the bits within these master control registers <b>202</b>, <b>210</b>, <b>218</b>, <b>226</b> may be set by the IFIFO control unit <b>272</b> concurrent with or independent of a data shift operation by the IFIFO unit <b>264</b>. This capability allows an instruction set to be written into any of the master registers <b>200</b>, <b>208</b>, <b>216</b>, <b>224</b>, and the corresponding status information to be written into the master control registers <b>202</b>, <b>210</b>, <b>218</b>, <b>226</b> asynchronously with respect to the operation of the IEU <b>104</b>.</p><p>Finally, an additional control line on the control and status bus <b>230</b> enables and directs the FIFO operation of the IFIFO unit <b>264</b>. An IFIFO shift is performed by the IFIFO control logic unit <b>272</b> in response to the shift request control signal provided by the PC logic unit <b>270</b> via the control lines <b>336</b>. The IFIFO control unit <b>272</b>, based on the availability of a master register <b>200</b>, <b>208</b>, <b>216</b>, <b>224</b> to receive an instruction set provides a control signal, via lines <b>316</b>, to the prefetch control unit <b>266</b> to request the transfer of a next appropriate instruction set from the prefetch buffers <b>260</b>. On transfer of the instruction set, the corresponding valid bit in the array <b>268</b> is reset.</p><p>C) IFU/IEU Control Interface:</p><p>The control interface between the IFU <b>102</b> and IEU <b>104</b> is provided by the control bus <b>126</b>. This control bus <b>126</b> is coupled to the PC logic unit <b>270</b> and consists of a number of control, address and specialized data lines. Interrupt request and acknowledge control signals, as passed via the control lines <b>340</b>, allow the IFU <b>102</b> to signal and synchronize interrupt operations with the IEU <b>104</b>. An externally generated interrupt signal is provided on a line <b>292</b> to the logic unit <b>270</b>. In response, an interrupt request control signal, provided on lines <b>340</b>, causes the IEU <b>104</b> to cancel tentatively executed instructions. Information regarding the nature of an interrupt is exchanged via interrupt information lines <b>341</b>. When the IEU <b>104</b> is ready to begin receiving instruction sets prefetched from the interrupt service routine address determined by the PC logic unit, <b>270</b>, the IEU <b>104</b> asserts an interrupt acknowledge control signal on the lines <b>340</b>. Execution of the interrupt service routine, as prefetched by the IFU <b>102</b>, will then commence.</p><p>An IFIFO read (IFIFO RD) control signal is provided by the IEU <b>104</b> to signal that the instruction set present in the deepest master register <b>224</b> has been completely executed and that a next instruction set is desired. Upon receipt of this control signal, the PC logic unit <b>270</b> directs the IFIFO control logic unit <b>272</b> to perform a IFIFO shift operation on the IFIFO unit <b>264</b>.</p><p>A PC increment request and size value (PC INC/SIZE) is provided on the control lines <b>344</b> to direct the PC logic unit <b>270</b> to update the current program counter value by a corresponding size number of instructions. This allows the PC logic unit <b>270</b> to maintain a point of execution program counter (DPC) that is precise to the location of the first in-order executing instruction in the current program instruction stream.</p><p>A target address (TARGET ADDR) is returned on the address lines <b>346</b> to the PC logic unit <b>270</b>. The target address is the virtual target address of a branch instruction that depends on data stored within the register file of the IEU <b>104</b>. Operation of the IEU <b>104</b> is therefore required to calculate the target address.</p><p>Control flow result (CF RESULT) control signals are provided on the control lines <b>348</b> to the PC logic unit <b>270</b> to identify whether any currently pending conditional branch instruction has been resolved and whether the result is either a branch taken or not taken. Based on these control signals, the PC logic unit <b>270</b> can determine which of the instruction sets in the prefetch buffer <b>260</b> and IFIFO unit <b>264</b> must be cancelled, if at all, as a consequence of the execution of the conditional flow instruction.</p><p>A number of IEU instruction return type control signals (IEU Return) are provided on the control lines <b>350</b> to alert the IFU <b>102</b> to the execution of certain instructions by the IEU <b>104</b>. These instructions include a return from procedural instruction, return from trap, and return from subroutine call. The return from trap instruction is used equally in hardware interrupt and software trap handling routines. The subroutine call return is also used in conjunction with jump-and-link type calls. In each case, the return control signals are provided to alert the IFU <b>102</b> to resume its instruction fetching operation with respect to the previously interrupted instruction stream. Origination of the signals from the IEU <b>104</b> allows the precise operation of the system <b>100</b> to be maintained; the resumption of an \u201cinterrupted\u201d instruction strean is performed at the point of execution of the return instruction.</p><p>A current instruction execution PC address (Current IF_PC) is provided on an address bus <b>352</b> to the IEU <b>104</b> This address value, the DPC, identifies the precise instruction being executed by the IEU <b>104</b>. That is, while the IEU <b>104</b> may tentatively execute ahead instructions past the current IF_PC address, this address must be maintained for purposes of precise control of the architecture <b>100</b> with respect to the occurrence of interrupts, exceptions, and any other events that would require knowing the precise state-of-the-machine. When the IEU <b>104</b> determines that the precise state-of-the-machine in the currently executing instruction stream can be advanced, the PC Inc/Size signal is provided to the IFU <b>102</b> and immediately reflected back in the current IF_PC address value.</p><p>Finally, an address and bi-directional data bus <b>354</b> is provided for the transfer of special register data. This data may be programmed into or read from special registers within the IFU <b>102</b> by the IEU <b>104</b>. Special register data is generally loaded or calculated by the IEU <b>104</b> for use by the IFU <b>102</b>.</p><p>D) PC Logic Unit Detail:</p><p>A detailed diagram of the PC Logic unit <b>270</b> including a PC control unit <b>362</b>, interrupt control unit <b>363</b>, prefetch PC control unit <b>364</b> and execution PC control unit <b>366</b>, is shown in FIG. <b>3</b>. The PC control unit <b>362</b> provides timing control over the prefetch and execution PC control units <b>364</b>, <b>366</b> in response to control signals from the prefetch control logic unit <b>266</b>, IFIFO control logic unit <b>272</b>, and the IEU <b>104</b>, via the interface bus <b>126</b>. The Interrupt Control Unit <b>363</b> is responsible for managing the precise processing of interrupts and exceptions, including the determination of a prefetch trap address offset that selects an appropriate handling routine to process a respective type of trap. The prefetch PC control unit <b>364</b> is, in particular, responsible for managing program counters necessary to support the prefetch buffers <b>188</b>, <b>190</b>, <b>192</b>, including storing return addresses for traps handling and procedural routine instruction flows. In support of this operation, the prefetch PC control unit <b>364</b> is responsible for generating the prefetch virtual address including the CCU PADDR address on the physical address bus lines <b>324</b> and the VMU VMADDR address on the address lines <b>326</b>. Consequently, the prefetch PC control unit <b>364</b> is responsible for maintaining the current prefetch PC virtual address value.</p><p>The prefetch operation is generally initiated by the IFIFO control logic unit <b>272</b> via a control signal provided on the control lines <b>316</b>. In response, the PC control unit <b>362</b> generates a number of control signals provided on the control lines <b>372</b> to operate the prefetch PC control unit <b>364</b> to generate the PADDR and, as needed, the VMADDR addresses on the address lines <b>324</b>, <b>326</b>. An increment signal, having a value of 0 to four, may be also provided on the control lines <b>374</b> depending on whether the PC control unit <b>362</b> is re-executing an instruction set fetch at the present prefetch address, aligning for the second in a series of prefetch requests, or selecting the next full sequential instruction set for prefetch. Finally, the current prefetch address PF_PC is provided on the bus <b>370</b> to the execution PC control unit <b>366</b>.</p><p>New prefetch addresses originate from a number of sources. A primary source of addresses is the current IF_PC address provided from the execution PC control unit <b>366</b> via bus <b>352</b>. Principally, the IF_PC address provides a return address for subsequent use by the prefetch PC control unit <b>364</b> when an initial call, trap or procedural instruction occurs. The IF_PC address is stored in registers in the prefetch PC control unit <b>364</b> upon each occurrence of these instructions. In this manner, the PC control unit <b>362</b>, on receipt of a IEU return signal, via control lines <b>350</b>, need merely select the corresponding return address register within the prefetch PC control unit <b>364</b> to source a new prefetch virtual address, thereby resuming the original program instruction stream.</p><p>Another source of prefetch addresses is the target address value provided on the relative target address bus <b>382</b> from the execution PC control unit <b>366</b> or on the absolute target address bus <b>346</b> provided from the IEU <b>104</b>. Relative target addresses are those that can be calculated by the execution PC control unit <b>366</b> directly. Absolute target addresses must be generated by the IEU <b>104</b>, since such target addresses are dependant on data contained in the IEU register file. The target address is routed over the target address bus <b>384</b> to the prefetch PC control unit <b>364</b> for use as a prefetch virtual address. In calculating the relative target address, an operand portion of the corresponding branch instruction is also provided on the operand displacement portion of the bus <b>318</b> from the IDecode unit <b>262</b>.</p><p>Another source of prefetch virtual addresses is the execution PC control unit <b>366</b>. A return address bus <b>352</b>\u2032 is provided to transfer the current IF_PC value (DPC) to the prefetch PC control unit <b>364</b>. This address is utilized as a return address where an interrupt, trap or other control flow instruction such as a call has occurred within the instruction stream. The prefetch PC control unit <b>364</b> is then free to prefetch a new instruction stream. The PC control unit <b>362</b> receives an IEU return signal, via lines <b>350</b>, from the IEU <b>104</b> once the corresponding interrupt or trap handling routine or subroutine has been executed. In turn, the PC control unit <b>362</b> selects, via one of the PFPC control signals on line <b>372</b> and based on an identification of the return instruction executed as provided via lines <b>350</b>, a register containing the current return virtual address. This address is then used to continue the prefetch operation by the PC logic unit <b>270</b>.</p><p>Finally, another source of prefetch virtual addresses is from the special register address and data bus <b>354</b>. An address value, or at least a base address value, calculated or loaded by the IEU <b>104</b> is transferred as data via the bus <b>354</b> to the prefetch PC control unit <b>364</b>. The base addresses include the base addresses for the trap address table, a fast trap table, and a base procedural instruction dispatch table. The bus <b>354</b> also allows many of the registers in the prefetch and execution PC control units <b>364</b>, <b>366</b> to be read to allow corresponding aspects of the state-of-the-machine to be manipulated through the IEU <b>104</b>.</p><p>The execution PC control unit <b>366</b>, subject to the control of the PC control unit <b>362</b> is primarily responsible for calculating the current IF_PC address value. In this role, the execution PC control unit <b>366</b> responds to control signals provided by the PC control unit <b>362</b> on the EXPC control lines <b>378</b> and increment/size control signals provided on the control lines <b>380</b> to adjust the IF_PC address. These control signals are generated primarily in response to the IFIFO read control signal provided on line <b>342</b> and the PC increment/size value provided on the control lines <b>344</b> from the IEU <b>104</b>.</p><p>1) PF and ExPC Control/Data Unit Detail;</p><p>FIG. 4 provides a detailed block diagram of the prefetch and execution PC control units <b>364</b>, <b>366</b>. These units primarily consist of registers, incrementors and the like, selectors and adder blocks. Control for managing the transfer of data between these blocks is provided by the PC Control Unit <b>362</b> via the PFPC control lines <b>372</b>, the ExPC control lines <b>378</b> and the Increment Control lines <b>374</b>, <b>380</b>. For purposes of clarity, those specific control lines are not shown in the block diagram of FIG. <b>4</b>. However, it should be understood that these control signals are provided to the blocks shown as described herein.</p><p>Central to the prefetch PC control unit <b>364</b> is a prefetch selector (PF_PC SEL) <b>390</b> that operates as a central selector of the current prefetch virtual address. This current prefetch address is provided on the output bus <b>392</b> from the prefetch selector to an incrementor unit <b>394</b> to generate a next prefetch address. This next prefetch address is provided on the incrementor output bus <b>396</b> to a parallel array of registers MBUF PFnPC <b>398</b>, TBUF PFnPC <b>400</b>, and EBUF PFnPC <b>402</b>. These registers <b>398</b>, <b>400</b>, <b>402</b> effectively store the next instruction prefetch address. However, in accordance with the preferred embodiment of the present invention, separate prefetch addresses are held for the MBUF <b>188</b>, TBUF <b>190</b>, and EBUF <b>192</b>. The prefetch addresses, as stored by the MBUF, TBUF and EBUF PFnPC registers <b>398</b>, <b>400</b>, <b>402</b> are respectively provided by the address buses <b>404</b>, <b>408</b>, <b>410</b> to the prefetch selector <b>390</b>. Thus, the PC control unit <b>362</b> can direct an immediate switch of the prefetch instruction stream merely by directing the selection, by the prefetch selector <b>390</b>, of another one of the prefetch registers <b>398</b>, <b>400</b>, <b>402</b>., Once that address value has been incremented by the incrementor <b>394</b>, if a next instruction set in the stream is to be prefetched, the value is returned to the appropriate one of the prefetch registers <b>398</b>, <b>400</b>, <b>402</b>. Another parallel array of registers, for simplicity shown as the single special register block <b>412</b>, is provided to store a number of special addresses. The register block <b>412</b> includes a trap return address register, a procedural instruction return address register, a procedural instruction dispatch table base address register, a trap routine dispatch table base address register, and a fast trap routine table base address register. Under the control of the PC control unit <b>362</b>, these return address registers may receive the current IF_PC execution address via the bus <b>352</b>\u2032. The address values stored by the return and base address registers within the register block <b>412</b> may be both read and written independently by the IEU <b>104</b>. The register are selected and values transferred via the special register address and data bus <b>354</b>.</p><p>A selector within the special register block <b>412</b>, controlled by the PC control unit <b>362</b>, allows the addresses stored by the registers of the register block <b>412</b> to be put on the special register output bus <b>416</b> to the prefetch selector <b>390</b>. Return addresses are provided directly to the prefetch selector <b>390</b>. Base address values are combined with the offset value provided on the interrupt offset bus <b>373</b> from the interrupt control unit <b>363</b>. Once sourced to the prefetch selector <b>390</b> via the bus <b>373</b>\u2032, a special address can be used as the initial address for a new prefetch instruction stream by thereafter continuing the incremental loop of the address through the incrementor <b>394</b> and one of the prefetch registers <b>398</b>, <b>400</b>, <b>402</b>.</p><p>Another source of addresses to the prefetch selector <b>390</b> is an array of registers within the target address register block <b>414</b>. The target registers within the block <b>414</b> provide for storage of, in the preferred embodiment, eight potential branch target addresses. These eight storage locations logically correspond to the eight potentially executable instructions held in the lowest two master registers <b>216</b>, <b>224</b> of the IFIFO unit <b>264</b>. Since any, and potentially all of the those instructions could be conditional branch instructions, the target register block <b>414</b> allows for their precalculated target addresses to be stored awaiting use for fetching of a target instruction stream through the TBUF <b>190</b>. In particular, if a conditional branch bias is set such that the PC Control Unit <b>362</b> immediately begins prefetching of a target instruction stream, the target address is immediately fed through the target register block <b>414</b> via the address bus <b>418</b> to the prefetch selector <b>390</b>. Once incremented by the incrementor <b>394</b>, the address is stored back to the TBUF PFnPC <b>400</b> for use in subsequent prefetch operations of the target instruction stream. If additional branch instructions occur within the target instruction stream, the target addresses of such secondary branches are calculated and stored in the target register array <b>414</b> pending use upon resolution of the first conditional branch instruction.</p><p>A calculated target address as stored by the target register block <b>414</b>, is transferred from a target address calculation unit within the execution PC control unit <b>366</b> via the address lines <b>382</b> or from the IEU <b>104</b> via the absolute target address bus <b>346</b>.</p><p>The Address value transferred through the prefetch PF_PC selector <b>390</b> is a full thirty-two bit virtual address value, The page size, in the preferred embodiment of the present invention is fixed at 16 KBytes, corresponding to the maximum page offset address value [13:0]. Therefore, a VMU page translation is not required unless there is a change in the current prefetch virtual page address [27:14]. A comparator in the prefetch selector <b>390</b> detects this circumstance. A VMU translation request signal (VMXLAT) is provided via line <b>372</b>\u2032 to the PC control unit <b>362</b> when there is a change in the virtual page address, either due incrementing across a page boundary or a control flow branch to another page address. In turn, the PC control unit <b>362</b> directs the placement of the VMU VMADDR address on lines <b>326</b>, in addition to the CCU PADDR on lines <b>324</b>, both via a buffer unit <b>420</b>, and the appropriate control signals on the VMU control lines <b>326</b>, <b>328</b>, <b>330</b> to obtain a VMU virtual to physical page translation. Where a page translation is not required, the current physical page address [31:14] is maintained by a latch at the output of the VMU unit <b>108</b> on the bus <b>122</b>.</p><p>The virtual address provided onto the bus <b>370</b> is incremented by the incrementor <b>394</b> in response to a signal provided on the increment control line <b>374</b>. The incrementor <b>394</b> increments by a value representing an instruction set (four instructions or sixteen bytes) in order to select a next instruction set. The low-order four bits of a prefetch address as provided to the CCU unit <b>106</b> are zero. Therefore the actual target address instruction in a first branch target instruction set may not be located in the first instruction location. However, the low-order four bits of the address are provided to the PC control unit <b>362</b> to allow the proper first branch instruction location to be known by the IFU <b>102</b>. The detection and handling, by returning :the low order bits [3:2] of a target address as the: two-bit buffer address, to select the proper first instruction for execution in a non-aligned target instruction set, is performed only for the first prefetch of a new instruction stream, i.e., any first non-sequential instruction set address in an instruction stream. The non-aligned relationship between the address of the first instruction in an instruction set and the prefetch address used in prefetching the instruction set can and is thereafter ignored for the duration of the current sequential instruction stream.</p><p>The remainder of the functional blocks shown in FIG. 4 comprise the execution PC control unit <b>366</b>. In accordance with the preferred embodiment of the present invention, the execution PC control unit <b>366</b> incorporates its own independently functioning program counter incrementor. Central to this function is an execution selector (DPC SEL) <b>430</b>. The address output by the execution selector <b>430</b>, on the address bus <b>352</b>\u2032, is the present execution address (DPC) of the architecture <b>100</b>. This execution address is provided to an adder unit <b>434</b>. The increment/size control signals provided on the lines <b>380</b> specify an instruction increment value of from one to four that the adder unit <b>434</b> adds to the address obtained from the selector <b>430</b>. As the adder <b>432</b> additionally performs an output latch function, the incremented next execution address is provided on the address lines <b>436</b> directly back to the execution selector <b>430</b> for use in the next execution increment cycle.</p><p>The initial execution address and all subsequent new stream addresses are obtained through a new stream register unit <b>438</b> via the address lines <b>440</b>. The new stream register unit <b>438</b> allows the new current prefetch address, as provided on the PFPC address bus <b>370</b> from the prefetch selector <b>390</b> to be passed on to the address bus <b>440</b> directly or stored for subsequent use. That is, where the prefetch PC control unit <b>364</b> determines to begin prefetching at a new virtual address, the new stream address is temporarily stored by the new stream register unit <b>438</b>. The PC control unit <b>362</b>, by its participation in both the prefetch and execution increment cycles, holds the new stream address in the new stream register <b>438</b> unit until the execution address has reached the program execution point corresponding to the control flow instruction that instigated the new instruction stream. The new stream address is then output from the new stream register unit <b>438</b> to the execution selector <b>430</b> to initiate the independent generation of execution addresses in the new instruction stream.</p><p>In accordance with the preferred embodiments of the present invention, the new stream register unit <b>438</b> provides for the buffering of two control flow instruction target addresses. By the immediate availability of the new stream address, there is essentially no latency in the switching of the execution PC control unit <b>366</b> from the generation of a current sequence of execution addresses to a new stream sequence of execution addresses.</p><p>Finally, an IF_PC selector (IF_PC SEL) <b>442</b> is provided to ultimately issue the current IF_PC address on the address bus <b>352</b> to the IEU <b>104</b>. The inputs to the IF_PC selector <b>442</b> are the output addresses obtained from either the execution selector <b>430</b> or new stream register unit <b>438</b>. In most instances, the IF_PC selector <b>442</b> is directed by the PC control unit <b>362</b> to select the execution address output by the execution selector <b>430</b>. However, in order to further reduce latency in switching to a new virtual address used to initiate execution of a new instruction stream, the selected address provided from the new stream register unit <b>438</b> can be bypassed via bus <b>440</b> directly to the IF_PC selector <b>442</b> for provision as the current IF_PC execution address.</p><p>The execution PC control unit <b>366</b> is capable of calculating all relative branch target addresses. The current execution point address and the new stream register unit <b>438</b> provided address are received by a control flow selector (CF_PC) <b>446</b>\u2014via the address buses <b>352</b>\u2032, <b>440</b>. Consequently, the PC control unit <b>362</b> has substantial flexibility in selecting the exact initial address from which to calculate a target address. This initial, or base, address is provided via address bus <b>454</b> to a target address ALU <b>450</b>. A second input value to the target ALU <b>450</b> is provided from a control flow displacement calculation unit <b>452</b> via bus <b>458</b>. Relative branch instructions, in accordance with the preferred architecture <b>100</b>, incorporate a displacement value in the form of an immediate mode constant that specifies a relative new target address. The control flow displacement calculation unit <b>452</b> receives the operand displacement value initially obtained via the IDecode unit operand output bus <b>318</b>. Finally, an offset register value is provided to the target address ALU <b>450</b> via the lines <b>456</b>. The offset register <b>448</b> receives an offset value via the control lines <b>378</b>\u2032 from the PC control unit <b>362</b>. The magnitude of the offset value is determined by the PC control unit <b>362</b> based on the address offset between the base address provided on the address lines <b>454</b> and the address of the current branch instruction for which the relative target address is being calculated. That is, the PC control unit <b>362</b>, through its control of the IFIFO control logic unit <b>272</b> tracks the number of instructions separating the instruction at the current execution point address (requested by CP_PC) and the instruction that is currently being processed by the IDecode unit <b>262</b> and, therefore, being processed by the PC logic unit <b>270</b> to determine the target address for that instruction.</p><p>Once the relative target address has been calculated by the target address ALU <b>450</b>, the target address is written into a corresponding one of the target registers <b>414</b> via the address bus <b>382</b>.</p><p>2) PC Control Algorithm Detail:</p><p>1. Main Instruction Stream Processing: MBUF PFnPC</p><p>1.1 the address of the next main flow prefetch instruction is stored in the MBUF PFNPC.</p><p>1.2 in the absence of a control flow instruction, a 32 bit incrementor adjusts the address value in the MBUF PFnPC by sixteen bytes (\u00d716) with each prefetch cycle.</p><p>1.3 when an unconditional control flow instruction is IDecoded, all prefetched data fetched subsequent to the instruction set will be flushed and the MBUF PFnPC is loaded, through the target register unit, PF_PC selector and incrementor, with the new main instruction stream address. The new address is also stored in the new stream registers.</p><p>1.3.1 the target address of a relative unconditional control flow is calculated by the IFU from register data maintained by the IFU and from operand data following the control flow instruction.</p><p>1.3.2 the target address of an absolute unconditional control flow instruction is eventually calculated by the IEU from a register reference, a base register value, and an index register value.</p><p>1.3.2.1 instruction prefetch cycling stalls until the target address is returned by the IEU for absolute address control flow instruction; instruction execution cycling continues.</p><p>1.4 the address of the next main flow prefetch instruction set, resulting from an unconditional control flow instruction, is bypassed through the target address register unit, PF_PC selector and incrementor and routed for eventual storage in the MBUF PFnPC; prefetching continues at 1.2.</p><p>2. Procedural Instruction Stream Processing: EBUF PFnPC</p><p>2.1 a procedural instruction may be prefetched in the main or branch target instruction stream. If fetched in a target stream, stall prefetching of the procedural stream until the conditional control flow instruction resolves and the procedural instruction is transferred to the MBUF. This allows the TBUF to be used in handling of conditional control flows that occur in the procedural instruction stream.</p><p>2.1.1 a procedural instruction should not appear in a procedural instruction stream, i.e., procedural instructions should not be nested: a return from procedural instruction will return execution to the main instruction flow. In order to allow nesting, an additional, dedicated return from nested procedural instruction would be required. While the architecture can readily support such an instruction, the need for a nested procedural instruction capability will not likely improve the performance of the architecture.</p><p>2.1.2 in a main instruction strean, a procedural instruction stream that, in turn, includes first and second conditional control flow instruction containing instruction sets will stall prefetching with respect to the second conditional control flow instruction set until any conditional control flow instructions in the first such instruction set are resolved and the second conditional control flow instruction set has been transferred to the MBUF.</p><p>2.2 procedural instructions provide a relative offset, included as an immediate mode operand field of the instruction, to identify the procedural routine starting address:</p><p>2.2.1 the offset value provided by the procedural instruction is combined with a value contained in a procedural base address (PBR) register maintained in the IFU. This PBR register is readable and writable via the special address and data bus in response to the execution of a special register move instruction.</p><p>2.3 when a procedural instruction is encountered, the next main instruction stream IF_PC address is stored in the uPC return address register and the procedure-in-progress bit in the processor status register (PSR) is set.</p><p>2.4 the starting address of the procedural stream is routed from the PBR register (plus the procedural instruction operand offset value) to the PF_PC selector.</p><p>2.5 the starting address of the procedural stream is simultaneously provided to the new stream register unit and to the incrementor for incrementing (\u00d716); the incremented address is then stored in the EBUF PFnPC.</p><p>2.6 in the absence of a control flow instruction, a 32 bit incrementor adjusts address value (\u00d716) in the EBUF PFnPC with each procedural instruction prefetch cycle.</p><p>2.7 when an unconditional control flow instruction is IDecoded, all prefetched data fetched subsequent to the branch instruction will be flushed and the EBUF PFnPC is loaded with the new procedural instruction stream address.</p><p>2.7.1 the target address of a relative unconditional control flow instruction is calculated by the IFU from IFU maintained register data and from the operand data provided within an immediate mode operand field of the control flow instruction.</p><p>2.7.2 the target address of an absolute unconditional branch is calculated by the IEU from a register reference, a base register value, and an index register value.</p><p>2.7.2.1 instruction prefetch cycling stalls until the target address is returned by the IEU for absolute address branches; execution cycling continues.</p><p>2.8 the address of the next procedural flow prefetch instruction set is stored in the EBUF PFnPC and prefetching continues at 1.2.</p><p>2.9 when a return from procedure instruction is IDecoded, prefetching continues from the address stored in the uPC register, which is then incremented (\u00d716) and returned to the MBUF PFnPC register for subsequent prefetches.</p><p>3 Branch Instruction Stream Processing: TBUF PFnPC</p><p>3.1 when a conditional control flow instruction, occurring in a first instruction set in the MBUF instruction stream, is IDecoded, the target address is determined by the IFU if the target address is relative to the current address or by the IEU for absolute addresses.</p><p>3.2 for \u201cbranch taken bias\u201d:</p><p>3.2.1 if the branch is to an absolute address, stall instruction prefetch cycling until the target address is returned by the IEU; execution cycling continues.</p><p>3.2.2 load the TBUF PFnPC with the branch target address by transfer through the PF PC selector and incrementor.</p><p>3.2.3 target instruction stream instructions are prefetched into the TBUF and then routed into the IFIFO for subsequent execution; if the IFIFO and TBUF becomes full, stall prefetching.</p><p>3.2.4 the 32 bit incrementor adjusts (\u00d716) the address value in the TBUF PFnPC with each prefetch cycle.</p><p>3.2.5 stall the prefetch operation on IDecode of a conditional control flow instruction, occurring in a second instruction set in the target instruction stream until the all conditional branch instructions in the first (primary) set are resolved (but go ahead and calculate the relative target address and store in target registers).</p><p>3.2.6 if conditional branch in the first instruction set resolves to \u201ctaken\u201d,</p><p>3.2.6.1 flush instruction sets following the first conditional flow instruction set in the MBUF or EBUF, if the source of the branch was the EBUF instruction stream as determined from the procedure-in-progress bit.</p><p>3.2.6.2 transfer the TBUF PFnPC value to MBUF PFnPC or EBUF based on the state of the procedure-in-progress bit.</p><p>3.2.6.3 transfer the prefetched TBUF instructions to the MBUF or EBUF based on the state of procedure-in-progress bit.</p><p>3.2.6.4 if a second conditional branch instruction set has not been IDecoded, continue MBUF or EBUF prefetching operations based on the state of the procedure-in-progress bit.</p><p>3.2.6.5 if a second conditional branch instruction has been IDecoded, begin processing that instruction (go to step 3.3.1).</p><p>3.2.7 if the conditional control for instruction(s) in the first conditional instruction set resolves to \u201cnot taken\u201d:</p><p>3.2.7.1 flush the IFIFO and IEU of instruction sets and instructions from the target instruction stream.</p><p>3.2.7.2 continue MBUF or EBUF prefetching operations.</p><p>3.3 for \u201cbranch not taken bias\u201d:</p><p>3.3.1 stall prefetch of instructions into the MBUF; execution cycling continues.</p><p>3.3.1.1 if the conditional control flow instruction in the first conditional instruction set is relative, calculate the target address and store in the target registers.</p><p>3.3.1.2 if the conditional control flow instructions in the first conditional instruction set is absolute, wait for the IEU to calculate the target address and return the address to the target registers.</p><p>3.3.1.3 stall the prefetch operation on IDecode of a conditional control flow instruction in a second instruction set until the conditional control flow instruction(s) in the first conditional instruction set instruction is resolved.</p><p>3.3.2 once the target address of the first conditional branch is calculated, load into TBUF PFnPC and also begin prefetching instructions into the TBUF concurrent with execution of the main instruction stream. Target instruction sets are not loaded into the IFIFO (the branch target instructions are thus on hand when each conditional control flow instruction in the first instruction set resolves).</p><p>3.3.3 if a conditional control flow instruction in the first set resolves to \u201ctaken\u201d:</p><p>3.3.3.1 flush the MBUF or EBUF, if the source of the branch was the EBUF instruction stream, as determined from the state of the procedure-in-progress bit, and the IFIFO and IEU of instructions from the main stream following the first conditional branch instruction set.</p><p>3.3.3.2 transfer the TBUF PFnPC value to MBUF PFnPC or EBUF, as determined from the state of the procedure-in-progress bit.</p><p>3.3.3.3 transfer the prefetched TBUF instructions to the MBUF or EBUF, as determined from the state of the procedure-in-progress bit.</p><p>3.3.3.4 continue MBUF or EBUF prefetching operations, as determined from the state of the procedure-in-progress bit.</p><p>3.3.4 if a conditional control flow instruction in the first set resolves to \u201cnot taken\u201d:</p><p>3.3.4.1 flush the TBUF of instruction sets from the target instruction stream.</p><p>3.3.4.2 if a second conditional branch instruction has not been IDecoded, continue MBUF or EBUF, as determined from the state of the procedure-in-progress bit, prefetching operations.</p><p>3.3.4.3 if a second conditional branch instruction has been IDecoded, begin processing that instruction (go to step 3.4.1).</p><p>4. Interrupts, Exceptions and Trap Instructions.</p><p>4.1 Traps generically include:</p><p>4.1.1 Hardware Interrupts.</p><p>4.1.1.1 asynchronously (external) occurring events, internal or external.</p><p>4.1.1.2 can occur at any time and persist.</p><p>4.1.1.3 serviced in priority order between atomic (ordinary) instructions and may suspend procedural instructions.</p><p>4.1.1.4 the starting address of an interrupt handler is determined as the vector number offset into a predefined table of trap handler entry points.</p><p>4.1.2 Software Trap Instructions;</p><p>4.1.2.1 synchronously (internal) occurring instructions.</p><p>4.1.2.2 a software instruction that executes as an exception.</p><p>4.1.2.3 the starting address of the trap handler is determined from the trap number offset combined with a base address value stored in the TBR or FTB register.</p><p>4.1.3 Exceptions.</p><p>4.1.3.1 Events occurring synchronously with an instruction.</p><p>4.1.3.2 handled at the time the instruction is executed.</p><p>4.1.3.3 due to consequences of the exception, the excepted instruction and all subsequent executed instructions are cancelled.</p><p>4.1.3.4 the starting address of the exception handler is determined from the trap number offset into a predefined table of trap handler entry point.</p><p>4.2 Trap instruction stream operations occur in-line with the then currently executing instruction stream.</p><p>4.3 Traps may nest, provided the trap handling routine saves the xPC address prior to a next allowed trap\u2014failure to do so will corrupt the state of the machine if a trap occurs prior to completion of the current trap operation.</p><p>5. Trap Instruction Stream Processing: xPC.</p><p>5.1 when a trap is encountered:</p><p>5.1.1 if an asynchronous interrupt, the execution of the currently executing instruction(s) is suspended.</p><p>5.1.2 if a synchronous exception, the trap is processed upon execution of the excepted instruction.</p><p>5.2 when a trap is processed:</p><p>5.2.1 interrupts are disabled.</p><p>5.2.2 the current IF_PC address is stored in the xPC trap state return address register.</p><p>5.2.3 the IFIFO and the MBUF prefetch buffers at and subsequent to the IF_PC address are flushed.</p><p>5.2.4 executed instructions at and subsequent to the address IF PC and the results of those instructions are flushed from the IEU.</p><p>5.2.5 the MBUF PFnPC is loaded with the address of the trap handler routine.</p><p>5.2.5.1 source of a trap address either the TBR or FTB register, depending on the type of trap as determined by the trap number, which are provided in the set of special registers.</p><p>5.2.6 instructions are prefetched and dropped into the IFIFO for execution in a normal manner.</p><p>5.2.7 the instructions of the trap routine are then executed.</p><p>5.2.7.1 the trap handling routine may provide for the xPC address to be saved to a predefined location and interrupts re-enabled; the xPC register is read/write via a special register move instruction and the special register address and data bus.</p><p>5.2.8 the trap state must be exited by the execution of a return from trap instruction.</p><p>5.2.8.1 if prior saved, the xPC address must be restored from its predefined location before executing the return from trap instruction.</p><p>5.3 when a return from trap is executed:</p><p>5.3.1 interrupts are enabled.</p><p>5.3.2 the xPC address is returned to the current instruction stream register MBUF or EBUF PFnPC, as determined from the state of the procedure-in-progress bit, and prefetching continues from that address.</p><p>5.3.3 the xPC address is restored to the IF_PC register through the new stream register.</p><p>E) Interrupt and Exception Handling:</p><p>1) Overview:</p><p>Interrupts and exceptions will be processed, as long as they are enabled, regardless of whether the processor is executing from the main instruction stream or a procedural instruction stream. Interrupts and exceptions are serviced in priority order, and persist until cleared. The starting address of a trap handler is determined as the vector number offset into a predefined table of trap handler addresses as described below.</p><p>Interrupts and exceptions are of two basic types in the present embodiment, those which occur synchronously with-particular instructions in the instruction stream, and those which occur asynchronously with particular instructions in the instruction stream. The terms interrupt, exception, trap and fault are used interchangeably herein. Asynchronous interrupts are generated by hardware, either on-chip or off-chip, which does not operate synchronously with the instruction stream. For example, interrupts generated by an on-chip timer/counter are asynchronous, as are hardware interrupts and non-maskable interrupts (NMI) provided from off-chip. When an asynchronous interrupt occurs, the processor context is frozen, all traps are disabled, certain processor status information is stored, and the processor vectors to an interrupt handler corresponding to the particular interrupt received. After the interrupt handler completes its processing, program execution continues with the instruction following the last completed instruction in the stream which was executing when the interrupt occurred.</p><p>Synchronous exceptions are those that occur synchronously with instructions in the instruction stream. These exceptions occur in relation to particular instructions, and are held until the relevant instruction is to be executed. In the preferred embodiments, synchronous exceptions arise during prefetch, during instruction decode, or during instruction execution. Prefetch exceptions include, for example, TLB miss or other VMU exceptions. Decode exceptions arise, for example, if the instruction being decoded is an illegal instruction or does not match the current privilege level of the processor. Execution exceptions arise due to arithmetic errors, for example, such as divide by zero. Whenever these exceptions occur, the preferred embodiments maintain them in correspondence with the particular instruction which caused the exception, until the time at which that instruction is to be retired. At that time, all prior completed instructions are retired, any tentative results from the instruction which caused the exception are flushed, as are the tentative results of any following tentatively executed instructions. Control is then transferred to an exception handler corresponding to the highest priority exception which occurred for that instruction.</p><p>Software trap instructions are detected at the IDecode stage by CF_DET <b>274</b> (FIG. 2) and are handled similarly to both unconditional call instructions and other synchronous traps. That is, a target address is calculated and prefetch continues to the then-current prefetch queue (EBUF or MBUF). At the same time, the exception is also noted in correspondence with the instruction and is handled when the instruction is to be retired. All other types of synchronous exceptions are merely noted and accumulated in correspondence with the particular instruction which caused it and are handled at execution time.</p><p>2) Asynchronous Interrupts:</p><p>Asynchronous interrupts are signaled to the PC logic unit <b>270</b> over interrupt lines <b>292</b>. As shown in FIG. 3, these lines are provided to the interrupt logic unit <b>363</b> in the PC logic unit <b>270</b>, and comprise an NMI line, an IRQ line and a set of interrupt level lines (LVL). The NMI line signals a non-maskable interrupt, and derives from an external source. It is the highest priority interrupt except for hardware reset. The IRQ line also derives from an external source, and indicates when an external device is requesting a hardware interrupt. The preferred embodiments permit up to 32 user-defined externally supplied hardware interrupts and the particular external device requesting the interrupt provides the number of the interrupt (0-31) on the interrupt level lines (LVL). The memory error line is activated by the MCU <b>110</b> to signal various kinds of memory errors. Other asynchronous interrupt lines (not shown) are also provided to the interrupt logic unit <b>363</b>, including lines for requesting a timer/counter interrupt, a memory I/O error interrupt, a machine check interrupt and a performance monitor interrupt. Each of the asynchronous interrupts, as well as the synchronous exceptions described below, have a corresponding predetermined trap number associated with them, <b>32</b> of these trap numbers being associated with the <b>32</b> available hardware interrupt levels. A table of these trap numbers is maintained in the interrupt logic unit <b>363</b>. The higher the trap number, in general, the higher the priority of the trap.</p><p>When one of the asynchronous interrupts is signaled to the interrupt logic unit <b>363</b>, the interrupt control unit <b>363</b> sends out an interrupt request to the IEU <b>104</b> over INT REQ/ACK lines <b>340</b>. Interrupt control unit <b>363</b> also sends a suspend prefetch signal to PC control unit <b>362</b> over lines <b>343</b>, causing the PC control unit <b>262</b> to stop prefetching instructions. The IEU <b>104</b> either cancels all then-executing instructions, and flushing all tentative results, or it may allow some or all instructions to complete. In the preferred embodiments, any then-executing instructions are canceled, thereby permitting the fastest response to asynchronous interrupts. In any event, the DPC in the execution PC control unit <b>366</b> is updated to correspond to the last instruction which has been completed and retired, before the IEU <b>104</b> acknowledges the interrupt. All other prefetched instructions in MBUF, EBUF, TBUF and IFIFO <b>264</b> are also cancelled.</p><p>Only when the IEU <b>104</b> is ready to receive instructions from an interrupt handler does it send an interrupt acknowledge signal on INT REQ/ACK lines <b>340</b> back to the interrupt control unit <b>363</b>. The interrupt control unit <b>363</b> then dispatches to the appropriate trap handler as described below.</p><p>3) Synchronous Exceptions:</p><p>For synchronous exceptions, the interrupt control unit <b>363</b> maintains a set of four internal exception bits (not shown) for each instruction set, one bit corresponding to each instruction in the set. The interrupt control unit <b>363</b> also maintains an indication of the particular trap numbers, if any detected for each instruction.</p><p>If the VMU signals a TLE miss or another VMU exception while a particular instruction set is being prefetched, this information is transmitted to the PC logic unit <b>270</b>, and in particular to the interrupt control unit <b>363</b>, over the VMU control lines <b>332</b> and <b>334</b>. When the interrupt control unit <b>363</b> receives such a signal, it signals the PC control unit <b>362</b> over line <b>34</b>.<b>3</b> to suspend further prefetches. At the same time, the interrupt control unit <b>363</b> sets the VM_Miss or VM_Excp bit, as appropriate, associated the prefetch buffer to which the instruction set was destined. The interrupt control unit <b>363</b> then sets all four internal exception indicator bits corresponding to that instruction set, since none of the instructions in the set are valid, and stores the trap number for the particular exception received in correspondence with each of the four instructions in the faulty instruction set. The shifting and executing of instructions prior to the faulty instruction set then continues as usual until the faulty set reaches the lowest level in the IFIFO <b>264</b>.</p><p>Similarly, if other synchronous exceptions are detected during the shifting of an instruction through the prefetch buffers <b>260</b>, the IDecode unit <b>262</b> or the IFIFO <b>264</b>, this information is also transmitted to the interrupt control unit <b>363</b> which sets the internal exception indicator bit corresponding to the instruction generating the exception and stores the trap number in correspondence with that exception. As with prefetch synchronous exceptions, the shifting and executing of instructions prior to the faulty instruction then continues as usual until the faulty set reaches the lowest level in the IFIFO <b>264</b>.</p><p>In the preferred embodiments, the only type of exception which is detected during the shifting of an instruction through the prefetch buffers <b>260</b>, the IDecode unit <b>262</b> or the IFIFO <b>264</b> is a software trap instruction. Software trap instructions are detected at the IDecode stage by CF_DET unit <b>274</b>. While.: in some embodiments other forms of synchronous exceptions may be detected in the IDecode unit <b>262</b>, it is preferred that the detection of any other synchronous exceptions wait until the instruction reaches the execution unit <b>104</b>. This avoids the possibility that certain exceptions, such as arising from the handling of privileged instruction, might be signaled on the basis of a processor state which could change before the effective in-order-execution of the instruction. Exceptions which do not depend on the processor state, such as illegal instruction, could be detected in the IDecode stage, but hardware is minimized if the same logic detects all pre-execution synchronous exceptions (apart from VMU exceptions). Nor is there any time penalty imposed by waiting until instructions reach the execution unit <b>104</b>, since the handling of such exceptions is rarely time critical.</p><p>As mentioned, software trap instructions are detected at the IDecode stage by the CF_DET unit <b>274</b>.</p><p>The internal exception indicator bit corresponding to that instruction in the interrupt logic unit <b>363</b> is set and the software trap number, which can be any number from 0 to 127 and which is specified in an immediate mode operand field of the software trap instruction, is stored in correspondence with the trap instruction. Unlike prefetch synchronous exceptions, however, since software traps are treated as both a control flow instruction and as a synchronous exception, the interrupt control unit <b>363</b> does not signal PC control unit <b>362</b> to suspend prefetches when a software trap instruction is detected. Rather, at the same time the instruction is shifting through the IFIFO <b>264</b>, the IFU <b>102</b> prefetches the trap handler into the MBUF instruction stream buffer.</p><p>When an instruction set reaches the lowest level of the IFIFO <b>264</b>, the interrupt logic unit <b>363</b> transmits the exception indicator bits for that instruction set as a 4-bit vector to the IEU <b>104</b> over the SYNCH_INT_INFO lines <b>341</b> to indicate which, if any, of the instructions in the instruction set have already been determined to be the source of a synchronous exception. The IEU <b>104</b> does not respond.-immediately, but rather permits all the instructions in the instruction set to be scheduled in the normal course. Further exceptions, such as integer arithmetic exceptions, may be generated during execution. Exceptions which depend on the current state of the machine, such as due to the execution of a privileged instruction, are also detected at this time, and in order to ensure that the state of the machine is current with respect to all previous instructions in the instruction stream, all instructions which have a possibility of affecting the PSR (such as special move and returns from trap instructions) are forced to execute in order. Only when an instruction that is the source of a synchronous exception of any sort is about to be retired, is the occurrence of the exception signaled to the interrupt logic unit <b>363</b>.</p><p>The IEU <b>104</b> retires all instructions which have been tentatively executed and which occur in the instruction stream prior to the first instruction which has a synchronous exception, and flushes the tentative results from any tentatively executed instructions which occur subsequently in the instruction stream. The particular instruction that caused the exception is also flushed since that instruction will typically be re-executed upon return from trap. The IF_PC in the execution PC control unit <b>366</b> is then updated to correspond to the last instruction actually retired, and the before any exception is signaled to the interrupt control unit <b>363</b>.</p><p>When the instruction that is the source of an exception is retired, the IEU <b>104</b> returns to the interrupt logic unit <b>363</b>, over the SYNCH_INT_INFO lines <b>341</b>, both a new 4-bit vector indicating which, if any, instructions in the retiring instruction set (register <b>224</b>) had a synchronous exception, as well as information indicating the source of the first exception in the instruction set. The information in the 4-bit exception vector returned by IEU <b>104</b> is an accumulation of the 4-bit exception vectors provided to the IEU <b>104</b> by the interrupt logic unit <b>363</b>, as well as exceptions generated in the IEU <b>104</b>. The remainder of the information returned from the IEU <b>104</b> to interrupt control unit <b>363</b>, together with any information already stored in the interrupt control unit <b>363</b> due to exceptions detected on prefetch or IDecode, is sufficient for the interrupt control unit <b>363</b> to determine the nature of the highest priority synchronous. exception and its trap number.</p><p>4) Handler Dispatch and Return:</p><p>After an interrupt acknowledge signal is received over lines <b>340</b> from the IEU, or after a non-zero exception vector is received over lines <b>341</b>, the current DPC is temporarily stored as a return address in an xPC register, which is one of the special registers <b>412</b> (FIG. <b>4</b>). The current processor status register (PSR) is also stored in a previous PSR (PPSR) register, and the current compare state register (CSR) is saved in a prior compare state register (PCSR) in the special registers <b>412</b>.</p><p>The address of a trap handler is calculated as a trap base register address plus an offset. The PC logic unit <b>270</b> maintains two base registers for traps, both of which are part of the special registers <b>412</b> (FIG. <b>4</b>), and both of which are initialized by special move instructions executed previously. For most traps, the base register used to calculate the address of the handler is a trap base register TBR.</p><p>The interrupt control unit <b>363</b> determines the highest priority interrupt or exception currently pending and, through a look-up table, determines the trap number associated therewith. This is provided over a set of INT_OFFSET lines <b>373</b> to the prefetch PC control unit <b>364</b> as an offset to the selected base register. Advantageously, the vector address is calculated by merely concatenating the offset bits as low-order bits to the higher order bits obtained from the TBR register. This avoids any need for the delays of an adder. (As used herein, the 2\u2032 bit is referred to as the i'th order bit.) For example, if traps are numbered from 0 through <b>255</b>, represented as an 8 bit value, the handler address may be calculated by concatenating the 8 bit trap number to the end of a 22-bit TBR stored value. Two low-order zero bits may be appended to the trap number to ensure that the trap handler address always occurs on a word boundary. The concatenated handler address thus constructed is provided as one of the inputs, <b>373</b>; to the prefetch selector PF_PC Sel <b>390</b> (FIG. <b>4</b>), and is selected as the next address from which instructions are to be prefetched.</p><p>The vector handler address for traps using the TBR register are all only one word apart. Thus, the instruction at the trap handler address must be a preliminary branch instruction to a longer trap handling routine. Certain traps require very careful handling, however, to prevent degradation of system performance. TLB traps, for example, must be executed very quickly. For this reason, the preferred embodiments include a fast trap mechanism designed to allow the calling of small trap handlers without the cost of this preliminary branch. In addition, fast trap handlers can be located independently in memory, in on-chip ROM, for example, to eliminate memory system penalties associated with RAM locations.</p><p>In the preferred embodiments, the only traps which result in fast traps are the VMU exceptions mentioned above. Fast traps are numbered separately from other traps, and have a range from 0 to 7. However, they have the same priority as MMU exceptions. When the interrupt control unit <b>363</b> recognizes a fast trap as the highest priority trap then pending, it causes a fast trap base register (FTB) to be selected from the special registers <b>412</b> and provided on the lines <b>416</b> to be combined with the trap offset. The resulting vector address provided to the prefetch selector PF_PC Sel <b>390</b>, via lines <b>373</b>\u2032, is then a concatenation of the nigh-order 22 bits from the FTB register, followed by three bits representing the fast trap number, followed by seven bits of 0's. Thus, each fast trap address is 128 bytes, or 32 words apart. When called, the processor branches to the starting word and may execute programs within the block or branch out of it. Execution of small programs, such as standard TLB handling routines which may be implemented in 32 instructions or less, is faster than ordinary traps because the preliminary branch to the actual exception handling routine is obviated.</p><p>It should be noted that although all instructions have the same length of 4 bytes (i.e., occupy four address locations) in the preferred embodiments, it should be noted that the fast trap mechanism is also useful in microprocessors whose instructions are variable in length. In this case, it will be appreciated that the fast trap vector addresses be separated by enough space to accommodate at least two of the shortest instructions available on the microprocessor, and preferably about 32 average-sized instructions. Certainly, if the microprocessor includes a return from trap instruction, the vector addresses should be separated by at least enough space to permit that instruction to be preceded by at least one other instruction in the handler.</p><p>Also on dispatch to a trap handler, the processor enters both a kernel mode and an interrupted state. Concurrently, a copy of the compare state register (CSR) is placed in the prior carry state register (PCSR) and a copy of the PSR is stored in the prior PSR (PPSR) register. The kernel and interrupted states modes are represented by bits in the processor status register (PSR). Whenever the interrupted_state bit in the current PSR Ls set, the shadow registers or trap registers RT[24] through RT[31], as described above and as shown in FIG. 7B, become visible. The interrupt handler may switch out of kernel mode merely by writing a new mode into the PSR, but the only way to leave the interrupted state is by executing a return from trap (RTT) instruction.</p><p>When the IEU <b>104</b> executes an RTT instruction, PCSR is restored to CSR register and PPSR register is restored to the PSR register, thereby automatically clearing the interrupt-state bit in the PSR register. The PF_PC SEL selector <b>390</b> also selects special register xPC in the special register set <b>412</b> as the next address from which to prefetch. xPC is restored to either the MBUF PFnPC or the EBUF PFnPC as appropriate, via incrementor <b>394</b> and bus <b>396</b>. The decision as to whether to restore xPC into the EBUF or MBUF PFnPC is made according to the \u201cprocedure_in_progress\u201d bit of the PSR, once restored.</p><p>It should be noted that the processor does not use the same special register xPC to store the return address for both traps and procedural instructions. The return address for a trap is stored in the special register xPC, as mentioned, but the address to return to after a procedural instruction is stored in a different special register, uPC. Thus, the interrupted state remains available even while the processor is executing an emulation stream invoked by a procedural instruction. On the other hand, exception handling routines should not include any procedural instructions since there is no special register to store an address for return to the exception handler after the emulation stream is complete.</p><p>5) Nesting:</p><p>Although certain processor status information is automatically backed up on dispatch to a trap handler, in particular CSR, PSR, the return PC, and. in a sense the HAN register set ra[24] through ra[31], other context information is not protected. For example, the contents of a floating point status register (FSR) is not automatically backed up. If a trap handler intends to alter these registers, it must perform its own backup.</p><p>Because of the limited backup which is performed automatically on a dispatch to a trap handler, nesting of traps is not automatically permitted. A trap handler should back up any desired registers, clear any interrupt condition, read any information necessary for handling the trap from the system registers and process it as appropriate. Interrupts are automatically disabled upon dispatch to the trap handler. After processing, the handler can then restore the backed up registers, re-enable interrupts and execute the RTT instruction to return from the interrupt.</p><p>If nested traps are to be allowed, the trap handler should be divided into first and second portions. In the first portion, while interrupts are disabled, the xPC should be copied, using a special register move instruction, and pushed onto the stack maintained by the trap handler. The address of the beginning of the second portion of the trap handler should then be moved using the special register move instruction into the XPC, and a return from trap instruction (RTT) executed. The RTT removes the interrupted state (via the restoration of PPSR into PSR) and transfers control to the address in the xPC, which now contains the address of the second portion of the handler. The second portion may enable interrupts at this point and continue to process the exception in an interruptable mode. It should be noted that the shadow registers RT[24] through RT[31] are visible only in the first portion of this handler, and not in the second portion. Thus, in the second portion, the handler should preserve any of the \u201cA\u201d register values where these register values are likely to be altered by the handler. When the trap handling procedure is finished, it should restore all backed up registers, pop the original xPC off the trap handler stack and move it back into the xPC special it register using a special register move instruction, and execute another RTT. This returns control to the appropriate instruction in the main or emulation instruction stream.</p><p>6) List of Traps:</p><p>The following Table I sets forth the trap numbers, priorities and handling modes of traps which are recognized in the preferred embodiments:</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"1\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"4\" colwidth=\"112PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE I</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Handling</entry><entry morerows=\"0\" valign=\"top\">Asynch/</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Trap #</entry><entry morerows=\"0\" valign=\"top\">Mode</entry><entry morerows=\"0\" valign=\"top\">Synch</entry><entry morerows=\"0\" valign=\"top\">Trap Name</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\">0-127</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Synch</entry><entry morerows=\"0\" valign=\"top\">Trap instruction</entry></row><row><entry morerows=\"0\" valign=\"top\">128</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Synch</entry><entry morerows=\"0\" valign=\"top\">FP exception</entry></row><row><entry morerows=\"0\" valign=\"top\">129</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Synch</entry><entry morerows=\"0\" valign=\"top\">Integer arithmetic exceptions</entry></row><row><entry morerows=\"0\" valign=\"top\">130</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Synch</entry><entry morerows=\"0\" valign=\"top\">MMU (except TLB miss or modified)</entry></row><row><entry morerows=\"0\" valign=\"top\">135</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Synch</entry><entry morerows=\"0\" valign=\"top\">Unaligned memory address</entry></row><row><entry morerows=\"0\" valign=\"top\">136</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Synch</entry><entry morerows=\"0\" valign=\"top\">Illegal instruction</entry></row><row><entry morerows=\"0\" valign=\"top\">137</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Synch</entry><entry morerows=\"0\" valign=\"top\">Privileged instruction</entry></row><row><entry morerows=\"0\" valign=\"top\">138</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Synon</entry><entry morerows=\"0\" valign=\"top\">Debug exception</entry></row><row><entry morerows=\"0\" valign=\"top\">144</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Asynch</entry><entry morerows=\"0\" valign=\"top\">Performance monitor</entry></row><row><entry morerows=\"0\" valign=\"top\">145</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Asyncn</entry><entry morerows=\"0\" valign=\"top\">Timer/Counter</entry></row><row><entry morerows=\"0\" valign=\"top\">146</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Asynch</entry><entry morerows=\"0\" valign=\"top\">Memory I/O error</entry></row><row><entry morerows=\"0\" valign=\"top\">160-191</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Asynch</entry><entry morerows=\"0\" valign=\"top\">Hardware interrupt</entry></row><row><entry morerows=\"0\" valign=\"top\">192-253</entry><entry morerows=\"0\" valign=\"top\">reserved</entry></row><row><entry morerows=\"0\" valign=\"top\">254</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Asynch</entry><entry morerows=\"0\" valign=\"top\">Machine check</entry></row><row><entry morerows=\"0\" valign=\"top\">255</entry><entry morerows=\"0\" valign=\"top\">normal</entry><entry morerows=\"0\" valign=\"top\">Asynch</entry><entry morerows=\"0\" valign=\"top\">NMI</entry></row><row><entry morerows=\"0\" valign=\"top\">0</entry><entry morerows=\"0\" valign=\"top\">fast trap</entry><entry morerows=\"0\" valign=\"top\">Synch</entry><entry morerows=\"0\" valign=\"top\">Fast MMU TLB miss</entry></row><row><entry morerows=\"0\" valign=\"top\">1</entry><entry morerows=\"0\" valign=\"top\">fast trap</entry><entry morerows=\"0\" valign=\"top\">Synch</entry><entry morerows=\"0\" valign=\"top\">Fast MMU TLB modified</entry></row><row><entry morerows=\"0\" valign=\"top\">2-3</entry><entry morerows=\"0\" valign=\"top\">fast trap</entry><entry morerows=\"0\" valign=\"top\">Synch</entry><entry morerows=\"0\" valign=\"top\">Fast MMU (reserved)</entry></row><row><entry morerows=\"0\" valign=\"top\">4-7</entry><entry morerows=\"0\" valign=\"top\">fast trap</entry><entry morerows=\"0\" valign=\"top\">Synch</entry><entry morerows=\"0\" valign=\"top\">Fast (reserved)</entry></row><row><entry align=\"center\" morerows=\"0\" nameend=\"4\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>III. Instruction Execution Unit:</p><p>The combined control and data path portions of IEU <b>104</b> are shown in FIG. <b>5</b>. The primary data path begins with the instruction/operand data bus <b>124</b> from the IFU <b>102</b>. As a data bus, immediate operands are provided to an operand alignment unit <b>470</b> and passed on to a register file (REG ARRAY) <b>472</b>. Register data is provided from the register file <b>472</b> through a bypass unit <b>474</b>, via a register file output bus <b>476</b>, to a parallel array of functional computing elements (FU<sub>0-n</sub>) <b>478</b><sub>0-n</sub>, via a distribution bus <b>480</b>. Data generated by the functional units <b>478</b><sub>0-n </sub>is provided back to the bypass unit <b>474</b> or the register array <b>472</b>, or both, via an output bus <b>482</b>.</p><p>A load/store unit <b>484</b> completes the data path portion of the IEU <b>104</b>. The load/store unit <b>484</b> is responsible for managing the transfer of data between the IEU <b>104</b> and CCU <b>106</b>. Specifically, load data obtained from the data cache <b>134</b> of the CCU <b>106</b> is transferred by the load/store unit <b>484</b> to an input of the register array <b>472</b> via a load data bus <b>486</b>. Data to be stored to the data cache <b>134</b> of the CCU <b>106</b> is received from the functional unit distribution bus <b>480</b>.</p><p>The control path portion of the IEU <b>104</b> is responsible for issuing, managing, and completing the processing of information through the IEU data path. In the preferred embodiments of the present invention the IEU control path is capable of managing the concurrent execution of multiple instructions and the IEU data path provides for multiple independent data transfers between essentially all data path elements of the IEU <b>104</b>. The IEU control path operates in response to instructions received via the instruction/opera-nd bus <b>124</b>. Specifically, instruction sets are received by the EDecode unit <b>490</b>. In the preferred embodiments of the present invention, the EDecode <b>490</b> receives and decodes both instruction'sets held by the IFIFO master registers <b>216</b>, <b>224</b>. The results of the decoding of all eight instructions is variously provided to a carry checker (CRY CHKR) unit <b>492</b>, dependency checker (DEP CHKR) unit <b>494</b>, register renaming unit (REG RENAME) <b>496</b>, instruction issuer (ISSUER) unit <b>498</b> and retirement control unit (RETIRE CTL) <b>500</b>.</p><p>The carry checker unit <b>492</b> receives decoded information about the eight pending instructions from the EDecode unit <b>490</b> via control lines <b>502</b>. The function of the carry checker <b>492</b> is to identify those ones of the pending instructions that either affect the carry bit of the processor status word or are dependent on the state of the carry bit. This control information is provided via control lines <b>504</b> to the instruction issuer unit <b>498</b>.</p><p>Decoded information identifying the registers of the register file <b>472</b> that are used by the eight pending instructions as provided directly to the register renaming unit <b>496</b> via control lines <b>506</b>. This information is also provided to the dependency checker unit <b>494</b>. The function of the dependency checker unit <b>494</b> is to determine which of the pending instructions reference registers as the destination for data and which instructions, if any, are dependant on any of those destination registers. Those instructions that have register dependencies are identified by control signals provided via the control lines <b>508</b> to the register rename unit <b>496</b>.</p><p>Finally, the EDecode unit <b>490</b> provides control information identifying the particular nature and function of each of the eight pending instructions to the instruction issuer unit <b>498</b> via control lines <b>510</b>. The issuer unit <b>498</b> is responsible for determining the data path resources, particularly of the availability of particular functional units, for the execution of pending instructions. In accordance with the preferred embodiments of the architecture <b>100</b>, instruction issuer unit <b>498</b> allows for the out-of-order execution of any of the eight pending instructions subject to the availability of data path resources and carry and register dependency constraints. The register rename unit <b>496</b> provides the instruction issuing unit <b>498</b> with a bit map, via control lines <b>512</b> of those instructions that are suitably unconstrained to allow execution. Instructions that have already been executed (done) and those with register or carry dependencies are logically removed from the bit map.</p><p>Depending on the availability of required functional units <b>478</b><sub>0-n</sub>, the instruction issuer unit <b>498</b> may initiate the execution of multiple instructions during each system clock cycle. The status of the functional units <b>478</b><sub>0-n </sub>are provided via a status bus <b>514</b> to the instruction issuer unit <b>498</b>. Control signals for initiating, and subsequently managing the execution of instructions are provided by the instruction issuer unit <b>498</b> on the control lines <b>516</b> to the register rename unit <b>496</b> and selectively to the functional units <b>478</b><sub>0-n</sub>. In response, the register rename unit <b>496</b> provides register selection signals on a register file access control bus <b>518</b>. The specific registers enabled via the control signals provided on the bus <b>518</b> are determined by the selection of the instruction being executed and by the determination by the register rename unit <b>496</b> of the registers referenced by that particular instruction.</p><p>A bypass control unit (BYPASS CTL) <b>520</b> generally controls the operation of the bypass data routing unit <b>474</b> via control signals on control lines <b>524</b>. The bypass control unit <b>520</b> monitors the status of each of the functional units <b>478</b><sub>0-n </sub>and, in conjunction with the register references provided from the register rename unit <b>496</b> via control lines <b>522</b>, determines whether data is to be routed from the register file <b>472</b> to the functional units <b>478</b><sub>0-n </sub>or whether data being produced by the functional units <b>478</b>. can be immediately routed via the bypass unit <b>474</b> to the functional unit distribution bus <b>480</b> for use in the execution of a newly issued instruction selected by the instruction issuer unit <b>498</b>. In either case, the instruction issuer unit <b>498</b> directly controls the routing of data from the distribution bus <b>480</b> to the functional units <b>478</b><sub>0-n </sub>by selectively enabling specific register data to each of the functional units <b>478</b><sub>0-n</sub>.</p><p>The remaining units of the IEU control path include a retirement control unit <b>500</b>, a control flow control (CF CT<b>1</b>) unit <b>528</b>, and a done control (DONE CTL) unit <b>540</b>. The retirement control unit <b>500</b> operates to void or confirm the execution of out-of-order executed instructions. Where an instruction has been executed out-of-order, that instruction can be confirmed or retired once all prior instructions have also been retired. Based on an identification of which of the current set of eight pending instructions have been executed provided on the control lines <b>532</b>, the retirement control unit <b>500</b> provides control signals on control lines <b>534</b> coupled to the bus <b>518</b> to effectively confirm the result data stored by the register array <b>472</b> as the result of the prior execution of an out-of-order executed instruction.</p><p>The retirement control unit <b>500</b> provides the PC increment/size control signals on control lines <b>344</b> to the IFU <b>102</b> as it retires each instruction. Since multiple instructions may be executed out-of-order, and therefore ready for simultaneous retirement, the retirement control unit <b>500</b> determines a size value based on the number of instructions simultaneously retired. Finally, where all instructions of the IFIFO master register <b>224</b> have been executed and retired, the retirement control unit <b>500</b> provides the IFIFO read control signal on the control line <b>342</b> to the IFU <b>102</b> to initiate an IFIFO unit <b>264</b> shift operation, thereby providing the EDecode unit <b>490</b> with an additional four instructions as instructions pending execution.</p><p>The control flow control unit <b>528</b> performs the somewhat more specific function of detecting the logical branch result of each conditional branch instruction. The control flow control unit <b>528</b> receives an 8 bit vector identification of the currently pending conditional branch instructions from the EDecode unit <b>490</b> via the control lines <b>510</b>. An 8 bit vector instruction done control signal is similarly received via the control lines <b>532</b> or <b>542</b> from the done control unit <b>540</b>. This done control signal allows the control flow control unit <b>528</b> to identify when a conditional branch instruction is done at least to a point sufficient to determine a conditional control flow status. The control flow status result for the pending conditional branch instructions are stored by the control flow control unit <b>528</b> as they are executed. The data necessary to determine the conditional control flow instruction outcome is obtained from temporary status registers in the register array <b>472</b> via the control lines <b>530</b>. As each conditional control flow instruction is executed, the control flow control unit provides a new control flow result signal on the control lines <b>348</b> to the IFU <b>102</b>. This control flow result signal preferably includes two 8 bit vectors defining whether the status results, by respective bit position, of the eight potentially pending control flow instruction are known and the corresponding status result states, also given by bit position correspondence.</p><p>Lastly, the done control unit <b>540</b> is provided to monitor the operational execution state of each of the functional units <b>478</b><sub>0-n</sub>. As any of the functional units <b>478</b><sub>0-n </sub>signal completion of an instruction execution operation, the done control unit <b>540</b> provides a corresponding done control signal on the control lines <b>542</b> to alert the register rename unit <b>496</b>, instruction issuer unit <b>498</b>, retirement control unit <b>500</b> and bypass control unit <b>520</b>.</p><p>The parallel array arrangement of the functional units <b>478</b><sub>0-n </sub>enhances the control consistency of the IEU <b>104</b>. The particular nature of the individual functional units <b>478</b><sub>0-n </sub>must be known by the instruction issuer unit <b>498</b> in order for instructions to be properly recognized and scheduled for execution. The functional units <b>478</b><sub>0-n </sub>are responsible for determining and implementing their specific control flow operation necessary to perform their requisite function. Thus, other than the instruction issuer <b>498</b>, none of the IEU control units need to have independent knowledge of the control flow processing of an instruction. Together, the instruction issuer unit <b>498</b> and the functional units <b>478</b><sub>0-n </sub>provide the necessary control signal prompting of the functions to be performed by the remaining control flow managing units <b>496</b>, <b>500</b>, <b>520</b>, <b>528</b>, <b>540</b>. Thus, alteration in the particular control flow operation of a functional unit <b>478</b><sub>0-n </sub>does not impact, the control operation of the IEU <b>104</b>. Further,, the functional augmentation, of an existing functional unit <b>478</b><sub>0-n </sub>and even the addition of one or more new functional units <b>478</b><sub>0-n</sub>, such as an extended precision floating point multiplier and extended precision floating point ALU, a fast fourier computation functional unit, and a trigonometric computational unit, require only minor modification of the instruction issuer unit <b>498</b>. The required modifications must provide for recognition of the particular instruction, based on the corresponding instruction field isolated by the EDecode unit <b>490</b>, a correlation of the instruction to the required functional unit <b>478</b><sub>0-n</sub>. Control over the selection of register date, routing of data, instruction completion and retirement remain consistent with the handling of all other instructions executed with respect to all other ones of the functional units <b>478</b><sub>0-n</sub>.</p><p>A) IEU Data Path Detail:</p><p>The central element of the IEU data path is the register file <b>472</b>. Within the IEU data path, however, the present invention provides for a number of parallel data paths optimized generally for specific functions. The two principal data paths are integer and floating point. Within each parallel data path, a portion of the register file <b>472</b> is provided to support the data manipulations occurring within that data path.</p><p>1) Register File Detail:</p><p>The preferred generic architecture of a data path register file is shown in FIG. <b>6</b>A. The data path register file <b>550</b> includes a temporary buffer <b>552</b>, a register file array <b>564</b>, an input selector <b>559</b>, and an output selector <b>556</b>. Data ultimately destined for the register array <b>564</b> is typically first received by the temporary buffer <b>552</b> through a combined data input bus <b>558</b>\u2032. That is, all data directed to-the data path register file <b>550</b> is multiplexed by the input selector <b>559</b> from a number of input buses <b>558</b>, preferably two, onto the input bus <b>558</b>\u2032. Register select and enable control signals provided on the control bus <b>518</b> select the register location for the received data within the temporary buffer <b>552</b>. On retirement of an instruction that produced data stored in the temporary buffer, control signals again provided on the control bus <b>518</b> enable the transfer of the data from the temporary buffer <b>552</b> to a logically corresponding register within the register file array <b>564</b> via the data bus <b>560</b>. However, prior to retirement of the instruction, data stored in the registers of the temporary buffer <b>552</b> may be utilized in the execution of subsequent instructions by routing the temporary buffer stored data to the output data selector <b>556</b> via a bypass portion of the data bus <b>560</b>. The selector <b>556</b>, controlled by a control signal provided via the control bus <b>518</b> selects between data provided from the registers of the temporary buffer <b>552</b> and of the register file array <b>564</b>. The resulting data is provided on the register file output bus <b>563</b>. Also, where an executing instruction will be retired on completion, i.e., the instruction has been executed in-order, the input selector <b>559</b> can be directed to route the result data directly to the register array <b>554</b> via bypass extension <b>558</b>\u2033.</p><p>In accordance with the preferred embodiments of the present invention, each data path register file <b>550</b> permits two simultaneous register operations to occur. Thus, the input bus <b>558</b> provides for two full register width data values to be written to the temporary buffer <b>552</b>. Internally, the temporary buffer <b>552</b> provides a multiplexer array permitting the simultaneous routing of the input data to any two registers within the temporary buffer <b>552</b>. Similarly, internal multiplexers allow any five registers of the temporary buffer <b>552</b> to be selected to output data onto the bus <b>560</b>. The register file array <b>564</b> likewise includes input and output multiplexers allowing two registers to be selected to receive, on bus <b>560</b>, or five to source, via bus <b>562</b>, respective data simultaneously. Finally, the register file output selector <b>556</b> is preferably implemented to allow any five of the ten register data values received via the buses <b>560</b>, <b>562</b> to be simultaneously ouzput on the register file output bus <b>563</b>.</p><p>The register set within the temporary bufLer is generally shown in FIG. <b>6</b>B. The register set <b>552</b>\u2032 consists of eight single word (32 bit) registers IORD, I1RD . . . I7RD. The register set <b>552</b>\u2032 may also be used as a set of four double word registers IORD, IORD+1 (IORD4), I1RD, I1RD+1 (ISRD) . . . I3RD, I3RD+1 (I7RD).</p><p>In accordance with the present invention, rather than provide duplicate registers for each of the registers within the register file array <b>564</b>, the registers in the temporary buffer register set <b>552</b> are referenced by the register rename unit <b>496</b> based on the relative location of the respective instructions within the two IFIFO master registers <b>216</b>, <b>224</b>. Each instruction implemented by the architecture <b>100</b> may reference for output up to two registers, or one double word register, for the destination of data produced by the execution of the instruction. Typically, an instruction will reference only a single output register. Thus, for an instruction two (I<sub>2</sub>) of the eight pending instructions, positionally identified as shown in FIG. <b>6</b>C and that references a single output register, the data destination register I2RD will be selected to receive data produced by the execution of the instruction. Where the data produced by the instruction I<sub>2 </sub>is used by a subsequent instruction, for example, I<sub>5</sub>, the data stored in the I2RD register will be transferred out: via the bus <b>560</b> and the resultant data stored back to the temporary buffer <b>552</b> into the register identified as I5RD. Notably, instruction I<sub>5 </sub>is dependent on instruction I<sub>2</sub>. Instruction I<sub>5 </sub>cannot be executed until the result data from I<sub>2 </sub>is available. However, as can be seen, instruction I<sub>5 </sub>can execute prior to the retirement of instruction I<sub>2 </sub>by obtaining its required input data from the instruction I<sub>2 </sub>data location of the temporary buffer <b>552</b>\u2032.</p><p>Finally, as instruction I<sub>2 </sub>is retired, the data from the register I2RD is written to the register location within the register file array <b>564</b> as determined by the logical position of the instruction at the point of retirement. That is, the retirement control unit <b>500</b> determines the address of the destination registers in the register file array from the register reference field data provided from the EDecode unit <b>490</b> on the control lines <b>510</b>. Once instructions IX have been retired, the values in I4RD-I7RD are shifted into I0RD-I3RD simultaneous with a shift of the IFIFO unit <b>264</b>.</p><p>A complication arises where instruction I<sub>2 </sub>provides a double word result value. In accordance with a preferred embodiment of the present invention, a combination of locations I2RD and I6RD is used to store the data resulting from instruction I<sub>2 </sub>until that instruction is retired or otherwise cancelled. In the preferred embodiment, execution of instructions I<sub>4-7 </sub>are held where a double word output reference by any of the instructions I<sub>0-3 </sub>is detected by the register rename unit <b>496</b>. This allows the entire temporary buffer <b>552</b>\u2032 to be used as a single bank of double word registers. Once instructions I<sub>0-3 </sub>have been retired, the temporary buffer <b>552</b>\u2032 can again be used as two banks of single word registers. Further, the execution of any instruction I<sub>4-7 </sub>is held where a double word output register is required until the instruction has been shifted into a corresponding I<sub>0-3 </sub>location.</p><p>The logical organization of the register file array <b>564</b> is shown in FIGS. 7A and 7B. In accordance with the preferred embodiments of the present invention, the register file array <b>564</b> for the integer data path consists of 40 32-bit wide registers. This set of registers, constituting a register set \u201cA\u201d, is organized as a base register set ra[0 . . . 23] <b>565</b>, a top set of general purpose registers ra[24 . . . 31] <b>566</b>, and a shadow register set of eight general purpose trap registers rt[24 . . . 31]. In normal operation, the general purpose registers ra[0 . . . 31] <b>565</b>, <b>566</b> constitutes the active \u201cA\u201d register set of the register file array for the integer data path.</p><p>As shown in FIG. 7B the trap registers rt[24 . . . 31] <b>567</b> may be swapped into the active register set \u201cA\u201d to allow access along with the active base set of registers ra[0 . . . 23] <b>565</b>. This configuration of the \u201cA\u201d register set is selected upon the acknowledgement of an interrupt or the execution of an exception trap handling routine. This state of the register set \u201cA\u201d is maintained until expressly returned to the state shown in FIG. 7A by the execution of an enable interrupts instruction or execution of a return from trap instruction.</p><p>In the preferred embodiment of the present invention as implemented by the architecture <b>100</b>, the floating point data path utilizes an extended precision register file array <b>572</b> as generally shown in FIG. <b>8</b>. The register file array <b>572</b> consists of 32 registers, rf[0 . . . 31] each having a width of 64 bits. The floating point register file <b>572</b> may also be logically referenced as a \u201cB\u201d set of integer registers rb[0 . . . 31]. In the architecture <b>100</b>, this \u201cB\u201d set of registers is equivalent to the low-order 32 bits of each of the floating point registers rf[0 . . . 31].</p><p>Representing a third data path, a boolean operator register set <b>574</b> is provided, as shown in FIG. 9, to store the logical result of boolean combinatorial operations. This \u201cC\u201d register set <b>574</b> consists of 32 single bit registers, rc[0 . . . 31]. The operation of the boolean register set <b>574</b> is unique in that the results of boolean operations can be directed to any instruction selected register of the boolean register set <b>574</b>. This is in contrast to utilizing a single processor status word register that stores single bit flags for conditions such as equal, not equal, greater than and other simple boolean status values.</p><p>Both the floating point register set <b>572</b> and the boolean register set <b>574</b> are complimented by temporary buffers architecturally identical to the integer temporary buffer <b>552</b> shown in FIG. <b>6</b>B. The essential difference is that the width of the temporary buffer registers is defined to be identical to those of the complimenting register file array <b>572</b>, <b>574</b>; in the preferred implementation, 64 bits and one bit, respectively.</p><p>A number of additional special registers are at least logically present in the register array <b>472</b>. The registers that are physically present in the register array <b>472</b>, as shown in FIG. 7C, include a kernel stack pointer <b>568</b>, processor state register (PSR) <b>569</b>, previous processor state register (PPSR) <b>570</b>, and an array of eight temporary processor state registers (tPSR[0 . . . 7]) <b>571</b>. The remaining special registers are distributed throughout various parts of the architecture <b>100</b>. The special address and data bus <b>354</b> is provided to select and transfer data between the special registers and the \u201cA\u201d and \u201cB\u201d sets of registers. A special register move instruction is provided to select a register from either the \u201cA\u201d or \u201cB\u201d register set, the direction of transfer and to specify the address identifier of a special register.</p><p>The kernel stack pointer register and temporary processor state registers differ from the other special registers. The kernel stack pointer may be accessed through execution of a standard register to register move instruction when in kernel state. The temporary processor state registers are not directly accessible. Rather, this array of registers is used to implement an inheritance mechanism for propagating the value of the processor state register for use by out-of-order executing instructions. The initial propagation value is that of the processor state register: the value provided by the last retired instruction. This initial value is propagated forward through the temporary processor state registers so that any out-of-order executing instruction has access to the value in the positionally corresponding temporary processor state register. The specific nature of an instruction defines the condition code bits, if any, that the instruction is dependent on and may change. Where an instruction is unconstrained by dependencies, register or condition code as determined by the register dependency checker unit <b>494</b> and carry dependency checker <b>492</b>, the instruction can be executed out-of-order. Any modification of the condition code bits of the processor state register are directed to the logically corresponding temporary processor state register. Specifically, only those bits that may change are applied to the value in the temporary processor state register and propagated to all higher order temporary processor state registers. Consequently, every out-of-order executed .instruction executes from a processor state register value modified appropriately by any intervening PSR modifying instructions. Retirement of an instruction only transfers the corresponding temporary processor state registers value to the PSR register <b>569</b>.</p><p>The remaining special registers are described in Table II.</p><p><tables id=\"TABLE-US-00002\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE II</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Special Registers</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"42PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"126PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Special</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Move</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Reg</entry><entry morerows=\"0\" valign=\"top\">R/W</entry><entry morerows=\"0\" valign=\"top\">Description</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PC</entry><entry morerows=\"0\" valign=\"top\">R</entry><entry morerows=\"0\" valign=\"top\">Program Counters: in general, PCs</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">maintain the next address of the</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">currently executing program</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">instruction stream.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IF_PC</entry><entry morerows=\"0\" valign=\"top\">R/W</entry><entry morerows=\"0\" valign=\"top\">IFU Program Counter: the IF_PC</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">maintains the precise next execution</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">address.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PFnPCs</entry><entry morerows=\"0\" valign=\"top\">R</entry><entry morerows=\"0\" valign=\"top\">Prefetch Program Counters: the MBUF,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">TBUF and EBUF PFnPCs maintain the</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">next prefetch instruction addresses</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">for the respective prefetch</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">instruction streams.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">uPC</entry><entry morerows=\"0\" valign=\"top\">R/W</entry><entry morerows=\"0\" valign=\"top\">Micro-Program Counter: maintains the</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">address of the instruction following</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">a procedural instruction. This is</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">the address of the first instruction</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">to be executed upon return from a</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">procedural routine.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">XPC</entry><entry morerows=\"0\" valign=\"top\">R/W</entry><entry morerows=\"0\" valign=\"top\">Interrupt/Exception Program Counter:</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">holds the return address of an</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">interrupt or and exception. The</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">return address is the address of the</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">IF_PC at the time of the trap.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">TBR</entry><entry morerows=\"0\" valign=\"top\">W</entry><entry morerows=\"0\" valign=\"top\">Trap Base Register: base address of</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">a vector table used for trap</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">handling routine dispatching. Each</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">entry is one word long. The trap</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">number, provided by Interrupt Logic</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Unit 363, is used as an index into</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">the table pointed to by this</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">address.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">FTB</entry><entry morerows=\"0\" valign=\"top\">W</entry><entry morerows=\"0\" valign=\"top\">Fast Trap Base Register: base</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">address of an immediate trap</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">handling routine table. Each table</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">entry is 32 words and is used to</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">directly implement a trap handling</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">routine. The trap number, provided</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">by Interrupt Logic Unit 363, times</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">32 is used as an offset into the</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">table pointed to by this address.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PBR</entry><entry morerows=\"0\" valign=\"top\">W</entry><entry morerows=\"0\" valign=\"top\">Procedural Base Register: base</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">address of a vector table used for</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">procedural routine dispatching.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Each entry is one word long, aligned</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">on four word boundaries. The</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">procedure number, provided as a</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">procedural instruction field is</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">used as an index into the table</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">pointed to by this address.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PSR</entry><entry morerows=\"0\" valign=\"top\">R/W</entry><entry morerows=\"0\" valign=\"top\">Processor State Register: maintains</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">the processor status word. Status</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">data bits include: carry, overflow,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">zero, negative, processor mode,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">current interrupt level, procedural</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">routine being executed, divide by</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0, overflow exception, hardware</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">function enables, procedural enable,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">interrupt enable.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PPSR</entry><entry morerows=\"0\" valign=\"top\">R/W</entry><entry morerows=\"0\" valign=\"top\">Previous Processor State Register:</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">loaded from the PSR on successful</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">completion of an instruction or when</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">an interrupt or trap is taken.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">CSR</entry><entry morerows=\"0\" valign=\"top\">R/W</entry><entry morerows=\"0\" valign=\"top\">Compare State (Boolean) Register:</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">the boolean register set accessible</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">as a single word.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">PCSR</entry><entry morerows=\"0\" valign=\"top\">R/W</entry><entry morerows=\"0\" valign=\"top\">Previous Compare State Register:</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">loaded from the CSR on successful</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">completion of an instruction or when</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">an interrupt or trap is taken.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>2) Integer Data Path Detail:</p><p>The integer data path of the IEU <b>104</b>, constructed in accordance with the preferred embodiment of the present invention, is shown in FIG. <b>10</b>. For purposes of clarity, the many control path connections to the integer data path <b>580</b> are not shown. Those connections are defined with respect to FIG. <b>5</b>.</p><p>Input data for the data path <b>580</b> is obtained from the alignment units <b>582</b>, <b>584</b> and the integer load/store unit <b>586</b>. Integer immediate data values, originally provided as an instruction embedded data field are obtained from the operand unit <b>470</b> via a bus <b>588</b>. The alignment unit <b>582</b> operates to isolate the integer data value and provide the resulting value onto the output bus <b>590</b> to a multiplexer <b>592</b>. A second input to the multiplexer <b>592</b> is the special register address and data bus <b>354</b>.</p><p>Immediate operands obtained from the instruction stream are also obtained from the operand unit <b>470</b> via the data bus <b>594</b>. These values are again right justified by the alignment unit <b>584</b> before provision onto an output bus <b>596</b>.</p><p>The integer load/store unit <b>586</b> communicates bi-directionally via the external data bus <b>598</b> with the CCU <b>106</b>. Inbound data to the IEU <b>104</b> is transferred by the integer load/store unit <b>586</b> onto the input data bus <b>600</b> to an input latch <b>602</b>. Data output from the multiplexer <b>592</b> and latch <b>602</b> are provided on the multiplexer input buses <b>604</b>, <b>606</b> of a multiplexer <b>608</b>. Data from the functional unit output bus <b>482</b>\u2032 is also received by the multiplexer <b>608</b>. This multiplexer <b>608</b>, in the preferred embodiments of the architecture <b>100</b>, provides for two simultaneous data paths to the output multiplexer buses <b>610</b>. Further, the transfer of data through the multiplexer <b>608</b> can be completed within each half cycle of the system clock. Since most instructions implemented by the architecture <b>100</b> utilize a single destination register, a maximum of four instructions can provide data to the temporary buffer <b>612</b> during each system clock cycle.</p><p>Data from the temporary buffer <b>612</b> can be transferred to an integer register file array <b>614</b>, via temporary register output buses <b>616</b> or to a output multiplexer <b>620</b> via alternate temporary buffer register buses <b>618</b>. Integer register array output buses <b>622</b> permit the transfer of integer register data to the multiplexer <b>620</b>. The output buses connected to the temporary buffer <b>612</b> and integer register file array <b>614</b> each permit five register values to be output simultaneously. That is, two instructions referencing a total of up to five source registers can be issued simultaneously. The temporary buffer <b>612</b>, register file array <b>614</b> and multiplexer <b>620</b> allow outbound register data transfers to occur every half system clock cycle. Thus, up to four integer and floating point instructions may be issued during each clock cycle.</p><p>The multiplexer <b>620</b> operates to select outbound register data values from the register file array <b>614</b> or directly from the temporary buffer <b>612</b>. This allows out-of-order executed instructions with dependencies on prior out-of-order executed instructions to be executed by the IEU <b>104</b>. This facilitates the twin goals of maximizing the execution through-put capability of the IEU integer data path by the out-of-order execution of pending instructions while precisely segregating out-of-order data results from data results produced by instructions that have been executed and retired. Whenever an interrupt or other exception condition occurs that requires the precise state of the machine to be restored, the present invention allows the data values present in the temporary buffer <b>612</b> to be simply cleared. The register file array <b>614</b> is therefore left to contain precisely those data values produced only by the execution of instructions completed and retired prior to the occurrence of the interrupt or other exception condition.</p><p>The up to five register data values selected during each half system clock cycle operation of the multiplexer <b>620</b> are provided via the multiplexer output buses <b>624</b> to an integer bypass unit <b>626</b>. This bypass unit <b>626</b> is, in essence, a parallel array of multiplexers that provide for the routing of data presented at any of its inputs to any of its outputs. The bypass unit <b>626</b> inputs include the special register addressed data value or immediate integer value via the output bus <b>604</b> from the multiplexer <b>592</b>, the up to five register data values provided on the buses <b>624</b>, the load operand data from the integer load/store unit <b>586</b> via the double integer bus <b>600</b>, the immediate operand value obtained from the alignment unit <b>584</b> via its output bus <b>596</b>, and, finally, a bypass data path from the functional unit output bus <b>482</b>\u2032. This bypass data path, and the data bus <b>482</b>\u2032, provides for the simultaneous transfer of four register values per system clock cycle.</p><p>Data is output by the bypass unit <b>626</b> onto an integer bypass bus <b>628</b> that is connected to the floating point data path, to two operand data buses providing for the transfer out of up to five register data values simultaneously, and a store data bus <b>632</b> that is used to provide data to the integer load/store unit <b>586</b>.</p><p>The functional unit distribution bus <b>480</b> is implemented through the operation of a router unit <b>634</b>. Again, the router unit <b>634</b> is implemented by a parallel array of multiplexers that permit five register values received at its inputs to be routed to the functional units provided in the integer data path. Specifically, the router unit <b>634</b> receives the five register data values provided via the buses <b>630</b> from the bypass unit <b>626</b>, the current IF_PC address value via the address bus <b>352</b> and the control flow offset value determined by the PC control unit <b>362</b> and as provided on the lines <b>378</b>\u2032. The router unit <b>634</b> may optionally receive, via the data bus <b>636</b> an operand data value sourced from a bypass unit provided within the floating point data path.</p><p>The register data values received by the router unit <b>634</b> may be transferred onto the special register address and data bus <b>354</b> and to the functional units <b>640</b>, <b>642</b>, <b>644</b>. Specifically, the router unit <b>634</b> is capable of providing up to three register operand values to each of the functional units <b>640</b>, <b>642</b>, <b>644</b> via router output buses <b>646</b>, <b>648</b>, <b>650</b>. Consistent with the general architecture of the architecture <b>100</b>, up to two instructions could be simultaneously issued to the functional units <b>640</b>, <b>642</b>, <b>644</b>. The preferred embodiment of the present invention provides for three dedicated integer functional units, implementing respectively a programmable shift function and two arithmetic logic unit functions.</p><p>An ALUO functional unit <b>644</b>, ALU<b>1</b> functional unit <b>642</b> and shifter functional unit <b>640</b> provide respective output register data onto the functional unit bus <b>482</b>\u2032. The output data produced by the ALU<b>0</b> and shifter functional unit <b>644</b>, <b>640</b> are also provided onto a shared integer functional unit bus <b>650</b> that is coupled into the floating point data path. A similar floating point functional unit output value data bus <b>652</b> is provided from the floating point data path to the functional unit output bus <b>482</b>\u2032.</p><p>The ALU<b>0</b> functional unit <b>644</b> is used also in the generation of virtual address values in support of both the prefetch operations of the IFU <b>102</b> and data operations of the integer load/store unit <b>586</b>. The virtual address value calculated by the ALU<b>0</b> functional unit <b>644</b> is provided onto an output bus <b>654</b> that connects to both the target address bus <b>346</b> of the IFU <b>102</b> and to the CCU <b>106</b> to provide the execution unit physical address (EX PADDR). A latch <b>656</b> is provided to store the virtualizing portion of the address produced by the ALU<b>0</b> functional unit <b>644</b>. This virtualizing portion of the address is provided onto an output bus <b>658</b> to the VMU <b>108</b>.</p><p>3) Floating Point Data Path Detail:</p><p>Referring now to FIG. 11, the floating point data path <b>660</b> is shown. Initial data is again received from a number of sources including the immediate integer operand bus <b>588</b>, immediate operand bus <b>594</b> and the special register address data bus <b>354</b>. The final source of external data is a floating point load/store unit <b>662</b> that is coupled to the CCU <b>106</b> via the external data bus <b>598</b>.</p><p>The immediate integer operand is received by an alignment unit <b>664</b> that functions to right justify the integer data field before submission to a multiplexer <b>666</b> via an alignment output data bus <b>668</b>. The multiplexer <b>666</b> also receives the special register address data bus <b>354</b>. Immediate operands are provided to a second alignment unit <b>670</b> for right justification before being provided on an output bus <b>672</b>. Inbound data from the floating point load/store unit <b>662</b> is received by a latch <b>674</b> from a load data bus <b>676</b>. Data from the multiplexer <b>666</b>, latch <b>674</b> and a functional unit data return bus <b>482</b>\u2033 is received on the inputs of a multiplexer <b>678</b>. The multiplexer <b>678</b> provides for selectable data paths sufficient to allow two register data values to be written to a temporary buffer <b>680</b>, via the multiplexer output buses <b>682</b>, each half cycle of the system clock. The temporary buffer <b>680</b> incorporates a register set logically identical to the temporary buffer <b>552</b>\u2032 as shown in FIG. <b>6</b>B. The temporary buffer <b>680</b> further provides for up to five register data values to be read from the temporary buffer <b>680</b> to a floating point register file array <b>684</b>, via data buses <b>686</b>, and to an output multiplexer <b>688</b> via output data buses <b>690</b>. The multiplexer <b>688</b> also receives, via data buses <b>692</b>, up to five register data values from the floating point register file array <b>684</b> simultaneously. The multiplexer <b>688</b> functions to select up to five register data values for simultaneous transfer to a bypass unit <b>694</b> via data buses <b>696</b>. The bypass unit <b>694</b> also receives the immediate operand value provided by the alignment unit <b>670</b> via the data bus <b>672</b>, the output data bus <b>698</b> from the multiplexer <b>666</b>, the load data bus <b>676</b> and a data bypass extension of the functional unit data return bus <b>482</b>\u2033. The bypass unit <b>694</b> operates to select up to five simultaneous register operand data values for output onto the bypass unit output buses <b>700</b>, a store data bus <b>702</b> connected to the floating point load/store unit <b>662</b>, and the floating point bypass bus <b>636</b> that connects to the router unit <b>634</b> of the integer data path <b>580</b>.</p><p>A floating point router unit <b>704</b> provides for simultaneous selectable data paths between the bypass unit output buses <b>700</b> and the integer data path bypass bus <b>628</b> and functional unit input buses <b>706</b>, <b>708</b>, <b>710</b> coupled to the respective functional units <b>712</b>, <b>714</b>, <b>716</b>. Each of the input buses <b>706</b>, <b>708</b>, <b>710</b>, in accordance with the preferred embodiment of the architecture <b>100</b>, permits the simultaneous transfer of up to three register operand data values to each of the functional unit <b>712</b>, <b>714</b>, <b>716</b>. The output buses of these functional units <b>712</b>, <b>714</b>, <b>716</b> are coupled to the functional unit data return bus <b>482</b>\u2033 for returning data to the register file input multiplexer <b>678</b>. The integer data path functional unit output bus <b>650</b> may also be provided to connect to the functional unit data return bus <b>4826</b>. The architecture <b>100</b> does provide for a connection of the functional unit output buses of a multiplier functional unit <b>712</b> and a floating point ALU <b>714</b> to be coupled via the floating point data path functional unit bus <b>652</b> to the functional unit data return bus <b>4821</b> of the integer data path <b>580</b>.</p><p>4) Boolean Register Data Path Detail:</p><p>The boolean operations data path <b>720</b> is shown in FIG. <b>12</b>. This data path <b>720</b> is utilized in support of the execution of essentially two types of instructions. The first type is an operand comparison instruction where two operands, selected from the integer register sets, floating point register sets or provided as immediate operands, are compared by subtraction in one of the ALU functional units of the integer and floating point data paths. Comparison is performed by a subtraction operation by any of the ALU functional units <b>642</b>, <b>644</b>, <b>714</b>, <b>716</b> with the resulting sign and zero status bits being provided to a combined input selector and comparison operator unit <b>722</b>. This unit <b>722</b>, in response to instruction identifying control signals received from the EDecode unit <b>490</b>, selects the output of an ALU functional unit <b>642</b>, <b>644</b>, <b>714</b>, <b>716</b> and combines the sign and zero bits to extract a boolean comparison result value. An output bus <b>723</b> allows the results of the comparison operation to be transferred simultaneously to an input multiplexer <b>726</b> and a bypass unit <b>742</b>. As in the integer and floating point data paths, the bypass unit <b>742</b> is implemented as a parallel array of multiplexers providing multiple selectable data paths between the inputs of the bypass unit <b>742</b> to multiple outputs. The other inputs of the bypass unit <b>742</b> include a boolean operation result return data bus <b>724</b> and two boolean operands on data buses <b>744</b>. The bypass unit <b>742</b> permits boolean operands representing up to two simultaneously executing boolean instructions to be transferred to a boolean operation functional unit <b>746</b>, via operand buses <b>748</b>. The bypass unit <b>742</b> also permits transfer of up to two single bit boolean operand bits (CF<b>0</b>, CF<b>1</b>) to be simultaneously provided on the control flow result control lines <b>750</b>, <b>752</b>.</p><p>The remainder of the boolean operation data path <b>720</b> includes the input multiplexer <b>726</b> that receives as its inputs, the comparison and the boolean operation result values provided on the comparison result bus <b>723</b> and a boolean result bus <b>724</b>. The bus <b>724</b> permits up to two simultaneous boolean result bits to be transferred to the multiplexer <b>726</b>. In addition, up to two comparison result bits may be transferred via the bus <b>723</b> to the multiplexer <b>726</b>. The multiplexer <b>726</b> permits any two single bits presented at the multiplexer inputs to be transferred via the multiplexer output buses <b>730</b> to a boolean operation temporary buffer <b>728</b> during each half cycle of the system clock. The temporary buffer <b>728</b> is logically equivalent to the temporary buffer <b>552</b>\u2032, as shown in FIG. 6B, though differing in two significant respects. The first respect is that each register entry in the temporary buffer <b>728</b> consists of a single bit. The second distinction is that only a single register is provided for each of the eight pending instruction slots, since the result of a boolean operation is, by definition, fully defined by a single result bit.</p><p>The temporary buffer <b>728</b> provides up to four output operand values simultaneously. This allows the simultaneous execution of two boolean instructions, each requiring access to two source registers. The four boolean register values may be transferred during each half cycle of the system clock onto the operand buses <b>736</b> to a multiplexer <b>738</b> or to a boolean register file array <b>732</b> via the boolean operand data buses <b>734</b>. The boolean register file array <b>732</b>, as logically depicted in FIG. 9, is a single 32 bit wide data register that permits any separate combination of up to four single bit locations to be modified with data from the temporary buffer <b>728</b> and read from the boolean register file array <b>732</b> onto the output buses <b>740</b> during each half cycle of the system clock. The multiplexer <b>738</b>, provides for any two pairs of boolean operands received at its inputs via the buses <b>736</b>, <b>740</b> to be transferred onto the operand output buses <b>744</b> to the bypass unit <b>742</b>.</p><p>The boolean operation functional unit <b>746</b> is capable of performing a wide range of boolean operations on two source values. In the case of comparison instructions, the source values are a pair of operands obtained from any of the integer and floating point register sets and any immediate operand provided to the IEU <b>104</b>, and, for a boolean instruction, any two of boolean register operands. Tables III and IV identify the logical comparison operations provided by the preferred embodiment of the architecture <b>100</b>. Table V identifies the direct boolean operations provided by the preferred implementation of the architecture <b>100</b>. The instruction condition codes and function codes specified in the Tables III-V represent a segment of the corresponding instructions. The instruction also provides an identification of the source pair of operand registers and the destination boolean register for storage of the corresponding boolean operation result.</p><p><tables id=\"TABLE-US-00003\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE III</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Integer Comparison</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"77PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"28PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Instruction</entry><entry morerows=\"0\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Condition*</entry><entry morerows=\"0\" valign=\"top\">SymbolCondition Code</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"28PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"right\" colname=\"2\" colwidth=\"35PT\"></colspec><colspec align=\"left\" colname=\"3\" colwidth=\"70PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 greater than rs2</entry><entry morerows=\"0\" valign=\"top\">&gt;</entry><entry morerows=\"0\" valign=\"top\">0000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 greater than</entry><entry morerows=\"0\" valign=\"top\">&gt;=</entry><entry morerows=\"0\" valign=\"top\">0001</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">or equal to rs2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 less than rs2</entry><entry morerows=\"0\" valign=\"top\">&lt;</entry><entry morerows=\"0\" valign=\"top\">0010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 less than</entry><entry morerows=\"0\" valign=\"top\">&lt;=</entry><entry morerows=\"0\" valign=\"top\">0011</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">or equal to rs2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 unequal to rs2</entry><entry morerows=\"0\" valign=\"top\">!=</entry><entry morerows=\"0\" valign=\"top\">0100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 equal to rs2</entry><entry morerows=\"0\" valign=\"top\">==</entry><entry morerows=\"0\" valign=\"top\">0101</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">reserved</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">0110</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">unconditional</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"left\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" valign=\"top\">*rs = register source </entry></row></tbody></tgroup></table></tables></p><p><tables id=\"TABLE-US-00004\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE IV</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Floating Point Comparison</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"105PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"70PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Instruction</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Condition</entry><entry morerows=\"0\" valign=\"top\">Symbol</entry><entry morerows=\"0\" valign=\"top\">Cond. Code</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 greater than rs2</entry><entry morerows=\"0\" valign=\"top\">&gt;</entry><entry morerows=\"0\" valign=\"top\">0000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 greater than or equal to rs2</entry><entry morerows=\"0\" valign=\"top\">&gt;=</entry><entry morerows=\"0\" valign=\"top\">0001</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 less than rs2</entry><entry morerows=\"0\" valign=\"top\">&lt;</entry><entry morerows=\"0\" valign=\"top\">0010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 less than or equal to rs2</entry><entry morerows=\"0\" valign=\"top\">&lt;=</entry><entry morerows=\"0\" valign=\"top\">0011</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 unequal to rs2</entry><entry morerows=\"0\" valign=\"top\">!=</entry><entry morerows=\"0\" valign=\"top\">0100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 equal to rs2</entry><entry morerows=\"0\" valign=\"top\">==</entry><entry morerows=\"0\" valign=\"top\">0101</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">unordered</entry><entry morerows=\"0\" valign=\"top\">?</entry><entry morerows=\"0\" valign=\"top\">1000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">unordered or rs1 greater than rs2</entry><entry morerows=\"0\" valign=\"top\">?&gt;</entry><entry morerows=\"0\" valign=\"top\">1001</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">unordered, rs1 greater than</entry><entry morerows=\"0\" valign=\"top\">?&gt;=</entry><entry morerows=\"0\" valign=\"top\">1010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">or equal to rs2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">unordered or rs1 less than rs2</entry><entry morerows=\"0\" valign=\"top\">?&lt;</entry><entry morerows=\"0\" valign=\"top\">1011</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">unordered, rs1 less than</entry><entry morerows=\"0\" valign=\"top\">?&lt;=</entry><entry morerows=\"0\" valign=\"top\">1100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">or equal to rs2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">unordered or rs1 equal to rs2</entry><entry morerows=\"0\" valign=\"top\">?=</entry><entry morerows=\"0\" valign=\"top\">1101</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">reserved</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1110-1111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p><tables id=\"TABLE-US-00005\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE IV</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Floating Point Comparison</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"4\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"105PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"28PT\"></colspec><colspec align=\"center\" colname=\"3\" colwidth=\"70PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Instruction</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Condition</entry><entry morerows=\"0\" valign=\"top\">Symbol</entry><entry morerows=\"0\" valign=\"top\">Cond. Code</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 greater than rs2</entry><entry morerows=\"0\" valign=\"top\">&gt;</entry><entry morerows=\"0\" valign=\"top\">0000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 greater than or equal to rs2</entry><entry morerows=\"0\" valign=\"top\">&gt;=</entry><entry morerows=\"0\" valign=\"top\">0001</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 less than rs2</entry><entry morerows=\"0\" valign=\"top\">&lt;</entry><entry morerows=\"0\" valign=\"top\">0010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 less than or equal to rs2</entry><entry morerows=\"0\" valign=\"top\">&lt;=</entry><entry morerows=\"0\" valign=\"top\">0011</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 unequal to rs2</entry><entry morerows=\"0\" valign=\"top\">!=</entry><entry morerows=\"0\" valign=\"top\">0100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">rs1 equal to rs2</entry><entry morerows=\"0\" valign=\"top\">==</entry><entry morerows=\"0\" valign=\"top\">0101</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">unordered</entry><entry morerows=\"0\" valign=\"top\">?</entry><entry morerows=\"0\" valign=\"top\">1000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">unordered or rs1 greater than rs2</entry><entry morerows=\"0\" valign=\"top\">?&gt;</entry><entry morerows=\"0\" valign=\"top\">1001</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">unordered, rs1 greater than</entry><entry morerows=\"0\" valign=\"top\">?&gt;=</entry><entry morerows=\"0\" valign=\"top\">1010</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">or equal to rs2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">unordered or rs1 less than rs2</entry><entry morerows=\"0\" valign=\"top\">?&lt;</entry><entry morerows=\"0\" valign=\"top\">1011</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">unordered, rs1 less than</entry><entry morerows=\"0\" valign=\"top\">?&lt;=</entry><entry morerows=\"0\" valign=\"top\">1100</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">or equal to rs2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">unordered or rs1 equal to rs2</entry><entry morerows=\"0\" valign=\"top\">?=</entry><entry morerows=\"0\" valign=\"top\">1101</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">reserved</entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">1110-1111</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"3\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>B) Load/Store Control Unit;</p><p>An exemplary load/store unit <b>760</b> is shown in FIG. <b>13</b>. Although separately shown in the data paths <b>580</b>, <b>660</b>, the load/store units <b>586</b><b>662</b> are preferably implemented as a single shared load/store unit <b>760</b>. The interface from a respective data path <b>580</b>, <b>660</b> is via an address bus <b>762</b> and load and store data buses <b>764</b> (<b>600</b>, <b>676</b>), <b>766</b> (<b>632</b>, <b>702</b>).</p><p>The address utilized by the load/store unit <b>760</b> is a physical address as opposed to the virtual address utilized by the IFU <b>102</b> and the remainder of the IEU <b>104</b>. While the IFU <b>102</b> operates on virtual addresses, relying on coordination between the CCU <b>106</b> and VMU <b>108</b> to produce a physical address, the IEU <b>104</b> requires the load/store unit <b>760</b> to operate directly in a physical address mode. This requirement is necessary to insure data integrity in the presence of out-of-order executed instructions that may involve overlapping physical address data load and store operations and in the presence of out-of-order data returns from the CCU <b>106</b> to the load/store unit <b>760</b>. In order to insure data integrity, the load/store unit <b>760</b> buffers data provided by store instructions until the store instruction is retired by the IEU <b>104</b>. Consequently, store data buffered by the load store unit <b>760</b> may be uniquely present only in the load/store unit <b>760</b>. Load instructions referencing the same physical address as executed but not retired store instructions are delayed until the store instruction is actually retired. At that point the store data may be transferred to the CCU <b>106</b> by the load/store unit <b>760</b> and then immediately loaded back by the execution of a CCU data load operation.</p><p>Specifically, full physical addresses are provided from the VMU <b>108</b> onto the load/store address bps <b>762</b>. Load addresses are, in general, stored in load address registers <b>768</b><sub>0-3</sub>. Store addresses are latched into store address registers <b>770</b><sub>3-0</sub>. A load/store control unit <b>774</b> operates in response to control signals received from the instruction issuer unit <b>498</b> in order to coordinate latching of load and store addresses into the registers <b>768</b><sub>3-0</sub>, <b>770</b><sub>3-0</sub>. The load/store control unit <b>774</b> provides control signals on control lines <b>778</b> for latching load addresses and on, control lines <b>780</b> for latching store addresses. Store data is latched simultaneous with the latching of store addresses in logically corresponding slots of the store data register set <b>782</b><sub>3-0</sub>. A 4\u00d74\u00d732 bit wide address comparator unit <b>772</b> is simultaneously provided with each of the addresses in the load and store address registers <b>768</b><sub>3-0</sub>, <b>770</b><sub>3-0</sub>. The execution of a full matrix address comparison during each half cycle of the system clock is controlled by the load/store control unit <b>774</b> via control lines <b>776</b>. The existence and logical location of a load address that matches a store address is provided via control signals returned to the load store control unit <b>774</b> via control lines <b>776</b>.</p><p>Where a load address is provided from the VMU <b>108</b> and there are no pending stores, the load address is bypassed directly from the bus <b>762</b> to an address selector <b>786</b> concurrent with the initiation of a CCU load operation. However, where store data is pending, the load address will be latched in an available load address latch <b>768</b><sub>0-3</sub>. Upon receipt of a control signal from the retirement control unit <b>500</b>, indicating that the corresponding store data instruction is retiring, the load/store control unit <b>774</b> initiates a CCU data transfer operation by arbitrating, via control lines <b>784</b> for access to the CCU <b>106</b>. When the CCU <b>106</b> signals ready, the load/store control unit <b>774</b> directs the selector <b>786</b> to provide a CCU physical address onto the CCU PADDR address bus <b>788</b>. This address is obtained from the corresponding store register <b>770</b><sub>3-0 </sub>via the address bus <b>790</b>. Data from the corresponding store data register <b>782</b>. is provided onto the CCU data bus <b>792</b>.</p><p>Upon issuance of load instruction by the instruction issuer <b>498</b>, the load store control unit <b>774</b> enables one of the load address latches <b>768</b><sub>3-0 </sub>to latch the requested load address. The specific latch <b>768</b>. selected logically corresponds to the position of the load instruction in the relevant instruction set. The instruction issuer <b>498</b> provides the load/store control unit <b>774</b> with a five bit vector identifying the load instruction within either of the two possible pending instruction sets. Where the comparator <b>772</b> does not identify a matching store address, the load address is routed via an address bus <b>794</b> to the selector <b>786</b> for output onto the CCU PADDR address bus <b>788</b>. Provision of the address is performed in concert with CCU request and ready control signals being exchanged between the load/store control unit <b>774</b> and CCU <b>106</b>. An execution ID value (ExID) is also prepared and issued by the load/store control unit <b>774</b> to the CCU <b>106</b> in order to identify the load request when the CCU <b>106</b> subsequently returns the requested data including ExID value. This ID value consists of a four bit vector utilizing unique bits to identify the respective load address latch <b>768</b><sub>0-3 </sub>from which the current load request is generated. A fifth bit is utilized to identify the instruction set that contains the load instruction. The ID value is thus the same as the bit vector provided with the load request from the instruction issuer unit <b>498</b>.</p><p>On subsequent signal from the CCU <b>106</b> to the load/store control unit <b>774</b> of the availability of prior requested load data, the load/store control unit <b>774</b> enables an alignment unit to receive the data and provide it on the load data bus <b>764</b>. An alignment unit <b>798</b> operates to right justify the load data.</p><p>Simultaneously with the return of data from the CCU <b>106</b>, the load/store control unit <b>774</b> receives the ExID value from the CCU <b>106</b>. The load/store control unit <b>774</b>, in turn, provides a control signal to the instruction issuer unit <b>498</b> identifying that load data is being provided on the load data bus <b>764</b> and, further, returns a bit vector identifying the load instruction for which the load data is being returned.</p><p>C) IEU Control Path Detail:</p><p>Referring again to FIG. 5, the operation of the IEU control path will now be described in detail with respect to the timing diagram provided in FIG. <b>14</b>. The timing of the execution of instructions represented in FIG. 14 is exemplary of the operation of the present invention, and not exhaustive of execution timing permutations.</p><p>The timing diagram of FIG. 14 shows a sequence of processor system clock cycles, P<sub>0-6</sub>. Each processor cycle begins with an internal T Cycle, T<sub>0</sub>, There are two T cycles per processor cycle in a preferred embodiment of the present invention as provided for by the architecture <b>100</b>.</p><p>In processor cycle zero, the IFU <b>102</b> and the VMU <b>108</b> operate to generate a physical address. The physical address is provided to the CCU <b>106</b> and an instruction cache access operation is initiated. Where the requested instruction set is present .in the instruction cache <b>132</b>, an instruction set is returned to the IFU <b>102</b> at about the mid-point of processor cycle one. The IFU <b>102</b> then manages the transfer of the instruction set through the prefetch-unit <b>260</b> and IFIFO <b>264</b>, whereupon the instruction set is first presented to the IEU <b>104</b> for execution.</p><p>1) EDecode Unit Detail:</p><p>The EDecode unit <b>490</b> receives the full instruction set in parallel for decoding prior to the conclusion of processor cycle one. The EDecode unit <b>490</b>, in the preferred architecture <b>100</b>, is implemented as a pure combinatorial logic block that provides for the direct parallel decoding of all valid instructions that are received via the bus <b>124</b>. Each type of instruction recognized by the architecture <b>100</b>, including the specification of the instruction, register requirements and resource needs are identified in Table VI.</p><p><tables id=\"TABLE-US-00006\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"1\" colsep=\"0\" rowsep=\"0\"><colspec align=\"center\" colname=\"1\" colwidth=\"217PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\">TABLE VI</entry></row></thead><tbody valign=\"top\"><row><entry align=\"center\" morerows=\"0\" nameend=\"1\" namest=\"1\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\">Instruction/Specifications</entry></row></tbody></tgroup><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"14PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"84PT\"></colspec><colspec align=\"left\" colname=\"2\" colwidth=\"119PT\"></colspec><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Instruction</entry><entry morerows=\"0\" valign=\"top\">Control and Operand Information*</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Move Register</entry><entry morerows=\"0\" valign=\"top\">Logical/Arithmetic Function Code:</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">to Register</entry><entry morerows=\"0\" valign=\"top\">specifies Add, Subtract, Multiply,</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">shift, etc.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Destination Register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Set PSR only</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Source Register 1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Source Register 2 or Immediate</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">constant value</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Register Set A/B select</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Move Immediate</entry><entry morerows=\"0\" valign=\"top\">Destination Register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">to Register</entry><entry morerows=\"0\" valign=\"top\">Immediate Integer or Floatinq</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Point constant value</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Register Set A/B select</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Load/Store</entry><entry morerows=\"0\" valign=\"top\">Operation Function Code: specifies</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Register</entry><entry morerows=\"0\" valign=\"top\">Load or Store, use immediate</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">value, base and immediate</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">value, or base and offset</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Source/Destination Register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Base Register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Index Register or Immediate</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">constant value</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Register Set A/B select</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Immediate Call</entry><entry morerows=\"0\" valign=\"top\">Signed Immediate Displacement</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Control Flow</entry><entry morerows=\"0\" valign=\"top\">Operation Function Code: specifies</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">branch type and triggering</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">condition</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Base Register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Index Register, Immediate constant</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">displacement value, or Trap</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Number</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Register Set A/B select</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Special Register</entry><entry morerows=\"0\" valign=\"top\">Operation Function Code: specifies</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Move</entry><entry morerows=\"0\" valign=\"top\">move to/from special/integer</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Special Register Address</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Identifier</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Source/Destination Register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Register Set A/B select</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Convert Integer</entry><entry morerows=\"0\" valign=\"top\">Operation Function Code: specifies</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Move</entry><entry morerows=\"0\" valign=\"top\">type of floating point to</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">integer conversion</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Source/Destination Register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Register Set A/B select</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Boolean Functions</entry><entry morerows=\"0\" valign=\"top\">Boolean Function Code: specifies</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">And, Or, etc.</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Destination boolean register</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Source Register 1</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Source Register 2</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Register Set A/B select</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Extended Procedure</entry><entry morerows=\"0\" valign=\"top\">Procedure specitier: specifies</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">address offset from</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">procedural base value</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Operation: value passed to</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">procedure routine</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Atomic Procedure</entry><entry morerows=\"0\" valign=\"top\">Procedure specifier: specifies</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">address value</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"left\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" valign=\"top\">*instruction includes these fields in addition to a field that decodes to identify the instruction. </entry></row></tbody></tgroup></table></tables></p><p>The EDecode unit <b>490</b> decodes each instruction of an instruction set in parallel. The resulting identification of instructions, instruction functions, register references and function requirements are made available on the outputs of the EDecode unit <b>490</b>. This information is regenerated and latched by the EDecode unit <b>490</b> during each half processor cycle until all instructions in the instruction set are retired. Thus, information regarding all eight pending instructions is constantly maintained at the output of the EDecode unit <b>490</b>. This information is presented in the form of eight element bit vectors where the bits or sub-fields of each vector logically correspond to the physical location of the corresponding instruction within the two pending instruction sets. Thus, eight vectors are provided via the control lines <b>502</b> to the carry checker <b>492</b>, where each vector specifies whether the corresponding instruction affects or is dependent on the carry bit of the processor status word. Eight vectors are provided via the control lines <b>510</b> to identify the specific nature of each instruction and the function unit requirements. Eight vectors are provided via the control lines <b>506</b> specifying the register references used by each of the eight pending instructions. These vectors are provided prior to the end of processor cycle one.</p><p>2) Carry Checker Unit Detail:</p><p>The carry checker unit <b>492</b> operates in parallel with the dependency check unit <b>494</b> during the data dependency phase of operation shown in FIG. <b>14</b>. The carry check unit <b>492</b> is implemented in the preferred architecture <b>100</b> as pure combinatorial logic. Thus, during each iteration of operation by the carry checker unit <b>492</b>, all eight instructions are considered with respect to whether they modify the carry flag of the processor state register. This is necessary in order to allow the out-of-order execution of instructions that depend on the state of the carry bit as set by prior instructions. Control signals provided on the control lines <b>504</b> allow the carry check unit <b>492</b> to identify the specific instructions that are dependant on the execution of prior instructions with respect to the carry flag.</p><p>In addition, the carry checker unit <b>492</b> maintains a temporary copy of the carry bit for each of the eight pending instructions. For those instructions that do not modify the carry bit, the carry checker unit <b>492</b> propagates the carry bit to the next instruction forward in the order of the program instruction stream. Thus, an out-of-order executed instruction that modifies the carry bit can-be executed and, further, a subsequent instruction that is dependant on such an out-of-order executed instruction may also be allowed to execute, though subsequent to the instruction that modifies the carry bit. Further, maintenance of the carry bit by the carry checker unit <b>492</b> facilitates out-of-order execution in that any exception occurring prior to the retirement of those instructions merely requires the carry checker unit <b>492</b> to clear the internal temporary carry bit register. Consequently, the processor status register is unaffected by the execution of out-of-order executed instructions. The temporary bit carry register maintained by the carry checker unit <b>492</b> is updated upon completion of each out-of-order executed instruction. Upon retirement of out-of-order executed instructions, the carry bit corresponding to the last retired instruction in the program instruction stream is transferred to the carry bit location of the processor status register.</p><p>3) Data Dependency Checker Unit Detail:</p><p>The data dependency checker unit <b>494</b> receives the eight register reference identification vectors from the EDecode unit <b>490</b> via the control lines <b>506</b>. Each register reference is indicated by a five bit value, suitable for identifying any one of <b>32</b> registers at a time, and a two bit value that identifies the register bank as located within the \u201cA\u201d, \u201cB\u201d or boolean register sets. The floating point register set is equivalently identified as the \u201cB\u201d register set. Each instruction may have up to three register reference fields: two source register fields and one destination. Although some instructions, most notably the move register to register instructions, may specify a destination register, an instruction bit field recognized by the EDecode unit <b>490</b> may signify that no actual output: data is to be produced. Rather, execution of the instruction is only for the purpose of determining an alteration of the value of the processor status register.</p><p>The data dependency checker <b>494</b>, implemented again as pure combinatorial logic in the preferred architecture <b>100</b>, operates to simultaneously determine dependencies between source register references of instructions subsequent in the program instruction stream and destination register references of relatively prior instructions. A bit array is produced by the data dependency checker <b>494</b> that identifies not only which instructions are dependant on others, but also the registers upon which each dependency arises.</p><p>The carry and register data dependencies are identified shortly after the beginning of the second processor cycle.</p><p>4) Register Rename Unit Detail:</p><p>The register rename unit <b>496</b> receives the identification of the register references of all eight pending instructions via the control lines <b>506</b>, and register dependencies via the control lines <b>508</b>. A matrix of eight elements is also received via the control lines <b>532</b> that identify those instructions within the current set of pending instructions that have been executed (done). From this information, the register rename unit <b>496</b> provides an eight element array of control signals to the instruction issuer unit <b>498</b> via the control lines <b>512</b>. The control information so provided reflects the determination made by the register rename unit <b>496</b> as to which of the currently pending instructions, that have not already been executed, are now available to be executed given the current set of identified data dependencies. The register rename unit <b>496</b> receives a selection control signal via the lines <b>516</b> that identifies up to six instructions that are to be simultaneously issued for execution: two integer, two floating point and two boolean.</p><p>The register rename unit <b>496</b> performs the additional function of selecting, via control signals provided on the bus <b>518</b> to the register file array <b>472</b>, the source registers for access in the execution of the identified instructions. Destination registers for out-of-order executed instructions are selected as being in the temporary buffers <b>612</b>, <b>680</b>, <b>728</b> of the corresponding data path. In-order executed instructions are retired on completion with result data being stored through to the register files <b>614</b>, <b>684</b>, <b>732</b>. The selection of source registers depends on whether the register has been prior selected as a destination and the corresponding prior instruction has not yet been retired. In such an instance, the source register is selected from the corresponding temporary buffer <b>612</b>, <b>680</b>, <b>728</b>. Where the prior instruction has been retired, then the register of the corresponding register file <b>614</b>, <b>684</b>, <b>732</b> is selected. Consequently, the register rename unit <b>496</b> operates to effectively substitute temporary buffer register references for register file register references in the case of out-of-order executed instructions.</p><p>As implemented in the architecture <b>100</b>, the temporary buffers <b>612</b>, <b>680</b>, <b>728</b> are not duplicate register structures of their corresponding register file arrays. Rather, a single destination register slot is provided for each of eight pending instructions. Consequently, the substitution of a temporary buffer destination register reference is determined by the location of the corresponding instruction within the pending register sets. A subsequent source register reference is identified by the data dependency checker <b>494</b> with respect to the instruction from which the source dependency occurs. Therefore, a destination slot in the temporary buffer register is readily determinable by the register rename unit <b>496</b>.</p><p>5) Instruction Issuer Unit Detail:</p><p>The instruction issuer unit <b>498</b> determines the set of instructions that can be issued, based on the output of the register rename unit <b>496</b> and the function requirements of the instructions as identified by the EDecode unit <b>490</b>. The instruction issuer unit <b>498</b> makes this determination based on the status of each of the functional units <b>478</b><sub>0-n </sub>as reported via control lines <b>514</b>. Thus, the instruction issuer unit <b>498</b> begins operation upon receipt of the available set of instructions to issue from the register rename unit <b>496</b>. Given that a register file access is required for the execution of each instruction, the instruction issuer unit <b>498</b> anticipates the availability of functional unit <b>478</b><sub>0-n </sub>that may be currently executing an instruction. In order to minimize the delay in identifying the instructions to be issued to the register rename unit <b>496</b>, the instruction issuer unit <b>498</b> is implemented in dedicated combinatorial logic.</p><p>Upon identification of the instructions to issue, the register rename unit <b>496</b> initiates a register file access that continues to the end of the third processor cycle, P<sub>2</sub>. At the beginning of processor cycle P<sub>3</sub>, the instruction issuer unit <b>498</b> initiates operation by one or more of the functional units <b>478</b><sub>0-n</sub>, such as shown as \u201cExecute 0\u201d, to receive and process source data provided from the register file array <b>472</b>.</p><p>Typically, most instructions processed by the architecture <b>100</b> are executed through a functional unit in a single processor cycle. However, some instructions require multiple processor cycles to complete, such as shown as \u201cExecute 1\u201d, a simultaneously issued instruction. The Execute zero and Execute 1 instructions may, for example, be executed by an ALU and floating point multiplier functional units respectively. The ALU functional unit, as shown is FIG. 14, produces output data within one processor cycle and, by simple provision of output latching, available for use in executing another instruction during the fifth processor cycle, P<sub>4</sub>. The floating point multiply functional unit is preferably an internally pipelined functional unit. Therefore, another additional floating point multiply instruction can be issued in the next processor cycle. However, the result of the first instruction will not be available for a data dependent number of processor cycles; the instruction shown in FIG. 14 requires three processor cycles to complete processing through the functional unit.</p><p>During each processor cycle, the function of the instruction issuer unit <b>498</b> is repeated. Consequently, the status of the current set of pending instructions as well as the availability state of the full set of functional units <b>478</b><sub>0-n </sub>are reevaluated during each processor cycle. Under optimum conditions, the preferred architecture <b>100</b> is therefore capable of executing up to six instructions per processor cycle. However, a typical instruction mix will result in an overall average execution of 1.5 to 2.0 instructions per processor cycle.</p><p>A final consideration in the function of the instruction issuer <b>498</b> is its participation in the handling of traps conditions and the execution of specific instructions. The occurrence of a trap condition requires that the IEU <b>104</b> be cleared of all instructions that have not yet been retired. Such a circumstance may arise in response to an externally received interrupt that is relayed to the IEU <b>104</b> via the interrupt request/acknowledge control line <b>340</b>, from any of the functional units <b>478</b><sub>0-n </sub>in response to an arithmetic fault, or, for example, the EDecode unit <b>490</b> upon the decoding of an illegal instruction. On the occurrence of the trap condition, the instruction issuer unit <b>498</b> is responsible for halting or voiding all un-retired instructions currently pending in the IEU <b>104</b>. All instructions that cannot be retired simultaneously will be voided. This result is essential to maintain the preciseness of the occurrence of the interrupt with respect to the conventional in-order execution of a program instruction stream. Once the IEU <b>104</b> is ready to begin execution of the trap handling program routine, the instruction issuer <b>498</b> acknowledges the interrupt via a return control signal along the control lines <b>340</b>. Also, in order to avoid the possibility that an exception condition relative to one instruction may be recognized based on a processor state bit which would have changed before that instruction would have executed in a classical pure in-order routine, the instruction issuer <b>498</b> is responsible for ensuring that all instructions which can alter the PSR (such as special move and return from trap) are executed strictly in-order.</p><p>Certain instructions that alter program control flow are not identified by the IDecode unit <b>262</b>. Instructions of this type include subroutine returns, returns from procedural instructions, and returns from traps. The instruction issuer unit <b>498</b> provides identifying control signals via the IEU return control lines <b>350</b> to the IFU <b>102</b>. A corresponding one of the special registers <b>412</b> is selected to provide the IF_PC execution address that existed at the point in time of the call instruction, occurrence of the trap or encountering of a procedural instruction.</p><p>6) Dope Control Unit Detail:</p><p>The done control unit <b>540</b> monitors the functional units <b>478</b><sub>0-n </sub>for the completion status of their current operations. In the preferred architecture <b>100</b>, the done control unit <b>540</b> anticipates the completion of operations by each functional unit sufficient to provide a completion vector, reflecting the status of the execution of each instruction in the currently pending set of instructions, to the register rename unit <b>496</b>, bypass control unit <b>520</b> and retirement control unit <b>500</b> approximately one half processor cycle prior to the execution completion of an instruction by a functional unit <b>478</b><sub>0-n</sub>. This allows the instruction issuer unit <b>498</b>, via the register rename unit <b>496</b>, to consider the instruction completing functional units as available resources for the next instruction issuing cycle. The bypass control unit <b>520</b> is allowed to prepare to bypass data output by the functional unit through the bypass unit <b>474</b>. Finally, the retirement control unit <b>500</b> nay operate to retire the corresponding instruction simultaneous with the transfer of data from the functional unit <b>478</b><sub>0-n </sub>to the register file array <b>472</b>.</p><p>7) Retirement Control Unit Detail:</p><p>In addition to the instruction done vector provided from the done control unit <b>540</b>, the retirement control unit <b>500</b> monitors the oldest instruction set output from the EDecode output <b>490</b>. As each instruction in instruction stream order is marked done by the done control unit <b>540</b>, the retirement control unit <b>500</b> directs, via control signals provided on control lines <b>534</b>, the transfer of data from the temporary buffer slot to the corresponding instruction specified register file register location within the register file array <b>472</b>. The PC Inc/Size control signals are provided on the control lines <b>344</b> for each one or more instruction simultaneously retired. Up to four instructions may be retired per processor cycle. Whenever an entire instruction set has been retired, an IFIFO read control signal is provided on the control line <b>342</b> to advance the IFIFO <b>264</b>.</p><p>8) Control Flow Control Unit Detail:</p><p>The control flow control unit <b>528</b> operates to continuously provide the IFU <b>102</b> with information specifying whether any control flow instructions within the current set of pending instructions have been resolved and, further, whether the branch result is taken or not taken. The control flow control unit <b>528</b> obtains, via control lines <b>510</b>, an identification of the control flow branch instructions by the EDecode <b>490</b>. The current set of register dependencies is provided via control lines <b>536</b> from the data dependency checker unit <b>494</b> to the control flow control unit <b>528</b> to allow the control flow control unit <b>528</b> to determine whether the outcome of a branch instruction is constrained by dependencies or is now known. The register references provided via bus <b>518</b> from the register rename unit <b>496</b> are monitored by the control flow control <b>528</b> to identify the boolean register that will define the branch decision. Thus, the branch decision may be determined even prior to the out-of-order execution of the control flow instruction.</p><p>Simultaneous with the execution of a control flow instruction, the bypass unit <b>472</b> is directed by the bypass control unit <b>520</b> to provide the control flow results onto control lines <b>530</b>, consisting of the control flow zero and control flow one 1 control lines <b>750</b>, <b>752</b>, to the control flow control unit <b>528</b>. Finally, the control flow control unit <b>528</b> continuously provides two vectors of eight bits each to the IFU <b>102</b> via control lines <b>348</b>. These vectors define whether a branch instruction at the corresponding logical location corresponding to the bits within the vectors have been resolved and whether the branch result is taken or not taken.</p><p>In the preferred architecture <b>100</b>, the control flow control unit <b>528</b> is implemented as pure combinatorial logic operating continuously in response to the input control signals to the control unit <b>528</b>.</p><p>9) Bypass Control Unit Detail:</p><p>The instruction issuer unit <b>498</b> operates closely in conjunction with the bypass control unit <b>520</b> to control the routing of data between the register file array <b>472</b> and the functional units <b>47801</b>. The bypass control unit <b>520</b> operates in conjunction with the register file access, output and store phases of operation shown in FIG. <b>14</b>. During a register file access, the bypass control unit <b>520</b> may recognize, via control lines <b>522</b>, an access of a destination register within the register file array <b>472</b> that is in the process of being written during the output phase of execution of an instruction. In this case, the bypass control unit <b>520</b> directs the selection of data provided on the functional unit output bus <b>482</b> to be bypassed back to the functional unit distribution bus <b>480</b>. Control over the bypass unit <b>520</b> is provided by the instruction issuer unit <b>498</b> via control lines <b>532</b>.</p><p>IV. Virtual Memory Control Unit:</p><p>An interface definition for the VMU <b>108</b> is provided in FIG. <b>15</b>. The VMU <b>108</b> consists principally of a VMU control logic unit <b>800</b> and a content addressable memory (CAM) <b>802</b>. The general function of the VMU <b>108</b> is shown graphically in FIG. <b>16</b>. There, a representation of a virtual address is shown partitioned into a space identifier (sID[31:28]), a virtual page number (VADDR[27:14]), page offset (PADDR[13:4]), and a request ID (rID[3:0]). The algorithm for generating a physical address is to use the space ID to select one of 16 registers within a space table <b>842</b>. The contents of the selected space register in combination with a virtual page number is used as an address for accessing a table look aside buffer (TLB) <b>844</b>. The 34 bit address operates as a content address tag used to identify a corresponding buffer register within the buffer <b>844</b>. On the occurrence of a tag match, an 18 bit wide register value is provided as the high order 18 bits of a physical address <b>846</b>. The page offset and request ID are provided as the low order 14 bits of the physical address <b>846</b>.</p><p>Where there is a tag miss in the table look aside buffer <b>844</b>, a VMU miss is signalled. This requires the execution of a VMU fast trap handling routine that implements conventional hash algorithm <b>848</b> that accesses a complete page table data structure maintained in the MAU <b>112</b>. This page table <b>850</b> contains entries for all memory pages currently in use by the architecture <b>100</b>. The hash algorithm <b>848</b> identifies those entries in the page table <b>850</b> necessary to satisfy the current virtual page translation operation. Those page table entries are loaded from the MAU <b>112</b> to the trap registers of register set \u201cA\u201d and then transferred by special register move instructions to the table look aside buffer <b>844</b>. Upon return from the exception handling routine, the instruction giving rise to the VMU miss exception is re-executed by the IEU <b>104</b>. The virtual to physical address translation operation should then complete without exception.</p><p>The VMU control logic <b>800</b> provides a dual interface to both the IFU <b>102</b> and IEU <b>104</b>. A ready signal is provided on control lines <b>822</b> to the IEU <b>104</b> to signify that the VMU <b>108</b> is available for an address translation. In the preferred embodiment, the VMU <b>108</b> is always ready to accept IFU <b>120</b> translation requests. Both the IFU and IEU <b>102</b>, <b>104</b> may pose requests via control line <b>328</b>, <b>804</b>. In the preferred architecture <b>100</b>, the IFU <b>10</b> has priority access to the VMU <b>108</b>. Consequently, only a single busy control line <b>820</b> is provided to the IEU <b>104</b>.</p><p>Both the IFU and IEU <b>102</b>, <b>104</b> provide the space ID and virtual page number fields to the VMU control logic <b>800</b> via control lines <b>326</b>, <b>808</b>, respectively. In addition, the IEU <b>104</b> provides a read/write control signal via control signal <b>806</b> to define whether the address is to be used for a load or store operation as necessary to modify memory access protection attributes of the virtual memory referenced. The space ID and virtual page fields of the virtual address are passed to the CAM unit <b>802</b> to perform the actual translation operation. The page offset and ExID fields are eventually provided by the IEU <b>104</b> directly to the CCU <b>106</b>. The physical page and request ID fields are provided on the address lines <b>836</b> to the CAM unit <b>802</b>. The occurrence of a table look aside buffer match is signalled via the hit line and control output lines <b>830</b> to the VEU control logic unit <b>800</b>. The resulting physical address, 18 bits in length, is provided on the address output lines <b>824</b>.</p><p>The VMU control logic unit <b>800</b> generates the virtual memory miss and virtual memory exception control signals on lines <b>334</b>, <b>332</b> in response to the hit and control output control signals on lines <b>830</b>. A virtual memory translation miss is defined as failure to match a page table identifier in the table look aside buffer <b>844</b>. All other translation errors are reported as virtual memory exceptions.</p><p>Finally, the data tables within the CAM unit <b>802</b> may be modified through the execution of special register to register move instructions by the IEU <b>104</b>. Read/write, register select, reset, load and clear control signals are provided by the IEU <b>104</b> via control lines <b>810</b>, <b>812</b>, <b>814</b>, <b>816</b>, <b>818</b>. Data to be written to the CAM unit registers is received by the VMU control logic unit <b>800</b> via the address bus <b>808</b> coupled to the special address data bus <b>354</b> from the IEU <b>104</b>. This data is transferred via bus <b>836</b> to the CAM unit <b>802</b> simultaneous with control signals <b>828</b> that control the initialization, register selection, and read or write control signal. Consequently, the data registers within the CAM unit <b>802</b> may be readily written as required during the dynamic operation of the architecture <b>100</b> including read out for storage as required for the handling of context switches defined by a higher level operating system.</p><p>V. Cache Control Unit:</p><p>The control on data interface for the CCU <b>106</b> is shown in FIG. <b>17</b>. Again, separate interfaces are provided for the IFU <b>102</b> and IEU <b>104</b>. Further, logically separate interfaces are provided by the CCU <b>106</b> to the MCU <b>110</b> with respect to instruction and data transfers.</p><p>The IFU interface consists of the physical page address provided on address lines <b>324</b>, the VMU converted page address as provided on the address lines <b>824</b>, and request IDs as transferred separately on control lines <b>294</b>, <b>296</b>. A unidirectional data transfer bus <b>114</b> is provided to transfer an entire instruction set in parallel to the IFU <b>102</b>. Finally, the read/busy and ready control signals are provided to the CCU <b>106</b> via control lines <b>298</b>, <b>300</b>, <b>302</b>.</p><p>Similarly, a complete physical address is provided by the IEU <b>102</b> via the physical address bus <b>788</b>. The request ExIDs are separately provided from and to the load/store unit of the IEU <b>104</b> via control lines <b>796</b>. An 80 bit wide bidirectional data bus is provided by the CCU <b>106</b> to the IEU <b>104</b>. However, in the present preferred implementation of the architecture <b>100</b>, only the lower 64 bits are utilized by the IEC <b>104</b>. The availability and support within the CCU <b>106</b> of a full 80 bit data transfer bus is provided to support subsequent implementations of the architecture <b>100</b> that support, through modifications of the floating point data path <b>660</b>, floating point operation in accordance with IEEE standard <b>754</b>.</p><p>The IEU control interface, established via request, busy, ready, read/write and with control signals <b>784</b> is substantially the same as the corresponding control signals utilized by the IFU <b>102</b>. The exception being the provision of a read/write control signal to differentiate between load and store operations. The width control signals specify the number of bytes being transferred during each CCU <b>106</b> access by the IEU <b>104</b>; in contrast every access of the instruction cache <b>132</b> is a fixed 128 bit wide data fetch operation.</p><p>The CCU <b>106</b> implements a substantially conventional cache controller function with respect to the separate instruction and data caches <b>132</b>, <b>134</b>. In the preferred architecture <b>100</b>, the instruction cache <b>132</b> is a high speed memory providing for the storage of 256 128 bit wide instruction sets. The data cache <b>134</b> provides for the storage of 1024 32 bit wide words of data. Instruction and data requests that cannot be immediately satisfied from the contents of the instruction and data caches <b>132</b>, <b>134</b> are passed on to the MCU <b>110</b>. For instruction cache misses, the 28 bit wide physical address is provided to the MCU <b>110</b> via the address bus <b>860</b>. The request ID and additional control signals for coordinating the operation of the CCU <b>106</b> and MCU <b>110</b> are provided on control lines <b>862</b>. Once the MCU <b>110</b> has coordinated the necessary read access of the MAU <b>112</b>, two consecutive 64 bit wide data transfers are performed directly from the MAU <b>112</b> through to the instruction cache <b>132</b>. Two transfers are required given that the data bus <b>136</b> is, in the preferred architecture <b>100</b>, a 64 bit wide bus. As the requested data is returned through the MCU <b>110</b> the request ID maintained during the pendency of the request operation is also returned to the CCU <b>106</b> via the control lines <b>862</b>.</p><p>Data transfer operations between the data cache <b>134</b> and MCU <b>110</b> are substantially the same as instruction cache operations. Since data load and store operations may reference a single byte, a full 32 bit wide physical address is provided to the MCU <b>110</b> via the address bus <b>864</b>. Interface control signals and the request EXID are transferred via control lines <b>866</b>. Bidirectional 64 bit wide data transfers are provided via the data cache bus <b>138</b>.</p><p>VI. Summary/Conclusion:</p><p>Thus, a high-performance RISC based microprocessor architecture has been disclosed. The architecture efficiently implements out-of-order execution of instructions, separate main and target instruction stream prefetch instruction transfer paths, and a procedural instruction recognition and dedicated prefetch path. The optimized instruction execution unit provides multiple optimized data processing paths supporting integer, floating point and boolean operations and incorporates respective temporary register files facilitating out-of-order execution and instruction cancellation while maintaining a readily established precise state-of-the-machine status.</p><p>It is therefore to be understood that while the foregoing disclosure describes the preferred embodiment of the present invention, other variations and modifications may be readily made by those of average skill within the scope of the present invention.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Le Trong", "last_name": "Nguyen", "name": ""}, {"first_name": "Derek J.", "last_name": "Lentz", "name": ""}, {"first_name": "Yoshiyuki", "last_name": "Miyayama", "name": ""}, {"first_name": "Sanjiv", "last_name": "Garg", "name": ""}, {"first_name": "Yasuaki", "last_name": "Hagiwara", "name": ""}, {"first_name": "Johannes", "last_name": "Wang", "name": ""}, {"first_name": "Te-Li", "last_name": "Lau", "name": ""}, {"first_name": "Sze-Shun", "last_name": "Wang", "name": ""}, {"first_name": "Quang H.", "last_name": "Trang", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "SEIKO EPSON CORPORATION"}], "ipc_classes": [{"primary": true, "label": "G06F   9/30"}, {"primary": false, "label": "G06F   9/34"}, {"primary": false, "label": "G06F   9/38"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/42        20060101ALI20051220RMJP"}, {"label": "G06F   9/34        20060101ALI20060310RMJP"}, {"label": "G06F   9/32        20060101AFI20051220RMJP"}, {"label": "G06F   9/38        20060101A I20051008RMEP"}, {"label": "G06F   9/30        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712041"}, {"primary": false, "label": "712E0906"}, {"primary": false, "label": "710052"}, {"primary": false, "label": "712023"}, {"primary": false, "label": "712E09055"}, {"primary": false, "label": "712E09027"}, {"primary": false, "label": "712E09024"}, {"primary": false, "label": "712E09025"}, {"primary": false, "label": "712211"}, {"primary": false, "label": "712E09048"}, {"primary": false, "label": "712213"}, {"primary": false, "label": "712E09057"}, {"primary": false, "label": "712E09071"}, {"primary": false, "label": "712E09072"}, {"primary": false, "label": "712E09049"}, {"primary": false, "label": "712E09053"}], "ecla_classes": [{"label": "G06F   9/38E8"}, {"label": "G06F   9/38H3"}, {"label": "G06F   9/38B"}, {"label": "G06F   9/38E1"}, {"label": "G06F   9/38C4"}, {"label": "G06F   9/38B2B"}, {"label": "G06F   9/38H2"}, {"label": "G06F   9/32B8"}, {"label": "G06F   9/30R5S"}, {"label": "G06F   9/38E1R"}, {"label": "G06F   9/30A3C2"}, {"label": "G06F   9/30R4D"}, {"label": "G06F   9/30T4T"}, {"label": "G06F   9/30R4C"}, {"label": "G06F   9/30A5"}, {"label": "G06F   9/38B2"}, {"label": "G06F   9/30R5C"}, {"label": "G06F   9/30R5D"}, {"label": "G06F   9/38E4"}, {"label": "G06F   9/38T"}, {"label": "G06F   9/38D4"}, {"label": "G06F   9/38E"}], "cpc_classes": [{"label": "G06F   9/30116"}, {"label": "G06F   9/30112"}, {"label": "G06F   9/30123"}, {"label": "G06F   9/3838"}, {"label": "G06F   9/3804"}, {"label": "G06F   9/30"}, {"label": "G06F   9/3802"}, {"label": "G06F   9/3826"}, {"label": "G06F   9/3013"}, {"label": "G06F   9/3834"}, {"label": "G06F   9/327"}, {"label": "G06F   9/3855"}, {"label": "G06F   9/30072"}, {"label": "G06F   9/3865"}, {"label": "G06F   9/3822"}, {"label": "G06F   9/30167"}, {"label": "G06F   9/06"}, {"label": "G06F   9/38"}, {"label": "G06F   9/384"}, {"label": "G06F   9/3885"}, {"label": "G06F   9/3836"}, {"label": "G06F   9/3806"}, {"label": "G06F   9/3851"}, {"label": "G06F   9/3863"}, {"label": "G06F   9/30061"}, {"label": "G06F   9/30134"}, {"label": "G06F   9/3857"}, {"label": "G06F   9/30134"}, {"label": "G06F   9/3836"}, {"label": "G06F   9/3851"}, {"label": "G06F   9/3834"}, {"label": "G06F   9/3865"}, {"label": "G06F   9/3826"}, {"label": "G06F   9/3857"}, {"label": "G06F   9/3885"}, {"label": "G06F   9/30112"}, {"label": "G06F   9/3863"}, {"label": "G06F   9/3802"}, {"label": "G06F   9/3855"}, {"label": "G06F   9/3822"}, {"label": "G06F   9/3804"}, {"label": "G06F   9/327"}, {"label": "G06F   9/30061"}, {"label": "G06F   9/3838"}, {"label": "G06F   9/30116"}, {"label": "G06F   9/3806"}, {"label": "G06F   9/30167"}, {"label": "G06F   9/3013"}, {"label": "G06F   9/30072"}, {"label": "G06F   9/384"}, {"label": "G06F   9/30123"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1991-07-08", "application_date": "1999-11-10", "family_members": [{"ucid": "JP-3791550-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Superscalar microprocessor and data processor"}]}, {"ucid": "US-7487333-B2", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "US-7739482-B2", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "KR-100633574-B1", "titles": [{"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}, {"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}]}, {"ucid": "US-6934829-B2", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "US-6959375-B2", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "US-6986024-B2", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "US-7162610-B2", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "KR-100325176-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "US-6101594-A", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "US-6256720-B1", "titles": [{"lang": "EN", "text": "High performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "KR-20040000411-A", "titles": []}, {"ucid": "US-6915412-B2", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "US-6941447-B2", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "US-20020029328-A1", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "US-20040054872-A1", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order intstruction execution"}]}, {"ucid": "US-20040093483-A1", "titles": [{"lang": "EN", "text": "High performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "DE-69232113-D1", "titles": [{"lang": "EN", "text": "HIGH PERFORMANCE ARCHITECTURE FOR RISC MICROPROCESSOR"}, {"lang": "DE", "text": "HOCHLEISTUNGSARCHITEKTUR F\u00dcR RISC-MIKROPROZESSOR"}]}, {"ucid": "KR-20070055586-A", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "US-6272619-B1", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "DE-69233313-T2", "titles": [{"lang": "EN", "text": "High performance architecture for RISC microprocessor"}, {"lang": "DE", "text": "Hochleistungsarchitektur f\u00fcr RISC-Mikroprozessor"}]}, {"ucid": "EP-1024426-B1", "titles": [{"lang": "DE", "text": "Hochleistungsarchitektur f\u00fcr RISC-Mikroprozessor"}, {"lang": "EN", "text": "High performance RISC microprocessor architecture"}, {"lang": "FR", "text": "Architecture de microprocesseur RISC \u00e0 hautes performances"}]}, {"ucid": "WO-1993001545-A1", "titles": [{"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}, {"lang": "FR", "text": "ARCHITECTURE DE MICROPROCESSEUR RISC A PERFORMANCES ELEVEES"}]}, {"ucid": "JP-2005293612-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR AND DATA PROCESSING APPARATUS"}]}, {"ucid": "KR-20040004506-A", "titles": []}, {"ucid": "KR-100449238-B1", "titles": []}, {"ucid": "US-7721070-B2", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "US-5539911-A", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "KR-100325175-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "US-5689720-A", "titles": [{"lang": "EN", "text": "High-performance superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "JP-3791545-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Superscalar microprocessor and data processor"}]}, {"ucid": "JP-3791544-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Superscalar microprocessor and data processor"}]}, {"ucid": "AT-450826-T", "titles": [{"lang": "EN", "text": "HIGH-PERFORMANCE ARCHITECTURE FOR RISC MICROPROCESSOR"}, {"lang": "DE", "text": "HOCHLEISTUNGSARCHITEKTUR F\u00dcR RISC-MIKROPROZESSOR"}]}, {"ucid": "AT-206829-T", "titles": [{"lang": "EN", "text": "HIGH PERFORMANCE ARCHITECTURE FOR RISC MICROPROCESSOR"}, {"lang": "DE", "text": "HOCHLEISTUNGSARCHITEKTUR F\u00dcR RISC-MIKROPROZESSOR"}]}, {"ucid": "JP-3731605-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Superscalar microprocessor and data processor"}]}, {"ucid": "JP-2005044383-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR AND DATA PROCESSING UNIT"}]}, {"ucid": "JP-3729202-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5"}, {"lang": "EN", "text": "Super scalar microprocessor"}]}, {"ucid": "JP-2004348772-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR"}]}, {"ucid": "US-20030070060-A1", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "US-20030056087-A1", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "JP-2006012195-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR AND DATA PROCESSOR"}]}, {"ucid": "US-20030079113-A1", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "JP-2003131869-A", "titles": [{"lang": "JA", "text": "\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u7528\u3044\u305f\u547d\u4ee4\u5b9f\u884c\u65b9\u6cd5"}, {"lang": "EN", "text": "INSTRUCTION-EXECUTION METHOD USING MICROPROCESSOR"}]}, {"ucid": "US-20040093482-A1", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "EP-1024426-A3", "titles": [{"lang": "DE", "text": "Hochleistungsarchitektur f\u00fcr RISC-Mikroprozessor"}, {"lang": "EN", "text": "High performance RISC microprocessor architecture"}, {"lang": "FR", "text": "Architecture de microprocesseur RISC \u00e0 hautes performances"}]}, {"ucid": "JP-2005267664-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR AND DATA PROCESSOR"}]}, {"ucid": "DE-69233313-D1", "titles": [{"lang": "EN", "text": "High performance architecture for RISC microprocessor"}, {"lang": "DE", "text": "Hochleistungsarchitektur f\u00fcr RISC-Mikroprozessor"}]}, {"ucid": "HK-1014782-A1", "titles": [{"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "JP-2000357091-A", "titles": [{"lang": "JA", "text": "\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "COMPUTER SYSTEM"}]}, {"ucid": "US-20070106878-A1", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "HK-1060417-A1", "titles": [{"lang": "EN", "text": "HIGH PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-100294475-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5\uc54c\uc544\uc774\uc5d0\uc2a4\uc528\ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c\uad6c\uc870"}, {"lang": "EN", "text": "High Performance RSC Microprocessor Architecture"}]}, {"ucid": "JP-2000353090-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u578b\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5"}, {"lang": "EN", "text": "SUPER COLOR-TYPE MICROPROCESSOR"}]}, {"ucid": "EP-1385085-A1", "titles": [{"lang": "DE", "text": "Hochleistungsarchitektur f\u00fcr RISC-Mikroprozessor"}, {"lang": "EN", "text": "High performance risc microprocessor architecture"}, {"lang": "FR", "text": "Architecture de microprocesseur RISC \u00e0 hautes performances"}]}, {"ucid": "JP-2000339162-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5"}, {"lang": "EN", "text": "SUPER SCALAR MICRO PROCESSOR"}]}, {"ucid": "US-20090019261-A1", "titles": [{"lang": "EN", "text": "High-Performance, Superscalar-Based Computer System with Out-of-Order Instruction Execution"}]}, {"ucid": "KR-20070056140-A", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-100764895-B1", "titles": [{"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}, {"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}]}, {"ucid": "JP-3915842-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Superscalar microprocessor and data processor"}]}, {"ucid": "JP-H06501122-A", "titles": []}, {"ucid": "KR-100764898-B1", "titles": [{"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}, {"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}]}, {"ucid": "KR-100469971-B1", "titles": []}, {"ucid": "KR-100449244-B1", "titles": []}, {"ucid": "KR-100469959-B1", "titles": []}, {"ucid": "KR-100469954-B1", "titles": []}, {"ucid": "KR-100449242-B1", "titles": []}, {"ucid": "KR-100559468-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-100875259-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-100449236-B1", "titles": []}, {"ucid": "KR-100875262-B1", "titles": [{"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}, {"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}]}, {"ucid": "KR-100393495-B1", "titles": []}, {"ucid": "EP-1024426-A2", "titles": [{"lang": "DE", "text": "Hochleistungsarchitektur f\u00fcr RISC-Mikroprozessor"}, {"lang": "EN", "text": "High performance RISC microprocessor architecture"}, {"lang": "FR", "text": "Architecture de microprocesseur RISC \u00e0 hautes performances"}]}, {"ucid": "KR-20070058594-A", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-20060015781-A", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-20070058597-A", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-20040004508-A", "titles": []}, {"ucid": "KR-20040000385-A", "titles": []}, {"ucid": "KR-20060015782-A", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-20040004500-A", "titles": []}, {"ucid": "JP-2005149534-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR AND DATA PROCESSOR"}]}, {"ucid": "JP-2005149524-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR"}]}, {"ucid": "JP-3654139-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u53ca\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Superscalar microprocessor and data processing device"}]}, {"ucid": "KR-100875257-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "JP-2005122740-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR AND DATA PROCESSOR"}]}, {"ucid": "JP-2005108264-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR AND DATA PROCESSOR"}]}, {"ucid": "US-6647485-B2", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "KR-100464272-B1", "titles": []}, {"ucid": "JP-2006313564-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR AND DATA PROCESSOR"}]}, {"ucid": "US-6948052-B2", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "AT-260485-T", "titles": [{"lang": "EN", "text": "HIGH PERFORMANCE ARCHITECTURE FOR RISC MICROPROCESSOR"}, {"lang": "DE", "text": "HOCHLEISTUNGSARCHITEKTUR F\u00dcR RISC-MIKROPROZESSOR"}]}, {"ucid": "EP-0547241-B1", "titles": [{"lang": "DE", "text": "HOCHLEISTUNGSARCHITEKTUR F\u00dcR RISC-MIKROPROZESSOR"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}, {"lang": "FR", "text": "ARCHITECTURE DE MICROPROCESSEUR RISC A PERFORMANCES ELEVEES"}]}, {"ucid": "US-20040093485-A1", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "US-6038654-A", "titles": [{"lang": "EN", "text": "High performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "US-6092181-A", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "DE-03024585-T1", "titles": [{"lang": "EN", "text": "High performance architecture for RISC microprocessor"}, {"lang": "DE", "text": "Hochleistungsarchitektur f\u00fcr RISC-Mikroprozessor"}]}, {"ucid": "DE-69232113-T2", "titles": [{"lang": "EN", "text": "HIGH PERFORMANCE ARCHITECTURE FOR RISC MICROPROCESSOR"}, {"lang": "DE", "text": "HOCHLEISTUNGSARCHITEKTUR F\u00dcR RISC-MIKROPROZESSOR"}]}, {"ucid": "DE-69233777-D1", "titles": [{"lang": "EN", "text": "High performance architecture for RISC microprocessor"}, {"lang": "DE", "text": "Hochleistungsarchitektur f\u00fcr RISC-Mikroprozessor"}]}, {"ucid": "JP-3441070-B2", "titles": [{"lang": "JA", "text": "\u9ad8\u6027\u80fd\uff32\uff29\uff33\uff23\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u53ca\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "High performance RISC microprocessor and data processing device"}]}, {"ucid": "JP-3791542-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Superscalar microprocessor and data processor"}]}, {"ucid": "JP-3791547-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Superscalar microprocessor and data processor"}]}, {"ucid": "KR-937002718-A", "titles": []}, {"ucid": "US-20030056086-A1", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}, {"ucid": "KR-20080109099-A", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "JP-2000339163-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u3001\u8a72\u30d7\u30ed\u30bb\u30c3\u30b5\u30b7\u30b9\u30c6\u30e0\u3001\u8a72\u30d7\u30ed\u30bb\u30c3\u30b5\u30b7\u30b9\u30c6\u30e0\u306b\u304a\u3051\u308b\u30c7\u30fc\u30bf\u51e6\u7406\u65b9\u6cd5\u3001\u53ca\u3073\u8a72\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u5099\u3048\u305f\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "SUPER SCALAR MICROPROCESSOR, ITS PROCESSOR SYSTEM, DATA PROCESSING METHOD IN THE SAME AND COMPUTER SYSTEM PROVIDED WITH PROCESSOR"}]}, {"ucid": "JP-2005310187-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR AND DATA PROCESSING APPARATUS"}]}, {"ucid": "KR-100469952-B1", "titles": []}, {"ucid": "EP-0547241-A1", "titles": [{"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}, {"lang": "DE", "text": "HOCHLEISTUNGSARCHITEKTUR F\u00dcR RISC-MIKROPROZESSOR"}, {"lang": "FR", "text": "ARCHITECTURE DE MICROPROCESSEUR RISC A PERFORMANCES ELEVEES"}]}, {"ucid": "KR-100875252-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-930702718-A", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c \uc544\uc774 \uc5d0\uc2a4 \uc528(RISC) \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870 \uad00\ub828\ucd9c\uc6d0\uc758 \uc0c1\ud638 \ucc38\uc870"}, {"lang": "EN", "text": "Cross reference of high performance RCI microprocessor architecture related applications"}]}, {"ucid": "KR-20060015783-A", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "JP-3731604-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Superscalar microprocessor and data processor"}]}, {"ucid": "JP-3654137-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u578b\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u53ca\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Super scalar type microprocessor and data processing device"}]}, {"ucid": "JP-3702873-B2", "titles": [{"lang": "JA", "text": "\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u7528\u3044\u305f\u547d\u4ee4\u5b9f\u884c\u65b9\u6cd5"}, {"lang": "EN", "text": "Instruction execution method using a microprocessor"}]}, {"ucid": "JP-3791548-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Superscalar microprocessor and data processor"}]}, {"ucid": "JP-3760948-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5"}, {"lang": "EN", "text": "Super scalar microprocessor"}]}, {"ucid": "JP-3760947-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Superscalar microprocessor and data processor"}]}, {"ucid": "JP-3838252-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Superscalar microprocessor and data processor"}]}, {"ucid": "JP-3654138-B2", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u578b\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u53ca\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Super scalar type microprocessor and data processing device"}]}, {"ucid": "JP-2000339161-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u5099\u3048\u305f\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30b7\u30b9\u30c6\u30e0"}, {"lang": "EN", "text": "COMPUTER SYSTEM PROVIDED WITH SUPER SCALAR MICRO PROCESSOR"}]}, {"ucid": "JP-2000339160-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u578b\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5"}, {"lang": "EN", "text": "SUPER SCALAR-TYPE MICRO PROCESSOR"}]}, {"ucid": "JP-2000339159-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u578b\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5"}, {"lang": "EN", "text": "SUPER SCALAR-TYPE MICRO PROCESSOR"}]}, {"ucid": "JP-2005251227-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR AND DATA PROCESSOR"}]}, {"ucid": "JP-2006031729-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR AND DATA PROCESSOR"}]}, {"ucid": "JP-2006236396-A", "titles": [{"lang": "JA", "text": "\u30b9\u30fc\u30d1\u30fc\u30b9\u30ab\u30e9\u30fc\u30de\u30a4\u30af\u30ed\u30d7\u30ed\u30bb\u30c3\u30b5\u304a\u3088\u3073\u30c7\u30fc\u30bf\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "SUPERSCALAR MICROPROCESSOR AND DATA PROCESSOR"}]}, {"ucid": "KR-100393497-B1", "titles": []}, {"ucid": "KR-100403164-B1", "titles": []}, {"ucid": "KR-100403166-B1", "titles": []}, {"ucid": "KR-100469964-B1", "titles": []}, {"ucid": "KR-100559465-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-100559463-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-100559455-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-100633578-B1", "titles": [{"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}, {"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}]}, {"ucid": "KR-100393494-B1", "titles": []}, {"ucid": "KR-100469968-B1", "titles": []}, {"ucid": "KR-100403165-B1", "titles": []}, {"ucid": "KR-100325177-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-100403167-B1", "titles": []}, {"ucid": "KR-100559482-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-100559475-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-100764894-B1", "titles": [{"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}, {"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}]}, {"ucid": "KR-100393496-B1", "titles": []}, {"ucid": "KR-100875266-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-100886000-B1", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-20040004499-A", "titles": []}, {"ucid": "KR-20040000410-A", "titles": []}, {"ucid": "KR-20040004505-A", "titles": []}, {"ucid": "KR-20040004504-A", "titles": []}, {"ucid": "KR-20040004503-A", "titles": []}, {"ucid": "KR-20040000386-A", "titles": []}, {"ucid": "KR-20040000384-A", "titles": []}, {"ucid": "KR-20040000383-A", "titles": []}, {"ucid": "KR-20040004501-A", "titles": []}, {"ucid": "KR-20040000382-A", "titles": []}, {"ucid": "KR-20040004507-A", "titles": []}, {"ucid": "KR-20040004502-A", "titles": []}, {"ucid": "KR-20040000381-A", "titles": []}, {"ucid": "KR-20070058596-A", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-20070058595-A", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-20070055585-A", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "KR-20070056141-A", "titles": [{"lang": "KO", "text": "\uace0\uc131\ub2a5 \uc54c\uc544\uc774\uc5d0\uc2a4\uc528 \ub9c8\uc774\ud06c\ub85c\ud504\ub85c\uc138\uc11c \uad6c\uc870"}, {"lang": "EN", "text": "HIGH-PERFORMANCE RISC MICROPROCESSOR ARCHITECTURE"}]}, {"ucid": "EP-1385085-B1", "titles": [{"lang": "DE", "text": "Hochleistungsarchitektur f\u00fcr RISC-Mikroprozessor"}, {"lang": "EN", "text": "High performance risc microprocessor architecture"}, {"lang": "FR", "text": "Architecture de microprocesseur RISC \u00e0 hautes performances"}]}, {"ucid": "US-6128723-A", "titles": [{"lang": "EN", "text": "High-performance, superscalar-based computer system with out-of-order instruction execution"}]}]}