{"patent_number": "US-5809294-A", "publication_id": 71817954, "family_id": 15937500, "publication_date": "1998-09-15", "titles": [{"lang": "EN", "text": "Parallel processing unit which processes branch instructions without decreased performance when a branch is taken"}], "abstracts": [{"lang": "EN", "paragraph_markup": "<abstract lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PA37814459\"><p>A parallel processing unit operable in a delayed branch method has a branch-delay slot filled with instructions to be executed when a branch by a branch instruction is taken. The instructions in the branch-delay slot are those fetched in a period from fetching of the branch instruction till the execution of the branch instruction. Instructions are prefetched from an instruction memory into a queue memory. The queue memory includes a plurality of blocks of storage units. Instructions in the same block as a branch instruction and subsequent to the branch instruction, and instructions in the block adjacent to the block including the branch instruction provide the branch delay slot for the branch instruction. A parallel processing unit operable in a predicted branch method includes a queue memory including a plurality of entries, each of which includes an instruction and a flag indicating that an associated instruction is executed according to a prediction of a branch. This flag is utilized to control execution and non execution of an associated instruction.</p></abstract>"}], "claims": [{"lang": "EN", "claims": [{"num": 1, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"1\"><claim-text>1. A parallel processing unit including an instruction memory for storing instructions and a plurality of function units operable in parallel for executing instructions, comprising:<claim-text>fetching means responsive to an address for fetching a plurality of instructions at a time from said instruction memory;</claim-text><claim-text>detecting means for detecting a branch instruction among the plurality of instructions fetched; and</claim-text><claim-text>forming means responsive to the detecting means for forming a branch delay slot including all of instructions fetched during a period from fetching the branch instruction to execution of the branch instruction, the instructions in the branch delay slot being subsequent to the branch instruction in an instruction sequence, wherein</claim-text><claim-text>said forming means includes:<claim-text>storage means for storing instructions fetched from said instruction memory,</claim-text><claim-text>write pointer means for generating a write pointer indicating an address of said storage unit at which fetched instructions are stored,</claim-text><claim-text>a read pointer means for generating a read pointer indicating an address of said storage means at which instructions are read out,</claim-text><claim-text>determination means, responsive to said detecting means, for determining whether any branch delay slot for the branch instruction is already stored in the storage means,</claim-text><claim-text>decision means for deciding whether a branch by the branch instruction is taken, and</claim-text><claim-text>control means, responsive to the write pointer, read pointer, said determination means, and said decision means, for controlling the write pointer from the write pointer means and the read pointer from the read pointer means.</claim-text></claim-text></claim-text></claim>"}, {"num": 2, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"2\"><claim-text>2. A parallel processing unit according to claim 1, wherein<claim-text>said control means includes means for adjusting the write pointer to a value of a sum of a current value of the write pointer and the number of fetched instructions from said instruction memory, when said determination means determines that the branch delay slot for the branch instruction has not been filled with instructions subsequent to the branch instruction and when said decision means decides that the branch is taken.</claim-text></claim-text></claim>"}, {"num": 3, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"3\"><claim-text>3. A parallel processing unit according to claim 1, wherein<claim-text>said control means includes means for adjusting the write pointer to a value of an address very next to a last address of the branch delay slot, when said determination means determines that the branch delay slot has been filed with instructions subsequent to the branch instruction, and when said decision means decides that the branch is taken.</claim-text></claim-text></claim>"}, {"num": 4, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"4\"><claim-text>4. A parallel processing unit according to claim 1, wherein said control means includes means for adjusting the read pointer to a value increased by the number of instructions dispatched into function units of said plurality of function units, when said decision means decides that the branch is taken.</claim-text></claim>"}, {"num": 5, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"5\"><claim-text>5. A parallel processing unit according to claim 1, wherein said control means further includes means for stopping dispatching of instructions subsequent to the branch instruction, when said decision means decides that no branch is taken by the branch instruction.</claim-text></claim>"}, {"num": 6, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"6\"><claim-text>6. A parallel processing unit according to claim 1, wherein said control mean includes means for adjusting the read pointer to a value of an address next to the last address for the branch delay slot, when said decision means decides that no branch is taken.</claim-text></claim>"}, {"num": 7, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"7\"><claim-text>7. A parallel processing unit according to claim 1, wherein<claim-text>said control means further includes means for stopping issuance of an instruction to a function unit, when said determination means determines that all instructions for the branch delay slot are not stored in said storage unit and when said decision means decides that no branch is taken by the branch instruction.</claim-text></claim-text></claim>"}, {"num": 8, "parent": 1, "type": "dependent", "paragraph_markup": "<claim num=\"8\"><claim-text>8. A parallel processing unit according to claim 1, wherein said storage means comprises a queue memory.</claim-text></claim>"}, {"num": 9, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"9\"><claim-text>9. A parallel processing unit including a plurality of function units operable in parallel for executing instructions and an instruction memory for storing instructions, comprising:<claim-text>storage means for storing instructions fetched from said instruction memory, said storage means including a plurality of entries, each of said entries including a first field for an instruction and a second field for storing a flag indicating that the instruction linked with said flag is executed under a prediction of branch;</claim-text><claim-text>predict means for detecting a branch instruction among instructions read out from said storage means and for predicting whether a branch is taken by the branch instruction;</claim-text><claim-text>setting means responsive to said predict means, for establishing a value of the flag in said second field; and</claim-text><claim-text>control means, response to a value of the flag, for controlling execution and non-execution of the instruction linked with said flag.</claim-text></claim-text></claim>"}, {"num": 10, "parent": 9, "type": "dependent", "paragraph_markup": "<claim num=\"10\"><claim-text>10. A parallel processing unit according to claim 9, wherein<claim-text>said control means includes means for inhibiting execution of the instruction linked with said flag when the flag indicates that the instruction linked with said flag is executed according to a predicted branch provided by said predict means.</claim-text></claim-text></claim>"}, {"num": 11, "parent": 9, "type": "dependent", "paragraph_markup": "<claim num=\"11\"><claim-text>11. A parallel processing unit according to claim 9, further comprising a register file including a plurality of registers, and wherein said control means includes means for storing a return address in one of the plurality of registers of said register file when the branch instruction can actually be executed if the branch instruction includes an instruction for storing t he return address required for returning from a taken branch in the register.</claim-text></claim>"}, {"num": 12, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"12\"><claim-text>12. A parallel processing unit including a plurality of function units operable in parallel for executing instructions and an instruction memory for storing instructions, comprising:<claim-text>storage means for storing instructions fetched from said instruction memory, said storage means including a plurality of entries, each of said entries including a first field for an instruction and a second field for storing a flag indicating that an associated instruction is executed under a prediction of branch;</claim-text><claim-text>predict means for detecting a branch instruction among instructions read out from said storage means and for predicting whether a branch is taken by the branch instruction;</claim-text><claim-text>setting means, responsive to said predict means, for establishing a value of the flag in said second field; and</claim-text><claim-text>control means, responsive to a value of the flag, for controlling execution and non-execution of an associated instruction, wherein</claim-text><claim-text>said control means includes;<claim-text>dispatch means receiving a plurality of instructions from said storage means, detecting simultaneously executable instructions out of the received instructions, and dispatching the simultaneously executable instructions to related function units,</claim-text><claim-text>predict verify means for executing the branch instruction and determining whether prediction of the branch is correct,</claim-text><claim-text>first flag generating means, responsive to said predict means and predict verify means, for generating a second flag for each instruction indicating that an associated instruction is to be dispatched to a related function unit in a period after prediction of a branch is made before the determination by said predict verify means,</claim-text><claim-text>second flag generating means for generating a third flag for each instruction indicating that an associated instruction is valid to be executed in a function unit, the second and third flags and the associated instruction being issued into a related function in a linkage manner, and</claim-text><claim-text>flag control means, responsive to said predict verify means, for controlling a value of the second and third flags dispatched into a function unit, said flag control means making only the second flag inactive when the predict verify means indicates that the prediction of a branch is correct, while making both the second and third flags inactive for an instruction having a second flag active when the predict verify means indicates that the prediction is incorrect.</claim-text></claim-text></claim-text></claim>"}, {"num": 13, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"13\"><claim-text>13. A parallel processing unit including a plurality of function units operable in parallel for executing instructions and an instruction memory for storing instructions, comprising:<claim-text>storage means for storing instructions fetched from said instruction memory, said storage means including a plurality of entries, each of said entries including a first field for an instruction and a second field for storing a flag indicating that an associated instruction is executed under a prediction of branch;</claim-text><claim-text>predict means for detecting a branch instruction among instructions read out from said storage means and for predicting whether a branch is taken by the branch instruction;</claim-text><claim-text>setting means responsive to said predict means, for establishing a value of the flag in said second field; and</claim-text><claim-text>control means, responsive to a value of the flag, for controlling execution and non-execution of an associated instruction, further comprising a register file including a plurality of registers, and wherein said control means includes:<claim-text>detecting means for detecting an instruction requiring writing of data into a register of said register file,</claim-text><claim-text>first flag storage means provided for each said register and responsive to said detecting means for storing a first flag indicating that an associated register is to be subject to data writing,</claim-text><claim-text>second flag storage means provided for each said register and responsive to said predict means, for storing a second flag indicating that the instruction requiring writing of data is an instruction dispatched after the prediction of a branch is made before the prediction is determined to be correct or incorrect, and</claim-text><claim-text>flag control means, responsive to said detecting means and said predict means, for controlling the second and third flags, said flag control means making all the third flags inactive when the prediction is determined to be correct, while making the second flag inactive for a register having the third flag active when the prediction is determined to be incorrect, an active third flag indicating that the content of an associated register is unavailable.</claim-text></claim-text></claim-text></claim>"}, {"num": 14, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"14\"><claim-text>14. A parallel processing system for pipeline processing of instructions including a branch instruction, each instruction being processed in a plurality of stages and a determination of either to branch or not to branch being found at a predetermined one of said stages, comprising:<claim-text>an instruction memory for storing said instructions;</claim-text><claim-text>means for compiling an application program and providing the instructions to be stored in the instruction memory;</claim-text><claim-text>fetching means for providing an address and fetching a plurality of instructions at a time from said instruction memory, said plurality of instructions fetched at a time being an instruction block;</claim-text><claim-text>decoder means for decoding said plurality of instructions fetched at a time and determining instructions to be executed in parallel; and</claim-text><claim-text>a plurality of function units for executing instructions provided by the decoder means including the instructions determined to be executed in parallel,</claim-text><claim-text>said means for compiling including<claim-text>means for detecting a branch instruction, and</claim-text><claim-text>forming means responsive to the detected branch instruction for forming a branch delay slot, said branch delay slot being an address range starting from an address immediately subsequent to the detected branch instruction to a last address of the instruction block fetched during said predetermined operation cycles which occur until determination of the branch result for the detected branch instruction, and said branch delay slot including a variable number of instructions and said instructions are only to be executed when a branch by the branch instruction is taken.</claim-text></claim-text></claim-text></claim>"}, {"num": 15, "parent": 12, "type": "dependent", "paragraph_markup": "<claim num=\"15\"><claim-text>15. A parallel processing unit according to claim 12, wherein<claim-text>said forming means includes a storage unit including a plurality of blocks of storage for sequentially storing instructions fetched in parallel from said instruction memory, the branch delay slot including instructions stored in a common block with the branch instruction and in a block adjacent in a downstream to said common block.</claim-text></claim-text></claim>"}, {"num": 16, "parent": 12, "type": "dependent", "paragraph_markup": "<claim num=\"16\"><claim-text>16. A parallel processing unit according to claim 12, wherein<claim-text>the branch delay slot includes instructions of an instruction at a branch target address to be executed when a branch is taken by the branch instruction through an instruction immediately before a next branch instruction in an instruction sequence.</claim-text></claim-text></claim>"}, {"num": 17, "parent": 12, "type": "dependent", "paragraph_markup": "<claim num=\"17\"><claim-text>17. A parallel processing unit according to claim 12, wherein<claim-text>said forming means includes storage means for queuing instructions fetched from said instruction memory.</claim-text></claim-text></claim>"}, {"num": 18, "parent": 12, "type": "dependent", "paragraph_markup": "<claim num=\"18\"><claim-text>18. A parallel processing unit according to claim 12, wherein<claim-text>said forming means includes a plurality of instruction registers for storing in parallel the plurality of instructions fetched from said instruction memory.</claim-text></claim-text></claim>"}, {"num": 19, "parent": 18, "type": "dependent", "paragraph_markup": "<claim num=\"19\"><claim-text>19. A parallel processing unit according to claim 18,<claim-text>wherein the branch delay slot is formed by instructions fetched simultaneously with and subsequently to the branch instruction, and instructions immediately subsequently fetched from said instruction memory and stored in said plurality of instruction registers at a time.</claim-text></claim-text></claim>"}, {"num": 20, "parent": 12, "type": "dependent", "paragraph_markup": "<claim num=\"20\"><claim-text>20. A parallel processing unit according to claim 12, wherein said storage means includes a queue memory.</claim-text></claim>"}, {"num": 21, "parent": -1, "type": "independent", "paragraph_markup": "<claim num=\"21\"><claim-text>21. A parallel processing unit comprising:<claim-text>and instruction memory for storing an instruction sequence having a plurality of instruction blocks, each of said instruction blocks including a plurality of instructions sequential in said instruction sequence;</claim-text><claim-text>an instruction fetch unit for providing addresses for said instruction memory and fetching the instruction blocks from said instruction memory sequentially, the plurality of instructions included in each instruction block being fetched in parallel, and a branch instruction included in a first instruction block of said plurality of instruction blocks;</claim-text><claim-text>an instruction issuance analysis unit inputting a plurality of instructions from said instruction fetch unit in parallel, for issuing instructions to be executed in parallel among the instructions inputted in parallel; and</claim-text><claim-text>a plurality of function units for executing instructions issued by said instruction issuance analysis unit in parallel;</claim-text><claim-text>a branch delay slot for said branch instruction being formed of a plurality of instructions stored in an address range of said instruction memory, the address range including sequential addresses starting from an address which accesses an instruction immediately subsequent to said branch instruction to a last address of a second instruction block of the instruction blocks immediately subsequent to said first instruction block in said instruction sequence, and</claim-text><claim-text>said plurality of instructions of said branch delay slot being executed in said plurality of function units only when a branch by said branch instruction is taken.</claim-text></claim-text></claim>"}, {"num": 22, "parent": 21, "type": "dependent", "paragraph_markup": "<claim num=\"22\"><claim-text>22. The parallel processing unit according to claim 21, further comprising:<claim-text>a branch processing unit receiving a plurality of instructions from said instruction fetch unit in parallel, for detecting said branch instruction and determining whether a branch by said branch instruction is taken, wherein</claim-text><claim-text>said instruction issuance analysis unit is responsive to said branch processing unit, for inhibiting the instructions of said branch delay slot from being issued to said plurality of function units when it is determined that a branch by said branch instruction is not taken.</claim-text></claim-text></claim>"}, {"num": 23, "parent": 21, "type": "dependent", "paragraph_markup": "<claim num=\"23\"><claim-text>23. The parallel processing unit according to claim 21, wherein<claim-text>said instruction fetch unit includes a queue having a plurality of storage units, each of said plurality of storage units addressed by a queue address and storing an instruction fetched from said instruction memory, and wherein</claim-text><claim-text>a plurality of storage units are grouped into a plurality of storage blocks, the instructions included in said first instruction block written into one of said plurality of storage blocks in parallel, while the instructions included in said second instruction block are written into another one of said plurality of storage blocks in parallel, and</claim-text><claim-text>the storage units for said first and second instruction blocks are addressed by sequential queue addresses.</claim-text></claim-text></claim>"}, {"num": 24, "parent": 23, "type": "dependent", "paragraph_markup": "<claim num=\"24\"><claim-text>24. The parallel processing unit according to claim 23, further comprising:<claim-text>a branch processing unit receiving a plurality of instructions from said instruction queue, for detecting said branch instruction and determining whether a branch by said branch instruction is taken, wherein</claim-text><claim-text>said instruction fetch unit further includes:<claim-text>a write pointer for indicating a head address of one of said plurality of storage blocks, instructions included in one of the instruction blocks being written into storage units included in the storage block having said head address in parallel;</claim-text><claim-text>a read pointer for indicating a read address of one of said plurality of storage units, instructions stored in storage units from a storage unit having said read address to a storage unit having an address being said read address plus a predetermined number being read out into said instruction issuance analysis unit; and</claim-text><claim-text>a control unit responsive to said branch processing unit, for controlling said write pointer to set a value of the head address and controlling said read pointer to set a value of the read address.</claim-text></claim-text></claim-text></claim>"}, {"num": 25, "parent": 21, "type": "dependent", "paragraph_markup": "<claim num=\"25\"><claim-text>25. The parallel processing unit according to claim 21, wherein<claim-text>said instruction fetch unit includes an instruction register for storing in parallel the instructions fetched from said instruction memory, said instruction register storing in parallel the instructions of said first instruction block including said branch instruction in a first period, and storing in parallel the instructions of said second instruction block in a second period following said first period.</claim-text></claim-text></claim>"}]}], "descriptions": [{"lang": "EN", "paragraph_markup": "<description lang=\"EN\" load-source=\"patent-office\" mxw-id=\"PDES67174536\"><?RELAPP description=\"Other Patent Relations\" end=\"lead\"?><p>This application is a continuation of application Ser. No. 07/910,885 filed Jul. 10, 1992 now abandoned.</p><?RELAPP description=\"Other Patent Relations\" end=\"tail\"?><?BRFSUM description=\"Brief Summary\" end=\"lead\"?><h4>BACKGROUND OF THE INVENTION</h4><p>1. Field of the Invention</p><p>The present invention relates generally to branch instruction processing methods and arrangements in parallel processing units.</p><p>2. Description of the Background Art</p><p>In a pipeline computer, instructions already in the pipeline are usually invalidated when a branch is taken. Such invalidating of instructions dispatched in the pipeline deteriorates the performance of the pipeline computer. For a better understanding of this situation, a processor including a five-stage pipeline as follows is to be considered.</p><p>IF: instruction fetch is made.</p><p>ID: instruction decode, reading from a register file, and a branch instruction are executed.</p><p>EXC: an operation is conducted using an ALU (Arithmetic and Logic Unit).</p><p>MEM: a memory (data memory) is accessed.</p><p>WB: writing of data into the register file is executed.</p><p>An operation of a pipeline when a branch is taken is illustrated in FIG. 1. When a branch does not exist, the pipeline sequentially executes given instructions. Therefore, instructions enter into the pipeline in the order of instructions i, i+1, i+2, i+3, . . . Assume that the instruction i+1 is a branch instruction. Whether or not a branch is actually taken by the instruction i+1 is not known until the end of the ID stage. Therefore, when the instruction i+1 enters the ID stage at time (cycle) T+2, the next instruction i+2 naturally enters the IF stage.</p><p>If it is known at the end of time T+2 that a branch is taken in accordance with the branch instruction i+1, the instruction to be executed next is not the instruction i+2 but a branch target instruction. Therefore, at this time (at the end of time T+2), the instruction i+2 is canceled. Assuming that the branch target instruction is an instruction j, the instruction j enters the IF stage at time T+3. More specifically, when a branch is taken, a time period of 1 clock during which no instruction is processed is generated to the pipeline. This empty time period of 1 clock in the pipeline degrades the processing speed of the processor, and the deterioration of the performance results.</p><p>Usually in an RISC (Reduced Instruction Set Computer), such deterioration of the performance by a branch instruction is prevented by the use of a delayed branch method. In delayed branch, instructions already in the pipeline when a branch is taken are not invalidated. In the case of delayed branch in which a time period with emptiness generated in the pipeline due to a branch being taken (branch delay) is \"1\" cycle, instructions are executed in the order:</p><p>BRANCH INSTRUCTION,</p><p>&lt;INSTRUCTION&gt;, and</p><p>BRANCH TARGET INSTRUCTION</p><p>The part of &lt;instruction&gt; is referred to as a branch-delay slot. The instruction of branch-delay slot is executed regardless of the presence or absence of a branch. Therefore, a compiler should form a branch slot by moving an instruction so that the result of execution is correct.</p><p>An instruction which can be moved to a branch-delay slot is shown in FIG. 2. In FIG. 2, each branch instruction is designated with \"IF . . . THEN\", and its branch target is shown by an arrow.</p><p>In FIG. 2(A), an instruction \"R1\u2190R2+R3\" is moved to a delay slot. The instruction \"R1\u2190R2+R3\" is executed regardless of the presence or absence of a branch by a branch instruction, and can therefore be moved to the branch delay slot unconditionally.</p><p>In the case of FIG. 2(B), when the branch target of a branch instruction is an instruction \"R4\u2190R5-R6\", this instruction \"R4\u2190R5-R6\" is moved to a delay slot. The instruction \"R4\u2190R5-R6\" in the delay slot is executed even if no branch is taken, and, therefore, it must be guaranteed that a correct result is obtained even in the event no branch is taken.</p><p>In FIG. 2(C), the instruction \"R4\u2190R5-R6\" next to the delay slot is moved into the delay slot. In this case, the instruction \"R4\u2190R5-R6\" is originally an instruction which is not executed when a branch is taken, and, therefore, it must be guaranteed that a correct result is also provided even when a branch is taken.</p><p>Now, a description of a superscalar follows. The superscalar is a processor including the characteristic features of:</p><p>(1) fetching a plurality of instructions;</p><p>(2) having a plurality of function units and executing a plurality of instructions at a time; and</p><p>(3) detecting simultaneously executable instructions out of the fetched plurality of instructions and dispatching these simultaneously executable instructions to associated function units.</p><p>A general structure of a superscalar is illustrated in FIG. 3. In FIG. 3, the superscalar includes an instruction memory 1 for storing instructions, an instruction fetch stage (IF stage) 2 for transmitting to instruction memory 1 the addresses of instructions to be fetched, an instruction decode stage (ID stage) 3 for executing decoding of the fetched plurality of instructions, reading from a register file (not shown), and branch instructions, function units 4a, 4b, 6, and 7 each for executing a prescribed operation, and a data memory 8 for storing data.</p><p>Instruction decode stage 3 also detects simultaneously executable instructions out of the decoded plurality of instructions, and dispatches these simultaneously executable instructions into function units 4a, 4b, 6, and 7.</p><p>Function units 4a and 4b execute integer addition, etc. Function unit 6 executes loading or storing of data from/into data memory 8. Function unit 7 executes floating point addition, etc.</p><p>Function units 4a, 4b, 6, and 7 each include a plurality of pipelined stages. Function units 4a and 4b includes an execution stage EXC for executing a given instruction, and a register file writing stage WB for writing the result of the execution into a register file (not shown). Function unit 6 includes an address calculation stage ADR for calculating an address to access data memory 8 from the given instruction, a memory access stage MEM for accessing data memory 8 in accordance with the calculated address, and a register file writing stage WB for writing data loaded from data memory 8 into the register file.</p><p>Function unit 7 includes three execution stages EXC1, EXC2, and EXC3, and a register file writing stage WB for writing the result of the execution into the register file. In the superscalar, as shown in FIG. 3, a plurality of instructions are simultaneously fetched from instruction memory 1, and a plurality of instructions are executed in parallel to each other in function units 4a, 4b, 6, and 7, and, therefore, an improved processing speed is provided as compared to a usual processor having only one pipeline.</p><p>An operation of a pipeline when a branch is taken in a superscalar is shown in FIG. 4. In FIG. 4, an operation of the pipeline in the superscalar by which two instructions are fetched at a time and maximum two integer operations can be executed simultaneously is illustrated. Assume that an instruction i+3 is a branch instruction and it is known when the instruction i+3 has reached the ID stage (instruction decode stage) that a branch is taken. At this time, instructions i+4 and i+5 are already in the IF stage (instruction fetch stage). These instructions i+4 and i+5 are canceled when the generation of the branch is known.</p><p>A branch target instruction, instruction j is started from time (cycle) T+3.</p><p>As shown in FIG. 4, in the superscalar, a plurality of instructions are executed at a time, a plurality of instructions to be canceled exist, and greater effects are given on the performance as compared to a processor including only one pipeline.</p><p>If a delayed branch method in which a branch delay slot is dispatched after this branch instruction is employed, a plurality of instructions should be provided as branch delay slots.</p><p>According to the recitation of \"Computer Architecture: A Quantitative Approach\" by J. Hennessy, D. A. Patterson, P. 276, FIG. 6. 22, the probability that a branch delay slot will be filled by an instruction moved by a compiler is about 50%. NOP instructions, etc. are usually inserted into branch delay slots which can not be filled by a significant instruction. Therefore, in a superscalar in which a plurality of branch delay slots exists, the probability that all the branch delay slot are filled with moved instructions would be very low.</p><p>Also in the superscalar, instructions which can be moved to branch delay slots can be moved for execution together with other instructions as simultaneously executable instructions, before being used to fill the branch delay slots. Accordingly, in the superscalar, it is difficult to improve its performance in accordance with a conventional delayed branch method.</p><h4>SUMMARY OF THE INVENTION</h4><p>It is an object of the present invention to provide a branch instruction processing method and scheme in a parallel processing unit by which the performance of the unit will not deteriorate when a branch is taken.</p><p>In a branch instruction processing method and arrangement according to a first aspect, a branch delay slot is defined as all instructions including an instruction positioned next to a branch instruction and instructions fetched during cycles for fetching and execution of the branch instruction.</p><p>In a branch instruction processing method and arrangement in accordance with a second aspect, a queue memory for instruction prefetch for prefetching an instruction from an instruction memory and storing the prefetched instruction is provided. A field for indicating in each entry of the queue memory that the instruction stored in the associated entry has been executed in accordance with a branch prediction is provided in the queue memory, and execution/execution inhibition of an instruction is controlled based on the value of the field.</p><p>In the first aspect, when the result of execution of a branch instruction is not a branch, an instruction to be fetched in a cycle next to the one in which a branch instruction is executed is for a branch delay slot, and, therefore, the instruction is executed without any delay due to a branch.</p><p>If the result of execution of the branch instruction is a branch, an instruction to be fetched in the next cycle next to the one in which the branch instruction is executed is to be executed next. If this instruction has been prefetched in a queue memory, a branch target instruction can be executed without any delay due to a branch simply by moving the read pointer of the queue memory.</p><p>In the second aspect, each instruction is linked with a field indicating whether or not execution has been made based on a branch prediction, and if the branch prediction is correct, the branch prediction instruction is executed, whereby time required for fetching another branch target instruction is saved, easing the deterioration of the performance.</p><p>The foregoing and other objects, features, aspects and advantages of the present invention will become more apparent from the following detailed description of the present invention when taken in conjunction with the accompanying drawings.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 is a table for illustrating a conventional branch delay operation;</p><p>FIGS. 2(a), 2(b) and 2(c) are representations for illustrating how a branch delay slot is filled with an instruction;</p><p>FIG. 3 is a representation showing a general structure of a superscalar;</p><p>FIG. 4 is a table for illustrating a branch delay operation in a superscalar;</p><p>FIG. 5 is a block diagram showing a structure of an instruction decode stage in accordance with one embodiment of the present invention;</p><p>FIG. 6 is a representation showing the basic operation of the instruction queue shown in FIG. 5;</p><p>FIG. 7 is a representation for illustrating the definition of a branch delay slot;</p><p>FIG. 8 is a representation showing the operation of an instruction queue when a branch is taken by a branch instruction and a branch delay slot has not yet been fetched;</p><p>FIG. 9 is a representation showing the state of a cycle next to the instruction queue shown in FIG. 8;</p><p>FIG. 10 is a representation showing the state of a cycle next to the instruction queue shown in FIG. 9;</p><p>FIG. 11 is a representation showing the operation of an instruction queue when a branch is taken by a branch instruction and a branch delay slot has already been fetched;</p><p>FIG. 12 is a representation showing the operation of an instruction queue when a branch is taken by a branch instruction and a branch delay slot has already been fetched;</p><p>FIG. 13 is a representation showing the operation of an instruction queue when a branch is taken by a branch instruction and a branch delay slot has already been fetched;</p><p>FIG. 14 is a representation showing the operation of an instruction queue when no branch is taken by a branch instruction, and a branch delay slot has already been fetched;</p><p>FIG. 15 is a representation showing the operation of an instruction queue when a branch is not taken by a branch instruction, and a branch delay slot has not yet been fetched;</p><p>FIG. 16 is a representation showing the operation of an instruction queue when a branch is not taken by a branch instruction, and a branch delay slot has not yet been fetched;</p><p>FIG. 17 is a representation showing the operation of an instruction queue when a branch is not taken by a branch instruction, and a branch delay slot has already been fetched;</p><p>FIG. 18 is a representation showing the operation of an instruction queue when a branch is not taken by a branch instruction, and a branch delay slot has already been fetched;</p><p>FIG. 19 is a table showing logics in the pointer control portion shown in FIG. 1;</p><p>FIGS. (20A) and (20B) are a logic diagrams showing the structure of the pointer control portion shown in FIG. 1;</p><p>FIG. 21 is a block diagram showing the structure of an instruction issuance analysis portion in accordance with the first embodiment of the present invention;</p><p>FIG. 22 is a logic diagram showing the structure of the issuance inhibition portion shown in FIG. 21;</p><p>FIG. 23 is a block diagram showing the structure of an instruction decode device used in a second embodiments of the present invention;</p><p>FIGS. (24A), (24B) and (24C) are representations showing the operation of an instruction register when a branch is taken by a branch instruction in the structure of the instruction decode stage shown in FIG. 23;</p><p>FIGS. (25A), (25B) and (25C) are representations showing the operation of the instruction register shown in FIG. 23 when a branch is not taken by a branch instruction;</p><p>FIG. 26 is a block diagram showing the structure of the instruction issuance analysis portion shown in FIG. 23;</p><p>FIG. 27 is a block diagram showing the structures of an instruction fetch stage and an instruction decode stage used in accordance with the second aspect of the present invention;</p><p>FIG. 28 is a representation showing a structure for making control based on an instruction validity flag and a branch prediction flag in an execution stage EXC and presence and absence of a branch.</p><p>FIG. 29 is a schematic representation generally showing the structure shown in FIG. 28;</p><p>FIG. 30 is a truth table for the control signals of a scoreboard for monitoring decision of the content of a register file;</p><p>FIG. 31 is a diagram showing the structure of logic circuitry for implementing the truth table shown in FIG. 30; and</p><p>FIG. 32 is a diagram showing the structure of the instruction decoder shown in FIG. 27.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DESCRIPTION OF THE PREFERRED EMBODIMENTS</h4><h4>EMBODIMENT 1</h4><p>The structure of the essential part of an instruction decode stage in a parallel processing unit in accordance with one embodiment of the present invention is shown in FIG. 5. In FIG. 5, the instruction decode stage includes an instruction queue 9, an instruction issuance analysis section 10, a pointer control section 12, and a branch processing section 11.</p><p>Instruction queue 9 prefetches a plurality of instructions (instructions 1-4) from an instruction memory 1 (see FIG. 3) and stores the prefetched instructions. Queue 9 includes a memory portion (queue) 13 for storing the instructions, a read pointer 14 for holding a read address scope, and a write pointer 15 for holding a write address queue<sub>--</sub> top.</p><p>Instruction issuance analysis section 10 analyzes which instruction among the instructions read out from instruction queue 9 is issuable. The result of the analysis by instruction issuance analysis section 10 is attached to each instruction in a form of a signal inst<sub>--</sub> avail for output. When the signal inst<sub>--</sub> avail is on, the corresponding instruction is an instruction issuable and to be executed. In the structure shown in FIG. 5, four instructions starting from the read address scope are read out from instruction queue 9 at a time, and issuance analysis is conducted at instruction issuance analysis section 10. For the signal inst<sub>--</sub> avail of 4 bits, if an instruction is issuable, a corresponding signal inst<sub>--</sub> avail is turned on. Instruction issuance analysis section 10, based on the signal inst<sub>--</sub> avail, generates a signal issue<sub>--</sub> count indicating the number of issuable instructions, and sends the generated signal to pointer control section 12.</p><p>If a branch instruction is included in the given instructions, instruction issuance analysis section 10 also sends a value br<sub>--</sub> block which ignores or truncates the less significant 2 bits of the address of instruction queue 9 storing the branch instruction.</p><p>If the instructions read out from instruction queue 9 include branch conditions (in the case of a conditioned branch instruction), branch processing section 11 tests the branch condition, and decides whether or not a branch should be taken. If a branch should be taken, branch processing section 11 turns on a signal Taken and if a branch is not taken, turns on signal Not Taken.</p><p>Pointer control section 12 controls the values of the read pointer scope and write pointer queue<sub>--</sub> top of pointers 14 and 15 of instruction queue 9. Pointer control section 12 generates a signal issue<sub>--</sub> stop which entirely inhibits issuance of the instructions from instruction decode stage ID to pipelines and applies the generated signal to instruction issuance analysis section 10.</p><p>In the structure of such a superscalar by which four instructions are fetched from the instruction memory at a time and the four instructions are decoded at a time, the instructions (instructions 1-4) supplied from instruction memory 1 are stored in four addresses of queue 13 starting from the write address queue<sub>--</sub> top. In the next cycle, 4 is added to write pointer queue<sub>--</sub> top.</p><p>The four instructions stored in the four addresses of queue 13 starting from read pointer scope are read out from queue 13, applied to instruction issuance analysis section 10 and a decode circuit (not shown) to be analyzed and decoded. As a result of this analysis, if n instructions are issued, n is added to the value of the read pointer scope in the next cycle.</p><p>FIG. 6 illustrates the operation of instruction queue 9. In FIG. 6, the size (the number of entries) of queue 13 is set to be 16.</p><p>In cycle T, write address queue<sub>--</sub> top represents 8. The four instructions read out from the instruction memory are written in addresses 8, 9, 10, and 11.</p><p>Read pointer scope indicates 3, and instructions in the addresses 3, 4, 5, and 6 of queue 13 are read out. In this cycle T, assume that 2 instructions are dispatched to function units. In other words, the number of issued instructions (issue-count) is 2. In this case, in the next cycle T+1, the value of read pointer scope is increased by 2 to be 5. Write pointer queue<sub>--</sub> top is increased by 4 to be 12. Queue 13 can write 4 instructions at a time, and read 4 instructions at a time. These writing operation and reading operation can be carried out asynchronously.</p><p>In order to decide a branch delay slot, an instruction block is defined. The following four instructions are called an instruction block:</p><p>instructions whose addresses in an instruction queue are 4n, 4n+1, 4n+2, and 4n+3 (n: integer).</p><p>A branch delay slot is defined to be in the range from a slot next to a branch instruction to the last slot of an instruction block next to an instruction block including a branch instruction. FIG. 7 illustrates an instruction block and a branch delay slot. In FIG. 7, if a branch instruction is included in a block B1, the range from a slot next to the branch instruction to the last slot of the next block B2 adjacent to this block B1 is defined as a branch delay slot (designated with slanted lines in FIG. 7). In the case of FIG. 7, the number of instructions included in the branch delay slot (the number of slots) is 5.</p><p>The branch delay slot is filled with instructions on the side of branching (instructions to be executed after a branch). Instructions to fill the branch delay slot are only needed to be instructions on the side of branching and instructions other than a branch instruction. More specifically, any instruction in the range from the address of a branch target instruction to an address preceding by one address to a branch instruction to be executed next will do. In a conventional delay branch method, instruction by which a correct result is provided in whatever direction a branch is directed (the presence/absence of a branch) is selected to fill a branch delay slot.</p><p>According to the present invention, the branch delay slot is only filled with instructions on the side of branching. If the result of an execution of a branch instruction indicates that no branch is taken, and the signal Not Taken is turned on, hardware makes a control so that instructions which fill the branch delay slot will not be executed. A description of an operation of an instruction queue when a branch instruction is executed follows.</p><p>\"When a branch is taken: the signal Taken is on\"</p><p>Assume that the value of an address in queue 13 with its less significant 2 bits omitted at which a branch instruction is stored is br<sub>--</sub> block, and the value of a write address queue<sub>--</sub> top with its less significant 2 bits omitted at the time is qt<sub>--</sub> block. A block at which a branch instruction is stored (a block in queue 13), and a block at which an instruction is written at the time are respectively shown both by omitting less significant 2 bits.</p><p>When the block addresses br<sub>--</sub> block and qt<sub>--</sub> block are equal, it indicates that a branch delay slot is not yet fetched into an instruction queue 9. In this case, the branch delay slot should be fetched in the next cycle. A given instruction is just written in the next block in queue 13. Therefore, 4 is added to a write pointer queue<sub>--</sub> top. This is represented by the following expressions.</p><p>br<sub>--</sub> block=(the address of a queue at which a branch instruction is stored) (3 . . . 2)</p><p>qt<sub>--</sub> block=queue<sub>--</sub> top (3 . . . 2)</p><p>If br<sub>--</sub> block==qt<sub>--</sub> block</p><p>then queue<sub>--</sub> top=queue<sub>--</sub> top+4, where qt<sub>--</sub> block=queue<sub>-</sub> top (3 . . . 2) indicates substitution of the second and third bits of write pointer queue<sub>--</sub> top into qt<sub>--</sub> block (equivalent to omission of the less significant 2 bits, bits 0 and 1). Queue 13 has 16 entries, and the write pointer and read pointer of the queue are represented by 4 bits. Therefore, a block in the queue is identified by observing the more significant 2 bits, bits 2 and 3. Also in the above expression, \"==\" indicates that its right side and left side are equal in value.</p><p>The br<sub>--</sub> block and the qt block not being equal indicates that the branch delay slot has already been fetched and stored in instruction queue 9. In this case, an address in queue 13 for storing a branch target instruction, in other words an address next to a queue address at which in turn the branch delay slot is stored is set to the write pointer queue top. More specifically,</p><p>If br<sub>--</sub> block|=qt<sub>--</sub> block then queue<sub>--</sub> top=br<sub>--</sub> block ##0<sup>2</sup> +8.</p><p>In this expression, \"|=\" indicates that its right side and left side are not equal in value. \"##\" indicates that its right term and left term are combined. X<sup>n</sup> indicates that an operation X is repeated n times. Therefore, in the above expression, br<sub>--</sub> block ##0<sup>2</sup> indicates that the value br<sub>--</sub> block is set to be most significant 2 bits and 0 is added to its less significant 2 bits. The head or starting address of a block in which a branch instruction is included is produced by this operation. Adding 8 to this head address produces the head address of a block next to the next block.</p><p>Furthermore, in this case, in the next cycle after the branch instruction was executed, a branch target instruction is not transmitted from the instruction memory (see FIG. 4). Therefore, in the next cycle after the branch instruction was executed, the write pointer queue<sub>--</sub> top is set to be the same as the value when the branch instruction was executed.</p><p>The read pointer scope is updated in the same manner as the case other than the case where a branch instruction is executed, regardless of a branch delay slot having been already fetched or not.</p><p>A detailed description of the aforementioned operation follows in conjunction with the drawings. An operation of a queue when a branch delay slot has not yet been fetched in a cycle in which a branch instruction is executed is shown in FIGS. 8 to 10.</p><p>FIG. 8 illustrates one example of the state of an instruction queue 9 in the cycle in which a branch instruction is executed. The read pointer scope and write pointer queue<sub>--</sub> top are both kept at the value of 0. Assume that a branch instruction exist in the address 2 of queue 13, and this branch instruction is executed in this cycle.</p><p>In the next cycle shown in FIG. 9, from the expression br<sub>--</sub> block==qt<sub>--</sub> block, the write pointer queue<sub>--</sub> top is increased by 4 and becomes 4. The addresses 4, 5, 6, and 7 of queue 13 are written with the instructions of a delay slot (instructions on the side of branching). At the time, the instruction memory is accessed in accordance with a branch target address.</p><p>In the next cycle, as shown in FIG. 10, the write pointer queue<sub>--</sub> top is increased by 4 to be 8. An instruction on a branch target is transmitted from the instruction memory. The addresses 8, 9, 10, and 11 of queue 13 are written with the instruction on the branch target. The instruction in the delay slot shown by the read pointer scope which underwent change in accordance with an issued instruction(s) are instructions on the side of branching. After an issuance of an instruction in the branch delay slot, the fetched branch target instructions are transmitted to a decode stage. Therefore, if a branch delay slot has not yet been fetched in the cycle in which a branch instruction is executed, performance deterioration (emptiness in a pipeline) due to the branch being taken is not generated.</p><p>FIGS. 11 to 13 illustrate the states of instruction queue 9 when a branch delay slot has already been fetched in the cycle in which a branch instruction is executed.</p><p>FIG. 11 shows one example of the state of queue 13 in the cycle in which a branch instruction is executed. The read pointer scope indicates 0, and the write pointer queue<sub>--</sub> top indicates 12. Now, consider a case where a branch instruction exists in the address 2 of queue 13 and the branch instruction is executed in this cycle.</p><p>In the next cycle shown in FIG. 12, the write pointer queue<sub>--</sub> top becomes 8 in order to hold the next address of the branch delay slot. In this cycle, an instruction incoming from the instruction memory is an unnecessary instruction. In other words it is an instruction on a branch target side other than the delay slot (an instruction to be executed when a branch is not taken). Therefore, in the next cycle shown in FIG. 13, the value of the write pointer queue<sub>--</sub> top is not updated. This unnecessary instruction may be written in queue 13. This instruction is to be only replaced with a branch target instruction in the next cycle.</p><p>In the cycle shown in FIG. 12, the instruction memory is accessed in accordance with a branch target address.</p><p>In the cycle shown in FIG. 13, a branch target instruction is transmitted from the instruction memory. The write pointer queue<sub>--</sub> top holds the next value of the branch delay slot. Therefore, queue addresses 8, 9, 10, and 11 are written with branch target instructions. As can be clearly seen from the operation shown in FIGS. 11 to 13, if a branch delay slot has already been fetched in the cycle in which a branch instruction is executed, no performance deterioration is caused by a branch taking.</p><p>\"When a branch is not taken: Not Taken is on\"</p><p>Among the instructions read out from instruction queue 9 and decoded, an instruction behind a branch instruction is invalidated. This is because the instructions behind the branch instruction correspond to a branch delay slot and the branch delay slot includes only instructions on the side of branching. As described above, an instruction on the side of branching which is in a branch delay slot is an branch target side instruction to be executed when a branch is taken by this branch instruction. More specifically, the instructions on the side of branching range from an instruction of a branch target address executed when a branch is taken by a branch instruction associated with this branch delay slot to an instruction in an address instruction preceding by one instruction to the branch instruction to be executed next. Therefore, when a branch is taken, an instruction to be dispatched into a branch target instruction block is an instruction to be executed subsequently to instructions constituting the delay slot.</p><p>If no branch is taken and the signal Not Taken is on, an instruction in the branch delay slot must not be executed in the next cycle. The instruction in the branch delay slot is skipped, and the next instruction should be executed. Therefore, the read pointer scope is represented by the following expression:</p><p>scope=br<sub>--</sub> block##0<sup>2</sup> +8</p><p>If an instruction block next to the branch delay slot has already been fetched, an instruction to be executed has already been fetched in the cycle next to the cycle in which the branch instruction is executed. Therefore, no deterioration in performance is caused by the execution of the branch instruction.</p><p>If the branch delay slot has not yet fetched, in other words if the pointer br<sub>--</sub> block and the pointer qt<sub>--</sub> block are equal, an instruction to be executed has not yet been fetched in the cycle next to the cycle in which the branch instruction is executed. In order to wait for fetching of the instruction to be executed, the pipeline should be stopped for 1 cycle. More specifically, if the pointer br<sub>--</sub> block and the pointer qt<sub>--</sub> block are equal, issuance of any instruction is inhibited in the next cycle.</p><p>Regardless whether or not the branch delay slot has already been fetched, the write pointer queue<sub>--</sub> top is updated in the same manner as the case other than the case where a branch instruction is executed.</p><p>FIGS. 14 to 16 specifically illustrate an operation of an instruction queue when the signal Not Taken is on and a branch delay slot has not yet been fetched. Referring to FIGS. 14 to 16, a description of the operation of the instruction queue when a branch is taken by a branch instruction and a branch delay slot has not yet been fetched follows.</p><p>FIG. 14 shows one example of the state of queue 13 in the cycle in which a branch instruction is executed. The read pointer scope and the write pointer queue<sub>--</sub> top both indicate 0. Assume that a branch instruction exist in the address 2 of queue 13, and the branch instruction is executed in this cycle.</p><p>In the cycle next to the branch instruction execution shown in FIG. 15, the write pointer queue<sub>--</sub> top is subjected to addition of 4 and becomes 4. Addresses 4, 5, 6, and 7 of queue 13 are written with instructions in a delay slot. Instructions to be executed are not stored in the addresses 8, 9, 10, and 11 of queue 13. Issuance of an instruction in this cycle is inhibited. More specifically, an issuance inhibition signal issue<sub>--</sub> stop is transmitted to the instruction issuance analysis section 10 shown in FIG. 15, and issuance of instructions is inhibited.</p><p>In the next cycle (FIG. 16), the write pointer queue<sub>--</sub> top is subjected to addition of 4 and becomes 8. At the time, with the read pointer scope indicating 8, the instruction block transmitted from the instruction memory is simultaneously read out and sent to the instruction decoder.</p><p>The stages of the superscalar operate with non-overlapping two phase clock (T clock and L clock), the input stage of each stage is provided with a latch circuit responsive to the T clock for latching an applied signal, and the output portion is provided with an L latch responsive to an L clock signal for latching an applied signal. At that time, writing of data into queue 13 is conducted in response to the T clock signal, while reading of data is conducted in response to the L clock signal, and, therefore writing of an instruction applied from the instruction memory into queue 13 and transmission thereof into the instruction decoder are implemented at a time. These writing and reading of data may be conducted in response to the T clock signal, with the reading timing for data being retarded to the writing timing of data, and the data of queue 13 may be read out when it is decided.</p><p>In the cycle in which a branch instruction is executed shown in FIGS. 17 and 18, an operation of a queue when a branch delay slot has already been fetched will be described.</p><p>FIG. 17 illustrates one example of the state of instruction queue 9 in the cycle in which a branch instruction is executed.</p><p>The read pointer scope indicate 0, while the write pointer queue<sub>--</sub> top indicates 8. Assume that a branch instruction exists in the address 2 of queue 13, and the branch instruction is executed in the cycle shown in FIG. 17.</p><p>In the next cycle shown in FIG. 18, the read pointer scope becomes 8 in order to indicate the next address of the delay slot. The write pointer queue<sub>--</sub> top is increased by 4 to become 12 as in a usual case.</p><p>As described above, when a branch delay slot has already been fetched in the cycle in which a branch instruction is executed, no deterioration is caused in performance due to the execution of the branch instruction. If no branch delay slot has been fetched, fetch waiting for 1 cycle is caused when a branch is not taken. However, generally, if the bandwidth of instruction fetch (the number of instructions fetched in one cycle) is set larger than the average speed of instruction issuance (the average number of instructions issued in one cycle), the probability that a delay slot will have already been fetched in the cycle in which a branch instruction is executed is high. Therefore, this structure keeps the probability very low that the performance of the processing unit will deteriorate by execution of a branch instruction.</p><p>FIG. 19 shows a list of logics (described above) achieved by a pointer control section 12. In FIG. 19, \"\u00d7\" indicates an arbitrary value. \"-\" indicates that it is not specified.</p><p>The structure of the pointer control portion is shown in FIGS. 20A and B. In FIGS. 20A and 20B, 16a denotes an adder for adding the output of a register 15 and the number 4, 16b denotes an adder for adding the output pointer scope of a register 14 and issued instruction information issue<sub>--</sub> count, 16c denotes an adder for adding the head address br<sub>--</sub> block ##0<sup>2</sup> of a block including a branch instruction (a block in a queue) and the number 8, 17a denotes a selector for selecting one of the output queue<sub>--</sub> top of register 15, the output of adder 16a, and the output of adder 16c, and writing the result of selection into register 15, 17b denotes a selector for selecting one of the output of adder 16b and the output of adder 16c, and writing the selected output into register 14, 18 denotes a comparator for comparing the pointer br<sub>--</sub> block and the pointer qt<sub>--</sub> block, 21 denotes an invertor for inverting the output of comparator 18, 22 denotes an AND circuit for producing the logical product of the output of comparator 18 and the signal Not Taken, 23 denotes an inverter for inverting the signal Not Taken, 24 denotes an AND circuit for producing the logical product of the output of inverter 21 and the signal Taken, 19 denotes a register for holding (delaying) the output of AND circuit 24 for 1 clock, and 25 denotes an NOR circuit for producing the negative logical sum of the output of AND circuit 24 and the data held in register 19.</p><p>An issuance inhibition signal issue<sub>--</sub> top is generated from AND circuit 22. Signals sel<sub>--</sub> c, sel<sub>--</sub> a and sel<sub>--</sub> b are signals for selecting corresponding inputs of selector 17a.</p><p>Signals sel<sub>--</sub> d and sel<sub>--</sub> e are signals for selecting corresponding inputs of selector 17b.</p><p>FIG. 21 shows the structure of issuance analysis section 10 shown in FIG. 5. In FIG. 21, instruction issuance analysis section 10 includes a hazard analysis portion 30, an issuance inhibition section 31 issuance number calculating section 32, and a gate 33 for controlling an availability signal inst<sub>--</sub> avail in accordance with the issuance inhibition signal issue<sub>--</sub> inhibit.</p><p>Hazard analysis section 30 analyzes hazard between instructions. Four instructions, instructions 1-4 are input into hazard analysis section 30. Among the input instructions, if the i-th instruction is free from any hazard, the i-th signal ia (availability signal) is turned on. \"Hazard\" indicates the state in which the value of a register (in a register file) to be used by an instruction is not determined. This analysis of hazard is conducted in accordance with the scoreboard of the register file (which will be later described).</p><p>Issuance inhibition section 31 receives the instructions 1-4, and produces a signal ignoring the less significant 2 bits of the address scope of a queue in which a branch instruction is stored, in other words produces a block address br<sub>--</sub> block for an instruction queue the branch instruction belongs to. Issuance inhibition section 31 also turns on a corresponding issuance inhibition signal issue<sub>--</sub> inhibit in order to inhibit issuance of an instruction which should be inhibited from being issued under any condition except for hazard. The issuance inhibition signal issue<sub>--</sub> inhibit is turned on by an issuance stop signal issue<sub>--</sub> stop transmitted from pointer control section 12, or is turned on for the instructions following a branch instruction when the signal Not Taken is on.</p><p>Gate 33 includes an inverter for inverting the issuance inhibition signal issue<sub>--</sub> inhibit from issuance inhibition section 31, and an AND circuit for receiving this inverter output and the signal ia from hazard analysis section 30. The inverter and AND circuit are provided correspondingly to instructions. The availability signals inst<sub>--</sub> avail are generated from gate 33 correspondingly to the instructions. More specifically, the signal inst<sub>--</sub> avail is the logical product of the signal ia and the signal/issue<sub>--</sub> inhibit (not issue inhibit).</p><p>Issuance number calculating section 32 receives the signals inst<sub>--</sub> avail from gate 33, calculates the number of instructions issued, and generates a signal issue<sub>--</sub> count indicating the number of issued instructions.</p><p>FIG. 22 is a logic diagram showing the issuance inhibition section shown in FIG. 21. In FIG. 22, a branch detection circuit 43 is provided correspondingly to each of the instructions 1-4. Branch detection circuit 43 detects whether or not an applied instruction is a branch instruction and turns on the output signal if the applied instruction is a branch instruction.</p><p>The output of branch detection circuit 43 is applied to a priority encoder 44. Priority encoder 44 detects the position of the branch instruction of the smallest address. A signal (2 bit data) indicating the position of the priority branch instruction is output from priority encoder 44. The output of priority encoder 44 is applied to adder 45. Adder 45 adds up the output of priority encoder 44 and the read pointer scope. The output of adder 45 indicates the address of the branch instruction in a queue. The output of adder 45 is applied to a less significant bit mask circuit 46. Less significant bit mask circuit 46 truncates the less significant 2 bits of the output (sets to \"0\"), and thus outputs a pointer br<sub>--</sub> block.</p><p>OR gates OR1-OR5 and AND gates AN1-AN3 are provided in order to control inhibition of issuance of instructions. If an instruction 1 is a branch instruction, one input of each of AND gates AN1-AN3 is pulled to \"H\". At this time, if the signal Not Taken attains \"H\", no branch is taken, and issuance of the instructions 2-4 is inhibited, resulting in the on state of the signal issue<sub>--</sub> inhibit. If the signal Not Taken is off, the issuance inhibition signal issue<sub>--</sub> inhibit to each of the instructions 2-4 is off, and, therefore, the instructions are issued. If any of the instructions 2-4 is a branch instruction, the position of the issuance inhibition signal issue<sub>--</sub> inhibit in each output portion is just shifted by 1. If the signal issue<sub>--</sub> stop is turned on, the instructions 1-4 are inhibited from being issued.</p><h4>EMBODIMENT 2</h4><p>In the above-stated embodiment 1, the instruction is prefetched in instruction queue 9. Now, a structure which use a usual instruction register and does not prefetch an instruction will be described.</p><p>FIG. 23 shows the essential structure of an instruction decode stage used in the second embodiment. In FIG. 23, the instruction decode stage includes an instruction register 54 for storing applied instructions (instructions 1-4), a branch processing section 11 for receiving an instruction from instruction register 54, detecting a branch instruction and determining whether or not a branch is taken, and an instruction issuance analysis section for receiving a signal Not Taken from branch processing section 11 and a instruction from instruction register 54 and analyzing the applied instruction as to whether or not the instruction: should be issued. In the structure shown in FIG. 23, with no instruction queue provided, a structure for controlling the pointer of an instruction queue is not provided. In the structure shown in FIG. 23, the definition of a branch delay slot is the same as that stated in the description of embodiment 1.</p><p>An operation of the instruction register when a branch is taken by a branch instruction is shown in FIG. 24. Among the instructions taken up into instruction register 54, consider that the second instruction is a branch instruction (FIG. 24A). In branch processing section 11, it is known that a branch is to be taken based on a execution of this branch instruction, the signal taken is turned on, and a branch target address is transmitted to the instruction memory. Instruction issuance analysis section 10 analyzes whether or not the instruction stored in instruction register 54 can be issued to a function unit, and turns on the signal inst<sub>--</sub> avail based on the result of the analysis. Assume that four instructions are issued.</p><p>In the next cycle shown in FIG. 24B, instructions in a branch delay slot are fetched into instruction register 54. These instructions are dispatched to function units.</p><p>In the next cycle (FIG. 24C), a branch target side instruction applied from instruction memory is stored in register memory 54 and subsequently executed.</p><p>As the case of the structure shown in FIG. 24, using instructions on the side of branching as a branch delay slot, no deterioration in performance is caused due to a branch if the signal Taken is on when the branch is taken.</p><p>FIG. 25 is a representation showing an operation of an instruction register when a branch is not taken, in other words the signal Not Taken is on. Now, referring to FIG. 25, an operation of the instruction register when the signal Not Taken is on will be described.</p><p>Among the instructions taken up into register 54, assume that the second instruction is a branch instruction (FIG. 25A). Branch processing section 11 executes this branch instruction, knows that the signal Not Taken should be issued (should be turned on), and turns on the signal Not Taken, signaling instruction issuance analysis section 10. Instruction issuance analysis section 10 inhibits unconditionally issuance of instructions following the branch instruction.</p><p>In the next cycle (FIG. 25B), instructions in the branch delay slot are fetched to instruction register 54. In this cycle, issuance of instructions are inhibited.</p><p>In the next cycle (FIG. 25C), instructions next to the delay slot arrive, which are registered in instruction register 54, and are subsequently executed.</p><p>As shown in FIGS. 25A-C, if no branch is taken and the signal Not Taken is on, issuance of instructions is inhibited for 1 clock cycle, resulting in deterioration in performance. If this branch is not taken (the signal Not Taken is on) the following method by which two kinds of branch instructions as follows are prepared is employed in order to prevent this deterioration in performance. More specifically, these approaches are:</p><p>(a) to fill a branch delay slot with instructions on the side of branching (branch target side), and</p><p>(b) to fill the branch delay slot with instructions on the side of not branching.</p><p>The former approach (a) is used in EMBODIMENT 1 and EMBODIMENT 2. The latter approach (b) is the same as the case in which a delayed branch method is not used. In other words the approach does not take advantage of a delayed branch method. The former approach (a) does not suffer from performance deterioration when a branch is taken, and is employed for a branch instruction with a high probability of branching. The latter approach (b) does not suffer from deterioration in performance when no branch is taken, and is employed for a branch instruction with a low probability of branching. In this case, an instruction register for receiving the output of instruction queue may be provided in an ID stage, or only the instruction queue may be used.</p><p>FIG. 26 shows one example of the structure of instruction issuance analysis section 10 shown in FIG. 23. The structure of the instruction issuance analysis section shown in FIG. 26 is similar to that shown in FIG. 21. However, issuance inhibition section 31 is provided with the signal Not Taken, and the issuance inhibition signal issue<sub>--</sub> stop through a register 35. Register 35 has a function of delaying the signal Not Taken for 1 clock cycle. The other structure is similar to that in FIG. 21. Since an instruction queue and/or an instruction register are used for issuance inhibition section 31 as is the case with the structure shown in FIG. 22, a priority encoder for detecting the priority branch instruction among instructions 1-4 and indicating its position is provided, and the structure of the less significant bit mask 46 and adder 45 are also used.</p><p>With issuance number calculating section 32 being provided, the issuance instruction number issue<sub>--</sub> count is generated. Instructions of addresses according to the number of issued instructions may be read out from the instruction memory without using the instruction queue. Also when the instruction register is used, a further instruction block may be taken up from the instruction memory after all the instructions stored in the register are issued.</p><h4>EMBODIMENT 3</h4><p>In the above EMBODIMENT 1 and EMBODIMENT 2, a branch instruction is processed in accordance with a delayed branch method, thus achieving a high speed processing. There is a method of branch prediction as one method of processing a branch instruction. According to the method of branch prediction, when a branch instruction exists, its branch direction is previously predicted, and a branch target instruction is executed based on the prediction. According to the branch prediction method, if a prediction is correct, time for fetching a target instruction is saved, and, therefore, deterioration in performance is reduced. Now, a description of a structure in accordance with this branch prediction method follows.</p><p>FIG. 27 schematically shows structures of an instruction fetch stage and an instruction decode stage associated with this third embodiment. In the following description of the third embodiment, four integer arithmetic operation units are considered as function units.</p><p>Instruction queue 9 prefetches instructions from the instruction memory and stores the prefetched instructions. Instruction queue 9 includes a register 14 for holding a read pointer scope, a register 15 for holding a write pointer queue<sub>--</sub> top, and a queue 13 for storing instructions as is the case with the first embodiment. Queue 13 stores, as one entry, an instruction, the address of the instruction (the address in the instruction memory), and a flag br<sub>--</sub> inv (which will be later described) indicating that the instruction is a branch instruction predicted.</p><p>An instruction decoder 66 decodes an instruction read out from instruction queue 9, and analyzes which instruction is issuable as is the case with the foregoing embodiments. The result of analysis is output as a flag indicating the availability of the instruction, an availability flag<sub>--</sub> inst<sub>--</sub> avail onto a signal line 91. In the structure shown in FIG. 27, four instructions are read out from instruction queue 9, and analysis of issuance as to these instructions is conducted in instruction decoder 66. Therefore, four bits of availability flags are provided, and if an instruction is issuable, a corresponding flag id<sub>--</sub> inst<sub>--</sub> avail is turned on in the flag id<sub>--</sub> inst<sub>--</sub> avail of 4 bits.</p><p>Instruction decoder 66 outputs the result of decode of the instruction, in other words an operation code onto a signal line 97 as a code ID<sub>--</sub> code. The operation code ID<sub>--</sub> code and the availability flag inst<sub>--</sub> avail of the instruction always proceed together in the function unit. Hereinafter EXC<sub>--</sub> code designates an operation code exiting in an execution stage EXC, while EXC<sub>--</sub> inst<sub>--</sub> avail represents the availability flag of an instruction in the execution stage EXC. The same designation is employed for a memory access stage MEM. Instruction decoder 66 further controls the values of pointer scope and queue<sub>--</sub> top of registers 14 and 15. The control will be later described.</p><p>In the structure shown in FIG. 27, the four instructions read out from instruction queue at a time are stored in instruction registers 65a-65d, respectively and applied to instruction decoder 66. Instruction registers 65a-65d each include an address storage region, an instruction code storage region, and a region storing a flag br<sub>--</sub> inv.</p><p>Instruction decoder 66 further controls the value of a program counter 12. An access to an instruction cache 61 is conducted in accordance with a pointer PC output from program counter 12, and the four instructions are simultaneously fetched from instruction cache 61.</p><p>Register file 69 is available for storing data and accessible from the instruction decode stage and function units.</p><p>A scoreboard control circuit 100 and a scoreboard circuit 101 are provided for monitoring the states of the registers in register file 69. The operations of the control circuit 100 and scoreboard circuit 101 will later be described in detail.</p><p>Execution of a branch instruction is conducted as follows.</p><p>Now, as an example of a branch instruction is considered: \"when a register R1 indicates 0, a branch is made to an address produced by adding 5 to the address of the branch instruction (this \"5\" is called a branch offset).</p><p>(1) Test of branch conditions;</p><p>In instruction decoder 66, it is tested whether or not the content of register R1 read out from register file 69 is \"0\".</p><p>(2) Branch:</p><p>If the result of the test is \"false\", nothing is conducted. In other words, no branch is taken, and the next instruction to the branch instruction is executed. The result of the test is \"true\", 5 is added to the address of the branch instruction, and the result of the addition is set to the program counter 12 of instruction fetch stage (IF stage) in the next cycle.</p><p>The aforementioned is a general way of executing a branch instruction. Now, a description of execution of a branch instruction according to branch prediction follows. Execution of a branch instruction based on branch prediction is conducted as follows.</p><p>(1) Determination as to whether or not prediction branch is made. The following conditions are considered:</p><p>IR1: R1\u2190R2+R3</p><p>IR2: IF R1==0 then PC\u2190address+5</p><p>IR3: instruction</p><p>IR4: instruction</p><p>The above instruction IR2 is a branch instruction described in the aforementioned example. The value of a register R1 necessary for this branch instruction is not decided until an addition instruction included in the instruction IR1 is complete. In such a case, the instruction IR2 is referred to as having a hazard. Therefore, in a conventional method of executing a branch instruction, the instruction IR2 enters the state of halting until the addition in the instruction IR1 is complete. According to a method of branch prediction, at this point, the branch instruction IR2 is predicted and it is decided that a branch will be taken. In subsequent cycles, instructions fetched based on the branch prediction will be executed.</p><p>In order to indicate execution of an instruction based on this branch prediction, the flag on<sub>--</sub> pred of register 63 is set to be on. Various methods are employed for predicting a branch. For example in the case of a method by means of branch offset, if a branch offset is a positive value, it is predicted that a branch is not taken, while if the branch offset is an negative value, it is predicted that a branch is taken.</p><p>(2) Branch: If a prediction indicates \"a branch is not taken\", nothing is going to happen and the instructions subsequent to the branch instruction are executed. If the prediction indicates \"a branch is taken\", 5 is added to the address of the branch instruction, and the resultant value is set to the program counter 12 of the instruction fetch stage IF in the next cycle.</p><p>(3) Setting of the flag br<sub>--</sub> inv:</p><p>The flag br<sub>--</sub> inv of the entry of instruction queue 9 in which the branch instruction IR2 is stored is set on. This indicates that the branch is under prediction. A branch address register 85 and a flag writing circuit 86 are provided for this purpose. Branch address register 85 stores the address br<sub>--</sub> add of a branch instruction in queue 13. Writing circuit 86 sets on the flag br<sub>--</sub> inv of an address specified by the address br<sub>--</sub> add in queue 13. In queue 13, simultaneous writing and reading of 4 instructions are executed. Therefore, a separate writing path may be provided for turning on or off only the flag br<sub>--</sub> inv of 1 bit. At that time, in writing circuit 86, a structure for making only a corresponding flag be 1 based on the address br<sub>--</sub> add and simultaneously writing the flag br<sub>--</sub> inv of 4 bits may be employed.</p><p>As described above, according to the branch prediction method in the third embodiment, the above mentioned steps (1) to (3) are executed. Now, execution of instructions after execution of a branch prediction will be described. Instructions to be executed after execution of a branch prediction are executed based on prediction, and, therefore, requires several mechanisms.</p><p>(1) Setting of a prediction flag inst<sub>--</sub> pred:</p><p>In order to indicate it is an instruction after a branch instruction subjected to branch prediction, the instruction to be issued to a function unit is provided with a flag inst<sub>--</sub> pred indicating that it is an instruction under branch prediction, and the flag is transmitted from instruction decoder 66 to a signal line 98. The flag inst<sub>--</sub> pred proceeds along with an operation code into the pipeline of the function unit. Instruction decoder 66 sets on a flag ID<sub>--</sub> inst<sub>--</sub> pred for an instruction after a branch instruction, when a flag on<sub>--</sub> pred is on.</p><p>(2) Non-execution of branch prediction instruction:</p><p>A branch instruction which has already undergone branch prediction, even if read out from instruction queue 9 once again and stored in instruction register 65, must not be executed, because its execution has already been completed. Therefore, the branch instruction which has undergone branch prediction is treated as an \"NOP instruction\" in instruction decoder 66. More specifically, the read out instruction with its flag br<sub>--</sub> inv being on is taken as the NOP instruction.</p><p>(3) Components of branch prediction instruction:</p><p>When the hazard of a branch instruction which has already underwent branch prediction has not yet disappeared, and an instruction (of a large address) further subsequent to the branch instruction is issued, the branch instruction is saved so that the direction of branch can later be decided when the hazard of the branch instruction disappears. Therefore, the branch instruction is stored in a control circuit 62 as an instruction br<sub>--</sub> save. Control circuit 62 stores the branch instruction which underwent branch prediction, and also has a function of testing and determining branch as is the case with decoder 66. For example, if a branch instruction indicates that a branch should be taken when the value of a register R5 in register file 69 is 0, control circuit 62 stores the branch instruction as an instruction br<sub>--</sub> save, and observes the data of register R5 in register file 69 and if the value of register R5 is decided, tests the branch instruction using the value of register R5.</p><p>(4) Deciding the direction of branch decided based on prediction and canceling pipeline:</p><p>When the hazard of a branch instruction under branch prediction disappears, a branch direction can be decided. Different controls will be made based on whether or not the branch direction matches the branch taken based on the prediction.</p><p>(a) If the prediction was right:</p><p>In that case, instruction decoder 66 outputs a signal pred<sub>--</sub> hit indicating that the branch prediction was correct. The flag inst<sub>--</sub> pred of each of the pipeline stages of a function unit is turned off.</p><p>(b) When the prediction wasn't right:</p><p>In that case, instruction decoder 66 outputs a signal pred<sub>--</sub> mis indicating that the branch prediction was incorrect to each function unit. In each of pipeline stages of the function unit, an instruction with the flag inst<sub>--</sub> pred being on is invalidated. More specifically, the flag inst<sub>--</sub> avail is turned off. Turning off the flag inst<sub>--</sub> avail inhibits writing by an instruction into the register file in a write back stage WB. Also, in an instruction of storing data into the data memory, storing operation of data into the data memory in this memory access stage is inhibited.</p><p>Summarizing the above process in an logical expression, the availability flag output EXC<sub>--</sub> inst<sub>--</sub> avail<sub>--</sub> out from the execution stage EXC and the branch prediction execution flag output EXC<sub>--</sub> pred<sub>--</sub> inst<sub>--</sub> out from the execution stage EXC are expressed as follows:</p><p>EXC<sub>--</sub> inst<sub>--</sub> avail<sub>--</sub> out=(/EXC<sub>--</sub> inst<sub>--</sub> pred+EXC<sub>--</sub> inst<sub>--</sub> pred*(pred<sub>--</sub> hit+/pred<sub>--</sub> hit*/pred<sub>--</sub> mis))*EXC<sub>--</sub> inst<sub>--</sub> avail,</p><p>EXC<sub>--</sub> inst<sub>--</sub> pred<sub>--</sub> out=EXC<sub>--</sub> inst<sub>--</sub> pred */pred*/pred<sub>--</sub> hit</p><p>FIG. 28 is a logic diagram showing a circuit configuration which implements the above expression. In FIG. 28, a structure for controlling the value of each flag when an instruction is transferred from the execution stage EXC to memory access stage MEM is shown. A block shown by a broken line in this execution stage EXC is similarly used in the memory access stage MEM. In the structure of each circuit, the operation \"+\" in the above logic expression is implemented by an OR circuit, the operation \"*\" is implemented by an AND gate, and the operation \"/\" is implemented by an inverter.</p><p>Instead of the structure shown in FIG. 28, as shown in FIG. 29, a structure may be employed in which the signals pred<sub>--</sub> mis and pred<sub>--</sub> hit are applied commonly to each of the stages, and resetting of a latch circuit in each of the stages (invalidating a flag) is executed.</p><p>The characters LA in FIG. 29 represents a latch circuit for latching a signal applied in response to a clock signal which clocks a pipeline operation.</p><p>When a branch direction is decided, the flag on<sub>--</sub> pred of register 63 (see FIG. 27) is turned off, indicating the completion of execution of the branch prediction.</p><p>In the above description, branch prediction to a usual branch instruction has been considered. Among branch instructions, there exists an instruction which also has the function of a special operation named linkage. Such an instruction is referred to as a jal herein. The jal instruction is described as:</p><p>jal target</p><p>The jal instruction unconditionally sets a branch target address \"target\" to program counter 63 and jumps, and also writes the address of itself in a specified register.</p><p>The jal instruction is provided with a function of rewriting the content of a register, besides the function of taking a branch which has been described. In the case of branch prediction, an instruction itself is executed even if instructions preceding to the instruction can not be issued. If the jal instruction conducts a similar operation, rewriting of the content of a register is executed, because execution of the preceding instructions is not complete. Such replacing the order of rewriting into the register makes interruption processing extremely difficult. Therefore, in the case of the jal instruction, only rewriting of the value of the pointer PC of program counter 62 is executed in branch prediction execution. An operation of linkage is to be issued when all the instructions preceding to the instruction jal are issued. More specifically, the jal instruction can take a branch based on a branch prediction, but linkage is not conducted at the time of the branch execution. The jal instruction with the flag br<sub>--</sub> inv being on does not take a branch, but issues the operation of linkage when a hazard disappears with all the preceding instructions having been issued.</p><p>A description of scoreboarding for implementing this method of branch prediction follows. Consider the order of instructions as follows:</p><p>IR1: R1\u2190M (R2)</p><p>IR2: R3\u2190R1+R4</p><p>The instruction IR1 accesses the data memory using the content of register R2 as an address, and stores the data of the accessed data memory into register R1. The instruction IR2 adds up the contents of register R1 and register R4, and writes the result of addition into register R3. The second instruction IR2 uses the result R1 of the first instruction IR1. Therefore, the second instruction IR2 can not be issued until reading operation of the data memory by the first instruction IR1 is complete. Therefore, a mechanism for indicating that the content of instruction register R1 is not decided and making such a control to inhibit other instructions from using incorrectly register R1 will be necessary.</p><p>If register file 69 is formed of 32 words, a flag is provided to each word. When the flag is on, it indicates that the content of a corresponding register is not decided. This flag is called a scoreboard. The scoreboard is expressed as RF<sub>--</sub> lkf&lt;31:0&gt;.</p><p>In the case of the above-stated instructions IR1 and IR2, the first instruction IR1 is to rewrite the content of register R1 when being issued. At that time, a 1 bit flag RE<sub>--</sub> lkf&lt;1&gt; is set on. If data is read out from the data memory, the flag RF<sub>--</sub> lkf&lt;1&gt; is turned off.</p><p>In addition to the flag RF<sub>--</sub> lkf, further provided in the present embodiment is a flag RF<sub>--</sub> lkf<sub>--</sub> pred&lt;31:0&gt; indicating that the instruction which has turned on the flag of the scoreboard corresponding to each of the registers is an instruction undergoing branch prediction.</p><p>An instruction for making a control for waiting the content of register to be decided using the scoreboard (designated by the reference numeral 101 in FIG. 27) is assumed to be herein only a \"load memory\" accessing the data memory. In this case, in scoreboard circuit 101, the bits of the flag RF<sub>--</sub> lkf corresponding to the write register are turned on when a load instruction is issued. If issuance of the load instruction is an execution after a branch prediction (the flag on<sub>--</sub> pred is on), the flag RF<sub>--</sub> lkf<sub>--</sub> pred corresponding to the register to be written is turned on.</p><p>When the branch prediction turns out to be incorrect, the flag RF<sub>--</sub> lkf<sub>--</sub> pred turns off the flag RF<sub>--</sub> lkf corresponding to the on bit. Furthermore, the flag RF<sub>--</sub> lkf<sub>--</sub> pred for each register is turned off.</p><p>A description of a logic circuit of a scoreboard control circuit 101 for controlling the scoreboard follows. Instruction decoder 66 turns on a signal issue<sub>--</sub> load when it issues a load instruction. The memory access stage MEM of a load/store unit turns on a signal MEM<sub>--</sub> load complete when it can read data from a data cache (data memory). Each of the bits of the scoreboard RF<sub>--</sub> lkf is provided with a write enable signal RF<sub>--</sub> lkf<sub>--</sub> we&lt;31:0&gt;. Writing into a register takes place only when the write enable signal is on. Similarly, the write enable signal RF<sub>--</sub> lkf<sub>--</sub> pred<sub>--</sub> we&lt;31:0&gt; is provided to the flag RF<sub>--</sub> lkf<sub>--</sub> pred. Furthermore, when the signal RF<sub>--</sub> lkf<sub>--</sub> pred<sub>--</sub> reset is turned on, all the flags of scoreboard RF<sub>--</sub> lkf<sub>--</sub> pred for prediction are turned on.</p><p>In the above described logic, control of the scoreboard RF<sub>--</sub> lkf and RF<sub>--</sub> lkf<sub>--</sub> pred can be expressed by a truth table shown in FIG. 30. Expressing the truth table shown in FIG. 3 in a logic circuit provides a circuit configuration shown in FIG. 31. In the configuration shown in FIG. 31, only a control portion corresponding to one register file is shown by way of illustration. A decoder 14 decodes a write register signal (5 bits) and selects one of output signal lines (32 output signal lines all together provided corresponding to write registers). The logical product of the output of decoder 140 and the signal issue<sub>--</sub> load is produced. Data is written into registers 141 and 142, in response to write enable signals RF<sub>--</sub> lkf<sub>--</sub> we&lt;i&gt; and RF<sub>--</sub> lkf<sub>--</sub> pred<sub>--</sub> we&lt;i&gt;, respectively. The outputs of registers 141 and 142 are transferred to instruction decoder 166.</p><p>A functional structure of instruction decoder 66 is shown in FIG. 32. In FIG. 32, an instruction decode circuit 160 decodes four instructions, instructions #1-#4, and issues an operation code ID<sub>--</sub> code. An issuance analysis section 161 receives these instructions #1-#4 and a flag br<sub>--</sub> inv, analyzes whether or not the instructions are issuable and issues an issuability flag ID<sub>--</sub> inst<sub>--</sub> avail.</p><p>A branch processing section 164 receives the instructions #1-#4, detects a branch instruction, and executes the branch instruction. If the branch instruction can not be executed in the cycle, branch processing section 164 issues a flag pr<sub>--</sub> ex indicating that a branch prediction is going on. Branch processing section 164 also generates signals Taken and Not Taken respectively showing the presence and absence of a branch when execution of the branch instruction is completed.</p><p>A register 163 receives the signal pr<sub>--</sub> ex from branch processing section 164, and stores the same as a flag on<sub>--</sub> pred.</p><p>A prediction flag generation circuit 162 receives the flag br<sub>--</sub> inv, the signals Taken and Not Taken, and the flag on<sub>--</sub> pred from branch processing section 164, and generates a prediction flag ID<sub>--</sub> inst<sub>--</sub> pred. The signals Taken and Not Taken from branch processing section 164 are applied to issuance analysis section 161. The operation of each of the circuits is the same as the one in the aforementioned signal generation method, and the description will not be repeated.</p><p>Although in the above embodiment, the number of instructions to be fetched at the time is 4, and the number of instructions to be analyzed at a time is four, the number of instruction is not limited to 4, and may be other numbers.</p><h4>POST SUMMARY</h4><p>The feature of the first aspect of the present invention will be summarized as follows.</p><p>(1) Among a plurality of instructions including a branch instruction, instructions from an instruction one address after the branch instruction to an instruction fetched last in the cycles necessary for the branch instruction to be fetched and executed constitute a branch delay slot.</p><p>(2) The branch delay slot is filled with instructions from an instruction of a branch target address to be executed when a branch is taken due to a branch instruction associated with the branch delay slot to an instruction one address before a branch instruction to be executed next.</p><p>(3) In the cycle in which instructions are prefetched from an instruction memory and stored in a queue memory, and a branch instruction is executed, it is determined whether or not the branch delay slot of the branch instruction has already been stored in the queue memory, and based on the result of the determination, the write addresses and read addresses of the queue memory, and information on whether or not a branch is taken obtained from the result of the execution of the branch instruction, the write addresses and read addresses of the queue memory are controlled.</p><p>(4) When a branch instruction is executed, and it is decided that a branch is taken as a result, if all of the instructions in the branch delay slot of the branch instruction have not yet been stored in the queue memory, the write address of the queue is set to be an address produced by adding the number of fetched instruction to the present value.</p><p>(5) When a branch instruction is executed and it is decided that a branch is taken as a result, if all the instructions of the branch delay slot of the branch instruction have been stored in the queue memory, the write address of the queue memory is set to be an address next to the queue address in which the instruction of the last address of the branch delay slot is stored.</p><p>(6) When a branch instruction is executed and it is decided that a branch is taken as a result, the read address of the queue memory is increased by the number of instructions issued to function units.</p><p>(7) When a branch instruction is executed, and it is decided that a branch is not taken as a result, issuance of an instruction after the branch instruction which is to be issued to the function unit is stopped.</p><p>(8) When a branch instruction is executed, and it is decided that a branch is not taken as a result, the read address of the queue memory is set to be an address next to the address of the queue memory in which the instruction of the last address of the branch delay slot is stored or is to be stored.</p><p>(9) When a branch instruction is executed and it is decided that a branch is not taken as a result, if all the instructions of the branch delay slot of the branch instruction have not yet stored in the queue memory, issuance of an instruction is stopped until all the instructions of the branch delay slot are stored.</p><p>The feature of the second aspect of the present invention is as follows.</p><p>(1) A plurality of instructions are prefetched from an instruction memory, and a queue memory for storing the prefetched instructions is provided. The queue memory includes a plurality of entries, in each of which one instruction is stored. The entry includes a field indicating that the stored instruction has already been executed based on a branch prediction.</p><p>(2) Based on the value of the field indicating the execution based on the prediction, control is made so that the instruction stored in the corresponding entry will not be executed.</p><p>(3) An instruction by which storing of a return address into the register of a register file and branching are simultaneously conducted is executed based on a branch prediction, only the branching is conducted, and the storing of the return address into the register will be executed when the instruction becomes executable.</p><p>(4) Instructions each in a function unit (a pipeline) have a first flag (inst<sub>--</sub> pred) indicating that the instruction is issued in a period before it is decided whether the prediction is correct or not after conducting a branch prediction, and a second flag (inst<sub>--</sub> avail) indicating that the instruction is available. If the branch prediction turns out to be correct, the first flag (inst<sub>--</sub> pred) is turned off, while if the prediction turns out to be incorrect, the second flag of an instruction with the first flag being on is turned off, and the first flag is turned off.</p><p>(5) A register file (a general purpose register) is provided with a third flag (RF<sub>--</sub> lkf) indicating that writing is to take place to the register, and a fourth flag (RF<sub>--</sub> lkf<sub>--</sub> pred) indicating the instruction which controls the flag is issued in the period after a branch prediction and before it is decided whether the prediction is correct or not. If the prediction is correct, the fourth flags of all the general purpose registers are reset. When the prediction turns out to be incorrect, the third flag of a register whose fourth flag is on is turned off.</p><p>According to the present invention, with a delayed branch slot associated with a branch instruction being filled with instructions on the side of branching, deterioration in performance due to execution of the branch instruction can be prevented regardless whether a branch is taken or not.</p><p>Furthermore, instructions are prefetched from an instruction memory and stored in a queue memory, a write pointer and a read pointer to queue when a branch instruction is executed are always controlled in such a manner that no empty stage is created in a pipeline, and deterioration in performance due to execution of the branch instruction can efficiently and surely prevented.</p><p>Furthermore, in a structure in which instructions are not prefetched, when a branch is taken by a branch instruction, filling a branch delay slot with branch target side instructions prevents deterioration in performance by the branch instruction.</p><p>According to the present invention, a branch instruction is executed based on a branch prediction before a hazard disappears. Therefore, in the case of branching, the cycle waiting for a branch target instruction to arrive from an instruction cache which is conventionally necessary will be unnecessary, a target instruction is previously fetched based on a prediction, the cycle for waiting for the target instruction to arrive from the instruction cache will not be necessary, whereby no empty stages are created in a pipeline. Thus, deterioration in performance of a parallel processing unit due to a branch instruction can be prevented.</p><p>Although the present invention has been described and illustrated in detail, it is clearly understood that the same is by way of illustration and example only and is not to be taken by way of limitation, the spirit and scope of the present invention being limited only by the terms of the appended claims.</p><?DETDESC description=\"Detailed Description\" end=\"tail\"?></description>"}], "inventors": [{"first_name": "Hideki", "last_name": "Ando", "name": ""}], "assignees": [{"first_name": "", "last_name": "", "name": "MITSUBISHI DENKI KABUSHIKI KAISHA"}], "ipc_classes": [{"primary": true, "label": "G06F   9/38"}], "locarno_classes": [], "ipcr_classes": [{"label": "G06F   9/38        20060101A I20051008RMEP"}], "national_classes": [{"primary": true, "label": "712233"}, {"primary": false, "label": "712234"}, {"primary": false, "label": "712239"}, {"primary": false, "label": "712237"}, {"primary": false, "label": "712E0905"}, {"primary": false, "label": "712E09056"}, {"primary": false, "label": "712235"}], "ecla_classes": [{"label": "G06F   9/30A5"}, {"label": "G06F   9/38B2"}, {"label": "G06F   9/38E2"}], "cpc_classes": [{"label": "G06F   9/3842"}, {"label": "G06F   9/30072"}, {"label": "G06F   9/3804"}, {"label": "G06F   9/3859"}, {"label": "G06F   9/3842"}, {"label": "G06F   9/3804"}, {"label": "G06F   9/30072"}, {"label": "G06F   9/3859"}], "f_term_classes": [], "legal_status": "Expired - Fee Related", "priority_date": "1991-07-12", "application_date": "1996-01-30", "family_members": [{"ucid": "JP-H0520067-A", "titles": [{"lang": "JA", "text": "\u4e26\u5217\u6f14\u7b97\u51e6\u7406\u88c5\u7f6e\u306b\u304a\u3051\u308b\u5206\u5c90\u547d\u4ee4\u51e6\u7406\u65b9\u5f0f"}, {"lang": "EN", "text": "BRANCH INSTRUCTION PROCESSING SYSTEM FOR PARALLEL ARITHMETIC PROCESSOR"}]}, {"ucid": "US-5809294-A", "titles": [{"lang": "EN", "text": "Parallel processing unit which processes branch instructions without decreased performance when a branch is taken"}]}, {"ucid": "JP-2875909-B2", "titles": [{"lang": "JA", "text": "\u4e26\u5217\u6f14\u7b97\u51e6\u7406\u88c5\u7f6e"}, {"lang": "EN", "text": "Parallel processing unit"}]}, {"ucid": "DE-4222776-A1", "titles": [{"lang": "EN", "text": "Parallel processor with branching delay slot for instructions - has queuing memory connected to instruction output analyser and branching processor circuits with flag control section"}, {"lang": "DE", "text": "VERFAHREN UND ANORDNUNG FUER EINE VERZWEIGUNGSBEFEHLSVERARBEITUNG IN EINER PARALLELVERARBEITUNGSEINHEIT"}]}, {"ucid": "DE-4222776-C2", "titles": [{"lang": "EN", "text": "Parallel processing unit and method for executing instructions"}, {"lang": "DE", "text": "Parallelverarbeitungseinheit und Verfahren zum Ausf\u00fchren von Befehlen"}]}]}